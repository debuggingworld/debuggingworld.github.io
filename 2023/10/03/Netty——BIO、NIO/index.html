

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">
  <link rel="apple-touch-icon" sizes="76x76" href="https://debugging.oss-cn-hangzhou.aliyuncs.com/debugIcon.jpg">
  <link rel="icon" href="https://debugging.oss-cn-hangzhou.aliyuncs.com/debugIcon.jpg">
  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="debuggingWorld">
  <meta name="keywords" content="">
  
    <meta name="description" content="1. BIO 在 BIO 中 ServerSocket 类负责绑定 IP 地址，启动监听端口，等待客户连接；客户端 Socket 类的实例发起连接操作，ServerSocket 接受连接后产生一个新的服务端 socket 实例负责和客户端 socket 实例通过输入和输出流进行通信。    123456789101112131415161718192021222324252627282930313">
<meta property="og:type" content="article">
<meta property="og:title" content="Netty——BIO、NIO">
<meta property="og:url" content="http://example.com/2023/10/03/Netty%E2%80%94%E2%80%94BIO%E3%80%81NIO/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="1. BIO 在 BIO 中 ServerSocket 类负责绑定 IP 地址，启动监听端口，等待客户连接；客户端 Socket 类的实例发起连接操作，ServerSocket 接受连接后产生一个新的服务端 socket 实例负责和客户端 socket 实例通过输入和输出流进行通信。    123456789101112131415161718192021222324252627282930313">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310031809953.png">
<meta property="og:image" content="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042006610.png">
<meta property="og:image" content="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042014630.png">
<meta property="og:image" content="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042023285.png">
<meta property="article:published_time" content="2023-10-03T08:50:16.000Z">
<meta property="article:modified_time" content="2025-09-01T02:21:27.785Z">
<meta property="article:author" content="debuggingWorld">
<meta property="article:tag" content="Netty">
<meta name="twitter:card" content="summary_large_image">
<meta name="twitter:image" content="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310031809953.png">
  
  
    <meta name="referrer" content="no-referrer-when-downgrade">
  
  
  <title>Netty——BIO、NIO - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/font_1749284_hj8rtnfg7um.css">



<link rel="stylesheet" href="//at.alicdn.com/t/font_1736178_kmeydafke9r.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  



  
<link rel="stylesheet" href="/css/iconfont.css">



  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.0","typing":{"enable":true,"typeSpeed":90,"cursorChar":"<img src=\"https://debugging.oss-cn-hangzhou.aliyuncs.com/喜爱.png\" height=\"35\" width=\"35\" />","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"right","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":false,"follow_dnt":true,"baidu":null,"google":null,"gtag":null,"tencent":{"sid":null,"cid":null},"woyaola":null,"cnzz":null,"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false}},"search_path":"/local-search.xml"};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>

  
<meta name="generator" content="Hexo 5.4.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>猫和少年</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/">
                <i class="iconfont icon-home-fill"></i>
                首页
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/">
                <i class="iconfont icon-archive-fill"></i>
                归档
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/">
                <i class="iconfont icon-category-fill"></i>
                分类
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/">
                <i class="iconfont icon-tags-fill"></i>
                标签
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/links/">
                <i class="iconfont icon-link-fill"></i>
                友链
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/">
                <i class="iconfont icon-user-fill"></i>
                关于
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              &nbsp;<i class="iconfont icon-search"></i>&nbsp;
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">&nbsp;<i
                class="iconfont icon-dark" id="color-toggle-icon"></i>&nbsp;</a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('https://debugging.oss-cn-hangzhou.aliyuncs.com/art_bg.jpg') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="Netty——BIO、NIO"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2023-10-03 16:50" pubdate>
          2023年10月3日 下午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          <!-- compatible with older versions-->
          25k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          <!-- compatible with older versions-->
          78 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <!-- SEO header -->
            <h1 style="display: none">Netty——BIO、NIO</h1>
            
            <div class="markdown-body">
              
              <h3 id="bio">1. BIO</h3>
<p>在 BIO 中 ServerSocket 类负责绑定 IP
地址，启动监听端口，等待客户连接；客户端 Socket
类的实例发起连接操作，ServerSocket 接受连接后产生一个新的服务端 socket
实例负责和客户端 socket 实例通过输入和输出流进行通信。</p>
<center>
<img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310031809953.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />
</center>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerSingle</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket();<br>        serverSocket.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8888</span>));<br>        System.out.println(<span class="hljs-string">&quot;Start Server ....&quot;</span>);<br>        <span class="hljs-keyword">int</span> connectCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                Socket socket = serverSocket.accept();<br>                System.out.println(<span class="hljs-string">&quot;accept client socket ....total =&quot;</span> + (++connectCount));<br>                <span class="hljs-keyword">try</span> (ObjectInputStream inputStream = <span class="hljs-keyword">new</span> ObjectInputStream(socket.getInputStream());<br>                     ObjectOutputStream outputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(socket.getOutputStream())) &#123;<br><br>                    String input = inputStream.readUTF();<br>                    System.out.println(<span class="hljs-string">&quot;Accept client message:&quot;</span> + input);<br>                    outputStream.writeUTF(<span class="hljs-string">&quot;Hello,&quot;</span> + input);<br>                    outputStream.flush();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        socket.close();<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            serverSocket.close();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>
<p><strong>客户端：</strong></p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Socket socket = <span class="hljs-keyword">null</span>;<br>        ObjectOutputStream output = <span class="hljs-keyword">null</span>;<br>        ObjectInputStream input = <span class="hljs-keyword">null</span>;<br>        InetSocketAddress addr = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8888</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            socket = <span class="hljs-keyword">new</span> Socket();<br>            socket.connect(addr);<br>            System.out.println(<span class="hljs-string">&quot;Connect Server success!!&quot;</span>);<br>            output = <span class="hljs-keyword">new</span> ObjectOutputStream(socket.getOutputStream());<br>            input = <span class="hljs-keyword">new</span> ObjectInputStream(socket.getInputStream());<br>            System.out.println(<span class="hljs-string">&quot;Ready send message.....&quot;</span>);<br>            <br>            output.writeUTF(<span class="hljs-string">&quot;debug&quot;</span>);<br>            output.flush();<br>            System.out.println(input.readUTF());<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (socket != <span class="hljs-keyword">null</span>) socket.close();<br>            <span class="hljs-keyword">if</span> (output != <span class="hljs-keyword">null</span>) output.close();<br>            <span class="hljs-keyword">if</span> (input != <span class="hljs-keyword">null</span>) input.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>BIO 的阻塞，主要体现在两个地方：</p>
<ol type="1">
<li>若一个服务器启动就绪，那么主线程就一直在等待着客户端的连接，这个等待过程中主线程就一直在阻塞。</li>
<li>在连接建立之后，在读取到 socket
信息之前，线程也是一直在等待，一直处于阻塞的状态下的。</li>
</ol>
<p>所以在 BIO
通信里，我们往往会在服务器的实现上结合线程来处理连接以及和客户端的通信。</p>
<p>传统 BIO 通信模型：采用 BIO 通信模型的服务端，通常由一个独立的
Acceptor
线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成后，通过输出流返回应答给客户端，线程销毁。即典型的一请求一应答模型，同时数据的读取写入也必须阻塞在一个线程内等待其完成。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket();<br>        serverSocket.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8888</span>));<br>        System.out.println(<span class="hljs-string">&quot;Start Server ....&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> ServerTask(serverSocket.accept())).start();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            serverSocket.close();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> Socket socket = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServerTask</span><span class="hljs-params">(Socket socket)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.socket = socket;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> (ObjectInputStream inputStream = <span class="hljs-keyword">new</span> ObjectInputStream(socket.getInputStream());<br>                 ObjectOutputStream outputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(socket.getOutputStream())) &#123;<br><br>                String input = inputStream.readUTF();<br>                System.out.println(<span class="hljs-string">&quot;Accept client message:&quot;</span> + input);<br>                outputStream.writeUTF(<span class="hljs-string">&quot;Hello,&quot;</span> + input);<br>                outputStream.flush();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    socket.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈1:1的正比关系，Java中的线程也是比较宝贵的系统资源，线程数量快速膨胀后，系统的性能将急剧下降，随着访问量的继续增大，系统最终就<strong>死-掉-了</strong>。</p>
<p>为了改进这种一连接一线程的模型，我们可以使用线程池来管理这些线程，实现1个或多个线程处理N个客户端的模型（但是底层还是使用的同步阻塞I/O），通常被称为“伪异步I/O模型“。</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerPool</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket();<br>        serverSocket.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8888</span>));<br>        System.out.println(<span class="hljs-string">&quot;Start Server ....&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                executorService.execute(<span class="hljs-keyword">new</span> ServerTask(serverSocket.accept()));<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            serverSocket.close();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> Socket socket = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServerTask</span><span class="hljs-params">(Socket socket)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.socket = socket;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> (ObjectInputStream inputStream = <span class="hljs-keyword">new</span> ObjectInputStream(socket.getInputStream());<br>                 ObjectOutputStream outputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(socket.getOutputStream())) &#123;<br><br>                String input = inputStream.readUTF();<br>                System.out.println(<span class="hljs-string">&quot;Accept client message:&quot;</span> + input);<br>                outputStream.writeUTF(<span class="hljs-string">&quot;Hello,&quot;</span> + input);<br>                outputStream.flush();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    socket.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>如果使用 CachedThreadPool
线程池，其实除了能自动帮我们管理线程（复用），看起来也就像是1:1的客户端：线程数模型，而使用FixedThreadPool
我们就有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N:M的伪异步
I/O 模型。</p>
<h3 id="nio">2.NIO</h3>
<p>NIO 库是在 JDK 1.4 中引入的。NIO 弥补了原来的 BIO 的不足，它在标准
Java 代码中提供了高速的、面向块的 I/O。</p>
<h4 id="和-bio-的主要区别">2.1 和 BIO 的主要区别</h4>
<p><strong>面向流与面向缓冲</strong></p>
<p>Java NIO 和 IO 之间第一个最大的区别是，IO 是面向流的，NIO
是面向缓冲区的。 Java IO
面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。
Java NIO
的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p>
<p><strong>阻塞与非阻塞 IO</strong></p>
<p>Java IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()
时，该线程被阻塞，直到有一些数据被读取或完全写入。该线程在此期间不能再干任何事情了。</p>
<p>Java NIO
的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。
非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。
线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO
操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p>
<h4 id="nio-三大核心组件">2.2 NIO 三大核心组件</h4>
<p>NIO 三大核心组件：Selector 选择器、Channel 管道、buffer 缓冲区。</p>
<p><strong>Selector</strong></p>
<p>Java NIO
的选择器允许一个单独的线程来监视多个输入通道，可以注册多个通道使用一个选择器(Selectors)，然后使用一个单独的线程来操作这个选择器，进而“选择”通道：通道里已经有可以处理的输入，或者选择已准备写入的通道。</p>
<p>应用程序将向 Selector 对象注册需要它关注的 Channel，以及具体的某一个
Channel 会对哪些 IO 事件感兴趣。Selector 中也会维护一个“已经注册的
Channel ”的容器。</p>
<p><strong>Channels</strong></p>
<p>通道，被建立的一个应用程序和操作系统交互事件、传递内容的渠道（注意是连接到操作系统）。那么既然是和操作系统进行内容的传递，那么说明应用程序可以通过通道读取数据，也可以通过通道向操作系统写数据，而且可以同时进行读写。</p>
<ul>
<li>所有被 Selector（选择器）注册的通道，只能是继承了 SelectableChannel
类的子类。</li>
<li>ServerSocketChannel：应用服务器程序的监听通道。只有通过这个通道，应用程序才能向操作系统注册支持“多路复用
IO”的端口监听。同时支持 UDP 协议和 TCP 协议。</li>
<li>ScoketChannel：TCP Socket 套接字的监听通道，一个 Socket
套接字对应了一个客户端IP:端口 到 服务器IP:端口 的通信连接。</li>
</ul>
<p>通道中的数据总是要先读到一个 Buffer，或者总是要从一个 Buffer
中写入。</p>
<p><strong>buffer 缓冲区</strong></p>
<p>JDK NIO 是面向缓冲的。Buffer 就是这个缓冲，用于和 NIO
通道进行交互。数据是从通道读入缓冲区，从缓冲区写入到通道中的。以写为例，应用程序都是将数据写入缓冲，再通过通道把缓冲的数据发送出去，读也是一样，数据总是先从通道读到缓冲，应用程序再读缓冲的数据。</p>
<p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存（其实就是数组）。这块内存被包装成
NIO Buffer 对象，并提供了一组方法，用来方便的访问该块内存。</p>
<p><img
src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310032157431.png" srcset="/img/loading.gif" lazyload /></p>
<h4 id="示例">2.3 示例</h4>
<p><strong>服务端：</strong></p>
<p>NioServer</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioServerHandle nioServerHandle = <span class="hljs-keyword">new</span> NioServerHandle(DEFAULT_PORT);<br>        <span class="hljs-keyword">new</span> Thread(nioServerHandle, <span class="hljs-string">&quot;Server&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>NioServerHandle</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioServerHandle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> started;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> port 指定要监听的端口号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioServerHandle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">/*创建选择器的实例*/</span><br>            selector = Selector.open();<br>            <span class="hljs-comment">/*创建ServerSocketChannel的实例*/</span><br>            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<br>            <span class="hljs-comment">/*设置通道为非阻塞模式*/</span><br>            serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">/*绑定端口*/</span><br>            serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> InetSocketAddress(port));<br>            <span class="hljs-comment">/*注册事件，表示关心客户端连接*/</span><br>            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<br><br>            started = <span class="hljs-keyword">true</span>;<br>            System.out.println(<span class="hljs-string">&quot;服务器已启动，端口号：&quot;</span> + port);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (started) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">/*获取当前有哪些事件*/</span><br>                selector.select(<span class="hljs-number">1000</span>);<br>                <span class="hljs-comment">/*获取事件的集合*/</span><br>                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br>                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                    SelectionKey key = iterator.next();<br>                    <span class="hljs-comment">/*我们必须首先将处理过的 SelectionKey 从选定的键集合中删除。</span><br><span class="hljs-comment">                    如果我们没有删除处理过的键，那么它仍然会在主集合中以一个激活</span><br><span class="hljs-comment">                    的键出现，这会导致我们尝试再次处理它。*/</span><br>                    iterator.remove();<br>                    handleInput(key);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*处理事件的发生*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleInput</span><span class="hljs-params">(SelectionKey selectionKey)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (selectionKey.isValid()) &#123;<br>            <span class="hljs-comment">/*处理新接入的客户端的请求*/</span><br>            <span class="hljs-keyword">if</span> (selectionKey.isAcceptable()) &#123;<br>                <span class="hljs-comment">/*获取关心当前事件的Channel*/</span><br>                ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.channel();<br>                <span class="hljs-comment">/*接受连接*/</span><br>                SocketChannel socketChannel = serverSocketChannel.accept();<br>                System.out.println(<span class="hljs-string">&quot;==========建立连接=========&quot;</span>);<br>                socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>                <span class="hljs-comment">/*关注读事件*/</span><br>                socketChannel.register(selector, SelectionKey.OP_READ);<br>            &#125;<br>            <span class="hljs-comment">/*处理对端的发送的数据*/</span><br>            <span class="hljs-keyword">if</span> (selectionKey.isReadable()) &#123;<br>                SocketChannel socketChannel = (SocketChannel) selectionKey.channel();<br>                <span class="hljs-comment">/*创建ByteBuffer，开辟一个缓冲区*/</span><br>                ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                <span class="hljs-comment">/*从通道里读取数据，然后写入buffer*/</span><br>                <span class="hljs-keyword">int</span> readBytes = socketChannel.read(buffer);<br>                <span class="hljs-keyword">if</span> (readBytes &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">/*将缓冲区当前的limit设置为position,position=0，</span><br><span class="hljs-comment">                    用于后续对缓冲区的读取操作*/</span><br>                    buffer.flip();<br>                    <span class="hljs-comment">/*根据缓冲区可读字节数创建字节数组*/</span><br>                    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buffer.remaining()];<br>                    <span class="hljs-comment">/*将缓冲区可读字节数组复制到新建的数组中*/</span><br>                    buffer.get(bytes);<br>                    String message = <span class="hljs-keyword">new</span> String(bytes, StandardCharsets.UTF_8);<br>                    System.out.println(<span class="hljs-string">&quot;服务器收到消息：&quot;</span> + message);<br>                    <span class="hljs-comment">/*处理数据*/</span><br>                    String result = Const.response(message);<br>                    <span class="hljs-comment">/*发送应答消息*/</span><br>                    doWrite(socketChannel, result);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readBytes &lt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">/*取消特定的注册关系*/</span><br>                    selectionKey.cancel();<br>                    <span class="hljs-comment">/*关闭通道*/</span><br>                    socketChannel.close();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*发送应答消息*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(SocketChannel sc, String response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] bytes = response.getBytes();<br>        ByteBuffer buffer = ByteBuffer.allocate(bytes.length);<br>        buffer.put(bytes);<br>        buffer.flip();<br>        sc.write(buffer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        started = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p><strong>客户端：</strong></p>
<p>NioClient</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioClient</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> NioClientHandle nioClientHandle;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        nioClientHandle = <span class="hljs-keyword">new</span> NioClientHandle(DEFAULT_SERVER_IP, DEFAULT_PORT);<br>        <span class="hljs-keyword">new</span> Thread(nioClientHandle, <span class="hljs-string">&quot;client&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-comment">//向服务器发送消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        nioClientHandle.sendMsg(msg);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        start();<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">while</span> (NioClient.sendMsg(scanner.next())) ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<p>NioClientHandle</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioClientHandle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String host;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;<br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> SocketChannel socketChannel;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> started;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioClientHandle</span><span class="hljs-params">(String ip, <span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.host = ip;<br>        <span class="hljs-keyword">this</span>.port = port;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">/*创建选择器的实例*/</span><br>            selector = Selector.open();<br>            <span class="hljs-comment">/*创建SocketChannel的实例*/</span><br>            socketChannel = SocketChannel.open();<br>            <span class="hljs-comment">/*设置通道为非阻塞模式*/</span><br>            socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>            started = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            doConnect();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            System.exit(<span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//循环遍历selector</span><br>        <span class="hljs-keyword">while</span> (started) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//无论是否有读写事件发生，selector每隔1s被唤醒一次</span><br>                selector.select(<span class="hljs-number">1000</span>);<br>                <span class="hljs-comment">//获取当前有哪些事件可以使用</span><br>                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>                Iterator&lt;SelectionKey&gt; selectionKeyIterator = keys.iterator();<br>                SelectionKey selectionKey;<br>                <span class="hljs-keyword">while</span> (selectionKeyIterator.hasNext()) &#123;<br>                    selectionKey = selectionKeyIterator.next();<br>                    selectionKeyIterator.remove();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        handleInput(selectionKey);<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        <span class="hljs-keyword">if</span> (selectionKey != <span class="hljs-keyword">null</span>) &#123;<br>                            selectionKey.cancel();<br>                            <span class="hljs-keyword">if</span> (selectionKey.channel() != <span class="hljs-keyword">null</span>) &#123;<br>                                selectionKey.channel().close();<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>                System.exit(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//selector关闭后会自动释放里面管理的资源</span><br>        <span class="hljs-keyword">if</span> (selector != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">try</span> &#123;<br>                selector.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//具体的事件处理方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleInput</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (!key.isValid()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//获得关心当前事件的channel</span><br>        SocketChannel socketChannel = (SocketChannel) key.channel();<br>        <span class="hljs-comment">//连接事件</span><br>        <span class="hljs-keyword">if</span> (key.isConnectable()) &#123;<br>            <span class="hljs-keyword">if</span> (socketChannel.finishConnect()) &#123;<br>                <span class="hljs-keyword">this</span>.socketChannel.register(selector, SelectionKey.OP_READ);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.exit(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//有数据可读事件</span><br>        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            <span class="hljs-keyword">int</span> readBytes = socketChannel.read(buffer);<br>            <span class="hljs-keyword">if</span> (readBytes &gt; <span class="hljs-number">0</span>) &#123;<br>                buffer.flip();<br>                <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buffer.remaining()];<br>                buffer.get(bytes);<br>                String result = <span class="hljs-keyword">new</span> String(bytes, StandardCharsets.UTF_8);<br>                System.out.println(<span class="hljs-string">&quot;客户端收到消息：&quot;</span> + result);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readBytes &lt; <span class="hljs-number">0</span>) &#123;<br>                key.cancel();<br>                socketChannel.close();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(SocketChannel channel, String request)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] bytes = request.getBytes();<br>        ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);<br>        writeBuffer.put(bytes);<br>        writeBuffer.flip();<br>        <span class="hljs-comment">/*关心事件和读写网络并不冲突*/</span><br>        channel.write(writeBuffer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doConnect</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">/*非阻塞的连接*/</span><br>        <span class="hljs-keyword">if</span> (socketChannel.connect(<span class="hljs-keyword">new</span> InetSocketAddress(host, port))) &#123;<br>            socketChannel.register(selector, SelectionKey.OP_READ);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            socketChannel.register(selector, SelectionKey.OP_CONNECT);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//写数据对外暴露的API</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        doWrite(socketChannel, msg);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        started = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>
<h4 id="selectionkey">2.4 SelectionKey</h4>
<p>SelectionKey 是一个抽象类，表示 selectableChannel 在 Selector
中注册的标识。每个 Channel 向 Selector 注册时，都将会创建一个
SelectionKey。SelectionKey 将 Channel 与 Selector 建立了关系，并维护了
channel 事件。</p>
<p>可以通过 cancel 方法取消键，取消的键不会立即从 selector
中移除，而是添加到 cancelledKeys 中,在下一次 select
操作时移除它。所以在调用某个 key 时，需要使用 isValid 进行校验。</p>
<p><strong>SelectionKey 类型和就绪条件：</strong></p>
<p>在向 Selector 对象注册感兴趣的事件时，JAVA NIO
共定义了四种：OP_READ、OP_WRITE、OP_CONNECT、OP_ACCEPT（定义在
SelectionKey 中），分别对应读、写、请求连接、接受连接等网络 Socket
操作。</p>
<table>

<thead>
<tr>
<th><strong>操作类型</strong></th>
<th><strong>就绪条件及说明</strong></th>
</tr>
</thead>
<tbody>
<tr>
<td>OP_READ</td>
<td>当操作系统读缓冲区有数据可读时就绪。并非时刻都有数据可读，所以一般需要注册该操作，仅当有就绪时才发起读操作，有的放矢，避免浪费CPU。</td>
</tr>
<tr>
<td>OP_WRITE</td>
<td>当操作系统写缓冲区有空闲空间时就绪。一般情况下写缓冲区都有空闲空间，小块数据直接写入即可，没必要注册该操作类型，否则该条件不断就绪浪费CPU；但如果是写密集型的任务，比如文件下载等，缓冲区很可能满，注册该操作类型就很有必要，同时注意写完后取消注册。</td>
</tr>
<tr>
<td>OP_CONNECT</td>
<td>当SocketChannel.connect()请求连接成功后就绪。该操作只给客户端使用。</td>
</tr>
<tr>
<td>OP_ACCEPT</td>
<td>当接收到一个客户端连接请求时就绪。该操作只给服务器使用。</td>
</tr>
</tbody>
</table>
<p><strong>服务端和客户端分别感兴趣的类型：</strong></p>
<p>ServerSocketChannel 和 SocketChannel
可以注册自己感兴趣的操作类型，当对应操作类型的就绪条件满足时 OS 会通知
channel，下表描述各种 Channel 允许注册的操作类型，Y 表示允许注册，N
表示不允许注册，其中服务器 SocketChannel
指由服务器ServerSocketChannel.accept() 返回的对象。</p>
<table>

<thead>
<tr>
<th></th>
<th>OP_READ</th>
<th>OP_WRITE</th>
<th>OP_CONNECT</th>
<th>OP_ACCEPT</th>
</tr>
</thead>
<tbody>
<tr>
<td>服务器ServerSocketChannel</td>
<td></td>
<td></td>
<td></td>
<td><strong>Y</strong></td>
</tr>
<tr>
<td>服务器 SocketChannel</td>
<td><strong>Y</strong></td>
<td><strong>Y</strong></td>
<td></td>
<td></td>
</tr>
<tr>
<td>客户端SocketChannel</td>
<td><strong>Y</strong></td>
<td><strong>Y</strong></td>
<td><strong>Y</strong></td>
<td></td>
</tr>
</tbody>
</table>
<p>服务器启动 ServerSocketChannel，关注 OP_ACCEPT 事件。</p>
<p>客户端启动 SocketChannel，连接服务器，关注 OP_CONNECT事件</p>
<p>服务器接受连接，启动一个服务器的 SocketChannel，这个 SocketChannel
可以关注 OP_READ、OP_WRITE 事件，一般连接建立后会直接关注 OP_READ
事件</p>
<p>客户端 SocketChannel 发现连接建立后，可以关注 OP_READ、OP_WRITE
事件。</p>
<h4 id="写事件监听示例">2.5 写事件监听示例</h4>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioServerHandleWriteable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> started;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioServerHandleWriteable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            selector = Selector.open();<br>            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<br>            serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<span class="hljs-comment">//开启非阻塞模式</span><br>            serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> InetSocketAddress(port), <span class="hljs-number">1024</span>);<br>            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<br>            started = <span class="hljs-keyword">true</span>;<br>            System.out.println(<span class="hljs-string">&quot;服务器已启动，端口号：&quot;</span> + port);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            System.exit(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (started) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//阻塞,只有当至少一个注册的事件发生的时候才会继续.</span><br>                selector.select();<br>                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>                Iterator&lt;SelectionKey&gt; selectionKeyIterator = selectionKeys.iterator();<br>                SelectionKey selectionKey = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">while</span> (selectionKeyIterator.hasNext()) &#123;<br>                    selectionKey = selectionKeyIterator.next();<br>                    selectionKeyIterator.remove();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        handleInput(selectionKey);<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        <span class="hljs-keyword">if</span> (selectionKey != <span class="hljs-keyword">null</span>) &#123;<br>                            selectionKey.cancel();<br>                            <span class="hljs-keyword">if</span> (selectionKey.channel() != <span class="hljs-keyword">null</span>) &#123;<br>                                selectionKey.channel().close();<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                t.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//selector关闭后会自动释放里面管理的资源</span><br>        <span class="hljs-keyword">if</span> (selector != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">try</span> &#123;<br>                selector.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleInput</span><span class="hljs-params">(SelectionKey selectionKey)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;当前通道的事件：&quot;</span> + selectionKey.interestOps());<br>        <span class="hljs-keyword">if</span> (selectionKey.isValid()) &#123;<br>            <span class="hljs-keyword">if</span> (selectionKey.isAcceptable()) &#123;<br>                ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.channel();<br>                <span class="hljs-comment">//通过ServerSocketChannel的accept创建SocketChannel实例</span><br>                <span class="hljs-comment">//完成该操作意味着完成TCP三次握手，TCP物理链路正式建立</span><br>                SocketChannel sc = serverSocketChannel.accept();<br>                System.out.println(<span class="hljs-string">&quot;======socket channel 建立连接=======&quot;</span>);<br>                <span class="hljs-comment">//设置为非阻塞的</span><br>                sc.configureBlocking(<span class="hljs-keyword">false</span>);<br>                <span class="hljs-comment">//连接已经完成了，可以开始关心读事件了</span><br>                sc.register(selector, SelectionKey.OP_READ);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (selectionKey.isReadable()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;======socket channel 数据准备完成，可以去读取=======&quot;</span>);<br>                SocketChannel socketChannel = (SocketChannel) selectionKey.channel();<br>                ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                <span class="hljs-keyword">int</span> readBytes = socketChannel.read(buffer);<br>                <span class="hljs-keyword">if</span> (readBytes &gt; <span class="hljs-number">0</span>) &#123;<br>                    buffer.flip();<br>                    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buffer.remaining()];<br>                    buffer.get(bytes);<br>                    String message = <span class="hljs-keyword">new</span> String(bytes, StandardCharsets.UTF_8);<br>                    System.out.println(<span class="hljs-string">&quot;服务器收到消息：&quot;</span> + message);<br>                    String result = response(message);<br>                    doWrite(socketChannel, result);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readBytes &lt; <span class="hljs-number">0</span>) &#123;<br>                    selectionKey.cancel();<br>                    socketChannel.close();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (selectionKey.isWritable()) &#123;<br>                SocketChannel socketChannel = (SocketChannel) selectionKey.channel();<br>                ByteBuffer buffer = (ByteBuffer) selectionKey.attachment();<br>                <span class="hljs-keyword">if</span> (buffer.hasRemaining()) &#123;<br>                    <span class="hljs-keyword">int</span> count = socketChannel.write(buffer);<br>                    System.out.println(<span class="hljs-string">&quot;write :&quot;</span> + count + <span class="hljs-string">&quot;byte, remaining:&quot;</span> + buffer.hasRemaining());<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">/*取消对写的注册*/</span><br>                    selectionKey.interestOps(SelectionKey.OP_READ);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//发送应答消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(SocketChannel channel, String response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] bytes = response.getBytes();<br>        ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);<br>        writeBuffer.put(bytes);<br>        writeBuffer.flip();<br>        channel.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, writeBuffer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        started = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure>
<p>写操作完成之后需要取消OP_WRITE的注册。</p>
<h4 id="buffer">2.6 Buffer</h4>
<h5 id="重要属性">1. 重要属性</h5>
<p><strong>capacity</strong></p>
<p>作为一个内存块，Buffer
有一个固定的大小值，也叫“capacity”。你只能往里写 capacity 个
byte、long，char 等类型。一旦 Buffer
满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</p>
<p><strong>position</strong></p>
<p>当你写数据到 Buffer 中时，position 表示当前能写的位置。初始的
position 值为 0。当一个 byte、long 等数据写到 Buffer 后， position
会向前移动到下一个可插入数据的 Buffer 单元。position 最大可为 capacity –
1.</p>
<p>当读取数据时，也是从某个特定位置读。当将 Buffer
从写模式切换到读模式，position 会被重置为 0。当从 Buffer 的 position
处读取数据时，position 向前移动到下一个可读的位置。</p>
<p><strong>limit</strong></p>
<p>在写模式下，Buffer 的 limit 表示你最多能往 Buffer 里写多少数据。
写模式下，limit 等于 Buffer 的 capacity。当切换 Buffer 到读模式时，
limit 表示你最多能读到多少数据。因此，当切换 Buffer 到读模式时，limit
会被设置成写模式下的 position值。</p>
<h5 id="buffer的分配">2. Buffer的分配</h5>
<p>要想获得一个 Buffer 对象首先要进行分配。 每一个 Buffer 类都有
<strong>allocate</strong>
方法(可以在堆上分配，也可以在直接内存上分配)。</p>
<p>分配48字节 capacity 的 ByteBuffer 的例子: ByteBuffer buf =
ByteBuffer.allocate(48);</p>
<p>分配一个可存储1024个字符的CharBuffer：CharBuffer buf =
CharBuffer.allocate(1024);</p>
<p><strong>wrap方法</strong>：把一个 byte 数组或 byte 数组的一部分包装成
ByteBuffer：</p>
<p>ByteBuffer wrap(byte [] array)</p>
<p>ByteBuffer wrap(byte [] array, int offset, int length)</p>
<h5 id="直接内存">3. 直接内存</h5>
<p>HeapByteBuffer 与 DirectByteBuffer，在原理上，前者可以看出分配的
buffer 是在 heap 区域的，其实真正 flush
到远程的时候会先拷贝到直接内存，再做下一步操作；在 NIO
的框架下，很多框架会采用 DirectByteBuffer 来操作，这样分配的内存不再是在
java heap
上，经过性能测试，可以得到非常快速的网络交互，在大量的网络交互下，一般速度会比
HeapByteBuffer 要快速好几倍。</p>
<p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是
Java
虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致
OutOfMemoryError 异常出现。</p>
<p>NIO 可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java
堆里面的 DirectByteBuffer
对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在
Java 堆和 Native 堆中来回复制数据。</p>
<p><strong>直接内存（堆外内存）与堆内存比较：</strong></p>
<p>直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显</p>
<p>直接内存 IO
读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显</p>
<h5 id="buffer的读写">4. Buffer的读写</h5>
<p><strong>向 Buffer 中写数据：</strong></p>
<ul>
<li>读取 Channel 写到 Buffer</li>
<li>通过 Buffer 的 put() 方法写到 Buffer 里</li>
</ul>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从Channel写到Buffer的例子</span><br><span class="hljs-keyword">int</span> readBytes = socketChannel.read(buffer);<br><span class="hljs-comment">//通过put方法写Buffer的例子：</span><br>buffer.put(bytes);<br></code></pre></td></tr></table></figure>
<p>put 方法有很多版本，允许你以不同的方式把数据写入到 Buffer 中。例如，
写到一个指定的位置，或者把一个字节数组写入到 Buffer。在比如：put(byte
b)，向 position 的位置写入一个 byte，并将
postion+1，为下次读写作准备。</p>
<p><strong>flip()方法</strong></p>
<p>flip方法将 Buffer 从写模式切换到读模式。调用 flip() 方法会将 position
设回 0，并将 limit 设置成之前 position 的值。</p>
<p><strong>从 Buffer 中读取数据</strong></p>
<ol type="1">
<li>从 Buffer 读取数据写入到 Channel</li>
<li>使用 get() 方法从 Buffer 中读取数据</li>
</ol>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">socketChannel.write(writeBuffer);<br>buffer.get(bytes);<br></code></pre></td></tr></table></figure>
<p>get 方法有很多版本，允许你以不同的方式从 Buffer
中读取数据。例如，从指定 position 读取，或者从 Buffer
中读取数据到字节数组，再比如 get() 属于相对读，从 position 位置读取一个
byte，并将 position+1，为下次读写作准备;</p>
<p><strong>使用 Buffer 读写数据常见步骤：</strong></p>
<ol type="1">
<li>写入数据到 Buffer</li>
<li>调用flip()方法</li>
<li>从 Buffer 中读取数据</li>
<li>调用 clear() 方法或者 compact() 方法，准备下一次的写入</li>
</ol>
<p>当向 buffer 写入数据时，buffer
会记录下写了多少数据。一旦要读取数据，需要通过 flip() 方法将 Buffer
从写模式切换到读模式。在读模式下，可以读取之前写入到 buffer
的所有数据。一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用
clear() 或 compact() 方法。clear() 方法会清空整个缓冲区。compact()
方法只会清除已经读过的数据。</p>
<h5 id="其他常用操作">5. 其他常用操作</h5>
<p><strong>绝对读写</strong></p>
<p>put(int index, byte b) 绝对写，向 byteBuffer 底层的 bytes 中下标为
index 的位置插入 byte b，不改变 position 的值。</p>
<p>get(int index) 属于绝对读，读取 byteBuffer 底层的 bytes 中下标为
index 的 byte，不改变 position。</p>
<p><strong>rewind()</strong></p>
<p>Buffer.rewind() 将 position 设回 0，所以你可以重读 Buffer
中的所有数据。limit 保持不变，仍然表示能从 Buffer
中读取多少个元素（byte、char等）。</p>
<p><strong>clear() 与 compact()</strong></p>
<p>一旦读完 Buffer 中的数据，需要让 Buffer 准备好再次被写入。可以通过
clear() 或 compact() 方法来完成。</p>
<p>如果调用的是 clear() 方法，position 将被设回 0，limit 被设置成
capacity 的值。换句话说，Buffer 被清空了。Buffer
中的数据并未清除，只是这些标记告诉我们可以从哪里开始往 Buffer
里写数据。compact() 方法将所有未读的数据拷贝到 Buffer 起始处。然后将
position 设到最后一个未读元素正后面。现在 Buffer
准备好写数据了，但是不会覆盖未读的数据。</p>
<p><strong>mark() 与 reset() 方法</strong></p>
<p>通过调用 Buffer.mark() 方法，可以标记 Buffer 中的一个特定
position。之后可以通过调用 Buffer.reset() 方法恢复到这个position。</p>
<p><strong>equals() 与 compareTo() 方法</strong></p>
<p>equals()：</p>
<p>当满足下列条件时，表示两个Buffer相等：</p>
<ol type="1">
<li>有相同的类型（byte、char、int等）。</li>
<li>Buffer 中剩余的 byte、char 等的个数相等。</li>
<li>Buffer 中所有剩余的 byte、char 等都相同。</li>
</ol>
<p>compareTo()：</p>
<p>compareTo() 方法比较两个 Buffer 的剩余元素(byte、char等)，
如果满足下列条件，则认为一个 Buffer “小于”另一个 Buffer：</p>
<ol type="1">
<li>第一个不相等的元素小于另一个Buffer中对应的元素 。</li>
<li>所有元素都相等，但第一个 Buffer 比另一个先耗尽(第一个 Buffer
的元素个数比另一个少)。</li>
</ol>
<h5 id="buffer方法总结">6. Buffer方法总结</h5>
<table>

<thead>
<tr>
<th>limit(), limit(10)等</th>
<th>其中读取和设置这4个属性的方法的命名和jQuery中的val(),val(10)类似，一个负责get，一个负责set</th>
</tr>
</thead>
<tbody>
<tr>
<td>reset()</td>
<td>把 position 设置成 mark
的值，相当于之前做过一个标记，现在要退回到之前标记的地方</td>
</tr>
<tr>
<td>clear()</td>
<td>position = 0;limit = capacity;mark = -1</td>
</tr>
<tr>
<td>flip()</td>
<td>limit = position;position = 0;mark = -1</td>
</tr>
<tr>
<td>rewind()</td>
<td>把 position 设为 0，mark 设为 -1，不改变 limit 的值</td>
</tr>
<tr>
<td>remaining()</td>
<td>返回 limit 和position 之间相对位置差</td>
</tr>
<tr>
<td>hasRemaining()</td>
<td>返回是否还有未读内容</td>
</tr>
<tr>
<td>compact()</td>
<td>把从 position 到 limit 中的内容移到 0 到 limit-position
的区域内</td>
</tr>
<tr>
<td>get()</td>
<td>相对读，从 position 位置读取一个 byte，并将
position+1，为下次读写作准备</td>
</tr>
<tr>
<td>get(int index)</td>
<td>绝对读，读取 byteBuffer 底层的 bytes 中下标为 index 的 byte，不改变
position</td>
</tr>
<tr>
<td>get(byte[] dst, int offset, int length)</td>
<td>从 position 位置开始相对读，读 length 个 byte，并写入 dst 下标从
offset 到 offset+length 的区域</td>
</tr>
<tr>
<td>put(byte b)</td>
<td>相对写，向 position 的位置写入一个 byte，并将
postion+1，为下次读写作准备</td>
</tr>
<tr>
<td>put(int index, byte b)</td>
<td>绝对写，向 byteBuffer 底层的 bytes 中下标为 index 的位置插入byte
b，不改变 position</td>
</tr>
<tr>
<td>put(ByteBuffer src)</td>
<td>用相对写，把src中可读的部分（也就是 position 到 limit
）写入此byteBuffer</td>
</tr>
<tr>
<td>put(byte[] src, int offset, int length)</td>
<td>从 src 数组中的 offset 到 offset+length
区域读取数据并使用相对写写入此 byteBuffer</td>
</tr>
</tbody>
</table>
<h4 id="reactor模式类型">2.7 Reactor模式类型</h4>
<h5 id="单线程reactor模式流程">1. 单线程Reactor模式流程</h5>
<ul>
<li>服务器端的 Reactor 是一个线程对象，该线程会启动事件循环，并使用
Selector (选择器)来实现 IO 的多路复用。注册一个 Acceptor 事件处理器到
Reactor 中，Acceptor 事件处理器所关注的事件是 ACCEPT 事件，这样 Reactor
会监听客户端向服务器端发起的连接请求事件(ACCEPT事件)。</li>
<li>客户端向服务器端发起一个连接请求，Reactor 监听到了该 ACCEPT
事件的发生并将该 ACCEPT 事件派发给相应的 Acceptor
处理器来进行处理。Acceptor 处理器通过 accept()
方法得到与这个客户端对应的连接(SocketChannel)，然后将该连接所关注的 READ
事件以及对应的 READ 事件处理器注册到 Reactor 中，这样一来 Reactor
就会监听该连接的 READ 事件了。</li>
<li>当 Reactor
监听到有读或者写事件发生时，将相关的事件派发给对应的处理器进行处理。比如，读处理器会通过
SocketChannel 的 read() 方法读取数据，此时 read()
操作可以直接读取到数据，而不会堵塞与等待可读的数据到来。</li>
<li>每当处理完所有就绪的感兴趣的 I/O 事件后，Reactor 线程会再次执行
select() 阻塞等待新的事件就绪并将其分派给对应处理器进行处理。</li>
</ul>
<p>注意，Reactor 的单线程模式的单线程主要是针对于 I/O
操作而言，也就是所有的 I/O 的 accept()、read()、write() 以及 connect()
操作都在一个线程上完成的。</p>
<p>但在目前的单线程 Reactor 模式中，不仅 I/O 操作在该 Reactor
线程上，连非 I/O 的业务操作也在该线程上进行处理了，这可能会大大延迟 I/O
请求的响应。所以我们应该将非 I/O 的业务逻辑操作从 Reactor
线程上卸载，以此来加速 Reactor 线程对 I/O 请求的响应。</p>
<center>
<img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042006610.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />
</center>
<h5 id="单线程reactor工作者线程池">2. 单线程Reactor，工作者线程池</h5>
<p>与单线程 Reactor 模式不同的是，添加了一个工作者线程池，并将非 I/O
操作从 Reactor 线程中移出转交给工作者线程池来执行。这样能够提高 Reactor
线程的 I/O 响应，不至于因为一些耗时的业务逻辑而延迟对后面 I/O
请求的处理。</p>
<p>使用线程池的优势：</p>
<p>①
通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程产生的巨大开销。</p>
<p>②
当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。</p>
<p>③
通过适当调整线程池的大小，可以创建足够多的线程以便使处理器保持忙碌状态。同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。</p>
<p>改进的版本中，I/O 操作依旧由一个 Reactor 来完成，包括 I/O 的
accept()、read()、write() 以及 connect() 操作。</p>
<p>对于一些小容量应用场景，可以使用单线程模型。但是对于高负载、大并发或大数据量的应用场景却不合适，主要原因如下：</p>
<p>① 一个 NIO 线程同时处理成百上千的链路，性能上无法支撑，即便 NIO
线程的 CPU 负荷达到100%，也无法满足海量消息的读取和发送；</p>
<p>② 当 NIO
线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重了
NIO
线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈；</p>
<center>
<img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042014630.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />
</center>
<h5 id="多线程主从reactor模式">3. 多线程主从Reactor模式</h5>
<p>Reactor 线程池中的每一 Reactor 线程都会有自己的
Selector、线程和分发的事件循环逻辑。</p>
<p>mainReactor 可以只有一个，但 subReactor 一般会有多个。mainReactor
线程主要负责接收客户端的连接请求，然后将接收到的 SocketChannel 传递给
subReactor，由 subReactor 来完成和客户端的通信。</p>
<p>流程：</p>
<p>① 注册一个 Acceptor 事件处理器到 mainReactor 中，Acceptor
事件处理器所关注的事件是 ACCEPT 事件，这样 mainReactor
会监听客户端向服务器端发起的连接请求事件(ACCEPT事件)。启动 mainReactor
的事件循环。</p>
<p>② 客户端向服务器端发起一个连接请求，mainReactor 监听到了该 ACCEPT
事件并将该 ACCEPT 事件派发给 Acceptor 处理器来进行处理。Acceptor
处理器通过 accept()
方法得到与这个客户端对应的连接(SocketChannel)，然后将这个 SocketChannel
传递给 subReactor 线程池。</p>
<p>③ subReactor 线程池分配一个 subReactor 线程给这个
SocketChannel，即，将 SocketChannel 关注的 READ 事件以及对应的 READ
事件处理器注册到 subReactor 线程中。Reactor 线程池中的每一 Reactor
线程都会有自己的 Selector、线程和分发的循环逻辑。</p>
<p>④ 当有 I/O 事件就绪时，相关的 subReactor
就将事件派发给响应的处理器处理。注意，这里 subReactor 线程只负责完成 I/O
的 read()
操作，在读取到数据后将业务逻辑的处理放入到线程池中完成，若完成业务逻辑后需要返回数据给客户端，则相关的
I/O 的 write 操作还是会被提交回 subReactor 线程来完成。</p>
<p>注意，所有的 I/O 操作(包括，I/O 的 accept()、read()、write() 以及
connect() 操作)依旧还是在 Reactor 线程( mainReactor 线程 或 subReactor
线程)中完成的。Thread Pool(线程池)仅用来处理非 I/O 操作的逻辑。</p>
<p>多 Reactor
线程模式将“接受客户端的连接请求”和“与该客户端的通信”分在了两个 Reactor
线程来完成。mainReactor
完成接收客户端连接请求的操作，它不负责与客户端的通信，而是将建立好的连接转交给
subReactor 线程来完成与客户端的通信，这样一来就不会因为 read()
数据量太大而导致后面的客户端连接请求得不到即时处理的情况。并且多 Reactor
线程模式在海量的客户端并发请求的情况下，还可以通过实现 subReactor
线程池来将海量的连接分发给多个 subReactor
线程，在多核的操作系统中这能大大提升应用的负载和吞吐量。</p>
<center>
<img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042023285.png" srcset="/img/loading.gif" lazyload style="zoom:50%;" />
</center>
<h5 id="和观察者模式的区别">4. 和观察者模式的区别</h5>
<p><strong>观察者模式：</strong>也可以称为为 发布-订阅
模式，主要适用于多个对象依赖某一个对象的状态，并且当某对象状态发生改变时，要通知其他依赖对象做出更新。是一种一对多的关系。当然，如果依赖的对象只有一个时，也是一种特殊的一对一关系。通常，观察者模式适用于消息事件处理，监听者监听到事件时通知事件处理者对事件进行处理。</p>
<p><strong>Reactor模式：</strong> 即反应器模式，是一种高效的异步 IO
模式，特征是回调，当 IO
完成时，回调对应的函数进行处理。这种模式并非是真正的异步，而是运用了异步的思想，当
IO 事件触发时，通知应用程序作出 IO 处理。模式本身并不调用系统的异步 IO
函数。</p>
<p>reactor模式与观察者模式有点像。不过，观察者模式与单个事件源关联，而反应器模式则与多个事件源关联
。当一个主体发生改变时，所有依属体都得到通知。</p>

              
            </div>
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/Netty/" class="category-chain-item">Netty</a>
  
  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/Netty/">#Netty</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>Netty——BIO、NIO</div>
      <div>http://example.com/2023/10/03/Netty——BIO、NIO/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>debuggingWorld</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2023年10月3日</div>
        </div>
      
      
      <div class="license-meta-item">
        <div>许可协议</div>
        <div>
          
            
            
              <a target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
              <span class="hint--top hint--rounded" aria-label="BY - 署名">
                <i class="iconfont icon-by"></i>
              </span>
              </a>
            
          
        </div>
      </div>
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2023/10/04/Netty%E2%80%94%E2%80%94%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E3%80%81%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%81epoll%E6%A8%A1%E5%9E%8B/" title="Netty——直接内存、零拷贝、epoll模型">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">Netty——直接内存、零拷贝、epoll模型</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2023/06/15/Dubbo%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E5%AF%BC%E5%87%BA%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%BC%95%E5%85%A5/" title="Dubbo——服务导出和服务引入">
                        <span class="hidden-mobile">Dubbo——服务导出和服务引入</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
  <article id="comments" lazyload>
    
  <script type="text/javascript">
    Fluid.utils.loadComments('#comments', function() {
      var light = 'github-light';
      var dark = 'github-dark';
      var schema = document.documentElement.getAttribute('data-user-color-scheme');
      if (schema === 'dark') {
        schema = dark;
      } else {
        schema = light;
      }
      window.UtterancesThemeLight = light;
      window.UtterancesThemeDark = dark;
      var s = document.createElement('script');
      s.setAttribute('src', 'https://utteranc.es/client.js');
      s.setAttribute('repo', 'debuggingworld/blogUtterances');
      s.setAttribute('issue-term', 'pathname');
      
      s.setAttribute('label', 'utterances');
      
      s.setAttribute('theme', schema);
      s.setAttribute('crossorigin', 'anonymous');
      document.getElementById('comments').appendChild(s);
    })
  </script>
  <noscript>Please enable JavaScript to view the comments</noscript>


  </article>


          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header"><i class="iconfont icon-list"></i>&nbsp;目录</p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  


  
  








    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/太空探索与卫星.svg" srcset="/img/loading.gif" lazyload height="250" width="250" /> <br/> <a>没有什么能够阻挡，你对自由的向往</a> <br/> <a>天马行空的生涯，你的心了无牵挂</a> <br/> <br/> <br/> <br> <font size="2" >--end--</font> <br/> 
    </div>
  
  
    <div class="statistics">
  
  

  
    
      <span id="busuanzi_container_site_pv" style="display: none">
        总访问量 
        <span id="busuanzi_value_site_pv"></span>
         次
      </span>
    
    
      <span id="busuanzi_container_site_uv" style="display: none">
        总访客数 
        <span id="busuanzi_value_site_uv"></span>
         人
      </span>
    
    
  
</div>

  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.0/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>






  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.18.0/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      headingSelector : CONFIG.toc.headingSelector || 'h1,h2,h3,h4,h5,h6',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      collapseDepth   : CONFIG.toc.collapseDepth || 0,
      scrollSmooth    : true,
      headingsOffset  : -boardTop
    });
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }
  });
</script>


  <script>
  (function() {
    var enableLang = CONFIG.code_language.enable && CONFIG.code_language.default;
    var enableCopy = CONFIG.copy_btn;
    if (!enableLang && !enableCopy) {
      return;
    }

    function getBgClass(ele) {
      return Fluid.utils.getBackgroundLightness(ele) >= 0 ? 'code-widget-light' : 'code-widget-dark';
    }

    var copyTmpl = '';
    copyTmpl += '<div class="code-widget">';
    copyTmpl += 'LANG';
    copyTmpl += '</div>';
    jQuery('.markdown-body pre').each(function() {
      var $pre = jQuery(this);
      if ($pre.find('code.mermaid').length > 0) {
        return;
      }
      if ($pre.find('span.line').length > 0) {
        return;
      }

      var lang = '';

      if (enableLang) {
        lang = CONFIG.code_language.default;
        if ($pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2 && $pre.children().hasClass('hljs')) {
          lang = $pre[0].children[0].classList[1];
        } else if ($pre[0].getAttribute('data-language')) {
          lang = $pre[0].getAttribute('data-language');
        } else if ($pre.parent().hasClass('sourceCode') && $pre[0].children.length > 0 && $pre[0].children[0].classList.length >= 2) {
          lang = $pre[0].children[0].classList[1];
          $pre.parent().addClass('code-wrapper');
        } else if ($pre.parent().hasClass('markdown-body') && $pre[0].classList.length === 0) {
          $pre.wrap('<div class="code-wrapper"></div>');
        }
        lang = lang.toUpperCase().replace('NONE', CONFIG.code_language.default);
      }
      $pre.append(copyTmpl.replace('LANG', lang).replace('code-widget">',
        getBgClass($pre[0]) + (enableCopy ? ' code-widget copy-btn" data-clipboard-snippet><i class="iconfont icon-copy"></i>' : ' code-widget">')));

      if (enableCopy) {
        Fluid.utils.createScript('https://lib.baomitu.com/clipboard.js/2.0.10/clipboard.min.js', function() {
          var clipboard = new window.ClipboardJS('.copy-btn', {
            target: function(trigger) {
              var nodes = trigger.parentNode.childNodes;
              for (var i = 0; i < nodes.length; i++) {
                if (nodes[i].tagName === 'CODE') {
                  return nodes[i];
                }
              }
            }
          });
          clipboard.on('success', function(e) {
            e.clearSelection();
            e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-copy', 'icon-success');
            setTimeout(function() {
              e.trigger.innerHTML = e.trigger.innerHTML.replace('icon-success', 'icon-copy');
            }, 2000);
          });
        });
      }
    });
  })();
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/4.3.1/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  
      <script>
        MathJax = {
          tex    : {
            inlineMath: { '[+]': [['$', '$']] }
          },
          loader : {
            load: ['ui/lazy']
          },
          options: {
            renderActions: {
              findScript    : [10, doc => {
                document.querySelectorAll('script[type^="math/tex"]').forEach(node => {
                  const display = !!node.type.match(/; *mode=display/);
                  const math = new doc.options.MathItem(node.textContent, doc.inputJax[0], display);
                  const text = document.createTextNode('');
                  node.parentNode.replaceChild(text, node);
                  math.start = { node: text, delim: '', n: 0 };
                  math.end = { node: text, delim: '', n: 0 };
                  doc.math.push(math);
                });
              }, '', false],
              insertedScript: [200, () => {
                document.querySelectorAll('mjx-container').forEach(node => {
                  let target = node.parentNode;
                  if (target.nodeName.toLowerCase() === 'li') {
                    target.parentNode.classList.add('has-jax');
                  }
                });
              }, '', false]
            }
          }
        };
      </script>
    

  <script  src="https://lib.baomitu.com/mathjax/3.2.0/es5/tex-mml-chtml.js" ></script>

  <script  src="/js/local-search.js" ></script>

  <script defer src="https://busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js" ></script>




  
<script src="/iconfont.js"></script>



<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
