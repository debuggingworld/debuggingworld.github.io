<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>java——java8新特性之Stream</title>
    <link href="/2021/12/01/java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/"/>
    <url>/2021/12/01/java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/</url>
    
    <content type="html"><![CDATA[<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p><strong>A sequence of elements supporting sequential and parallel aggregate operations .</strong></p><ol><li>Stream 是元素的集合，这点让 Stream 看起来用些类似 Iterator；</li><li>可以支持顺序和并行的对原Stream进行汇聚的操作；</li></ol><blockquote><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulkdata operation)。</p></blockquote><p>Stream API 借助于 Lambda 表达式，极大的提高编程效率和程序可读性。同时提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势（使用 fork/join框架，fork 递归式地分解问题，然后每段并行执行，最终由 join 合并结果，返回最后的值）。</p><p>[例] 统计列表中不为 null 的元素个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; nums = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">6</span>);<br><br><span class="hljs-comment">//原始版本</span><br><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (Integer item : nums) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != item) &#123;<br>        count++;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Stream 版本</span><br><span class="hljs-keyword">long</span> count1 = nums.stream().filter(Objects::nonNull).count();<br></code></pre></td></tr></table></figure><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h3><p><img src="https://user-images.githubusercontent.com/45761474/144250337-a744591a-f7ef-4877-8876-c01a7ede3661.jpg" alt="Stream表达式"></p><p>一条语句分为三部分：</p><ol><li>红色框中的语句是一个 Stream 的生命开始的地方，负责创建一个Stream实例；</li><li>绿色框中的语句是赋予 Stream 灵魂的地方，把一个 Stream 转换成另外一个 Stream；</li><li>蓝色框中的语句是汇聚的地方，把 Stream 里面包含的内容按照某种算法来汇聚成一个值。</li></ol><blockquote><p>使用Stream的基本步骤：</p><ol><li>创建Stream；</li><li>转换Stream，每次转换原有Stream对象不改变，返回一个新的Stream对象（可以有多次转换）；</li><li>对Stream进行聚合（Reduce）操作，获取想要的结果</li></ol></blockquote><h3 id="3-创建-Stream"><a href="#3-创建-Stream" class="headerlink" title="3. 创建 Stream"></a>3. 创建 Stream</h3><p>常见创建 Stream 的方式有三种：</p><ul><li>通过 Stream 接口的静态工厂方法</li><li>通过 Collection 接口的默认方法 stream() 把一个 Collection 对象转换为 Stream</li><li>通过数组，Arrays.stream(T array)</li></ul><ol><li><p>of 方法：有两个 overload 方法，一个接受变长参数，一个接口单一值；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>Stream&lt;String&gt; stringStream = Stream.of(<span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>generator 方法<br>生成一个无限长度的 Stream ，其元素生成时通过给定的 Supplier 接口提供</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.generate(<span class="hljs-keyword">new</span> Supplier&lt;Double&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Math.random();<br>    &#125;<br>&#125;);<br>Stream.generate(()-&gt;Math.random());<br><br>Stream.generate(Math::random);<br></code></pre></td></tr></table></figure><p>生成一个无限长度的Stream，其中值是随机的。这个无限长度Stream是懒加载。</p><ol start="3"><li>iterate 方法：</li></ol><p>也是生成无限长度的 Stream，和 generator 不同的是，其元素的生成是重复对给定的种子值(seed)调用用户指定函数来生成的。其中包含的元素可以认为是：seed，f(seed),f(f(seed))无限循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先获取一个无限长度的正整数集合的Stream，然后取出前10个打印。</span><br>      Stream.iterate(<span class="hljs-number">1</span>, item -&gt; item * <span class="hljs-number">2</span>).limit(<span class="hljs-number">10</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><ol start="4"><li>通过 Collection 子类获取 Stream<br>Collection接口有一个stream方法，所以其所有子类都都可以获取对应的Stream对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integerList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">3</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>integerList.stream();<br>Set&lt;Integer&gt; integerSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>integerSet.stream();<br>Map&lt;String, String&gt; stringMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>stringMap.entrySet().stream();<br>stringMap.keySet().stream();<br>stringMap.values().stream();<br></code></pre></td></tr></table></figure></li><li>Arrays.stream(T array)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.stream(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);<br></code></pre></td></tr></table></figure><p>转换Stream<br>转换Stream其实就是把一个Stream通过某些行为转换成一个新的Stream。<br>Stream接口中定义了几个常用的转换方法:<br>disinct<br>filter<br>map<br>flatmap<br>peek<br>limit<br>skip</p><ol><li>distinct</li><li>对于Stream中包含的元素进行去重操作(依赖于元素的 equals 方法),新生成的Stream<br>中没有重复的元素。<br>List<Integer> nums = Lists.newArrayList(1,1,null,2,3,4,null,5,6,7,8,9)<br>System.out.println(“sum is : “ + nums.stream().distinct());</li><li>filter<br>对于Stream中包含的元素使用给定的过滤函数进行过滤操作，新生成的Stream只包含符<br>合条件的元素<br>List<Integer> nums = Lists.newArrayList(1,1,null,2,3,4,null,5,6,7,8,9)<br>System.out.println(“sum is : “ + nums.stream().filter(i-&gt;i!=null));</li><li>map<br>对于Stream中包含的元素使用给定的转换函数进行转换操作，新生成的Stream只包含转<br>换生成的元素.<br>这个方法有三个对于原始类型的变种方法，分别是：mapToInt，mapToLong和<br>mapToDouble。<br>List<Integer> nums = Lists.newArrayList(1,1,null,2,3,4,null,5,6,7,8,9)<br>System.out.println(“sum is : “ + nums.stream().map(i-&gt;i*2));</li><li>flatMap<br>和map类似，不同的是其每个元素转换得到的是Stream对象，会把子Stream中的元素压<br>缩到父集合中</li><li>peek<br>生成一个包含原Stream的所有元素的新Stream，同时会提供一个消费函数（Consumer实<br>例），新Stream每个元素被消费的时候都会执行给定的消费函数；<br>List<Integer> nums = Lists.newArrayList(1,1,null,2,3,4,null,5,6,7,8,9)<br>System.out.println(“sum is : “ + nums.stream().peek(System.out::println));</li><li>limit<br>对一个Stream进行截断操作，获取其前N个元素，如果原Stream中包含的元素个数小于<br>N，那就获取其所有的元素；<br>List<Integer> nums = Lists.newArrayList(1,1,null,2,3,4,null,5,6,7,8,9)<br>System.out.println(“sum is : “ + nums.stream().limit(4));</li><li>skip<br>返回一个丢弃原Stream的前N个元素后剩下元素组成的新Stream，如果原Stream中包含<br>的元素个数小于N，那么返回空Stream；<br>List<Integer> nums = Lists.newArrayList(1,1,null,2,3,4,null,5,6,7,8,9)<br>System.out.println(“sum is : “ + nums.stream().skip(2));<br>综合应用<br>给定一个Integer类型的List，过滤掉null，去重，每个元素乘以2，每个元素被消费的时<br>候打印自身，再跳过前两个元素，最后取前四个元素进行加和运算.<br>List<Integer> nums = Lists.newArrayList(1,1,null,2,3,4,null,5,6,7,8,9)<br>System.out.println(“sum is : “ + nums.stream()<br>.filter(i-&gt;i!=null)<br>.distinct()<br>.mapToInt(i-&gt;i*2)<br>.peek(System.out::println)<br>.skip(2)<br>.limit(4)<br>.sum());<br>性能问题<br>对于一个Stream进行多次转换操作，每次都对Stream的每个元素进行转换，而且是执行<br>多次，这样时间复杂度就是一个for循环里把所有操作都做掉的N（转换的次数）倍？<br>答案是否定的：<br>转换操作都是lazy的，多个转换操作只会在汇聚操作的时候融合起来，一次循环完成。<br>可以这样简单的理解，Stream里有个操作函数的集合，每次转换操作就是把转换函数放<br>入这个集合中，在汇聚操作的时候循环Stream对应的集合，然后对每个元素执行所有的<br>函数。<br>常见错误用法<br>在一个stream 上执行一组操作，然后用其他操作以两种不同的方式处理结果stream。<br>List<Integer> ints = Lists.newArrayList(1, 1, 2, 3, 4, 5, 5, 6, 7, 8, 9, 9);<br>Stream<Integer> streamInt = ints.stream().distinct();<br>System.out.println(“” + streamInt.filter(i-&gt; i%2 == 0).collect(Collectors.toList()));<br>System.out.println(“” + streamInt.filter(i-&gt; i%2 == 1).collect(Collectors.toList()));<br>java.lang.IllegalStateException: stream has already been operated upon or closed<br>stream 是有状态对象，可认为是迭代器或者指针，上述操作是对同一指针的引用。<br>第一个收集方法执行完stream的指针已经走到了尽头，所以第二个收集方式试图访问操<br>作终点的指针，是非法操作。<br>解决：<br>List<Integer> streamInt = ints.stream().distinct().collect(Collectors.toList());<br>先收集中</li></ol>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——函数式编程</title>
    <link href="/2021/11/30/java%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/11/30/java%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1-重新认识接口"><a href="#1-重新认识接口" class="headerlink" title="1. 重新认识接口"></a>1. 重新认识接口</h3><h4 id="1-1-java8之前"><a href="#1-1-java8之前" class="headerlink" title="1.1 java8之前"></a>1.1 java8之前</h4><p>接口的作用：定义该类型实例具有的功能，不关心如何进行这些工作。所以，接口定义中只有抽象方法（public abstract）和常量（public static final），并且接口中不允许定义实例变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInterface</span> </span>&#123;<br>    Integer age = <span class="hljs-number">18</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-java8之后"><a href="#1-2-java8之后" class="headerlink" title="1.2 java8之后"></a>1.2 java8之后</h4><p>从JKD8开始，接口可以加入静态方法和默认方法<br>默认方法允许接口方法定义默认实现，而所有子类都继承该方法及实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInterface</span> </span>&#123;<br>    Integer age = <span class="hljs-number">18</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printHello</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getString</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>默认方法的优势</strong></p><ol><li>默认方法的主要优势是提供一种拓展接口的方法，而不破坏现有代码。增加新的方法，并且能保证对使用这个接口的老版本代码的兼容性。<br>在JDK8以前，如果为一个现有接口增加一个新方法，则我们必须在所有实现类中添加该方法的实现，否则编译会出现异常。<br>如果实现类比较多或者我们没有权限修改实现类源代码，这样可能就比较麻烦。<br>默认方法则解决了这个问题，它提供了一个实现，当没有显式提供其他实现时就采用这个实现，这样新添加的方法将不会破坏现有代码。</li><li>另一个优势是该方法是可选，子类可以根据不同的需求Override默认实现。<br>例如，我们定义一个集合接口，其中有增、删、改等操作。如果实现类90%都是以数组保存数据，那么可以定义针对这些方法给出默认实现，而对于其他非数组集合或者有其他类似业务，可以选择性复写接口中默认方法。</li></ol><h3 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2.函数式接口"></a>2.函数式接口</h3><p><strong>定义：</strong></p><blockquote><p>如果一个接口定义唯一一个抽象方法，那么这个接口就成为函数式接口。</p></blockquote><p>java.lang.Runnable 就是一个函数式接口，因为它只有一个抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认方法不是abstract的，所以一个函数式接口里可以定义任意多的默认方法。<br>为了标明函数式接口Java8引入了一个新的注解： @FunctionalInterface</p><p><strong>函数接口特性</strong></p><ul><li>@FunctionInterface 注解只能标记在有且仅有一个抽象方法的接口上；</li><li>Java8接口中的静态方法和默认方法，都不算是抽象方法；</li><li>接口默认继承 java.lang.Object ,所以如果接口声明覆盖了Object中的方法，那么也不算抽象方法；</li><li>注解不是必须的，如果接口符合函数式接口的定义，那么不加注解也没有影响。加上则编译器可以进行检查。如果不是函数接口而加上了注解，则编译器会报错。</li></ul><h3 id="3-函数式编程"><a href="#3-函数式编程" class="headerlink" title="3.  函数式编程"></a>3.  函数式编程</h3><p>函数编程特性：</p><p><strong>a. 闭包与高阶函数</strong><br>函数编程支持函数作为第一类对象，有时称为 闭包或者 仿函数（functor）对象。实质上，闭包是起函数的作用并可以像对象一样操作的对象。高阶函数可以用另一个函数作为其输入参数，也可以返回一个函数作为其输出参数。</p><p><strong>b. 惰性计算</strong><br>在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算。延迟的计算可以编写可能潜在地生成无穷输出的函数。因为不会计算多于程序的其余部分所需要的值，所以不需要担心由无穷计算所导致的 out-of-memory 错误。</p><p><strong>c. 没有“副作用”</strong><br>所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p><blockquote><p>综上所述，函数式编程可以简言之是： 使用不可变值和函数， 通过函数对一个值进行处理， 映射成另一个值。这个值在面向对象语言中可以理解为对象，另外这个值还可以作为函数的输入。</p></blockquote><p>Java8 中的函数式编程</p><ul><li>内建的函数式接口</li><li>Optional API</li><li>Lambda表达式</li><li>Stream API</li></ul><h4 id="3-1-内建的函数式接口"><a href="#3-1-内建的函数式接口" class="headerlink" title="3.1 内建的函数式接口"></a>3.1 内建的函数式接口</h4><p>Java8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。</p><table><thead><tr><th align="center">name</th><th align="center">type</th><th align="center">description</th></tr></thead><tbody><tr><td align="center">Consumer(消费者)</td><td align="center">Consumer<T></td><td align="center">接收 T 对象，不返回值</td></tr><tr><td align="center">Predicate(谓词)</td><td align="center">Predicate<T></td><td align="center">接收 T 对象并返回boolean</td></tr><tr><td align="center">Function(函数)</td><td align="center">Function&lt;T,R&gt;</td><td align="center">接收 T 对象，返回 R 对象</td></tr><tr><td align="center">Supplier(提供者)</td><td align="center">Supplier<T></td><td align="center">提供T对象，不接收值</td></tr><tr><td align="center">UnaryOperator(一元运算符)</td><td align="center">UnaryOperator<T></td><td align="center">接收T对象，返回T对象</td></tr><tr><td align="center">BinaryOperator(二元操作)</td><td align="center">BinaryOperator<T></td><td align="center">接收两个T对象，返回T对象</td></tr></tbody></table><blockquote><p>以上四种为基本的函数接口，在此之上JDK又提供了若干扩展：</p><ol><li>以上前三种添加了Bi的前缀：BiConsumer,BiPredicate,BiFunction,入参变为两个；</li><li>对Function的扩展产生了UnaryOperator(一元运算符)，接收T返回T；</li><li>对BiFunction的扩展产生了BinaryOperator(二元操作)，收两个T对象，返回T对象</li><li>增加了若干具体基本类型的接口，可参见function包下具体接口说明。</li></ol></blockquote><h4 id="3-2-Optional-API"><a href="#3-2-Optional-API" class="headerlink" title="3.2 Optional API"></a>3.2 Optional API</h4><p>Java8中引入的 Optional 是一种优雅解决NPE(NullPointExcepiton)问题的方法，是通过函数式接口实现的。</p><p>Optional 提供的方法：</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">public<U> Optional<U> map(Function&lt;? super T, ? extends U&gt; mapper)</td><td align="center">如果当前 Optional 为 Optional.empty，则依旧返回 Optional.empty；否则返回一个新的 Optional，该 Optional 包含的是：函数 mapper 在以 value 作为输入时的输出值。</td></tr><tr><td align="center">public T orElse(T other)</td><td align="center">如果有值则将其返回，否则返回一个默认值</td></tr><tr><td align="center">public T orElseGet(Supplier&lt;? extends T&gt; other)</td><td align="center">如果有值则将其返回，否则返回一个由指定的Supplier接口生成的值</td></tr></tbody></table><p>如果当前 Optional 为 Optional.empty，则依旧返回 Optional.empty；否则返回一个新的 Optional，该 Optional 包含的是：函数 mapper 在以 value 作为输入时的输出值。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git——rebase命令</title>
    <link href="/2021/11/29/Git%E2%80%94%E2%80%94rebase%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/11/29/Git%E2%80%94%E2%80%94rebase%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h3><ul><li>合并多次提交记录</li><li>分支合并</li><li>对一个分支做『变基』操作</li></ul><h3 id="2-合并多次提交记录"><a href="#2-合并多次提交记录" class="headerlink" title="2. 合并多次提交记录"></a>2. 合并多次提交记录</h3><p>合并最近两次commit:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> rebase -i HEAD~<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>执行命令后会自动进入 vi 编辑模式：</p><figure class="highlight plaintext"><figcaption><span>6935383 rename冲突</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pick">pick 23b1a51 debug<br><br># Rebase eb7f366..23b1a51 onto eb7f366 (2 commands)<br>#<br># Commands:<br># p, pick &lt;commit&gt; = use commit<br># r, reword &lt;commit&gt; = use commit, but edit the commit message<br># e, edit &lt;commit&gt; = use commit, but stop for amending<br># s, squash &lt;commit&gt; = use commit, but meld into previous commit<br># f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&#x27;s log message<br># x, exec &lt;command&gt; = run command (the rest of the line) using shell<br># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)<br># d, drop &lt;commit&gt; = remove commit<br># l, label &lt;label&gt; = label current HEAD with a name<br># t, reset &lt;label&gt; = reset HEAD to a label<br># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]<br># .       create a merge commit using the original merge commit&#x27;s<br># .       message (or the oneline, if no original merge commit was<br># .       specified). Use -c &lt;commit&gt; to reword the commit message.<br>#<br># These lines can be re-ordered; they are executed from top to bottom.<br>#<br># If you remove a line here THAT COMMIT WILL BE LOST.<br>#<br># However, if you remove everything, the rebase will be aborted.<br></code></pre></td></tr></table></figure><blockquote><p>【注】<br>p, pick = use commit<br>r, reword = use commit, but edit the commit message<br>e, edit = use commit, but stop for amending<br>s, squash = use commit, but meld into previous commit<br>f, fixup = like “squash”, but discard this commit’s log message<br>x, exec = run command (the rest of the line) using shell<br>d, drop = remove commit</p></blockquote><p>修改提交纪录并保存退出。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pick</span> <span class="hljs-number">6935383</span> rename冲突<br><span class="hljs-attribute">s</span> <span class="hljs-number">23</span>b<span class="hljs-number">1</span>a<span class="hljs-number">51</span> debug<br></code></pre></td></tr></table></figure><p>保存后到注释修改界面。</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># This is a combination of 2 commits.</span><br><span class="hljs-meta"># This is the 1st commit message:</span><br><br>rename冲突<br><br><span class="hljs-meta"># This is the commit message #2:</span><br><br>debug<br><br><span class="hljs-meta"># Please enter the commit message for your changes. Lines starting</span><br><span class="hljs-meta"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># Date:      Tue Nov 24 22:56:02 2020 +0800</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># interactive rebase in progress; onto eb7f366</span><br><span class="hljs-meta"># Last commands done (2 commands done):</span><br><span class="hljs-meta">#    pick 6935383 rename冲突</span><br><span class="hljs-meta">#    squash 23b1a51 debug</span><br><span class="hljs-meta"># No commands remaining.</span><br><span class="hljs-meta"># You are currently rebasing branch &#x27;maseter&#x27; on &#x27;eb7f366&#x27;.</span><br></code></pre></td></tr></table></figure><p>（非编辑状态输入dd删除一行）</p><p>保存后即合并完成。</p><blockquote><p>异常情况：<br>1、不要合并已提交远程分支的纪录<br>如果这样做，可能出现push rejected。 解决方式当然是先拉下远程的代码，进行冲突处理，再进行提交。<br>2、git rebase -i 异常操作导致退出了vim编辑页面，会提示：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ git rebase -i head~<span class="hljs-number">2</span><br><span class="hljs-keyword">error</span>: could <span class="hljs-keyword">not</span> apply <span class="hljs-number">040</span>bd4b... commit <span class="hljs-keyword">on</span> issue<span class="hljs-number">-005</span><br>Resolve all conflicts manually, mark them <span class="hljs-keyword">as</span> resolved <span class="hljs-keyword">with</span><br><span class="hljs-string">&quot;git add/rm &lt;conflicted_files&gt;&quot;</span>, <span class="hljs-keyword">then</span> <span class="hljs-built_in">run</span> <span class="hljs-string">&quot;git rebase --continue&quot;</span>.<br>You can instead skip this commit: <span class="hljs-built_in">run</span> <span class="hljs-string">&quot;git rebase --skip&quot;</span>.<br>To abort <span class="hljs-keyword">and</span> <span class="hljs-keyword">get</span> <span class="hljs-keyword">back</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span> state <span class="hljs-keyword">before</span> <span class="hljs-string">&quot;git rebase&quot;</span>, <span class="hljs-built_in">run</span> <span class="hljs-string">&quot;git rebase --abort&quot;</span>.<br>Could <span class="hljs-keyword">not</span> apply <span class="hljs-number">040</span>bd4b... commit <span class="hljs-keyword">on</span> issue<span class="hljs-number">-005</span><br>Auto-merging README.md<br>CONFLICT (content): Merge conflict <span class="hljs-keyword">in</span> README.md<br></code></pre></td></tr></table></figure><p>使用 git rebase –edit-todo 会再次进入刚才编辑错误退出前的vim状态，这时候可以修改你的编辑。<br>使用git rebase –abort  表明退出当前的合并请求( 又回到原来的2个commit的状态)</p></blockquote><h3 id="3-变基"><a href="#3-变基" class="headerlink" title="3. 变基"></a>3. 变基</h3><p>使用场景：本地与远端同一分支提交历史不一致</p><p>多个人在同一个分支上协作时，比如由我和A一同开发。我在修复了一个bug以后准备提交。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">add</span> .<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git commit -<span class="hljs-keyword">m</span> <span class="hljs-string">&quot;debug the world&quot;</span><br>[master a40d43c] <span class="hljs-keyword">debug</span> the world<br> <span class="hljs-number">1</span> <span class="hljs-keyword">file</span> changed, <span class="hljs-number">0</span> insertions(+), <span class="hljs-number">0</span> deletions(-)<br> create <span class="hljs-keyword">mode</span> <span class="hljs-number">100644</span> aa.txt<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git push origin master<br>To github.<span class="hljs-keyword">com</span>:Zhangtao153/learngit.git<br> ! [rejected]        master -&gt; master (non-fast-forward)<br>error: failed <span class="hljs-keyword">to</span> push some refs <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;github.com:Zhangtao153/learngit.git&#x27;</span><br>hin<span class="hljs-variable">t:</span> Updates were rejected because the tip of your current branch <span class="hljs-keyword">is</span> behind<br>hin<span class="hljs-variable">t:</span> its remote counterpart. Integrate the remote <span class="hljs-keyword">changes</span> (<span class="hljs-keyword">e</span>.g.<br>hin<span class="hljs-variable">t:</span> <span class="hljs-string">&#x27;git pull ...&#x27;</span>) before pushing again.<br>hin<span class="hljs-variable">t:</span> See the <span class="hljs-string">&#x27;Note about fast-forwards&#x27;</span> in <span class="hljs-string">&#x27;git push --help&#x27;</span> <span class="hljs-keyword">for</span> details.<br></code></pre></td></tr></table></figure><p>push失败了，说明A在我之前已经提交了，我本地master分支的提交历史已经落后远端了，需要先pull一下，与远端同步后才能push</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git pull<br>Merge made <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> README.md | <span class="hljs-number">3</span> ++-<br> <span class="hljs-number">1</span> <span class="hljs-built_in">file</span> changed, <span class="hljs-number">2</span> insertions(+), <span class="hljs-number">1</span> deletion(-)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--oneline --graph</span><br>*   <span class="hljs-number">912</span>bb85 (HEAD -&gt; master) Merge branch <span class="hljs-string">&#x27;master&#x27;</span> <span class="hljs-keyword">of</span> github.com:Zhangtao153/learngit <span class="hljs-keyword">into</span> master<br>|\<br>| * <span class="hljs-number">7</span>ad4fd6 (origin/master) <span class="hljs-built_in">add</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span><br>* | a40d43c debug <span class="hljs-keyword">the</span> world<br>|/<br>* a8d2e0d 手动删除<br>* <span class="hljs-number">1</span>d243ca <span class="hljs-built_in">add</span> test <span class="hljs-built_in">file</span><br>* <span class="hljs-number">8438389</span> wrote <span class="hljs-keyword">a</span> readme <span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure><p>竟然分叉了！由于我本地master的提交历史和远端的master分支的提交历史不一致，所以git为我进行了自动合并，然后生成了一个新的提交历史。</p><p>这个时候就可以用 git rebase 解决分叉的问题。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git rebase<br>Successfully rebased <span class="hljs-keyword">and</span> updated refs/heads/master.<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br><span class="hljs-symbol">$</span> git <span class="hljs-built_in">log</span> --oneline --graph<br><span class="hljs-comment">* 4178b6e (HEAD -&gt; master) debug the world</span><br><span class="hljs-comment">* 7ad4fd6 (origin/master) add a new function</span><br><span class="hljs-comment">* a8d2e0d 手动删除</span><br><span class="hljs-comment">* 1d243ca add test file</span><br><span class="hljs-comment">* 8438389 wrote a readme file</span><br></code></pre></td></tr></table></figure><p>然后再push，将本地修改同步到远端。</p><p>git pull –rebase 和上面的效果一致。</p><h3 id="4-合并分支"><a href="#4-合并分支" class="headerlink" title="4. 合并分支"></a>4. 合并分支</h3><p>先创建一个分支用于解决bug</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git checkout -b issues<span class="hljs-number">-001</span><br>Switched <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> branch <span class="hljs-string">&#x27;issues-001&#x27;</span><br></code></pre></td></tr></table></figure><p>接下解决bug，然后保存提交</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (issues-<span class="hljs-number">001</span>)<br>$ git add .<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (issues-<span class="hljs-number">001</span>)<br>$ git commit -m <span class="hljs-string">&quot;issues-001&quot;</span><br>[issues-<span class="hljs-number">001</span> <span class="hljs-number">7</span>a55a26] issues-<span class="hljs-number">001</span><br> <span class="hljs-number">1</span> <span class="hljs-keyword">file</span> changed, <span class="hljs-number">1</span> insertion(+)<br></code></pre></td></tr></table></figure><p>先尝试通过 merge 合并：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issues<span class="hljs-number">-001</span>)<br>$ git <span class="hljs-keyword">switch</span> master<br>Switched <span class="hljs-built_in">to</span> branch <span class="hljs-string">&#x27;master&#x27;</span><br>Your branch is ahead <span class="hljs-keyword">of</span> <span class="hljs-string">&#x27;origin/master&#x27;</span> <span class="hljs-keyword">by</span> <span class="hljs-number">1</span> commit.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> <span class="hljs-built_in">to</span> publish your <span class="hljs-built_in">local</span> commits)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">merge</span> issues<span class="hljs-number">-001</span><br>Merge made <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> aa.txt | <span class="hljs-number">1</span> +<br> <span class="hljs-number">1</span> <span class="hljs-built_in">file</span> changed, <span class="hljs-number">1</span> insertion(+)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--oneline --graph</span><br>*   ae02ea0 (HEAD -&gt; master) Merge branch <span class="hljs-string">&#x27;issues-001&#x27;</span> <span class="hljs-keyword">into</span> master<br>|\<br>| * <span class="hljs-number">7</span>a55a26 (issues<span class="hljs-number">-001</span>) issues<span class="hljs-number">-001</span><br>* | d36d166 commit <span class="hljs-keyword">on</span> <span class="hljs-title">master</span><br>|/<br>* <span class="hljs-number">4178</span>b6e (origin/master) debug <span class="hljs-keyword">the</span> world<br>* <span class="hljs-number">7</span>ad4fd6 <span class="hljs-built_in">add</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span><br>* a8d2e0d 手动删除<br>* <span class="hljs-number">1</span>d243ca <span class="hljs-built_in">add</span> test <span class="hljs-built_in">file</span><br>* <span class="hljs-number">8438389</span> wrote <span class="hljs-keyword">a</span> readme <span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure><p>虽然合并成功，但是Master已经保存了合并历史，出现开叉了！</p><p>通过rebase合并分支</p><p>先将代码回退到merge之前</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^</span><br>HEAD <span class="hljs-keyword">is</span> now at d36d166 <span class="hljs-keyword">commit</span> <span class="hljs-keyword">on</span> master<br></code></pre></td></tr></table></figure><p>先切换回issues-001分支，在issues-001分支上执行: git rebase master</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (master)<br>$ git <span class="hljs-keyword">switch</span> issues-<span class="hljs-number">001</span><br>Switched to branch <span class="hljs-string">&#x27;issues-001&#x27;</span><br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (issues-<span class="hljs-number">001</span>)<br>$ git rebase master<br>Successfully rebased and updated refs<span class="hljs-regexp">/heads/i</span>ssues-<span class="hljs-number">001</span>.<br></code></pre></td></tr></table></figure><p>【注】如果rebase出现冲突，先解决冲突，然后通过add添加，之前的rebase其实只是完成了一半，由于出现冲突而终止，冲突解决之后，可以通过git rebase —continue继续完成之前的rebase操作。</p><p>切换到主分支master，将issues-001分支上的提交合并过来。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issues<span class="hljs-number">-001</span>)<br>$ git <span class="hljs-keyword">switch</span> master<br>Switched <span class="hljs-built_in">to</span> branch <span class="hljs-string">&#x27;master&#x27;</span><br>Your branch is ahead <span class="hljs-keyword">of</span> <span class="hljs-string">&#x27;origin/master&#x27;</span> <span class="hljs-keyword">by</span> <span class="hljs-number">1</span> commit.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> <span class="hljs-built_in">to</span> publish your <span class="hljs-built_in">local</span> commits)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">merge</span> issues<span class="hljs-number">-001</span><br>Updating d36d166.<span class="hljs-number">.43823</span>d4<br>Fast-forward<br> aa.txt | <span class="hljs-number">1</span> +<br> <span class="hljs-number">1</span> <span class="hljs-built_in">file</span> changed, <span class="hljs-number">1</span> insertion(+)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--oneline --graph</span><br>* <span class="hljs-number">43823</span>d4 (HEAD -&gt; master, issues<span class="hljs-number">-001</span>) issues<span class="hljs-number">-001</span><br>* d36d166 commit <span class="hljs-keyword">on</span> <span class="hljs-title">master</span><br>* <span class="hljs-number">4178</span>b6e (origin/master) debug <span class="hljs-keyword">the</span> world<br>* <span class="hljs-number">7</span>ad4fd6 <span class="hljs-built_in">add</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span><br>* a8d2e0d 手动删除<br>* <span class="hljs-number">1</span>d243ca <span class="hljs-built_in">add</span> test <span class="hljs-built_in">file</span><br>* <span class="hljs-number">8438389</span> wrote <span class="hljs-keyword">a</span> readme <span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure><p>master是一条直线了。最后删除掉issues-001分支。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (master)<br>$ git branch -d issues-<span class="hljs-number">001</span><br>Deleted branch issues-<span class="hljs-number">001</span> (was <span class="hljs-number">43823</span>d4).<br></code></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——java8新特性之Lambda 表达式</title>
    <link href="/2021/11/28/java%E2%80%94%E2%80%94jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/11/28/java%E2%80%94%E2%80%94jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><blockquote><p>lambda 表达式本质上是一段匿名内部类，也可以是一段可以传递的代码</p></blockquote><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h4><p>完整的 Lambda 表达式由三部分组成：参数列表、箭头、声明语句；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> (Type1 param1, Type2 param2, ..., TypeN paramN) ‐&gt; &#123; statment1;<br>statment2; <span class="hljs-comment">//............. return statmentM;&#125;</span><br></code></pre></td></tr></table></figure><ol><li>绝大多数情况，编译器都可以从上下文环境中推断出lambda表达式的参数类型，所以参数可以省略：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(param1,param2, ..., paramN) ‐&gt; &#123; statment1; statment2; <span class="hljs-comment">//............. r</span><br>eturn statmentM;&#125;<br></code></pre></td></tr></table></figure></li><li>当lambda表达式的参数个数只有一个，可以省略小括号：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">param1 ‐&gt; &#123; statment1; statment2; <span class="hljs-comment">//............. return statmentM;&#125;</span><br></code></pre></td></tr></table></figure></li><li>当lambda表达式只包含一条语句时，可以省略大括号、return和语句结尾的分号：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">param1 ‐&gt; statment<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-函数接口"><a href="#2-函数接口" class="headerlink" title="2. 函数接口"></a>2. 函数接口</h4><p>函数接口是只有一个抽象方法的接口， 用作 Lambda 表达式的返回类型。<br>包路径为 java.util.function 接口类上面都有@FunctionalInterface这个注解。</p><h4 id="3-类型检查、类型推断"><a href="#3-类型检查、类型推断" class="headerlink" title="3.  类型检查、类型推断"></a>3.  类型检查、类型推断</h4><p>Java编译器根据 Lambda 表达式上下文信息就能推断出参数的正确类型。 程序依然要经过类型检查来保证运行的安全性， 但不用再显式声明类型罢了。 这就是所谓的类型推断。</p><h4 id="4-局部变量限制"><a href="#4-局部变量限制" class="headerlink" title="4.  局部变量限制"></a>4.  局部变量限制</h4><p>Lambda表达式也允许使用自由变量（不是参数，而是在外层作用域中定义的变量），就像匿名类一样。 它们被称作捕获Lambda。 Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为final，或事实上是final。</p><p>Lambda 表达式访问外部变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String[] strings = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;;<br>    <span class="hljs-keyword">for</span> (Integer i : Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)) &#123;<br>        Stream.of(strings).map(string -&gt; string + i).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>为什么局部变量有这些限制？<br>实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。因此， Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] strings = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>    Stream.of(strings).map(string -&gt; string + i).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>上面的代码会报编译错误，lambda 表达式引用的变量需要时final或等效final的变量。</strong></p><h4 id="5-Lambda表达式的方法和构造器引用"><a href="#5-Lambda表达式的方法和构造器引用" class="headerlink" title="5.  Lambda表达式的方法和构造器引用"></a>5.  Lambda表达式的方法和构造器引用</h4><p>方法引用的语法格式有以下三种：</p><ol><li>objectName::instanceMethod</li><li>ClassName::staticMethod</li><li>ClassName::instanceMethod</li></ol><blockquote><p>前两种等同于把lambda表达式的参数当成 instanceMethod | staticMethod 的参数来调用。<br>例如： Math::max等同于(x, y)-&gt;Math.max(x,y)</p><p>后一种等于把lambda表达式的第一个参数当成instanceMethod 的目标对象，其他参数当成该方法的参数。<br>例如： String::toLowerCase() 等同于 x-&gt;x.toLowerCase()</p></blockquote><p><em>构造器引用语法如下</em></p><p>ClassName::new</p><blockquote><p>把 lambda 表达式的参数当成 ClassName 构造器的参数。例如： BigDecimal::new 等同于 x-&gt;new BigDecimal(x)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java,java8新特性 - java - java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis——入门</title>
    <link href="/2021/11/28/Redis%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"/>
    <url>/2021/11/28/Redis%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-NoSQL介绍"><a href="#1-NoSQL介绍" class="headerlink" title="1.  NoSQL介绍"></a>1.  NoSQL介绍</h2><p>NoSQL （Not Only SQL）指的是非关系型的数据库，是对不同于传统的关系型数据库的数据库管理系统的统称。NoSQL用于超大规模数据的存储。Redis就属于非关系型数据库,传统的Mysql ,oracle ,sql server 等 都是关系型数据库。</p><h2 id="2-为什么需要NoSQL"><a href="#2-为什么需要NoSQL" class="headerlink" title="2. 为什么需要NoSQL"></a>2. 为什么需要NoSQL</h2><p>主要应对以下问题时，传统关系型数据库力不从心</p><p>  高并发读写<br>  海量数据的高效率存储和访问<br>  高可扩展性和高可用性</p><h2 id="3-Redis-简介"><a href="#3-Redis-简介" class="headerlink" title="3. Redis 简介"></a>3. Redis 简介</h2><p>Redis 是一个高性能的 key-value 数据库。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><p>Redis 与其他 key - value 缓存产品相比有以下三个特点：<br>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。<br>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>Redis支持数据的备份，即master-slave模式的数据备份。<br>Redis的应用场景<br>缓存<br>任务队列<br>网站访问统计<br>数据过期处理<br>应用排行榜<br>分布式集群架构中的session分离<br>Redis 支持的五种数据类型：<br>字符串（String）<br>字符串列表（list）<br>哈希（hash）<br>字符串集合（set）<br>有序字符串集合（zset）</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
