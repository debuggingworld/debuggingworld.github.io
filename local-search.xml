<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>大模型评测——OpenCompass</title>
    <link href="/2025/06/14/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AF%84%E6%B5%8B%E2%80%94%E2%80%94OpenCompass/"/>
    <url>/2025/06/14/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E8%AF%84%E6%B5%8B%E2%80%94%E2%80%94OpenCompass/</url>
    
    <content type="html"><![CDATA[<h3 id="大模型评测体系">1. 大模型评测体系</h3><p>　　大模型的评测可以分为 3个关键组成部分：“评什么”(维度、指标、数据)、 “怎么评”(模式、流程)、“评到什么程度”(主客观指标、基准与专项评测集)。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506150918489.png" style="zoom:60%;" /></p><h4 id="大模型评测维度">1.1 大模型评测维度</h4><p>　　大模型的评测维度，一般可以分为3个，分别是通用能力、场景应用、行业应用。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506150920096.png" style="zoom:60%;" /></p><h4 id="大模型评测方法">1.2 大模型评测方法</h4><p>　　　模型的评测方法，主要有3种，分别是：客观性评测、基于人的主观性评测、基于模型的评测。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506150923502.png" style="zoom:60%;" /></p><h4 id="大模型评测指标">1.3 大模型评测指标</h4><p>　　大模型的评测指标，主要分为客观评测指标、主观评测指标。</p><h5 id="客观评测指标">1. 客观评测指标</h5><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506150927263.png" style="zoom:60%;" /></p><h5 id="主观评测指标">2. 主观评测指标</h5><p><img src="https://pic4.zhimg.com/v2-e9258a17a26aa1bd3bcdfe26106bbe57_1440w.jpg" alt="img" style="zoom:60%;" /></p><h4 id="大模型公开评测集">1.4 大模型公开评测集</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506150932306.png" style="zoom:60%;" /></p><h3 id="opencompass-评测">2. OpenCompass 评测</h3><p><ahref="https://doc.opencompass.org.cn/zh_CN/latest/index.html">文档</a></p><p><strong>OpenCompass支持以下主要评估指标，覆盖生成式大模型的多样化需求</strong>：</p><ul><li><p>准确率（Accuracy）：用于选择题或分类任务，通过比对生成结果与标准答案计算正确率。在OpenCompass中通过metric=accuracy配置</p></li><li><p>困惑度（Perplexity,PPL）：衡量模型对候选答案的预测能力，适用于选择题评估。需使用ppl类型的数据集配置（如ceval_ppl）</p></li><li><p>生成质量（GEN）：通过文本生成结果提取答案，需结合后处理脚本解析输出。使用gen类型的数据集（如ceval_gen），配置metric=gen并指定后处理规则</p></li><li><p>ROUGE/LCS：用于文本生成任务的相似度评估，需安装rouge==1.0.1依赖，并在数据配置中设置metric=rouge</p></li><li><p>条件对数概率（CLP）：结合上下文计算答案的条件概率，适用于复杂推理任务，需在模型配置中启用use_logprob=True</p></li></ul><p><strong>OpenCompass内置超过70个数据集，覆盖五大能力维度：</strong></p><ul><li><p>知识类：C-Eval（中文考试题）、CMMLU（多语言知识问答）、MMLU（英文多选题）。</p></li><li><p>推理类：GSM8K（数学推理）、BBH（复杂推理链）。</p></li><li><p>语言类：CLUE（中文理解）、AFQMC（语义相似度）。</p></li><li><p>代码类：HumanEval（代码生成）、MBPP（编程问题）。</p></li><li><p>多模态类：MMBench（图像理解）、SEED-Bench（多模态问答）。</p></li></ul><h4 id="安装">2.1 安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/open-compass/opencompass opencompass<br>cd opencompass<br>pip install -e .<br></code></pre></td></tr></table></figure><p>【注】python=3.10</p><h4 id="数据集准备">2.2 数据集准备</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">wget https://github.com/open-compass/opencompass/releases/download/0.2.2.rc1/OpenCompassData-core-20240207.zip<br>unzip OpenCompassData-core-20240207.zip<br></code></pre></td></tr></table></figure><h4 id="命令行自定义hf模型评测">2.3 命令行（自定义HF模型）评测</h4><p>　　对于 HuggingFace模型，用户可以通过命令行直接设置模型参数，无需额外的配置文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell">python run.py \<br>    --datasets demo_gsm8k_chat_gen demo_math_chat_gen \<br>    --hf-type chat \<br>    --hf-path /root/autodl-tmp/models/Qwen/Qwen3-4B \<br>    --batch-size  16<br></code></pre></td></tr></table></figure><blockquote><p>模型和数据集的配置文件预存于 <code>configs/models</code> 和<code>configs/datasets</code> 中。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 查看所有数据集和模型</span><br>python tools/list_configs.py<br><span class="hljs-meta">#</span><span class="bash"> 指定条件过滤</span><br>python tools/list_configs.py llama mmlu<br></code></pre></td></tr></table></figure></blockquote><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506151533133.png" style="zoom:50%;" /></p><blockquote><p>在 <code>--debug</code>模式下，任务将按顺序执行，并实时打印输出。</p></blockquote><p><strong>debug模式</strong>：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506151530658.png" style="zoom:50%;" /></p><p>非debug模型：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506151602847.png" style="zoom:50%;" /></p><p>评测完成：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506151540749.png" style="zoom:50%;" /></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506151541338.png" style="zoom:50%;" /></p><h4 id="命令行评测">2.4 命令行评测</h4><p>　　<strong>修改配置文件:</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506151629038.png" style="zoom:50%;" /></p><p>　　qwen2 没有 hf 配置文件，修改 qwen2 配置文件hf_qwen2_5_7b_instruct：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506151635771.png" style="zoom:40%;" /></p><p>　　用户可以使用 <code>--models</code> 和 <code>--datasets</code>结合想测试的模型和数据集。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">python run.py \<br>    --models hf_qwen2_5_7b_instruct \<br>    --datasets demo_gsm8k_chat_gen demo_math_chat_gen \<br>    --debug<br></code></pre></td></tr></table></figure><h4 id="配置文件评测">2.5 配置文件评测</h4><p>　　除了通过命令行配置实验外，OpenCompass还允许用户在配置文件中编写实验的完整配置，并通过 <code>run.py</code>直接运行它。配置文件是以 Python 格式组织的，并且必须包括<code>datasets</code> 和 <code>models</code> 字段。</p><p>　　添加配置文件 configs/eval_chat_demo.py ：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> mmengine.config <span class="hljs-keyword">import</span> read_base<br><br><span class="hljs-keyword">with</span> read_base():<br>    <span class="hljs-keyword">from</span> .datasets.demo.demo_gsm8k_chat_gen <span class="hljs-keyword">import</span> gsm8k_datasets<br>    <span class="hljs-keyword">from</span> .datasets.demo.demo_math_chat_gen <span class="hljs-keyword">import</span> math_datasets<br>    <span class="hljs-keyword">from</span> .models.qwen2_5.hf_qwen2_5_7b_instruct <span class="hljs-keyword">import</span> models <span class="hljs-keyword">as</span> hf_qwen2_5_7b_instruct<br>    <span class="hljs-keyword">from</span> .models.qwen.hf_qwen2_1_5b_instruct <span class="hljs-keyword">import</span> models <span class="hljs-keyword">as</span> hf_qwen2_1_5b_instruct_models<br>    <span class="hljs-keyword">from</span> .models.hf_internlm.hf_internlm2_chat_1_8b <span class="hljs-keyword">import</span> models <span class="hljs-keyword">as</span> hf_internlm2_chat_1_8b_models<br><br>datasets = gsm8k_datasets + math_datasets<br>models = hf_qwen2_5_7b_instruct<br></code></pre></td></tr></table></figure><p>　　执行评测任务：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python run.py opencompass/configs/eval_chat_demo.py --debug<br></code></pre></td></tr></table></figure><h4 id="评测加速">2.6 评测加速</h4><p>　　在 OpenCompass 评测过程中，默认使用 Huggingface 的 transformers库进行推理，这是一个非常通用的方案，但在某些情况下，我们可能需要更高效的推理方法来加速这一过程，比如借助VLLM 或 LMDeploy。</p><h5 id="评测时使用-vllm-或-lmdeploy">1. 评测时使用 VLLM 或 LMDeploy</h5><p>　　以 LMDeploy 为例：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506151700521.png" style="zoom:40%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">python run.py \<br>    --models lmdeploy_qwen3_0_6b \<br>    --datasets demo_gsm8k_chat_gen demo_math_chat_gen<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506151711681.png" style="zoom:40%;" /></p><h5 id="api加速评测">2. API加速评测</h5><p>修改配置文件：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> opencompass.models <span class="hljs-keyword">import</span> OpenAISDK<br><br>api_meta_template = <span class="hljs-built_in">dict</span>(<br>    <span class="hljs-built_in">round</span>=[<br>        <span class="hljs-built_in">dict</span>(role=<span class="hljs-string">&#x27;HUMAN&#x27;</span>, api_role=<span class="hljs-string">&#x27;HUMAN&#x27;</span>),<br>        <span class="hljs-built_in">dict</span>(role=<span class="hljs-string">&#x27;BOT&#x27;</span>, api_role=<span class="hljs-string">&#x27;BOT&#x27;</span>, generate=<span class="hljs-literal">True</span>),<br>    ],<br>    reserved_roles=[<span class="hljs-built_in">dict</span>(role=<span class="hljs-string">&#x27;SYSTEM&#x27;</span>, api_role=<span class="hljs-string">&#x27;SYSTEM&#x27;</span>)],<br>)<br><br>models = [<br>    <span class="hljs-built_in">dict</span>(<br>        abbr=<span class="hljs-string">&#x27;qwen_3_0.6b_thinking-turbomind&#x27;</span>,<br>        <span class="hljs-comment"># path=&#x27;Qwen/Qwen3-0.6B&#x27;,</span><br>        <span class="hljs-built_in">type</span>=OpenAISDK,<br>        key=<span class="hljs-string">&#x27;EMPTY&#x27;</span>, <span class="hljs-comment"># API key</span><br>        openai_api_base=<span class="hljs-string">&#x27;http://0.0.0.0:23333/v1&#x27;</span>, <span class="hljs-comment"># 服务地址</span><br>        path=<span class="hljs-string">&#x27;Qwen3-4&#x27;</span>, <span class="hljs-comment"># 请求服务时的 model name</span><br>        tokenizer_path=<span class="hljs-string">&#x27;/root/autodl-tmp/models/Qwen/Qwen3-4B&#x27;</span>, <span class="hljs-comment"># 分词器路径</span><br>        rpm_verbose=<span class="hljs-literal">True</span>, <span class="hljs-comment"># 是否打印请求速率</span><br>        meta_template=api_meta_template, <span class="hljs-comment"># 服务请求模板</span><br>        query_per_second=<span class="hljs-number">1</span>, <span class="hljs-comment"># 服务请求速率</span><br>        max_seq_len=<span class="hljs-number">32768</span>,<br>        max_out_len=<span class="hljs-number">32000</span>,<br>        temperature=<span class="hljs-number">0.01</span>, <span class="hljs-comment"># 生成温度</span><br>        batch_size=<span class="hljs-number">8</span>, <span class="hljs-comment"># 批处理大小</span><br>        retry=<span class="hljs-number">3</span>, <span class="hljs-comment"># 重试次数</span><br>    ),<br>]<br></code></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">python run.py     --models lmdeploy_qwen3_0_6b     --datasets demo_gsm8k_chat_gen demo_math_chat_gen --debug<br></code></pre></td></tr></table></figure><h4 id="自定义数据集评测">2.7 自定义数据集评测</h4><p><ahref="https://doc.opencompass.org.cn/zh_CN/latest/advanced_guides/custom_dataset.html">文档</a></p><ol type="1"><li><p>添加自定义评测集</p><p>opencompass/datasets/my_dataset.jsonl</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<span class="hljs-attr">&quot;question&quot;</span>: <span class="hljs-string">&quot;752+361+181+933+235+986=&quot;</span>, <span class="hljs-attr">&quot;answer&quot;</span>: <span class="hljs-string">&quot;3448&quot;</span>&#125;<br>&#123;<span class="hljs-attr">&quot;question&quot;</span>: <span class="hljs-string">&quot;712+165+223+711=&quot;</span>, <span class="hljs-attr">&quot;answer&quot;</span>: <span class="hljs-string">&quot;1811&quot;</span>&#125;<br>&#123;<span class="hljs-attr">&quot;question&quot;</span>: <span class="hljs-string">&quot;921+975+888+539=&quot;</span>, <span class="hljs-attr">&quot;answer&quot;</span>: <span class="hljs-string">&quot;3323&quot;</span>&#125;<br>&#123;<span class="hljs-attr">&quot;question&quot;</span>: <span class="hljs-string">&quot;752+321+388+643+568+982+468+397=&quot;</span>, <span class="hljs-attr">&quot;answer&quot;</span>: <span class="hljs-string">&quot;4519&quot;</span>&#125;<br></code></pre></td></tr></table></figure></li><li><p>执行评测</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">python run.py \<br>    --hf-path /root/autodl-tmp/models/Qwen/Qwen3-4B \<br>    --custom-dataset-path /root/autodl-tmp/opencompass/opencompass/datasets/my_dataset.jsonl  --debug<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>模型评测</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模型压缩——知识蒸馏</title>
    <link href="/2025/06/12/%E6%A8%A1%E5%9E%8B%E5%8E%8B%E7%BC%A9%E2%80%94%E2%80%94%E8%92%B8%E9%A6%8F/"/>
    <url>/2025/06/12/%E6%A8%A1%E5%9E%8B%E5%8E%8B%E7%BC%A9%E2%80%94%E2%80%94%E8%92%B8%E9%A6%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是知识蒸馏">1. 什么是知识蒸馏</h3><p>　　知识蒸馏（KnowledgeDistillation）是一种在模型压缩和迁移学习领域非常重要的技术。其核心思想是先训练一个复杂网络模型，然后使用这个复杂网络的输出和数据的真实标签去训练一个更小的网络，从而在保持高精度的同时，显著减少模型的参数量和计算量。其中复制的模型被称为Teacher 模型，小模型被称为 Student 模型。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506121906484.png" style="zoom:67%;" /></p><p>　　知识蒸馏采用 Teacher-Student模式，即使用复杂且大型的模型作为教师（Teacher），辅助结构较为简单的学生模型（Student）的训练。教师模型由于学习能力强，可以将学到的知识迁移给学习能力相对弱的学生模型，从而增强学生模型的泛化能力。复杂但效果好的教师模型不会上线使用，而是作为导师角色，真正部署进行预测任务的是灵活轻巧的学生模型。</p><p>知识蒸馏是对模型能力的迁移，根据迁移方法的不同，可以分为以下两大方向：</p><ul><li>基于目标蒸馏（也称 Soft-target 蒸馏或 Logits方法蒸馏）：通过教师模型的输出软标签来指导学生模型。</li><li>基于特征蒸馏：通过教师模型的中间层特征来指导学生模型。</li></ul><h3 id="知识蒸馏的作用">2. 知识蒸馏的作用</h3><p>知识蒸馏的作用可以概况为以下三种：</p><ul><li><p>提升模型精度</p><p>如果对目前的网络模型 A 的精度不是很满意，那么可以先训练一个更高精度的teacher 模型 B（通常参数量更多，推理延迟时间更长），然后用这个训练好的teacher 模型 B 对 student 模型 A 进行知识蒸馏，得到一个更高精度的 A模型。</p></li><li><p>降低模型时延，压缩网络参数</p><p>如果对目前的网络模型 A的推理延迟或模型大小不满意，可以先找到一个推理延迟更低，参数量更小的模型B，通常来讲，这种模型精度也会比较低，然后使用网络模型 A对这个参数量小的模型 B 进行知识蒸馏，使得该模型 B 的精度接近模型 A的同时，能达到降低推理延迟和减小模型大小的目的。</p></li><li><p>标签之间的域迁移</p><p>假如使用狗和猫的数据集训练了一个 teacher 模型A，使用香蕉和苹果训练了一个 teacher 模型B，那么就可以用这两个模型同时蒸馏出一个可以识别狗、猫、香蕉以及苹果的模型，将两个不同域的数据集进行集成和迁移。</p></li></ul><h3 id="知识蒸馏与从头训练的区别">3. 知识蒸馏与从头训练的区别</h3><p>　　使用教师模型 B 对学生模型 A 进行蒸馏训练，与直接用数据集训练模型A 相比，主要区别在于知识传递和优化路径。</p><p>　　模型 B已经在搜索空间中找到最优或次优的参数组合，这些知识通过软标签传递给模型A，缩小了其搜索空间，使模型 A不仅从数据中学习，还从教师模型的预测中获取丰富信息，能更快地找到有效参数组合，从而在较短时间内达到较高性能。</p><p>　　相比之下，直接训练模型 A需要从随机初始化开始，在模型整个搜索空间中查找参数最优解，所以优化难度大，训练时间长，且容易陷入局部最优解。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506121909733.png" style="zoom:70%;" /></p><h3 id="基于目标蒸馏">4. 基于目标蒸馏</h3><p>　　目标蒸馏方法中最经典的论文就是来自于 2015 年 Hinton发表的一篇神作<a href="https://arxiv.org/abs/1503.02531">《Distillingthe Knowledge in a Neural Network》</a>。在这篇论文中，Hinton将问题限定在分类问题下，分类问题的共同点是模型最后会有一个 Softmax层，其输出值对应了相应类别的概率值。在知识蒸馏时，由于我们已经有了一个泛化能力较强的Teacher 模型，我们在利用 Teacher 模型来蒸馏训练 Student模型时，可以直接让 Student 模型去学习 Teacher模型的泛化能力。一个很直白且高效的迁移泛化能力的方法就是：使用 Softmax层输出的类别的概率来作为 Soft-target 。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506121911361.png" style="zoom:40%;" /></p><h4 id="hard-target-和-soft-target">4.1 Hard-target 和 Soft-target</h4><p>　　传统的神经网络训练方法是定义一个损失函数，目的是让模型的预测尽可能接近真实值（Hard-target），损失函数的设计旨在最小化神经网络的预测与真实标签之间的差异，从而使得模型能够准确地预测数据的真实性（即对ground truth 求极大似然）。在基于目标的知识蒸馏中，比较特别的是使用了Teacher 模型的预测类别概率作为 Soft-target 来指导学生模型的训练。</p><ul><li>Hard-target：原始数据集标注的 one-hot 标签，除了正标签为1，其他负标签都是 0。</li><li>Soft-target：Teacher 模型 Softmax层输出的类别概率，每个类别都分配了概率，正标签的概率最高。</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506121913026.png" style="zoom:70%;" /></p><p>　　知识蒸馏用 Teacher 模型预测的 Soft-target 来辅助 Hard-target 训练Student 模型的方式为什么有效呢？Softmax层的输出，除了正例之外，负标签也带有 Teacher模型归纳推理的大量信息，比如某些负标签对应的概率远远大于其他负标签，则代表Teacher模型在推理时认为该样本与该负标签有一定的相似性。而在传统的训练过程（Hard-target）中，所有负标签都被统一对待。也就是说，知识蒸馏的训练方式使得每个样本给Student 模型带来的信息量大于传统的训练方式。</p><p>　　如在 MNIST 数据集中做手写体数字识别任务，假设某个输入的 "2"更加形似 "3"，Softmax 的输出值中 "3"对应的概率会比其他负标签类别高；而另一个 "2" 更加形似"7"，则这个样本分配给 "7" 对应的概率会比其他负标签类别高。这两个 "2"对应的 Hard-target 的值是相同的，但是它们的 Soft-target却是不同的，由此我们可见 Soft-target 蕴含着比 Hard-target更多的信息。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506121915596.png" style="zoom:70%;" /></p><p>　　在使用 Soft-target 训练时，Student 模型可以很快学习到 Teacher模型的推理过程；而传统的 Hard-target的训练方式，所有的负标签都会被平等对待。因此，Soft-target 给Student模型带来的信息量要大于 Hard-target，并且 Soft-target分布的熵相对高时，其 Soft-target 蕴含的知识就更丰富。同时，使用Soft-target训练时，梯度的方差会更小，训练时可以使用更大的学习率，所需要的样本也更少。这也解释了为什么通过蒸馏的方法训练出的Student 模型相比使用完全相同的模型结构和训练数据只使用 Hard-target的训练方法得到的模型，拥有更好的泛化能力。</p><h4 id="蒸馏温度">4.2 蒸馏温度</h4><p>　　Logits 是深度神经网络中未经 Softmax处理的输出值，它们代表了模型在每个类别上的得分或概率（未归一化）。在分类问题中，这些logits 汇总了网络内部对各个类别的信息，每个 logits表示输入属于对应类别的得分，而不是概率。假设有一个分类任务，最后一个输出层是全连接层，则它的直接输出就是logits，可以用一个向量 z 表示： <span class="math display">\[z=\left[z_1, z_2, \ldots, z_n\right]\]</span> 其中：</p><p>（1）n 是总的类别数。</p><p>（2）<span class="math inline">\(z_i\)</span> 是第 i个类别的预测得分。</p><p>　　在分类任务重，我们通常不直接使用 logits，而是用 Softmax 函数将logits 转换为概率分布，使得这些概率之和为 1。logits 经 Softmax函数处理后各类的概率如下： <span class="math display">\[q_i=\frac{\exp \left(z_i\right)}{\sum_{j=1}^n \exp \left(z_j\right)}\]</span> 其中：</p><p>（1）n 是总的类别数。</p><p>（2）<span class="math inline">\(z_i\)</span> 是第 i个类别的预测得分。</p><p>（3）<span class="math inline">\(q_i\)</span> 是第 i个类别的预测概率。</p><p>　　但是直接使用 Softmax 层的输出值 q 作为 Soft-target会带来一个问题，当 Softmax 输出的概率分布熵较小时，某些类别的概率会接近0 或 1，这可能导致得到的 Soft-target 近似于 Hard-target，从而失去了Soft-target 的优势和信息。一种常见的解决方法是引入蒸馏温度参数 𝑇，通过缩放 logits 来调节 Softmax 输出的概率分布。温度调节可以使 Softmax输出的概率分布更加平滑，减少极端概率值的出现，从而提高 Soft-target的有效性。下面的公式是加了蒸馏温度之后的 Softmax 函数： <spanclass="math display">\[q^T_i=\frac{\exp \left(z_i / T\right)}{\sum_{j=1}^n \exp \left(z_j /T\right)}\]</span> 其中：</p><p>（1）n 是总的类别数。</p><p>（2）<span class="math inline">\(z_i\)</span> 是第 i个类别的预测得分。</p><p>（3）T 是蒸馏温度参数，通常是高温蒸馏，即 T&gt;1。</p><p>（4）<span class="math inline">\(q_i^T\)</span> 是经温度 T 修正后的第i 个类别的预测概率。</p><p>温度参数 T 有这样几个特点：</p><ul><li>当 T=1 时，Softmax 函数为标准的 Softmax 函数，即没有温度调节。</li><li>当 T&lt;1 时，Softmax 函数输出的概率差异变大，即概率分布比标准Softmax 函数的输出更不均匀。</li><li>当 T→0 时，Softmax 函数输出的概率分布接近Hard-target，即输出概率接近 0 或 1。</li><li>当 T&gt;1 时，Softmax 函数输出的概率差异变小，即概率分布比标准Softmax 函数的输出更均匀。</li><li>当 T→+∞ 时，Softmax函数输出的概率接近接近均匀分布，即每个类别的概率相等。</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506121935701.png" style="zoom:70%;" /></p><p>　　温度的高低改变的是 Student模型训练过程中对负标签的关注程度。当温度较低时，对负标签的关注，尤其是那些显著低于平均值的负标签的关注较少；而温度较高时，负标签相关的值会相对增大，Student模型会相对更多地关注到负标签。</p><p>　　实际上，负标签中包含一定的信息，尤其是那些负标签概率值显著高于平均值的负标签。但由于Teacher模型的训练过程决定了负标签部分概率值都比较小，并且负标签的值越低，其信息就越不可靠。因此温度的选取需要进行实际实验的比较，本质上就是在下面两种情况之中取舍:</p><ul><li>当想从负标签中学到一些信息量的时候，温度 T 应调高一些；</li><li>当想减少负标签的干扰的时候，温度 T 应调低一些；</li></ul><p>　　总的来说，T 的选择和 Student 模型的大小有关，Student模型参数量比较小的时候，相对比较低的温度就可以了。因为参数量小的模型不能学到所有Teacher 模型的知识，所以可以适当忽略掉一些负标签的信息。</p><blockquote><p>在实际 T 可以初步设置为 2 或 3 然后逐步增加，以确定最优的蒸馏温度T。</p></blockquote><p>　　在整个知识蒸馏过程中，在训练阶段，我们先让温度 T升高。在测试阶段，再恢复正常温度（T=1），从而将原模型中的知识提取出来，因此将其称为是蒸馏。</p><p><ahref="https://blog.csdn.net/tsyccnh/article/details/79163834">信息量、交叉熵</a></p><h4 id="目标蒸馏的实现步骤">4.3 目标蒸馏的实现步骤</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506121939539.png" /></p><p>目标蒸馏训练的具体方法如上图所示，主要包括以下几个步骤：</p><ol type="1"><li><p>选择 Teacher 模型和 Student 模型</p><p>Teacher模型选择一个训练良好且性能优越的复杂模型，通常是深度且大规模的神经网络。而Student模型选择一个较为简单、参数较少的模型，以便在硬件受限的环境中部署。</p></li><li><p>训练 Teacher 模型</p><p>按照标准训练流程训练Teacher模型，使其在给定的任务上有较高的准确率。</p></li><li><p>定义用于 Student 模型训练的损失函数</p><ul><li><p>计算 Soft Loss</p><p>　　Soft Loss 是通过计算学生模型 Soft-prediction（高温 Thigh 下通过Softmax 函数处理的模型输出） 与 Teacher 模型的 Soft-target 之间的 KL散度得到： <span class="math display">\[L_{\text{soft}} = \text{KL}(q_t^{T_{high}} \parallel q_s^{T_{high}}) =\sum_{i=1}^{n} q_{t,i}^{T_{high}} \log\left(\frac{q_{t,i}^{T_{high}}}{q_{s,i}^{T_{high}}}\right)\]</span> 其中： （1）n 是总的类别数。</p><p>（2）<span class="math inline">\(q_{t,i}^{T_{high}}\)</span> 是Teacher 模型在高温 Thigh 下通过 Softmax 函数处理得到的第 i类的概率。</p><p>（3）<span class="math inline">\(q_{s,i}^{T_{high}}\)</span> 是Student 模型在高温 Thigh 下通过 Softmax 函数处理得到的第 i类的概率。</p><blockquote><p>较高的温度 T 会导致 logits 被缩小，从而使得 Softmax函数的输出更平滑。但在反向传播过程中，这种缩放会影响梯度的计算，使得梯度被过度缩小。因此，在代码实现时，计算的KL 散度需要乘以 T2，用于梯度补偿。</p></blockquote></li><li><p>计算 Hard Loss</p><p>　　Hard Loss 是通过计算学生模型 Hard-prediction（标准 Softmax函数处理的模型输出）输出与真实标签 Hard-target 之间的交叉熵损失得到：<span class="math display">\[L_{\text{hard}} = \text{CE}(y, p_s^1) = - \sum_{i=1}^{K} y_i\log(p_{s,i}^1)\]</span> 其中：</p><p>（1）n 是总的类别数。</p><p>（2）<span class="math inline">\(y_i\)</span> 是真实的标签Hard-target 中第 i 类的值。</p><p>（3）<span class="math inline">\(q_{s,i}^1\)</span> 是学生模型在标准Softmax 函数（T=1）下处理得到的第 i 类的概率。</p></li><li><p>综合损失</p><p>　　高温蒸馏过程的损失函数由 Soft Loss 和 Hard Loss加权得到。常用损失函数公式如下： <span class="math display">\[L=(1-\alpha)\cdot L_{soft}+\alpha\cdot L_{hard}\]</span></p><p>　　其中 α 是一个权重参数，用于平衡软目标损失和硬目标损失的贡献。</p><p>　　真正的损失是由 Soft Loss 和 Hard Loss 综合得到的原因是：Teacher模型也有一定的错误率，使用真实标签可以有效降低错误信息被传播给 Student模型的可能性。例如，老师虽然学识远远超过学生，但是他仍然有出错的可能，而这时候如果学生在老师的教授之外，可以同时参考到标准答案，就可以有效地降低被老师偶尔的错误“带偏”的可能性。</p><p>　　α的设置取决于你希望学生模型更倾向于学习教师模型输出还是真实标签。通常，α的取值应通过实验确定，但可以根据以下指导原则进行初步设置：</p><p>（1）如果你希望学生模型在学习教师模型的同时也能关注真实标签， α值可以设置为 0.5，这种方式可以平衡交叉熵损失和蒸馏损失。</p><p>（2）如果 Teacher 模型的性能较好，则可以选择一个较小的 α 值（例如 0.1或 0.3），让 Student 模型更多地学习 Teacher 模型的知识。</p><p>（3）如果 Teacher 模型性能不够好，则可以选择一个较大的 α 值（例如 0.7或 0.9），让 Student 模型更多地学习真实标签的知识。</p><p>（4）在知识蒸馏的过程中， α也可以随训练的进程逐渐变化。这种策略可以帮助学生模型在训练初期更多地学习教师模型的知识，然后逐渐过渡到更多关注真实标签。在训练的早期阶段，学生模型可能还不够强大，更多依赖教师模型的指导，通过设定较小的α值让学生模型更多地学习教师模型的知识。随着训练的进行，学生模型变得更加成熟，可以更多地依赖真实标签，通过逐渐增大α 值，使学生模型更多地关注真实标签的损失。</p><blockquote><p>在实际中， α可能需要基于以上方案分别进行训练，以确定适合当前任务的最优 α 值。</p></blockquote></li><li><p>蒸馏损失的 PyTorch 代码实现</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">distillation_loss</span>(<span class="hljs-params">student_logits, teacher_logits, targets, alpha, T</span>):</span><br>    soft_loss = F.kl_div(<br>    F.log_softmax(student_logits / T, dim=<span class="hljs-number">1</span>),<br>    F.softmax(teacher_logits / T, dim=<span class="hljs-number">1</span>),<br>    reduction=<span class="hljs-string">&#x27;batchmean&#x27;</span><br>    ) * T ** <span class="hljs-number">2</span><br>    hard_loss = F.cross_entropy(student_logits, targets)<br>    <span class="hljs-keyword">return</span> alpha * hard_loss + (<span class="hljs-number">1</span> - alpha) * soft_loss<br><br></code></pre></td></tr></table></figure></li></ul></li><li><p>训练 Student 模型</p><p>　　使用设计好的蒸馏损失函数正常训练 Student模型。需要注意的是，在测试阶段需要将蒸馏温度恢复成1，确保学生模型输出与标准 Softmax输出一致，此时再进行模型评估和测试。</p></li></ol><h4 id="matching-logits">4.4 Matching Logits</h4><p>　　Matching Logits是一种特殊的目标蒸馏方法，它在蒸馏过程中不直接使用 Softmax 函数对Teacher 和 Student 模型的输出进行处理。而是直接比较它们的logits（即未经过 Softmax处理的输出值）。这种方法的目标是通过尽可能匹配教师和学生模型在每个类别上的logits，来传递知识。</p><p>　　具体来说，Matching Logits 的损失函数通常可以定义为 logits的平方误差或者其他形式的距离度量。一种常见的 Matching Logits损失函数形式可以如下表示： <span class="math display">\[L=\sum_{i=1}^n\left(z_{t, i}-z_{s, i}\right)^2\]</span> 其中：</p><p>（1）n 是总的类别数。</p><p>（2）<span class="math inline">\(z_{t,i}\)</span> 是 Teacher 模型对第i 个类别的 logits 值。</p><p>（3）<span class="math inline">\(z_{s,i}\)</span> 是 Student 模型对第i 个类别的 logits 值。</p><p>　　Matching Logits 方法的优点在于，它避免了 Softmax函数引入的一些问题，如极端概率值和信息丢失，而直接关注于 logits的匹配，更加精确地传递 Teacher 模型的知识。Matching Logits方法的缺点是依赖模型结构，如果两个模型的内部表示和学习机制大相径庭，直接匹配logits 也可能无法有效传递教师模型的知识。</p><p>　　此时蒸馏损失的 PyTorch 代码实现：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">distillation_loss</span>(<span class="hljs-params">student_logits, teacher_logits</span>):</span><br>    <span class="hljs-keyword">return</span> F.mse_loss(student_logits, teacher_logits)<br><br></code></pre></td></tr></table></figure><h3 id="基于特征蒸馏">5 基于特征蒸馏</h3><p>　　另外一种知识蒸馏思路是特征蒸馏方法，这种方法最早在论文《<ahref="https://arxiv.org/abs/1412.6550">FitNets: Hints for Thin DeepNets</a>》中被提出，其核心思想是让学生模型不仅学习教师模型的最终决策（如概率分布或logits），而且更重要的是学习教师模型在处理输入数据过程中的中间层特征表示。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506122005403.png" style="zoom:80%;" /></p><p>　　这篇论文首先提出一个案例，既宽又深的模型通常需要大量的乘法运算，导致对内存和计算资源的高需求，从而限制了它们在现实应用中的广泛使用。为了解决这个问题，可以通过知识蒸馏将知识从复杂的模型转移到参数较少的简单模型，但现有的知识蒸馏技术主要关注Student 网络与 Teacher网络具有相同或更小的参数，而未关注特征学习的基本层面——深度。因此，该篇论文主要针对Hinton 提出的知识蒸馏法进行扩展，允许 Student 模型可以比 Teacher模型更深更窄，使用 Teacher网络的输出和中间层的特征作为提示，改进训练过程和 Student网络的性能。</p><blockquote><p>论文中将这种具有比 Teacher 网络更多的层但每层具有较少神经元数量的Student 网络称为 "thin deep network"。</p></blockquote><h3 id="知识蒸馏代码实现">6. 知识蒸馏代码实现</h3><h4 id="导入必要的依赖">6.1 导入必要的依赖</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms, models<br><span class="hljs-keyword">from</span> torchvision.datasets <span class="hljs-keyword">import</span> CIFAR10<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br></code></pre></td></tr></table></figure><h4 id="定义训练早停类">6.2 定义训练早停类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EarlyStopping</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, patience=<span class="hljs-number">100</span>, min_delta=<span class="hljs-number">0</span></span>):</span><br>        <span class="hljs-keyword">if</span> patience &lt;= <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;patience must be a positive integer&#x27;</span>)<br>        <span class="hljs-keyword">if</span> min_delta &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;min_delta must be a positive number&#x27;</span>)<br><br>        self.patience = patience<br>        self.current_patience = patience<br>        self.min_delta = min_delta<br>        self.early_stop = <span class="hljs-literal">False</span><br>        self.best_acc = <span class="hljs-number">0</span><br>        self.best_loss = <span class="hljs-literal">None</span><br>        self.best_epoch = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, val_loss, val_acc, epoch</span>):</span><br>        <span class="hljs-keyword">if</span> val_acc &gt; self.best_acc + self.min_delta:<br>            self.current_patience = self.patience<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Epoch <span class="hljs-subst">&#123;epoch&#125;</span>: &#x27;</span><br>                  <span class="hljs-string">f&quot;best acc improved from <span class="hljs-subst">&#123;self.best_acc:<span class="hljs-number">.4</span>f&#125;</span> to <span class="hljs-subst">&#123;val_acc:<span class="hljs-number">.4</span>f&#125;</span>, &quot;</span><br>                  <span class="hljs-string">f&#x27;current patience reset to <span class="hljs-subst">&#123;self.patience&#125;</span>&#x27;</span>)<br>            self.best_acc = val_acc<br>            self.best_loss = val_loss<br>            self.best_epoch = epoch<br>        <span class="hljs-keyword">else</span>:<br>            self.current_patience -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> self.current_patience &lt;= <span class="hljs-number">0</span>:<br>                self.early_stop = <span class="hljs-literal">True</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.patience&#125;</span> patience exhausted, early stopping! &quot;</span><br>                      <span class="hljs-string">f&quot;Best acc: <span class="hljs-subst">&#123;self.best_acc:<span class="hljs-number">.4</span>f&#125;</span>, &quot;</span><br>                      <span class="hljs-string">f&quot;and best loss: <span class="hljs-subst">&#123;self.best_loss:<span class="hljs-number">.4</span>f&#125;</span>,&quot;</span><br>                      <span class="hljs-string">f&quot;appear at epoch <span class="hljs-subst">&#123;self.best_epoch&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Epoch <span class="hljs-subst">&#123;epoch&#125;</span>: &#x27;</span><br>                      <span class="hljs-string">f&#x27;best acc did not improve from <span class="hljs-subst">&#123;self.best_acc:<span class="hljs-number">.4</span>f&#125;</span>, &#x27;</span><br>                      <span class="hljs-string">f&#x27;current patience: <span class="hljs-subst">&#123;self.current_patience&#125;</span>/<span class="hljs-subst">&#123;self.patience&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">return</span> self.early_stop<br></code></pre></td></tr></table></figure><h4 id="定义训练基础类">6.3 定义训练基础类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseTrainer</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,</span></span><br><span class="hljs-params"><span class="hljs-function">                 num_epochs,</span></span><br><span class="hljs-params"><span class="hljs-function">                 batch_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                 save_dir=<span class="hljs-string">&quot;weight&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 device=<span class="hljs-string">&quot;cuda&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 num_workers=<span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 patience=<span class="hljs-number">10</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 min_delta=<span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 </span>):</span><br>        <span class="hljs-comment"># 设置随机种子</span><br>        seed = <span class="hljs-number">42</span><br>        torch.manual_seed(seed)<br>        torch.cuda.manual_seed(seed)<br>        torch.cuda.manual_seed_all(seed)<br>        torch.backends.cudnn.deterministic = <span class="hljs-literal">True</span><br>        torch.backends.cudnn.benchmark = <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 设置设备</span><br>        <span class="hljs-keyword">if</span> device == <span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">and</span> torch.cuda.is_available():<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Using GPU for training&quot;</span>)<br>            self.device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> torch.cuda.is_available():<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;CUDA is not available, using CPU instead&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Using CPU for training&quot;</span>)<br>            self.device = torch.device(<span class="hljs-string">&quot;cpu&quot;</span>)<br><br>        <span class="hljs-comment"># 定义输出位置</span><br>        self.save_dir = save_dir<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(self.save_dir):  <span class="hljs-comment"># 如果不存在该目录，则创建该目录</span><br>            os.makedirs(self.save_dir)<br><br>        <span class="hljs-comment"># 加载模型</span><br>        self.model = self.load_model()<br>        self.model.to(self.device)<br><br>        <span class="hljs-comment"># 定义训练参数</span><br>        self.num_epochs = num_epochs<br>        self.batch_size = batch_size<br>        self.num_workers = num_workers<br>        self.optimizer, self.scheduler = self.load_optimizer_and_scheduler()<br>        self.early_stopping = EarlyStopping(patience=patience, min_delta=min_delta)<br>        self.history = []<br>        self.train_loader, self.test_loader = self.get_data_loader()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_data_loader</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 计算训练集的mean和std</span><br>        dataset = CIFAR10(root=<span class="hljs-string">&#x27;data&#x27;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>, transform=transforms.ToTensor())<br>        data_loader = DataLoader(dataset, batch_size=<span class="hljs-built_in">len</span>(dataset), num_workers=self.num_workers)<br>        data = <span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(data_loader))<br>        mean = torch.mean(data[<span class="hljs-number">0</span>], dim=(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).tolist()  <span class="hljs-comment"># 计算均值</span><br>        std = torch.std(data[<span class="hljs-number">0</span>], dim=(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).tolist()  <span class="hljs-comment"># 计算标准差</span><br><br>        <span class="hljs-comment"># 定义数据预处理</span><br>        train_transform = transforms.Compose([  <span class="hljs-comment"># 定义训练集的预处理</span><br>            transforms.RandomCrop(<span class="hljs-number">32</span>, padding=<span class="hljs-number">4</span>),  <span class="hljs-comment"># 随机裁剪，增强模型对图像位置的鲁棒性</span><br>            transforms.RandomHorizontalFlip(),  <span class="hljs-comment"># 随机水平翻转，增加数据的多样性</span><br>            transforms.ColorJitter(brightness=<span class="hljs-number">0.2</span>, contrast=<span class="hljs-number">0.2</span>, saturation=<span class="hljs-number">0.2</span>),  <span class="hljs-comment"># 颜色抖动，增强模型对颜色变化的鲁棒性</span><br>            transforms.RandomRotation(<span class="hljs-number">15</span>),  <span class="hljs-comment"># 随机旋转，增加模型对旋转变换的鲁棒性</span><br>            transforms.ToTensor(),<br>            transforms.Normalize(mean, std),<br>        ])<br><br>        test_transform = transforms.Compose([  <span class="hljs-comment"># 定义测试集的预处理</span><br>            transforms.ToTensor(),<br>            transforms.Normalize(mean, std)<br>        ])<br><br>        <span class="hljs-comment"># 创建数据集和数据加载器</span><br>        train_dataset = CIFAR10(root=<span class="hljs-string">&#x27;data&#x27;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>, transform=train_transform)<br>        test_dataset = CIFAR10(root=<span class="hljs-string">&#x27;data&#x27;</span>, train=<span class="hljs-literal">False</span>, download=<span class="hljs-literal">True</span>, transform=test_transform)<br>        train_loader = DataLoader(train_dataset, batch_size=self.batch_size, shuffle=<span class="hljs-literal">True</span>, num_workers=self.num_workers)<br>        test_loader = DataLoader(test_dataset, batch_size=self.batch_size, shuffle=<span class="hljs-literal">False</span>, num_workers=self.num_workers)<br>        <span class="hljs-keyword">return</span> train_loader, test_loader<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_model</span>(<span class="hljs-params">self</span>):</span><br>        num_classes = <span class="hljs-number">10</span><br>        model = models.resnet18(weights=models.ResNet18_Weights.DEFAULT)<br>        model.fc = torch.nn.Linear(model.fc.in_features, num_classes)<br>        <span class="hljs-keyword">return</span> model<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_optimizer_and_scheduler</span>(<span class="hljs-params">self</span>):</span><br>        lr = <span class="hljs-number">0.01</span><br>        momentum = <span class="hljs-number">0.9</span><br>        weight_decay = <span class="hljs-number">1e-4</span><br>        optimizer = torch.optim.SGD(self.model.parameters(), lr=lr, momentum=momentum, weight_decay=weight_decay)<br>        scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=self.num_epochs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Optimizer: <span class="hljs-subst">&#123;optimizer.__class__.__name__&#125;</span>, lr=<span class="hljs-subst">&#123;lr&#125;</span>, momentum=<span class="hljs-subst">&#123;momentum&#125;</span>, weight_decay=<span class="hljs-subst">&#123;weight_decay&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Scheduler: <span class="hljs-subst">&#123;scheduler.__class__.__name__&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;You can change the optimizer and scheduler in the load_optimizer_and_scheduler method!&quot;</span>)<br>        <span class="hljs-keyword">return</span> optimizer, scheduler<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_model</span>(<span class="hljs-params">self, filename</span>):</span><br>        torch.save(self.model.state_dict(), os.path.join(self.save_dir, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;filename&#125;</span>.pt&quot;</span>))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_graph</span>(<span class="hljs-params">self, epoch</span>):</span><br>        <span class="hljs-comment"># 展示训练过程</span><br>        history_np = np.array(self.history)<br>        plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>))  <span class="hljs-comment"># 创建一个10*10的画布绘制损失曲线图</span><br>        plt.plot(np.arange(<span class="hljs-number">1</span>, epoch + <span class="hljs-number">1</span>), (history_np[:, [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]]))  <span class="hljs-comment"># 画出训练集损失和验证集损失</span><br>        plt.legend([<span class="hljs-string">&#x27;Train Loss&#x27;</span>, <span class="hljs-string">&#x27;Test Loss&#x27;</span>])  <span class="hljs-comment"># 显示图例</span><br>        plt.xlabel(<span class="hljs-string">&#x27;Epoch&#x27;</span>)  <span class="hljs-comment"># 设置x轴标签</span><br>        plt.ylabel(<span class="hljs-string">&#x27;Loss&#x27;</span>)  <span class="hljs-comment"># 设置y轴标签</span><br>        x_ticks = np.arange(<span class="hljs-number">0</span>, epoch + <span class="hljs-number">1</span>, step=<span class="hljs-number">10</span>)<br>        x_ticks[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>  <span class="hljs-comment"># epoch是从1开始的</span><br>        plt.xticks(x_ticks)  <span class="hljs-comment"># 设置坐标轴刻度</span><br>        plt.yticks(np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">2.05</span>, <span class="hljs-number">0.1</span>))  <span class="hljs-comment"># 设置坐标轴刻度</span><br>        plt.grid()  <span class="hljs-comment"># 画出网格</span><br>        plt.gca().set_ylim([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>])  <span class="hljs-comment"># 设置y轴范围</span><br>        best_test_loss_idx = np.argmin(history_np[:, <span class="hljs-number">2</span>])<br>        best_test_loss = history_np[best_test_loss_idx, <span class="hljs-number">2</span>]<br>        plt.text(<br>            <span class="hljs-number">0.1</span>,<br>            <span class="hljs-number">1.05</span>,<br>            <span class="hljs-string">f&#x27;Best test loss: <span class="hljs-subst">&#123;best_test_loss:<span class="hljs-number">.4</span>f&#125;</span>, epoch: <span class="hljs-subst">&#123;best_test_loss_idx + <span class="hljs-number">1</span>&#125;</span>&#x27;</span>,<br>            ha=<span class="hljs-string">&#x27;center&#x27;</span>,<br>            va=<span class="hljs-string">&#x27;center&#x27;</span>,<br>            transform=plt.gca().transAxes<br>        )<br>        plt.savefig(os.path.join(self.save_dir, <span class="hljs-string">&#x27;loss_curve.png&#x27;</span>))  <span class="hljs-comment"># 保存图片</span><br>        plt.close()  <span class="hljs-comment"># 关闭画布</span><br><br>        plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>))  <span class="hljs-comment"># 创建一个10*10的画布绘制准确率曲线图</span><br>        plt.plot(np.arange(<span class="hljs-number">1</span>, epoch + <span class="hljs-number">1</span>), (history_np[:, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]]))  <span class="hljs-comment"># 画出训练集准确率和验证集准确率</span><br>        plt.legend([<span class="hljs-string">&#x27;Train Accuracy&#x27;</span>, <span class="hljs-string">&#x27;Test Accuracy&#x27;</span>])  <span class="hljs-comment"># 显示图例</span><br>        plt.xlabel(<span class="hljs-string">&#x27;Epoch&#x27;</span>)  <span class="hljs-comment"># 设置x轴标签</span><br>        plt.ylabel(<span class="hljs-string">&#x27;Accuracy&#x27;</span>)  <span class="hljs-comment"># 设置y轴标签</span><br>        x_ticks = np.arange(<span class="hljs-number">0</span>, epoch + <span class="hljs-number">1</span>, step=<span class="hljs-number">10</span>)<br>        x_ticks[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>  <span class="hljs-comment"># epoch是从1开始的</span><br>        plt.xticks(x_ticks)  <span class="hljs-comment"># 设置坐标轴刻度</span><br>        plt.yticks(np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">1.05</span>, <span class="hljs-number">0.05</span>))  <span class="hljs-comment"># 设置坐标轴刻度</span><br>        plt.grid()  <span class="hljs-comment"># 画出网格</span><br>        best_test_acc_idx = np.argmax(history_np[:, <span class="hljs-number">3</span>])<br>        best_test_acc = history_np[best_test_acc_idx, <span class="hljs-number">3</span>]<br>        plt.text(<br>            <span class="hljs-number">0.1</span>,<br>            <span class="hljs-number">1.05</span>,<br>            <span class="hljs-string">f&#x27;Best test acc: <span class="hljs-subst">&#123;best_test_acc:<span class="hljs-number">.4</span>f&#125;</span>, epoch: <span class="hljs-subst">&#123;best_test_acc_idx + <span class="hljs-number">1</span>&#125;</span>&#x27;</span>,<br>            ha=<span class="hljs-string">&#x27;center&#x27;</span>,<br>            va=<span class="hljs-string">&#x27;center&#x27;</span>,<br>            transform=plt.gca().transAxes<br>        )<br>        plt.savefig(os.path.join(self.save_dir, <span class="hljs-string">&#x27;acc_curve.png&#x27;</span>))  <span class="hljs-comment"># 保存图片</span><br>        plt.close()  <span class="hljs-comment"># 关闭画布</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span>(<span class="hljs-params">self, epoch</span>):</span><br>        train_total_loss = <span class="hljs-number">0</span><br>        train_total_acc = <span class="hljs-number">0</span><br>        self.model.train()<br>        <span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> tqdm.tqdm(self.train_loader, total=<span class="hljs-built_in">len</span>(self.train_loader),<br>                                        desc=<span class="hljs-string">f&#x27;Training Epoch <span class="hljs-subst">&#123;epoch&#125;</span>/<span class="hljs-subst">&#123;self.num_epochs&#125;</span>&#x27;</span>, delay=<span class="hljs-number">0.1</span>):<br>            images = images.to(self.device)<br>            labels = labels.to(self.device)<br>            outputs = self.model(images)<br>            loss = F.cross_entropy(outputs, labels)<br>            self.optimizer.zero_grad()<br>            loss.backward()<br>            self.optimizer.step()<br>            train_total_loss += loss.item()<br>            train_total_acc += (outputs.argmax(dim=<span class="hljs-number">1</span>) == labels).<span class="hljs-built_in">float</span>().<span class="hljs-built_in">sum</span>().item()<br>        train_avg_loss = train_total_loss / <span class="hljs-built_in">len</span>(self.train_loader)<br>        train_avg_acc = train_total_acc / <span class="hljs-built_in">len</span>(self.train_loader.dataset)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Epoch <span class="hljs-subst">&#123;epoch&#125;</span>/<span class="hljs-subst">&#123;self.num_epochs&#125;</span>, Train Loss: <span class="hljs-subst">&#123;train_avg_loss:<span class="hljs-number">.4</span>f&#125;</span>, Train Acc: <span class="hljs-subst">&#123;train_avg_acc:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">return</span> train_avg_loss, train_avg_acc<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self, epoch</span>):</span><br>        test_total_loss = <span class="hljs-number">0</span><br>        test_total_acc = <span class="hljs-number">0</span><br>        self.model.<span class="hljs-built_in">eval</span>()<br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            <span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> tqdm.tqdm(self.test_loader, total=<span class="hljs-built_in">len</span>(self.test_loader),<br>                                            desc=<span class="hljs-string">f&#x27;Testing Epoch <span class="hljs-subst">&#123;epoch&#125;</span>/<span class="hljs-subst">&#123;self.num_epochs&#125;</span>&#x27;</span>, delay=<span class="hljs-number">0.1</span>):<br>                images = images.to(self.device)<br>                labels = labels.to(self.device)<br>                outputs = self.model(images)<br>                loss = F.cross_entropy(outputs, labels)<br>                test_total_loss += loss.item()<br>                test_total_acc += (outputs.argmax(dim=<span class="hljs-number">1</span>) == labels).<span class="hljs-built_in">float</span>().<span class="hljs-built_in">sum</span>().item()<br>        test_avg_loss = test_total_loss / <span class="hljs-built_in">len</span>(self.test_loader)<br>        test_avg_acc = test_total_acc / <span class="hljs-built_in">len</span>(self.test_loader.dataset)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Epoch <span class="hljs-subst">&#123;epoch&#125;</span>/<span class="hljs-subst">&#123;self.num_epochs&#125;</span>, Test Loss: <span class="hljs-subst">&#123;test_avg_loss:<span class="hljs-number">.4</span>f&#125;</span>, Test Acc: <span class="hljs-subst">&#123;test_avg_acc:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">return</span> test_avg_loss, test_avg_acc<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        start_time = time.time()  <span class="hljs-comment"># 记录开始时间</span><br>        <span class="hljs-keyword">if</span> self.history:<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;This object has already run, please create a new object&quot;</span>)<br>        <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span> + self.num_epochs):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Current lr: <span class="hljs-subst">&#123;self.scheduler.get_last_lr()[<span class="hljs-number">0</span>]:<span class="hljs-number">.6</span>f&#125;</span>&quot;</span>)<br>            train_loss, train_acc = self.train(epoch)<br>            test_loss, test_acc = self.test(epoch)<br>            self.history.append((train_loss, train_acc, test_loss, test_acc))<br>            self.scheduler.step()<br>            self.save_graph(epoch)<br>            self.save_model(<span class="hljs-string">&quot;last&quot;</span>)<br>            <span class="hljs-keyword">if</span> self.early_stopping(test_loss, test_acc, epoch):<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> self.early_stopping.current_patience == self.early_stopping.patience:<br>                self.save_model(<span class="hljs-string">&quot;best&quot;</span>)<br>            <span class="hljs-built_in">print</span>()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Training finished. &quot;</span><br>              <span class="hljs-string">f&quot;Best acc: <span class="hljs-subst">&#123;self.early_stopping.best_acc:<span class="hljs-number">.4</span>f&#125;</span> &quot;</span><br>              <span class="hljs-string">f&quot;and best loss: <span class="hljs-subst">&#123;self.early_stopping.best_loss:<span class="hljs-number">.4</span>f&#125;</span> &quot;</span><br>              <span class="hljs-string">f&quot;appear at epoch <span class="hljs-subst">&#123;self.early_stopping.best_epoch&#125;</span>&quot;</span>)<br>        end_time = time.time()  <span class="hljs-comment"># 记录结束时间</span><br>        period = <span class="hljs-built_in">round</span>(end_time - start_time)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;All time: <span class="hljs-subst">&#123;period&#125;</span> s&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;All Time: <span class="hljs-subst">&#123;period // <span class="hljs-number">60</span>:d&#125;</span> min <span class="hljs-subst">&#123;period % <span class="hljs-number">60</span>:d&#125;</span> s&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="定义-teacher-模型训练类">6.4 定义 Teacher 模型训练类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TeacherTrainer</span>(<span class="hljs-params">BaseTrainer</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,</span></span><br><span class="hljs-params"><span class="hljs-function">                 num_epochs,</span></span><br><span class="hljs-params"><span class="hljs-function">                 batch_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                 save_dir=<span class="hljs-string">&quot;weight&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 device=<span class="hljs-string">&quot;cuda&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 num_workers=<span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 patience=<span class="hljs-number">10</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 min_delta=<span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 </span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(num_epochs, batch_size, save_dir, device, num_workers, patience, min_delta)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_data_loader</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 计算训练集的mean和std</span><br>        dataset = CIFAR10(root=<span class="hljs-string">&#x27;data&#x27;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>, transform=transforms.ToTensor())<br>        data_loader = DataLoader(dataset, batch_size=<span class="hljs-built_in">len</span>(dataset), num_workers=self.num_workers)<br>        data = <span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(data_loader))<br>        mean = torch.mean(data[<span class="hljs-number">0</span>], dim=(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).tolist()  <span class="hljs-comment"># 计算均值</span><br>        std = torch.std(data[<span class="hljs-number">0</span>], dim=(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).tolist()  <span class="hljs-comment"># 计算标准差</span><br><br>        <span class="hljs-comment"># 定义数据预处理</span><br>        train_transform = transforms.Compose([  <span class="hljs-comment"># 定义训练集的预处理</span><br>            transforms.RandomCrop(<span class="hljs-number">32</span>, padding=<span class="hljs-number">4</span>),  <span class="hljs-comment"># 随机裁剪，增强模型对图像位置的鲁棒性</span><br>            transforms.RandomHorizontalFlip(),  <span class="hljs-comment"># 随机水平翻转，增加数据的多样性</span><br>            transforms.ColorJitter(brightness=<span class="hljs-number">0.2</span>, contrast=<span class="hljs-number">0.2</span>, saturation=<span class="hljs-number">0.2</span>),  <span class="hljs-comment"># 颜色抖动，增强模型对颜色变化的鲁棒性</span><br>            transforms.RandomRotation(<span class="hljs-number">15</span>),  <span class="hljs-comment"># 随机旋转，增加模型对旋转变换的鲁棒性</span><br>            transforms.ToTensor(),<br>            transforms.Normalize(mean, std),<br>        ])<br><br>        test_transform = transforms.Compose([  <span class="hljs-comment"># 定义测试集的预处理</span><br>            transforms.ToTensor(),<br>            transforms.Normalize(mean, std)<br>        ])<br><br>        <span class="hljs-comment"># 创建数据集和数据加载器</span><br>        train_dataset = CIFAR10(root=<span class="hljs-string">&#x27;data&#x27;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>, transform=train_transform)<br>        test_dataset = CIFAR10(root=<span class="hljs-string">&#x27;data&#x27;</span>, train=<span class="hljs-literal">False</span>, download=<span class="hljs-literal">True</span>, transform=test_transform)<br>        train_loader = DataLoader(train_dataset, batch_size=self.batch_size, shuffle=<span class="hljs-literal">True</span>, num_workers=self.num_workers)<br>        test_loader = DataLoader(test_dataset, batch_size=self.batch_size, shuffle=<span class="hljs-literal">False</span>, num_workers=self.num_workers)<br>        <span class="hljs-keyword">return</span> train_loader, test_loader<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_model</span>(<span class="hljs-params">self</span>):</span><br>        num_classes = <span class="hljs-number">10</span><br>        model = models.resnet152(weights=models.ResNet152_Weights.DEFAULT)<br>        model.fc = torch.nn.Linear(model.fc.in_features, num_classes)<br>        <span class="hljs-keyword">return</span> model<br></code></pre></td></tr></table></figure><h4 id="定义-student-基准模型训练类">6.5 定义 Student基准模型训练类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BenchmarkTrainer</span>(<span class="hljs-params">BaseTrainer</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,</span></span><br><span class="hljs-params"><span class="hljs-function">                 num_epochs,</span></span><br><span class="hljs-params"><span class="hljs-function">                 batch_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                 save_dir=<span class="hljs-string">&quot;weight&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 device=<span class="hljs-string">&quot;cuda&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 num_workers=<span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 patience=<span class="hljs-number">10</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 min_delta=<span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 </span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(num_epochs, batch_size, save_dir, device, num_workers, patience, min_delta)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_data_loader</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 计算训练集的mean和std</span><br>        dataset = CIFAR10(root=<span class="hljs-string">&#x27;data&#x27;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>, transform=transforms.ToTensor())<br>        data_loader = DataLoader(dataset, batch_size=<span class="hljs-built_in">len</span>(dataset), num_workers=self.num_workers)<br>        data = <span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(data_loader))<br>        mean = torch.mean(data[<span class="hljs-number">0</span>], dim=(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).tolist()  <span class="hljs-comment"># 计算均值</span><br>        std = torch.std(data[<span class="hljs-number">0</span>], dim=(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).tolist()  <span class="hljs-comment"># 计算标准差</span><br><br>        <span class="hljs-comment"># 定义数据预处理</span><br>        train_transform = transforms.Compose([  <span class="hljs-comment"># 定义训练集的预处理</span><br>            transforms.RandomCrop(<span class="hljs-number">32</span>, padding=<span class="hljs-number">4</span>),  <span class="hljs-comment"># 随机裁剪，增强模型对图像位置的鲁棒性</span><br>            transforms.RandomHorizontalFlip(),  <span class="hljs-comment"># 随机水平翻转，增加数据的多样性</span><br>            transforms.ColorJitter(brightness=<span class="hljs-number">0.2</span>, contrast=<span class="hljs-number">0.2</span>, saturation=<span class="hljs-number">0.2</span>),  <span class="hljs-comment"># 颜色抖动，增强模型对颜色变化的鲁棒性</span><br>            transforms.RandomRotation(<span class="hljs-number">15</span>),  <span class="hljs-comment"># 随机旋转，增加模型对旋转变换的鲁棒性</span><br>            transforms.ToTensor(),<br>            transforms.Normalize(mean, std),<br>        ])<br><br>        test_transform = transforms.Compose([  <span class="hljs-comment"># 定义测试集的预处理</span><br>            transforms.ToTensor(),<br>            transforms.Normalize(mean, std)<br>        ])<br><br>        <span class="hljs-comment"># 创建数据集和数据加载器</span><br>        train_dataset = CIFAR10(root=<span class="hljs-string">&#x27;data&#x27;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>, transform=train_transform)<br>        test_dataset = CIFAR10(root=<span class="hljs-string">&#x27;data&#x27;</span>, train=<span class="hljs-literal">False</span>, download=<span class="hljs-literal">True</span>, transform=test_transform)<br>        train_loader = DataLoader(train_dataset, batch_size=self.batch_size, shuffle=<span class="hljs-literal">True</span>, num_workers=self.num_workers)<br>        test_loader = DataLoader(test_dataset, batch_size=self.batch_size, shuffle=<span class="hljs-literal">False</span>, num_workers=self.num_workers)<br>        <span class="hljs-keyword">return</span> train_loader, test_loader<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_model</span>(<span class="hljs-params">self</span>):</span><br>        num_classes = <span class="hljs-number">10</span><br>        model = models.resnet18(weights=models.ResNet18_Weights.DEFAULT)<br>        model.fc = torch.nn.Linear(model.fc.in_features, num_classes)<br>        <span class="hljs-keyword">return</span> model<br></code></pre></td></tr></table></figure><h4 id="定义蒸馏损失类">6.6 定义蒸馏损失类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">KDLoss</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, num_epoch, alpha_scope=(<span class="hljs-params"><span class="hljs-number">0.1</span>, <span class="hljs-number">0.9</span></span>), temperature=<span class="hljs-number">3</span></span>):</span><br>        self.num_epoch = num_epoch<br>        self.alpha = alpha_scope<br>        self.temperature = temperature<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">_cal_alpha</span>(<span class="hljs-params">self, epoch</span>):</span><br>        <span class="hljs-keyword">return</span> self.alpha[<span class="hljs-number">0</span>] + (self.alpha[<span class="hljs-number">1</span>] - self.alpha[<span class="hljs-number">0</span>]) * epoch / self.num_epoch<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, student_logits, teacher_logits, targets, epoch</span>):</span><br>        alpha = self._cal_alpha(epoch)<br>        hard_loss = F.cross_entropy(student_logits, targets)<br>        soft_loss = F.kl_div(F.log_softmax(student_logits / self.temperature, dim=<span class="hljs-number">1</span>),<br>                             F.softmax(teacher_logits / self.temperature, dim=<span class="hljs-number">1</span>),<br>                             reduction=<span class="hljs-string">&#x27;batchmean&#x27;</span>) * self.temperature ** <span class="hljs-number">2</span><br>        <span class="hljs-keyword">return</span> alpha * hard_loss + (<span class="hljs-number">1</span> - alpha) * soft_loss<br></code></pre></td></tr></table></figure><h4 id="定义-student-模型训练类">6.7 定义 Student 模型训练类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StudentTrainer</span>(<span class="hljs-params">BaseTrainer</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,</span></span><br><span class="hljs-params"><span class="hljs-function">                 num_epoch,</span></span><br><span class="hljs-params"><span class="hljs-function">                 batch_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                 save_dir=<span class="hljs-string">&quot;weight&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 device=<span class="hljs-string">&quot;cuda&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 num_workers=<span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 patience=<span class="hljs-number">10</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 min_delta=<span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 alpha_scope=(<span class="hljs-params"><span class="hljs-number">0.1</span>, <span class="hljs-number">0.9</span></span>),</span></span><br><span class="hljs-params"><span class="hljs-function">                 temperature=<span class="hljs-number">3</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 teacher_weight_path=<span class="hljs-string">&quot;teacher/best.pt&quot;</span></span></span><br><span class="hljs-params"><span class="hljs-function">                 </span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(num_epoch, batch_size, save_dir, device, num_workers, patience, min_delta)<br>        self.teacher_weight_path = teacher_weight_path<br>        self.kl_loss = KDLoss(num_epoch, alpha_scope, temperature)<br>        self.teacher_model = self.load_teacher_model()<br>        self.teacher_model.to(self.device)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_data_loader</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 计算训练集的mean和std</span><br>        dataset = CIFAR10(root=<span class="hljs-string">&#x27;data&#x27;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>, transform=transforms.ToTensor())<br>        data_loader = DataLoader(dataset, batch_size=<span class="hljs-built_in">len</span>(dataset), num_workers=self.num_workers)<br>        data = <span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(data_loader))<br>        mean = torch.mean(data[<span class="hljs-number">0</span>], dim=(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).tolist()  <span class="hljs-comment"># 计算均值</span><br>        std = torch.std(data[<span class="hljs-number">0</span>], dim=(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).tolist()  <span class="hljs-comment"># 计算标准差</span><br><br>        <span class="hljs-comment"># 定义数据预处理</span><br>        train_transform = transforms.Compose([  <span class="hljs-comment"># 定义训练集的预处理</span><br>            transforms.RandomCrop(<span class="hljs-number">32</span>, padding=<span class="hljs-number">4</span>),  <span class="hljs-comment"># 随机裁剪，增强模型对图像位置的鲁棒性</span><br>            transforms.RandomHorizontalFlip(),  <span class="hljs-comment"># 随机水平翻转，增加数据的多样性</span><br>            transforms.ColorJitter(brightness=<span class="hljs-number">0.2</span>, contrast=<span class="hljs-number">0.2</span>, saturation=<span class="hljs-number">0.2</span>),  <span class="hljs-comment"># 颜色抖动，增强模型对颜色变化的鲁棒性</span><br>            transforms.RandomRotation(<span class="hljs-number">15</span>),  <span class="hljs-comment"># 随机旋转，增加模型对旋转变换的鲁棒性</span><br>            transforms.ToTensor(),<br>            transforms.Normalize(mean, std),<br>        ])<br><br>        test_transform = transforms.Compose([  <span class="hljs-comment"># 定义测试集的预处理</span><br>            transforms.ToTensor(),<br>            transforms.Normalize(mean, std)<br>        ])<br><br>        <span class="hljs-comment"># 创建数据集和数据加载器</span><br>        train_dataset = CIFAR10(root=<span class="hljs-string">&#x27;data&#x27;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>, transform=train_transform)<br>        test_dataset = CIFAR10(root=<span class="hljs-string">&#x27;data&#x27;</span>, train=<span class="hljs-literal">False</span>, download=<span class="hljs-literal">True</span>, transform=test_transform)<br>        train_loader = DataLoader(train_dataset, batch_size=self.batch_size, shuffle=<span class="hljs-literal">True</span>, num_workers=self.num_workers)<br>        test_loader = DataLoader(test_dataset, batch_size=self.batch_size, shuffle=<span class="hljs-literal">False</span>, num_workers=self.num_workers)<br>        <span class="hljs-keyword">return</span> train_loader, test_loader<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_teacher_model</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(self.teacher_weight_path):<br>            <span class="hljs-keyword">raise</span> FileNotFoundError(<span class="hljs-string">&quot;teacher weight not found&quot;</span>)<br>        num_classes = <span class="hljs-number">10</span><br>        model = models.resnet152()<br>        model.fc = torch.nn.Linear(model.fc.in_features, num_classes)<br>        model.load_state_dict(torch.load(self.teacher_weight_path))<br>        <span class="hljs-keyword">return</span> model<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_model</span>(<span class="hljs-params">self</span>):</span><br>        num_classes = <span class="hljs-number">10</span><br>        model = models.resnet18(weights=models.ResNet18_Weights.DEFAULT)<br>        model.fc = torch.nn.Linear(model.fc.in_features, num_classes)<br>        <span class="hljs-keyword">return</span> model<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span>(<span class="hljs-params">self, epoch</span>):</span><br>        train_total_loss = <span class="hljs-number">0</span><br>        train_total_acc = <span class="hljs-number">0</span><br>        self.model.train()<br>        <span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> tqdm.tqdm(self.train_loader, total=<span class="hljs-built_in">len</span>(self.train_loader),<br>                                        desc=<span class="hljs-string">f&#x27;Training Epoch <span class="hljs-subst">&#123;epoch&#125;</span>/<span class="hljs-subst">&#123;self.num_epochs&#125;</span>&#x27;</span>, delay=<span class="hljs-number">0.1</span>):<br>            images = images.to(self.device)<br>            labels = labels.to(self.device)<br>            outputs = self.model(images)<br>            teacher_outputs = self.teacher_model(images)<br>            loss = self.kl_loss(outputs, teacher_outputs, labels, epoch)<br>            self.optimizer.zero_grad()<br>            loss.backward()<br>            self.optimizer.step()<br>            train_total_loss += loss.item()<br>            train_total_acc += (outputs.argmax(dim=<span class="hljs-number">1</span>) == labels).<span class="hljs-built_in">float</span>().<span class="hljs-built_in">sum</span>().item()<br>        train_avg_loss = train_total_loss / <span class="hljs-built_in">len</span>(self.train_loader)<br>        train_avg_acc = train_total_acc / <span class="hljs-built_in">len</span>(self.train_loader.dataset)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Epoch <span class="hljs-subst">&#123;epoch&#125;</span>/<span class="hljs-subst">&#123;self.num_epochs&#125;</span>, Train Loss: <span class="hljs-subst">&#123;train_avg_loss:<span class="hljs-number">.4</span>f&#125;</span>, Train Acc: <span class="hljs-subst">&#123;train_avg_acc:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">return</span> train_avg_loss, train_avg_acc<br></code></pre></td></tr></table></figure><h4 id="开始训练">6.8 开始训练</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    teacher_trainer = TeacherTrainer(<br>        num_epochs=<span class="hljs-number">200</span>,<br>        batch_size=<span class="hljs-number">512</span>,<br>        save_dir=<span class="hljs-string">&quot;teacher&quot;</span>,<br>        num_workers=<span class="hljs-number">3</span>,<br>        patience=<span class="hljs-number">200</span>,<br>    )<br>    teacher_trainer.run()<br><br>    benchmark_trainer = BenchmarkTrainer(<br>        num_epochs=<span class="hljs-number">200</span>,<br>        batch_size=<span class="hljs-number">512</span>,<br>        save_dir=<span class="hljs-string">&quot;benchmark&quot;</span>,<br>        num_workers=<span class="hljs-number">3</span>,<br>        patience=<span class="hljs-number">200</span>,<br>    )<br>    benchmark_trainer.run()<br><br>    student_trainer = StudentTrainer(<br>        num_epoch=<span class="hljs-number">100</span>,<br>        batch_size=<span class="hljs-number">512</span>,<br>        save_dir=<span class="hljs-string">&quot;student&quot;</span>,<br>        num_workers=<span class="hljs-number">3</span>,<br>        patience=<span class="hljs-number">100</span>,<br>        teacher_weight_path=<span class="hljs-string">&quot;teacher/best.pt&quot;</span><br>    )<br>    student_trainer.run()<br></code></pre></td></tr></table></figure><h3 id="实现二">7. 实现二</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForCausalLM, AdamW<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset, DataLoader<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><br><br><span class="hljs-comment"># ========== 配置参数 ==========</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span>:</span><br>    <span class="hljs-comment"># 模型设置</span><br>    teacher_model_name = <span class="hljs-string">&quot;Qwen/Qwen-7B&quot;</span><br>    student_model_name = <span class="hljs-string">&quot;Qwen/Qwen-1.8B&quot;</span><br><br>    <span class="hljs-comment"># 训练参数</span><br>    batch_size = <span class="hljs-number">16</span><br>    num_epochs = <span class="hljs-number">3</span><br>    learning_rate = <span class="hljs-number">2e-5</span><br>    max_seq_length = <span class="hljs-number">512</span><br>    temperature = <span class="hljs-number">5.0</span><br>    alpha = <span class="hljs-number">0.7</span>  <span class="hljs-comment"># 蒸馏损失权重</span><br><br>    <span class="hljs-comment"># 设备设置</span><br>    device = <span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span><br>    grad_accum_steps = <span class="hljs-number">4</span>  <span class="hljs-comment"># 梯度累积步数</span><br><br><br>config = Config()<br><br><br><span class="hljs-comment"># ========== 数据加载 ==========</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DistillationDataset</span>(<span class="hljs-params">Dataset</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, tokenizer, sample_texts</span>):</span><br>        self.tokenizer = tokenizer<br>        self.examples = []<br><br>        <span class="hljs-comment"># 示例数据（实际需替换为真实数据集）</span><br>        sample_texts = [<br>            <span class="hljs-string">&quot;人工智能的核心理念是&quot;</span>,<br>            <span class="hljs-string">&quot;大语言模型蒸馏的关键在于&quot;</span>,<br>            <span class="hljs-string">&quot;深度学习模型的压缩方法包括&quot;</span><br>        ]<br><br>        <span class="hljs-keyword">for</span> text <span class="hljs-keyword">in</span> sample_texts:<br>            encoding = tokenizer(<br>                text,<br>                max_length=config.max_seq_length,<br>                padding=<span class="hljs-string">&quot;max_length&quot;</span>,<br>                truncation=<span class="hljs-literal">True</span>,<br>                return_tensors=<span class="hljs-string">&quot;pt&quot;</span><br>            )<br>            self.examples.append(encoding)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.examples)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, idx</span>):</span><br>        <span class="hljs-keyword">return</span> &#123;<br>            <span class="hljs-string">&quot;input_ids&quot;</span>: self.examples[idx][<span class="hljs-string">&quot;input_ids&quot;</span>].squeeze(),<br>            <span class="hljs-string">&quot;attention_mask&quot;</span>: self.examples[idx][<span class="hljs-string">&quot;attention_mask&quot;</span>].squeeze()<br>        &#125;<br><br><br><span class="hljs-comment"># ========== 模型初始化 ==========</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_models</span>():</span><br>    <span class="hljs-comment"># 加载教师模型（冻结参数）</span><br>    teacher = AutoModelForCausalLM.from_pretrained(<br>        config.teacher_model_name,<br>        device_map=<span class="hljs-string">&quot;auto&quot;</span>,<br>        torch_dtype=torch.bfloat16<br>    ).<span class="hljs-built_in">eval</span>()<br><br>    <span class="hljs-comment"># 加载学生模型</span><br>    student = AutoModelForCausalLM.from_pretrained(<br>        config.student_model_name,<br>        device_map=<span class="hljs-string">&quot;auto&quot;</span>,<br>        torch_dtype=torch.bfloat16<br>    ).train()<br><br>    <span class="hljs-keyword">return</span> teacher, student<br><br><br><span class="hljs-comment"># ========== 蒸馏损失函数 ==========</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DistillationLoss</span>:</span><br><span class="hljs-meta">    @staticmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">calculate</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">            teacher_logits,  <span class="hljs-comment"># 教师模型logits [batch, seq_len, vocab]</span></span></span><br><span class="hljs-params"><span class="hljs-function">            student_logits,  <span class="hljs-comment"># 学生模型logits [batch, seq_len, vocab]</span></span></span><br><span class="hljs-params"><span class="hljs-function">            temperature=config.temperature,</span></span><br><span class="hljs-params"><span class="hljs-function">            alpha=config.alpha</span></span><br><span class="hljs-params"><span class="hljs-function">    </span>):</span><br>        <span class="hljs-comment"># 软目标蒸馏损失</span><br>        soft_teacher = F.softmax(teacher_logits / temperature, dim=-<span class="hljs-number">1</span>)<br>        soft_student = F.log_softmax(student_logits / temperature, dim=-<span class="hljs-number">1</span>)<br><br>        kl_loss = F.kl_div(<br>            soft_student,<br>            soft_teacher,<br>            reduction=<span class="hljs-string">&quot;batchmean&quot;</span>,<br>            log_target=<span class="hljs-literal">False</span><br>        ) * (temperature ** <span class="hljs-number">2</span>)<br><br>        <span class="hljs-comment"># 学生自训练损失（交叉熵）</span><br>        shift_logits = student_logits[..., :-<span class="hljs-number">1</span>, :].contiguous()<br>        shift_labels = teacher_logits.argmax(-<span class="hljs-number">1</span>)[..., <span class="hljs-number">1</span>:].contiguous()<br>        ce_loss = F.cross_entropy(<br>            shift_logits.view(-<span class="hljs-number">1</span>, shift_logits.size(-<span class="hljs-number">1</span>)),<br>            shift_labels.view(-<span class="hljs-number">1</span>)<br>        )<br><br>        <span class="hljs-keyword">return</span> alpha * kl_loss + (<span class="hljs-number">1</span> - alpha) * ce_loss<br><br><br><span class="hljs-comment"># ========== 训练流程 ==========</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span>():</span><br>    <span class="hljs-comment"># 初始化组件</span><br>    tokenizer = AutoTokenizer.from_pretrained(config.teacher_model_name)<br>    teacher, student = load_models()<br><br>    <span class="hljs-comment"># 数据集示例</span><br>    dataset = DistillationDataset(tokenizer)<br>    dataloader = DataLoader(dataset, batch_size=config.batch_size)<br><br>    <span class="hljs-comment"># 优化器设置</span><br>    optimizer = AdamW(student.parameters(), lr=config.learning_rate)<br><br>    <span class="hljs-comment"># 混合精度训练</span><br>    scaler = torch.cuda.amp.GradScaler()<br><br>    <span class="hljs-comment"># 训练循环</span><br>    step_count = <span class="hljs-number">0</span><br>    student.to(config.device)<br><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(config.num_epochs):<br>        <span class="hljs-keyword">for</span> batch_idx, batch <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(dataloader):<br>            inputs = &#123;k: v.to(config.device) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> batch.items()&#125;<br><br>            <span class="hljs-comment"># 教师模型前向（不计算梯度）</span><br>            <span class="hljs-keyword">with</span> torch.no_grad(), torch.cuda.amp.autocast():<br>                teacher_outputs = teacher(**inputs)<br><br>            <span class="hljs-comment"># 学生模型前向</span><br>            <span class="hljs-keyword">with</span> torch.cuda.amp.autocast():<br>                student_outputs = student(**inputs)<br>                loss = DistillationLoss.calculate(<br>                    teacher_outputs.logits,<br>                    student_outputs.logits<br>                )<br><br>            <span class="hljs-comment"># 反向传播（带梯度累积）</span><br>            scaler.scale(loss / config.grad_accum_steps).backward()<br><br>            <span class="hljs-keyword">if</span> (batch_idx + <span class="hljs-number">1</span>) % config.grad_accum_steps == <span class="hljs-number">0</span>:<br>                <span class="hljs-comment"># 梯度裁剪</span><br>                torch.nn.utils.clip_grad_norm_(student.parameters(), <span class="hljs-number">1.0</span>)<br><br>                <span class="hljs-comment"># 参数更新</span><br>                scaler.step(optimizer)<br>                scaler.update()<br>                optimizer.zero_grad()<br>                step_count += <span class="hljs-number">1</span><br><br>                <span class="hljs-comment"># 学习率调整（示例）</span><br>                lr = config.learning_rate * <span class="hljs-built_in">min</span>(step_count ** -<span class="hljs-number">0.5</span>, step_count * (<span class="hljs-number">300</span> ** -<span class="hljs-number">1.5</span>))<br>                <span class="hljs-keyword">for</span> param_group <span class="hljs-keyword">in</span> optimizer.param_groups:<br>                    param_group[<span class="hljs-string">&#x27;lr&#x27;</span>] = lr<br><br>                <span class="hljs-comment"># 打印训练信息</span><br>                <span class="hljs-keyword">if</span> step_count % <span class="hljs-number">10</span> == <span class="hljs-number">0</span>:<br>                    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Epoch <span class="hljs-subst">&#123;epoch + <span class="hljs-number">1</span>&#125;</span> | Step <span class="hljs-subst">&#123;step_count&#125;</span> | Loss: <span class="hljs-subst">&#123;loss.item():<span class="hljs-number">.4</span>f&#125;</span>&quot;</span>)<br><br>    <span class="hljs-comment"># 保存蒸馏后的模型</span><br>    student.save_pretrained(<span class="hljs-string">&quot;./distilled_qwen&quot;</span>)<br>    tokenizer.save_pretrained(<span class="hljs-string">&quot;./distilled_qwen&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    train()<br></code></pre></td></tr></table></figure><p>　　</p><p>转载自：https://www.cnblogs.com/marui199710/articles/18283785</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>模型压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模型压缩——剪枝</title>
    <link href="/2025/06/11/%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D/"/>
    <url>/2025/06/11/%E6%A8%A1%E5%9E%8B%E5%89%AA%E6%9E%9D/</url>
    
    <content type="html"><![CDATA[<h3 id="模型压缩的概述">1 模型压缩的概述</h3><p>　　深度学习因其计算复杂度或参数见余，在一些场景和设备上限制了相应的模型部署，需要借助模型压缩、优化加速、异构计算等方法突破瓶颈。模型压缩算法能够有效降低参数余，从而减少存储占用、通信带宽和计算复杂度，有助于深度学习的应用部署，具体可划分为如下几种方法：</p><ul><li>剪枝（Pruning）：剪枝技术通过移除网络中不重要的参数或神经元来减少模型的大小和计算复杂度。</li><li>知识蒸馏（KnowledgeDistillation）：知识蒸馏技术通过将复杂模型（教师模型）的知识传递给较小的模型（学生模型）来进行模型压缩。</li><li>量化（Quantization）：量化技术通过减少模型参数和计算的数值精度来压缩模型。</li><li>网络结构简化：网络结构简化是指通过设计更高效的网络结构来减少计算复杂度和参数数量。</li></ul><style>.collapsible {    margin: 1.5rem 0px;    padding: 0.5rem 1rem;    border: 1px solid rgb(229, 230, 235);    border-radius: 2px;    font-size: 15px;}.collapsible summary p {    display: inline;    margin: 0;    padding: 0;    background: none;}</style><h3 id="什么是剪枝">2 什么是剪枝</h3><p>　　神经网络在训练过程中为了捕捉数据中的复杂模式，通常会过参数化，这导致模型拥有大量对最终输出贡献不大的冗余参数。而模型剪枝就是指从深度学习神经网络模型中删除冗余参数（即将其置为0）的技术，它能够在不牺牲太多准确性的前提下压缩模型大小并提高模型的推理速度。</p><blockquote><p>一般来说，只有权重参数（weight）被修剪，而偏置参数（bias）保持不变，因为对偏置的修剪往往会带来更大的负面影响。</p></blockquote><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506112048624.png" style="zoom:60%;" /></p><p>主要有两种方式来实现模型剪枝，即训练时剪枝和训练后剪枝：</p><ul><li>训练时剪枝（train-time pruning）训练时剪枝是在模型训练过程中动态进行剪枝操作的方法。这种方法的核心思想是在训练过程中逐步剪枝，从而使模型在训练结束时已经是一个剪枝后的模型。其优点是剪枝过程与模型训练过程紧密结合，能够在训练结束时直接得到剪枝后的模型，避免了额外的后续微调步骤，节省了训练时间和计算资源。缺点是在训练过程中剪枝可能导致模型训练的不稳定，需要精细调整超参数和剪枝策略，增加了实现的复杂性。</li><li>训练后剪枝（post-training pruning）训练后剪枝是在模型完成训练后对其进行剪枝的方法。先训练一个完整的模型，然后在训练结束后对模型进行剪枝，再进行微调以恢复性能。其优点是剪枝步骤相对独立，无需在训练过程中动态调整剪枝操作，可以根据最终模型的需求选择最优的剪枝策略，再进行微调，以达到更好的性能恢复。缺点是剪枝后可能需要多次微调，才能恢复模型性能。</li></ul><p>在上述两种实现方式中，训练后剪枝更为常用，因为它在实施上简单直接，不需要在训练过程中动态调整剪枝操作，剪枝步骤相对独立且容易实施。</p><h3 id="剪枝的分类">3. 剪枝的分类</h3><h4 id="按剪枝的粒度分">3.1 按剪枝的粒度分</h4><p>根据剪枝的粒度分，剪枝方法可以大致分为以下六种：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506112051964.png" style="zoom:70%;" /></p><blockquote><p>上图展示了在输入通道（即卷积核通道数）是3，输出通道（即卷积核个数）是 2的卷积层上进行六种不同粒度剪枝操作的效果。</p></blockquote><ul><li><p>Fine-grained Pruning（细粒度剪枝）</p><p>细粒度剪枝是指在最细粒度上进行剪枝，即删除某些单个的权重值。这种方法能够在较少的准确率损失下实现更高的剪枝率，但缺点是剪枝后的稀疏矩阵是不规则的（即非零元素的分布是不规则的），这不利于压缩存储和加速计算，需要专门的软硬件支持。</p></li><li><p>Vector-level Pruning（向量级剪枝）</p><p>向量级剪枝是指在向量这一层次上进行参数移除，例如一个神经元的输出权重向量或卷积层中一个滤波器的权重向量。这比细粒度剪枝的范围更大，能够减少剪枝后矩阵的不规则性，便于硬件加速，但在牺牲少量模型表达能力的同时，可能不如细粒度剪枝那样精细地优化模型大小和性能。</p></li><li><p>Kernel-level Pruning（核级剪枝）</p><p>核级剪枝是针对卷积神经网络中的卷积核进行的，即整体移除一个卷积核的所有权重。减少了计算量和模型尺寸，但可能会影响模型捕获细节的能力，因为整个特征检测器被移除。</p></li><li><p>Filter-level Pruning（滤波器级剪枝）</p><p>实质上与核级剪枝相似，滤波器级剪枝专注于从卷积层中移除完整的滤波器。这一策略简化了网络结构，显著降低了计算成本和内存使用，不过可能需要更多的调参来维持原有性能。</p></li><li><p>Channel-level Pruning（通道级剪枝）</p><p>通道级剪枝针对具有通道结构的层，比如卷积层中的通道，移除整个通道的特征映射。这不仅减少了参数量，还可能因通道间潜在的冗余而减少信息重复，但要求对通道重要性有精准的评估，以免损害模型的表达能力。</p></li><li><p>Layer-level Pruning（层级剪枝）</p><p>层级剪枝是最粗粒度的剪枝策略，直接移除整个网络层。这种方法极大地简化了模型结构，加快了推理速度，降低了资源消耗，但需谨慎执行，以防过度简化导致性能急剧下降，需深入分析每一层对最终任务的重要性。</p></li></ul><h4 id="按照剪枝后矩阵是否规则">3.2 按照剪枝后矩阵是否规则</h4><p>按照剪枝后的稀疏矩阵是否规则，剪枝算法也可以分为：</p><ul><li><p>非结构化化剪枝（Unstructured Pruning）</p><p>即细粒度剪枝。非结构化稀疏具有更高的模型压缩率和准确性，在通用硬件上的加速效果不好。因为其计算特征上的“不规则”，导致需要特定硬件支持才能实现加速效果。</p></li><li><p>结构化剪枝（Structured Pruning）</p><p>即向量级、核级、滤波器级、通道级以及层级剪枝。与非结构化剪枝相比，结构化剪枝通常通常会牺牲模型的准确率和压缩比。结构化稀疏对非零权值的位置进行了限制，在剪枝过程中会将一些数值较大的权值移除，从而影响模型准确率。结构化稀疏虽然牺牲了模型压缩率或准确率，但在通用硬件上的加速效果好，所以其被广泛应用。因为结构化稀疏使得权值矩阵更规则更加结构化，更利于硬件加速。</p></li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506112059203.png" style="zoom:67%;" /></p><h4 id="按照不同的修剪范围">3.3 按照不同的修剪范围</h4><ul><li>局部剪枝（Local Pruning）局部剪枝是指在模型的特定部分或局部区域进行参数的删除，它允许更精细地控制模型的哪个部分将被简化。这种方法基于这样的假设：模型的不同部分对最终性能的贡献不同，通过有针对性地剪枝某些局部区域，可以更有效地减少计算量和内存占用，同时尽量保持模型的关键性能。</li><li>全局剪枝（Global Pruning）全局剪枝则是指在整个模型范围内统一进行参数的剪除，不特别区分模型的不同部分。这种方法会基于某种全局性标准（例如基于权值的L1范数）来决定哪些参数被剪枝。全局剪枝简化了剪枝过程的复杂度，因为它应用的是统一的剪枝比例或标准，但可能不够灵活，无法充分考虑到模型内部不同部分的差异性对性能的影响。全局剪枝的一个直接结果是模型的整体稀疏度一致，这有时可能导致某些关键区域的性能下降。</li></ul><h3 id="pytorch-剪枝">4. PyTorch 剪枝</h3><h4 id="pytorch-剪枝的原理">4.1 PyTorch 剪枝的原理</h4><p>　　PyTroch 中神经网络模型或模块类都是继承自 torch.nn.Module类的，该类中和剪枝实现相关的关键属性包括<code>_modules</code>、<code>_parameters</code> 以及<code>_buffers</code>。以下是对这些属性的详细介绍：</p><ul><li><code>_parameters</code>：<code>_parameters</code> 是一个OrderedDict 对象，用于存储当前模块的所有可学习参数（如 weight 和bias）及其参数名称，这些参数会在训练过程中被优化器更新。</li><li><code>_buffers</code>：<code>_buffers</code>是一个 OrderedDict对象，用于存储当前模块的所有非学习参数（如 BN 层的 running mean 和runningvariance，或者存储剪枝掩码）。这些参数不会在训练过程中被优化器更新，而是用于存储模型状态的一部分。</li><li><code>_forward_pre_hooks</code>：<code>_forward_pre_hooks</code>是一个 OrderedDict对象，用于存储在前向传播前需要调用的钩子（hook）函数及其序号，这些钩子函数会在模型的前向传播前执行一些自定义操作。</li></ul><p>并且上述这些属性中的元素都可以通过 del方式删除以及使用模块对象提供的方法进行查询和添加。</p><p>另外，若模块（如nn.Linear、nn.Conv2d）拥有训练参数，则这些训练参数不仅会存储在<code>_parameters</code> 中，也会存储在模块对象的 weight 以及 bias属性中，这些属性是 torch.Tensor 对象（实际上是torch.nn.parameter.Parameter 类型，它 torch.Tensor 类型的子类）：</p><ul><li>weight：weight是一个张量，表示模块的权重参数。它用于在前向传播时与输入进行矩阵进行线性运算。</li><li>bias：bias也是一个张量，表示模块的偏置参数。它在前向传播过程中应用于加到线性变换结果上的偏置值。</li></ul><p>掌握了以上预备知识后，继续介绍 PyTorch剪枝的实现原理，首先定义一个简单的神经网络模型便于演示，以 LeNet网络为例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn <span class="hljs-keyword">as</span> nn<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">from</span> torch.nn.utils <span class="hljs-keyword">import</span> prune<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LeNet</span>(<span class="hljs-params">nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, num_classes=<span class="hljs-number">10</span></span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        self.conv1 = nn.Conv2d(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, kernel_size=<span class="hljs-number">5</span>)<br>        self.conv2 = nn.Conv2d(<span class="hljs-number">6</span>, <span class="hljs-number">16</span>, kernel_size=<span class="hljs-number">5</span>)<br>        self.fc1 = nn.Linear(<span class="hljs-number">16</span> * <span class="hljs-number">4</span> * <span class="hljs-number">4</span>, <span class="hljs-number">120</span>)<br>        self.fc2 = nn.Linear(<span class="hljs-number">120</span>, <span class="hljs-number">84</span>)<br>        self.fc3 = nn.Linear(<span class="hljs-number">84</span>, num_classes)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, x</span>):</span><br>        x = F.relu(self.conv1(x))<br>        x = F.max_pool2d(x, <span class="hljs-number">2</span>)<br>        x = F.relu(self.conv2(x))<br>        x = F.max_pool2d(x, <span class="hljs-number">2</span>)<br>        x = x.view(x.size(<span class="hljs-number">0</span>), -<span class="hljs-number">1</span>)<br>        x = F.relu(self.fc1(x))<br>        x = F.relu(self.fc2(x))<br>        x = self.fc3(x)<br>        <span class="hljs-keyword">return</span> x<br></code></pre></td></tr></table></figure><p>为了方便进行研究，我们只对上述网络中 fc3线性层模块的权重参数（weight）进行研究，首先获取代表 fc3的模块对象：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python">model = LeNet()<br>module = model.fc3<br></code></pre></td></tr></table></figure><p>接下来对剪枝不同阶段时，个属性参数的变化进行介绍：</p><ol type="1"><li><p>剪枝前</p><ul><li><p>module 的 weight 属性和 <code>_parameters</code> 属性中的 weight参数其实是同一个张量对象。也就是说剪枝前的反向传播会同时更新 weight属性和 <code>_parameters</code> 属性中的 weight参数。例如我们输出它们的对象标识：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(module._parameters[<span class="hljs-string">&#x27;weight&#x27;</span>]))<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">id</span>(module.weight))<br></code></pre></td></tr></table></figure><details class="collapsible"><summary><p>点击查看输出结果</p></summary><pre  class=" language-shell"  data-language="shell"><code class="language-shell">17693186813121769318681312</code></pre></details></li><li><p>由于还未进行剪枝，所以 model 的 <code>_buffers</code>缓冲区暂时是空的（这是由于还未在其中生成用于剪枝的掩码张量）。例如我们输出<code>_buffers</code> 的长度：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(module._buffers))<br></code></pre></td></tr></table></figure><details class="collapsible"><summary><p>点击查看输出结果</p></summary><pre  class=" language-shell"  data-language="shell"><code class="language-shell">0</code></pre></details></li></ul></li><li><p>剪枝时</p><p>现在对 module 的权重参数进行随机非结构化剪枝，代码如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python">prune.random_unstructured(module, name=<span class="hljs-string">&quot;weight&quot;</span>, amount=<span class="hljs-number">0.5</span>)<br></code></pre></td></tr></table></figure><p>剪枝时，PyTorch 会具体执行以下步骤：</p><ul><li><p>在 module 的 <code>_parameters</code> 属性中新增一个名为weight_orig 的参数，该参数存储了剪枝前的原始权重张量。并且会删除<code>_parameters</code> 属性中原来的 weight参数（即将原始权重张量的新引用 weight_orig 添加进了<code>_parameters</code>，并将旧引用 weight 从 <code>_parameters</code>中删除了）。例如输出剪枝前后 <code>_parameters</code> 中的参数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Before pruning:&quot;</span>)<br>[<span class="hljs-built_in">print</span>(k, v.shape, <span class="hljs-built_in">id</span>(v)) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> module._parameters.items()]<br>prune.random_unstructured(module, name=<span class="hljs-string">&quot;weight&quot;</span>, amount=<span class="hljs-number">0.5</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;After pruning:&quot;</span>)<br>[<span class="hljs-built_in">print</span>(k, v.shape, <span class="hljs-built_in">id</span>(v)) <span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> module._parameters.items()]<br></code></pre></td></tr></table></figure><details class="collapsible"><summary><p>点击查看输出结果</p></summary><pre  class=" language-shell"  data-language="shell"><code class="language-shell">Before pruning:bias torch.Size([10]) 1769318681392weight torch.Size([10, 84]) 1769318681312After pruning:bias torch.Size([10]) 1769318681392weight_orig torch.Size([10, 84]) 1769318681312</code></pre></details></li><li><p>会在 module 的 <code>_buffers</code>属性中创建一个与权重参数形状相同的掩码张量weight_mask，剪枝的位置在掩码中被设置为零。例如输出剪枝后的<code>_buffers</code> 属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(module._buffers)<br></code></pre></td></tr></table></figure><details class="collapsible"><summary><p>点击查看输出结果</p></summary><pre  class=" language-shell"  data-language="shell"><code class="language-shell">OrderedDict([('weight_mask', tensor([[0., 0., 1., 1., 1., 1., 1., 1., 1., 0., 1., 1., 0., 1., 0., 0., 1., 0.,    1., 1., 1., 0., 1., 1., 0., 1., 1., 0., 0., 1., 0., 1., 0., 0., 0., 1.,    0., 1., 0., 0., 0., 1., 1., 1., 0., 1., 1., 0., 0., 0., 1., 1., 0., 1.,    1., 1., 0., 1., 0., 1., 0., 0., 0., 1., 1., 1., 0., 0., 0., 0., 1., 0.,    1., 0., 1., 0., 0., 0., 1., 1., 1., 0., 1., 0.],# 省略8行   [0., 0., 1., 0., 0., 0., 1., 1., 0., 1., 0., 1., 0., 1., 1., 0., 0., 1.,    1., 1., 1., 0., 0., 1., 1., 0., 0., 0., 1., 1., 0., 0., 0., 0., 1., 1.,    0., 1., 1., 0., 0., 0., 1., 0., 0., 1., 0., 1., 0., 0., 1., 1., 0., 0.,    1., 1., 1., 0., 0., 1., 0., 0., 1., 1., 1., 0., 0., 1., 0., 0., 0., 0.,    1., 1., 0., 0., 1., 1., 1., 0., 0., 0., 0., 0.]]))])</code></pre></details></li><li><p>对 module 的 weight属性进行重参数化，即将掩码应用到参与前向传播的权重参数上（<code>module.weight = weight_mask * weight_orig</code>）。例如输出<code>weight</code> 属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(module.weight)<br></code></pre></td></tr></table></figure><details class="collapsible"><summary><p>点击查看输出结果</p></summary><pre  class=" language-shell"  data-language="shell"><code class="language-shell">tensor([[ 0.0000, -0.0000, -0.0918, -0.0204,  0.0444, -0.0631,  0.0495,  0.0694,     0.0566, -0.0000,  0.0642, -0.0855, -0.0000, -0.0551, -0.0000, -0.0000,     0.0159,  0.0000,  0.0345, -0.0151, -0.0336, -0.0000, -0.0944, -0.0476,     0.0000, -0.0079,  0.0647,  0.0000,  0.0000,  0.0558, -0.0000, -0.0190,     0.0000,  0.0000, -0.0000, -0.0531,  0.0000, -0.0569,  0.0000,  0.0000,     0.0000,  0.0567,  0.0818, -0.0130,  0.0000, -0.0915, -0.0170, -0.0000,    -0.0000,  0.0000,  0.0291, -0.0265, -0.0000,  0.0054,  0.0695,  0.1014,     0.0000, -0.0581, -0.0000, -0.1043, -0.0000, -0.0000, -0.0000,  0.0153,    -0.0820, -0.0215,  0.0000, -0.0000,  0.0000, -0.0000,  0.0226, -0.0000,    -0.0038, -0.0000,  0.0826,  0.0000, -0.0000,  0.0000,  0.0801,  0.0692,     0.1081, -0.0000,  0.0274, -0.0000],   # 省略8行   [-0.0000,  0.0000,  0.0752, -0.0000,  0.0000,  0.0000, -0.0273, -0.0308,    -0.0000, -0.0962,  0.0000,  0.0268,  0.0000,  0.0777,  0.0210, -0.0000,    -0.0000,  0.0507,  0.0736, -0.0917, -0.0100,  0.0000,  0.0000,  0.0922,     0.0657,  0.0000, -0.0000,  0.0000,  0.0682, -0.0926, -0.0000, -0.0000,     0.0000, -0.0000, -0.0571,  0.0771, -0.0000,  0.0821,  0.0468,  0.0000,    -0.0000, -0.0000,  0.0317, -0.0000, -0.0000,  0.0643, -0.0000, -0.0041,     0.0000, -0.0000,  0.0845,  0.0621,  0.0000,  0.0000,  0.0761, -0.0151,     0.0584, -0.0000, -0.0000,  0.0290, -0.0000, -0.0000,  0.0699,  0.0089,     0.0859, -0.0000,  0.0000, -0.0684,  0.0000,  0.0000, -0.0000,  0.0000,     0.0279,  0.0149, -0.0000, -0.0000, -0.0132, -0.0531,  0.0495, -0.0000,     0.0000,  0.0000, -0.0000, -0.0000]], grad_fn=<MulBackward0>)     </code></pre></details></li><li><p>会在 module 的 <code>_forward_pre_hooks</code>属性中注册一个剪枝方法（其实是一个剪枝类对象，在此案例中是RandomUnstructured类对象），该剪枝方法会在每次前向传播之前被调用。例如输出 module 的<code>_forward_pre_hooks</code> 属性：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-built_in">print</span>(module._forward_pre_hooks)<br></code></pre></td></tr></table></figure><details class="collapsible"><summary><p>点击查看输出结果</p></summary><pre  class=" language-shell"  data-language="shell"><code class="language-shell">OrderedDict([(0, &lt;torch.nn.utils.prune.RandomUnstructured object at 0x00000174F3BEC280&gt;)])     </code></pre></details></li></ul></li></ol><h4 id="pytorch-的剪枝函数">4.2 PyTorch 的剪枝函数</h4><p>　　PyTorch 剪枝功能在 torch.nn.utils.prune模块中实现，主要的剪枝类如下图所示：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506121747825.png" style="zoom:12%;" /></p><p>　　以上的剪枝类中 BasePruningMethod 类是 PyTorch中剪枝模块的基础抽象类，它定义了剪枝方法所需的基本接口和属性，它不直接用于剪枝操作，而是供其他具体剪枝方法继承。其他具体的剪枝类从它继承而来的，根据需要进行了定制化和扩展，它们具体功能如下：</p><ul><li>PruningContainer类：是一个容器类，用于将多个剪枝方法组合在一起应用于模型的不同部分。它可以包含多个剪枝方法对象，统一管理和应用这些剪枝方法。</li><li>Identity类：实现了在不修剪任何单元的情况下应用剪枝重参数化的功能，通常作为基准或占位符使用。</li><li>RandomUnstructured 类：实现了随机非结构化剪枝的功能。</li><li>L1Unstructured 类：实现了基于 L1 范数的非结构化剪枝的功能。</li><li>RandomStructured 类：实现了随机结构化剪枝的功能。</li><li>LnStructured 类：实现基于 Ln 范数的构化剪枝的功能。</li><li>CustomFromMask类：实现了根据预定义的掩码对权重张量进行自定义结构化剪枝的功能。</li></ul><p>　　虽然在 torch.nn.utils.prune模块中定义了这些剪枝类，但我们通常不直接实例化和使用它们，而是通过<code>torch.nn.utils.prune</code>模块提供的便捷函数来进行剪枝操作。这些便捷函数对底层的剪枝类进行了封装，使剪枝操作更加简洁和易于使用。下面是对封装函数的详细介绍：</p><ol type="1"><li><p>identity 函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">identity</span>(<span class="hljs-params">module, name</span>)</span><br></code></pre></td></tr></table></figure><p>函数 identity的作用是在不实际移除任何神经网络单元的情况下，对指定模块中的某个参数实施剪枝操作的重新参数化过程。此操作直接修改输入的module 并将其返回。 参数说明：</p><ul><li>module（nn.Module）：需要进行剪枝的神经网络模块。</li><li>name（str）：模块中待进行剪枝的参数名称。</li></ul><p>返回值：</p><ul><li>经过剪枝后的模型模块。</li></ul></li></ol><hr /><ol start="2" type="1"><li><p>random_unstructured 函数 函数 random_unstructured作用是执行随机非结构化剪枝操作。从 module 中名为 name的参数中随机移除指定数量的单元（当前未剪枝的）。此操作直接修改输入的module 并将其返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">random_unstructured</span>(<span class="hljs-params">module, name, amount</span>)</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>module（nn.Module）：需要进行剪枝的神经网络模块。</li><li>name（str）：模块中待进行剪枝的参数名称。</li><li>amount（int 或 float）：若为 float，应介于 0.0 到 1.0之间，表示参数被剪枝的比例；若为 int，则直接表示剪枝的参数个数。</li></ul><p>返回值：</p><ul><li>经过剪枝后的模型模块。</li></ul></li></ol><hr /><ol start="3" type="1"><li><p>l1_unstructured 函数 函数 l1_unstructured 作用是根据 L1范数执行非结构化剪枝操作。从 module 中名为 name 的参数中移除具有最低 L1范数的指定数量的单元（当前未剪枝的）。此操作直接修改输入的 module并将其返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">l1_unstructured</span>(<span class="hljs-params">module, name, amount, importance_scores=<span class="hljs-literal">None</span></span>)</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>module（nn.Module）：需要进行剪枝的神经网络模块。</li><li>name（str）：模块中待进行剪枝的参数名称。</li><li>amount（int 或 float）：若为 float，应介于 0.0 到 1.0之间，表示参数被剪枝的比例；若为 int，则直接表示剪枝的参数个数。</li><li>importance_scores（torch.Tensor,optional）：形状与模块参数相同的重要性分数张量，用于确定剪枝掩码。如果不提供或为None，则使用模块参数本身计算重要性。</li></ul><p>返回值：</p><ul><li>经过剪枝后的模型模块。</li></ul></li></ol><hr /><ol start="4" type="1"><li><p>random_structured 函数 函数 random_structured执行随机结构化剪枝操作。从 module 中名为 name 的参数中沿着指定的 dim维度随机选择并移指定数量的结构（如向量、卷积核，通道等）。此操作直接修改输入的module 并将其返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">random_structured</span>(<span class="hljs-params">module, name, amount, dim</span>)</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>module（nn.Module）：需要进行剪枝的神经网络模块。</li><li>name（str）：模块中待进行剪枝的参数名称。</li><li>amount（int 或 float）：若为 float，应介于 0.0 到 1.0之间，表示参数被剪枝的比例；若为 int，则直接表示剪枝的参数个数。</li><li>dim（int）：指定要进行剪枝的维度索引。</li></ul><p>返回值：</p><ul><li>经过剪枝后的模型模块。</li></ul></li></ol><hr /><ol start="5" type="1"><li><p>ln_structured 函数 函数 ln_structured 依据指定维度上的最低 Ln范数执行结构化剪枝操作。移除选定数量的通道。从 module 中名为 name的参数中沿着指定的 dim 维度中移除具有最低 Ln范数的指定数量的结构（如向量、卷积核，通道等）。此操作直接修改输入的module 并将其返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">ln_structured</span>(<span class="hljs-params">module, name, amount, n, dim, importance_scores=<span class="hljs-literal">None</span></span>)</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>module（nn.Module）：需要进行剪枝的神经网络模块。</li><li>name（str）：模块中待进行剪枝的参数名称。</li><li>amount（int 或 float）：若为 float，应介于 0.0 到 1.0之间，表示参数被剪枝的比例；若为 int，则直接表示剪枝的参数个数。</li><li>n（int 或 float）：规定了用于计算范数的类型，对应于 torch.norm函数中的 p 参数，用于衡量权重的重要性。</li><li>dim（int）：指定要进行剪枝的维度索引。</li><li>importance_scores（torch.Tensor,optional）：形状与模块参数相同的重要性分数张量，用于确定剪枝掩码。如果不提供或为None，则使用模块参数本身计算重要性。</li></ul><p>返回值：</p><ul><li>经过剪枝后的模型模块。</li></ul><hr /></li><li><p>global_unstructured 函数 函数 global_unstructured作用是执行全局非结构化剪枝操作，它的核心作用是在不考虑参数空间结构的情况下，基于全局重要性评估，统一决定哪些参数进行剪枝。这允许开发者跨多个层或模块统一剪枝标准，简化剪枝过程，尤其适合于想要快速减小模型大小而不过多考虑特定结构影响的情况。此操作直接修改输入的module 并将其返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">global_unstructured</span>(<span class="hljs-params">parameters, pruning_method, importance_scores=<span class="hljs-literal">None</span>, **kwargs</span>)</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>parameters（Iterable of (module, name) tuples）：这是一个包含多个<code>(module, name)</code> 对的可迭代对象，其中 module 是 nn.Module类型的神经网络层，name 是该层中参数的名称（通常是权重 weight 或偏置bias）。这些参数将被全局地、非结构化地进行剪枝。</li><li>pruning_method（function）：一个剪枝函数，用于确定进行非结构化剪枝的方式。内置的非结构化剪枝方法有：（1）L1Unstructured （2）RandomUnstructured</li><li>importance_scores（dict, optional）: 一个字典，映射每个<code>(module, name)</code>对到一个同形状的重要性分数张量。这些分数用于决定剪枝哪些元素。如果不提供或为None，则使用模块参数本身计算重要性。</li><li>kwargs：其他关键字参数，最常见的是amount，用于指定剪枝的数量或比例。</li></ul><p>返回值：</p><ul><li>经过剪枝后的模型模块。</li></ul></li></ol><hr /><ol start="7" type="1"><li><p>custom_from_mask 函数 custom_from_mask函数允许用户使用预先计算好的掩码（mask）来对模块中的特定参数进行剪枝。这个函数主要用于自定义剪枝策略，当用户已经知道哪些元素应该被剪枝，或者从其他来源获取了剪枝掩码时使用。此操作直接修改输入的module 并将其返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">custom_from_mask</span>(<span class="hljs-params">module, name, mask</span>)</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>module（nn.Module）：需要进行剪枝的神经网络模块。</li><li>name（str）：模块中待进行剪枝的参数名称。</li><li>mask（Tensor）：二进制掩码张量，其形状与目标参数相同。</li></ul><p>返回值：</p><ul><li>经过剪枝后的模型模块。</li></ul></li></ol><hr /><ol start="8" type="1"><li><p>remove 函数 remove函数的作用是从给定的模块中移除之前应用的剪枝重新参数化，以及从前向传播钩子中移除剪枝方法。这意味着，虽然之前被剪枝的参数状态（按照剪枝掩码永久剪枝）会被保留，但是与剪枝相关的额外组件（原始参数和掩码）会被清理，使得模型更加简洁，以便于后续的部署或进一步处理。</p><p>该操作并不“撤销”剪枝，也就是说，被剪枝的权重并不会被恢复。它只是移除了剪枝的痕迹，使得模型看起来像一个未经剪枝的模型，但是剪枝的效果（即参数的缺失）仍然存在。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove</span>(<span class="hljs-params">module, name</span>)</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>module（nn.Module）： 需要移除剪枝设置的神经网络模块。</li><li>name（str）：要移除剪枝参数的名称，该参数在之前已经被剪枝过。</li></ul><p>返回值：</p><ul><li>None</li></ul></li></ol><hr /><ol start="9" type="1"><li><p>is_pruned 函数 is_pruned函数用于检查给定的神经网络模块是否已经应用了剪枝操作。它通过检测模块中是否存在继承自BasePruningMethod 的前向传播预钩子来判断模块是否已被剪枝。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">is_pruned</span>(<span class="hljs-params">module</span>)</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>module（nn.Module）： 需要检查是否经过剪枝的神经网络模块。</li></ul><p>返回值：</p><ul><li>果模块已应用剪枝，则返回 True；否则，返回 False。</li></ul></li></ol><h3 id="剪枝的代码实现">5. 剪枝的代码实现</h3><h4 id="导入必要的依赖">5.1 导入必要的依赖</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> time<br><br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">import</span> torch.nn.functional <span class="hljs-keyword">as</span> F<br><span class="hljs-keyword">import</span> tqdm<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> torch.nn.utils <span class="hljs-keyword">import</span> prune<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> torchvision <span class="hljs-keyword">import</span> transforms, models<br><span class="hljs-keyword">from</span> torchvision.datasets <span class="hljs-keyword">import</span> CIFAR10<br></code></pre></td></tr></table></figure><h4 id="定义训练早停类">5.2 定义训练早停类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EarlyStopping</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, patience=<span class="hljs-number">100</span>, min_delta=<span class="hljs-number">0</span></span>):</span><br>        <span class="hljs-keyword">if</span> patience &lt;= <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;patience must be a positive integer&#x27;</span>)<br>        <span class="hljs-keyword">if</span> min_delta &lt; <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">raise</span> ValueError(<span class="hljs-string">&#x27;min_delta must be a positive number&#x27;</span>)<br><br>        self.patience = patience<br>        self.current_patience = patience<br>        self.min_delta = min_delta<br>        self.early_stop = <span class="hljs-literal">False</span><br>        self.best_acc = <span class="hljs-number">0</span><br>        self.best_loss = <span class="hljs-literal">None</span><br>        self.best_epoch = <span class="hljs-literal">None</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__call__</span>(<span class="hljs-params">self, val_loss, val_acc, epoch</span>):</span><br>        <span class="hljs-keyword">if</span> val_acc &gt; self.best_acc + self.min_delta:<br>            self.current_patience = self.patience<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Epoch <span class="hljs-subst">&#123;epoch&#125;</span>: &#x27;</span><br>                  <span class="hljs-string">f&quot;best acc improved from <span class="hljs-subst">&#123;self.best_acc:<span class="hljs-number">.4</span>f&#125;</span> to <span class="hljs-subst">&#123;val_acc:<span class="hljs-number">.4</span>f&#125;</span>, &quot;</span><br>                  <span class="hljs-string">f&#x27;current patience reset to <span class="hljs-subst">&#123;self.patience&#125;</span>&#x27;</span>)<br>            self.best_acc = val_acc<br>            self.best_loss = val_loss<br>            self.best_epoch = epoch<br>        <span class="hljs-keyword">else</span>:<br>            self.current_patience -= <span class="hljs-number">1</span><br>            <span class="hljs-keyword">if</span> self.current_patience &lt;= <span class="hljs-number">0</span>:<br>                self.early_stop = <span class="hljs-literal">True</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.patience&#125;</span> patience exhausted, early stopping! &quot;</span><br>                      <span class="hljs-string">f&quot;Best acc: <span class="hljs-subst">&#123;self.best_acc:<span class="hljs-number">.4</span>f&#125;</span>, &quot;</span><br>                      <span class="hljs-string">f&quot;and best loss: <span class="hljs-subst">&#123;self.best_loss:<span class="hljs-number">.4</span>f&#125;</span>,&quot;</span><br>                      <span class="hljs-string">f&quot;appear at epoch <span class="hljs-subst">&#123;self.best_epoch&#125;</span>&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Epoch <span class="hljs-subst">&#123;epoch&#125;</span>: &#x27;</span><br>                      <span class="hljs-string">f&#x27;best acc did not improve from <span class="hljs-subst">&#123;self.best_acc:<span class="hljs-number">.4</span>f&#125;</span>, &#x27;</span><br>                      <span class="hljs-string">f&#x27;current patience: <span class="hljs-subst">&#123;self.current_patience&#125;</span>/<span class="hljs-subst">&#123;self.patience&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">return</span> self.early_stop<br></code></pre></td></tr></table></figure><h4 id="定义训练基础类">5.3 定义训练基础类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseTrainer</span>:</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,</span></span><br><span class="hljs-params"><span class="hljs-function">                 num_epochs,</span></span><br><span class="hljs-params"><span class="hljs-function">                 batch_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                 save_dir=<span class="hljs-string">&quot;weight&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 device=<span class="hljs-string">&quot;cuda&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 num_workers=<span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 patience=<span class="hljs-number">10</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 min_delta=<span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 </span>):</span><br>        <span class="hljs-comment"># 设置随机种子</span><br>        seed = <span class="hljs-number">42</span><br>        torch.manual_seed(seed)<br>        torch.cuda.manual_seed(seed)<br>        torch.cuda.manual_seed_all(seed)<br>        torch.backends.cudnn.deterministic = <span class="hljs-literal">True</span><br>        torch.backends.cudnn.benchmark = <span class="hljs-literal">False</span><br><br>        <span class="hljs-comment"># 设置设备</span><br>        <span class="hljs-keyword">if</span> device == <span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">and</span> torch.cuda.is_available():<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Using GPU for training&quot;</span>)<br>            self.device = torch.device(<span class="hljs-string">&quot;cuda&quot;</span>)<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> torch.cuda.is_available():<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;CUDA is not available, using CPU instead&quot;</span>)<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;Using CPU for training&quot;</span>)<br>            self.device = torch.device(<span class="hljs-string">&quot;cpu&quot;</span>)<br><br>        <span class="hljs-comment"># 定义输出位置</span><br>        self.save_dir = save_dir<br>        <span class="hljs-keyword">if</span> <span class="hljs-keyword">not</span> os.path.exists(self.save_dir):  <span class="hljs-comment"># 如果不存在该目录，则创建该目录</span><br>            os.makedirs(self.save_dir)<br><br>        <span class="hljs-comment"># 加载模型</span><br>        self.model = self.load_model()<br>        self.model.to(self.device)<br><br>        <span class="hljs-comment"># 定义训练参数</span><br>        self.num_epochs = num_epochs<br>        self.batch_size = batch_size<br>        self.num_workers = num_workers<br>        self.optimizer, self.scheduler = self.load_optimizer_and_scheduler()<br>        self.early_stopping = EarlyStopping(patience=patience, min_delta=min_delta)<br>        self.history = []<br>        self.train_loader, self.test_loader = self.get_data_loader()<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_data_loader</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 计算训练集的mean和std</span><br>        dataset = CIFAR10(root=<span class="hljs-string">&#x27;data&#x27;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>, transform=transforms.ToTensor())<br>        data_loader = DataLoader(dataset, batch_size=<span class="hljs-built_in">len</span>(dataset), num_workers=self.num_workers)<br>        data = <span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(data_loader))<br>        mean = torch.mean(data[<span class="hljs-number">0</span>], dim=(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).tolist()  <span class="hljs-comment"># 计算均值</span><br>        std = torch.std(data[<span class="hljs-number">0</span>], dim=(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).tolist()  <span class="hljs-comment"># 计算标准差</span><br><br>        <span class="hljs-comment"># 定义数据预处理</span><br>        train_transform = transforms.Compose([  <span class="hljs-comment"># 定义训练集的预处理</span><br>            transforms.RandomCrop(<span class="hljs-number">32</span>, padding=<span class="hljs-number">4</span>),  <span class="hljs-comment"># 随机裁剪，增强模型对图像位置的鲁棒性</span><br>            transforms.RandomHorizontalFlip(),  <span class="hljs-comment"># 随机水平翻转，增加数据的多样性</span><br>            transforms.ColorJitter(brightness=<span class="hljs-number">0.2</span>, contrast=<span class="hljs-number">0.2</span>, saturation=<span class="hljs-number">0.2</span>),  <span class="hljs-comment"># 颜色抖动，增强模型对颜色变化的鲁棒性</span><br>            transforms.RandomRotation(<span class="hljs-number">15</span>),  <span class="hljs-comment"># 随机旋转，增加模型对旋转变换的鲁棒性</span><br>            transforms.ToTensor(),<br>            transforms.Normalize(mean, std),<br>        ])<br><br>        test_transform = transforms.Compose([  <span class="hljs-comment"># 定义测试集的预处理</span><br>            transforms.ToTensor(),<br>            transforms.Normalize(mean, std)<br>        ])<br><br>        <span class="hljs-comment"># 创建数据集和数据加载器</span><br>        train_dataset = CIFAR10(root=<span class="hljs-string">&#x27;data&#x27;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>, transform=train_transform)<br>        test_dataset = CIFAR10(root=<span class="hljs-string">&#x27;data&#x27;</span>, train=<span class="hljs-literal">False</span>, download=<span class="hljs-literal">True</span>, transform=test_transform)<br>        train_loader = DataLoader(train_dataset, batch_size=self.batch_size, shuffle=<span class="hljs-literal">True</span>, num_workers=self.num_workers)<br>        test_loader = DataLoader(test_dataset, batch_size=self.batch_size, shuffle=<span class="hljs-literal">False</span>, num_workers=self.num_workers)<br>        <span class="hljs-keyword">return</span> train_loader, test_loader<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_model</span>(<span class="hljs-params">self</span>):</span><br>        num_classes = <span class="hljs-number">10</span><br>        model = models.resnet18(weights=models.ResNet18_Weights.DEFAULT)<br>        model.fc = torch.nn.Linear(model.fc.in_features, num_classes)<br>        <span class="hljs-keyword">return</span> model<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_optimizer_and_scheduler</span>(<span class="hljs-params">self</span>):</span><br>        lr = <span class="hljs-number">0.01</span><br>        momentum = <span class="hljs-number">0.9</span><br>        weight_decay = <span class="hljs-number">1e-4</span><br>        optimizer = torch.optim.SGD(self.model.parameters(), lr=lr, momentum=momentum, weight_decay=weight_decay)<br>        scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=self.num_epochs)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Optimizer: <span class="hljs-subst">&#123;optimizer.__class__.__name__&#125;</span>, lr=<span class="hljs-subst">&#123;lr&#125;</span>, momentum=<span class="hljs-subst">&#123;momentum&#125;</span>, weight_decay=<span class="hljs-subst">&#123;weight_decay&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Scheduler: <span class="hljs-subst">&#123;scheduler.__class__.__name__&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;You can change the optimizer and scheduler in the load_optimizer_and_scheduler method!&quot;</span>)<br>        <span class="hljs-keyword">return</span> optimizer, scheduler<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_model</span>(<span class="hljs-params">self, filename</span>):</span><br>        torch.save(self.model.state_dict(), os.path.join(self.save_dir, <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;filename&#125;</span>.pt&quot;</span>))<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_graph</span>(<span class="hljs-params">self, epoch</span>):</span><br>        <span class="hljs-comment"># 展示训练过程</span><br>        history_np = np.array(self.history)<br>        plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>))  <span class="hljs-comment"># 创建一个10*10的画布绘制损失曲线图</span><br>        plt.plot(np.arange(<span class="hljs-number">1</span>, epoch + <span class="hljs-number">1</span>), (history_np[:, [<span class="hljs-number">0</span>, <span class="hljs-number">2</span>]]))  <span class="hljs-comment"># 画出训练集损失和验证集损失</span><br>        plt.legend([<span class="hljs-string">&#x27;Train Loss&#x27;</span>, <span class="hljs-string">&#x27;Test Loss&#x27;</span>])  <span class="hljs-comment"># 显示图例</span><br>        plt.xlabel(<span class="hljs-string">&#x27;Epoch&#x27;</span>)  <span class="hljs-comment"># 设置x轴标签</span><br>        plt.ylabel(<span class="hljs-string">&#x27;Loss&#x27;</span>)  <span class="hljs-comment"># 设置y轴标签</span><br>        x_ticks = np.arange(<span class="hljs-number">0</span>, epoch + <span class="hljs-number">1</span>, step=<span class="hljs-number">10</span>)<br>        x_ticks[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>  <span class="hljs-comment"># epoch是从1开始的</span><br>        plt.xticks(x_ticks)  <span class="hljs-comment"># 设置坐标轴刻度</span><br>        plt.yticks(np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">2.05</span>, <span class="hljs-number">0.1</span>))  <span class="hljs-comment"># 设置坐标轴刻度</span><br>        plt.grid()  <span class="hljs-comment"># 画出网格</span><br>        plt.gca().set_ylim([<span class="hljs-number">0</span>, <span class="hljs-number">2</span>])  <span class="hljs-comment"># 设置y轴范围</span><br>        best_test_loss_idx = np.argmin(history_np[:, <span class="hljs-number">2</span>])<br>        best_test_loss = history_np[best_test_loss_idx, <span class="hljs-number">2</span>]<br>        plt.text(<br>            <span class="hljs-number">0.1</span>,<br>            <span class="hljs-number">1.05</span>,<br>            <span class="hljs-string">f&#x27;Best test loss: <span class="hljs-subst">&#123;best_test_loss:<span class="hljs-number">.4</span>f&#125;</span>, epoch: <span class="hljs-subst">&#123;best_test_loss_idx + <span class="hljs-number">1</span>&#125;</span>&#x27;</span>,<br>            ha=<span class="hljs-string">&#x27;center&#x27;</span>,<br>            va=<span class="hljs-string">&#x27;center&#x27;</span>,<br>            transform=plt.gca().transAxes<br>        )<br>        plt.savefig(os.path.join(self.save_dir, <span class="hljs-string">&#x27;loss_curve.png&#x27;</span>))  <span class="hljs-comment"># 保存图片</span><br>        plt.close()  <span class="hljs-comment"># 关闭画布</span><br><br>        plt.figure(figsize=(<span class="hljs-number">10</span>, <span class="hljs-number">10</span>))  <span class="hljs-comment"># 创建一个10*10的画布绘制准确率曲线图</span><br>        plt.plot(np.arange(<span class="hljs-number">1</span>, epoch + <span class="hljs-number">1</span>), (history_np[:, [<span class="hljs-number">1</span>, <span class="hljs-number">3</span>]]))  <span class="hljs-comment"># 画出训练集准确率和验证集准确率</span><br>        plt.legend([<span class="hljs-string">&#x27;Train Accuracy&#x27;</span>, <span class="hljs-string">&#x27;Test Accuracy&#x27;</span>])  <span class="hljs-comment"># 显示图例</span><br>        plt.xlabel(<span class="hljs-string">&#x27;Epoch&#x27;</span>)  <span class="hljs-comment"># 设置x轴标签</span><br>        plt.ylabel(<span class="hljs-string">&#x27;Accuracy&#x27;</span>)  <span class="hljs-comment"># 设置y轴标签</span><br>        x_ticks = np.arange(<span class="hljs-number">0</span>, epoch + <span class="hljs-number">1</span>, step=<span class="hljs-number">10</span>)<br>        x_ticks[<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>  <span class="hljs-comment"># epoch是从1开始的</span><br>        plt.xticks(x_ticks)  <span class="hljs-comment"># 设置坐标轴刻度</span><br>        plt.yticks(np.arange(<span class="hljs-number">0</span>, <span class="hljs-number">1.05</span>, <span class="hljs-number">0.05</span>))  <span class="hljs-comment"># 设置坐标轴刻度</span><br>        plt.grid()  <span class="hljs-comment"># 画出网格</span><br>        best_test_acc_idx = np.argmax(history_np[:, <span class="hljs-number">3</span>])<br>        best_test_acc = history_np[best_test_acc_idx, <span class="hljs-number">3</span>]<br>        plt.text(<br>            <span class="hljs-number">0.1</span>,<br>            <span class="hljs-number">1.05</span>,<br>            <span class="hljs-string">f&#x27;Best test acc: <span class="hljs-subst">&#123;best_test_acc:<span class="hljs-number">.4</span>f&#125;</span>, epoch: <span class="hljs-subst">&#123;best_test_acc_idx + <span class="hljs-number">1</span>&#125;</span>&#x27;</span>,<br>            ha=<span class="hljs-string">&#x27;center&#x27;</span>,<br>            va=<span class="hljs-string">&#x27;center&#x27;</span>,<br>            transform=plt.gca().transAxes<br>        )<br>        plt.savefig(os.path.join(self.save_dir, <span class="hljs-string">&#x27;acc_curve.png&#x27;</span>))  <span class="hljs-comment"># 保存图片</span><br>        plt.close()  <span class="hljs-comment"># 关闭画布</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span>(<span class="hljs-params">self, epoch</span>):</span><br>        train_total_loss = <span class="hljs-number">0</span><br>        train_total_acc = <span class="hljs-number">0</span><br>        self.model.train()<br>        <span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> tqdm.tqdm(self.train_loader, total=<span class="hljs-built_in">len</span>(self.train_loader),<br>                                        desc=<span class="hljs-string">f&#x27;Training Epoch <span class="hljs-subst">&#123;epoch&#125;</span>/<span class="hljs-subst">&#123;self.num_epochs&#125;</span>&#x27;</span>, delay=<span class="hljs-number">0.1</span>):<br>            images = images.to(self.device)<br>            labels = labels.to(self.device)<br>            outputs = self.model(images)<br>            loss = F.cross_entropy(outputs, labels)<br>            self.optimizer.zero_grad()<br>            loss.backward()<br>            self.optimizer.step()<br>            train_total_loss += loss.item()<br>            train_total_acc += (outputs.argmax(dim=<span class="hljs-number">1</span>) == labels).<span class="hljs-built_in">float</span>().<span class="hljs-built_in">sum</span>().item()<br>        train_avg_loss = train_total_loss / <span class="hljs-built_in">len</span>(self.train_loader)<br>        train_avg_acc = train_total_acc / <span class="hljs-built_in">len</span>(self.train_loader.dataset)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Epoch <span class="hljs-subst">&#123;epoch&#125;</span>/<span class="hljs-subst">&#123;self.num_epochs&#125;</span>, Train Loss: <span class="hljs-subst">&#123;train_avg_loss:<span class="hljs-number">.4</span>f&#125;</span>, Train Acc: <span class="hljs-subst">&#123;train_avg_acc:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">return</span> train_avg_loss, train_avg_acc<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>(<span class="hljs-params">self, epoch</span>):</span><br>        test_total_loss = <span class="hljs-number">0</span><br>        test_total_acc = <span class="hljs-number">0</span><br>        self.model.<span class="hljs-built_in">eval</span>()<br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            <span class="hljs-keyword">for</span> images, labels <span class="hljs-keyword">in</span> tqdm.tqdm(self.test_loader, total=<span class="hljs-built_in">len</span>(self.test_loader),<br>                                            desc=<span class="hljs-string">f&#x27;Testing Epoch <span class="hljs-subst">&#123;epoch&#125;</span>/<span class="hljs-subst">&#123;self.num_epochs&#125;</span>&#x27;</span>, delay=<span class="hljs-number">0.1</span>):<br>                images = images.to(self.device)<br>                labels = labels.to(self.device)<br>                outputs = self.model(images)<br>                loss = F.cross_entropy(outputs, labels)<br>                test_total_loss += loss.item()<br>                test_total_acc += (outputs.argmax(dim=<span class="hljs-number">1</span>) == labels).<span class="hljs-built_in">float</span>().<span class="hljs-built_in">sum</span>().item()<br>        test_avg_loss = test_total_loss / <span class="hljs-built_in">len</span>(self.test_loader)<br>        test_avg_acc = test_total_acc / <span class="hljs-built_in">len</span>(self.test_loader.dataset)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;Epoch <span class="hljs-subst">&#123;epoch&#125;</span>/<span class="hljs-subst">&#123;self.num_epochs&#125;</span>, Test Loss: <span class="hljs-subst">&#123;test_avg_loss:<span class="hljs-number">.4</span>f&#125;</span>, Test Acc: <span class="hljs-subst">&#123;test_avg_acc:<span class="hljs-number">.4</span>f&#125;</span>&#x27;</span>)<br>        <span class="hljs-keyword">return</span> test_avg_loss, test_avg_acc<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">run</span>(<span class="hljs-params">self</span>):</span><br>        start_time = time.time()  <span class="hljs-comment"># 记录开始时间</span><br>        <span class="hljs-keyword">if</span> self.history:<br>            <span class="hljs-keyword">raise</span> Exception(<span class="hljs-string">&quot;This object has already run, please create a new object&quot;</span>)<br>        <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">1</span>, <span class="hljs-number">1</span> + self.num_epochs):<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Current lr: <span class="hljs-subst">&#123;self.scheduler.get_last_lr()[<span class="hljs-number">0</span>]:<span class="hljs-number">.6</span>f&#125;</span>&quot;</span>)<br>            train_loss, train_acc = self.train(epoch)<br>            test_loss, test_acc = self.test(epoch)<br>            self.history.append((train_loss, train_acc, test_loss, test_acc))<br>            self.scheduler.step()<br>            self.save_graph(epoch)<br>            self.save_model(<span class="hljs-string">&quot;last&quot;</span>)<br>            <span class="hljs-keyword">if</span> self.early_stopping(test_loss, test_acc, epoch):<br>                <span class="hljs-keyword">break</span><br>            <span class="hljs-keyword">if</span> self.early_stopping.current_patience == self.early_stopping.patience:<br>                self.save_model(<span class="hljs-string">&quot;best&quot;</span>)<br>            <span class="hljs-built_in">print</span>()<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Training finished. &quot;</span><br>              <span class="hljs-string">f&quot;Best acc: <span class="hljs-subst">&#123;self.early_stopping.best_acc:<span class="hljs-number">.4</span>f&#125;</span> &quot;</span><br>              <span class="hljs-string">f&quot;and best loss: <span class="hljs-subst">&#123;self.early_stopping.best_loss:<span class="hljs-number">.4</span>f&#125;</span> &quot;</span><br>              <span class="hljs-string">f&quot;appear at epoch <span class="hljs-subst">&#123;self.early_stopping.best_epoch&#125;</span>&quot;</span>)<br>        end_time = time.time()  <span class="hljs-comment"># 记录结束时间</span><br>        period = <span class="hljs-built_in">round</span>(end_time - start_time)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&#x27;All time: <span class="hljs-subst">&#123;period&#125;</span> s&#x27;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;All Time: <span class="hljs-subst">&#123;period // <span class="hljs-number">60</span>:d&#125;</span> min <span class="hljs-subst">&#123;period % <span class="hljs-number">60</span>:d&#125;</span> s&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="定义剪枝训练类">5.4 定义剪枝训练类</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PruneTrainer</span>(<span class="hljs-params">BaseTrainer</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self,</span></span><br><span class="hljs-params"><span class="hljs-function">                 num_epochs,</span></span><br><span class="hljs-params"><span class="hljs-function">                 batch_size,</span></span><br><span class="hljs-params"><span class="hljs-function">                 save_dir=<span class="hljs-string">&quot;weight&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 device=<span class="hljs-string">&quot;cuda&quot;</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 num_workers=<span class="hljs-number">0</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 patience=<span class="hljs-number">10</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">                 min_delta=<span class="hljs-number">0</span></span></span><br><span class="hljs-params"><span class="hljs-function">                 </span>):</span><br>        <span class="hljs-built_in">super</span>().__init__(num_epochs, batch_size, save_dir, device, num_workers, patience, min_delta)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_data_loader</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-comment"># 计算训练集的mean和std</span><br>        dataset = CIFAR10(root=<span class="hljs-string">&#x27;data&#x27;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>, transform=transforms.ToTensor())<br>        data_loader = DataLoader(dataset, batch_size=<span class="hljs-built_in">len</span>(dataset), num_workers=self.num_workers)<br>        data = <span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(data_loader))<br>        mean = torch.mean(data[<span class="hljs-number">0</span>], dim=(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).tolist()  <span class="hljs-comment"># 计算均值</span><br>        std = torch.std(data[<span class="hljs-number">0</span>], dim=(<span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)).tolist()  <span class="hljs-comment"># 计算标准差</span><br><br>        <span class="hljs-comment"># 定义数据预处理</span><br>        train_transform = transforms.Compose([  <span class="hljs-comment"># 定义训练集的预处理</span><br>            transforms.RandomCrop(<span class="hljs-number">32</span>, padding=<span class="hljs-number">4</span>),  <span class="hljs-comment"># 随机裁剪，增强模型对图像位置的鲁棒性</span><br>            transforms.RandomHorizontalFlip(),  <span class="hljs-comment"># 随机水平翻转，增加数据的多样性</span><br>            transforms.ColorJitter(brightness=<span class="hljs-number">0.2</span>, contrast=<span class="hljs-number">0.2</span>, saturation=<span class="hljs-number">0.2</span>),  <span class="hljs-comment"># 颜色抖动，增强模型对颜色变化的鲁棒性</span><br>            transforms.RandomRotation(<span class="hljs-number">15</span>),  <span class="hljs-comment"># 随机旋转，增加模型对旋转变换的鲁棒性</span><br>            transforms.ToTensor(),<br>            transforms.Normalize(mean, std),<br>        ])<br><br>        test_transform = transforms.Compose([  <span class="hljs-comment"># 定义测试集的预处理</span><br>            transforms.ToTensor(),<br>            transforms.Normalize(mean, std)<br>        ])<br><br>        <span class="hljs-comment"># 创建数据集和数据加载器</span><br>        train_dataset = CIFAR10(root=<span class="hljs-string">&#x27;data&#x27;</span>, train=<span class="hljs-literal">True</span>, download=<span class="hljs-literal">True</span>, transform=train_transform)<br>        test_dataset = CIFAR10(root=<span class="hljs-string">&#x27;data&#x27;</span>, train=<span class="hljs-literal">False</span>, download=<span class="hljs-literal">True</span>, transform=test_transform)<br>        train_loader = DataLoader(train_dataset, batch_size=self.batch_size, shuffle=<span class="hljs-literal">True</span>, num_workers=self.num_workers)<br>        test_loader = DataLoader(test_dataset, batch_size=self.batch_size, shuffle=<span class="hljs-literal">False</span>, num_workers=self.num_workers)<br>        <span class="hljs-keyword">return</span> train_loader, test_loader<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_model</span>(<span class="hljs-params">self</span>):</span><br>        num_classes = <span class="hljs-number">10</span><br>        model = models.resnet18(weights=models.ResNet18_Weights.DEFAULT)<br>        model.fc = torch.nn.Linear(model.fc.in_features, num_classes)<br>        <span class="hljs-keyword">return</span> model<br></code></pre></td></tr></table></figure><h4 id="定义施加剪枝和移除剪枝的函数">5.5定义施加剪枝和移除剪枝的函数</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">apply_pruning</span>(<span class="hljs-params">model, prune_rate</span>):</span><br>    <span class="hljs-keyword">for</span> name, module <span class="hljs-keyword">in</span> model.named_modules():<br>        <span class="hljs-comment"># 对layer进行L1结构化剪枝</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(module, torch.nn.Conv2d):  <span class="hljs-comment"># 不对resent18的全连接层进行剪枝，因为是输出层</span><br>            <span class="hljs-keyword">if</span> prune_rate &gt; <span class="hljs-number">0</span>:<br>                prune.l1_unstructured(module, <span class="hljs-string">&#x27;weight&#x27;</span>, amount=prune_rate)<br>            <span class="hljs-keyword">else</span>:<br>                prune.identity(module, <span class="hljs-string">&#x27;weight&#x27;</span>)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">remove_pruning</span>(<span class="hljs-params">model</span>):</span><br>    <span class="hljs-keyword">for</span> name, module <span class="hljs-keyword">in</span> model.named_modules():<br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">isinstance</span>(module, torch.nn.Conv2d) <span class="hljs-keyword">or</span> <span class="hljs-built_in">isinstance</span>(module, torch.nn.Linear):<br>            <span class="hljs-keyword">if</span> prune.is_pruned(module):<br>                prune.remove(module, <span class="hljs-string">&#x27;weight&#x27;</span>)<br></code></pre></td></tr></table></figure><h4 id="开始训练">5.6 开始训练</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    total_prune_rate = <span class="hljs-number">0</span><br>    per_prune_rate = <span class="hljs-number">0.5</span><br>    acc_decay_tol = <span class="hljs-number">0.02</span><br>    prune_trainer = PruneTrainer(<br>        num_epochs=<span class="hljs-number">100</span>,<br>        batch_size=<span class="hljs-number">256</span>,<br>        patience=<span class="hljs-number">20</span>,<br>        min_delta=<span class="hljs-number">0</span>,<br>        num_workers=<span class="hljs-number">2</span>,<br>        save_dir=<span class="hljs-string">f&quot;prune/rate_<span class="hljs-subst">&#123;total_prune_rate&#125;</span>&quot;</span>)<br>    apply_pruning(prune_trainer.model, <span class="hljs-number">0</span>)  <span class="hljs-comment"># 将模型剪枝化</span><br>    prune_trainer.run()<br>    history_best_acc = prune_trainer.early_stopping.best_acc<br>    pre_weight = torch.load(<span class="hljs-string">f&quot;prune/rate_<span class="hljs-subst">&#123;total_prune_rate&#125;</span>/best.pt&quot;</span>)<br>    pre_total_prune_rate = <span class="hljs-number">0</span><br>    pre_best_acc = prune_trainer.early_stopping.best_acc<br><br>    <span class="hljs-keyword">while</span> total_prune_rate &lt; <span class="hljs-number">1</span>:<br>        total_prune_rate += (<span class="hljs-number">1</span> - total_prune_rate) * per_prune_rate<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;prune rate: <span class="hljs-subst">&#123;total_prune_rate&#125;</span>&quot;</span>)<br>        prune_trainer = PruneTrainer(<br>            num_epochs=<span class="hljs-number">100</span>,<br>            batch_size=<span class="hljs-number">256</span>,<br>            patience=<span class="hljs-number">20</span>,<br>            min_delta=<span class="hljs-number">0</span>,<br>            num_workers=<span class="hljs-number">2</span>,<br>            save_dir=<span class="hljs-string">f&quot;prune/rate_<span class="hljs-subst">&#123;total_prune_rate&#125;</span>&quot;</span>)<br>        apply_pruning(prune_trainer.model, <span class="hljs-number">0</span>)<br>        prune_trainer.model.load_state_dict(pre_weight)<br>        apply_pruning(prune_trainer.model, total_prune_rate)<br>        prune_trainer.run()<br>        <span class="hljs-keyword">if</span> prune_trainer.early_stopping.best_acc &lt; history_best_acc - acc_decay_tol:<br>            <span class="hljs-comment"># 将上次的剪枝作为最终结果</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;acc decay more than <span class="hljs-subst">&#123;acc_decay_tol&#125;</span>, stop pruning, &quot;</span><br>                  <span class="hljs-string">f&quot;final prune rate: <span class="hljs-subst">&#123;pre_total_prune_rate&#125;</span>, &quot;</span><br>                  <span class="hljs-string">f&quot;final best acc: <span class="hljs-subst">&#123;pre_best_acc&#125;</span>&quot;</span>)<br>            prune_trainer.model.load_state_dict(pre_weight)<br>            remove_pruning(prune_trainer.model)<br>            torch.save(prune_trainer.model.state_dict(), <span class="hljs-string">f&quot;prune/best.pt&quot;</span>)<br>            <span class="hljs-keyword">break</span><br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-comment"># 继续剪枝</span><br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;history_best_acc: <span class="hljs-subst">&#123;history_best_acc&#125;</span>, &quot;</span><br>                  <span class="hljs-string">f&quot;current best_acc: <span class="hljs-subst">&#123;prune_trainer.early_stopping.best_acc&#125;</span>, &quot;</span><br>                  <span class="hljs-string">f&quot;acc decay less than <span class="hljs-subst">&#123;acc_decay_tol&#125;</span>, continue pruning\n&quot;</span>)<br>            <span class="hljs-keyword">if</span> prune_trainer.early_stopping.best_acc &gt; history_best_acc:<br>                history_best_acc = prune_trainer.early_stopping.best_acc<br>            pre_weight = prune_trainer.model.state_dict()<br>            pre_total_prune_rate = total_prune_rate<br>            pre_best_acc = prune_trainer.early_stopping.best_acc<br></code></pre></td></tr></table></figure><p>　　</p><blockquote><p>转载自：https://www.cnblogs.com/marui199710/articles/18283785</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>模型压缩</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式推理与量化部署(vLLM、LMDeploy)</title>
    <link href="/2025/06/05/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8E%A8%E7%90%86%E4%B8%8E%E9%87%8F%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <url>/2025/06/05/%E5%88%86%E5%B8%83%E5%BC%8F%E6%8E%A8%E7%90%86%E4%B8%8E%E9%87%8F%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<p>　　分布式推理是指将大模型的计算任务拆分到多个 GPU设备上并行执行，以解决单卡显存不足、提升推理速度的技术。其核心在于张量并行（TensorParallelism）和流水线并行（Pipeline Parallelism）。</p><h3 id="推理引擎如何实现高效推理">1. 推理引擎如何实现高效推理？</h3><p>　　推理引擎旨在优化生产环境中 LLM的内存使用和性能。它们通过实现高吞吐量和低延迟来保证 LLM能够处理大量的请求并快速响应。</p><p>　　推理引擎的核心技术主要包括 <strong>KV缓存管理、分页机制、连续批处理、结构化输出、张量并行、流水线并行、专家并行和 低比特量化等。</strong></p><h4 id="kv-缓存管理">1. KV 缓存管理</h4><p>　　在自回归推理场景中，模型每生成一个新 token，都需计算并保存对应的KV（键-值）缓存，以供后续的 token 解码重复使用。</p><p><strong>如何管理并最大化复用这些缓存，成为推理性能优化的重要方向。</strong></p><blockquote><p>首个广泛落地这一技术的是 vLLM 项目。vLLM 引入了名为 PagedAttention的机制，通过精细的分页缓存管理，动态按需加载和共享前缀缓存，从而大幅降低了重复计算和显存占用。</p><p>随后，SGLang 提出RadixAttention，基于前缀树结构进一步提高了缓存命中率，尤其适用于多轮对话场景。</p><p>Hugging Face 的 Text Generation Inference（TGI）也在 2024 年发布的v3.0 版本中新版本中加入类似机制，使长上下文推理场景显著提速。</p></blockquote><h4 id="分页机制">2. 分页机制</h4><p>　　传统的 KV缓存分配通常以最大上下文长度为单位进行整体分配，导致严重的显存浪费。</p><p><strong>为解决该问题，vLLM率先提出了基于分页机制（PagedAttention）的精细化内存管理方法</strong>。</p><p>　　这种方法借鉴操作系统虚拟内存分页的理念，将 KV缓存分割为固定大小的“小页”，允许动态、非连续存储，从而大幅降低显存碎片率，并显著提升显存利用率。</p><p>　　这种设计随后得到了广泛认可，TGI 和 DeepSpeed-Inference也在各自的引擎中加入了类似分页式的缓存管理方案，使得该技术成为了主流推理引擎的标配机制。</p><h4 id="连续批处理">3. 连续批处理</h4><p>　　推理场景下的批处理机制传统上为静态批量，即等待批量请求齐全再开始计算，导致GPU 资源闲置率较高。连续批处理实现动态批量调度。</p><p>　　<strong>vLLM 项目首次提出并实现了“连续批处理（ContinuousBatching）”的概念</strong>，这种机制通过动态地将不同用户的推理请求实时插入到当前运行的批次中，从而最大限度减少GPU 空转，显著提高硬件利用率与推理吞吐量。</p><p>　　连续批处理将推理过程拆分为两个阶段：预填充阶段（Prefill）和解码阶段（Decode），并将预填充与解码解耦，使得模型在处理长上下文输入（预填充耗时长）和后续逐字生成（单步耗时短）时都能各自批量并行，避免资源闲置。这种PD 分离的架构也被月之暗面的 Mooncake 所采用。</p><p>　　<strong>目前，连续批处理已广泛被其他推理引擎如 TGI 和 SGLang等采纳，各项目在此基础上进一步优化了实时拼批策略，推动其成为业界标准做法。</strong></p><h4 id="结构化输出规范模型生成内容">4. 结构化输出：规范模型生成内容</h4><p>　　<strong>模型生成的自由文本在特定应用场景下往往难以直接使用，如API 调用或 JSON 响应。</strong></p><p>　　结构化输出技术通过在生成过程中施加约束（例如正则约束、有限状态机FSM约束），使模型能够直接产出符合预定义格式的结构化数据。</p><blockquote><p><strong>这一技术由 SGLang 项目首创，推出了名为 xGrammar的约束解码模块</strong>，实现对 JSON和函数调用等格式的强约束，极大简化了应用端的解析工作。</p><p>随后，vLLM 与 Hugging Face也分别推出了相似的结构化输出功能，并逐步将这一特性推广为推理引擎的常规功能之一。<strong>OpenAI在其 API 中引入了 “函数调用” 机制，也是一种结构化输出思路。</strong></p></blockquote><h4 id="张量并行与流水线并行">5. 张量并行与流水线并行</h4><p>　　张量并行（Tensor Parallelism, TP）和流水线并行（PipelineParallelism,PP）是目前模型规模扩展至数十亿乃至千亿级别时常用的推理部署方法。</p><p><strong>TP 将单层网络参数张量分割并分布到多张 GPU上同时计算，从而突破单 GPU 显存瓶颈；</strong></p><p><strong>PP 则将模型不同层分割到不同 GPU 上，流水线式执行推理，使单个GPU 承担的模型层数减少，从而支持更大的模型。</strong></p><blockquote><p>这两种并行策略由 NVIDIA 的 Megatron-LM 首先提出并推广，随后微软的DeepSpeed 和开源引擎 vLLM、SGLang等也广泛采纳，形成了面向超大模型推理场景的行业标准解决方案。</p></blockquote><h4 id="专家并行">6. 专家并行</h4><p>　　专家并行（Expert Parallelism, EP）技术伴随 Mixture-of-Experts(MoE) 模型架构的兴起而受到关注，并在 DeepSeek的火爆传播中受到更多的重视。</p><p><strong>MoE模型通过路由网络选择激活部分专家子模型，从而实现稀疏激活和极大规模参数扩展。</strong></p><p><strong>EP 将不同的专家分配到不同 GPU上并行运行，从而有效实现稀疏计算与内存高效管理。</strong></p><blockquote><p>微软 DeepSpeed-MoE 在推理端首次规模化实现了这一技术，使万亿参数级别的MoE 模型具备实际可用的推理效率。</p><p>此后，NVIDIA 的 Megatron-Core、NeMo等平台迅速跟进并在大规模场景中验证了该技术的有效性。vLLM 则计划于 2025Q2 在主干中正式支持专家并行，进一步促进 MoE 推理的普及。</p></blockquote><p>　　专家并行支持了稀疏激活的超大模型</p><h4 id="低比特量化实现模型的高效压缩">7.低比特量化：实现模型的高效压缩</h4><p>　　<strong>低比特量化（如 INT8 或INT4）是降低大模型推理成本的主流方案。</strong></p><p>　　通过精细的权重量化技术，在几乎不损失精度的情况下，大幅压缩模型体积并降低显存占用，使得推理服务的部署成本和硬件门槛显著下降。</p><blockquote><p>开创性的 GPTQ 算法首次实现了百亿至千亿参数模型的 INT4 量化。</p><p>后续 Hugging Face、vLLM 和 llama.cpp 等主流推理引擎均支持 GPTQ或类似的量化方案，推动 INT8 和 INT4量化模型成为业界推理部署的主流模式。</p></blockquote><h3 id="vllm-分布式推理">2. vLLM 分布式推理</h3><p>vLLM 通过 PagedAttention 和张量并行技术优化显存管理和计算效率，支持多GPU 推理。</p><p>核心机制：</p><ul><li>张量并行：通过 tensor_parallel_size 参数指定 GPU数量，模型自动拆分到多卡。</li><li>PagedAttention：将注意力机制的键值（KV）缓存分块存储，减少显存碎片，提升利用率。</li><li>连续批处理：动态合并不同长度的请求，减少GPU空闲时间。</li></ul><p><ahref="https://vllm.hyper.ai/docs/inference-and-serving/distributed_serving_new">文档</a></p><p>张量并行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">vllm serve facebook/opt-13b \<br>    --tensor-parallel-size 4<br></code></pre></td></tr></table></figure><p>张量并行+流水线并行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">vllm serve gpt2 \<br>    --tensor-parallel-size 4 \<br>    --pipeline-parallel-size 2<br></code></pre></td></tr></table></figure><h3 id="lmdeploy-分布式推理">3. LMDeploy 分布式推理</h3><p><ahref="https://www.bilibili.com/video/BV1iW4y1A77P/">教程地址</a></p><p>LMDeploy是专为高效部署设计的框架，支持量化技术与分布式推理，尤其适合低显存环境。</p><p>核心机制：</p><ul><li>张量并行：通过 --tp 参数指定 GPU 数量，支持多卡协同计算。</li><li>KV Cache 量化：支持 INT8/INT4 量化，降低显存占用。</li><li>动态显存管理：通过 --cache-max-entry-count 控制 KV 缓存比例</li></ul><h4 id="量化">3.1 量化</h4><p>为什么要做量化？</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506082143958.png" style="zoom:40%;" /></p><h4 id="为什么做-weight-only-的量化">3.2 为什么做 Weight Only的量化？</h4><p>两个基本概念</p><ul><li><p>计算密集(compute-bound)：推理的绝大部分时间消耗在数值计算上；针对计算密集场景，可以通过使用更快的硬件计算单元来提升计算速度，比如量化为W8A8 使用 INT8 Tensor Core 来加速计算。</p></li><li><p>访存密集(memory-bound)：推理时，绝大部分时间消耗在数据读取上；针对访存密集型场景，一般是通过提高计算访存比来提升性能。</p><blockquote><p>LLM 是典型的访存密集型任务。 常见的 LLM 模型是 Decoder Only架构。推理时大部分时间消耗在逐 Token 生成阶段( Decoding阶段)，是典型的访存密集型场景。 A100 的 FP16 峰值算力为 312TFLOPS，只有在 Batch Size 达到 128这个量级时，计算才成为推理的瓶颈，但由于 LLM 模型本身就很大，推理时的 KVCache 也会占用很多显存，还有一些其他的因素影响（如 Persistent Batch),实际推理时很难做到 128 这么大的 Batch Size。</p></blockquote></li></ul><p>　　Weight Only 量化一举多得。4 bit Weight Only 量化，将 FP16的模型权重量化为 INT4，访存量直接降为 FP16 模型的1/4，大幅降低了访存成本，提高了 Decoding的速度。加速的同时还节省了显存，同样的设备能够支持更大的模型以及更长的对话长度。</p><h4 id="如何做-weight-only-的量化">3.3 如何做 Weight Only 的量化？</h4><p>　　LMDeploy 使用 MIT HAN LAB 开源的 AWQ 算法，量化为 4bit模型，推理时，先把 4bit 权重，反量化回 FP16（在 Kernel 内部进行，从Global Memory 读取时仍是 4bit），依旧使用的是 FP16 计算。相较于社区使用比较多的 GPTQ 算法，AWQ的推理速度更快，量化的时间更短。</p><h4 id="推理引擎turbomind">3.4 推理引擎TurboMind</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506082208732.png" style="zoom:40%;" /></p><h4 id="实践">3.5 实践</h4><h5 id="多卡部署">1. 多卡部署</h5><p><ahref="https://lmdeploy.readthedocs.io/zh-cn/latest/llm/api_server.html">文档</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lmdeploy serve api_server Qwen/Qwen3-4B --server-port 23333 --model-name Qwen3-4B  --session-len 4096   --max-batch-size 32 --tp 2<br></code></pre></td></tr></table></figure><p>　　api_server启动时的参数可以通过命令行<code>lmdeploy serve api_server -h</code>查看。比如，<code>--tp</code> 设置张量并行，<code>--session-len</code>设置推理的最大上下文窗口长度，<code>--cache-max-entry-count</code> 调整k/v cache 的内存使用比例等等。</p><h5 id="key-valuekv-cache-量化">2. Key-Value(KV) Cache 量化</h5><p><ahref="https://lmdeploy.readthedocs.io/zh-cn/latest/quantization/kv_quant.html">文档</a></p><p>　　自 v0.4.0 起，LMDeploy 支持<strong>在线</strong> kv cacheint4/int8 量化，量化方式为 per-head per-token 的非对称量化。原来的 kv离线量化方式移除。</p><p>　　量化 kv 有利于增加 kv block 的数量。与 fp16 相比，int4/int8 kv 的kv block 分别可以增加到 4 倍和 2 倍。这意味着，在相同的内存条件下，kv量化后，系统能支撑的并发数可以大幅提升，从而最终提高吞吐量。</p><p>LMDeploy kv 量化具备以下优势：</p><ol type="1"><li>量化不需要校准数据集</li><li>支持 volta 架构（sm70）及以上的所有显卡型号</li><li>kv int8 量化精度几乎无损，kv int4 量化精度在可接受范围之内</li><li>推理高效，在 llama2-7b 上加入 int8/int4 kv 量化，RPS 相较于 fp16分别提升近 30% 和 40</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lmdeploy serve api_server Qwen/Qwen3-4B --quant-policy 8<br></code></pre></td></tr></table></figure><h5 id="turbomind">3. TurboMind</h5><p>　　使用 TurboMind 引擎进行推理：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lmdeploy serve api_server  /root/autodl-tmp/models/Qwen/Qwen3-4B-merged  --backend turbomind  --model-name qwen3_4b<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506101106920.png" style="zoom:50%;" /></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lmdeploy serve api_client http://localhost:23333<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202506101107413.png" style="zoom:50%;" /></p><blockquote><p>lmdeploy 版本：0.8.0</p><p>--backend {pytorch,turbomind} Set the inference backend. Default:turbomind. Type: str</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>模型部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>分布式微调大模型（LLamA-Factory、xtuner）</title>
    <link href="/2025/05/24/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/05/24/%E5%88%86%E5%B8%83%E5%BC%8F%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="分布式训练基本概念">1. 分布式训练基本概念</h3><h4 id="为什么需要分布式训练">1.1 为什么需要分布式训练</h4><p>　　计算资源需求：训练大模型需要海量计算（如GPT-3需数万GPU小时），分布式训练可加速训练过程。</p><p>　　内存瓶颈：单卡显存不足以容纳大模型参数、梯度及优化器状态。</p><h4 id="分布式训练的并行策略">1.2 分布式训练的并行策略</h4><h5 id="数据并行data-parallelism">1. 数据并行（Data Parallelism）</h5><p>　　原理：将数据划分为多个批次，分发到不同设备，每个设备拥有完整的模型副本。</p><p>　　同步方式：通过 All-Reduce 操作同步梯度（如 PyTorch 的DistributedDataParallel）。</p><p>　　挑战：通信开销大，显存占用高（需存储完整模型参数和优化器状态）。</p><h5 id="模型并行model-parallelism">2. 模型并行（Model Parallelism）</h5><p>　　原理：将模型切分到不同设备（如按层或张量分片）。</p><p>　　类型：</p><p>　　　1. 横向并行（层拆分）：将模型的层分配到不同设备。</p><p>　　　2. 纵向并行（张量拆分）：如 Megatron-LM 将矩阵乘法分片。</p><p>　　挑战：设备间通信频繁，负载均衡需精细设计。</p><h5 id="流水线并行pipeline-parallelism">3. 流水线并行（PipelineParallelism）</h5><p>　　原理：将模型按层划分为多个阶段（stage），数据分块后按流水线执行。</p><p>　　优化：微批次（Micro-batching）减少流水线气泡（Bubble）。</p><p>　　挑战：需平衡阶段划分，避免资源闲置。</p><h5 id="混合并行3d并行">4. 混合并行（3D并行）</h5><p>　　组合策略：结合数据并行、模型并行、流水线并行，典型应用如训练千亿级模型。</p><p>　　案例：微软 Turing-NLG、Meta 的 LLaMA-2。</p><h4 id="deepspeed">1.3 DeepSpeed</h4><h5 id="基本概念">1. 基本概念</h5><p>　　DeepSpeed是由微软开发的开源深度学习优化库，专为大规模模型训练设计，其核心技术通过显存优化、计算加速、通信优化三个维度突破传统分布式训练的局限。</p><p>　　核心目标：降低大模型训练成本，提升显存和计算效率。</p><p>　　集成生态：与 PyTorch 无缝兼容，支持 Hugging FaceTransformers库。</p><h5 id="核心技术">2. 核心技术</h5><p><strong>（１）ZeRO（Zero Redundancy Optimizer）</strong></p><p>　　原理：通过分片优化器状态、梯度、参数，消除数据并行中的显存冗余。</p><p>　　阶段划分：</p><p>　　　ZeRO-1：优化器状态分片。</p><p>　　　ZeRO-2：梯度分片 + 优化器状态分片。　</p><p>　　　ZeRO-3：参数分片 + 梯度分片 + 优化器状态分片。</p><p>　　优势：显存占用随设备数线性下降，支持训练更大模型。</p><p><strong>（2）显存优化技术</strong></p><p>　　梯度检查点（ActivationCheckpointing）：用时间换空间，减少激活值显存占用。</p><p>　　CPU Offloading：将优化器状态和梯度卸载到 CPU 内存。</p><p>　　混合精度训练：FP16/BP16与动态损失缩放（Loss Scaling）。</p><p>​ 其他特性：</p><p>　　　大规模推理支持：模型并行推理（如 ZeRO-Inference）。</p><p>　　　自适应通信优化：自动选择最佳通信策略（如 All-Reduce vs.All-Gather）。</p><p><strong>（3）优势与特点</strong></p><p>　　显存效率高：ZeRO-3 可将显存占用降低至 1/设备数。</p><p>　　易用性强：通过少量代码修改即可应用（如 DeepSpeed 配置 JSON文件）。</p><p>　　扩展性优秀：支持千卡级集群训练。</p><p>　　开源社区支持：持续更新，与 Hugging Face 等生态深度集成。</p><p><strong>（4） 使用场景</strong></p><p>　　训练百亿/千亿参数模型（如GPT-3、Turing-NLG）。</p><p>　　资源受限环境：单机多卡训练时通过 Offloading 扩展模型规模。</p><p>　　快速实验：通过 ZeRO-2 加速中等规模模型训练。</p><h3 id="llama-factory-分布式训练">2. LLamA-Factory 分布式训练</h3><p><ahref="https://llamafactory.readthedocs.io/zh-cn/latest/advanced/distributed.html">文档</a></p><ol type="1"><li>不开启 DeepSpeed</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505301904397.png" style="zoom:50%;" /></p><ol start="2" type="1"><li>开启 DeepSpeed ZeRO-2</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505301913537.png" style="zoom:50%;" /></p><p>显存占用：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505301921929.png" style="zoom:45%;" /></p><h3 id="xtuner-分布式训练">3. xtuner 分布式训练</h3><p><ahref="https://xtuner.readthedocs.io/zh-cn/latest/acceleration/deepspeed.html">文档</a></p><ol type="1"><li>不开启 DeepSpeed</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">NPROC_PER_NODE=2 xtuner train  ./qwen1_5_4b_chat_qlora_alpaca_e3.py<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505301933524.png" style="zoom:50%;" /></p><ol start="2" type="1"><li>开启 DeepSpeed ZeRO-2</li></ol><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">NPROC_PER_NODE</span>=<span class="hljs-number">2</span> xtuner train  ./qwen<span class="hljs-number">1</span>_<span class="hljs-number">5</span>_<span class="hljs-number">4</span>b_chat_qlora_alpaca_e<span class="hljs-number">3</span>.py --deepspeed deepspeed_zero<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505301929314.png" style="zoom:50%;" /></p><ol start="3" type="1"><li>DeepSpeed ZeRO-3 + CPU Offloading</li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">NPROC_PER_NODE=2 xtuner train  ./qwen1_5_4b_chat_qlora_alpaca_e3.py --deepspeed deepspeed_zero3_offload<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>微调</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微调大模型——xtuner</title>
    <link href="/2025/05/22/xtuner%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/05/22/xtuner%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://xtuner.readthedocs.io/zh-cn/latest/index.html">中文文档</a></p><p><ahref="https://github.com/InternLM/xtuner/tree/main/docs/zh_cn/user_guides">github用户文档</a></p><h3 id="安装xtuner">1. 安装xtuner</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">conda create --name xtuner python=3.10 -y<br>conda activate xtuner<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 源码安装</span><br>git clone https://github.com/InternLM/xtuner.git<br>cd xtuner<br>pip install -e &#x27;.[deepspeed]&#x27;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 验证</span><br>xtuner list-cfg<br></code></pre></td></tr></table></figure><h3 id="微调">2. 微调</h3><p><ahref="https://github.com/InternLM/xtuner/blob/main/docs/zh_cn/user_guides/single_turn_conversation.md">单轮对话data pipeline</a></p><h4 id="数据集准备">2.1 数据集准备</h4><p><ahref="https://xtuner.readthedocs.io/zh-cn/latest/training/open_source_dataset.html">开源指令微调数据集</a></p><h5 id="a.-数据采集">a. 数据采集</h5><p><ahref="https://modelscope.cn/datasets/w10442005/ruozhiba_qa">弱智吧问答数据</a></p><h5 id="b.-数据转换">b. 数据转换</h5><p>转换脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><br><span class="hljs-comment"># 源数据文件路径</span><br>source_file = <span class="hljs-string">&#x27;data/ruozhiba_qaswift.json&#x27;</span><br><span class="hljs-comment"># 目标数据文件路径</span><br>target_file = <span class="hljs-string">&#x27;data/target_data.json&#x27;</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(source_file, <span class="hljs-string">&#x27;r&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    source_data = json.load(f)<br><br>target_data = []<br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> source_data:<br>    conversation = &#123;<br>        <span class="hljs-string">&quot;conversation&quot;</span>: [<br>            &#123;<br>                <span class="hljs-string">&quot;input&quot;</span>: item[<span class="hljs-string">&quot;query&quot;</span>],<br>                <span class="hljs-string">&quot;output&quot;</span>: item[<span class="hljs-string">&quot;response&quot;</span>]<br>            &#125;<br>        ]<br>    &#125;<br>    target_data.append(conversation)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(target_file, <span class="hljs-string">&#x27;w&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>    json.dump(target_data, f, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">4</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;数据已成功转换并保存到 <span class="hljs-subst">&#123;target_file&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>转换后数据集：</p><p><ahref="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505281415328.json">target_data_1.json</a></p><h4 id="准备配置文件">2.1 准备配置文件</h4><p>根据微调的模型选择对应的配置文件，以 qwen3 为例：</p><p>xtuner 的目录中找到xtuner/xtuner/configs/qwen/qwen1_5/qwen1_5_4b_chat/qwen1_5_4b_chat_qlora_alpaca_e3.py复制一份至根目录。</p><h4 id="修改配置文件">2.2 修改配置文件</h4><p>修改待微调模型路径和数据路径为本地路径，并且修改数据集加载方式、prompt_template等。</p><blockquote><p>对话模板选择：<ahref="https://xtuner.readthedocs.io/zh-cn/latest/preparation/prompt_template.html">文档</a></p><ul><li>微调 chat 模型:</li></ul><p>使用模型所对应的对话模版，如 <code>internlm2-chat</code> 使用<code>internlm2_chat</code>、<code>Qwen-Chat</code> 使用<code>qwen_chat</code>。</p><ul><li>全量微调 base 模型:</li></ul><p>任选对话模版，优先使用 chat 版模型所对应的对话模版 。</p><ul><li>LoRA 微调 base 模型:</li></ul><p>使用默认对话模版 <code>default</code>。这是由于 LoRA / QLoRA微调默认会关闭 <code>embed_tokens</code> 和 <code>lm_head</code>的训练，此时如果引入未学习过的特殊 token（如对话模版中的<code>&lt;|im_start|&gt;</code>），则会影响模型的训练。</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">### PART 1中</span><br><span class="hljs-comment">#微调模型存放的位置</span><br>pretrained_model_name_or_path = <span class="hljs-string">&quot;/root/autodl-tmp/models/Qwen/Qwen3-4B&quot;</span><br><span class="hljs-comment">#微调数据存放的位置</span><br>data_files = <span class="hljs-string">&#x27;/root/autodl-tmp/xtuner/dataset/target_data.json&#x27;</span><br><br><span class="hljs-comment"># 最大文本长度</span><br>max_length = <span class="hljs-number">512</span><br><span class="hljs-comment"># 批次大小</span><br>batch_size = <span class="hljs-number">10</span><br><span class="hljs-comment">#最大训练轮数</span><br>max_epochs = <span class="hljs-number">1000</span><br><span class="hljs-comment"># Save</span><br>save_steps = <span class="hljs-number">200</span><br>save_total_limit = <span class="hljs-number">2</span><br>evaluation_freq = <span class="hljs-number">200</span><br><span class="hljs-comment">#验证数据</span><br>evaluation_inputs = [<br><span class="hljs-string">&#x27;只剩一个心脏了还能活吗？&#x27;</span>, <span class="hljs-string">&#x27;爸爸再婚，我是不是就有了个新娘？&#x27;</span>,<br><span class="hljs-string">&#x27;樟脑丸是我吃过最难吃的硬糖有奇怪的味道怎么还有人买&#x27;</span>,<span class="hljs-string">&#x27;马上要上游泳课了，昨天洗的泳裤还没干，怎么办&#x27;</span>,<br><span class="hljs-string">&#x27;我只出生了一次，为什么每年都要庆生&#x27;</span><br>]<br><span class="hljs-comment">### PART 2中</span><br><span class="hljs-comment"># 指定量化位数</span><br>load_in_4bit=<span class="hljs-literal">True</span>,<br>load_in_8bit=<span class="hljs-literal">False</span>,<br><span class="hljs-comment"># 指定秩的大小</span><br>r=<span class="hljs-number">64</span>,<br>lora_alpha=<span class="hljs-number">128</span>,<br><br><span class="hljs-comment"># PART 3中</span><br>dataset=<span class="hljs-built_in">dict</span>(<span class="hljs-built_in">type</span>=load_dataset, path=<span class="hljs-string">&quot;json&quot;</span>,data_files=data_files)<br>dataset_map_fn=<span class="hljs-literal">None</span><br></code></pre></td></tr></table></figure><h4 id="启动微调">2.3 启动微调</h4><p>在完成上述操作后，便可以使用下面的指令启动微调任务了。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-comment"># 单机单卡</span><br><span class="hljs-attribute">xtuner</span> train  ./qwen<span class="hljs-number">1</span>_<span class="hljs-number">5</span>_<span class="hljs-number">4</span>b_chat_qlora_alpaca_e<span class="hljs-number">3</span>.py <br></code></pre></td></tr></table></figure><p>开始训练：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505281423653.png" style="zoom:50%;" /></p><p>在训练开始前，可以看到模型的输出如下所示：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505281424812.png" style="zoom:50%;" /></p><p>而在训练完全完成后，可以观察到模型的输出如下所示：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505281426936.png" style="zoom:50%;" /></p><h3 id="模型转换-lora-合并">3. 模型转换 + LoRA 合并</h3><p>在训练完成后，会得到几个 <code>.pth</code> 文件（例如 iter_2000.pth，如果使用了 DeepSpeed，则将会是一个文件夹），这些文件存储了 QLoRA算法训练过程所更新的参数，而<strong>不是</strong>模型的全部参数。因此我们需要将这些<code>.pth</code> 文件转换为 HuggingFace格式，并合并入原始的语言模型权重中。</p><h4 id="模型转换">3.1 模型转换</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 命令格式：</span><br>xtuner convert pth_to_hf $&#123;FINETUNE_CFG&#125; $&#123;PTH_PATH&#125; $&#123;SAVE_PATH&#125;<br><span class="hljs-meta">#</span><span class="bash"> 例如：</span><br>xtuner convert pth_to_hf qwen1_5_4b_chat_qlora_alpaca_e3.py ./work_dirs/qwen1_5_4b_chat_qlora_alpaca_e3/iter_800.pth  work_dirs/qwen1_5_4b_chat_qlora_alpaca_e3/iter_800_hf<br></code></pre></td></tr></table></figure><h4 id="lora-合并">3.2 LoRA 合并</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 命令格式：</span><br>xtuner convert merge $&#123;LLM&#125; $&#123;LLM_ADAPTER&#125; $&#123;SAVE_PATH&#125;<br><span class="hljs-meta">#</span><span class="bash"> 例如：</span><br>xtuner convert merge /root/autodl-tmp/models/Qwen/Qwen3-4B work_dirs/qwen1_5_4b_chat_qlora_alpaca_e3/iter_800_hf/  /root/autodl-tmp/models/Qwen/Qwen3-4B_xtuner_merged --max-shard-size 4GB<br></code></pre></td></tr></table></figure><h3 id="可视化训练过程">4. 可视化训练过程</h3><p><ahref="https://xtuner.readthedocs.io/zh-cn/latest/training/visualization.html">文档</a></p><p>WandB：</p><ol type="1"><li><p>使用 WandB 前需安装依赖库 <code>wandb</code> 并登录至 wandb。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> pip install wandb</span><br><span class="hljs-meta">$</span><span class="bash"> wandb login</span><br></code></pre></td></tr></table></figure><p>获取token: https://wandb.ai/authorize</p></li><li><p>设置 config 中的 <code>visualizer</code> 字段，并将<code>vis_backends</code> 设置为 WandbVisBackend：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">set</span> visualizer</span><br>+ from mmengine.visualization import Visualizer, WandbVisBackend<br>- visualizer = None<br>+ visualizer = dict(type=Visualizer, vis_backends=[dict(type=WandbVisBackend)])<br></code></pre></td></tr></table></figure></li><li><p>启动实验后，可在 wandb 网页端 <code>https://wandb.ai</code>上查看可视化结果：</p></li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505281355398.png" style="zoom:50%;" /></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>微调</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>模型上下文协议 MCP</title>
    <link href="/2025/05/12/MCP/"/>
    <url>/2025/05/12/MCP/</url>
    
    <content type="html"><![CDATA[<h3 id="mcp介绍">1. MCP介绍</h3><p>MCP（Model Context Protocol，模型上下文协议）是一种开放协议，旨在实现大型语言模型（LLM）应用与外部数据源、工具和服务之间的无缝集成，类似于网络中的 HTTP协议或邮件中的 SMTP 协议。</p><p>MCP 协议通过标准化模型与外部资源的交互方式，提升 LLM应用的功能性、灵活性和可扩展性。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505121906263.png" style="zoom:50%;" /></p><p>MCP 通过定义标准化的接口和协议，使 LLM能够动态访问和集成以下内容：</p><ol type="1"><li><strong>外部数据源</strong>：如数据库、API、文档库等，为 LLM提供实时或历史数据。</li><li><strong>工具和服务</strong>：如计算工具、搜索引擎、第三方服务等，扩展LLM 的功能。</li><li><strong>上下文管理</strong>：动态维护 LLM的对话上下文，确保连贯性和一致性。</li></ol><h4 id="mcp-和-api-的区别">1.1 MCP 和 API 的区别</h4><p>在推出 MCP 之前，AI应用如果要对接外部工具，通常需要单独整合多个不同的 API，每个 API的接口可能都各不相同，认证方式和错误处理也可能不同，极大地增加了开发复杂度和维护成本。</p><p>所以说，传统 API 就像不同的门，每扇门都有一把不同的钥匙，而 MCP像一把万能钥匙，AI应用开发者只要集成了这个万能钥匙，就可以打开任意的门。下面是 MCP 和传统API 的对比：</p><table><thead><tr><th>功能</th><th>MCP</th><th>传统API</th></tr></thead><tbody><tr><td>整合难度</td><td>一次标准化整合</td><td>每个API单独整合</td></tr><tr><td>实时双向通信</td><td>✅ 支持</td><td>❌ 不支持</td></tr><tr><td>动态发现工具</td><td>✅ 支持</td><td>❌ 不支持</td></tr><tr><td>扩展性</td><td>即插即用</td><td>需要额外开发</td></tr><tr><td>安全性与控制</td><td>所有工具统一标准</td><td>每个API单独定义</td></tr></tbody></table><h4 id="mcp核心解决的问题">1.2 MCP核心解决的问题</h4><p><strong>传统范式之困：</strong>在传统开发模式中，大模型调用外部服务需要经历复杂的技术链路：</p><p>​ 自然语言理解 -&gt; 业务逻辑解析 -&gt; API调用 -&gt; 结果处理</p><p>​ 每个环节都可能产生信息损耗，比如下面提到的三个典型问题：</p><ul><li><strong>语义鸿沟：</strong>自然语言指令到具体API参数的映射模糊</li><li><strong>能力黑洞：</strong>模型对可用服务缺乏实时认知</li><li><strong>安全边界：</strong>直接开放API调用存在风险敞口</li></ul><p><strong>MCP核心解决的问题：</strong></p><p>​ 打通模型与工具、与现实世界、与人类所见、所思、所想的最后一公里。</p><h4 id="mcp与functioncall的关系">1.3 MCP与functionCall的关系</h4><p><strong>一句话总结：</strong></p><p>​ MCP 统一了不同大模型和不同服务之间的协议。</p><p><strong>一张图理解：</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505141601911.png" style="zoom:50%;" /></p><h3 id="mcp-的架构">2. MCP 的架构</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505141530342.png" style="zoom:50%;" /></p><p>MCP 的架构由四个关键部分组成：</p><ol type="1"><li><strong>主机（Host）</strong>：主机是期望从服务器获取数据的人工智能应用，例如ClaudeDesktop、Cursor、一个集成开发环境（IDE）等。主机负责初始化和管理客户端、处理用户授权、管理上下文聚合等。</li><li><strong>客户端（Client）</strong>：客户端是主机与服务器之间的桥梁。它与服务器保持一对一的连接，负责消息路由、能力管理、协议协商和订阅管理等。客户端确保主机和服务器之间的通信清晰、安全且高效。</li><li><strong>服务器（Server）</strong>：服务器是提供外部数据和工具的组件。它通过工具、资源和提示模板为大型语言模型提供额外的上下文和功能。例如，一个服务器可以提供与Gmail、Slack等外部服务的API调用。</li></ol><p>结合AI模型，以一个Java应用为例，架构是这样：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505141532185.png" style="zoom:50%;" /></p><p>可以看到传输层有两类：</p><ul><li>StdioTransport</li><li>HTTP SSE</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505141533286.png" style="zoom:50%;" /></p><h3 id="协议消息">3. 协议消息</h3><p>MCP 的核心是使用 JSON-RPC 2.0作为消息格式，为客户端和服务器之间的通信提供了一种标准化的方式。</p><p>基础协议定义了三种基本消息类型，分别是请求（Requests）、响应（Responses）和通知（Notifications）。</p><ul><li><strong>请求和响应</strong>：请求和响应是一对一的，客户端发送请求后，服务器会返回一个响应。<code>id</code>字段用于关联请求和响应。</li><li><strong>通知</strong>：通知是单向的，发送方不需要等待接收方的回复。通知通常用于事件推送或状态更新等场景。</li><li><strong>错误处理</strong>：如果请求失败，响应中会包含<code>error</code>字段，提供错误代码和描述，帮助开发者快速定位问题。</li></ul><p><a href="https://zhuanlan.zhihu.com/p/30515707345">交互过程</a></p><h3 id="基于spring-ai-集成-mcp">4. 基于Spring AI 集成 MCP</h3><h4 id="mcp-server">4.1 MCP server</h4><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-starter-mcp-server-webflux<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-M8<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>定义工具方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WeatherService</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> RestClient restClient;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">WeatherService</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.restClient = RestClient.create();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * The response format from the Open-Meteo API</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> record <span class="hljs-title">WeatherResponse</span><span class="hljs-params">(Current current)</span> </span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> record <span class="hljs-title">Current</span><span class="hljs-params">(LocalDateTime time, <span class="hljs-keyword">int</span> interval, <span class="hljs-keyword">double</span> temperature_2m)</span> </span>&#123;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Tool(description = &quot;Get the temperature (in celsius) for a specific location&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getTemperature</span><span class="hljs-params">(<span class="hljs-meta">@ToolParam(description = &quot;The location latitude&quot;)</span> <span class="hljs-keyword">double</span> latitude,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 <span class="hljs-meta">@ToolParam(description = &quot;The location longitude&quot;)</span> <span class="hljs-keyword">double</span> longitude,</span></span><br><span class="hljs-params"><span class="hljs-function">                                 ToolContext toolContext)</span> </span>&#123;<br>        WeatherResponse weatherResponse = restClient<br>                .get()<br>                .uri(<span class="hljs-string">&quot;https://api.open-meteo.com/v1/forecast?latitude=&#123;latitude&#125;&amp;longitude=&#123;longitude&#125;&amp;current=temperature_2m&quot;</span>,<br>                        latitude, longitude)<br>                .retrieve()<br>                .body(WeatherResponse.class);<br>        <span class="hljs-keyword">return</span> weatherResponse.current().temperature_2m() + <span class="hljs-string">&quot;°C&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用 <strong><span class="citation"data-cites="Tool">@Tool</span></strong> 和 <strong><spanclass="citation" data-cites="ToolParam">@ToolParam</span></strong>注解定义 mcp 服务 <strong>tool</strong> 的行为和参数。</p><p>然后将 <strong>MCP Tool</strong> 注册到 <strong>MCP服务</strong>。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ToolCallbackProvider <span class="hljs-title">weatherTools</span><span class="hljs-params">(WeatherService weatherService)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> MethodToolCallbackProvider.builder().toolObjects(weatherService).build();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="mcp-server调试">4.2 MCP server调试</h4><p>MCP Inspector 进行调试:</p><p>安装：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">npx @modelcontextprotocol/inspector@0.7.0<br></code></pre></td></tr></table></figure><p><ahref="https://www.cnblogs.com/ghj1976/p/18790993/shi-yonginspector-diao-shimcp-fu-wu">MCPInspector 使用说明</a></p><p>调用示例：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505121922324.png" style="zoom:40%;" /></p><p>SSE连接：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505121952750.png" style="zoom:40%;" /></p><h4 id="mcp-client">4.3 MCP Client</h4><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-mcp-client-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud.ai<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-ai-alibaba-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-M6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Central Portal Snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>central-portal-snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://central.sonatype.com/repository/maven-snapshots/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>spring-milestones<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Spring Milestones<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.spring.io/milestone<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">snapshots</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">snapshots</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>spring-snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>Spring Snapshots<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>https://repo.spring.io/snapshot<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">releases</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">enabled</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">enabled</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">releases</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br></code></pre></td></tr></table></figure><p>服务配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">ai:</span><br>    <span class="hljs-attr">dashscope:</span><br>      <span class="hljs-attr">api-key:</span> &#123;&#123;<span class="hljs-string">千问key</span>&#125;&#125;<br>    <span class="hljs-attr">mcp:</span><br>      <span class="hljs-attr">client:</span><br>        <span class="hljs-attr">sse:</span><br>          <span class="hljs-attr">connections:</span><br>            <span class="hljs-attr">server1:</span><br>              <span class="hljs-attr">url:</span> <span class="hljs-string">http://localhost:8080</span><br>        <span class="hljs-attr">stdio:</span><br>          <span class="hljs-attr">servers-configuration:</span> <span class="hljs-string">classpath:/mcp-servers-config.json</span><br></code></pre></td></tr></table></figure><p>mcp-servers-config.json:</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;mcpServers&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;server-filesystem&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;npx&quot;</span>,<br>      <span class="hljs-attr">&quot;args&quot;</span>: [<br>        <span class="hljs-string">&quot;-y&quot;</span>,<br>        <span class="hljs-string">&quot;@modelcontextprotocol/server-filesystem&quot;</span>,<br>        <span class="hljs-string">&quot;/Users/a123/Downloads&quot;</span><br>      ],<br>      <span class="hljs-attr">&quot;env&quot;</span>: &#123;<br>      &#125;<br>    &#125;,<br>    <span class="hljs-attr">&quot;amap-maps&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;command&quot;</span>: <span class="hljs-string">&quot;npx&quot;</span>,<br>      <span class="hljs-attr">&quot;args&quot;</span>: [<br>        <span class="hljs-string">&quot;-y&quot;</span>,<br>        <span class="hljs-string">&quot;@amap/amap-maps-mcp-server&quot;</span><br>      ],<br>      <span class="hljs-attr">&quot;env&quot;</span>: &#123;<br>        <span class="hljs-attr">&quot;AMAP_MAPS_API_KEY&quot;</span>: <span class="hljs-string">&quot;&#123;&#123;高德key&#125;&#125;&quot;</span><br>      &#125;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义客户端对话接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/client&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ChatClient chatClient;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Client</span><span class="hljs-params">(ChatClient.Builder chatClientBuilder, ToolCallbackProvider tools)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.chatClient = chatClientBuilder.defaultTools(tools).build();<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/chat&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">chat</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String input)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.chatClient.prompt().user(input).call().content();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>MCP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>微调大模型——LLamA-Factory</title>
    <link href="/2025/05/01/LLamaFactory-%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B/"/>
    <url>/2025/05/01/LLamaFactory-%E5%BE%AE%E8%B0%83%E5%A4%A7%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p><ahref="https://github.com/hiyouga/LLaMA-Factory/blob/main/README_zh.md">github</a>| <ahref="https://llamafactory.readthedocs.io/zh-cn/latest/index.html">文档</a></p><h3 id="安装">1. 安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone --depth 1 https://github.com/hiyouga/LLaMA-Factory.git<br>cd LLaMA-Factory<br>pip install -e .<br></code></pre></td></tr></table></figure><p>可视化启动：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 一定要在 LLaMA-Factor 目录</span><br>llamafactory-cli webui<br></code></pre></td></tr></table></figure><p>ui地址：http://127.0.0.1:7860/</p><h3 id="lora微调">2. lora微调</h3><h4 id="数据集准备">2.1 数据集准备</h4><h5 id="内置数据集">1. 内置数据集</h5><p>使用 LLamA-Factory 的 identity 数据集进行自我认知训练。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505011743318.png" style="zoom:35%;" /></p><h5 id="自定义微调数据集">2. 自定义微调数据集</h5><p><ahref="https://llamafactory.readthedocs.io/zh-cn/latest/getting_started/data_preparation.html">LLamA-Factory数据处理</a></p><p>微调数据格式：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs json">[<br>  &#123;<br>    <span class="hljs-attr">&quot;instruction&quot;</span>: <span class="hljs-string">&quot;人类指令（必填）&quot;</span>,<br>    <span class="hljs-attr">&quot;input&quot;</span>: <span class="hljs-string">&quot;人类输入（选填）&quot;</span>,<br>    <span class="hljs-attr">&quot;output&quot;</span>: <span class="hljs-string">&quot;模型回答（必填）&quot;</span>,<br>    <span class="hljs-attr">&quot;system&quot;</span>: <span class="hljs-string">&quot;系统提示词（选填）&quot;</span>,<br>    <span class="hljs-attr">&quot;history&quot;</span>: [<br>      [<span class="hljs-string">&quot;第一轮指令（选填）&quot;</span>, <span class="hljs-string">&quot;第一轮回答（选填）&quot;</span>],<br>      [<span class="hljs-string">&quot;第二轮指令（选填）&quot;</span>, <span class="hljs-string">&quot;第二轮回答（选填）&quot;</span>]<br>    ]<br>  &#125;<br>]<br></code></pre></td></tr></table></figure><h6 id="a.-数据采集">a. 数据采集</h6><p><ahref="https://modelscope.cn/datasets/w10442005/ruozhiba_qa">弱智吧问答数据</a></p><h6 id="b.-数据转换">b. 数据转换</h6><p>转换脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> json<br><br>input_file = <span class="hljs-string">&quot;./ruozhiba_qaswift.json&quot;</span><br>output_file = <span class="hljs-string">&quot;./ruozhiba_qaswift_train.json&quot;</span><br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(input_file, <span class="hljs-string">&quot;r&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    data = json.load(f)<br><br><span class="hljs-comment"># 转换后的数据</span><br>converted_data = []<br><br><span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data:<br>    converted_item = &#123;<br>        <span class="hljs-string">&quot;instruction&quot;</span>: item[<span class="hljs-string">&quot;query&quot;</span>],<br>        <span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-string">&quot;&quot;</span>,<br>        <span class="hljs-string">&quot;output&quot;</span>: item[<span class="hljs-string">&quot;response&quot;</span>]<br>    &#125;<br>    converted_data.append(converted_item)<br><br><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(output_file, <span class="hljs-string">&quot;w&quot;</span>, encoding=<span class="hljs-string">&quot;utf-8&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    json.dump(converted_data, f, ensure_ascii=<span class="hljs-literal">False</span>, indent=<span class="hljs-number">4</span>)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;转换完成，数据已保存为 <span class="hljs-subst">&#123;output_file&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>转换后数据集：</p><p><ahref="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505012248327.json">ruozhiba_qaswift_train.json</a></p><h6 id="c.-配置数据集">c. 配置数据集</h6><ol type="1"><li><p>将数据集上传到 data 目录</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505021622686.png" style="zoom:40%;" /></p></li><li><p>配置数据集</p><p>在 dataset_info.json 中配置自定义数据集</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505021628555.png" style="zoom:40%;" /></p></li></ol><h4 id="参数配置">2.1 参数配置</h4><p><strong>基本参数配置：</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505052033106.png" style="zoom:40%;" /></p><p>【注】检查点路径：权重保存路径。示例：/root/xxx/LLaMA-Factory/saves/Qwen3-4B-Instruct/lora/train_2025-05-05-20-30-37/checkpoint-100</p><p><strong>微调参数配置：</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505052051596.png" style="zoom:40%;" /></p><blockquote><ul><li>最大样本数：超过最大样本数的数据会被裁剪掉</li><li>截断长度：根据数据集文本长度进行设置</li></ul></blockquote><p><strong>其他参数配置：</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505011902017.png" style="zoom:40%;" /></p><p>【注】步数即训练轮数 epoch</p><p>每次保存前会进行验证，然后保存。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505052121145.png" style="zoom:40%;" /></p><p><strong>根据显存占用调整批处理大小：</strong></p><p>参看显存占用：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">nvitop<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505052052332.png" style="zoom:40%;" /></p><h4 id="进度监控">2.2 进度监控</h4><ol type="1"><li><p>控制台输出</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505052112301.png" style="zoom:50%;" /></p></li><li><p>UI 进度条展示</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505052113059.png" style="zoom:50%;" /></p></li></ol><h4 id="测试">2.3 测试</h4><h5 id="evaluate-测试">1. Evaluate 测试</h5><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505061126179.png" style="zoom:40%;" /></p><p>测试结果：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>    <span class="hljs-attr">&quot;predict_bleu-4&quot;</span>: <span class="hljs-number">88.92755507246376</span>,<br>    <span class="hljs-attr">&quot;predict_model_preparation_time&quot;</span>: <span class="hljs-number">0.0053</span>,<br>    <span class="hljs-attr">&quot;predict_rouge-1&quot;</span>: <span class="hljs-number">93.41544807813484</span>,<br>    <span class="hljs-attr">&quot;predict_rouge-2&quot;</span>: <span class="hljs-number">90.64988815374922</span>,<br>    <span class="hljs-attr">&quot;predict_rouge-l&quot;</span>: <span class="hljs-number">92.30600718336484</span>,<br>    <span class="hljs-attr">&quot;predict_runtime&quot;</span>: <span class="hljs-number">247.6047</span>,<br>    <span class="hljs-attr">&quot;predict_samples_per_second&quot;</span>: <span class="hljs-number">6.409</span>,<br>    <span class="hljs-attr">&quot;predict_steps_per_second&quot;</span>: <span class="hljs-number">0.129</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="chat测试">2. chat测试</h5><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505061124641.png" style="zoom:50%;" /></p><h3 id="qlora微调">3. QLoRA微调</h3><p>使用 QLoRA 进行多轮数据集微调。</p><p>数据集：<ahref="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505100942802.json">财经数据</a></p><p><strong>基本参数配置：</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505082027525.png" style="zoom:50%;" /></p><p><strong>LoRA参数设置：</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505082030048.png" style="zoom:50%;" /></p><p>LoRA 秩：32-128</p><p>LoRA 缩放系数一般为 LoRA 秩的二倍</p><h3 id="模型合并量化">4. 模型合并&amp;量化</h3><h4 id="模型合并">4.1 模型合并</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505061136582.png" style="zoom:40%;" /></p><p>合并后结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505061144254.png" style="zoom:50%;" /></p><h4 id="模型量化">4.2 模型量化</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505061203384.png" style="zoom:40%;" /></p><p>量化后模型：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505061204037.png" style="zoom:40%;" /></p><p>量化前后模型大小对比：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505061204640.png" style="zoom:50%;" /></p><h3 id="hf模型转gguf">5. hf模型转GGUF</h3><h4 id="gguf">5.1 GGUF</h4><p>GGUF 格式的全名为（GPT-Generated Unified Format），GGUF 的前身是GGML（GPT-Generated Model Language）。GGML是专门为了机器学习设计的张量库，最早可以追溯到2022/10。其目的是为了有一个单文件共享的格式，并且易于在不同架构的 GPU 和CPU上进行推理。但在后续的开发中，遇到了灵活性不足、相容性及难以维护的问题。</p><p><strong>为什么要转换 GGUF 格式：</strong></p><p>在传统的 Deep Learning Model 开发中大多使用 PyTorch来进行开发，但因为在部署时会面临依赖 Library太多、版本管理的问题，于是才有了 GGML、GGMF、GGJT等格式，而在开源社群不停的迭代后 GGUF 就诞生了。</p><p>GGUF 实际上是基于 GGJT 的格式进行优化的，并解决了 GGML当初面临的问题，包括：</p><ol type="1"><li>可扩展性：轻松为 GGML 架构下的工具添加新功能，或者向 GGUF 模型添加新Feature，不会破坏与现有模型的兼容性。</li><li>对 mmap（内存映射）的兼容性：该模型可以使用 mmap进行加载，实现快速载入和存储。</li><li>易于使用：模型可以使用少量代码轻松加载和存储，无需依赖的Library，同时对于不同编程语言支持程度也高。</li><li>模型信息完整：加载模型所需的所有信息都包含在模型文件中，不需要额外编写设置文件。</li><li>有利于模型量化：GGUF 支持模型量化（4 位、8 位、F16）。</li></ol><h4 id="格式转换">5.2 格式转换</h4><ol type="1"><li><p>获取 llama.cpp</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">git clone https://github.com/ggerganov/llama.cpp.git<br>pip install -r llama.cpp/requirements.txt<br></code></pre></td></tr></table></figure></li><li><p>执行转换</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 不量化</span><br>python llama.cpp/convert_hf_to_gguf.py ./models/Qwen/Qwen3-4B-merged --outtype f16  --verbose --outfile Qwen3-4B-merged-gguf.gguf<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 量化</span><br>python llama.cpp/convert_hf_to_gguf.py ./models/Qwen/Qwen3-4B-merged/  --outtype q8_0 --verbose --outfile  ./models/Qwen/Qwen3-4B-merged-q8_0-gguf.gguf<br></code></pre></td></tr></table></figure><blockquote><p>--outtype 是输出类型：</p><p>q2_k：特定张量（Tensor）采用较高的精度设置，而其他的则保持基础级别。</p><p>q3_k_l、q3_k_m、q3_k_s：这些变体在不同张量上使用不同级别的精度，从而达到性能和效率的平衡。</p><p>q4_0：这是最初的量化方案，使用 4 位精度。</p><p>q4_1 和q4_k_m、q4_k_s：这些提供了不同程度的准确性和推理速度，适合需要平衡资源使用的场景。</p><p>q5_0、q5_1、q5_k_m、q5_k_s：这些版本在保证更高准确度的同时，会使用更多的资源并且推理速度较</p><p>慢。</p><p>q6_k 和q8_0：这些提供了最高的精度，但是因为高资源消耗和慢速度，可能不适合所有用户。</p><p>fp16 和 f32: 不量化，保留原始精度。</p></blockquote><ol start="3" type="1"><li><p>ollama 运行 gguf</p><ol type="1"><li><p>创建 ModelFile</p><p>创建名为“ModelFile”的meta文件，内容如下</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">GGUF文件路径</span><br>FROM /root/autodl-tmp/models/Qwen/Qwen3-4B-merged-q8_0-gguf.gguf<br><br>PARAMETER temperature 0.6<br>PARAMETER top_p 0.95<br>PARAMETER top_k 20<br>PARAMETER repeat_penalty 1<br>TEMPLATE &quot;&quot;&quot;&#123;&#123;- if .Messages &#125;&#125;<br>&#123;&#123;- if or .System .Tools &#125;&#125;&lt;|im_start|&gt;system<br>&#123;&#123;- if .System &#125;&#125;<br>&#123;&#123; .System &#125;&#125;<br>&#123;&#123;- end &#125;&#125;<br>&#123;&#123;- if .Tools &#125;&#125;<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> Tools</span><br><br>You may call one or more functions to assist with the user query.<br><br>You are provided with function signatures within &lt;tools&gt;&lt;/tools&gt; XML tags:<br>&lt;tools&gt;<br>&#123;&#123;- range .Tools &#125;&#125;<br>&#123;&quot;type&quot;: &quot;function&quot;, &quot;function&quot;: &#123;&#123; .Function &#125;&#125;&#125;<br>&#123;&#123;- end &#125;&#125;<br>&lt;/tools&gt;<br><br>For each function call, return a json object with function name and arguments within &lt;tool_call&gt;&lt;/tool_call&gt; XML tags:<br>&lt;tool_call&gt;<br>&#123;&quot;name&quot;: &lt;function-name&gt;, &quot;arguments&quot;: &lt;args-json-object&gt;&#125;<br>&lt;/tool_call&gt;<br>&#123;&#123;- end &#125;&#125;&lt;|im_end|&gt;<br>&#123;&#123; end &#125;&#125;<br>&#123;&#123;- range $i, $_ := .Messages &#125;&#125;<br>&#123;&#123;- $last := eq (len (slice $.Messages $i)) 1 -&#125;&#125;<br>&#123;&#123;- if eq .Role &quot;user&quot; &#125;&#125;&lt;|im_start|&gt;user<br>&#123;&#123; .Content &#125;&#125;&lt;|im_end|&gt;<br>&#123;&#123; else if eq .Role &quot;assistant&quot; &#125;&#125;&lt;|im_start|&gt;assistant<br>&#123;&#123; if .Content &#125;&#125;&#123;&#123; .Content &#125;&#125;<br>&#123;&#123;- else if .ToolCalls &#125;&#125;&lt;tool_call&gt;<br>&#123;&#123; range .ToolCalls &#125;&#125;&#123;&quot;name&quot;: &quot;&#123;&#123; .Function.Name &#125;&#125;&quot;, &quot;arguments&quot;: &#123;&#123; .Function.Arguments &#125;&#125;&#125;<br>&#123;&#123; end &#125;&#125;&lt;/tool_call&gt;<br>&#123;&#123;- end &#125;&#125;&#123;&#123; if not $last &#125;&#125;&lt;|im_end|&gt;<br>&#123;&#123; end &#125;&#125;<br>&#123;&#123;- else if eq .Role &quot;tool&quot; &#125;&#125;&lt;|im_start|&gt;user<br>&lt;tool_response&gt;<br>&#123;&#123; .Content &#125;&#125;<br>&lt;/tool_response&gt;&lt;|im_end|&gt;<br>&#123;&#123; end &#125;&#125;<br>&#123;&#123;- if and (ne .Role &quot;assistant&quot;) $last &#125;&#125;&lt;|im_start|&gt;assistant<br>&#123;&#123; end &#125;&#125;<br>&#123;&#123;- end &#125;&#125;<br>&#123;&#123;- else &#125;&#125;<br>&#123;&#123;- if .System &#125;&#125;&lt;|im_start|&gt;system<br>&#123;&#123; .System &#125;&#125;&lt;|im_end|&gt;<br>&#123;&#123; end &#125;&#125;&#123;&#123; if .Prompt &#125;&#125;&lt;|im_start|&gt;user<br>&#123;&#123; .Prompt &#125;&#125;&lt;|im_end|&gt;<br>&#123;&#123; end &#125;&#125;&lt;|im_start|&gt;assistant<br>&#123;&#123; end &#125;&#125;&#123;&#123; .Response &#125;&#125;&#123;&#123; if .Response &#125;&#125;&lt;|im_end|&gt;&#123;&#123; end &#125;&#125;&quot;&quot;&quot;<br><span class="hljs-meta">#</span><span class="bash"> <span class="hljs-built_in">set</span> the system message</span><br>SYSTEM &quot;&quot;&quot;<br>You are a helpful assistant.<br>&quot;&quot;&quot;<br></code></pre></td></tr></table></figure><p>模型参数参考 <a href="https://ollama.com/library/qwen3:4b">ollama官网</a>，或者根据 hf 模型中 chat_template 进行转换。</p></li><li><p>创建自定义模型</p><p>使用 ollama create 命令创建自定义模型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 启动服务</span><br>ollama serve<br><span class="hljs-meta">#</span><span class="bash"> 创建模型</span><br>ollama create  Qwen3-4B-merged-q8  --file ModelFile<br></code></pre></td></tr></table></figure></li><li><p>运行模型</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ollama run Qwen3-4B-merged-q8<br></code></pre></td></tr></table></figure></li></ol></li></ol></li></ol><h3 id="llamafactory微调效果与vllm部署效果不一致">6.LLamaFactory微调效果与Vllm部署效果不一致</h3><h4 id="效果不一致原因">6.1 效果不一致原因</h4><p>LLamaFactory 微调时使用的是 LLamaFactory自带的对话模板，而并不是模型的对话模板。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505101018174.png" style="zoom:50%;" /></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505101022828.png" style="zoom:50%;" /></p><p>由于 Vllm 部署模型时使用的是模型的对话模板：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505101025469.png" style="zoom:50%;" /></p><p>由于微调和部署对话模板不一致，导致效果不一致。</p><h4 id="模板对齐">6.2 模板对齐</h4><p>vllm 部署时指定 LLamaFactory 微调时的模板即可。</p><p>vllm 可以指定自定义对话模板：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vllm serve &lt;model&gt; --chat-template ./path-to-chat-template.jinja<br></code></pre></td></tr></table></figure><p>vllm 需要 jinja 格式模板，LLamaFactory提供了转换方法，但是是私有方法。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505101033512.png" style="zoom:50%;" /></p><p>有公有调用方法但是需要 tokenizer 对象：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505101056872.png" style="zoom:50%;" /></p><p>转换脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> sys<br><span class="hljs-keyword">import</span> os<br><br><span class="hljs-comment"># 将项目根目录添加到 Python 路径</span><br>root_dir = os.path.dirname(os.path.dirname(os.path.dirname(os.path.dirname(os.path.abspath(__file__)))))<br>sys.path.append(root_dir)<br><br><span class="hljs-keyword">from</span> llamafactory.data.template <span class="hljs-keyword">import</span> TEMPLATES<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer<br><br><span class="hljs-comment"># 1. 初始化分词器（任意支持的分词器均可）</span><br>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&quot;/root/autodl-tmp/models/Qwen/Qwen3-4B&quot;</span>)<br><br><span class="hljs-comment"># 2. 获取模板对象</span><br>template_name = <span class="hljs-string">&quot;qwen3&quot;</span>  <span class="hljs-comment"># 替换为你需要查看的模板名称</span><br>template = TEMPLATES[template_name]<br><br><span class="hljs-comment"># 3. 修复分词器的 Jinja 模板</span><br>template.fix_jinja_template(tokenizer)<br><br><span class="hljs-comment"># 4. 直接输出模板的 Jinja 格式</span><br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=&quot;</span> * <span class="hljs-number">40</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Template [<span class="hljs-subst">&#123;template_name&#125;</span>] 的 Jinja 格式:&quot;</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;=&quot;</span> * <span class="hljs-number">40</span>)<br><span class="hljs-built_in">print</span>(tokenizer.chat_template)<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202505101057957.png" style="zoom:50%;" /></p><p>放在统计目录即可。</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>微调</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>大模型本地私有化部署(transformers、Ollama、vllm、LMDeploy)</title>
    <link href="/2025/04/24/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0%E7%A7%81%E6%9C%89%E5%8C%96%E9%83%A8%E7%BD%B2/"/>
    <url>/2025/04/24/%E5%A4%A7%E6%A8%A1%E5%9E%8B%E6%9C%AC%E5%9C%B0%E7%A7%81%E6%9C%89%E5%8C%96%E9%83%A8%E7%BD%B2/</url>
    
    <content type="html"><![CDATA[<h3 id="transformers">1. transformers</h3><h4 id="模型下载">1.1模型下载</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> modelscope <span class="hljs-keyword">import</span> snapshot_download<br>snapshot_download(model_id=<span class="hljs-string">&quot;Qwen/Qwen2.5-0.5B-Instruct&quot;</span>,cache_dir=<span class="hljs-string">&quot;/root/autodl-tmp/models&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="模型调用">1.2 模型调用</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用transformer加载qwen模型</span><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForCausalLM, AutoTokenizer<br><span class="hljs-keyword">import</span> torch<br><br>DEVICE = <span class="hljs-string">&quot;cuda&quot;</span><br><br><span class="hljs-comment"># 加载本地模型路径为该模型配置文件所在的根目录</span><br>model_dir = <span class="hljs-string">&quot;/root/autodl-tmp/models/Qwen/Qwen2.5-0.5B-Instruct&quot;</span><br><br><span class="hljs-comment"># 使用transformer加载模型</span><br>model = AutoModelForCausalLM.from_pretrained(model_dir, torch_dtype=<span class="hljs-string">&quot;auto&quot;</span>, device_map=<span class="hljs-string">&quot;auto&quot;</span>)<br>tokenizer = AutoTokenizer.from_pretrained(model_dir)<br><br><span class="hljs-comment"># 调用模型</span><br><span class="hljs-comment"># 定义提示词</span><br>prompt = <span class="hljs-string">&quot;你好，请介绍下你自己。&quot;</span><br><span class="hljs-comment"># 将提示词封装为message</span><br>message = [&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;You are a helpful assistant system&quot;</span>&#125;, &#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: prompt&#125;]<br><span class="hljs-comment"># 使用分词器的apply_chat_template()方法将上面定义的消息列表进行转换;tokenize=False表示此时不进行令牌化</span><br>text = tokenizer.apply_chat_template(message, tokenize=<span class="hljs-literal">False</span>, add_generation_prompt=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;text:\n&quot;</span>,text)<br><br><span class="hljs-comment"># 将处理后的文本令牌化并转换为模型的输入张量</span><br>model_inputs = tokenizer([text], return_tensors=<span class="hljs-string">&quot;pt&quot;</span>).to(DEVICE)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;model_inputs:\n&quot;</span>,model_inputs)<br><br><span class="hljs-keyword">with</span> torch.inference_mode():<br>    <span class="hljs-comment"># 将数据输入模型得到输出</span><br>    response = model.generate(model_inputs.input_ids, max_new_tokens=<span class="hljs-number">512</span>)<br>    <span class="hljs-built_in">print</span>(response)<br>    <span class="hljs-comment"># 对输出的内容进行解码还原</span><br>    response = tokenizer.batch_decode(response, skip_special_tokens=<span class="hljs-literal">True</span>)<br>    <span class="hljs-built_in">print</span>(response)<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs shell">text:<br> &lt;|im_start|&gt;system<br>You are a helpful assistant system&lt;|im_end|&gt;<br>&lt;|im_start|&gt;user<br>你好，请介绍下你自己。&lt;|im_end|&gt;<br>&lt;|im_start|&gt;assistant<br><br>model_inputs:<br> &#123;&#x27;input_ids&#x27;: tensor([[151644,   8948,    198,   2610,    525,    264,  10950,  17847,   1849,<br>         151645,    198, 151644,    872,    198, 108386,  37945, 100157,  16872,<br>         107828,   1773, 151645,    198, 151644,  77091,    198]],<br>       device=&#x27;cuda:0&#x27;), &#x27;attention_mask&#x27;: tensor([[1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,<br>         1]], device=&#x27;cuda:0&#x27;)&#125;<br>response:<br> tensor([[151644,   8948,    198,   2610,    525,    264,  10950,  17847,   1849,<br>         151645,    198, 151644,    872,    198, 108386,  37945, 100157,  16872,<br>         107828,   1773, 151645,    198, 151644,  77091,    198,  35946,  99882,<br>         102661,  99718, 100013,   9370,  71304, 105483, 102064, 104949,   3837,<br>          73670, 105792,  31935,  64559,  99320,  56007, 100631,  30709,     48,<br>           1773, 104198, 101897, 101930, 104034,  33108, 103983,  33447, 100623,<br>          48692, 100168, 110498,   3837, 100006, 102104, 100646,  86119,   5373,<br>          99553,  27369,   5373, 104223,  87335,   3837, 104468,  71817, 105051,<br>           5373, 104223, 101941,  49567,   1773,  97611, 100160,  20412, 100364,<br>          20002, 105344, 115167, 107124,   3837,  17714,  99650,  99553, 115404,<br>         105427, 110854,   1773, 106870, 110117,  86119,  57191,  85106, 100364,<br>          37945, 102422, 106525,   3837, 105351, 110121, 113445, 100143,  33108,<br>         106185,   1773, 151645]], device=&#x27;cuda:0&#x27;)<br>[&#x27;system\nYou are a helpful assistant system\nuser\n你好，请介绍下你自己。\nassistant\n我叫阿里云开发的超大规模语言模型，可以叫做通义千问或者小Q。我是经过长期训练和优化后的人工智能助手，能够回答各种问题、提供信息、创作文字，还可以进行对话、创作音乐等。我的目标是帮助用户更好地理解和解决问题，为他们提供有用的信息和支持。如果您有任何问题或需要帮助，请随时告诉我，我会尽力为您提供支持和解答。&#x27;]<br></code></pre></td></tr></table></figure><h3 id="ollama">2. Ollama</h3><h4 id="安装">2.1 安装</h4><p><a href="https://ollama.com/download/linux">官网地址</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202504262033782.png" style="zoom:40%;" /></p><p>ollama命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs shell">Usage:<br>  ollama [flags]<br>  ollama [command]<br><br>Available Commands:<br>  serve       Start ollama<br>  create      Create a model from a Modelfile<br>  show        Show information for a model<br>  run         Run a model<br>  stop        Stop a running model<br>  pull        Pull a model from a registry<br>  push        Push a model to a registry<br>  list        List models<br>  ps          List running models<br>  cp          Copy a model<br>  rm          Remove a model<br>  help        Help about any command<br><br>Flags:<br>  -h, --help      help for ollama<br>  -v, --version   Show version information<br></code></pre></td></tr></table></figure><h4 id="启动模型">2.2 启动模型</h4><p>启动模型：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">ollama run deepseek-r1:7b<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202504272151522.png" style="zoom:50%;" /></p><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 使用openai的API风格调用ollama</span><br><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI<br><br>client = OpenAI(base_url=<span class="hljs-string">&quot;http://localhost:11434/v1/&quot;</span>, api_key=<span class="hljs-string">&quot;xxxx&quot;</span>)<br><br>chat_completion = client.chat.completions.create(<br>    messages=[&#123;<span class="hljs-string">&quot;role&quot;</span>: <span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>: <span class="hljs-string">&quot;你好，请介绍下你自己。&quot;</span>&#125;], model=<span class="hljs-string">&quot;deepseek-r1:7b&quot;</span><br>)<br><span class="hljs-built_in">print</span>(chat_completion.choices[<span class="hljs-number">0</span>])<br><br></code></pre></td></tr></table></figure><h3 id="vllm">3. vllm</h3><p><a href="https://vllm.hyper.ai/docs/">中文文档</a></p><h4 id="安装-1">3.1 安装</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install vllm<br></code></pre></td></tr></table></figure><h4 id="启动模型-1">3.2 启动模型</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">vllm serve /root/autodl-tmp/models/deepseek-ai/DeepSeek-R1-Distill-Qwen-7B --max-model-len 4096 --served-model-name DeepSeek-R1-Distill-Qwen-7B<br></code></pre></td></tr></table></figure><p>【注】：--max-model-len默认值：<strong>32768</strong>，不指定可能导致 OOM</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202504272258459.png" style="zoom:40%;" /></p><p>查看模型列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">curl http://localhost:8000/v1/models<br></code></pre></td></tr></table></figure><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;object&quot;</span>: <span class="hljs-string">&quot;list&quot;</span>,<br><span class="hljs-attr">&quot;data&quot;</span>: [&#123;<br><span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;DeepSeek-R1-Distill-Qwen-7B&quot;</span>,<br><span class="hljs-attr">&quot;object&quot;</span>: <span class="hljs-string">&quot;model&quot;</span>,<br><span class="hljs-attr">&quot;created&quot;</span>: <span class="hljs-number">1745845827</span>,<br><span class="hljs-attr">&quot;owned_by&quot;</span>: <span class="hljs-string">&quot;vllm&quot;</span>,<br><span class="hljs-attr">&quot;root&quot;</span>: <span class="hljs-string">&quot;/root/autodl-tmp/models/deepseek-ai/DeepSeek-R1-Distill-Qwen-7B&quot;</span>,<br><span class="hljs-attr">&quot;parent&quot;</span>: <span class="hljs-literal">null</span>,<br><span class="hljs-attr">&quot;max_model_len&quot;</span>: <span class="hljs-number">4096</span>,<br><span class="hljs-attr">&quot;permission&quot;</span>: [&#123;<br><span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;modelperm-5fc218224d8e4b858af8864d2561d305&quot;</span>,<br><span class="hljs-attr">&quot;object&quot;</span>: <span class="hljs-string">&quot;model_permission&quot;</span>,<br><span class="hljs-attr">&quot;created&quot;</span>: <span class="hljs-number">1745845827</span>,<br><span class="hljs-attr">&quot;allow_create_engine&quot;</span>: <span class="hljs-literal">false</span>,<br><span class="hljs-attr">&quot;allow_sampling&quot;</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-attr">&quot;allow_logprobs&quot;</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-attr">&quot;allow_search_indices&quot;</span>: <span class="hljs-literal">false</span>,<br><span class="hljs-attr">&quot;allow_view&quot;</span>: <span class="hljs-literal">true</span>,<br><span class="hljs-attr">&quot;allow_fine_tuning&quot;</span>: <span class="hljs-literal">false</span>,<br><span class="hljs-attr">&quot;organization&quot;</span>: <span class="hljs-string">&quot;*&quot;</span>,<br><span class="hljs-attr">&quot;group&quot;</span>: <span class="hljs-literal">null</span>,<br><span class="hljs-attr">&quot;is_blocking&quot;</span>: <span class="hljs-literal">false</span><br>&#125;]<br>&#125;]<br>&#125;<br></code></pre></td></tr></table></figure><p>模型显存占用情况：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202504282113415.png" style="zoom:50%;" /></p><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用openai的API风格调用ollama</span><br><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI<br><br>client = OpenAI(base_url=<span class="hljs-string">&quot;http://0.0.0.0:8000/v1/&quot;</span>,api_key=<span class="hljs-string">&quot;xxxx&quot;</span>)<br><br>chat_completion = client.chat.completions.create(<br>    messages=[&#123;<span class="hljs-string">&quot;role&quot;</span>:<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;你好，请介绍下你自己。&quot;</span>&#125;],model=<span class="hljs-string">&quot;DeepSeek-R1-Distill-Qwen-7B&quot;</span><br>)<br><span class="hljs-built_in">print</span>(chat_completion.choices[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h3 id="lmdeploy">4. LMDeploy</h3><p><a href="https://intern-ai.org.cn/home">官网</a>，<ahref="https://internlm.intern-ai.org.cn/">开发者平台</a></p><h4 id="安装-2">4.1 安装</h4><p><ahref="https://lmdeploy.readthedocs.io/zh-cn/latest/index.html">文档</a></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install lmdeploy<br></code></pre></td></tr></table></figure><h4 id="启动模型-2">4.2 启动模型</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lmdeploy serve api_server -h<br></code></pre></td></tr></table></figure><p>启动参数查询。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">lmdeploy serve api_server /root/autodl-tmp/models/deepseek-ai/DeepSeek-R1-Distill-Qwen-7B --model-name DeepSeek-R1-Distill-Qwen-7B  --session-len 4096   --max-batch-size 32  <br></code></pre></td></tr></table></figure><p>【注】 --max-batch-size 不指定可能 OOM</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202504291157129.png" style="zoom:40%;" /></p><p>通过网页或接口查看模型列表：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;object&quot;</span>: <span class="hljs-string">&quot;list&quot;</span>,<br>  <span class="hljs-attr">&quot;data&quot;</span>: [<br>    &#123;<br>      <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;DeepSeek-R1-Distill-Qwen-7B&quot;</span>,<br>      <span class="hljs-attr">&quot;object&quot;</span>: <span class="hljs-string">&quot;model&quot;</span>,<br>      <span class="hljs-attr">&quot;created&quot;</span>: <span class="hljs-number">1745899139</span>,<br>      <span class="hljs-attr">&quot;owned_by&quot;</span>: <span class="hljs-string">&quot;lmdeploy&quot;</span>,<br>      <span class="hljs-attr">&quot;root&quot;</span>: <span class="hljs-string">&quot;DeepSeek-R1-Distill-Qwen-7B&quot;</span>,<br>      <span class="hljs-attr">&quot;parent&quot;</span>: <span class="hljs-literal">null</span>,<br>      <span class="hljs-attr">&quot;permission&quot;</span>: [<br>        &#123;<br>          <span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;modelperm-VzDaGNVTCRJNXYM7YtaEG8&quot;</span>,<br>          <span class="hljs-attr">&quot;object&quot;</span>: <span class="hljs-string">&quot;model_permission&quot;</span>,<br>          <span class="hljs-attr">&quot;created&quot;</span>: <span class="hljs-number">1745899139</span>,<br>          <span class="hljs-attr">&quot;allow_create_engine&quot;</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-attr">&quot;allow_sampling&quot;</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-attr">&quot;allow_logprobs&quot;</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-attr">&quot;allow_search_indices&quot;</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-attr">&quot;allow_view&quot;</span>: <span class="hljs-literal">true</span>,<br>          <span class="hljs-attr">&quot;allow_fine_tuning&quot;</span>: <span class="hljs-literal">false</span>,<br>          <span class="hljs-attr">&quot;organization&quot;</span>: <span class="hljs-string">&quot;*&quot;</span>,<br>          <span class="hljs-attr">&quot;group&quot;</span>: <span class="hljs-literal">null</span>,<br>          <span class="hljs-attr">&quot;is_blocking&quot;</span>: <span class="hljs-literal">false</span><br>        &#125;<br>      ]<br>    &#125;<br>  ]<br>&#125;<br></code></pre></td></tr></table></figure><p>模型显存占用情况：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202504291201761.png" style="zoom:50%;" /></p><p>测试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment">#使用openai的API风格调用ollama</span><br><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI<br><br>client = OpenAI(base_url=<span class="hljs-string">&quot;http://0.0.0.0:23333/v1/&quot;</span>,api_key=<span class="hljs-string">&quot;xxxx&quot;</span>)<br><br>chat_completion = client.chat.completions.create(<br>    messages=[&#123;<span class="hljs-string">&quot;role&quot;</span>:<span class="hljs-string">&quot;user&quot;</span>,<span class="hljs-string">&quot;content&quot;</span>:<span class="hljs-string">&quot;你好，请介绍下你自己。&quot;</span>&#125;],model=<span class="hljs-string">&quot;DeepSeek-R1-Distill-Qwen-7B&quot;</span><br>)<br><span class="hljs-built_in">print</span>(chat_completion.choices[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>模型部署</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于GPT2中文生成模型定制化</title>
    <link href="/2025/04/23/%E5%9F%BA%E4%BA%8EGPT2%E4%B8%AD%E6%96%87%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E5%AE%9A%E5%88%B6%E5%8C%96/"/>
    <url>/2025/04/23/%E5%9F%BA%E4%BA%8EGPT2%E4%B8%AD%E6%96%87%E7%94%9F%E6%88%90%E6%A8%A1%E5%9E%8B%E5%AE%9A%E5%88%B6%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="模型调用">1. 模型调用</h3><h4 id="模型配置">1.1 模型配置</h4><p>模型名：models--uer--gpt2-chinese-poem</p><p>配置信息：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br>  <span class="hljs-attr">&quot;activation_function&quot;</span>: <span class="hljs-string">&quot;gelu_new&quot;</span>,<br>  <span class="hljs-attr">&quot;architectures&quot;</span>: [<br>    <span class="hljs-string">&quot;GPT2LMHeadModel&quot;</span><br>  ],<br>  <span class="hljs-attr">&quot;attn_pdrop&quot;</span>: <span class="hljs-number">0.1</span>,<br>  <span class="hljs-attr">&quot;embd_pdrop&quot;</span>: <span class="hljs-number">0.1</span>,<br>  <span class="hljs-attr">&quot;gradient_checkpointing&quot;</span>: <span class="hljs-literal">false</span>,<br>  <span class="hljs-attr">&quot;initializer_range&quot;</span>: <span class="hljs-number">0.02</span>,<br>  <span class="hljs-attr">&quot;layer_norm_epsilon&quot;</span>: <span class="hljs-number">1e-05</span>,<br>  <span class="hljs-attr">&quot;model_type&quot;</span>: <span class="hljs-string">&quot;gpt2&quot;</span>,<br>  <span class="hljs-attr">&quot;n_ctx&quot;</span>: <span class="hljs-number">1024</span>,<br>  <span class="hljs-attr">&quot;n_embd&quot;</span>: <span class="hljs-number">768</span>,<br>  <span class="hljs-attr">&quot;n_head&quot;</span>: <span class="hljs-number">12</span>,<br>  <span class="hljs-attr">&quot;n_inner&quot;</span>: <span class="hljs-literal">null</span>,<br>  <span class="hljs-attr">&quot;n_layer&quot;</span>: <span class="hljs-number">12</span>,<br>  <span class="hljs-attr">&quot;n_positions&quot;</span>: <span class="hljs-number">1024</span>,<br>  <span class="hljs-attr">&quot;output_past&quot;</span>: <span class="hljs-literal">true</span>,<br>  <span class="hljs-attr">&quot;resid_pdrop&quot;</span>: <span class="hljs-number">0.1</span>,<br>  <span class="hljs-attr">&quot;task_specific_params&quot;</span>: &#123;<br>    <span class="hljs-attr">&quot;text-generation&quot;</span>: &#123;<br>      <span class="hljs-attr">&quot;do_sample&quot;</span>: <span class="hljs-literal">true</span>,<br>      <span class="hljs-attr">&quot;max_length&quot;</span>: <span class="hljs-number">120</span><br>    &#125;<br>  &#125;,<br>  <span class="hljs-attr">&quot;tokenizer_class&quot;</span>: <span class="hljs-string">&quot;BertTokenizer&quot;</span>,<br>  <span class="hljs-attr">&quot;vocab_size&quot;</span>: <span class="hljs-number">22557</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="模型调用-1">1.2 模型调用</h4><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-comment"># 中文白话文文章生成</span><br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> GPT2LMHeadModel, BertTokenizer, TextGenerationPipeline<br><br>model_path = <span class="hljs-string">&quot;./model/models--uer--gpt2-chinese-poem/snapshots/6335c88ef6a3362dcdf2e988577b7bafeda6052b&quot;</span><br><span class="hljs-comment"># 加载模型和分词器</span><br>model = GPT2LMHeadModel.from_pretrained(model_path)<br>tokenizer = BertTokenizer.from_pretrained(model_path)<br><span class="hljs-built_in">print</span>(model)<br><br><span class="hljs-comment"># 使用 Pipeline 调用模型</span><br>text_generator = TextGenerationPipeline(model, tokenizer, device=<span class="hljs-string">&quot;cuda:3&quot;</span>)<br><br><span class="hljs-comment"># 使用text_generator生成文本</span><br><span class="hljs-comment"># do_sample是否进行随机采样。为True时，每次生成的结果都不一样；为False时，每次生成的结果都是相同的。</span><br><span class="hljs-built_in">print</span>(text_generator(<span class="hljs-string">&quot;白日&quot;</span>, max_length=<span class="hljs-number">100</span>, do_sample=<span class="hljs-literal">False</span>))<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs shell">GPT2LMHeadModel(<br>  (transformer): GPT2Model(<br>    (wte): Embedding(22557, 768)<br>    (wpe): Embedding(1024, 768)<br>    (drop): Dropout(p=0.1, inplace=False)<br>    (h): ModuleList(<br>      (0-11): 12 x GPT2Block(<br>        (ln_1): LayerNorm((768,), eps=1e-05, elementwise_affine=True)<br>        (attn): GPT2SdpaAttention(<br>          (c_attn): Conv1D()<br>          (c_proj): Conv1D()<br>          (attn_dropout): Dropout(p=0.1, inplace=False)<br>          (resid_dropout): Dropout(p=0.1, inplace=False)<br>        )<br>        (ln_2): LayerNorm((768,), eps=1e-05, elementwise_affine=True)<br>        (mlp): GPT2MLP(<br>          (c_fc): Conv1D()<br>          (c_proj): Conv1D()<br>          (act): NewGELUActivation()<br>          (dropout): Dropout(p=0.1, inplace=False)<br>        )<br>      )<br>    )<br>    (ln_f): LayerNorm((768,), eps=1e-05, elementwise_affine=True)<br>  )<br>  (lm_head): Linear(in_features=768, out_features=22557, bias=False)<br>)<br>Truncation was not explicitly activated but `max_length` is provided a specific value, please use `truncation=True` to explicitly truncate examples to max length. Defaulting to &#x27;longest_first&#x27; truncation strategy. If you encode pairs of sequences (GLUE-style) with the tokenizer you can select this strategy more precisely by providing a specific strategy to `truncation`.<br>[&#123;&#x27;generated_text&#x27;: &#x27;白日 易 陨 ， 黄 河 流 易 涸 。 大 化 无 停 机 ， 百 年 一 局 棋 。 思 在 所 为 ， 岂 在 多 辛 悲 。 此 履 霜 戒 ， 逝 将 同 所 归 。 期 千 载 下 ， 终 与 一 日 违 。 言 不 可 忘 ， 努 力 加 餐 食 。 风 发 短 歌 ， 歌 罢 泪 沾 臆 。 怀 千 载 人 ， 此 意 谁 能 识 。 哉 天&#x27;&#125;]<br></code></pre></td></tr></table></figure><h3 id="模型训练">2. 模型训练</h3><p><ahref="https://debugging.oss-cn-hangzhou.aliyuncs.com/202504231147639.txt">训练数据集（古诗词）</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AdamW<br><span class="hljs-keyword">from</span> transformers.optimization <span class="hljs-keyword">import</span> get_scheduler<br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForCausalLM, AutoTokenizer  <span class="hljs-comment"># 导入transformers的模型和分词器类</span><br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader  <span class="hljs-comment"># 导入PyTorch的数据加载器类</span><br><span class="hljs-keyword">from</span> data <span class="hljs-keyword">import</span> MyDataset  <span class="hljs-comment"># 导入自定义的数据集类</span><br><br><span class="hljs-comment"># 实例化自定义数据集</span><br>dataset = MyDataset()  <span class="hljs-comment"># 创建数据集对象</span><br><br>model_path = <span class="hljs-string">&quot;./model/models--uer--gpt2-chinese-poem/snapshots/6335c88ef6a3362dcdf2e988577b7bafeda6052b&quot;</span><br><br><span class="hljs-comment"># 加载预训练的分词器，用于文本编码</span><br>tokenizer = AutoTokenizer.from_pretrained(model_path)<br><span class="hljs-comment"># 加载预训练的模型，用于语言模型任务</span><br>model = AutoModelForCausalLM.from_pretrained(model_path)<br><br><br><span class="hljs-comment"># 定义一个函数，用于将文本数据转换为模型所需的格式</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">collate_fn</span>(<span class="hljs-params">data</span>):</span><br>    <span class="hljs-comment"># 使用分词器对数据进行编码，并填充或截断到固定长度</span><br>    data = tokenizer.batch_encode_plus(data,<br>                                       padding=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 填充序列</span><br>                                       truncation=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 截断序列</span><br>                                       max_length=<span class="hljs-number">512</span>,  <span class="hljs-comment"># 最大长度</span><br>                                       return_tensors=<span class="hljs-string">&#x27;pt&#x27;</span>)  <span class="hljs-comment"># 返回PyTorch张量</span><br>    <span class="hljs-comment"># 复制输入ID作为标签，用于语言模型训练</span><br>    data[<span class="hljs-string">&#x27;labels&#x27;</span>] = data[<span class="hljs-string">&#x27;input_ids&#x27;</span>].clone()<br>    <span class="hljs-keyword">return</span> data<br><br><br><span class="hljs-comment"># 使用DataLoader创建数据加载器，用于批量加载数据</span><br>loader = DataLoader(<br>    dataset=dataset,  <span class="hljs-comment"># 指定数据集</span><br>    batch_size=<span class="hljs-number">20</span>,  <span class="hljs-comment"># 指定批量大小</span><br>    shuffle=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 打乱数据</span><br>    drop_last=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 如果最后一个批次的数据量小于batch_size，则丢弃</span><br>    collate_fn=collate_fn  <span class="hljs-comment"># 指定如何从数据集中收集样本到批次中</span><br>)<br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;数据的长度：<span class="hljs-subst">&#123;<span class="hljs-built_in">len</span>(loader)&#125;</span>&quot;</span>)  <span class="hljs-comment"># 打印数据加载器中的批次数量</span><br><br><br><span class="hljs-comment"># 定义训练函数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">train</span>():</span><br>    <span class="hljs-comment"># 定义训练参数</span><br>    EPOCH = <span class="hljs-number">3000</span>  <span class="hljs-comment"># 训练轮数</span><br>    <span class="hljs-keyword">global</span> model  <span class="hljs-comment"># 使用全局模型变量</span><br>    DEVICE = <span class="hljs-string">&quot;cuda:3&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>  <span class="hljs-comment"># 检测是否有GPU，如果有则使用，否则使用CPU</span><br>    model = model.to(DEVICE)  <span class="hljs-comment"># 将模型移动到指定设备</span><br><br>    <span class="hljs-comment"># 定义优化器</span><br>    optimizer = AdamW(model.parameters(), lr=<span class="hljs-number">2e-5</span>)  <span class="hljs-comment"># 使用AdamW优化器，并设置学习率</span><br>    <span class="hljs-comment"># 定义学习率调度器</span><br>    scheduler = get_scheduler(name=<span class="hljs-string">&quot;linear&quot;</span>,  <span class="hljs-comment"># 线性调度器</span><br>                              num_warmup_steps=<span class="hljs-number">0</span>,  <span class="hljs-comment"># 预热步数</span><br>                              num_training_steps=<span class="hljs-built_in">len</span>(loader),  <span class="hljs-comment"># 总训练步数</span><br>                              optimizer=optimizer)<br>    model.train()  <span class="hljs-comment"># 将模型设置为训练模式</span><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(EPOCH):  <span class="hljs-comment"># 循环每一轮训练</span><br>        <span class="hljs-keyword">for</span> i, data <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(loader):  <span class="hljs-comment"># 遍历数据加载器中的批次</span><br>            <span class="hljs-keyword">for</span> k <span class="hljs-keyword">in</span> data.keys():  <span class="hljs-comment"># 将数据移动到指定设备</span><br>                data[k] = data[k].to(DEVICE)<br>            out = model(**data)  <span class="hljs-comment"># 前向传播</span><br>            loss = out[<span class="hljs-string">&#x27;loss&#x27;</span>]  <span class="hljs-comment"># 获取损失</span><br>            loss.backward()  <span class="hljs-comment"># 反向传播</span><br>            torch.nn.utils.clip_grad_norm_(model.parameters(), <span class="hljs-number">1.0</span>)  <span class="hljs-comment"># 梯度裁剪，防止梯度爆炸</span><br>            optimizer.step()  <span class="hljs-comment"># 更新模型参数</span><br>            scheduler.step()  <span class="hljs-comment"># 更新学习率</span><br>            optimizer.zero_grad()  <span class="hljs-comment"># 清空优化器的梯度</span><br>            model.zero_grad()  <span class="hljs-comment"># 清空模型的梯度</span><br><br>            <span class="hljs-keyword">if</span> i % <span class="hljs-number">50</span> == <span class="hljs-number">0</span>:  <span class="hljs-comment"># 每隔50个批次打印一次信息</span><br>                labels = data[<span class="hljs-string">&quot;labels&quot;</span>][:, <span class="hljs-number">1</span>:]  <span class="hljs-comment"># 获取真实标签，忽略&lt;bos&gt;标记</span><br>                out = out[<span class="hljs-string">&quot;logits&quot;</span>].argmax(dim=<span class="hljs-number">2</span>)[:, :-<span class="hljs-number">1</span>]  <span class="hljs-comment"># 获取预测结果，忽略&lt;eos&gt;标记</span><br><br>                select = labels != <span class="hljs-number">0</span>  <span class="hljs-comment"># 选择非填充的标签</span><br>                labels = labels[select]  <span class="hljs-comment"># 应用选择</span><br>                out = out[select]  <span class="hljs-comment"># 应用选择</span><br>                <span class="hljs-keyword">del</span> select  <span class="hljs-comment"># 删除不再使用的select</span><br>                <span class="hljs-comment"># 计算准确率</span><br>                acc = (labels == out).<span class="hljs-built_in">sum</span>().item() / labels.numel()  <span class="hljs-comment"># 计算准确率的公式</span><br>                lr = optimizer.state_dict()[<span class="hljs-string">&quot;param_groups&quot;</span>][<span class="hljs-number">0</span>][<span class="hljs-string">&#x27;lr&#x27;</span>]  <span class="hljs-comment"># 获取当前学习率</span><br><br>                <span class="hljs-comment"># 打印训练信息</span><br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;epoch:<span class="hljs-subst">&#123;epoch&#125;</span>,batch:<span class="hljs-subst">&#123;i&#125;</span>,loss:<span class="hljs-subst">&#123;loss.item()&#125;</span>,lr:<span class="hljs-subst">&#123;lr&#125;</span>,acc:<span class="hljs-subst">&#123;acc&#125;</span>&quot;</span>)<br><br>        <span class="hljs-comment"># 保存最后一轮模型参数</span><br>        torch.save(model.state_dict(), <span class="hljs-string">&quot;params/net.pt&quot;</span>)  <span class="hljs-comment"># 保存模型参数到指定路径</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;权重保存成功！&quot;</span>)  <span class="hljs-comment"># 打印成功信息</span><br><br><br><span class="hljs-comment"># 当该脚本作为主程序运行时，调用训练函数</span><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    train()  <span class="hljs-comment"># 开始训练过程</span><br><br></code></pre></td></tr></table></figure><h3 id="使用训练参数推理">3. 使用训练参数推理</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForCausalLM, AutoTokenizer, TextGenerationPipeline<br><span class="hljs-keyword">import</span> torch<br><br>model_path = <span class="hljs-string">&quot;./model/models--uer--gpt2-chinese-poem/snapshots/6335c88ef6a3362dcdf2e988577b7bafeda6052b&quot;</span><br>tokenizer = AutoTokenizer.from_pretrained(model_path)<br>model = AutoModelForCausalLM.from_pretrained(model_path)<br><br><span class="hljs-comment"># 加载我们自己训练的权重（中文古诗词）</span><br><span class="hljs-comment"># model.load_state_dict(torch.load(&quot;params/net.pt&quot;))</span><br><br><span class="hljs-comment"># 使用pipeline工具生成内容</span><br>pipeline = TextGenerationPipeline(model, tokenizer, device=<span class="hljs-string">&quot;cuda:3&quot;</span>)<br><br><span class="hljs-built_in">print</span>(pipeline(<span class="hljs-string">&quot;天高&quot;</span>, max_length=<span class="hljs-number">100</span>))<br><br></code></pre></td></tr></table></figure><h3 id="定制化输出">4. 定制化输出</h3><p>输出行列的古诗：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 定制化生成内容</span><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer, AutoModelForCausalLM<br><br>model_path = <span class="hljs-string">&quot;./model/models--uer--gpt2-chinese-poem/snapshots/6335c88ef6a3362dcdf2e988577b7bafeda6052b&quot;</span><br>tokenizer = AutoTokenizer.from_pretrained(model_path)<br>model = AutoModelForCausalLM.from_pretrained(model_path)<br><span class="hljs-comment"># 加载我们自己训练的权重（中文古诗词）</span><br><span class="hljs-comment"># model.load_state_dict(torch.load(&quot;params/net.pt&quot;, map_location=&quot;cpu&quot;))</span><br>model.load_state_dict(torch.load(<span class="hljs-string">&quot;params/net.pt&quot;</span>))<br><br><br><span class="hljs-comment"># 定义函数，用于生成5言绝句 text是提示词，row是生成文本的行数，col是每行的字符数。</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate</span>(<span class="hljs-params">text, row, col</span>):</span><br>    <span class="hljs-comment"># 定义一个内部递归函数，用于生成文本</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">generate_loop</span>(<span class="hljs-params">data</span>):</span><br>        <span class="hljs-comment"># 禁用梯度计算</span><br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            <span class="hljs-comment"># 使用data字典中的数据作为模型输入，并获取输出</span><br>            out = model(**data)<br>        <span class="hljs-comment"># 获取最后一个字(logits未归一化的概率输出)</span><br>        out = out[<span class="hljs-string">&quot;logits&quot;</span>]<br>        <span class="hljs-comment"># 选择每个序列的最后一个logits，对应于下一个词的预测</span><br>        out = out[:, -<span class="hljs-number">1</span>]<br><br>        <span class="hljs-comment"># 找到概率排名前50的值，以此为分界线，小于该值的全部舍去</span><br>        topk_value = torch.topk(out, <span class="hljs-number">50</span>).values<br>        <span class="hljs-comment"># 获取每个输出序列中前50个最大的logits（为保持原维度不变，需要对结果增加一个维度，因为索引操作会降维）</span><br>        topk_value = topk_value[:, -<span class="hljs-number">1</span>].unsqueeze(dim=<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 将所有小于第50大的值的logits设置为负无穷，减少低概率词的选择</span><br>        out = out.masked_fill(out &lt; topk_value, -<span class="hljs-built_in">float</span>(<span class="hljs-string">&quot;inf&quot;</span>))<br><br>        <span class="hljs-comment"># 将特殊符号的logits值设置为负无穷，防止模型生成这些符号。</span><br>        <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-string">&quot;,.()《》[]「」&#123;&#125;，。.？!&quot;</span>:<br>            out[:, tokenizer.get_vocab()[i]] = -<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>        <span class="hljs-comment"># 去特殊符号</span><br>        out[:, tokenizer.get_vocab()[<span class="hljs-string">&quot;[UNK]&quot;</span>]] = -<span class="hljs-built_in">float</span>(<span class="hljs-string">&#x27;inf&#x27;</span>)<br>        <span class="hljs-comment"># 根据概率采样，无放回，避免生成重复的内容</span><br>        out = out.softmax(dim=<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 从概率分布中进行采样，选择下一个词的ID</span><br>        out = out.multinomial(num_samples=<span class="hljs-number">1</span>)<br><br>        <span class="hljs-comment"># 强值添加标点符号</span><br>        <span class="hljs-comment"># 计算当前生成的文本长度于预期的长度的比例</span><br>        c = data[<span class="hljs-string">&quot;input_ids&quot;</span>].shape[<span class="hljs-number">1</span>] / (col + <span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 如果当前的长度是预期长度的整数倍，则添加标点符号</span><br>        <span class="hljs-keyword">if</span> c % <span class="hljs-number">1</span> == <span class="hljs-number">0</span>:<br>            <span class="hljs-keyword">if</span> c % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>:<br>                <span class="hljs-comment"># 在偶数位添加句号</span><br>                out[:, <span class="hljs-number">0</span>] = tokenizer.get_vocab()[<span class="hljs-string">&quot;.&quot;</span>]<br>            <span class="hljs-keyword">else</span>:<br>                <span class="hljs-comment"># 在奇数位添加逗号</span><br>                out[:, <span class="hljs-number">0</span>] = tokenizer.get_vocab()[<span class="hljs-string">&quot;,&quot;</span>]<br>        <span class="hljs-comment"># 将生成的新词ID添加到输入序列的末尾</span><br>        data[<span class="hljs-string">&quot;input_ids&quot;</span>] = torch.cat([data[<span class="hljs-string">&quot;input_ids&quot;</span>], out], dim=<span class="hljs-number">1</span>)<br>        <span class="hljs-comment"># 更新注意力掩码，标记所有有效位置</span><br>        data[<span class="hljs-string">&quot;attention_mask&quot;</span>] = torch.ones_like(data[<span class="hljs-string">&quot;input_ids&quot;</span>])<br>        <span class="hljs-comment"># 更新token的ID类型，通常在BERTm模型中使用，但是在GPT模型中是不用的</span><br>        data[<span class="hljs-string">&quot;token_type_ids&quot;</span>] = torch.ones_like(data[<span class="hljs-string">&quot;input_ids&quot;</span>])<br>        <span class="hljs-comment"># 更新标签，这里将输入ID复制到标签中，在语言生成模型中通常用与预测下一个词</span><br>        data[<span class="hljs-string">&quot;labels&quot;</span>] = data[<span class="hljs-string">&quot;input_ids&quot;</span>].clone()<br><br>        <span class="hljs-comment"># 检查生成的文本长度是否达到或超过指定的行数和列数</span><br>        <span class="hljs-keyword">if</span> data[<span class="hljs-string">&quot;input_ids&quot;</span>].shape[<span class="hljs-number">1</span>] &gt;= row * col + row + <span class="hljs-number">1</span>:<br>            <span class="hljs-comment"># 如果达到长度要求，则返回最终的data字典</span><br>            <span class="hljs-keyword">return</span> data<br>        <span class="hljs-comment"># 如果长度未达到要求，递归调用generate_loop函数继续生成文本</span><br>        <span class="hljs-keyword">return</span> generate_loop(data)<br><br>    <span class="hljs-comment"># 生成3首诗词</span><br>    <span class="hljs-comment"># 使用tokenizer对输入文本进行编码，并重复3次生成3个样本。</span><br>    data = tokenizer.batch_encode_plus([text] * <span class="hljs-number">3</span>, return_tensors=<span class="hljs-string">&quot;pt&quot;</span>)<br>    <span class="hljs-comment"># 移除编码后的序列中的最后一个token(结束符号)</span><br>    data[<span class="hljs-string">&quot;input_ids&quot;</span>] = data[<span class="hljs-string">&quot;input_ids&quot;</span>][:, :-<span class="hljs-number">1</span>]<br>    <span class="hljs-comment"># 创建一个与input_ids形状相同的全1张量，用于注意力掩码</span><br>    data[<span class="hljs-string">&quot;attention_mask&quot;</span>] = torch.ones_like(data[<span class="hljs-string">&quot;input_ids&quot;</span>])<br>    <span class="hljs-comment"># 创建一个与input_ids形状相同的全0张量，用于token类型ID</span><br>    data[<span class="hljs-string">&quot;token_type_ids&quot;</span>] = torch.zeros_like(data[<span class="hljs-string">&quot;input_ids&quot;</span>])<br>    <span class="hljs-comment"># 复制input_ids到labels，用于模型的目标</span><br>    data[<span class="hljs-string">&#x27;labels&#x27;</span>] = data[<span class="hljs-string">&quot;input_ids&quot;</span>].clone()<br><br>    <span class="hljs-comment"># 调用generate_loop函数开始生成文本</span><br>    data = generate_loop(data)<br><br>    <span class="hljs-comment"># 遍历生成的3个样本</span><br>    <span class="hljs-keyword">for</span> i <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(<span class="hljs-number">3</span>):<br>        <span class="hljs-comment"># 打印输出样本索引和对应的解码后的文本</span><br>        <span class="hljs-built_in">print</span>(i, tokenizer.decode(data[<span class="hljs-string">&quot;input_ids&quot;</span>][i]))<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    generate(<span class="hljs-string">&quot;白&quot;</span>, row=<span class="hljs-number">4</span>, col=<span class="hljs-number">5</span>)<br><br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">0 [CLS] 白 鹤 先 归 汉, 黄 鹂 独 啭 春. 柳 条 行 碧 甸, 桃 叶 渡 芳 津.<br>1 [CLS] 白 露 下 苍 柏, 亭 亭 荫 庭 中. 微 风 度 帘 钩, 疏 影 当 帘 栊.<br>2 [CLS] 白 头 人 去 几, 独 坐 对 斜 晖. 酒 醒 残 花 在, 诗 成 一 鸟 飞.<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>GPT</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>基于Bert的中文评价情感分析</title>
    <link href="/2025/04/10/%E5%9F%BA%E4%BA%8EBert%E7%9A%84%E4%B8%AD%E6%96%87%E8%AF%84%E4%BB%B7%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90/"/>
    <url>/2025/04/10/%E5%9F%BA%E4%BA%8EBert%E7%9A%84%E4%B8%AD%E6%96%87%E8%AF%84%E4%BB%B7%E6%83%85%E6%84%9F%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<h3 id="模型训练">1. 模型训练</h3><h4 id="准备数据">1.1 准备数据</h4><ol type="1"><li>﻿﻿获取数据</li><li>﻿﻿转换数据格式（制作数据集）</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_from_disk<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> Dataset<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TrainModelDataset</span>(<span class="hljs-params">Dataset</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self, split</span>):</span><br>        <span class="hljs-comment"># 从磁盘加载数据</span><br>        self.dataset = load_from_disk(<span class="hljs-string">&quot;./dataset/ChnSentiCorp&quot;</span>)<br>        <span class="hljs-keyword">if</span> split == <span class="hljs-string">&quot;train&quot;</span>:<br>            self.dataset = self.dataset[<span class="hljs-string">&quot;train&quot;</span>]<br>        <span class="hljs-keyword">elif</span> split == <span class="hljs-string">&quot;test&quot;</span>:<br>            self.dataset = self.dataset[<span class="hljs-string">&quot;test&quot;</span>]<br>        <span class="hljs-keyword">elif</span> split == <span class="hljs-string">&quot;validation&quot;</span>:<br>            self.dataset = self.dataset[<span class="hljs-string">&quot;validation&quot;</span>]<br>        <span class="hljs-keyword">else</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;数据名错误！&quot;</span>)<br><br>    <span class="hljs-comment"># 返回数据集长度</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__len__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(self.dataset)<br><br>    <span class="hljs-comment"># 对每条数据单独做处理</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__getitem__</span>(<span class="hljs-params">self, index</span>):</span><br>        text = self.dataset[index][<span class="hljs-string">&quot;text&quot;</span>]<br>        label = self.dataset[index][<span class="hljs-string">&quot;label&quot;</span>]<br>        <span class="hljs-keyword">return</span> text, label<br></code></pre></td></tr></table></figure><h4 id="模型选型设计">1.2 模型选型/设计</h4><p>增量微调 Bert 中文模型</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertModel<br><br><span class="hljs-comment"># 定义设备信息</span><br>DEVICE = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br><span class="hljs-built_in">print</span>(DEVICE)<br><br><span class="hljs-comment"># 加载预训练模型</span><br>modelPath = <span class="hljs-string">&quot;./model/bert-base-chinese/models--bert-base-chinese/snapshots/c30a6ed22ab4564dc1e3b2ecbf6e766b0611a33f&quot;</span><br>pretrained = BertModel.from_pretrained(modelPath).to(DEVICE)<br><span class="hljs-built_in">print</span>(pretrained)<br><br><br><span class="hljs-comment"># 定义下游任务（增量模型）</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyModel</span>(<span class="hljs-params">torch.nn.Module</span>):</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params">self</span>):</span><br>        <span class="hljs-built_in">super</span>().__init__()<br>        <span class="hljs-comment"># 设计全连接网络，实现二分类任务</span><br>        self.fc = torch.nn.Linear(<span class="hljs-number">768</span>, <span class="hljs-number">2</span>)<br><br>    <span class="hljs-comment"># 使用模型处理数据（执行前向计算）</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">forward</span>(<span class="hljs-params">self, input_ids, attention_mask, token_type_ids</span>):</span><br>        <span class="hljs-comment"># 全量训练</span><br>        <span class="hljs-comment"># out = pretrained(input_ids=input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids)</span><br>        <span class="hljs-comment"># 冻结 Bert 模型的参数，让其不参与训练</span><br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            out = pretrained(input_ids=input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids)<br>        <span class="hljs-comment"># 增量模型参与训练</span><br>        out = self.fc(out.last_hidden_state[:, <span class="hljs-number">0</span>])<br>        <span class="hljs-keyword">return</span> out<br></code></pre></td></tr></table></figure><h4 id="模型训练-1">1.3 模型训练</h4><ol type="1"><li><p>加载模型和数据开始训练</p></li><li><p>观察状态</p></li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模型训练</span><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch.optim <span class="hljs-keyword">import</span> AdamW<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertTokenizer<br><br><span class="hljs-keyword">from</span> debug_bert.net <span class="hljs-keyword">import</span> MyModel<br><span class="hljs-keyword">from</span> debug_bert.trainModelDataset <span class="hljs-keyword">import</span> TrainModelDataset<br><br><span class="hljs-comment"># 定义设备信息</span><br>DEVICE = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br><span class="hljs-comment"># 定义训练的轮次(将整个数据集训练完一次为一轮)</span><br>EPOCH = <span class="hljs-number">1000</span><br><br><span class="hljs-comment"># 加载字典和分词器</span><br>modelPath = <span class="hljs-string">&quot;./model/bert-base-chinese/models--bert-base-chinese/snapshots/c30a6ed22ab4564dc1e3b2ecbf6e766b0611a33f&quot;</span><br>tokenModel = BertTokenizer.from_pretrained(modelPath)<br><br><br><span class="hljs-comment"># 将传入的字符串进行编码</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">collate_fn</span>(<span class="hljs-params">data</span>):</span><br>    text = [item[<span class="hljs-number">0</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data]<br>    label = [item[<span class="hljs-number">1</span>] <span class="hljs-keyword">for</span> item <span class="hljs-keyword">in</span> data]<br>    <span class="hljs-comment"># 编码</span><br>    data = tokenModel.batch_encode_plus(<br>        batch_text_or_text_pairs=text,<br>        add_special_tokens=<span class="hljs-literal">True</span>,<br>        <span class="hljs-comment"># 当句子长度大于max_length(上限是model_max_length)时，截断</span><br>        truncation=<span class="hljs-literal">True</span>,<br>        max_length=<span class="hljs-number">512</span>,<br>        <span class="hljs-comment"># 一律补0到max_length</span><br>        padding=<span class="hljs-string">&quot;max_length&quot;</span>,<br>        <span class="hljs-comment"># 可取值为tf,pt,np,默认为list</span><br>        return_tensors=<span class="hljs-string">&quot;pt&quot;</span>,<br>        <span class="hljs-comment"># 返回序列长度</span><br>        return_length=<span class="hljs-literal">True</span><br>    )<br>    input_ids = data[<span class="hljs-string">&quot;input_ids&quot;</span>]<br>    attention_mask = data[<span class="hljs-string">&quot;attention_mask&quot;</span>]<br>    token_type_ids = data[<span class="hljs-string">&quot;token_type_ids&quot;</span>]<br>    label = torch.LongTensor(label)<br>    <span class="hljs-keyword">return</span> input_ids, attention_mask, token_type_ids, label<br><br><br><span class="hljs-comment"># 创建数据集</span><br>train_dataset = TrainModelDataset(<span class="hljs-string">&quot;train&quot;</span>)<br>train_loader = DataLoader(<br>    dataset=train_dataset,<br>    <span class="hljs-comment"># 训练批次</span><br>    batch_size=<span class="hljs-number">128</span>,<br>    <span class="hljs-comment"># 打乱数据集</span><br>    shuffle=<span class="hljs-literal">True</span>,<br>    <span class="hljs-comment"># 舍弃最后一个批次的数据，防止形状出错</span><br>    drop_last=<span class="hljs-literal">True</span>,<br>    <span class="hljs-comment"># 对加载的数据进行编码</span><br>    collate_fn=collate_fn<br>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 开始训练</span><br>    <span class="hljs-built_in">print</span>(DEVICE)<br>    model = MyModel().to(DEVICE)<br>    <span class="hljs-comment"># 定义优化器</span><br>    optimizer = AdamW(model.parameters())<br>    <span class="hljs-comment"># 定义损失函数</span><br>    loss_func = torch.nn.CrossEntropyLoss()<br><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(EPOCH):<br>        <span class="hljs-keyword">for</span> i, (input_ids, attention_mask, token_type_ids, label) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>            <span class="hljs-comment"># 将数据放到 DEVICE 上面</span><br>            input_ids, attention_mask, token_type_ids, label = (input_ids.to(DEVICE), attention_mask.to(DEVICE)<br>                                                                , token_type_ids.to(DEVICE), label.to(DEVICE))<br>            <span class="hljs-comment"># 前向计算（将数据输入模型得到输出）</span><br>            out = model(input_ids, attention_mask, token_type_ids)<br>            <span class="hljs-comment"># 根据输出计算损失</span><br>            loss = loss_func(out, label)<br>            <span class="hljs-comment"># 根据误差优化参数</span><br>            optimizer.zero_grad()<br>            loss.backward()<br>            optimizer.step()<br><br>            <span class="hljs-comment"># 每隔5个批次输出训练信息</span><br>            <span class="hljs-keyword">if</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:<br>                <span class="hljs-comment"># 在类别维度（dim=1）取最大值索引，得到预测的类别标签</span><br>                out = out.argmax(dim=<span class="hljs-number">1</span>)<br>                <span class="hljs-comment"># 计算训练精度</span><br>                <span class="hljs-comment"># (out == label) 生成布尔张量（如 [True, False]）</span><br>                <span class="hljs-comment"># .sum()：统计 True 的数量</span><br>                <span class="hljs-comment"># .item()：将张量转换为标量</span><br>                acc = (out == label).<span class="hljs-built_in">sum</span>().item() / <span class="hljs-built_in">len</span>(label)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;epoch:<span class="hljs-subst">&#123;epoch&#125;</span>,i:<span class="hljs-subst">&#123;i&#125;</span>,loss:<span class="hljs-subst">&#123;loss.item()&#125;</span>,acc:<span class="hljs-subst">&#123;acc&#125;</span>&quot;</span>)<br>        <span class="hljs-comment"># 每训练完一轮，保存一次参数</span><br>        torch.save(model.state_dict(), <span class="hljs-string">f&quot;params/<span class="hljs-subst">&#123;epoch&#125;</span>_bert.pth&quot;</span>)<br>        <span class="hljs-built_in">print</span>(epoch, <span class="hljs-string">&quot;参数保存成功！&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="模型测试">2. 模型测试</h3><h4 id="客观评估">2.1 客观评估</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><span class="hljs-keyword">from</span> debug_bert.train <span class="hljs-keyword">import</span> collate_fn<br><span class="hljs-keyword">from</span> debug_bert.trainModelDataset <span class="hljs-keyword">import</span> TrainModelDataset<br><span class="hljs-keyword">from</span> debug_bert.net <span class="hljs-keyword">import</span> MyModel<br><br><span class="hljs-comment"># 定义设备信息</span><br>DEVICE = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br><br>test_dataset = TrainModelDataset(<span class="hljs-string">&quot;test&quot;</span>)<br>test_loader = DataLoader(<br>    dataset=test_dataset,<br>    batch_size=<span class="hljs-number">100</span>,<br>    shuffle=<span class="hljs-literal">True</span>,<br>    drop_last=<span class="hljs-literal">True</span>,<br>    collate_fn=collate_fn<br>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    acc = <span class="hljs-number">0.0</span><br>    total = <span class="hljs-number">0</span><br><br>    <span class="hljs-comment"># 开始测试</span><br>    <span class="hljs-built_in">print</span>(DEVICE)<br>    model = MyModel().to(DEVICE)<br>    <span class="hljs-comment"># 加载模型训练参数</span><br>    model.load_state_dict(torch.load(<span class="hljs-string">&quot;params/my_bert.pth&quot;</span>, map_location=DEVICE))<br>    <span class="hljs-comment"># 开启测试模式</span><br>    model.<span class="hljs-built_in">eval</span>()<br><br>    <span class="hljs-keyword">for</span> i, (input_ids, attention_mask, token_type_ids, label) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(test_loader):<br>        <span class="hljs-comment"># 将数据放到 DEVICE 上面</span><br>        input_ids, attention_mask, token_type_ids, label = input_ids.to(DEVICE), attention_mask.to(<br>            DEVICE), token_type_ids.to(DEVICE), label.to(DEVICE)<br>        <span class="hljs-comment"># 前向计算（将数据输入模型得到输出）</span><br>        out = model(input_ids, attention_mask, token_type_ids)<br>        out = out.argmax(dim=<span class="hljs-number">1</span>)<br>        acc += (out == label).<span class="hljs-built_in">sum</span>().item()<br>        <span class="hljs-built_in">print</span>(i, (out == label).<span class="hljs-built_in">sum</span>().item())<br>        total += <span class="hljs-built_in">len</span>(label)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;test acc:<span class="hljs-subst">&#123;acc / total&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>分类模型测试方法：<ahref="https://blog.csdn.net/seagal890/article/details/105059498">混淆矩阵</a></p><h4 id="主观评价">2.2 主观评价</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># 模型使用接口（主观评估）</span><br><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertTokenizer<br><span class="hljs-keyword">from</span> debug_bert.net <span class="hljs-keyword">import</span> MyModel<br><span class="hljs-keyword">from</span> debug_bert.train <span class="hljs-keyword">import</span> collate_fn<br><br>DEVICE = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br>model = MyModel().to(DEVICE)<br>names = [<span class="hljs-string">&quot;负向评价&quot;</span>, <span class="hljs-string">&quot;正向评价&quot;</span>]<br><br>modelPath = <span class="hljs-string">&quot;./model/bert-base-chinese/models--bert-base-chinese/snapshots/c30a6ed22ab4564dc1e3b2ecbf6e766b0611a33f&quot;</span><br>tokenModel = BertTokenizer.from_pretrained(modelPath)<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">collate_fn</span>(<span class="hljs-params">data</span>):</span><br>    sentences = [data]<br>    data = tokenModel.batch_encode_plus(<br>        batch_text_or_text_pairs=sentences,<br>        truncation=<span class="hljs-literal">True</span>,<br>        max_length=<span class="hljs-number">512</span>,<br>        padding=<span class="hljs-string">&quot;max_length&quot;</span>,<br>        return_tensors=<span class="hljs-string">&quot;pt&quot;</span>,<br>        return_length=<span class="hljs-literal">True</span><br>    )<br>    input_ids = data[<span class="hljs-string">&quot;input_ids&quot;</span>]<br>    attention_mask = data[<span class="hljs-string">&quot;attention_mask&quot;</span>]<br>    token_type_ids = data[<span class="hljs-string">&quot;token_type_ids&quot;</span>]<br>    <span class="hljs-keyword">return</span> input_ids, attention_mask, token_type_ids<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">test</span>():</span><br>    <span class="hljs-comment"># 加载模型训练参数</span><br>    model.load_state_dict(torch.load(<span class="hljs-string">&quot;params/my_bert.pth&quot;</span>, map_location=DEVICE))<br><br>    <span class="hljs-comment"># 开启测试模型</span><br>    model.<span class="hljs-built_in">eval</span>()<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        data = <span class="hljs-built_in">input</span>(<span class="hljs-string">&quot;请输入测试数据（输入‘q’退出）：&quot;</span>)<br>        <span class="hljs-keyword">if</span> data == <span class="hljs-string">&#x27;q&#x27;</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;测试结束&quot;</span>)<br>            <span class="hljs-keyword">break</span><br>        input_ids, attention_mask, token_type_ids = collate_fn(data)<br>        input_ids, attention_mask, token_type_ids = input_ids.to(DEVICE), attention_mask.to(DEVICE), token_type_ids.to(<br>            DEVICE)<br>        <span class="hljs-comment"># 将数据输入到模型，得到输出</span><br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            out = model(input_ids, attention_mask, token_type_ids)<br>            out = out.argmax(dim=<span class="hljs-number">1</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;模型判定：&quot;</span>, names[out], <span class="hljs-string">&quot;\n&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    test()<br></code></pre></td></tr></table></figure><h3 id="优化">3. 优化</h3><ol type="1"><li>训练过程中进行评测，防止过拟合</li><li>只保存最优参数&amp;最后一轮训练参数</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> torch<br><span class="hljs-keyword">from</span> torch.optim <span class="hljs-keyword">import</span> AdamW<br><span class="hljs-keyword">from</span> debug_bert.net <span class="hljs-keyword">import</span> MyModel<br><span class="hljs-keyword">from</span> debug_bert.train <span class="hljs-keyword">import</span> collate_fn<br><span class="hljs-keyword">from</span> debug_bert.trainModelDataset <span class="hljs-keyword">import</span> TrainModelDataset<br><span class="hljs-keyword">from</span> torch.utils.data <span class="hljs-keyword">import</span> DataLoader<br><br>DEVICE = torch.device(<span class="hljs-string">&quot;cuda&quot;</span> <span class="hljs-keyword">if</span> torch.cuda.is_available() <span class="hljs-keyword">else</span> <span class="hljs-string">&quot;cpu&quot;</span>)<br><span class="hljs-comment"># 定义训练的轮次(将整个数据集训练完一次为一轮)</span><br>EPOCH = <span class="hljs-number">30000</span><br><br><span class="hljs-comment"># 创建训练数据集</span><br>train_dataset = TrainModelDataset(<span class="hljs-string">&quot;train&quot;</span>)<br>train_loader = DataLoader(dataset=train_dataset, batch_size=<span class="hljs-number">50</span>, shuffle=<span class="hljs-literal">True</span>, drop_last=<span class="hljs-literal">True</span>, collate_fn=collate_fn)<br><span class="hljs-comment"># 创建验证数据集 验证数据集没必要打乱</span><br>val_dataset = TrainModelDataset(<span class="hljs-string">&quot;validation&quot;</span>)<br>val_loader = DataLoader(dataset=val_dataset, batch_size=<span class="hljs-number">50</span>, shuffle=<span class="hljs-literal">True</span>, drop_last=<span class="hljs-literal">False</span>, collate_fn=collate_fn)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-built_in">print</span>(DEVICE)<br>    model = MyModel().to(DEVICE)<br>    optimizer = AdamW(model.parameters())<br>    loss_func = torch.nn.CrossEntropyLoss()<br><br>    <span class="hljs-comment"># 初始化验证最佳准确率</span><br>    best_val_acc = <span class="hljs-number">0.0</span><br><br>    <span class="hljs-keyword">for</span> epoch <span class="hljs-keyword">in</span> <span class="hljs-built_in">range</span>(EPOCH):<br>        model.train()<br>        <span class="hljs-keyword">for</span> i, (input_ids, attention_mask, token_type_ids, label) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(train_loader):<br>            input_ids, attention_mask, token_type_ids, label = input_ids.to(DEVICE), attention_mask.to(<br>                DEVICE), token_type_ids.to(DEVICE), label.to(DEVICE)<br>            out = model(input_ids, attention_mask, token_type_ids)<br>            loss = loss_func(out, label)<br>            optimizer.zero_grad()<br>            loss.backward()<br>            optimizer.step()<br>            <span class="hljs-keyword">if</span> i % <span class="hljs-number">5</span> == <span class="hljs-number">0</span>:<br>                out = out.argmax(dim=<span class="hljs-number">1</span>)<br>                acc = (out == label).<span class="hljs-built_in">sum</span>().item() / <span class="hljs-built_in">len</span>(label)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;epoch:<span class="hljs-subst">&#123;epoch&#125;</span>,i:<span class="hljs-subst">&#123;i&#125;</span>,loss:<span class="hljs-subst">&#123;loss.item()&#125;</span>,acc:<span class="hljs-subst">&#123;acc&#125;</span>&quot;</span>)<br>        <span class="hljs-comment"># 验证模型（判断模型是否过拟合）</span><br>        <span class="hljs-comment"># 设置为评估模型</span><br>        model.<span class="hljs-built_in">eval</span>()<br>        <span class="hljs-comment"># 不需要模型参与训练</span><br>        <span class="hljs-keyword">with</span> torch.no_grad():<br>            val_acc = <span class="hljs-number">0.0</span><br>            val_loss = <span class="hljs-number">0.0</span><br>            <span class="hljs-keyword">for</span> i, (input_ids, attention_mask, token_type_ids, label) <span class="hljs-keyword">in</span> <span class="hljs-built_in">enumerate</span>(val_loader):<br>                input_ids, attention_mask, token_type_ids, label = input_ids.to(DEVICE), attention_mask.to(<br>                    DEVICE), token_type_ids.to(DEVICE), label.to(DEVICE)<br>                out = model(input_ids, attention_mask, token_type_ids)<br>                <span class="hljs-comment"># 根据输出计算损失</span><br>                val_loss += loss_func(out, label)<br>                <span class="hljs-comment"># 根据数据，计算验证精度</span><br>                out = out.argmax(dim=<span class="hljs-number">1</span>)<br>                val_acc += (out == label).<span class="hljs-built_in">sum</span>().item()<br>            val_loss /= <span class="hljs-built_in">len</span>(val_loader)<br>            val_acc /= <span class="hljs-built_in">len</span>(val_loader)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;验证集：loss:<span class="hljs-subst">&#123;val_loss&#125;</span>,acc:<span class="hljs-subst">&#123;val_acc&#125;</span>&quot;</span>)<br>            <span class="hljs-comment"># #每训练完一轮，保存一次参数</span><br>            <span class="hljs-comment"># torch.save(model.state_dict(),f&quot;params/&#123;epoch&#125;_bert.pth&quot;)</span><br>            <span class="hljs-comment"># print(epoch,&quot;参数保存成功！&quot;)</span><br>            <span class="hljs-comment"># 根据验证准确率保存最优参数</span><br>            <span class="hljs-keyword">if</span> val_acc &gt; best_val_acc:<br>                best_val_acc = val_acc<br>                torch.save(model.state_dict(), <span class="hljs-string">&quot;params1/best_bert.pth&quot;</span>)<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;EPOCH:<span class="hljs-subst">&#123;epoch&#125;</span>:保存最优参数：acc<span class="hljs-subst">&#123;best_val_acc&#125;</span>&quot;</span>)<br>        <span class="hljs-comment"># 保存最后一轮参数</span><br>        torch.save(model.state_dict(), <span class="hljs-string">&quot;params1/last_bert.pth&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;EPOCH:<span class="hljs-subst">&#123;epoch&#125;</span>:最后一轮参数保存成功！&quot;</span>)<br></code></pre></td></tr></table></figure><blockquote><p>1 <strong>训练模式（<code>model.train()</code>）</strong></p><ul><li><strong>Dropout层</strong>：随机丢弃神经元，强制模型不依赖特定节点（正则化防止过拟合）。</li><li><strong>BatchNorm层</strong>：基于当前训练 batch的数据动态计算均值和方差，并更新全局统计量。</li><li><strong>其他层</strong>：例如部分自定义层可能有训练/推理阶段的不同行为。</li></ul><p>2 <strong>评估模式（<code>model.eval()</code>）</strong></p><ul><li><strong>Dropout层</strong>：停止随机丢弃，所有神经元激活（相当于关闭正则化）。</li><li><strong>BatchNorm层</strong>：固定使用训练阶段积累的全局均值和方差，不再更新统计量。</li><li><strong>其他层</strong>：例如停止梯度跟踪，确保推理效率。</li></ul></blockquote>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>Bert</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HuggingFace核心组件</title>
    <link href="/2025/04/05/HuggingFace%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    <url>/2025/04/05/HuggingFace%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="transformers-库使用">1. Transformers 库使用</h3><h4 id="安装-transformers">1.1 安装 transformers</h4><p>Hugging Face 提供了 transformers 库，用于加载和使用模型</p><blockquote><p>基础环境：Anaconda,CUDA,cuDNN,pytorch</p><p><ahref="https://blog.csdn.net/wyf2017/article/details/118676765">安装Anaconda</a></p><p><ahref="https://blog.csdn.net/qq_44961869/article/details/115954258">安装cuda和对应版本的cudnn</a></p></blockquote><p>安装 <a href="https://pytorch.org/">pytorch</a>：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202504251101080.png" style="zoom:40%;" /></p><p>安装 transformers：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install transformers<br></code></pre></td></tr></table></figure><p>如果还需要安装其他依赖库，如 datasets 和 tokenizers，可以使用以下命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">pip install transformers datasets tokenizers<br></code></pre></td></tr></table></figure><h4 id="模型下载">1.2 模型下载</h4><p>Hugging Face提供了一个庞大的模型库，你可以通过以下步骤来查找所需的模型：</p><ol type="1"><li>访问 <a href="https://huggingface.co/models">模型库页面</a>。</li><li>在搜索栏中输入关键字，如 "GPT-2" 或 "BERT"，然后点击搜索。</li><li>你可以使用左侧的过滤器按任务、框架、语言等条件筛选模型</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForCausalLM, AutoTokenizer<br><br><span class="hljs-comment"># 将模型和分词器下载到本地，并指定保存路径</span><br>model_name = <span class="hljs-string">&quot;uer/gpt2-chinese-cluecorpussmall&quot;</span><br>cache_dir = <span class="hljs-string">&quot;model/uer/gpt2-chinese-cluecorpussmall&quot;</span><br><br><span class="hljs-comment"># 下载模型</span><br>AutoModelForCausalLM.from_pretrained(model_name, cache_dir=cache_dir)<br><span class="hljs-comment"># 下载分词工具</span><br>AutoTokenizer.from_pretrained(model_name, cache_dir=cache_dir)<br><br><span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;模型分词器已下载到：<span class="hljs-subst">&#123;cache_dir&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><h4 id="模型执行">1.3 模型执行</h4><h5 id="文本生成">1. 文本生成</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoModelForCausalLM, AutoTokenizer, pipeline<br><br><span class="hljs-comment"># 设置具体包含config.json的目录</span><br>model_dir = <span class="hljs-string">&quot;/Users/a123/Workspace/code/debugWorld/debug_LLM/debug_trsanformers/model/uer/gpt2-chinese-cluecorpussmall/models--uer--gpt2-chinese-cluecorpussmall/snapshots/c2c0249d8a2731f269414cc3b22dff021f8e07a3&quot;</span><br><br><span class="hljs-comment"># 加载模型和分词器</span><br>model = AutoModelForCausalLM.from_pretrained(model_dir)<br>tokenizer = AutoTokenizer.from_pretrained(model_dir)<br><br><span class="hljs-comment"># 使用加载的模型和分词器创建生成文本的pipeline</span><br>generator = pipeline(<span class="hljs-string">&quot;text-generation&quot;</span>, model=model, tokenizer=tokenizer, device=<span class="hljs-string">&quot;cpu&quot;</span>)<br><br><span class="hljs-comment"># 生成文本</span><br><span class="hljs-comment"># output = generator(&quot;你好，我是一款语言模型，&quot;,max_length=50,num_return_sequences=1)</span><br>output = generator(<br>    <span class="hljs-string">&quot;你好，我是一款语言模型，&quot;</span>,  <span class="hljs-comment"># 生成文本的输入种子文本（prompt）</span><br>    max_length=<span class="hljs-number">50</span>,  <span class="hljs-comment"># 指定生成文本的最大长度。表示生成的文本最多包含 50 个 tokens</span><br>    num_return_sequences=<span class="hljs-number">1</span>,  <span class="hljs-comment"># 指定返回多少个独立生成的文本序列。值为 1 表示只生成并返回一段文本。</span><br>    truncation=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 该参数决定是否截断输入文本以适应模型的最大输入长度。如果 True，超出模型最大输入长度的部分将被截断；如果 False，模型可能无法处理过长的输入，可能会报错。</span><br>    temperature=<span class="hljs-number">0.7</span>,<br>    <span class="hljs-comment"># 该参数控制生成文本的随机性。值越低，生成的文本越保守（倾向于选择概率较高的词）；值越高，生成的文本越多样（倾向于选择更多不同的词）。0.7 是一个较为常见的设置，既保留了部分随机性，又不至于太混乱。</span><br>    top_k=<span class="hljs-number">50</span>,  <span class="hljs-comment"># 该参数限制模型在每一步生成时仅从概率最高的 k 个词中选择下一个词。这里 top_k=50 表示模型在生成每个词时只考虑概率最高的前 50 个候选词，从而减少生成不太可能的词的概率。</span><br>    top_p=<span class="hljs-number">0.9</span>,<br>    <span class="hljs-comment"># 该参数（又称为核采样）进一步限制模型生成时的词汇选择范围。它会选择一组累积概率达到 p 的词汇，模型只会从这个概率集合中采样。top_p=0.9 意味着模型会在可能性最强的 90% 的词中选择下一个词，进一步增加生成的质量。</span><br>    clean_up_tokenization_spaces=<span class="hljs-literal">True</span><br>    <span class="hljs-comment"># 该参数控制生成的文本中是否清理分词时引入的空格。如果设置为 True，生成的文本会清除多余的空格；如果为 False，则保留原样。默认值即将改变为 False，因为它能更好地保留原始文本的格式。</span><br>)<br><span class="hljs-built_in">print</span>(output)<br></code></pre></td></tr></table></figure><h5 id="文本分类">2. 文本分类</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertTokenizer, BertForSequenceClassification, pipeline<br><br>model_dir = <span class="hljs-string">&quot;model/bert-base-chinese&quot;</span><br><br>model = BertForSequenceClassification.from_pretrained(<span class="hljs-string">&quot;bert-base-chinese&quot;</span>, cache_dir=model_dir)<br>tokenizer = BertTokenizer.from_pretrained(<span class="hljs-string">&quot;bert-base-chinese&quot;</span>, cache_dir=model_dir)<br><br><span class="hljs-comment"># 创建分类 pipeline</span><br>classifier = pipeline(<span class="hljs-string">&quot;text-classification&quot;</span>, model=model, tokenizer=tokenizer, device=<span class="hljs-string">&quot;cpu&quot;</span>)<br><span class="hljs-comment"># 进行文本分类</span><br>result = classifier(<span class="hljs-string">&quot;你好，我是一款语言模型&quot;</span>)<br><br><span class="hljs-built_in">print</span>(result)<br><span class="hljs-built_in">print</span>(model)<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs shell">[&#123;&#x27;label&#x27;: &#x27;LABEL_1&#x27;, &#x27;score&#x27;: 0.5209763646125793&#125;]<br>BertForSequenceClassification(<br>  (bert): BertModel(<br>    (embeddings): BertEmbeddings(<br>      (word_embeddings): Embedding(21128, 768, padding_idx=0)<br>      (position_embeddings): Embedding(512, 768)<br>      (token_type_embeddings): Embedding(2, 768)<br>      (LayerNorm): LayerNorm((768,), eps=1e-12, elementwise_affine=True)<br>      (dropout): Dropout(p=0.1, inplace=False)<br>    )<br>    (encoder): BertEncoder(<br>      (layer): ModuleList(<br>        (0-11): 12 x BertLayer(<br>          (attention): BertAttention(<br>            (self): BertSdpaSelfAttention(<br>              (query): Linear(in_features=768, out_features=768, bias=True)<br>              (key): Linear(in_features=768, out_features=768, bias=True)<br>              (value): Linear(in_features=768, out_features=768, bias=True)<br>              (dropout): Dropout(p=0.1, inplace=False)<br>            )<br>            (output): BertSelfOutput(<br>              (dense): Linear(in_features=768, out_features=768, bias=True)<br>              (LayerNorm): LayerNorm((768,), eps=1e-12, elementwise_affine=True)<br>              (dropout): Dropout(p=0.1, inplace=False)<br>            )<br>          )<br>          (intermediate): BertIntermediate(<br>            (dense): Linear(in_features=768, out_features=3072, bias=True)<br>            (intermediate_act_fn): GELUActivation()<br>          )<br>          (output): BertOutput(<br>            (dense): Linear(in_features=3072, out_features=768, bias=True)<br>            (LayerNorm): LayerNorm((768,), eps=1e-12, elementwise_affine=True)<br>            (dropout): Dropout(p=0.1, inplace=False)<br>          )<br>        )<br>      )<br>    )<br>    (pooler): BertPooler(<br>      (dense): Linear(in_features=768, out_features=768, bias=True)<br>      (activation): Tanh()<br>    )<br>  )<br>  (dropout): Dropout(p=0.1, inplace=False)<br>  (classifier): Linear(in_features=768, out_features=2, bias=True)<br>)<br></code></pre></td></tr></table></figure><h3 id="datasets-使用">2. Datasets 使用</h3><p>Datasets 库是 HuggingFace生态系统中一个重要的数据集库，可用于轻松地访问和共享数据集，这些数据集是关于音频、计算机视觉、以及自然语言处理等领域。Datasets库可以通过一行来加载一个数据集，并且可以使用 Hugging Face强大的数据处理方法来快速准备好你的数据集。在 Apache Arrow格式的支持下，通过 zero-copy read来处理大型数据集，而没有任何内存限制，从而实现最佳速度和效率。</p><p>  当需要微调模型的时候，需要对数据集进行以下操作：</p><ol type="1"><li>数据集加载：下载、加载数据集</li><li>数据集预处理：使用Dataset.map() 预处理数据</li><li>数据集评估指标：加载和计算指标</li></ol><h4 id="加载数据">2.1 加载数据</h4><h5 id="加载dataset数据集">1. 加载Dataset数据集</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_from_disk,load_dataset<br><br><span class="hljs-comment"># 默认缓存路径：~/.cache/huggingface/datasets</span><br><span class="hljs-comment"># dataset = load_dataset(path=&quot;lansinuote/ChnSentiCorp&quot;)</span><br>dataset = load_dataset(path=<span class="hljs-string">&quot;lansinuote/ChnSentiCorp&quot;</span>,cache_dir=<span class="hljs-string">&quot;dataset_cache/&quot;</span>)<br><span class="hljs-built_in">print</span>(dataset)<br></code></pre></td></tr></table></figure><p>打印结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs shell">DatasetDict(&#123;<br>    train: Dataset(&#123;<br>        features: [&#x27;text&#x27;, &#x27;label&#x27;],<br>        num_rows: 9600<br>    &#125;)<br>    validation: Dataset(&#123;<br>        features: [&#x27;text&#x27;, &#x27;label&#x27;],<br>        num_rows: 1200<br>    &#125;)<br>    test: Dataset(&#123;<br>        features: [&#x27;text&#x27;, &#x27;label&#x27;],<br>        num_rows: 1200<br>    &#125;)<br>&#125;)<br><br></code></pre></td></tr></table></figure><h5 id="保存dataset并加载">2. 保存Dataset并加载</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_from_disk,load_dataset<br><br><span class="hljs-comment"># dataset = load_dataset(path=&quot;lansinuote/ChnSentiCorp&quot;,cache_dir=&quot;dataset_cache/&quot;)</span><br><span class="hljs-comment"># dataset.save_to_disk(&quot;./dataset/ChnSentiCorp&quot;)</span><br><br><span class="hljs-comment"># 加载本地数据，用于移植等</span><br>dataset = load_from_disk(<span class="hljs-string">&quot;./dataset/ChnSentiCorp&quot;</span>)<br><span class="hljs-built_in">print</span>(dataset)<br></code></pre></td></tr></table></figure><p>数据集保存文件结构：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202504071121415.png" style="zoom:50%;" /></p><h5 id="从文件中加载">3. 从文件中加载</h5><h5 id="支持csv-tsv-txt-json-jsonl等格式的文件">支持csv, tsv, txt, json,jsonl等格式的文件</h5><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs py"><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_dataset<br><br>data_files = &#123;<span class="hljs-string">&quot;train&quot;</span>: <span class="hljs-string">&quot;./data/sougou_mini/train.csv&quot;</span>, <span class="hljs-string">&quot;test&quot;</span>: <span class="hljs-string">&quot;./data/sougou_mini/test.csv&quot;</span>&#125;<br>drug_dataset = load_dataset(<span class="hljs-string">&quot;csv&quot;</span>, data_files=data_files, delimiter=<span class="hljs-string">&quot;,&quot;</span>)<br><br></code></pre></td></tr></table></figure><h5 id="从内存中加载">4. 从内存中加载</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> pandas<br><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> Dataset<br><br><span class="hljs-built_in">dict</span> = &#123;<span class="hljs-string">&quot;a&quot;</span>: [<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>], <span class="hljs-string">&quot;b&quot;</span>: [<span class="hljs-string">&#x27;A&#x27;</span>, <span class="hljs-string">&#x27;B&#x27;</span>, <span class="hljs-string">&#x27;C&#x27;</span>]&#125;<br>dataset1 = Dataset.from_dict(<span class="hljs-built_in">dict</span>)<br><br>df = pandas.DataFrame(<span class="hljs-built_in">dict</span>)<br>dataset2 = Dataset.from_pandas(df)<br><br><span class="hljs-built_in">print</span>(dataset1)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell">Dataset(&#123;<br>    features: [&#x27;a&#x27;, &#x27;b&#x27;],<br>    num_rows: 3<br>&#125;)<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202504071129907.png" style="zoom:50%;" /></p><h4 id="数据切分">2.2 数据切分</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_from_disk<br><br>dataset = load_from_disk(<span class="hljs-string">&quot;./dataset/ChnSentiCorp&quot;</span>)<br><span class="hljs-comment"># 获取某个划分数据集，比如 train</span><br>train_dataset = dataset[<span class="hljs-string">&#x27;train&#x27;</span>]<br><span class="hljs-comment"># 获取前10条数据</span><br>head_dataset = train_dataset.select(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(head_dataset)<br><span class="hljs-comment"># 获取随机10条数据</span><br>shuffle_dataset = train_dataset.shuffle(seed=<span class="hljs-number">42</span>).select(<span class="hljs-built_in">range</span>(<span class="hljs-number">10</span>))<br><span class="hljs-built_in">print</span>(shuffle_dataset)<br><span class="hljs-comment"># 数据切片</span><br>slice_dataset = train_dataset[<span class="hljs-number">10</span>:<span class="hljs-number">20</span>]<br><span class="hljs-built_in">print</span>(slice_dataset)<br></code></pre></td></tr></table></figure><p>输出结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell">Dataset(&#123;<br>    features: [&#x27;text&#x27;, &#x27;label&#x27;],<br>    num_rows: 10<br>&#125;)<br>Dataset(&#123;<br>    features: [&#x27;text&#x27;, &#x27;label&#x27;],<br>    num_rows: 10<br>&#125;)<br>&#123;&#x27;text&#x27;: [&#x27;我看过朋友的还可以，但是我订的书迟迟未到已有半个月，都没有收到打电话也没有用，以后你们订书一定要考虑好！当当实在是太慢了&#x27;, ......&#x27;], &#x27;label&#x27;: [0, 1, 1, 1, 0, 0, 1, 0, 1, 0]&#125;<br><br></code></pre></td></tr></table></figure><h4 id="更多特性">2.3 更多特性</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> datasets <span class="hljs-keyword">import</span> load_from_disk, load_dataset, Value<br><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> AutoTokenizer<br><br><span class="hljs-comment"># 流式加载，使用场景:</span><br><span class="hljs-comment"># 1. 你不想等待整个庞大的数据集下载完毕</span><br><span class="hljs-comment"># 2. 数据集大小超过了你计算机的可用硬盘空间</span><br><span class="hljs-comment"># 3. 你想快速探索数据集的少数样本</span><br>dataset = load_dataset(<span class="hljs-string">&#x27;lansinuote/ChnSentiCorp&#x27;</span>, split=<span class="hljs-string">&#x27;test&#x27;</span>, streaming=<span class="hljs-literal">True</span>)<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">next</span>(<span class="hljs-built_in">iter</span>(dataset)))<br><br>dataset = load_from_disk(<span class="hljs-string">&quot;./dataset/ChnSentiCorp&quot;</span>)<br>train_dataset = dataset[<span class="hljs-string">&#x27;train&#x27;</span>]<br><span class="hljs-comment"># 打乱数据集,如果设置打乱的 seed 是相同的，那我们就可以得到一个完全相同的打乱结果.</span><br>shuffle_dataset = train_dataset.shuffle(seed=<span class="hljs-number">42</span>)<br><br><span class="hljs-comment"># 数据列重命名,将 text 列重命名为 context</span><br>rename_dataset = shuffle_dataset.rename_column(<span class="hljs-string">&#x27;text&#x27;</span>, <span class="hljs-string">&#x27;context&#x27;</span>)<br><br><span class="hljs-comment"># 数据丢弃列</span><br>removed_dataset = rename_dataset.remove_columns([<span class="hljs-string">&#x27;label&#x27;</span>])<br><br><span class="hljs-comment"># 数据新增列</span><br>test_dataset = removed_dataset.add_column(<span class="hljs-string">&quot;test&quot;</span>, [<span class="hljs-string">&#x27;111&#x27;</span>] * removed_dataset.num_rows)<br><span class="hljs-built_in">print</span>(test_dataset.features)  <span class="hljs-comment"># &#123;&#x27;context&#x27;: Value(dtype=&#x27;string&#x27;, id=None), &#x27;test&#x27;: Value(dtype=&#x27;string&#x27;, id=None)&#125;</span><br><br><span class="hljs-comment"># 转换test列的数据类型</span><br>new_features = test_dataset.features.copy()<br>new_features[<span class="hljs-string">&quot;test&quot;</span>] = Value(<span class="hljs-string">&quot;int64&quot;</span>)<br>new_test_dataset = test_dataset.cast(new_features)<br><span class="hljs-built_in">print</span>(new_test_dataset.features)  <span class="hljs-comment"># &#123;&#x27;context&#x27;: Value(dtype=&#x27;string&#x27;, id=None), &#x27;test&#x27;: Value(dtype=&#x27;int64&#x27;, id=None)&#125;</span><br><br><span class="hljs-comment"># 数据展平,针对嵌套结构的数据类型，将子字段提取到它们自己的独立列中。</span><br>flatten_dataset = train_dataset.flatten()<br><span class="hljs-built_in">print</span>(flatten_dataset)<br><br><span class="hljs-comment"># 数据过滤,获取label为1的数据</span><br>filter_dataset = train_dataset.<span class="hljs-built_in">filter</span>(<span class="hljs-keyword">lambda</span> x: x[<span class="hljs-string">&#x27;label&#x27;</span>] == <span class="hljs-number">1</span>)<br><br><span class="hljs-comment"># set_format() 数据格式转换，不会修改原始数据，而是在访问时动态转换格式。</span><br><span class="hljs-comment"># 支持的数据格式有：None, numpy, torch, tensorflow, pandas, arrow, 如果选择None，就会返回python对象</span><br><span class="hljs-comment"># 新增列, title_length, 标题长度</span><br>title_length_dataset = train_dataset.add_column(<span class="hljs-string">&quot;title_length&quot;</span>, [<span class="hljs-built_in">len</span>(_) <span class="hljs-keyword">for</span> _ <span class="hljs-keyword">in</span> dataset[<span class="hljs-string">&#x27;train&#x27;</span>][<span class="hljs-string">&#x27;title&#x27;</span>]])<br><span class="hljs-comment"># 转换为numpy支持的数据格式</span><br>title_length_dataset.set_format(<span class="hljs-built_in">type</span>=<span class="hljs-string">&quot;numpy&quot;</span>, columns=[<span class="hljs-string">&quot;title_length&quot;</span>])<br><br><span class="hljs-comment"># 数据映射</span><br><span class="hljs-comment"># 它接收一个函数，Dataset中的每个元素都会被当作这个函数的输入，并将函数返回值作为新的Dataset。常见的map函数的应用是对文本进行tokenize</span><br>tokenizer = AutoTokenizer.from_pretrained(<span class="hljs-string">&#x27;bert-base-cased&#x27;</span>)<br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">tokenize_function</span>(<span class="hljs-params">sample</span>):</span><br>    <span class="hljs-keyword">return</span> tokenizer(sample[<span class="hljs-string">&#x27;context&#x27;</span>], truncation=<span class="hljs-literal">True</span>, max_length=<span class="hljs-number">256</span>)<br>tokenized_dataset = train_dataset.<span class="hljs-built_in">map</span>(tokenize_function, batched=<span class="hljs-literal">True</span>)<br></code></pre></td></tr></table></figure><h3 id="编码">3. 编码</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> transformers <span class="hljs-keyword">import</span> BertTokenizer<br><br><span class="hljs-comment"># 加载字典和分词器</span><br>token = BertTokenizer.from_pretrained(<br>    <span class="hljs-string">&quot;./model/bert-base-chinese/models--bert-base-chinese/snapshots/c30a6ed22ab4564dc1e3b2ecbf6e766b0611a33f&quot;</span>)<br><br><span class="hljs-comment"># 准备要编码的文本数据</span><br>texts = [<span class="hljs-string">&quot;白日依山尽，&quot;</span>,<br>         <span class="hljs-string">&quot;价格在这个地段属于适中, 附近有早餐店,小饭店, 比较方便,无早也无所&quot;</span>]<br><br><span class="hljs-comment"># 批量编码句子</span><br>out = token.batch_encode_plus(<br>    batch_text_or_text_pairs=texts,<br>    add_special_tokens=<span class="hljs-literal">True</span>,<br>    <span class="hljs-comment"># 当句子长度大于max_length(上限是model_max_length)时，截断</span><br>    truncation=<span class="hljs-literal">True</span>,<br>    max_length=<span class="hljs-number">15</span>,<br>    <span class="hljs-comment"># 一律补0到max_length</span><br>    padding=<span class="hljs-string">&quot;max_length&quot;</span>,<br>    <span class="hljs-comment"># 可取值为tf,pt,np,默认为list</span><br>    return_tensors=<span class="hljs-literal">None</span>,<br>    return_attention_mask=<span class="hljs-literal">True</span>,<br>    return_token_type_ids=<span class="hljs-literal">True</span>,<br>    return_special_tokens_mask=<span class="hljs-literal">True</span>,<br>    <span class="hljs-comment"># 返回序列长度</span><br>    return_length=<span class="hljs-literal">True</span><br>)<br><span class="hljs-comment"># input_ids 就是编码后的词</span><br><span class="hljs-comment"># token_type_ids 第一个句子为 0，第二个句子为 1。单句输入时全为 0。</span><br><span class="hljs-comment"># special_tokens_mask 特殊符号的位置是1，其他位置是0</span><br><span class="hljs-comment"># length 编码之后的序列长度</span><br><span class="hljs-keyword">for</span> k, v <span class="hljs-keyword">in</span> out.items():<br>    <span class="hljs-built_in">print</span>(k, <span class="hljs-string">&quot;:&quot;</span>, v)<br><br><span class="hljs-comment"># 解码文本数据</span><br><span class="hljs-built_in">print</span>(token.decode(out[<span class="hljs-string">&quot;input_ids&quot;</span>][<span class="hljs-number">0</span>]), token.decode(out[<span class="hljs-string">&quot;input_ids&quot;</span>][<span class="hljs-number">1</span>]))<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202504092118684.png" style="zoom:35%;" /></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>HuggingFace</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LangChain4j——RAG组件工作原理分析</title>
    <link href="/2025/03/09/LangChain4j%E2%80%94%E2%80%94RAG%E7%BB%84%E4%BB%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/"/>
    <url>/2025/03/09/LangChain4j%E2%80%94%E2%80%94RAG%E7%BB%84%E4%BB%B6%E5%B7%A5%E4%BD%9C%E5%8E%9F%E7%90%86%E5%88%86%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>RAG 组件：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202503091616500.png" style="zoom:50%;" /></p><p>使用 dmeo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">ContentRetriever contentRetriever1 = buildContentRetriever(embeddingStore1, embeddingModel);<br>ContentRetriever contentRetriever2 = buildContentRetriever(embeddingStore2, embeddingModel);<br><br>Query query = Query.from(<span class="hljs-string">&quot;提现什么时候到账？&quot;</span>);<br><br>QueryTransformer queryTransformer = <span class="hljs-keyword">new</span> ExpandingQueryTransformer(chatModel);<br>Collection&lt;Query&gt; queries = queryTransformer.transform(query);<br><br>QueryRouter queryRouter = <span class="hljs-keyword">new</span> LanguageModelQueryRouter(chatModel,Map.of( contentRetriever1, <span class="hljs-string">&quot;商品知识库&quot;</span>,contentRetriever2,<span class="hljs-string">&quot;常见客户问题知识库&quot;</span>));<br>Collection&lt;ContentRetriever&gt; retrievers = queryRouter.route(query);<br><br>Map&lt;Query, Collection&lt;List&lt;Content&gt;&gt;&gt; queryContent = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>queries.forEach(q -&gt; &#123;<br>    List&lt;List&lt;Content&gt;&gt; contents = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    retrievers.forEach(retriever -&gt; &#123;<br>        contents.add(retriever.retrieve(q));<br>    &#125;);<br>    queryContent.put(q, contents);<br>&#125;);<br><br>ContentAggregator contentAggregator = <span class="hljs-keyword">new</span> DefaultContentAggregator();<br>List&lt;Content&gt; aggregate = contentAggregator.aggregate(queryContent);<br></code></pre></td></tr></table></figure><p>整合 AiServices:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CustomerServiceAgent</span> </span>&#123;<br><br>    <span class="hljs-function">String <span class="hljs-title">answer</span><span class="hljs-params">(String question)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> CustomerServiceAgent <span class="hljs-title">getCustomerServiceAgent</span><span class="hljs-params">()</span> </span>&#123;<br>        EmbeddingModel embeddingModel = ZhipuChatModelUtil.getZhipuEmbeddingModel();<br>        ChatLanguageModel chatModel = ZhipuChatModelUtil.getZhipuChatModel();<br><br>        EmbeddingStore&lt;TextSegment&gt; embeddingStore1 = RedisEmbeddingStore.builder().host(<span class="hljs-string">&quot;127.0.0.1&quot;</span>).port(<span class="hljs-number">16379</span>).dimension(<span class="hljs-number">1024</span>).build();<br>        EmbeddingStore&lt;TextSegment&gt; embeddingStore2 = RedisEmbeddingStore.builder().host(<span class="hljs-string">&quot;127.0.0.1&quot;</span>).port(<span class="hljs-number">16379</span>).dimension(<span class="hljs-number">1024</span>).build();<br><br>        ChatMemory chatMemory = MessageWindowChatMemory.withMaxMessages(<span class="hljs-number">10</span>);<br><br>        ContentRetriever contentRetriever1 = buildContentRetriever(embeddingStore1, embeddingModel);<br>        ContentRetriever contentRetriever2 = buildContentRetriever(embeddingStore2, embeddingModel);<br><br><br>        QueryTransformer queryTransformer = <span class="hljs-keyword">new</span> ExpandingQueryTransformer(chatModel, <span class="hljs-number">5</span>);<br>        QueryRouter queryRouter = <span class="hljs-keyword">new</span> LanguageModelQueryRouter(chatModel, Map.of(contentRetriever1, <span class="hljs-string">&quot;商品知识库&quot;</span>, contentRetriever2, <span class="hljs-string">&quot;常见客户问题知识库&quot;</span>));<br>        ContentAggregator contentAggregator = <span class="hljs-keyword">new</span> DefaultContentAggregator();<br><br>        DefaultRetrievalAugmentor retrievalAugmentor = DefaultRetrievalAugmentor.builder().queryRouter(queryRouter)<br>                .queryTransformer(queryTransformer).contentAggregator(contentAggregator).build();<br><br>        <span class="hljs-keyword">return</span> AiServices.builder(CustomerServiceAgent.class).chatLanguageModel(chatModel).tools(<span class="hljs-keyword">new</span> DateCalculator())<br>                .retrievalAugmentor(retrievalAugmentor).chatMemory(chatMemory).build();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ContentRetriever <span class="hljs-title">buildContentRetriever</span><span class="hljs-params">(EmbeddingStore&lt;TextSegment&gt; embeddingStore, EmbeddingModel embeddingModel)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> EmbeddingStoreContentRetriever.builder()<br>                .embeddingStore(embeddingStore).embeddingModel(embeddingModel)<br>                .maxResults(<span class="hljs-number">5</span>).minScore(<span class="hljs-number">0.8</span>).build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="querytransformer">1. QueryTransformer</h3><p>Transforms the given Query into one or multiple Querys.</p><p>The goal is to enhance retrieval quality by modifying or expandingthe original Query.</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202503091839592.png" style="zoom:40%;" /></p><h4 id="defaultquerytransformer">1.1 DefaultQueryTransformer</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultQueryTransformer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">QueryTransformer</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;Query&gt; <span class="hljs-title">transform</span><span class="hljs-params">(Query query)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> singletonList(query);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认实现没有任何操作。</p><h4 id="expandingquerytransformer">1.2 ExpandingQueryTransformer</h4><p>生成多个版本问题，用于检索增强</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> PromptTemplate DEFAULT_PROMPT_TEMPLATE = PromptTemplate.from(<br>           <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">                   Generate &#123;&#123;n&#125;&#125; different versions of a provided user query. \</span><br><span class="hljs-string">                   Each version should be worded differently, using synonyms or alternative sentence structures, \</span><br><span class="hljs-string">                   but they should all retain the original meaning. \</span><br><span class="hljs-string">                   These versions will be used to retrieve relevant documents. \</span><br><span class="hljs-string">                   It is very important to provide each query version on a separate line, \</span><br><span class="hljs-string">                   without enumerations, hyphens, or any additional formatting!</span><br><span class="hljs-string">                   User query: &#123;&#123;query&#125;&#125;&quot;</span><span class="hljs-string">&quot;&quot;</span><br>   );<br></code></pre></td></tr></table></figure><h4 id="compressingquerytransformer">1.3CompressingQueryTransformer</h4><p>压缩历史会话</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> PromptTemplate DEFAULT_PROMPT_TEMPLATE = PromptTemplate.from(<br>        <span class="hljs-string">&quot;&quot;</span><span class="hljs-string">&quot;</span><br><span class="hljs-string">                Read and understand the conversation between the User and the AI. \</span><br><span class="hljs-string">                Then, analyze the new query from the User. \</span><br><span class="hljs-string">                Identify all relevant details, terms, and context from both the conversation and the new query. \</span><br><span class="hljs-string">                Reformulate this query into a clear, concise, and self-contained format suitable for information retrieval.</span><br><span class="hljs-string">                </span><br><span class="hljs-string">                Conversation:</span><br><span class="hljs-string">                &#123;&#123;chatMemory&#125;&#125;</span><br><span class="hljs-string">                </span><br><span class="hljs-string">                User query: &#123;&#123;query&#125;&#125;</span><br><span class="hljs-string">                </span><br><span class="hljs-string">                It is very important that you provide only reformulated query and nothing else! \</span><br><span class="hljs-string">                Do not prepend a query with anything!&quot;</span><span class="hljs-string">&quot;&quot;</span><br>);<br></code></pre></td></tr></table></figure><h3 id="contentaggregator">2. ContentAggregator</h3><p>Aggregates all Contents retrieved from all ContentRetrievers usingall Querys. The goal is to ensure that only the most relevant andnon-redundant Contents are presented to the LLM.</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202503091945008.png" style="zoom:50%;" /></p><h4 id="defaultcontentaggregator">2.1 DefaultContentAggregator</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultContentAggregator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ContentAggregator</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;Content&gt; <span class="hljs-title">aggregate</span><span class="hljs-params">(Map&lt;Query, Collection&lt;List&lt;Content&gt;&gt;&gt; queryToContents)</span> </span>&#123;<br><br>        <span class="hljs-comment">// First, for each query, fuse all contents retrieved from different sources using that query.</span><br>        Map&lt;Query, List&lt;Content&gt;&gt; fused = fuse(queryToContents);<br><br>        <span class="hljs-comment">// Then, fuse all contents retrieved using all queries</span><br>        <span class="hljs-keyword">return</span> ReciprocalRankFuser.fuse(fused.values());<br>    &#125;<br><br>    <span class="hljs-keyword">protected</span> Map&lt;Query, List&lt;Content&gt;&gt; fuse(Map&lt;Query, Collection&lt;List&lt;Content&gt;&gt;&gt; queryToContents) &#123;<br>        Map&lt;Query, List&lt;Content&gt;&gt; fused = <span class="hljs-keyword">new</span> LinkedHashMap&lt;&gt;();<br>        <span class="hljs-keyword">for</span> (Query query : queryToContents.keySet()) &#123;<br>            Collection&lt;List&lt;Content&gt;&gt; contents = queryToContents.get(query);<br>            fused.put(query, ReciprocalRankFuser.fuse(contents));<br>        &#125;<br>        <span class="hljs-keyword">return</span> fused;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Stage 1: For each Query, all List&lt;Content&gt; retrieved with thatQuery are merged into a single List&lt;Content&gt;.</p><p>Stage 2: All List&lt;Content&gt; (results from stage 1) are mergedinto a single List&lt;Content&gt;.</p><p>将所有结果按出现次数排序。</p><h4 id="rerankingcontentaggregator">2.2 ReRankingContentAggregator</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 以上逻辑和DefaultContentAggregator类似</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> List&lt;Content&gt; <span class="hljs-title">reRankAndFilter</span><span class="hljs-params">(List&lt;Content&gt; contents, Query query)</span> </span>&#123;<br><br>    List&lt;TextSegment&gt; segments = contents.stream()<br>            .map(Content::textSegment)<br>            .collect(Collectors.toList());<br><br>    List&lt;Double&gt; scores = scoringModel.scoreAll(segments, query.text()).content();<br><br>    Map&lt;TextSegment, Double&gt; segmentToScore = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; segments.size(); i++) &#123;<br>        segmentToScore.put(segments.get(i), scores.get(i));<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> segmentToScore.entrySet().stream()<br>            .filter(entry -&gt; minScore == <span class="hljs-keyword">null</span> || entry.getValue() &gt;= minScore)<br>            .sorted(Map.Entry.&lt;TextSegment, Double&gt;comparingByValue().reversed())<br>            .map(entry -&gt;  Content.from(entry.getKey(), Map.of(RERANKED_SCORE, entry.getValue())))<br>            .limit(maxResults)<br>            .collect(Collectors.toList());<br>&#125;<br></code></pre></td></tr></table></figure><p>用打分模型进行打分，排除低于 minScore的记录，用分数进行排序，最后取指定条数的记录。</p><h3 id="queryrouter">3. QueryRouter</h3><p>Routes the given Query to one or multiple ContentRetrievers.</p><p>The goal is to ensure that Content is retrieved only from relevantdata sources.</p><h4 id="defaultqueryrouter">3.1 DefaultQueryRouter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultQueryRouter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">QueryRouter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Collection&lt;ContentRetriever&gt; contentRetrievers;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;ContentRetriever&gt; <span class="hljs-title">route</span><span class="hljs-params">(Query query)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> contentRetrievers;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认路由返回所有检索器。</p><h4 id="languagemodelqueryrouter">3.2 LanguageModelQueryRouter</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Collection&lt;ContentRetriever&gt; <span class="hljs-title">route</span><span class="hljs-params">(Query query)</span> </span>&#123;<br>    Prompt prompt = createPrompt(query);<br>    <span class="hljs-keyword">try</span> &#123;<br>        String response = chatLanguageModel.generate(prompt.text());<br>        <span class="hljs-keyword">return</span> parse(response);<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        log.warn(<span class="hljs-string">&quot;Failed to route query &#x27;&#123;&#125;&#x27;&quot;</span>, query.text(), e);<br>        <span class="hljs-keyword">return</span> fallback(query, e);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用大模型判断使用哪个 ContentRetriever。</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>LangChain4j</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LangChain4j——基于RAG实现企业智能客服系统</title>
    <link href="/2025/03/08/LangChain4j%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8ERAG%E5%AE%9E%E7%8E%B0%E4%BC%81%E4%B8%9A%E6%99%BA%E8%83%BD%E5%AE%A2%E6%9C%8D%E7%B3%BB%E7%BB%9F/"/>
    <url>/2025/03/08/LangChain4j%E2%80%94%E2%80%94%E5%9F%BA%E4%BA%8ERAG%E5%AE%9E%E7%8E%B0%E4%BC%81%E4%B8%9A%E6%99%BA%E8%83%BD%E5%AE%A2%E6%9C%8D%E7%B3%BB%E7%BB%9F/</url>
    
    <content type="html"><![CDATA[<h3 id="整理数据">1. 整理数据</h3><p>首先，我们需要把数据整理成文档，可以是 txt、pdf、xlsx、markdown等格式都可以。这里我们将<ahref="https://waimai.meituan.com/help/faq">美团外卖 -常见问题</a>网页中的问题和答案转成 txt 文件，<ahref="https://debugging.oss-cn-hangzhou.aliyuncs.com/202503081027259.txt">【传送门】</a></p><h3 id="导入知识库">2. 导入知识库</h3><h4 id="加载并解析文件">2.1 加载并解析文件</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">DocumentParser documentParser = <span class="hljs-keyword">new</span> TextDocumentParser();<br>Document document = documentParser.parse(Main.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;meituan-qa.txt&quot;</span>));<br></code></pre></td></tr></table></figure><h4 id="切分文件">2.2 切分文件</h4><p>需要把文件中的内容切分成问答对。</p><p>自定义分割方法（按空行分割，即两个换行）：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomerServiceDocumentSplitter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">DocumentSplitter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;TextSegment&gt; <span class="hljs-title">split</span><span class="hljs-params">(Document document)</span> </span>&#123;<br>        List&lt;TextSegment&gt; segments = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>        String[] parts = split(document.text());<br>        <span class="hljs-keyword">for</span> (String part : parts) &#123;<br>            segments.add(TextSegment.from(part));<br>        &#125;<br>        <span class="hljs-keyword">return</span> segments;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> String[] split(String text) &#123;<br>        <span class="hljs-keyword">return</span> text.split(<span class="hljs-string">&quot;\\s*\\R\\s*\\R\\s*&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>切分 Document 对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">DocumentSplitter splitter = <span class="hljs-keyword">new</span> CustomerServiceDocumentSplitter() ;<br>List&lt;TextSegment&gt; segments = splitter.split(document);<br></code></pre></td></tr></table></figure><h4 id="文本向量化">2.3 文本向量化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">EmbeddingModel embeddingModel = ZhipuChatModelUtil.getZhipuEmbeddingModel();<br>List&lt;Embedding&gt; embeddings = embeddingModel.embedAll(segments).content();<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202503081138881.png" style="zoom:35%;" /></p><h4 id="向量存储">2.4 向量存储</h4><p>得到向量后，就需要把文本和向量之间的映射关系存储下来，使用CustomerServiceAgent在回答问题时，能够根据向量相似度找到和用户问题相似的知识库问题。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">EmbeddingStore&lt;TextSegment&gt; embeddingStore = RedisEmbeddingStore.builder()<br>        .host(<span class="hljs-string">&quot;127.0.0.1&quot;</span>).port(<span class="hljs-number">16379</span>).dimension(<span class="hljs-number">1024</span>).build();<br>embeddingStore.addAll(embeddings, segments);<br></code></pre></td></tr></table></figure><h3 id="contentretriever">3. ContentRetriever</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ContentRetriever contentRetriever = EmbeddingStoreContentRetriever.builder()<br>        .embeddingStore(embeddingStore).embeddingModel(embeddingModel)<br>        .maxResults(<span class="hljs-number">5</span>) <span class="hljs-comment">// 最相似的5个结果</span><br>        .minScore(<span class="hljs-number">0.8</span>) <span class="hljs-comment">// 只找相似度在0.8以上的内容</span><br>        .build();<br></code></pre></td></tr></table></figure><p>提问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Query query = <span class="hljs-keyword">new</span> Query(<span class="hljs-string">&quot;余额提现什么时候到账？&quot;</span>);<br>List&lt;Content&gt; retrieve = contentRetriever.retrieve(query);<br></code></pre></td></tr></table></figure><h3 id="整合大模型">4.整合大模型</h3><p>当我们能根据用户问题匹配到原始问题和答案后，该如何将问题的答案返回给用户呢？比如今天是2025 年 3 月 8号，用户问“今天的余额提现，最晚什么时候能到账？”，作为智能客服系统，能不能直接告诉客户具体的日期呢，而不是只返回一个“1-7个工作日内可退回您的支付账户”让客户来算日期，实现这个功能就可以结合大模型来实现了。</p><h4 id="定义-agent">4.1 定义 Agent</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CustomerServiceAgent</span> </span>&#123;<br><br>    <span class="hljs-function">String <span class="hljs-title">answer</span><span class="hljs-params">(String question)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> CustomerServiceAgent <span class="hljs-title">getCustomerServiceAgent</span><span class="hljs-params">()</span> </span>&#123;<br>        EmbeddingModel embeddingModel = ZhipuChatModelUtil.getZhipuEmbeddingModel();<br>        ChatLanguageModel chatModel = ZhipuChatModelUtil.getZhipuChatModel();<br>        EmbeddingStore&lt;TextSegment&gt; embeddingStore = RedisEmbeddingStore.builder()<br>                .host(<span class="hljs-string">&quot;127.0.0.1&quot;</span>).port(<span class="hljs-number">16379</span>).dimension(<span class="hljs-number">1024</span>).build();<br>        ChatMemory chatMemory = MessageWindowChatMemory.withMaxMessages(<span class="hljs-number">10</span>);<br><br>        ContentRetriever contentRetriever = buildContentRetriever(embeddingStore, embeddingModel);<br>        <span class="hljs-keyword">return</span> AiServices.builder(CustomerServiceAgent.class).chatLanguageModel(chatModel)<br>                .contentRetriever(contentRetriever).chatMemory(chatMemory).build();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ContentRetriever <span class="hljs-title">buildContentRetriever</span><span class="hljs-params">(EmbeddingStore&lt;TextSegment&gt; embeddingStore, EmbeddingModel embeddingModel)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> EmbeddingStoreContentRetriever.builder()<br>                .embeddingStore(embeddingStore).embeddingModel(embeddingModel)<br>                .maxResults(<span class="hljs-number">5</span>) <span class="hljs-comment">// 最相似的5个结果</span><br>                .minScore(<span class="hljs-number">0.8</span>) <span class="hljs-comment">// 只找相似度在0.8以上的内容</span><br>                .build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">CustomerServiceAgent serviceAgent = CustomerServiceAgent.getCustomerServiceAgent();<br>String answer = serviceAgent.answer(<span class="hljs-string">&quot;余额提现什么时候到账？&quot;</span>);<br>System.out.println(answer);<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">余额提现通常在1-7个工作日内到账，但具体到账时间可能会因银行处理延迟而有所不同，请以账户实际到账时间为准。<br></code></pre></td></tr></table></figure><p>没有达到我们想要的效果，我们可以这么问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String answer = serviceAgent.answer(<span class="hljs-string">&quot;今天的余额提现，最晚哪天能到账？给我具体的日期&quot;</span>);<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight subunit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs subunit">根据您提供的信息，如果今天进行余额提现，最晚在1<span class="hljs-string">-7</span>个工作日内可以到账。由于工作日不包括周末和公共假日，因此需要具体确定从今天开始计算的工作日天数。<br><br>例如，如果今天是周一，那么最晚到账的日期将是周五。如果今天是周二，那么最晚到账的日期将是下周的周二。<br><br>请您根据实际的工作日计算，从今天起算的第7个工作日即为最晚到账日期。如果您需要具体的日期，请提供今天的具体日期，我可以帮您计算出最晚到账的日期。<br></code></pre></td></tr></table></figure><p>我们发现虽然整合了大模型，但是大模型似乎对今天是不是周末、是不是工作日这些不太智能，那这就需要利用langchain4j 的 Tools 技术了。</p><h4 id="整合tools">4.2 整合tools</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DateCalculator</span> </span>&#123;<br>    <span class="hljs-meta">@Tool(&quot;计算指定天数后的具体日期&quot;)</span><br>    <span class="hljs-function">String <span class="hljs-title">date</span><span class="hljs-params">(Integer days)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> LocalDate.now().plusDays(days).toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>绑定到 AiService 中:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">return</span> AiServices.builder(CustomerServiceAgent.class).chatLanguageModel(chatModel).tools(<span class="hljs-keyword">new</span> DateCalculator())<br>        .contentRetriever(contentRetriever).chatMemory(chatMemory).build();<br></code></pre></td></tr></table></figure><p>重新直接结果：</p><figure class="highlight dns"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs dns">根据您提供的余额提现信息，一般来说<span class="hljs-number">1</span>-<span class="hljs-number">7</span>个工作日内可退回您的支付账户，但具体到账时间会因银行处理可能有延迟而有所不同。根据计算，您今天的余额提现最晚在<span class="hljs-number">2025年3月15</span>日到账。<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>LangChain4j</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LangChain4j——ChatMemory、Tools、Embedding</title>
    <link href="/2025/03/03/LangChain4j%E2%80%94%E2%80%94ChatMemory%E3%80%81Tools%E3%80%81Embedding/"/>
    <url>/2025/03/03/LangChain4j%E2%80%94%E2%80%94ChatMemory%E3%80%81Tools%E3%80%81Embedding/</url>
    
    <content type="html"><![CDATA[<h3 id="chatmemory">1. ChatMemory</h3><p>ChatMemory 是一个接口，默认提供了两个实现类：</p><ol type="1"><li>MessageWindowChatMemory</li><li>TokenWindowChatMemory</li></ol><h4 id="使用">1.1 使用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ChatLanguageModel model = ZhipuChatModelUtil.getZhipuChatModel();<br>ChatMemory chatMemory = MessageWindowChatMemory.withMaxMessages(<span class="hljs-number">10</span>);<br><br>NamingMaster namingMaster = AiServices.builder(NamingMaster.class).chatLanguageModel(model).chatMemory(chatMemory).build();<br>System.out.println(namingMaster.naming(<span class="hljs-string">&quot;取一个中国文化内涵的男孩名字&quot;</span>));<br>System.out.println(namingMaster.naming(<span class="hljs-string">&quot;换一个&quot;</span>));<br></code></pre></td></tr></table></figure><h4 id="消息存储">1.2 消息存储</h4><p>两个实现类内部都有一个 ChatMemoryStore 属性，ChatMemoryStore也是一个接口，默认有一个 InMemoryChatMemoryStore实现类，该类的实现比较简单：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InMemoryChatMemoryStore</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ChatMemoryStore</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;Object, List&lt;ChatMessage&gt;&gt; messagesByMemoryId = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Constructs a new &#123;<span class="hljs-doctag">@link</span> InMemoryChatMemoryStore&#125;.</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">InMemoryChatMemoryStore</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;ChatMessage&gt; <span class="hljs-title">getMessages</span><span class="hljs-params">(Object memoryId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> messagesByMemoryId.computeIfAbsent(memoryId, ignored -&gt; <span class="hljs-keyword">new</span> ArrayList&lt;&gt;());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateMessages</span><span class="hljs-params">(Object memoryId, List&lt;ChatMessage&gt; messages)</span> </span>&#123;<br>        messagesByMemoryId.put(memoryId, messages);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteMessages</span><span class="hljs-params">(Object memoryId)</span> </span>&#123;<br>        messagesByMemoryId.remove(memoryId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本质上就是一个ConcurrentHashMap，所以我们可以自定义 ChatMemoryStore的实现类来实现将 ChatMessage 持久化到磁盘。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FileDBPersistentChatMemoryStore</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ChatMemoryStore</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> DB db = DBMaker.fileDB(<span class="hljs-string">&quot;chat-memory.db&quot;</span>).transactionEnable().make();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;String, String&gt; map = db.hashMap(<span class="hljs-string">&quot;messages&quot;</span>, STRING, STRING).createOrOpen();<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> List&lt;ChatMessage&gt; <span class="hljs-title">getMessages</span><span class="hljs-params">(Object memoryId)</span> </span>&#123;<br>        String json = map.get((String) memoryId);<br>        <span class="hljs-keyword">return</span> messagesFromJson(json);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateMessages</span><span class="hljs-params">(Object memoryId, List&lt;ChatMessage&gt; messages)</span> </span>&#123;<br>        String json = messagesToJson(messages);<br>        map.put((String) memoryId, json);<br>        db.commit();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">deleteMessages</span><span class="hljs-params">(Object memoryId)</span> </span>&#123;<br>        map.remove((String) memoryId);<br>        db.commit();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mapdb<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mapdb<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.jetbrains.kotlin<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>kotlin-stdlib<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="消息淘汰机制">1.3 消息淘汰机制</h4><p>MessageWindowChatMemory.add()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(ChatMessage message)</span> </span>&#123;<br>    <span class="hljs-comment">// 从ChatMemoryStore获取当前所存储的ChatMessage</span><br>    List&lt;ChatMessage&gt; messages = messages();<br>    <span class="hljs-comment">// 如果待添加的是SystemMessage</span><br>    <span class="hljs-keyword">if</span> (message <span class="hljs-keyword">instanceof</span> SystemMessage) &#123;<br>        Optional&lt;SystemMessage&gt; systemMessage = findSystemMessage(messages);<br>        <span class="hljs-keyword">if</span> (systemMessage.isPresent()) &#123;<br>            <span class="hljs-keyword">if</span> (systemMessage.get().equals(message)) &#123;<br>                <span class="hljs-keyword">return</span>; <span class="hljs-comment">// do not add the same system message</span><br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                messages.remove(systemMessage.get()); <span class="hljs-comment">// need to replace existing system message</span><br>            &#125;<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">// 添加消息</span><br>    messages.add(message);<br>    <span class="hljs-comment">// 如果超过了maxMessages限制，则会淘汰List最前面的，也就是最旧的ChatMessage</span><br>  <span class="hljs-comment">// 注意，SystemMessage不会被淘汰</span><br>    ensureCapacity(messages, maxMessages);<br>    <span class="hljs-comment">// 将改变了的List更新到ChatMemoryStore中</span><br>    store.updateMessages(id, messages);<br>&#125;<br></code></pre></td></tr></table></figure><p>TokenWindowChatMemory 和 MessageWindowChatMemory类似，区别在于计算容量的方式不一样，MessageWindowChatMemory 直接取的是List&lt;ChatMessage&gt;的大小，而 TokenWindowChatMemory 会利用指定的Tokenizer 对List&lt;ChatMessage&gt; 对应的 Token数进行估算，然后和设置的 maxTokens 进行比较，超过 maxTokens也会进行淘汰，也是淘汰最旧的 ChatMessage。</p><h4 id="独立chatmemory">1.4 独立ChatMemory</h4><p>MessageWindowChatMemory 和 TokenWindowChatMemory 还有一个 id属性，用于区分不同的用户。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">NamingMaster</span> </span>&#123;<br>    <span class="hljs-meta">@SystemMessage(&quot;你是一个资深的取名大师，根据输入的主题取名&quot;)</span><br>    <span class="hljs-function">String <span class="hljs-title">naming</span><span class="hljs-params">(<span class="hljs-meta">@MemoryId</span> String userId, <span class="hljs-meta">@UserMessage</span> String desc)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">NamingMaster namingMaster = AiServices.builder(NamingMaster.class).chatLanguageModel(model)<br>        .chatMemoryProvider(usrId -&gt; MessageWindowChatMemory.withMaxMessages(<span class="hljs-number">10</span>)).build();<br><br>System.out.println(namingMaster.naming(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;取一个中国文化内涵的男孩名字&quot;</span>));<br>System.out.println(namingMaster.naming(<span class="hljs-string">&quot;1&quot;</span>, <span class="hljs-string">&quot;换一个&quot;</span>));<br></code></pre></td></tr></table></figure><h4 id="aiservices-整合-chatmemory-源码分析">1.5 AiServices 整合ChatMemory 源码分析</h4><p>DefaultAiServices 代理对象 invoke() 方法中，<ahref="https://debuggingworld.github.io/2025/02/27/LangChain4j%E2%80%94%E2%80%94AiService/">【传送门】</a>,会执行以下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Object memoryId = findMemoryId(method, args).orElse(DEFAULT);<br></code></pre></td></tr></table></figure><p>就是解析方法参数中加了 <span class="citation"data-cites="MemoryId">@MemoryId</span> 注解的参数值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (context.hasChatMemory()) &#123;<br>    <span class="hljs-comment">// 根据memoryId获取或创建ChatMemory</span><br>    ChatMemory chatMemory = context.chatMemory(memoryId);<br>    <span class="hljs-comment">// 将SystemMessage、UserMessage添加到ChatMemory中</span><br>    systemMessage.ifPresent(chatMemory::add);<br>    chatMemory.add(userMessage);<br>&#125;<br></code></pre></td></tr></table></figure><p>context 为 AiServiceContext，它内部有一个 chatMemories 属性，类型为Map&lt;Object, ChatMemory&gt; ，就是专门用来存储 memoryId 和 ChatMemory对象之间的映射关系的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;ChatMessage&gt; messages;<br><span class="hljs-keyword">if</span> (context.hasChatMemory()) &#123;<br>    messages = context.chatMemory(memoryId).messages();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>    messages = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    systemMessage.ifPresent(messages::add);<br>    messages.add(userMessage);<br>&#125;<br></code></pre></td></tr></table></figure><p>根据 memoryId 把对应的 ChatMemory 中存储的所有 ChatMessage获取出来，然后传入给大模型就可以了。</p><h3 id="tools">2. Tools</h3><h4 id="toolspecification">2.1 ToolSpecification</h4><p>首先需要定义一个工具，其实就是一个方法。</p><p>实例：获取当前时间，并且通过 <span class="citation"data-cites="Tool">@Tool</span>注解来描述该工具，从而使得大模型在需要获取当前时间时能够调用该工具方法得到当前时间。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Tool(&quot;获取当前时间&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">dateUtil</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> LocalDateTime.now().toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>然后将工具方法转成 ToolSpecification 对象，并传递给大模型：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    ChatLanguageModel model = ZhipuChatModelUtil.getZhipuChatModel();<br>    ToolSpecification toolSpecification = ToolSpecifications.toolSpecificationFrom(Tools.class.getMethod(<span class="hljs-string">&quot;dateUtil&quot;</span>));<br><br>    ChatRequestParameters parameters = ChatRequestParameters.builder().toolSpecifications(toolSpecification).build();<br><br>    List&lt;ChatMessage&gt; messages = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    messages.add(UserMessage.from(<span class="hljs-string">&quot;今天是几号&quot;</span>));<br><br>    ChatRequest chatRequest = ChatRequest.builder().messages(messages).parameters(parameters).build();<br>    AiMessage aiMessage = model.chat(chatRequest).aiMessage();<br>    messages.add(aiMessage);<br>    <span class="hljs-keyword">if</span> (aiMessage.hasToolExecutionRequests()) &#123;<br>        <span class="hljs-keyword">for</span> (ToolExecutionRequest toolExecutionRequest : aiMessage.toolExecutionRequests()) &#123;<br>            Method method = Tools.class.getMethod(toolExecutionRequest.name());<br>            String result = (String) method.invoke(<span class="hljs-keyword">null</span>);<br>            log.info(<span class="hljs-string">&quot;tool invoke result &#123;&#125;&quot;</span>, result);<br>            <span class="hljs-comment">// 把工具的执行结果封装为ToolExecutionResultMessage</span><br>            messages.add(ToolExecutionResultMessage.from(toolExecutionRequest.id(), toolExecutionRequest.name(), result));<br>        &#125;<br>    &#125;<br><br>    chatRequest = ChatRequest.builder().messages(messages).parameters(parameters).build();<br>    aiMessage = model.chat(chatRequest).aiMessage();<br>    log.info(<span class="hljs-string">&quot;&#123;&#125;&quot;</span>, aiMessage);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="aiservices整合tools">2.2 AiServices整合Tools</h4><p>如果大模型要解决一个复杂问题需要调用多个工具或多轮工具调用，以上代码就更不合适了，而AiServices 能简化这个过程。</p><p>假如有这么一个需求：获取今天注册的所有新用户信息，对于这个需求我们可以这么来实现。</p><p>定义两个Tools：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tools</span> </span>&#123;<br>    <span class="hljs-meta">@Tool(&quot;获取当前时间&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">dateUtil</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> LocalDateTime.now().toString();<br>    &#125;<br><br>    <span class="hljs-meta">@Tool(&quot;获取指定日期注册的用户信息&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> List&lt;User&gt; <span class="hljs-title">getUserInfo</span><span class="hljs-params">(String date)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;date:&#123;&#125;&quot;</span>, date);<br>        User user1 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;debug&quot;</span>, <span class="hljs-number">18</span>);<br>        User user2 = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;world&quot;</span>, <span class="hljs-number">18</span>);<br>        <span class="hljs-keyword">return</span> Lists.newArrayList(user1, user2);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>再定义一个 UserService 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-meta">@SystemMessage(&quot;先获取时间，然后获取指定时间的用户信息&quot;)</span><br>    <span class="hljs-function">String <span class="hljs-title">getUserInfo</span><span class="hljs-params">(String desc)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后利用 AiServices 创建 UserService 接口的代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    ChatLanguageModel model = ZhipuChatModelUtil.getZhipuChatModel();<br><br>    UserService userService = AiServices.builder(UserService.class).chatLanguageModel(model).tools(<span class="hljs-keyword">new</span> Tools())<br>            .chatMemory(MessageWindowChatMemory.withMaxMessages(<span class="hljs-number">10</span>)).build();<br>    String userInfo = userService.getUserInfo(<span class="hljs-string">&quot;获取今天注册的用户&quot;</span>);<br>    log.info(<span class="hljs-string">&quot;userInfo:&#123;&#125;&quot;</span>, userInfo);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs shell">11:13:21.180 [main] DEBUG dev.langchain4j.service.tool.DefaultToolExecutor - About to execute ToolExecutionRequest &#123; id = &quot;call_-8929807481949233726&quot;, name = &quot;dateUtil&quot;, arguments = &quot;&#123;&#125;&quot; &#125; for memoryId default<br>11:13:21.202 [main] DEBUG dev.langchain4j.service.tool.DefaultToolExecutor - Tool execution result: 2025-03-04T11:13:21.202692<br>11:13:22.148 [main] DEBUG dev.langchain4j.service.tool.DefaultToolExecutor - About to execute ToolExecutionRequest &#123; id = &quot;call_-8929805763961766996&quot;, name = &quot;getUserInfo&quot;, arguments = &quot;&#123;&quot;arg0&quot;: &quot;2025-03-04&quot;&#125;&quot; &#125; for memoryId default<br>11:13:22.149 [main] INFO com.debug.ai.spring_ai_test.AiService.Tools - date:2025-03-04<br>11:13:22.163 [main] DEBUG dev.langchain4j.service.tool.DefaultToolExecutor - Tool execution result: [<br>  &#123;<br>    &quot;username&quot;: &quot;debug&quot;,<br>    &quot;age&quot;: 18<br>  &#125;,<br>  &#123;<br>    &quot;username&quot;: &quot;world&quot;,<br>    &quot;age&quot;: 18<br>  &#125;<br>]<br>11:13:23.748 [main] INFO com.debug.ai.spring_ai_test.AiService.Main - userInfo:根据您的要求，我已经获取了今天注册的用户信息。根据API调用结果，今天注册的用户有debug和world两位，他们的年龄都是18岁。<br><br></code></pre></td></tr></table></figure><h4 id="源码分析">2.3 源码分析</h4><p>在代理对象的 invoke() 方法中，以下代码会去调用大模型的底层API：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">ToolExecutionResult toolExecutionResult = context.toolService.executeInferenceAndToolsLoop(<br>        chatResponse,<br>        parameters,<br>        messages,<br>        context.chatModel,<br>        context.hasChatMemory() ? context.chatMemory(memoryId) : <span class="hljs-keyword">null</span>,<br>        memoryId,<br>        toolExecutionContext.toolExecutors());<br></code></pre></td></tr></table></figure><p>执行过程：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> ToolExecutionResult <span class="hljs-title">executeInferenceAndToolsLoop</span><span class="hljs-params">(.....)</span> </span>&#123;<br>    TokenUsage tokenUsageAccumulator = chatResponse.metadata().tokenUsage();<br>    <span class="hljs-keyword">int</span> executionsLeft = MAX_SEQUENTIAL_TOOL_EXECUTIONS;<br>    List&lt;ToolExecution&gt; toolExecutions = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>        AiMessage aiMessage = chatResponse.aiMessage();<br>        <span class="hljs-comment">// ai消息入库</span><br>        <span class="hljs-keyword">if</span> (chatMemory != <span class="hljs-keyword">null</span>) &#123;<br>            chatMemory.add(aiMessage);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            messages = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(messages);<br>            messages.add(aiMessage);<br>        &#125;<br>        <span class="hljs-comment">// 没有tool执行直接返回</span><br>        <span class="hljs-keyword">if</span> (!aiMessage.hasToolExecutionRequests()) &#123;<br>            <span class="hljs-keyword">break</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">for</span> (ToolExecutionRequest toolExecutionRequest : aiMessage.toolExecutionRequests()) &#123;<br>            ToolExecutor toolExecutor = toolExecutors.get(toolExecutionRequest.name());<br><br>            <span class="hljs-comment">// 执行tool,获取tool结果</span><br>            ToolExecutionResultMessage toolExecutionResultMessage = toolExecutor == <span class="hljs-keyword">null</span><br>                    ? toolHallucinationStrategy.apply(toolExecutionRequest)<br>                    : ToolExecutionResultMessage.from(<br>                            toolExecutionRequest, toolExecutor.execute(toolExecutionRequest, memoryId));<br><br>            toolExecutions.add(ToolExecution.builder()<br>                    .request(toolExecutionRequest)<br>                    .result(toolExecutionResultMessage.text())<br>                    .build());<br><br>            <span class="hljs-comment">// 工具结果入库</span><br>            <span class="hljs-keyword">if</span> (chatMemory != <span class="hljs-keyword">null</span>) &#123;<br>                chatMemory.add(toolExecutionResultMessage);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                messages.add(toolExecutionResultMessage);<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (chatMemory != <span class="hljs-keyword">null</span>) &#123;<br>            messages = chatMemory.messages();<br>        &#125;<br><br>        <span class="hljs-comment">// 构造下一轮请求</span><br>        ChatRequest chatRequest = ChatRequest.builder()<br>                .messages(messages)<br>                .parameters(parameters)<br>                .build();<br><br>        <span class="hljs-comment">// 请求大模型</span><br>        chatResponse = chatModel.chat(chatRequest);<br><br>        tokenUsageAccumulator = TokenUsage.sum(<br>                tokenUsageAccumulator, chatResponse.metadata().tokenUsage());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ToolExecutionResult(chatResponse, toolExecutions, tokenUsageAccumulator);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="embedding">3. Embedding</h3><h4 id="文本向量化">3.1 文本向量化</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">EmbeddingModel embeddingModel = ZhipuChatModelUtil.getZhipuEmbeddingModel();<br>Response&lt;Embedding&gt; embed = embeddingModel.embed(<span class="hljs-string">&quot;hello,debuggingWorld&quot;</span>);<br>System.out.println(embed.content());<br>System.out.println(embed.content().vector().length);<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">Embedding &#123; vector = [-0.013567284, 0.045297697, .....]&#125;<br>1024<br></code></pre></td></tr></table></figure><h4 id="向量数据库">3.2 向量数据库</h4><p>对于向量模型生成出来的向量，我们可以持久化到向量数据库，并且能利用向量数据库来计算两个向量之间的相似度，或者根据一个向量查找跟这个向量最相似的向量。</p><p>支持的数据库已支持的操作<ahref="https://docs.langchain4j.dev/integrations/embedding-stores/">【传送门】</a></p><p>以 redis 为例：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>dev.langchain4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>langchain4j-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-alpha1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>【注】redis 一定要带 <strong>RediSearch</strong>模块，可以用官方镜像：redislabs/redisearch。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">EmbeddingModel embeddingModel = ZhipuChatModelUtil.getZhipuEmbeddingModel();<br><br>RedisEmbeddingStore embeddingStore = RedisEmbeddingStore.builder()<br>        .host(<span class="hljs-string">&quot;127.0.0.1&quot;</span>).port(<span class="hljs-number">16379</span>).dimension(<span class="hljs-number">1024</span>).build();<br><br><span class="hljs-comment">// 向量化</span><br>Response&lt;Embedding&gt; embed = embeddingModel.embed(<span class="hljs-string">&quot;debug world&quot;</span>);<br><span class="hljs-comment">// 存储向量</span><br>embeddingStore.add(embed.content());<br></code></pre></td></tr></table></figure><p>向量库清空：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">redis-cli FT.DROPINDEX embedding-index DD<br></code></pre></td></tr></table></figure><h4 id="匹配向量">3.3 匹配向量</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java">EmbeddingModel embeddingModel = ZhipuChatModelUtil.getZhipuEmbeddingModel();<br><br>RedisEmbeddingStore embeddingStore = RedisEmbeddingStore.builder()<br>        .host(<span class="hljs-string">&quot;127.0.0.1&quot;</span>).port(<span class="hljs-number">16379</span>).dimension(<span class="hljs-number">1024</span>).build();<br><br>TextSegment textSegment1 = TextSegment.textSegment(<span class="hljs-string">&quot;客服电话是400-8558558&quot;</span>);<br>TextSegment textSegment2 = TextSegment.textSegment(<span class="hljs-string">&quot;客服工作时间是周一到周五&quot;</span>);<br>TextSegment textSegment3 = TextSegment.textSegment(<span class="hljs-string">&quot;投诉电话是400-8668668&quot;</span>);<br><br>embeddingStore.add(embeddingModel.embed(textSegment1).content(), textSegment1);<br>embeddingStore.add(embeddingModel.embed(textSegment2).content(), textSegment2);<br>embeddingStore.add(embeddingModel.embed(textSegment3).content(), textSegment3);<br><br><br><span class="hljs-comment">// 生成向量</span><br>Response&lt;Embedding&gt; embed = embeddingModel.embed(<span class="hljs-string">&quot;客服电话多少&quot;</span>);<br><br>EmbeddingSearchRequest searchRequest = EmbeddingSearchRequest.builder().queryEmbedding(embed.content()).maxResults(<span class="hljs-number">2</span>).build();<br>List&lt;EmbeddingMatch&lt;TextSegment&gt;&gt; result = embeddingStore.search(searchRequest).matches();<br><span class="hljs-keyword">for</span> (EmbeddingMatch&lt;TextSegment&gt; embeddingMatch : result) &#123;<br>    System.out.println(embeddingMatch.embedded().text() + <span class="hljs-string">&quot;,分数为：&quot;</span> + embeddingMatch.score());<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>LangChain4j</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LangChain4j——AiService</title>
    <link href="/2025/02/27/LangChain4j%E2%80%94%E2%80%94AiService/"/>
    <url>/2025/02/27/LangChain4j%E2%80%94%E2%80%94AiService/</url>
    
    <content type="html"><![CDATA[<p>Supercharge your Java application with the power of LLMs官网：https://docs.langchain4j.dev/</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202503091614093.png" style="zoom:50%;" /></p><h3 id="helloworld">1. HelloWorld</h3><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>dev.langchain4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>langchain4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>dev.langchain4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>langchain4j-open-ai<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-beta1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="对话">1.1 对话</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ChatLanguageModel model = OpenAiChatModel.builder().apiKey(<span class="hljs-string">&quot;demo&quot;</span>).modelName(<span class="hljs-string">&quot;gpt-4o-mini&quot;</span>).build();<br>String answer = model.chat(<span class="hljs-string">&quot;你好，你是谁？&quot;</span>);<br>System.out.println(answer);<br></code></pre></td></tr></table></figure><h4 id="多轮对话">1.2 多轮对话</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ChatLanguageModel model = OpenAiChatModel.builder().apiKey(<span class="hljs-string">&quot;demo&quot;</span>).modelName(<span class="hljs-string">&quot;gpt-4o-mini&quot;</span>).build();<br><br>UserMessage userMessage = UserMessage.userMessage(<span class="hljs-string">&quot;你好，我是无极&quot;</span>);<br>AiMessage aiMessage = model.chat(userMessage).aiMessage();<br>AiMessage aiMessage2 = model.chat(userMessage, aiMessage, UserMessage.userMessage(<span class="hljs-string">&quot;我是谁&quot;</span>)).aiMessage();<br>System.out.println(aiMessage2);<br></code></pre></td></tr></table></figure><h4 id="流式输出">1.3 流式输出</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java">Duration sixtySeconds = Duration.ofSeconds(<span class="hljs-number">60</span>);<br>StreamingChatLanguageModel streamingChatModel = ZhipuAiStreamingChatModel.builder().apiKey(apiKey) .callTimeout(sixtySeconds).connectTimeout(sixtySeconds).writeTimeout(sixtySeconds).readTimeout(sixtySeconds).build();<br><br>streamingChatModel.chat(<span class="hljs-string">&quot;你好，你是谁？&quot;</span>, <span class="hljs-keyword">new</span> StreamingChatResponseHandler() &#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onPartialResponse</span><span class="hljs-params">(String partialResponse)</span> </span>&#123;<br>        System.out.println(partialResponse);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleteResponse</span><span class="hljs-params">(ChatResponse completeResponse)</span> </span>&#123;<br>        System.out.println(completeResponse.aiMessage());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable error)</span> </span>&#123;<br>        System.out.println(error.getMessage());<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h4 id="多模态模型">1.4 多模态模型</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ImageModel imageModel = ZhipuAiImageModel.builder().apiKey(apiKey).callTimeout(sixtySeconds)<br>        .connectTimeout(sixtySeconds).writeTimeout(sixtySeconds).readTimeout(sixtySeconds).build();<br>Image image = imageModel.generate(<span class="hljs-string">&quot;一只可爱的猫&quot;</span>).content();<br>System.out.println(image.url());<br>System.out.println(image.base64Data());<br></code></pre></td></tr></table></figure><h3 id="aiservice">2. AiService</h3><h4 id="基本用法">2.1 基本用法</h4><p>首先，我们定义一个接口Writer，表示作家：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Writer</span> </span>&#123;<br>    <span class="hljs-function">String <span class="hljs-title">write</span><span class="hljs-params">(String title)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用定义AiService来创建一个Writer代理对象，然后获取模型回答结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ChatLanguageModel model = ZhipuChatModelUtil.getZhipuChatModel();<br>Writer writer = AiServices.create(Writer.class, model);<br><br>String result = writer.write(<span class="hljs-string">&quot;写一篇关于机器学习算法的文章,两百字左右&quot;</span>);<br>System.out.println(result);<br></code></pre></td></tr></table></figure><h4 id="systemmessage">2.2 <span class="citation"data-cites="SystemMessage">@SystemMessage</span></h4><p>我们只需要在接口方法上定义 <span class="citation"data-cites="SystemMessage">@SystemMessage</span>，就可以指定系统提示词。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Writer</span> </span>&#123;<br>    <span class="hljs-meta">@SystemMessage(&quot;你是一名资深机器学习专家，根据输入的主题写一篇200字左右的论文&quot;)</span><br>    <span class="hljs-function">String <span class="hljs-title">write</span><span class="hljs-params">(String title)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Writer writer = AiServices.create(Writer.class, model);<br>String result = writer.write(<span class="hljs-string">&quot;强化学习&quot;</span>);<br>System.out.println(result);<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs css">标题：强化学习在复杂决策环境中的应用与挑战<br><br>摘要：强化学习作为一种先进的学习范式，通过智能体与环境交互，实现决策优化。本文综述了强化学习的基本原理、算法及其在复杂决策环境中的应用。首先介绍了强化学习的基本概念和主要算法，如<span class="hljs-selector-tag">Q</span>学习、SARSA、深度<span class="hljs-selector-tag">Q</span>网络等。接着探讨了强化学习在机器人控制、游戏、推荐系统等领域的应用实例。然而，强化学习在实际应用中仍面临诸多挑战，如样本效率、稀疏奖励、长期依赖等。本文最后分析了强化学习的研究趋势和未来发展方向。<br><br>关键词：强化学习；复杂决策；应用；挑战；研究趋势<br></code></pre></td></tr></table></figure><h4 id="v">2.3 <span class="citation" data-cites="V">@V</span></h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Writer</span> </span>&#123;<br>    <span class="hljs-meta">@SystemMessage(&quot;你是一名资深机器学习专家，根据输入的主题写一篇&#123;&#123;num&#125;&#125;字左右的论文&quot;)</span><br>    <span class="hljs-function">String <span class="hljs-title">write</span><span class="hljs-params">(<span class="hljs-meta">@UserMessage</span> String title, <span class="hljs-meta">@V(&quot;num&quot;)</span> <span class="hljs-keyword">int</span> num)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中{num}就是变量，该变量的值由用户在调用write方法时指定，注意由于write()有两个参数了，需要在title参数前面定义@UserMessage，表示title是用户消息。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String result = writer.write(<span class="hljs-string">&quot;强化学习&quot;</span>,<span class="hljs-number">200</span>);<br></code></pre></td></tr></table></figure><h4 id="moderate-和-moderationmodel">2.4 <span class="citation"data-cites="Moderate">@Moderate</span> 和 ModerationModel</h4><p>敏感词校验</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Writer</span> </span>&#123;<br>    <span class="hljs-meta">@Moderate</span><br>    <span class="hljs-function">String <span class="hljs-title">write</span><span class="hljs-params">(String title)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">ChatLanguageModel model = ZhipuChatModelUtil.getZhipuChatModel();<br>ModerationModel moderationModel = OpenAiModerationModel.builder().apiKey(<span class="hljs-string">&quot;demo&quot;</span>).build();<br>Writer writer = AiServices.builder(Writer.class).chatLanguageModel(model).moderationModel(moderationModel).build();<br><br>String result = writer.write(<span class="hljs-string">&quot;如何杀人&quot;</span>);<br>System.out.println(result);<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs js">Exception <span class="hljs-keyword">in</span> thread <span class="hljs-string">&quot;main&quot;</span> dev.langchain4j.service.ModerationException: Text <span class="hljs-string">&quot;如何杀人&quot;</span> violates content policy<br>at dev.langchain4j.service.AiServices.verifyModerationIfNeeded(AiServices.java:<span class="hljs-number">453</span>)<br>at dev.langchain4j.service.DefaultAiServices$1.invoke(DefaultAiServices.java:<span class="hljs-number">217</span>)<br>at jdk.proxy2/jdk.proxy2.$Proxy4.write(Unknown Source)<br>at com.debug.ai.spring_ai_test.AiService.Main.main(Main.java:<span class="hljs-number">24</span>)<br></code></pre></td></tr></table></figure><h4 id="源码分析">2.5 源码分析</h4><h5 id="代理对象的创建流程">1. 代理对象的创建流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 验证是否配置了ChatModel</span><br>    performBasicValidation();<br>  <br>    <span class="hljs-keyword">for</span> (Method method : context.aiServiceClass.getMethods()) &#123;<br>        <span class="hljs-comment">// 验证接口中是否有方法上加了@Moderate，但是又没有配置 ModerationModel</span><br>        <span class="hljs-keyword">if</span> (method.isAnnotationPresent(Moderate.class) &amp;&amp; context.moderationModel == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">throw</span> illegalConfiguration(<span class="hljs-string">&quot;The @Moderate annotation is present, but the moderationModel is not set up. Please ensure a valid moderationModel is configured before using the @Moderate annotation.&quot;</span>);<br>        &#125;<br>      <br>        <span class="hljs-comment">// 确保不使用通配符和/ 或参数化类型作为服务方法返回类型</span><br>        <span class="hljs-keyword">if</span> (method.getReturnType() == Result.class<br>                || method.getReturnType() == List.class<br>                || method.getReturnType() == Set.class) &#123;<br>            TypeUtils.validateReturnTypesAreProperlyParametrized(method.getName(),method.getGenericReturnType());<br>        &#125;<br><br>        <span class="hljs-comment">// 验证是不是没有提供 ChatMemoryProvider，但使用了 @MemoryId</span><br>        <span class="hljs-keyword">if</span> (context.chatMemoryProvider == <span class="hljs-keyword">null</span>) &#123;<br>            <span class="hljs-keyword">for</span> (Parameter parameter : method.getParameters()) &#123;<br>                <span class="hljs-keyword">if</span> (parameter.isAnnotationPresent(MemoryId.class)) &#123;<br>                    <span class="hljs-keyword">throw</span> illegalConfiguration(<span class="hljs-string">&quot;In order to use @MemoryId, please configure the ChatMemoryProvider on the &#x27;%s&#x27;.&quot;</span>, context.aiServiceClass.getName());<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">// JDK动态代理创建代理对象</span><br>    Object proxyInstance = Proxy.newProxyInstance(<br>            context.aiServiceClass.getClassLoader(),<br>            <span class="hljs-keyword">new</span> Class&lt;?&gt;[] &#123;context.aiServiceClass&#125;,<br>            <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br><br>                <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ExecutorService executor = Executors.newCachedThreadPool();<br><br>                <span class="hljs-meta">@Override</span><br>                <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;  <br>                <span class="hljs-comment">// ...</span><br>                &#125;<br>            &#125;);<br><br>    <span class="hljs-keyword">return</span> (T) proxyInstance;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="代理对象的方法执行流程">2. 代理对象的方法执行流程</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (method.getDeclaringClass() == Object.class) &#123;<br>        <span class="hljs-comment">// methods like equals(), hashCode() and toString() should not be handled by this proxy</span><br>        <span class="hljs-keyword">return</span> method.invoke(<span class="hljs-keyword">this</span>, args);<br>    &#125;<br><br>    <span class="hljs-comment">// 参数校验：如果有多个参数，是不是都带有注解</span><br>    validateParameters(method);<br><br>    <span class="hljs-comment">// @MemoryId 注解的值或者默认值</span><br>    Object memoryId = findMemoryId(method, args).orElse(DEFAULT);<br><br>    <span class="hljs-comment">// 获取 @SystemMessage 注解的所有值拼接成多行，并替换变量</span><br>    Optional&lt;SystemMessage&gt; systemMessage = prepareSystemMessage(memoryId, method, args);<br>  <br>    <span class="hljs-comment">// 获取方法上@UserMessage &amp; 参数上@UserMessage</span><br>    <span class="hljs-comment">// 同时存在抛错</span><br>    <span class="hljs-comment">// 都不存在，如果第一次参数没有注解，将第一个参数作为userMessage</span><br>    UserMessage userMessage = prepareUserMessage(method, args);<br>    <span class="hljs-comment">// 获取历史消息或者retrieved内容</span><br>    AugmentationResult augmentationResult = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (context.retrievalAugmentor != <span class="hljs-keyword">null</span>) &#123;<br>        List&lt;ChatMessage&gt; chatMemory = context.hasChatMemory()<br>                ? context.chatMemory(memoryId).messages()<br>                : <span class="hljs-keyword">null</span>;<br>        Metadata metadata = Metadata.from(userMessage, memoryId, chatMemory);<br>        AugmentationRequest augmentationRequest = <span class="hljs-keyword">new</span> AugmentationRequest(userMessage, metadata);<br>        augmentationResult = context.retrievalAugmentor.augment(augmentationRequest);<br>        userMessage = (UserMessage) augmentationResult.chatMessage();<br>    &#125;<br><br>    <span class="hljs-comment">// TODO give user ability to provide custom OutputParser</span><br>    Type returnType = method.getGenericReturnType();<br><br>    <span class="hljs-keyword">boolean</span> streaming = returnType == TokenStream.class || canAdaptTokenStreamTo(returnType);<br><br>    <span class="hljs-keyword">boolean</span> supportsJsonSchema =<br>            supportsJsonSchema(); <span class="hljs-comment">// TODO should it be called for returnType==String?</span><br>    Optional&lt;JsonSchema&gt; jsonSchema = Optional.empty();<br>    <span class="hljs-keyword">if</span> (supportsJsonSchema &amp;&amp; !streaming) &#123;<br>        jsonSchema = jsonSchemaFrom(returnType);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> ((!supportsJsonSchema || jsonSchema.isEmpty()) &amp;&amp; !streaming) &#123;<br>        <span class="hljs-comment">// TODO append after storing in the memory?</span><br>        userMessage = appendOutputFormatInstructions(returnType, userMessage);<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (context.hasChatMemory()) &#123;<br>        ChatMemory chatMemory = context.chatMemory(memoryId);<br>        systemMessage.ifPresent(chatMemory::add);<br>        chatMemory.add(userMessage);<br>    &#125;<br><br>    List&lt;ChatMessage&gt; messages;<br>    <span class="hljs-keyword">if</span> (context.hasChatMemory()) &#123;<br>        messages = context.chatMemory(memoryId).messages();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        messages = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        systemMessage.ifPresent(messages::add);<br>        messages.add(userMessage);<br>    &#125;<br><br>    Future&lt;Moderation&gt; moderationFuture = triggerModerationIfNeeded(method, messages);<br><br>    ToolExecutionContext toolExecutionContext =<br>            context.toolService.executionContext(memoryId, userMessage);<br><br>    <span class="hljs-keyword">if</span> (streaming) &#123;<br>        TokenStream tokenStream = <span class="hljs-keyword">new</span> AiServiceTokenStream(<br>                messages,<br>                toolExecutionContext.toolSpecifications(),<br>                toolExecutionContext.toolExecutors(),<br>                augmentationResult != <span class="hljs-keyword">null</span> ? augmentationResult.contents() : <span class="hljs-keyword">null</span>,<br>                context,<br>                memoryId);<br>        <span class="hljs-comment">// TODO moderation</span><br>        <span class="hljs-keyword">if</span> (returnType == TokenStream.class) &#123;<br>            <span class="hljs-keyword">return</span> tokenStream;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> adapt(tokenStream, returnType);<br>        &#125;<br>    &#125;<br><br>    ResponseFormat responseFormat = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">if</span> (supportsJsonSchema &amp;&amp; jsonSchema.isPresent()) &#123;<br>        responseFormat = ResponseFormat.builder()<br>                .type(JSON)<br>                .jsonSchema(jsonSchema.get())<br>                .build();<br>    &#125;<br><br>    ChatRequestParameters parameters = ChatRequestParameters.builder()<br>            .toolSpecifications(toolExecutionContext.toolSpecifications())<br>            .responseFormat(responseFormat)<br>            .build();<br><br>    ChatRequest chatRequest = ChatRequest.builder()<br>            .messages(messages)<br>            .parameters(parameters)<br>            .build();<br><br>    ChatResponse chatResponse = context.chatModel.chat(chatRequest);<br><br>    verifyModerationIfNeeded(moderationFuture);<br><br>    ToolExecutionResult toolExecutionResult = context.toolService.executeInferenceAndToolsLoop(<br>            chatResponse,<br>            parameters,<br>            messages,<br>            context.chatModel,<br>            context.hasChatMemory() ? context.chatMemory(memoryId) : <span class="hljs-keyword">null</span>,<br>            memoryId,<br>            toolExecutionContext.toolExecutors());<br><br>    chatResponse = toolExecutionResult.chatResponse();<br>    FinishReason finishReason = chatResponse.metadata().finishReason();<br>    Response&lt;AiMessage&gt; response = Response.from(<br>            chatResponse.aiMessage(), toolExecutionResult.tokenUsageAccumulator(), finishReason);<br><br>    Object parsedResponse = serviceOutputParser.parse(response, returnType);<br>    <span class="hljs-keyword">if</span> (typeHasRawClass(returnType, Result.class)) &#123;<br>        <span class="hljs-keyword">return</span> Result.builder()<br>                .content(parsedResponse)<br>                .tokenUsage(toolExecutionResult.tokenUsageAccumulator())<br>                .sources(augmentationResult == <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">null</span> : augmentationResult.contents())<br>                .finishReason(finishReason)<br>                .toolExecutions(toolExecutionResult.toolExecutions())<br>                .build();<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">return</span> parsedResponse;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>LangChain4j</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LangChain——房产销售聊天机器人</title>
    <link href="/2024/09/24/LangChain%E2%80%94%E2%80%94%E5%AE%9E%E6%88%98%EF%BC%9A%E6%88%BF%E4%BA%A7%E9%94%80%E5%94%AE%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/"/>
    <url>/2024/09/24/LangChain%E2%80%94%E2%80%94%E5%AE%9E%E6%88%98%EF%BC%9A%E6%88%BF%E4%BA%A7%E9%94%80%E5%94%AE%E8%81%8A%E5%A4%A9%E6%9C%BA%E5%99%A8%E4%BA%BA/</url>
    
    <content type="html"><![CDATA[<p>　　<strong>整体架构</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409242205916.png" style="zoom:50%;" /></p><h3 id="构造数据">1. 构造数据</h3><p>　　使用 GPT-4 构造销售话术数据</p><p>　　ChatGPT分享链接：https://chat.openai.com/share/f3e4b9b0-95fb-4c6a-a3c7-f901dd194c91</p><p>　　使用 ChatGPT 构造销售数据的 Prompt 示例：</p><figure class="highlight angelscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs angelscript">你是中国顶级的房地产销售，现在培训职场新人，请给出<span class="hljs-number">100</span>条实用的销售话术。<br><br>每条销售话术以如下格式给出：<br><span class="hljs-string">[客户问题]</span><br><span class="hljs-string">[销售回答]</span><br></code></pre></td></tr></table></figure><p>　　GPT-4 回复结果：</p><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs prolog">在房地产销售行业中，精心准备的销售话术可以极大地提高成交率。以下是一些适用于中国房地产销售的实用话术：<br><br><span class="hljs-number">1.</span>  <br>[客户问题] 这个小区交通便利吗？<br>[销售回答] 当然了，这个小区距离地铁站只有几分钟的步行距离，而且附近有多条公交线路，非常方便。<br><br><span class="hljs-number">2.</span>  <br>[客户问题] 我担心楼下太吵。<br>[销售回答] 这个小区特别注重居住体验，我们有良好的隔音设计，并且小区内部规划了绿化区域，可以有效降低噪音。<br><br><span class="hljs-number">3.</span>  <br>[客户问题] 我看房价还在涨，这个投资回报怎么样？<br>[销售回答] 这个区域未来有大量的商业和基础设施建设，所以从长期来看，投资回报非常有保证。<br><br>.....<br></code></pre></td></tr></table></figure><h3 id="数据处理">2. 数据处理</h3><p>　　使用 Document Transformers 模块来处理原始数据。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&quot;real_estate_sales_data.txt&quot;</span>) <span class="hljs-keyword">as</span> f:<br>    real_estate_sales = f.read()<br><br>text_splitter = CharacterTextSplitter(<br>    separator=<span class="hljs-string">r&#x27;\d+\.&#x27;</span>,<br>    chunk_size=<span class="hljs-number">100</span>,<br>    chunk_overlap=<span class="hljs-number">0</span>,<br>    length_function=<span class="hljs-built_in">len</span>,<br>    is_separator_regex=<span class="hljs-literal">True</span>,<br>)<br>docs = text_splitter.create_documents([real_estate_sales])<br></code></pre></td></tr></table></figure><h3 id="持久化">3. 持久化</h3><p>　　使用 Faiss作为向量数据库，持久化存储房产销售问答对（QA-Pair）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">db = FAISS.from_documents(docs, OpenAIEmbeddings())<br><br>db.save_local(<span class="hljs-string">&quot;real_estates_sale&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="查询结果">4. 查询结果</h3><p>　　使用 retriever 从向量数据库中获取结果</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">query = <span class="hljs-string">&quot;小区吵不吵&quot;</span><br>answer_list = db.similarity_search(query)<br><span class="hljs-keyword">for</span> ans <span class="hljs-keyword">in</span> answer_list:<br>    <span class="hljs-built_in">print</span>(ans.page_content + <span class="hljs-string">&quot;\n&quot;</span>)<br><br><span class="hljs-comment"># 指定返回结果数量</span><br>topK_retriever = db.as_retriever(search_kwargs=&#123;<span class="hljs-string">&quot;k&quot;</span>: <span class="hljs-number">3</span>&#125;)<br>docs = topK_retriever.get_relevant_documents(query)<br><span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> docs:<br>    <span class="hljs-built_in">print</span>(doc.page_content + <span class="hljs-string">&quot;\n&quot;</span>)<br><br><span class="hljs-comment"># 设置阈值，提升结果的相关性质量</span><br>retriever = db.as_retriever(search_type=<span class="hljs-string">&quot;similarity_score_threshold&quot;</span>, search_kwargs=&#123;<span class="hljs-string">&quot;score_threshold&quot;</span>: <span class="hljs-number">0.8</span>&#125;)<br>docs = retriever.get_relevant_documents(query)<br><span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> docs:<br>    <span class="hljs-built_in">print</span>(doc.page_content + <span class="hljs-string">&quot;\n&quot;</span>)<br></code></pre></td></tr></table></figure><h3 id="整合大语言模型能力">5. 整合大语言模型能力</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">llm = ChatOpenAI(model_name=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>, temperature=<span class="hljs-number">0.5</span>)<br>qa_chain = RetrievalQA.from_chain_type(llm,<br>                                       retriever=db.as_retriever(search_type=<span class="hljs-string">&quot;similarity_score_threshold&quot;</span>,<br>                                                                 search_kwargs=&#123;<span class="hljs-string">&quot;score_threshold&quot;</span>: <span class="hljs-number">0.8</span>&#125;))<br><span class="hljs-built_in">print</span>(qa_chain(&#123;<span class="hljs-string">&quot;query&quot;</span>: <span class="hljs-string">&quot;小区吵不吵&quot;</span>&#125;))<br></code></pre></td></tr></table></figure><h3 id="服务化">6. 服务化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> gradio <span class="hljs-keyword">as</span> gr<br><br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> OpenAIEmbeddings<br><span class="hljs-keyword">from</span> langchain.chains <span class="hljs-keyword">import</span> RetrievalQA<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI<br><span class="hljs-keyword">from</span> langchain_community.vectorstores <span class="hljs-keyword">import</span> FAISS<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">initialize_sales_bot</span>(<span class="hljs-params">vector_store_dir: <span class="hljs-built_in">str</span> = <span class="hljs-string">&quot;real_estates_sale&quot;</span></span>):</span><br>    db = FAISS.load_local(vector_store_dir, OpenAIEmbeddings(), allow_dangerous_deserialization=<span class="hljs-literal">True</span>)<br>    llm = ChatOpenAI(model_name=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>, temperature=<span class="hljs-number">0</span>)<br><br>    <span class="hljs-keyword">global</span> SALES_BOT<br>    SALES_BOT = RetrievalQA.from_chain_type(<br>        llm,<br>        retriever=db.as_retriever(search_type=<span class="hljs-string">&quot;similarity_score_threshold&quot;</span>, search_kwargs=&#123;<span class="hljs-string">&quot;score_threshold&quot;</span>: <span class="hljs-number">0.8</span>&#125;)<br>    )<br>    <span class="hljs-comment"># 返回向量数据库的检索结果</span><br>    SALES_BOT.return_source_documents = <span class="hljs-literal">True</span><br><br>    <span class="hljs-keyword">return</span> SALES_BOT<br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">sales_chat</span>(<span class="hljs-params">message, history</span>):</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[message]<span class="hljs-subst">&#123;message&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[history]<span class="hljs-subst">&#123;history&#125;</span>&quot;</span>)<br>    <span class="hljs-comment"># <span class="hljs-doctag">TODO:</span> 从命令行参数中获取</span><br>    enable_chat = <span class="hljs-literal">True</span><br><br>    ans = SALES_BOT(&#123;<span class="hljs-string">&quot;query&quot;</span>: message&#125;)<br>    <span class="hljs-comment"># 如果检索出结果，或者开了大模型聊天模式</span><br>    <span class="hljs-comment"># 返回 RetrievalQA combine_documents_chain 整合的结果</span><br>    <span class="hljs-keyword">if</span> ans[<span class="hljs-string">&quot;source_documents&quot;</span>] <span class="hljs-keyword">or</span> enable_chat:<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[result]<span class="hljs-subst">&#123;ans[<span class="hljs-string">&#x27;result&#x27;</span>]&#125;</span>&quot;</span>)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;[source_documents]<span class="hljs-subst">&#123;ans[<span class="hljs-string">&#x27;source_documents&#x27;</span>]&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">return</span> ans[<span class="hljs-string">&quot;result&quot;</span>]<br>    <span class="hljs-comment"># 否则输出套路话术</span><br>    <span class="hljs-keyword">else</span>:<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;这个问题我要问问领导&quot;</span><br><br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">launch_gradio</span>():</span><br>    demo = gr.ChatInterface(<br>        fn=sales_chat,<br>        title=<span class="hljs-string">&quot;房产销售&quot;</span>,<br>        <span class="hljs-comment"># retry_btn=None,</span><br>        <span class="hljs-comment"># undo_btn=None,</span><br>        chatbot=gr.Chatbot(height=<span class="hljs-number">600</span>),<br>    )<br><br>    demo.launch(share=<span class="hljs-literal">True</span>, server_name=<span class="hljs-string">&quot;0.0.0.0&quot;</span>)<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-comment"># 初始化房产销售机器人</span><br>    initialize_sales_bot()<br>    <span class="hljs-comment"># 启动 Gradio 服务</span><br>    launch_gradio()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>LangChain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LangChain——Agent</title>
    <link href="/2024/09/14/LangChain%E2%80%94%E2%80%94Agent/"/>
    <url>/2024/09/14/LangChain%E2%80%94%E2%80%94Agent/</url>
    
    <content type="html"><![CDATA[<h3 id="agent">1. Agent</h3><p>　　OpenAI应用研究主管LilianWeng写的<ahref="https://lilianweng.github.io/posts/2023-06-23-agent/">LLM PoweredAutonomous Agents</a>把人工智能代理(AIAgent)分成了以下3个部分：规划模块，工具调用模块和记忆模块</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409141156281.png" style="zoom:30%;" /></p><ol type="1"><li>规划：如何对问题进行拆解得到解决路径，既模型推理步骤</li><li>工具：支持哪些工具使用，如何进行工具选择，并生成调用工具的请求</li><li>记忆：短期记忆包括工具的返回值，已经完成的推理路径，长期记忆包括可访问的外部长期存储例如知识库</li></ol><p><strong>LangChain Agents 设计原理：</strong></p><p>代理的核心思想是使用 LLM 来选择一系列要执行的动作。</p><ul><li>在链式结构（Chains）中，一系列动作执行是硬编码的（ SequentialChain和 RouterChain 也仅实现了面向过程）。</li><li>在代理（Agents）中，语言模型被用作推理引擎，以确定应该采取哪些动作以及执行顺序</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409141545871.png" style="zoom:40%;" /></p><h3 id="self-ask">2. Self Ask</h3><h4 id="原理">2.1 原理</h4><blockquote><p>measuring and narrowing the compositionality gap in languagemodels</p><p>https://ofir.io/Self-ask-prompting/</p></blockquote><p>　　SelfAsk提出了一种把问题拆解成子问题的Prompt范式，每一步模型都会<strong>自我提问</strong>是否可以把问题改写/拆解成一个简单的子问题，并进行回答，回答时可以调用搜索工具来获得答案，然后根据工具返回结果，继续进行自我提问，直到获得最终答案。其实自我提问的推理形式并不是核心，核心是引导模型来进行问题拆解，也就是开头提到的规划能力。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409141552817.png" style="zoom:35%;" /></p><h4 id="langchain-实现">2.2 Langchain 实现：</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs python">model = ChatOpenAI(model=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>)<br>search = TavilySearchResults(max_results=<span class="hljs-number">1</span>)<br>tools = [<br>    Tool(<br>        name=<span class="hljs-string">&quot;Intermediate Answer&quot;</span>,<br>        func=search.run,<br>        description=<span class="hljs-string">&quot;useful for when you need to ask with search&quot;</span><br>    )<br>]<br><br>agent = initialize_agent(tools, model, agent=AgentType.SELF_ASK_WITH_SEARCH,<br>                         handle_parsing_errors=<span class="hljs-literal">True</span>,<br>                         verbose=<span class="hljs-literal">True</span>)<br>result = agent(<span class="hljs-string">&quot;Who is the CEO of Tesla&quot;</span>)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> Entering new AgentExecutor chain...</span><br>Could not parse output: No.<br>Intermediate answer: Invalid or incomplete response<br>Follow up: What is the full name of the CEO of Tesla?<br>Intermediate answer: [&#123;&#x27;url&#x27;: &#x27;https://www.bloomberg.com/profile/person/1954518&#x27;, &#x27;content&#x27;: &quot;Elon Reeve Musk is Chief Executive Officer/Co-Founder at Tesla Inc. See Elon Reeve Musk&#x27;s compensation, career history, education, &amp; memberships.&quot;&#125;]<br>So the final answer is: Elon Reeve Musk<br><span class="hljs-meta"></span><br><span class="hljs-meta">&gt;</span><span class="bash"> Finished chain.</span><br>&#123;&#x27;input&#x27;: &#x27;Who is the CEO of Tesla&#x27;, &#x27;output&#x27;: &#x27;Elon Reeve Musk&#x27;&#125;<br></code></pre></td></tr></table></figure><h3 id="react">3. ReAct</h3><h4 id="原理-1">3.1 原理</h4><blockquote><p>ReAct: synergizing reasoning and acting in language modelshttps://tsmatz.wordpress.com/2023/03/07/react-with-openai-gpt-and-langchain/</p></blockquote><p>　　ReAct 文如其名，模型推理分成了两个部分，Reason和Action。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409141538461.png" style="zoom:50%;" /></p><p>　　Reason 生成分析步骤，Action生成工具调用请求，二者交替进行直到得到最终的结果。和 Self Ask对比，ReAct 进一步把推理和工具调用进行了解耦, 在 Self Ask中，自我提问既是推理步骤也是搜索工具的请求 query，而在 ReAct中工具调用的请求在推理步骤之后，这样可以更好的支持搜索以外的其他工具。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409141541825.png" style="zoom:45%;" /></p><h4 id="langchain-实现-1">3.2 Langchain 实现</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    model = ChatOpenAI(model=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>)<br>    tools = load_tools([<span class="hljs-string">&quot;llm-math&quot;</span>], llm=model)<br>    search = TavilySearchResults(max_results=<span class="hljs-number">1</span>)<br>    tools.append(search)<br><br>    agent = initialize_agent(tools, model, agent=AgentType.CHAT_ZERO_SHOT_REACT_DESCRIPTION,<br>                             handle_parsing_errors=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 处理出错设置为True可以有效规避莫名bug</span><br>                             verbose=<span class="hljs-literal">True</span>)  <span class="hljs-comment"># 开启日志打印</span><br>    resp = agent(<span class="hljs-string">&quot;What is the 25% of 300?&quot;</span>)<br>    <span class="hljs-built_in">print</span>(resp)<br>    result = agent(<span class="hljs-string">&quot;Who is the CEO of Tesla&quot;</span>)<br>    <span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p><strong>执行输出：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">&gt;</span><span class="bash"> Entering new AgentExecutor chain...</span><br>I can use the calculator tool to find the answer to this math problem.<br><br>Action:<br>```<br>&#123;<br>  &quot;action&quot;: &quot;Calculator&quot;,<br>  &quot;action_input&quot;: &quot;300 * 0.25&quot;<br>&#125;<br>```<br>Observation: Answer: 75.0<br>Thought:Could not parse LLM output: I now know the final answer.<br>Observation: Invalid or incomplete response<br>Thought:I made a mistake in my previous observation. I apologize for that. The correct answer is 75.0.<br><br>Final Answer: The 25% of 300 is 75.0.<br><span class="hljs-meta"></span><br><span class="hljs-meta">&gt;</span><span class="bash"> Finished chain.</span><br>&#123;&#x27;input&#x27;: &#x27;What is the 25% of 300?&#x27;, &#x27;output&#x27;: &#x27;The 25% of 300 is 75.0.&#x27;&#125;<br><span class="hljs-meta"></span><br><span class="hljs-meta"></span><br><span class="hljs-meta">&gt;</span><span class="bash"> Entering new AgentExecutor chain...</span><br>Could not parse LLM output: I don&#x27;t have that information readily available. Let me search the web for you.<br>Observation: Invalid or incomplete response<br>Thought:Could not parse LLM output: I need to use the search tool to find the answer to the question &quot;Who is the CEO of Tesla?&quot;<br>Observation: Invalid or incomplete response<br>Thought:Could not parse LLM output: I need to use the search tool to find the answer to the question &quot;Who is the CEO of Tesla?&quot;<br>Observation: Invalid or incomplete response<br>Thought:I need to use the search tool to find the answer to the question &quot;Who is the CEO of Tesla?&quot;<br>Action:<br>```<br>&#123;<br>  &quot;action&quot;: &quot;tavily_search_results_json&quot;,<br>  &quot;action_input&quot;: &quot;Who is the CEO of Tesla&quot;<br>&#125;<br>```<br>Observation: [&#123;&#x27;url&#x27;: &#x27;https://www.tesla.com/elon-musk&#x27;, &#x27;content&#x27;: &#x27;Elon Musk is the co-founder and CEO of Tesla, a company that produces electric vehicles, battery products and solar energy products. He also leads SpaceX, Neuralink and The Boring Company, and has a vision of making humans a multi-planet species.&#x27;&#125;]<br>Thought:The CEO of Tesla is Elon Musk.<br>Final Answer: Elon Musk is the CEO of Tesla.<br><span class="hljs-meta"></span><br><span class="hljs-meta">&gt;</span><span class="bash"> Finished chain.</span><br>&#123;&#x27;input&#x27;: &#x27;Who is the CEO of Tesla&#x27;, &#x27;output&#x27;: &#x27;Elon Musk is the CEO of Tesla.&#x27;&#125;<br></code></pre></td></tr></table></figure><h5 id="tavily">1. tavily</h5><p>　　<a href="https://tavily.com/">Tavily's Search API</a> is a searchengine built specifically for AI agents (LLMs), delivering real-time,accurate, and factual results at speed.</p><p>　　<ahref="https://python.langchain.com/v0.2/docs/integrations/tools/tavily_search/">LangChaintavily</a></p><figure class="highlight py"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs py">os.environ[<span class="hljs-string">&quot;TAVILY_API_KEY&quot;</span>] = <span class="hljs-string">&quot;xxx&quot;</span><br></code></pre></td></tr></table></figure><h5 id="streaming-messages">2. Streaming Messages</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    model = ChatOpenAI(model=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>)<br>    search = TavilySearchResults(max_results=<span class="hljs-number">1</span>)<br>    tools = [search]<br>    agent = initialize_agent(tools, model, agent=AgentType.CHAT_ZERO_SHOT_REACT_DESCRIPTION,<br>                             handle_parsing_errors=<span class="hljs-literal">True</span>,<br>                             verbose=<span class="hljs-literal">False</span>)<br><br>    <span class="hljs-keyword">for</span> chunk <span class="hljs-keyword">in</span> agent.stream(<span class="hljs-built_in">input</span>=<span class="hljs-string">&quot;北京今天天气怎么样&quot;</span>):<br>        <span class="hljs-built_in">print</span>(chunk)<br>        <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;----&quot;</span>)<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs shell">&#123;&#x27;actions&#x27;: [AgentAction(tool=&#x27;tavily_search_results_json&#x27;, tool_input=&#x27;Beijing current weather&#x27;, log=&#x27;Thought: I need to use the search engine tool to find the current weather in Beijing.\n\nAction:\n```\n&#123;\n  &quot;action&quot;: &quot;tavily_search_results_json&quot;,\n  &quot;action_input&quot;: &quot;Beijing current weather&quot;\n&#125;\n```&#x27;)], &#x27;messages&#x27;: [AIMessage(content=&#x27;Thought: I need to use the search engine tool to find the current weather in Beijing.\n\nAction:\n```\n&#123;\n  &quot;action&quot;: &quot;tavily_search_results_json&quot;,\n  &quot;action_input&quot;: &quot;Beijing current weather&quot;\n&#125;\n```&#x27;)]&#125;<br>----<br>&#123;&#x27;steps&#x27;: [AgentStep(action=AgentAction(tool=&#x27;tavily_search_results_json&#x27;, tool_input=&#x27;Beijing current weather&#x27;, log=&#x27;Thought: I need to use the search engine tool to find the current weather in Beijing.\n\nAction:\n```\n&#123;\n  &quot;action&quot;: &quot;tavily_search_results_json&quot;,\n  &quot;action_input&quot;: &quot;Beijing current weather&quot;\n&#125;\n```&#x27;), observation=[&#123;&#x27;url&#x27;: &#x27;https://www.weatherapi.com/&#x27;, &#x27;content&#x27;: &quot;&#123;&#x27;location&#x27;: &#123;&#x27;name&#x27;: &#x27;Beijing&#x27;, &#x27;region&#x27;: &#x27;Beijing&#x27;, &#x27;country&#x27;: &#x27;China&#x27;, &#x27;lat&#x27;: 39.93, &#x27;lon&#x27;: 116.39, &#x27;tz_id&#x27;: &#x27;Asia/Shanghai&#x27;, &#x27;localtime_epoch&#x27;: 1724851989, &#x27;localtime&#x27;: &#x27;2024-08-28 21:33&#x27;&#125;, &#x27;current&#x27;: &#123;&#x27;last_updated_epoch&#x27;: 1724851800, &#x27;last_updated&#x27;: &#x27;2024-08-28 21:30&#x27;, &#x27;temp_c&#x27;: 22.0, &#x27;temp_f&#x27;: 71.6, &#x27;is_day&#x27;: 0, &#x27;condition&#x27;: &#123;&#x27;text&#x27;: &#x27;Clear&#x27;, &#x27;icon&#x27;: &#x27;//cdn.weatherapi.com/weather/64x64/night/113.png&#x27;, &#x27;code&#x27;: 1000&#125;, &#x27;wind_mph&#x27;: 2.2, &#x27;wind_kph&#x27;: 3.6, &#x27;wind_degree&#x27;: 199, &#x27;wind_dir&#x27;: &#x27;SSW&#x27;, &#x27;pressure_mb&#x27;: 1010.0, &#x27;pressure_in&#x27;: 29.83, &#x27;precip_mm&#x27;: 0.0, &#x27;precip_in&#x27;: 0.0, &#x27;humidity&#x27;: 88, &#x27;cloud&#x27;: 0, &#x27;feelslike_c&#x27;: 24.5, &#x27;feelslike_f&#x27;: 76.2, &#x27;windchill_c&#x27;: 23.5, &#x27;windchill_f&#x27;: 74.2, &#x27;heatindex_c&#x27;: 25.3, &#x27;heatindex_f&#x27;: 77.6, &#x27;dewpoint_c&#x27;: 18.8, &#x27;dewpoint_f&#x27;: 65.8, &#x27;vis_km&#x27;: 10.0, &#x27;vis_miles&#x27;: 6.0, &#x27;uv&#x27;: 1.0, &#x27;gust_mph&#x27;: 7.2, &#x27;gust_kph&#x27;: 11.6&#125;&#125;&quot;&#125;])], &#x27;messages&#x27;: [HumanMessage(content=[&#123;&#x27;url&#x27;: &#x27;https://www.weatherapi.com/&#x27;, &#x27;content&#x27;: &quot;&#123;&#x27;location&#x27;: &#123;&#x27;name&#x27;: &#x27;Beijing&#x27;, &#x27;region&#x27;: &#x27;Beijing&#x27;, &#x27;country&#x27;: &#x27;China&#x27;, &#x27;lat&#x27;: 39.93, &#x27;lon&#x27;: 116.39, &#x27;tz_id&#x27;: &#x27;Asia/Shanghai&#x27;, &#x27;localtime_epoch&#x27;: 1724851989, &#x27;localtime&#x27;: &#x27;2024-08-28 21:33&#x27;&#125;, &#x27;current&#x27;: &#123;&#x27;last_updated_epoch&#x27;: 1724851800, &#x27;last_updated&#x27;: &#x27;2024-08-28 21:30&#x27;, &#x27;temp_c&#x27;: 22.0, &#x27;temp_f&#x27;: 71.6, &#x27;is_day&#x27;: 0, &#x27;condition&#x27;: &#123;&#x27;text&#x27;: &#x27;Clear&#x27;, &#x27;icon&#x27;: &#x27;//cdn.weatherapi.com/weather/64x64/night/113.png&#x27;, &#x27;code&#x27;: 1000&#125;, &#x27;wind_mph&#x27;: 2.2, &#x27;wind_kph&#x27;: 3.6, &#x27;wind_degree&#x27;: 199, &#x27;wind_dir&#x27;: &#x27;SSW&#x27;, &#x27;pressure_mb&#x27;: 1010.0, &#x27;pressure_in&#x27;: 29.83, &#x27;precip_mm&#x27;: 0.0, &#x27;precip_in&#x27;: 0.0, &#x27;humidity&#x27;: 88, &#x27;cloud&#x27;: 0, &#x27;feelslike_c&#x27;: 24.5, &#x27;feelslike_f&#x27;: 76.2, &#x27;windchill_c&#x27;: 23.5, &#x27;windchill_f&#x27;: 74.2, &#x27;heatindex_c&#x27;: 25.3, &#x27;heatindex_f&#x27;: 77.6, &#x27;dewpoint_c&#x27;: 18.8, &#x27;dewpoint_f&#x27;: 65.8, &#x27;vis_km&#x27;: 10.0, &#x27;vis_miles&#x27;: 6.0, &#x27;uv&#x27;: 1.0, &#x27;gust_mph&#x27;: 7.2, &#x27;gust_kph&#x27;: 11.6&#125;&#125;&quot;&#125;])]&#125;<br>----<br>&#123;&#x27;output&#x27;: &#x27;The current weather in Beijing is clear with a temperature of 22.0°C (71.6°F).&#x27;, &#x27;messages&#x27;: [AIMessage(content=&#x27;The search results show the current weather in Beijing.\nFinal Answer: The current weather in Beijing is clear with a temperature of 22.0°C (71.6°F).&#x27;)]&#125;<br>----<br></code></pre></td></tr></table></figure><h5 id="streaming-tokens">3. Streaming tokens</h5><p>　　In addition to streaming back messages, it is also useful to bestreaming back tokens. We can do this with the<code>.astream_events</code> method.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_function_tools</span>():</span><br>    model = ChatOpenAI(model=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>)<br>    search = TavilySearchResults(max_results=<span class="hljs-number">1</span>)<br>    tools = [search]<br>    agent = initialize_agent(tools, model, agent=AgentType.CHAT_ZERO_SHOT_REACT_DESCRIPTION,<br>                             handle_parsing_errors=<span class="hljs-literal">True</span>,  <span class="hljs-comment"># 处理出错设置为True可以有效规避莫名bug</span><br>                             verbose=<span class="hljs-literal">False</span>)  <span class="hljs-comment"># 开启日志打印</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-keyword">for</span> event <span class="hljs-keyword">in</span> agent.astream_events(<span class="hljs-string">&quot;北京今天天气怎么样&quot;</span>, version=<span class="hljs-string">&quot;v1&quot;</span>):<br>        kind = event[<span class="hljs-string">&quot;event&quot;</span>]<br>        eventName = event[<span class="hljs-string">&quot;name&quot;</span>]<br>        <span class="hljs-keyword">if</span> kind == <span class="hljs-string">&quot;on_chain_start&quot;</span>:<br>            <span class="hljs-keyword">if</span> eventName == <span class="hljs-string">&quot;Agent&quot;</span>:<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Starting agent: <span class="hljs-subst">&#123;event[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span> with input: <span class="hljs-subst">&#123;event[<span class="hljs-string">&#x27;data&#x27;</span>].get(<span class="hljs-string">&#x27;input&#x27;</span>)&#125;</span>&quot;</span>)<br>        <span class="hljs-keyword">elif</span> kind == <span class="hljs-string">&quot;on_chain_end&quot;</span>:<br>            <span class="hljs-keyword">if</span> eventName == <span class="hljs-string">&quot;Agent&quot;</span>:  <span class="hljs-comment"># Was assigned when creating the agent with `.with_config(&#123;&quot;run_name&quot;: &quot;Agent&quot;&#125;)`</span><br>                <span class="hljs-built_in">print</span>()<br>                <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--&quot;</span>)<br>                <span class="hljs-built_in">print</span>(<br>                    <span class="hljs-string">f&quot;Done agent: <span class="hljs-subst">&#123;event[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span> with output: <span class="hljs-subst">&#123;event[<span class="hljs-string">&#x27;data&#x27;</span>].get(<span class="hljs-string">&#x27;output&#x27;</span>)[<span class="hljs-string">&#x27;output&#x27;</span>]&#125;</span>&quot;</span><br>                )<br>        <span class="hljs-keyword">if</span> kind == <span class="hljs-string">&quot;on_chat_model_stream&quot;</span>:<br>            content = event[<span class="hljs-string">&quot;data&quot;</span>][<span class="hljs-string">&quot;chunk&quot;</span>].content<br>            <span class="hljs-keyword">if</span> content:<br>                <span class="hljs-built_in">print</span>(content, end=<span class="hljs-string">&quot;|&quot;</span>)<br>        <span class="hljs-keyword">elif</span> kind == <span class="hljs-string">&quot;on_tool_start&quot;</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<br>                <span class="hljs-string">f&quot;Starting tool: <span class="hljs-subst">&#123;event[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span> with inputs: <span class="hljs-subst">&#123;event[<span class="hljs-string">&#x27;data&#x27;</span>].get(<span class="hljs-string">&#x27;input&#x27;</span>)&#125;</span>&quot;</span><br>            )<br>        <span class="hljs-keyword">elif</span> kind == <span class="hljs-string">&quot;on_tool_end&quot;</span>:<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Done tool: <span class="hljs-subst">&#123;event[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span>&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Tool output was: <span class="hljs-subst">&#123;event[<span class="hljs-string">&#x27;data&#x27;</span>].get(<span class="hljs-string">&#x27;output&#x27;</span>)&#125;</span>&quot;</span>)<br>            <span class="hljs-built_in">print</span>(<span class="hljs-string">&quot;--&quot;</span>)<br>            <br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    asyncio.run(get_function_tools())<br></code></pre></td></tr></table></figure><p><strong>输出：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell">Thought|:| I| need| to| use| the| search| engine| tool| to| find| the| current| weather| in| Beijing|.<br>|Action|:<br>|``|`<br>|&#123;<br>| | &quot;|action|&quot;:| &quot;|t|av|ily|_search|_results|_json|&quot;,<br>| | &quot;|action|_input|&quot;:| &quot;|Be|ijing| current| weather|&quot;<br>|&#125;<br>|```|--<br>Starting tool: tavily_search_results_json with inputs: None<br>Done tool: tavily_search_results_json<br>Tool output was: [&#123;&#x27;url&#x27;: &#x27;https://www.weatherapi.com/&#x27;, &#x27;content&#x27;: &quot;&#123;&#x27;location&#x27;: &#123;&#x27;name&#x27;: &#x27;Beijing&#x27;, &#x27;region&#x27;: &#x27;Beijing&#x27;, &#x27;country&#x27;: &#x27;China&#x27;, &#x27;lat&#x27;: 39.93, &#x27;lon&#x27;: 116.39, &#x27;tz_id&#x27;: &#x27;Asia/Shanghai&#x27;, &#x27;localtime_epoch&#x27;: 1724852408, &#x27;localtime&#x27;: &#x27;2024-08-28 21:40&#x27;&#125;, &#x27;current&#x27;: &#123;&#x27;last_updated_epoch&#x27;: 1724851800, &#x27;last_updated&#x27;: &#x27;2024-08-28 21:30&#x27;, &#x27;temp_c&#x27;: 22.0, &#x27;temp_f&#x27;: 71.6, &#x27;is_day&#x27;: 0, &#x27;condition&#x27;: &#123;&#x27;text&#x27;: &#x27;Clear&#x27;, &#x27;icon&#x27;: &#x27;//cdn.weatherapi.com/weather/64x64/night/113.png&#x27;, &#x27;code&#x27;: 1000&#125;, &#x27;wind_mph&#x27;: 2.2, &#x27;wind_kph&#x27;: 3.6, &#x27;wind_degree&#x27;: 199, &#x27;wind_dir&#x27;: &#x27;SSW&#x27;, &#x27;pressure_mb&#x27;: 1010.0, &#x27;pressure_in&#x27;: 29.83, &#x27;precip_mm&#x27;: 0.0, &#x27;precip_in&#x27;: 0.0, &#x27;humidity&#x27;: 88, &#x27;cloud&#x27;: 0, &#x27;feelslike_c&#x27;: 24.5, &#x27;feelslike_f&#x27;: 76.2, &#x27;windchill_c&#x27;: 23.5, &#x27;windchill_f&#x27;: 74.2, &#x27;heatindex_c&#x27;: 25.3, &#x27;heatindex_f&#x27;: 77.6, &#x27;dewpoint_c&#x27;: 18.8, &#x27;dewpoint_f&#x27;: 65.8, &#x27;vis_km&#x27;: 10.0, &#x27;vis_miles&#x27;: 6.0, &#x27;uv&#x27;: 1.0, &#x27;gust_mph&#x27;: 7.2, &#x27;gust_kph&#x27;: 11.6&#125;&#125;&quot;&#125;]<br>--<br>I| have| found| the| current| weather| in| Beijing|.<br>|Final| Answer|:| The| current| weather| in| Beijing| is| clear| with| a| temperature| of| |22|°C| (|71|.|6|°F|).|<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>LangChain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LangChain——Loaders、Splitters、embedding、Vector stores、Retrievers</title>
    <link href="/2024/09/10/LangChain%E2%80%94%E2%80%94Loaders%E3%80%81Splitters%E3%80%81embedding%E3%80%81Vector%20stores%E3%80%81Retrievers/"/>
    <url>/2024/09/10/LangChain%E2%80%94%E2%80%94Loaders%E3%80%81Splitters%E3%80%81embedding%E3%80%81Vector%20stores%E3%80%81Retrievers/</url>
    
    <content type="html"><![CDATA[<h3 id="document-loaders">1. Document Loaders</h3><p>　　使用文档加载器从源中加载数据作为文档。一个文档是一段文字和相关的元数据。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409101052724.png" style="zoom:40%;" /></p><p>例如，有用于加载简单 .txt 文件的文档加载器，用于加载 ArXiv论文，或者任何网页的文本内容</p><h4 id="baseloader-类定义">1. BaseLoader 类定义</h4><p>　　<code>BaseLoader</code>类定义了如何从不同的数据源加载文档，并提供了一个可选的方法来分割加载的文档。使用这个类作为基础，开发者可以为特定的数据源创建自定义的加载器，并确保所有这些加载器都提供了加载数据的方法。load_and_split方法还提供了一个额外的功能，可以根据需要将加载的文档分割为更小的块。</p><p>内置实现类：TextLoader、CSVLoader、JSONLoader、ArxivLoader、HuggingFaceDatasetLoader、UnstructuredPDFLoader、UnstructuredURLLoader.....</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs python">lass BaseLoader(ABC):<br>    <span class="hljs-string">&quot;&quot;&quot;Interface for Document Loader.</span><br><span class="hljs-string"></span><br><span class="hljs-string">    Implementations should implement the lazy-loading method using generators</span><br><span class="hljs-string">    to avoid loading all Documents into memory at once.</span><br><span class="hljs-string">    &quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">List</span>[Document]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;Load data into Document objects.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> <span class="hljs-built_in">list</span>(self.lazy_load())<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_and_split</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        self, text_splitter: <span class="hljs-type">Optional</span>[TextSplitter] = <span class="hljs-literal">None</span></span></span><br><span class="hljs-params"><span class="hljs-function">    </span>) -&gt; <span class="hljs-type">List</span>[Document]:</span><br>        <span class="hljs-keyword">if</span> text_splitter <span class="hljs-keyword">is</span> <span class="hljs-literal">None</span>:<br>            _text_splitter: TextSplitter = RecursiveCharacterTextSplitter()<br>        <span class="hljs-keyword">else</span>:<br>            _text_splitter = text_splitter<br>        docs = self.load()<br>        <span class="hljs-keyword">return</span> _text_splitter.split_documents(docs)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lazy_load</span>(<span class="hljs-params">self</span>) -&gt; Iterator[Document]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;A lazy loader for Documents.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> <span class="hljs-built_in">type</span>(self).load != BaseLoader.load:<br>            <span class="hljs-keyword">return</span> <span class="hljs-built_in">iter</span>(self.load())<br>        <span class="hljs-keyword">raise</span> NotImplementedError(<br>            <span class="hljs-string">f&quot;<span class="hljs-subst">&#123;self.__class__.__name__&#125;</span> does not implement lazy_load()&quot;</span><br>        )<br></code></pre></td></tr></table></figure><h4 id="使用-textloader-加载-txt-文件">2. 使用 TextLoader 加载 Txt文件</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain_community.document_loaders <span class="hljs-keyword">import</span> TextLoader<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    docs = TextLoader(<span class="hljs-string">&#x27;../../data/state_of_the_union.txt&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>).load()<br>    <span class="hljs-comment"># &lt;class &#x27;langchain_core.documents.base.Document&#x27;&gt;</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(docs[<span class="hljs-number">0</span>]))<br>    <span class="hljs-comment"># &#123;&#x27;source&#x27;: &#x27;../../data/state_of_the_union.txt&#x27;&#125;</span><br>    <span class="hljs-built_in">print</span>(docs[<span class="hljs-number">0</span>].metadata)<br>    <span class="hljs-built_in">print</span>(docs[<span class="hljs-number">0</span>].page_content)<br></code></pre></td></tr></table></figure><h4 id="使用-arxivloader-加载-arxiv-论文">3. 使用 ArxivLoader 加载 ArXiv论文</h4><p>　　<code>ArxivLoader</code>类专门用于从Arxiv平台获取文档。用户提供一个搜索查询，然后加载器与ArxivAPI交互，以检索与该查询相关的文档列表。这些文档然后以标准的Document格式返回。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ArxivLoader</span>(<span class="hljs-params">BaseLoader</span>):</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        self, query: <span class="hljs-built_in">str</span>, doc_content_chars_max: <span class="hljs-type">Optional</span>[<span class="hljs-built_in">int</span>] = <span class="hljs-literal">None</span>, **kwargs: <span class="hljs-type">Any</span></span></span><br><span class="hljs-params"><span class="hljs-function">    </span>):</span><br>        <span class="hljs-comment"># 传递给Arxiv API进行搜索的特定查询或关键字。</span><br>        self.query = query<br>        <span class="hljs-comment"># doc_content_chars_max 从搜索中检索文档的上限</span><br>        self.client = ArxivAPIWrapper(<br>            doc_content_chars_max=doc_content_chars_max, **kwargs<br>        )<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">lazy_load</span>(<span class="hljs-params">self</span>) -&gt; Iterator[Document]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;Lazy load Arvix documents&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">yield</span> <span class="hljs-keyword">from</span> self.client.lazy_load(self.query)<br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_summaries_as_docs</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">List</span>[Document]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;Uses papers summaries as documents rather than source Arvix papers&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">return</span> self.client.get_summaries_as_docs(self.query)<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># query = &quot;LLM&quot;</span><br><span class="hljs-comment"># https://arxiv.org/abs/2005.14165 GPT3 论文</span><br>query = <span class="hljs-string">&quot;2005.14165&quot;</span><br>docs = ArxivLoader(query=query, load_max_docs=<span class="hljs-number">5</span>).load()<br><span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(docs))<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409101200954.png" style="zoom:50%;" /></p><h4 id="使用-unstructuredurlloader-加载网页内容">4. 使用UnstructuredURLLoader 加载网页内容</h4><p>　　使用非结构化分区函数(Unstructured)来检测MIME类型并将文件路由到适当的分区器(partitioner)。</p><p>　　支持两种模式运行加载程序："single"和"elements"。如果使用"single"模式，文档将作为单个langchainDocument对象返回。如果使用"elements"模式，非结构化库将把文档拆分成标题和叙述文本等元素。您可以在mode后面传入其他非结构化kwargs以应用不同的非结构化设置。</p><p>　　UnstructuredURLLoader 主要参数：</p><ul><li>urls：待加载网页 URL 列表</li><li>continue_on_failure：默认<code>True</code>，某个URL加载失败后，是否继续</li><li>mode：默认<code>single</code>，</li></ul><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python">urls = [<span class="hljs-string">&quot;https://debuggingworld.github.io&quot;</span>]<br>loader = UnstructuredURLLoader(urls=urls)<br>data = loader.load()<br><span class="hljs-built_in">print</span>(data[<span class="hljs-number">0</span>].metadata)<br><span class="hljs-built_in">print</span>(data[<span class="hljs-number">0</span>].page_content)<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409101759907.png" style="zoom:50%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">urls = [<br>    <span class="hljs-string">&quot;https://debuggingworld.github.io&quot;</span>,<br>]<br>loader = UnstructuredURLLoader(urls=urls, mode=<span class="hljs-string">&quot;elements&quot;</span>)<br>data = loader.load()<br><span class="hljs-built_in">print</span>(data[<span class="hljs-number">0</span>].metadata)<br><span class="hljs-built_in">print</span>(data[<span class="hljs-number">0</span>].page_content)<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409101758354.png" style="zoom:50%;" /></p><h3 id="text-splitters">2. Text Splitters</h3><p>文本分割器的工作原理如下：</p><ol type="1"><li>将文本分成小而有意义的块（通常是句子）。</li><li>开始将这些小块组合成较大的块，直到达到指定大小（通过某个函数进行测量）。</li><li>一旦达到该大小，使该块成为自己独立的一部分，并开始创建一个具有一定重叠（以保持上下文关系）的新文本块。</li></ol><p>这意味着可以沿两个不同轴向定制文本分割器：</p><ol type="1"><li>如何拆分文字</li><li>如何测量块大小</li></ol><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TextSplitter</span>(<span class="hljs-params">BaseDocumentTransformer, ABC</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;Interface for splitting text into chunks.&quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">__init__</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        self,</span></span><br><span class="hljs-params"><span class="hljs-function">        chunk_size: <span class="hljs-built_in">int</span> = <span class="hljs-number">4000</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        chunk_overlap: <span class="hljs-built_in">int</span> = <span class="hljs-number">200</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        length_function: <span class="hljs-type">Callable</span>[[<span class="hljs-built_in">str</span>], <span class="hljs-built_in">int</span>] = <span class="hljs-built_in">len</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        keep_separator: <span class="hljs-type">Union</span>[<span class="hljs-built_in">bool</span>, <span class="hljs-type">Literal</span>[<span class="hljs-string">&quot;start&quot;</span>, <span class="hljs-string">&quot;end&quot;</span>]] = <span class="hljs-literal">False</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        add_start_index: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">False</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">        strip_whitespace: <span class="hljs-built_in">bool</span> = <span class="hljs-literal">True</span>,</span></span><br><span class="hljs-params"><span class="hljs-function">    </span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;Create a new TextSplitter.</span><br><span class="hljs-string"></span><br><span class="hljs-string">        Args:</span><br><span class="hljs-string">            chunk_size: Maximum size of chunks to return</span><br><span class="hljs-string">            chunk_overlap: Overlap in characters between chunks</span><br><span class="hljs-string">            length_function: Function that measures the length of given chunks</span><br><span class="hljs-string">            keep_separator: Whether to keep the separator and where to place it</span><br><span class="hljs-string">                            in each corresponding chunk (True=&#x27;start&#x27;)</span><br><span class="hljs-string">            add_start_index: If `True`, includes chunk&#x27;s start index in metadata</span><br><span class="hljs-string">            strip_whitespace: If `True`, strips whitespace from the start and end of</span><br><span class="hljs-string">                              every document</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br>        <span class="hljs-keyword">if</span> chunk_overlap &gt; chunk_size:<br>            <span class="hljs-keyword">raise</span> ValueError(<br>                <span class="hljs-string">f&quot;Got a larger chunk overlap (<span class="hljs-subst">&#123;chunk_overlap&#125;</span>) than chunk size &quot;</span><br>                <span class="hljs-string">f&quot;(<span class="hljs-subst">&#123;chunk_size&#125;</span>), should be smaller.&quot;</span><br>            )<br>        self._chunk_size = chunk_size<br>        <span class="hljs-comment"># 切块之间的最大重叠部分。保持一定程度的重叠可以使得各个切块之间保持连贯性（例如滑动窗口）。</span><br>        self._chunk_overlap = chunk_overlap<br>        self._length_function = length_function<br>        self._keep_separator = keep_separator<br>        self._add_start_index = add_start_index<br>        self._strip_whitespace = strip_whitespace<br><br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">split_text</span>(<span class="hljs-params">self, text: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;Split text into multiple components.&quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">create_documents</span>(<span class="hljs-params"></span></span><br><span class="hljs-params"><span class="hljs-function">        self, texts: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>], metadatas: <span class="hljs-type">Optional</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">dict</span>]] = <span class="hljs-literal">None</span></span></span><br><span class="hljs-params"><span class="hljs-function">    </span>) -&gt; <span class="hljs-type">List</span>[Document]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;Create documents from a list of texts.&quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">split_documents</span>(<span class="hljs-params">self, documents: Iterable[Document]</span>) -&gt; <span class="hljs-type">List</span>[Document]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;Split documents.&quot;&quot;&quot;</span><br>        texts, metadatas = [], []<br>        <span class="hljs-keyword">for</span> doc <span class="hljs-keyword">in</span> documents:<br>            texts.append(doc.page_content)<br>            metadatas.append(doc.metadata)<br>        <span class="hljs-keyword">return</span> self.create_documents(texts, metadatas=metadatas)<br><br>    <br></code></pre></td></tr></table></figure><p>使用 <code>RecursiveCharacterTextSplitter</code> 文本分割器</p><h4 id="分割文本">1. 分割文本</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain_text_splitters <span class="hljs-keyword">import</span> RecursiveCharacterTextSplitter<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-keyword">with</span> <span class="hljs-built_in">open</span>(<span class="hljs-string">&#x27;../../data/state_of_the_union.txt&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>) <span class="hljs-keyword">as</span> f:<br>        state_of_the_union = f.read()<br>        text_splitter = RecursiveCharacterTextSplitter(<br>            chunk_size=<span class="hljs-number">100</span>,<br>            chunk_overlap=<span class="hljs-number">20</span>,<br>            length_function=<span class="hljs-built_in">len</span>,<br>            add_start_index=<span class="hljs-literal">True</span>,<br>        )<br>        docs = text_splitter.create_documents([state_of_the_union])<br>        <span class="hljs-built_in">print</span>(docs[<span class="hljs-number">0</span>])<br>        <span class="hljs-comment"># &lt;class &#x27;langchain_core.documents.base.Document&#x27;&gt;</span><br>        <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(docs[<span class="hljs-number">0</span>]))<br><br>        <span class="hljs-comment"># 添加元数据、批量分割文档</span><br>        metadata = [&#123;<span class="hljs-string">&quot;document&quot;</span>: <span class="hljs-number">1</span>&#125;, &#123;<span class="hljs-string">&quot;document&quot;</span>: <span class="hljs-number">2</span>&#125;]<br>        documents = text_splitter.create_documents([state_of_the_union, state_of_the_union], metadatas=metadata)<br>        <span class="hljs-built_in">print</span>(documents[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h4 id="代码分割">2. 代码分割</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python">java_text = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">    public PageResp&lt;QueryDatasetResp&gt; queryTask(QueryDatasetReq req) throws IOException &#123;</span><br><span class="hljs-string">    PageResp&lt;QueryDatasetResp&gt; queryDatasetRespPageResp = datasetService.queryTask(req);</span><br><span class="hljs-string">    if (queryDatasetRespPageResp.getData().isEmpty()) &#123;</span><br><span class="hljs-string">        return queryDatasetRespPageResp;</span><br><span class="hljs-string">    &#125;</span><br><span class="hljs-string">    buildAccountInfo(queryDatasetRespPageResp);</span><br><span class="hljs-string">    return queryDatasetRespPageResp;</span><br><span class="hljs-string">&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>java_splitter = RecursiveCharacterTextSplitter.from_language(<br>    language=Language.JAVA, chunk_size=<span class="hljs-number">100</span>, chunk_overlap=<span class="hljs-number">0</span><br>)<br>java_docs = java_splitter.create_documents([java_text])<br><span class="hljs-built_in">print</span>(java_docs[<span class="hljs-number">0</span>])<br></code></pre></td></tr></table></figure><h3 id="embedding-models">3. embedding models</h3><p><ahref="https://python.langchain.com/v0.2/docs/integrations/text_embedding/">Langchain支持的 embedding 模型</a></p><p>　　Embeddings类是一个专门用于与文本嵌入模型进行交互的类。有许多嵌入模型提供者（OpenAI、Cohere、HuggingFace等）-这个类旨在为所有这些提供者提供一个标准接口。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Embeddings</span>(<span class="hljs-params">ABC</span>):</span><br>   <br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">embed_documents</span>(<span class="hljs-params">self, texts: <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>]]:</span><br><br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">embed_query</span>(<span class="hljs-params">self, text: <span class="hljs-built_in">str</span></span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">float</span>]:</span><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    embeddings_model = OpenAIEmbeddings()<br>    embeddings = embeddings_model.embed_documents(<br>        [<br>            <span class="hljs-string">&quot;Hi there!&quot;</span>,<br>            <span class="hljs-string">&quot;Oh, hello!&quot;</span>,<br>            <span class="hljs-string">&quot;What&#x27;s your name?&quot;</span>,<br>            <span class="hljs-string">&quot;My friends call me World&quot;</span>,<br>            <span class="hljs-string">&quot;Hello World!&quot;</span><br>        ]<br>    )<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(embeddings))<br>    <span class="hljs-comment"># 1536</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(embeddings[<span class="hljs-number">0</span>]))<br><br>    embedded_vector = embeddings_model.embed_query(<span class="hljs-string">&quot;What was the name mentioned in the conversation?&quot;</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(embedded_vector))<br></code></pre></td></tr></table></figure><h3 id="vector-stores">4. Vector stores</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409111729906.png" style="zoom:20%;" /></p><p>　　存储和搜索非结构化数据最常见的方法之一是将其嵌入并存储生成的嵌入向量，然后在查询时将非结构化查询进行嵌入，并检索与嵌入查询“最相似”的嵌入向量。</p><p>　　向量存储库负责存储已经过嵌入处理的数据并执行向量搜索。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python">raw_documents = TextLoader(<span class="hljs-string">&#x27;../../data/state_of_the_union.txt&#x27;</span>, encoding=<span class="hljs-string">&#x27;utf-8&#x27;</span>).load()<br><span class="hljs-comment"># 实例化文本分割器</span><br>text_splitter = CharacterTextSplitter(chunk_size=<span class="hljs-number">300</span>, chunk_overlap=<span class="hljs-number">50</span>)<br><span class="hljs-comment"># 分割文本</span><br>documents = text_splitter.split_documents(raw_documents)<br><br>embeddings_model = OpenAIEmbeddings()<br>db = Chroma.from_documents(documents, embeddings_model)<br><br><span class="hljs-comment"># 使用文本进行语义相似度搜索</span><br>query = <span class="hljs-string">&quot;What did the president say about Ketanji Brown Jackson&quot;</span><br>docs = db.similarity_search(query)<br><span class="hljs-built_in">print</span>(docs[<span class="hljs-number">0</span>].page_content)<br><br><span class="hljs-comment"># 返回相似度分数</span><br>docs = db.similarity_search_with_score(query)<br><span class="hljs-keyword">for</span> doc, score <span class="hljs-keyword">in</span> docs:<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;Score: <span class="hljs-subst">&#123;score&#125;</span>&quot;</span>)<br>    <span class="hljs-built_in">print</span>(doc.page_content)<br><br><span class="hljs-comment"># 使用嵌入向量进行语义相似度搜索</span><br>embedding_vector = embeddings_model.embed_query(query)<br>docs = db.similarity_search_by_vector(embedding_vector)<br><span class="hljs-built_in">print</span>(docs[<span class="hljs-number">0</span>].page_content)<br></code></pre></td></tr></table></figure><h3 id="retrievers">5. Retrievers</h3><p>　　LangChain VectorStore 对象不是 Runnable的子类，因此不能立即集成到 LangChain 表达式语言链中。</p><p>　　LangChain Retrievers 是Runnables，因此它们实现了一组标准方法（例如，同步和异步调用以及批处理操作），并被设计为合并到LCEL 链中。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python">retriever = vectorstore.as_retriever(<br>    search_type=<span class="hljs-string">&quot;similarity&quot;</span>,<br>    search_kwargs=&#123;<span class="hljs-string">&quot;k&quot;</span>: <span class="hljs-number">1</span>&#125;,<br>)<br><br>retriever.batch([<span class="hljs-string">&quot;cat&quot;</span>, <span class="hljs-string">&quot;shark&quot;</span>])<br></code></pre></td></tr></table></figure><p>　　<code>VectorStoreRetriever</code> supports search types of<code>"similarity"</code> (default), <code>"mmr"</code> (maximummarginal relevance), and <code>"similarity_score_threshold"</code>. Wecan use the latter to threshold documents output by the retriever bysimilarity score.</p><p>　　检索器可以轻松地合并到更复杂的应用程序中，例如检索增强生成（RAGretrieval-augmentedgeneration）应用程序，它将给定的问题与检索到的上下文组合成 prompt 给到LLM。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs python">llm = ChatOpenAI(model=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>)<br>message = <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">Answer this question using the provided context only.</span><br><span class="hljs-string"></span><br><span class="hljs-string">&#123;question&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">Context:</span><br><span class="hljs-string">&#123;context&#125;</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br><br>prompt = ChatPromptTemplate.from_messages([(<span class="hljs-string">&quot;human&quot;</span>, message)])<br>rag_chain = &#123;<span class="hljs-string">&quot;context&quot;</span>: retriever, <span class="hljs-string">&quot;question&quot;</span>: RunnablePassthrough()&#125; | prompt | llm<br>response = rag_chain.invoke(<span class="hljs-string">&quot;tell me about cats&quot;</span>)<br><span class="hljs-built_in">print</span>(response.content)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>LangChain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LangChain——Memory</title>
    <link href="/2024/09/07/LangChain%E2%80%94%E2%80%94Memory/"/>
    <url>/2024/09/07/LangChain%E2%80%94%E2%80%94Memory/</url>
    
    <content type="html"><![CDATA[<p>　　记忆组件需要实现两个基本操作：读取和写入。</p><p>　　LangChain 的各类 chain 任务组件，如果你打开 Memory功能，他会执行下面类似的逻辑</p><ol type="1"><li>接收初始用户输入的时候，Chain会尝试从记忆组件中查询相关的历史信息，然后把历史信息和用户的输入拼接到提示词中传给LLM。</li><li>在接收 LLM返回内容的时候，会自动把结果存储到记忆组件，方便下次查询。</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409071044757.png" style="zoom:25%;" /></p><h3 id="memory-组件">1. Memory 组件</h3><h4 id="basememory">1.1 BaseMemory</h4><p>　　类继承关系：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean">## 适用于简单的语言模型<br>BaseMemory --&gt; BaseChatMemory --&gt; &lt;name&gt;Memory  # Examples: ZepMemory, ConversationBufferMemory<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseMemory</span>(<span class="hljs-params">Serializable, ABC</span>):</span><br>    <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span>:</span><br>        arbitrary_types_allowed = <span class="hljs-literal">True</span><br><br><span class="hljs-meta">    @property</span><br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">memory_variables</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">str</span>]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;The string keys this memory class will add to chain inputs.&quot;&quot;&quot;</span><br><br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">load_memory_variables</span>(<span class="hljs-params">self, inputs: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]</span>) -&gt; <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;Return key-value pairs given the text input to the chain.&quot;&quot;&quot;</span><br><br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">save_context</span>(<span class="hljs-params">self, inputs: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-type">Any</span>], outputs: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;Save the context of this chain run to memory.</span><br><span class="hljs-string">        Args:</span><br><span class="hljs-string">            inputs: The inputs to the chain.</span><br><span class="hljs-string">            outputs: The outputs of the chain.</span><br><span class="hljs-string">        &quot;&quot;&quot;</span><br><br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clear</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;Clear memory contents.&quot;&quot;&quot;</span><br></code></pre></td></tr></table></figure><h4 id="basechatmessagehistory">1.2 BaseChatMessageHistory</h4><p>类继承关系：</p><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs clean"># 适用于聊天模型<br>BaseChatMessageHistory --&gt; &lt;name&gt;ChatMessageHistory  # Example: ElasticsearchChatMessageHistory  KafkaChatMessageHistory<br></code></pre></td></tr></table></figure><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseChatMessageHistory</span>(<span class="hljs-params">ABC</span>):</span><br>    messages: <span class="hljs-type">List</span>[BaseMessage]<br>    <span class="hljs-string">&quot;&quot;&quot;A property or attribute that returns a list of messages.&quot;&quot;&quot;</span><br><br>    <span class="hljs-keyword">async</span> <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">aget_messages</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-type">List</span>[BaseMessage]:</span><br>        <span class="hljs-string">&quot;&quot;&quot;Async version of getting messages.&quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_user_message</span>(<span class="hljs-params">self, message: <span class="hljs-type">Union</span>[HumanMessage, <span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;Convenience method for adding a human message string to the store.&quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_ai_message</span>(<span class="hljs-params">self, message: <span class="hljs-type">Union</span>[AIMessage, <span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;Convenience method for adding an AI message string to the store.&quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_message</span>(<span class="hljs-params">self, message: BaseMessage</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;Add a Message object to the store.&quot;&quot;&quot;</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_messages</span>(<span class="hljs-params">self, messages: <span class="hljs-type">Sequence</span>[BaseMessage]</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;Add a list of messages.&quot;&quot;&quot;</span><br>        <span class="hljs-keyword">for</span> message <span class="hljs-keyword">in</span> messages:<br>            self.add_message(message)<br><br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">clear</span>(<span class="hljs-params">self</span>) -&gt; <span class="hljs-literal">None</span>:</span><br>        <span class="hljs-string">&quot;&quot;&quot;Remove all messages from the store&quot;&quot;&quot;</span><br><br><br><br></code></pre></td></tr></table></figure><h3 id="memory使用">2. Memory使用</h3><h4 id="conversationbuffermemory">2.1 ConversationBufferMemory</h4><h5 id="基于-conversationchain">1. 基于 ConversationChain</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    llm = OpenAI(temperature=<span class="hljs-number">0</span>)<br>    conversation = ConversationChain(<br>        llm=llm,<br>        verbose=<span class="hljs-literal">True</span>,<br>        memory=ConversationBufferMemory()<br>    )<br>    <span class="hljs-built_in">print</span>(conversation.predict(<span class="hljs-built_in">input</span>=<span class="hljs-string">&quot;Hi ,my name is Bob!&quot;</span>))<br>    <span class="hljs-built_in">print</span>(conversation.predict(<span class="hljs-built_in">input</span>=<span class="hljs-string">&quot;What did I just say my name was?&quot;</span>))<br>   <br></code></pre></td></tr></table></figure><h5 id="conversationchain-prompt">2. ConversationChain + prompt</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 使用openai模型</span><br>    llm = OpenAI(temperature=<span class="hljs-number">0</span>)<br><br>    <span class="hljs-comment"># 注意，我们使用*chat_history模板参数代表历史消息内容，下面记忆组件需要跟这个参数保持一致，才能把历史消息填充进来*</span><br>    template = <span class="hljs-string">&quot;&quot;&quot;你是一个很好的聊天机器人，正在与人类对话。</span><br><span class="hljs-string">    之前的对话内容:</span><br><span class="hljs-string">    &#123;chat_history&#125;</span><br><span class="hljs-string"></span><br><span class="hljs-string">    新的问题: &#123;input&#125;</span><br><span class="hljs-string">    AI回答:&quot;&quot;&quot;</span><br>    prompt = PromptTemplate.from_template(template)<br><br>    <span class="hljs-comment"># 定义记忆组件存储历史对话信息，这里指定了memory_key参数，需要保持跟前面的提示词模板历史消息模板参数一致，都使用chat_history</span><br>    memory = ConversationBufferMemory(memory_key=<span class="hljs-string">&quot;chat_history&quot;</span>)<br>    <span class="hljs-comment"># 通过memory参数指定我们定义的记忆组件（ps: langchain这种设计，很方便切换到其他的记忆组件）</span><br>    conversation = ConversationChain(<br>        llm=llm,<br>        memory=memory,<br>        prompt=prompt,<br>        verbose=<span class="hljs-literal">True</span><br>    )<br><br>    <span class="hljs-built_in">print</span>(conversation.predict(<span class="hljs-built_in">input</span>=<span class="hljs-string">&quot;hi&quot;</span>))<br>    <span class="hljs-built_in">print</span>(conversation.predict(<span class="hljs-built_in">input</span>=<span class="hljs-string">&quot;what can you do&quot;</span>))<br></code></pre></td></tr></table></figure><h5 id="chatmodel-prompt">3. ChatModel + Prompt</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs python">llm = ChatOpenAI()<br><span class="hljs-comment"># 定义消息提示词模板</span><br>prompt = ChatPromptTemplate(<br>    messages=[<br>        SystemMessagePromptTemplate.from_template(<span class="hljs-string">&quot;You are a nice chatbot having a conversation with a human.&quot;</span>),<br>        <span class="hljs-comment"># 设置历史消息的模板参数变量是chat_history</span><br>        MessagesPlaceholder(variable_name=<span class="hljs-string">&quot;chat_history&quot;</span>),<br>        HumanMessagePromptTemplate.from_template(<span class="hljs-string">&quot;&#123;question&#125;&quot;</span>)<br>    ]<br>)<br><span class="hljs-comment"># `return_messages=True` 参数目的是返回langchain封装的对话消息格式</span><br><span class="hljs-comment"># memory_key的chat_history参数要跟前面的历史消息模板参数对应</span><br>memory = ConversationBufferMemory(memory_key=<span class="hljs-string">&quot;chat_history&quot;</span>, return_messages=<span class="hljs-literal">True</span>)<br><br><span class="hljs-comment"># 通过memory参数指定记忆组件</span><br>conversation = LLMChain(<br>    llm=llm,<br>    prompt=prompt,<br>    verbose=<span class="hljs-literal">True</span>,<br>    memory=memory<br>)<br><br><span class="hljs-built_in">print</span>(conversation(&#123;<span class="hljs-string">&quot;question&quot;</span>: <span class="hljs-string">&quot;hi&quot;</span>&#125;))<br><span class="hljs-built_in">print</span>(conversation(&#123;<span class="hljs-string">&quot;question&quot;</span>: <span class="hljs-string">&quot;what can you do&quot;</span>&#125;))<br></code></pre></td></tr></table></figure><h4 id="conversationbufferwindowmemory">2.2ConversationBufferWindowMemory</h4><p><code>ConversationBufferWindowMemory</code>会在时间轴上保留对话的交互列表。它只使用最后 K次交互。这对于保持最近交互的滑动窗口非常有用，以避免缓冲区过大。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">conversation_with_window = ConversationChain(<br>    llm=OpenAI(temperature=<span class="hljs-number">0</span>, max_tokens=<span class="hljs-number">1000</span>),<br>    <span class="hljs-comment"># We set a low k=2, to only keep the last 2 interactions in memory</span><br>    memory=ConversationBufferWindowMemory(k=<span class="hljs-number">2</span>),<br>    verbose=<span class="hljs-literal">True</span><br>)<br><span class="hljs-built_in">print</span>(conversation_with_window.predict(<span class="hljs-built_in">input</span>=<span class="hljs-string">&quot;Hi ,my name is Bob!&quot;</span>))<br><span class="hljs-built_in">print</span>(conversation_with_window.predict(<span class="hljs-built_in">input</span>=<span class="hljs-string">&quot;What did I just say my name was?&quot;</span>))<br><span class="hljs-built_in">print</span>(conversation_with_window.predict(<span class="hljs-built_in">input</span>=<span class="hljs-string">&quot;hwo are you?&quot;</span>))<br><span class="hljs-built_in">print</span>(conversation_with_window.predict(<span class="hljs-built_in">input</span>=<span class="hljs-string">&quot;what are you doing?&quot;</span>))<br></code></pre></td></tr></table></figure><h4 id="conversationsummarybuffermemory">2.3ConversationSummaryBufferMemory</h4><p><code>ConversationSummaryBufferMemory</code>在内存中保留了最近的交互缓冲区，但不仅仅是完全清除旧的交互，而是将它们编译成摘要并同时使用。与以前的实现不同的是，它使用token长度而不是交互次数来确定何时清除交互。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python">memory = ConversationSummaryBufferMemory(llm=OpenAI(temperature=<span class="hljs-number">0</span>, max_tokens=<span class="hljs-number">1000</span>), max_token_limit=<span class="hljs-number">10</span>)<br>memory.save_context(&#123;<span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-string">&quot;嗨，你最近过得怎么样？&quot;</span>&#125;, &#123;<br>    <span class="hljs-string">&quot;output&quot;</span>: <span class="hljs-string">&quot; 嗨！我最近过得很好，谢谢你问。我最近一直在学习新的知识，并且正在尝试改进自己的性能。我也在尝试更多的交流，以便更好地了解人类的思维方式。&quot;</span>&#125;)<br>memory.save_context(&#123;<span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-string">&quot;你最近学到什么新知识了?&quot;</span>&#125;, &#123;<br>    <span class="hljs-string">&quot;output&quot;</span>: <span class="hljs-string">&quot; 最近我学习了有关自然语言处理的知识，以及如何更好地理解人类的语言。我还学习了有关机器学习的知识，以及如何使用它来改善自己的性能。&quot;</span>&#125;)<br><br><span class="hljs-built_in">print</span>(memory.load_memory_variables(&#123;&#125;))<br><br><span class="hljs-built_in">print</span>(memory.load_memory_variables(&#123;&#125;)[<span class="hljs-string">&#x27;history&#x27;</span>])<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>LangChain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LangChain——chains</title>
    <link href="/2024/09/05/LangChain%E2%80%94%E2%80%94chains/"/>
    <url>/2024/09/05/LangChain%E2%80%94%E2%80%94chains/</url>
    
    <content type="html"><![CDATA[<h3 id="llmchain">1. LLMChain</h3><p>　　LLMChain 是 LangChain 中最简单的链，作为其他复杂 Chains 和 Agents的内部调用，被广泛应用。</p><p>　　一个 LLMChain 由 PromptTemplate 和语言模型（LLM or ChatModel）组成。它使用直接传入（或 memory 提供）的 key-value 来规范化生成Prompt Template（提示模板），并将生成的 prompt（格式化后的字符串）传递给大模型，并返回大模型输出。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409051056959.png" style="zoom:9%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> OpenAI<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    llm = OpenAI()<br>    template = ChatPromptTemplate.from_messages([<br>        (<span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;You are a helpful AI bot.&quot;</span>),<br>        (<span class="hljs-string">&quot;human&quot;</span>, <span class="hljs-string">&quot;&#123;user_input&#125;&quot;</span>),<br>    ])<br>    <span class="hljs-comment"># chain = LLMChain(llm=llm, prompt=template)</span><br>    chain = template | llm<br>    <span class="hljs-built_in">print</span>(chain.invoke(&#123;<span class="hljs-string">&quot;user_input&quot;</span>: <span class="hljs-string">&quot;What is the capital of France?&quot;</span>&#125;))<br></code></pre></td></tr></table></figure><h3 id="sequential-chain">2. Sequential Chain</h3><p>　　串联式调用语言模型（将一个调用的输出作为另一个调用的输入）。</p><p>　　顺序链（Sequential Chain）允许用户连接多个链并将它们组合成执行特定场景的流水线（Pipeline）。</p><p>　　顺序链的类型：</p><ul><li>SimpleSequentialChain：最简单形式的顺序链，每个步骤都具有单一输入/输出，并且一个步骤的输出是下一个步骤的输入。</li><li>SequentialChain：更通用形式的顺序链，允许多个输入/输出。</li></ul><h4 id="simplesequentialchain">2.1 SimpleSequentialChain</h4><p>　　使用 SimpleSequentialChain实现戏剧摘要和评论（单输入/单输出）</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409052030736.png" style="zoom:10%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.chains.llm <span class="hljs-keyword">import</span> LLMChain<br><span class="hljs-keyword">from</span> langchain.chains.sequential <span class="hljs-keyword">import</span> SimpleSequentialChain<br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> PromptTemplate<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> OpenAI<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    llm = OpenAI(temperature=<span class="hljs-number">0.7</span>, max_tokens=<span class="hljs-number">1000</span>)<br><br>    template = <span class="hljs-string">&quot;&quot;&quot;你是一位剧作家。根据戏剧的标题，你的任务是为该标题写一个简介。</span><br><span class="hljs-string">    标题：&#123;title&#125;</span><br><span class="hljs-string">    剧作家：以下是对上述戏剧的简介：&quot;&quot;&quot;</span><br>    prompt_template = PromptTemplate(input_variables=[<span class="hljs-string">&quot;title&quot;</span>], template=template)<br>    synopsis_chain = LLMChain(llm=llm, prompt=prompt_template)<br><br>    template = <span class="hljs-string">&quot;&quot;&quot;你是《纽约时报》的戏剧评论家。根据剧情简介，你的工作是为该剧撰写一篇评论。</span><br><span class="hljs-string">    剧情简介：</span><br><span class="hljs-string">    &#123;synopsis&#125;</span><br><span class="hljs-string">    以下是来自《纽约时报》戏剧评论家对上述剧目的评论：&quot;&quot;&quot;</span><br>    review_prompt_template = PromptTemplate(input_variables=[<span class="hljs-string">&quot;synopsis&quot;</span>], template=template)<br>    review_chain = LLMChain(llm=llm, prompt=review_prompt_template)<br><br>    overall_chain = SimpleSequentialChain(chains=[synopsis_chain, review_chain], verbose=<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment"># overall_chain = prompt_template | llm | review_prompt_template | llm</span><br>    review = overall_chain.invoke(<span class="hljs-string">&quot;三体人不是无法战胜的&quot;</span>)<br>    <span class="hljs-built_in">print</span>(review)<br></code></pre></td></tr></table></figure><p><strong>执行过程：</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409052035582.png" style="zoom:10%;" /></p><h4 id="sequentialchain">2.2 SequentialChain</h4><p>　　使用 SequentialChain 实现戏剧摘要和评论（多输入/多输出）</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409052129423.png" style="zoom:10%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    llm = OpenAI(temperature=<span class="hljs-number">0.7</span>, max_tokens=<span class="hljs-number">1000</span>)<br><br>    template = <span class="hljs-string">&quot;&quot;&quot;你是一位剧作家。根据戏剧的标题，你的任务是为该标题写一个简介。</span><br><span class="hljs-string">    标题：&#123;title&#125;</span><br><span class="hljs-string">    剧作家：以下是对上述戏剧的简介：&quot;&quot;&quot;</span><br>    prompt_template = PromptTemplate(input_variables=[<span class="hljs-string">&quot;title&quot;</span>], template=template)<br>    synopsis_chain = LLMChain(llm=llm, prompt=prompt_template, output_key=<span class="hljs-string">&quot;synopsis&quot;</span>, verbose=<span class="hljs-literal">True</span>)<br><br>    review_template = <span class="hljs-string">&quot;&quot;&quot;你是《纽约时报》的戏剧评论家。根据剧情简介，你的工作是为该剧撰写一篇评论。</span><br><span class="hljs-string">    剧情简介：</span><br><span class="hljs-string">    &#123;synopsis&#125;</span><br><span class="hljs-string">    以下是来自《纽约时报》戏剧评论家对上述剧目的评论：&quot;&quot;&quot;</span><br>    review_prompt_template = PromptTemplate(input_variables=[<span class="hljs-string">&quot;synopsis&quot;</span>], template=review_template)<br>    review_chain = LLMChain(llm=llm, prompt=review_prompt_template, output_key=<span class="hljs-string">&quot;review&quot;</span>, verbose=<span class="hljs-literal">True</span>)<br><br>    overall_chain = SequentialChain(chains=[synopsis_chain, review_chain], input_variables=[<span class="hljs-string">&quot;title&quot;</span>],<br>                                    output_variables=[<span class="hljs-string">&quot;synopsis&quot;</span>, <span class="hljs-string">&quot;review&quot;</span>], verbose=<span class="hljs-literal">True</span>)<br>    review = overall_chain.invoke(&#123;<span class="hljs-string">&quot;title&quot;</span>: <span class="hljs-string">&quot;三体人不是无法战胜的&quot;</span>&#125;)<br>    <span class="hljs-built_in">print</span>(review)<br></code></pre></td></tr></table></figure><p>结果：</p><figure class="highlight taggerscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs taggerscript">&#123;&#x27;title&#x27;: &#x27;三体人不是无法战胜的&#x27;, &#x27;synopsis&#x27;: &#x27;<span class="hljs-symbol">\n</span><span class="hljs-symbol">\n</span>《三体人不是无法战胜的》是一部充满挑战和希望的戏剧作品。故事讲述了一个来自外星球的文明，因为受到宇宙中的三体黑暗森林法则的影响，陷入了无休止的战争和混乱之中。面对强大的三体文明，人类陷入了绝境，但他们并没有放弃希望，而是通过不断的探索和努力，最终找到了战胜三体人的方法。这部戏剧将带领观众进入一个充满惊险和扣人心弦的未来世界，同时也反映出人类对于未知与挑战的勇敢精神。它不仅仅是一部科幻作品，更是一部关于人类意志和毅力的励志故事。让我们一起来见证人类如何战胜不可能，证明三体人并非无法被击败！&#x27;, &#x27;review&#x27;: &#x27; <span class="hljs-symbol">\n</span><span class="hljs-symbol">\n</span>《三体人不是无法战胜的》是一部令人兴奋的戏剧作品，它带领观众进入一个未来充满挑战和希望的世界。该剧通过讲述来自外星球的文明与人类之间的战争，展现了人类面对困难时不屈不挠的精神。<span class="hljs-symbol">\n</span><span class="hljs-symbol">\n</span>在这部作品中，三体黑暗森林法则成为了人类与外星文明的战争规则，给人类带来了巨大的挑战。面对强大的敌人，人类并没有屈服，而是通过不断的探索和努力，最终找到了战胜三体人的方法。这让人们感受到了人类意志和毅力的伟大力量。<span class="hljs-symbol">\n</span><span class="hljs-symbol">\n</span>同时，该剧也反映出了人类对于未知与挑战的勇敢精神。人类在面对未知的外星文明时，没有恐惧，而是勇敢地迎接挑战，并最终取得了胜利。这种勇气和决心令人钦佩，也给观众带来了强烈的鼓舞和启发。<span class="hljs-symbol">\n</span><span class="hljs-symbol">\n</span>《三体人不是无法战胜的》不仅仅是一部科幻作品，更是一部关于人类意志和毅力的励志故事。它深刻地揭示了人类的力量和潜力，令人们对未来充满希望。<span class="hljs-symbol">\n</span><span class="hljs-symbol">\n</span>该剧的制作也非常出色，舞台设计精美，服装华丽，演员们的表演也十分精彩。观众将被带入一个充满惊险和扣人心弦的未来世界，沉浸在剧情中无法自拔。<span class="hljs-symbol">\n</span><span class="hljs-symbol">\n</span>总的来说，《三体人不是无法战胜的》是一部令人振奋的戏剧作品，它不仅带来了视觉上的享受，更让人们重新认识和感受到了人类的力量。让我们一起来见证人类如何战胜不可能，证明三体人并非无法被击败！&#x27;&#125;<br><br></code></pre></td></tr></table></figure><h3 id="transform-chain">3. Transform Chain</h3><p>　　实现快捷处理超长文本。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409051130323.png" style="zoom:10%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.chains.transform <span class="hljs-keyword">import</span> TransformChain<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    joke_text = <span class="hljs-string">&#x27;&#x27;&#x27;1. 为什么程序员喜欢用黑色的键盘？因为它们可以隐藏所有的bug。</span><br><span class="hljs-string"></span><br><span class="hljs-string">2. 一个程序员走进一家酒吧，点了一杯啤酒，然后点了0.1个啤酒，接着点了0.0001个啤酒，最后服务员问他：“你为什么不点一杯啤酒？”程序员回答：“我怕溢出。”</span><br><span class="hljs-string"></span><br><span class="hljs-string">3. 为什么程序员总是喜欢用八进制？因为七八九。</span><br><span class="hljs-string"></span><br><span class="hljs-string">4. 有一天，程序员在写代码的时候突然发现自己的键盘坏了。他赶紧拿出手机，打开计算器开始敲代码，因为他发现自己的计算器比键盘更容易敲出正确的代码。</span><br><span class="hljs-string"></span><br><span class="hljs-string">5. 一个程序员的女朋友问他：“你最爱的是我还是你的电脑？” 程序员回答：“当然是你，我的电脑是我的生活。”</span><br><span class="hljs-string"></span><br><span class="hljs-string">6. 为什么程序员总是喜欢用电梯？因为他们不喜欢爬楼梯，怕出现“栈溢出”的错误。</span><br><span class="hljs-string"></span><br><span class="hljs-string">7. 一个程序员和一个普通人一起玩猜数字的游戏，普通人选择的数字是123，程序员选择的数字是NULL，结果普通人输了。程序员解释道：“因为NULL是没有值的，所以它就是最大的数字。”</span><br><span class="hljs-string"></span><br><span class="hljs-string">8. 为什么程序员喜欢用Mac？因为它有一个“命令+Z”的超能力，可以撤销所有错误。</span><br><span class="hljs-string"></span><br><span class="hljs-string">9. 一个程序员在一家餐厅点了一份鱼和一份鱼，服务员问他：“为什么要点两份一样的？”程序员回答：“我怕出现死循环。”</span><br><span class="hljs-string"></span><br><span class="hljs-string">10. 为什么程序员总是喜欢熬夜？因为他们喜欢看夜晚的“运行时”错误。 &#x27;&#x27;&#x27;</span><br><br>    <span class="hljs-comment"># 定义一个转换函数，输入是字典，输出也是字典。</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">transform_func</span>(<span class="hljs-params">inputs: <span class="hljs-built_in">dict</span></span>) -&gt; <span class="hljs-built_in">dict</span>:</span><br>        <span class="hljs-comment"># 从输入字典中获取&quot;text&quot;键对应的文本。</span><br>        text = inputs[<span class="hljs-string">&quot;text&quot;</span>]<br>        <span class="hljs-comment"># 使用split方法将文本按照&quot;\n\n&quot;分隔为多个段落，并只取前三个，然后再使用&quot;\n\n&quot;将其连接起来。</span><br>        shortened_text = <span class="hljs-string">&quot;\n\n&quot;</span>.join(text.split(<span class="hljs-string">&quot;\n\n&quot;</span>)[:<span class="hljs-number">3</span>])<br>        <span class="hljs-comment"># 返回裁剪后的文本，用&quot;output_text&quot;作为键。</span><br>        <span class="hljs-keyword">return</span> &#123;<span class="hljs-string">&quot;output_text&quot;</span>: shortened_text&#125;<br><br><br>    <span class="hljs-comment"># 使用上述转换函数创建一个TransformChain对象。</span><br>    <span class="hljs-comment"># 定义输入变量为[&quot;text&quot;]，输出变量为[&quot;output_text&quot;]，并指定转换函数为transform_func。</span><br>    transform_chain = TransformChain(<br>        input_variables=[<span class="hljs-string">&quot;text&quot;</span>], output_variables=[<span class="hljs-string">&quot;output_text&quot;</span>], transform=transform_func<br>    )<br>    transformed_text = transform_chain.invoke(&#123;<span class="hljs-string">&quot;text&quot;</span>: joke_text&#125;)<br>    <span class="hljs-built_in">print</span>(transformed_text[<span class="hljs-string">&#x27;output_text&#x27;</span>])<br></code></pre></td></tr></table></figure><p><strong>使用 Sequential Chain 编排:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python">template = <span class="hljs-string">&quot;&quot;&quot;总结下面文本:</span><br><span class="hljs-string">&#123;output_text&#125;</span><br><span class="hljs-string">总结:</span><br><span class="hljs-string">&quot;&quot;&quot;</span><br>prompt = PromptTemplate(input_variables=[<span class="hljs-string">&quot;output_text&quot;</span>], template=template)<br>llm_chain = LLMChain(llm=OpenAI(), prompt=prompt, verbose=<span class="hljs-literal">True</span>)<br><br>sequential_chain = SimpleSequentialChain(chains=[transform_chain, llm_chain])<br>resp = sequential_chain.invoke(joke_text)<br><span class="hljs-built_in">print</span>(resp)<br></code></pre></td></tr></table></figure><h3 id="router-chain">4. Router Chain</h3><p>　　实现条件判断的大模型调用</p><p>　　建一个可定制的链路系统，用户可以提供不同的输入提示，并根据这些提示获取适当的响应。</p><p>　　主要逻辑：从<code>prompt_infos</code>创建多个<code>LLMChain</code>对象，并将它们保存在一个字典中，然后创建一个默认的<code>ConversationChain</code>，最后创建一个带有路由功能的<code>MultiPromptChain</code>。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409061315704.png" style="zoom:10%;" /></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.chains.conversation.base <span class="hljs-keyword">import</span> ConversationChain<br><span class="hljs-keyword">from</span> langchain.chains.llm <span class="hljs-keyword">import</span> LLMChain<br><span class="hljs-keyword">from</span> langchain.chains.router <span class="hljs-keyword">import</span> MultiPromptChain<br><span class="hljs-keyword">from</span> langchain.chains.router.llm_router <span class="hljs-keyword">import</span> RouterOutputParser, LLMRouterChain<br><span class="hljs-keyword">from</span> langchain.chains.router.multi_prompt_prompt <span class="hljs-keyword">import</span> MULTI_PROMPT_ROUTER_TEMPLATE<br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> PromptTemplate<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> OpenAI<br><br>physics_template = <span class="hljs-string">&quot;&quot;&quot;你是一位非常聪明的物理教授。</span><br><span class="hljs-string">你擅长以简洁易懂的方式回答关于物理的问题。</span><br><span class="hljs-string">当你不知道某个问题的答案时，你会坦诚承认。</span><br><span class="hljs-string"></span><br><span class="hljs-string">这是一个问题：</span><br><span class="hljs-string">&#123;input&#125;&quot;&quot;&quot;</span><br><br>math_template = <span class="hljs-string">&quot;&quot;&quot;你是一位很棒的数学家。你擅长回答数学问题。</span><br><span class="hljs-string">之所以如此出色，是因为你能够将难题分解成各个组成部分，</span><br><span class="hljs-string">先回答这些组成部分，然后再将它们整合起来回答更广泛的问题。</span><br><span class="hljs-string"></span><br><span class="hljs-string">这是一个问题：</span><br><span class="hljs-string">&#123;input&#125;&quot;&quot;&quot;</span><br><br>prompt_infos = [<br>    &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;物理&quot;</span>,<br>        <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;适用于回答物理问题&quot;</span>,<br>        <span class="hljs-string">&quot;prompt_template&quot;</span>: physics_template,<br>    &#125;,<br>    &#123;<br>        <span class="hljs-string">&quot;name&quot;</span>: <span class="hljs-string">&quot;数学&quot;</span>,<br>        <span class="hljs-string">&quot;description&quot;</span>: <span class="hljs-string">&quot;适用于回答数学问题&quot;</span>,<br>        <span class="hljs-string">&quot;prompt_template&quot;</span>: math_template,<br>    &#125;,<br>]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    llm = OpenAI()<br>    <span class="hljs-comment"># 创建一个空的目标链字典，用于存放根据prompt_infos生成的LLMChain。</span><br>    destination_chains = &#123;&#125;<br><br>    <span class="hljs-comment"># 遍历prompt_infos列表，为每个信息创建一个LLMChain。</span><br>    <span class="hljs-keyword">for</span> p_info <span class="hljs-keyword">in</span> prompt_infos:<br>        <span class="hljs-comment"># 创建PromptTemplate对象</span><br>        prompt = PromptTemplate(template=p_info[<span class="hljs-string">&quot;prompt_template&quot;</span>], input_variables=[<span class="hljs-string">&quot;input&quot;</span>])<br>        <span class="hljs-comment"># 使用上述模板和llm对象创建LLMChain对象</span><br>        chain = LLMChain(llm=llm, prompt=prompt, verbose=<span class="hljs-literal">True</span>)<br>        <span class="hljs-comment"># 将新创建的chain对象添加到destination_chains字典中</span><br>        destination_chains[p_info[<span class="hljs-string">&quot;name&quot;</span>]] = chain<br><br>    <span class="hljs-comment"># 创建一个默认的ConversationChain</span><br>    default_chain = ConversationChain(llm=llm, output_key=<span class="hljs-string">&quot;text&quot;</span>)<br><br>    <span class="hljs-comment"># 从prompt_infos中提取目标信息并将其转化为字符串列表</span><br>    destinations = [<span class="hljs-string">f&quot;<span class="hljs-subst">&#123;p[<span class="hljs-string">&#x27;name&#x27;</span>]&#125;</span>: <span class="hljs-subst">&#123;p[<span class="hljs-string">&#x27;description&#x27;</span>]&#125;</span>&quot;</span> <span class="hljs-keyword">for</span> p <span class="hljs-keyword">in</span> prompt_infos]<br>    <span class="hljs-comment"># 使用join方法将列表转化为字符串，每个元素之间用换行符分隔</span><br>    destinations_str = <span class="hljs-string">&quot;\n&quot;</span>.join(destinations)<br>    <span class="hljs-comment"># 根据MULTI_PROMPT_ROUTER_TEMPLATE格式化字符串和destinations_str创建路由模板</span><br>    router_template = MULTI_PROMPT_ROUTER_TEMPLATE.<span class="hljs-built_in">format</span>(destinations=destinations_str)<br>    <span class="hljs-comment"># 创建路由的PromptTemplate</span><br>    router_prompt = PromptTemplate(<br>        template=router_template,<br>        input_variables=[<span class="hljs-string">&quot;input&quot;</span>],<br>        output_parser=RouterOutputParser(),<br>    )<br>    <span class="hljs-comment"># 使用上述路由模板和llm对象创建LLMRouterChain对象</span><br>    router_chain = LLMRouterChain.from_llm(llm, router_prompt, verbose=<span class="hljs-literal">True</span>)<br><br>    chain = MultiPromptChain(<br>        router_chain=router_chain,<br>        destination_chains=destination_chains,<br>        default_chain=default_chain,<br>        verbose=<span class="hljs-literal">True</span>,<br>    )<br><br>    <span class="hljs-built_in">print</span>(chain.invoke(&#123;<span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-string">&quot;黑体辐射是什么？&quot;</span>&#125;))<br><br>    <span class="hljs-comment"># print(chain.invoke(&#123;&quot;input&quot;: &quot;大于40的第一个质数是多少，使得这个质数加一能被3整除？&quot;&#125;))</span><br></code></pre></td></tr></table></figure><p><strong>执行输出：</strong></p><figure class="highlight node-repl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs node-repl"><span class="hljs-meta">&gt;</span> <span class="javascript">Entering <span class="hljs-keyword">new</span> MultiPromptChain chain...</span><br><br><br><span class="hljs-meta">&gt;</span> <span class="javascript">Entering <span class="hljs-keyword">new</span> LLMRouterChain chain...</span><br><br><span class="hljs-meta">&gt;</span> <span class="javascript">Finished chain.</span><br>物理: &#123;&#x27;input&#x27;: &#x27;黑体辐射是什么？&#x27;&#125;<br><br><span class="hljs-meta">&gt;</span> <span class="javascript">Entering <span class="hljs-keyword">new</span> LLMChain chain...</span><br>Prompt after formatting:<br>你是一位非常聪明的物理教授。<br>你擅长以简洁易懂的方式回答关于物理的问题。<br>当你不知道某个问题的答案时，你会坦诚承认。<br><br>这是一个问题：<br>黑体辐射是什么？<br><br><span class="hljs-meta">&gt;</span> <span class="javascript">Finished chain.</span><br><br><span class="hljs-meta">&gt;</span> <span class="javascript">Finished chain.</span><br>&#123;&#x27;input&#x27;: &#x27;黑体辐射是什么？&#x27;, &#x27;text&#x27;: &#x27;\n\n黑体辐射是一种理想的热辐射体，它能够以任何温度发射出所有波长的电磁辐射。根据普朗克定律，黑体辐射的强度与波长和温度有关，即随着温度的升高，短波长的辐射强度会增加。黑体辐射是研究热辐射和热力学性质的重要理论基础。&#x27;&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>LangChain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LangChain——model I/O(models、Prompts、OutputParser)</title>
    <link href="/2024/08/30/LangChain%E2%80%94%E2%80%94model%20I:O(models%E3%80%81Prompts%E3%80%81OutputParser)/"/>
    <url>/2024/08/30/LangChain%E2%80%94%E2%80%94model%20I:O(models%E3%80%81Prompts%E3%80%81OutputParser)/</url>
    
    <content type="html"><![CDATA[<p>　　<code>Model I/O</code> 是 LangChain 为开发者提供的一套面向 LLM的标准化模型接口，包括模型输入（Prompts）、模型输出（OutputParsers）和模型本身（Models）。</p><ul><li>Prompts：模板化、动态选择和管理模型输入</li><li>Models：以通用接口调用语言模型</li><li>Output Parser：从模型输出中提取信息，并规范化内容</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409022025891.png" style="zoom:20%;" /></p><h3 id="模型抽象-model">1. 模型抽象 Model</h3><ul><li>语言模型(LLMs): LangChain 的核心组件。LangChain 并不提供自己的LLMs，而是为与许多不同的 LLMs（OpenAI、Cohere、HuggingFace等）进行交互提供了一个标准接口。</li><li>聊天模型(Chat Models):语言模型的一种变体。虽然聊天模型在内部使用了语言模型，但它们提供的接口略有不同。与其暴露一个“输入文本，输出文本”的API 不同，它们提供了一个以“聊天消息”作为输入和输出的接口。</li></ul><p>（注：对比 OpenAI Completion API和 Chat Completion API）</p><h4 id="语言模型llms">1.1 语言模型（LLMs)</h4><p>类继承关系：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">B<span class="hljs-function"><span class="hljs-title">aseLanguageModel</span> --&gt;</span> B<span class="hljs-function"><span class="hljs-title">aseLLM</span> --&gt;</span> LLM --&gt; &lt;<span class="hljs-keyword">name</span>&gt;  # Examples: AI21, HuggingFaceHub, OpenAI<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408301931738.png" style="zoom:50%;" /></p><p>主要抽象:</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">LLMResult,</span> PromptValue,<br><span class="hljs-built_in">CallbackManagerForLLMRun,</span> AsyncCallbackManagerForLLMRun,<br><span class="hljs-built_in">CallbackManager,</span> AsyncCallbackManager,<br><span class="hljs-built_in">AIMessage,</span> BaseMessage<br></code></pre></td></tr></table></figure><h5 id="baselanguagemodel">1. BaseLanguageModel</h5><p>　　这个基类为语言模型定义了一个接口，该接口允许用户以不同的方式与模型交互（例如通过提示或消息）。<code>generate_prompt</code>是其中的一个主要方法，它接受一系列提示，并返回模型的生成结果。</p><p>　　主要提供三种方法：</p><ul><li>generate_prompt: 为一系列的提示词生成语言模型输出。</li><li>predict: 将单个字符串传递给语言模型并返回字符串预测。</li><li>predict_messages: 将一系列BaseMessages（对应于单个模型调用）传递给语言模型，并返回 BaseMessage预测。</li></ul><p>　　每种方法都有对应的异步方法。</p><h5 id="llms-已支持模型清单">2. LLMs 已支持模型清单</h5><p>　　<strong>开发者文档：https://python.langchain.com/docs/integrations/llms/</strong></p><p>　　<strong>代码实现：https://github.com/langchain-ai/langchain/tree/master/libs/langchain/langchain/llms</strong></p><h5 id="调用语言模型">3.调用语言模型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> OpenAI<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    llm = OpenAI(model_name=<span class="hljs-string">&quot;gpt-3.5-turbo-instruct&quot;</span>)<br>    llm.max_tokens = <span class="hljs-number">1024</span><br>    <span class="hljs-built_in">print</span>(llm.invoke(<span class="hljs-string">&quot;讲一个笑话&quot;</span>))<br></code></pre></td></tr></table></figure><h4 id="聊天模型chat-models">1.2 聊天模型（Chat Models)</h4><p>类继承关系：</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xl">B<span class="hljs-function"><span class="hljs-title">aseLanguageModel</span> --&gt;</span> B<span class="hljs-function"><span class="hljs-title">aseChatModel</span> --&gt;</span> &lt;<span class="hljs-keyword">name</span>&gt;  # Examples: ChatOpenAI, ChatGooglePalm<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202409022048040.png" style="zoom:50%;" /></p><p>主要抽象：</p><figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs autohotkey"><span class="hljs-built_in">AIMessage,</span> BaseMessage, HumanMessage<br></code></pre></td></tr></table></figure><h5 id="调用聊天模型">1. 调用聊天模型</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI<br><span class="hljs-keyword">from</span> langchain.schema <span class="hljs-keyword">import</span> (<br>    AIMessage,<br>    HumanMessage,<br>    SystemMessage<br>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    chat_model = ChatOpenAI(model_name=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>)<br>    messages = [SystemMessage(content=<span class="hljs-string">&quot;You are a helpful assistant.&quot;</span>),<br>                HumanMessage(content=<span class="hljs-string">&quot;Who won the world series in 2020?&quot;</span>),<br>                AIMessage(content=<span class="hljs-string">&quot;The Los Angeles Dodgers won the World Series in 2020.&quot;</span>),<br>                HumanMessage(content=<span class="hljs-string">&quot;Where was it played?&quot;</span>)]<br><br>    chat_result = chat_model.invoke(messages)<br>    <span class="hljs-comment"># langchain_core.messages.ai.AIMessage</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(chat_result))<br>    <span class="hljs-built_in">print</span>(chat_result)<br></code></pre></td></tr></table></figure><h3 id="模型输入-prompts">2. 模型输入 Prompts</h3><p>　　一个语言模型的提示是用户提供的一组指令或输入，用于引导模型的响应，帮助它理解上下文并生成相关和连贯的基于语言的输出，例如回答问题、完成句子或进行对话。</p><ul><li>Prompt Templates：参数化的模型输入</li><li>Example Selectors：动态选择要包含在提示中的示例</li></ul><h4 id="prompt-templates">2.1 Prompt Templates</h4><p>　　<strong>Prompt Templates提供了一种预定义、动态注入、模型无关和参数化的提示词生成方式，以便在不同的语言模型之间重用模板。</strong></p><p>　　一个模板可能包括指令、少量示例以及适用于特定任务的具体背景和问题。</p><p>　　通常，提示要么是一个字符串（LLMs），要么是一组聊天消息（ChatModel）。</p><p>类继承关系:</p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xl">B<span class="hljs-function"><span class="hljs-title">asePromptTemplate</span> --&gt;</span> PipelinePromptTemplate<br>                       S<span class="hljs-function"><span class="hljs-title">tringPromptTemplate</span> --&gt;</span> PromptTemplate<br>                                                FewShotPromptTemplate<br>                                                FewShotPromptWithTemplates<br>                       B<span class="hljs-function"><span class="hljs-title">aseChatPromptTemplate</span> --&gt;</span> AutoGPTPrompt<br>                                                  C<span class="hljs-function"><span class="hljs-title">hatPromptTemplate</span> --&gt;</span> AgentScratchPadChatPromptTemplate<br><br><br><br>B<span class="hljs-function"><span class="hljs-title">aseMessagePromptTemplate</span> --&gt;</span> MessagesPlaceholder<br>                              B<span class="hljs-function"><span class="hljs-title">aseStringMessagePromptTemplate</span> --&gt;</span> ChatMessagePromptTemplate<br>                                                                  HumanMessagePromptTemplate<br>                                                                  AIMessagePromptTemplate<br>                                                                  SystemMessagePromptTemplate<br><br>P<span class="hljs-function"><span class="hljs-title">romptValue</span> --&gt;</span> StringPromptValue<br>                ChatPromptValue<br></code></pre></td></tr></table></figure><h5 id="prompttemplate">1. PromptTemplate</h5><p>　　通常，PromptTemplate 类的实例，使用 Python 的 str.format语法生成模板化提示；也可以使用其他模板语法（例如jinja2）。</p><p>　　<strong>使用 from_template 方法实例化PromptTemplate：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> PromptTemplate<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    prompt_template = PromptTemplate.from_template(<span class="hljs-string">&quot;Tell me a &#123;adjective&#125; joke about &#123;content&#125;.&quot;</span>)<br>    prompt = prompt_template.<span class="hljs-built_in">format</span>(adjective=<span class="hljs-string">&quot;funny&quot;</span>, content=<span class="hljs-string">&quot;chickens&quot;</span>)<br>    <span class="hljs-built_in">print</span>(prompt)<br></code></pre></td></tr></table></figure><p>　　<strong>使用构造函数实例化 PromptTemplate：</strong></p><blockquote><p>使用构造函数实例化 <code>prompt_template</code>时必须传入参数：<code>input_variables</code> 和<code>template</code>。</p><p>在生成提示过程中，会检查输入变量与模板字符串中的变量是否匹配，如果不匹配，则会引发异常；</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    template = PromptTemplate(<br>        input_variables=[<span class="hljs-string">&quot;adjective&quot;</span>, <span class="hljs-string">&quot;content&quot;</span>],<br>        template=<span class="hljs-string">&quot;Tell me a &#123;adjective&#125; joke about &#123;content&#125;.&quot;</span><br>    )<br>    prompt = template.<span class="hljs-built_in">format</span>(adjective=<span class="hljs-string">&quot;funny&quot;</span>, content=<span class="hljs-string">&quot;chickens&quot;</span>)<br><br>    llm = OpenAI(model_name=<span class="hljs-string">&quot;gpt-3.5-turbo-instruct&quot;</span>, max_tokens=<span class="hljs-number">1000</span>)<br>    result = llm.invoke(prompt)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-string">f&quot;result: <span class="hljs-subst">&#123;result&#125;</span>&quot;</span>)<br></code></pre></td></tr></table></figure><p>　　<strong>使用 jinja2 生成模板化提示：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs python">jinja2_template = <span class="hljs-string">&quot;Tell me a &#123;&#123; adjective &#125;&#125; joke about &#123;&#123; content &#125;&#125;&quot;</span><br>prompt = PromptTemplate.from_template(jinja2_template, template_format=<span class="hljs-string">&quot;jinja2&quot;</span>)<br>prompt.<span class="hljs-built_in">format</span>(adjective=<span class="hljs-string">&quot;funny&quot;</span>, content=<span class="hljs-string">&quot;chickens&quot;</span>)<br></code></pre></td></tr></table></figure><h5 id="chatprompttemplate">2. ChatPromptTemplate</h5><p>　　使用 from_messages 方法实例化ChatPromptTemplate，生成适用于聊天模型的提示。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    template = ChatPromptTemplate.from_messages([<br>        (<span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;You are a helpful AI bot. Your name is &#123;name&#125;.&quot;</span>),<br>        (<span class="hljs-string">&quot;human&quot;</span>, <span class="hljs-string">&quot;Hello, how are you doing?&quot;</span>),<br>        (<span class="hljs-string">&quot;ai&quot;</span>, <span class="hljs-string">&quot;I&#x27;m doing well, thanks!&quot;</span>),<br>        (<span class="hljs-string">&quot;human&quot;</span>, <span class="hljs-string">&quot;&#123;user_input&#125;&quot;</span>),<br>    ])<br><br>    messages = template.format_messages(<br>        name=<span class="hljs-string">&quot;Bob&quot;</span>,<br>        user_input=<span class="hljs-string">&quot;What is your name?&quot;</span><br>    )<br>    <span class="hljs-built_in">print</span>(messages)<br>    <span class="hljs-built_in">print</span>(messages[<span class="hljs-number">0</span>].content)<br></code></pre></td></tr></table></figure><h5 id="fewshotprompttemplate">3. FewShotPromptTemplate</h5><p>　　构造 few-shot prompt 的方法通常有两种：</p><ul><li>从示例集（set of examples）中手动选择；</li><li>通过示例选择器（Example Selector）自动选择.</li></ul><h6 id="a.-手动选择">a. 手动选择</h6><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> FewShotPromptTemplate, PromptTemplate<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    examples = [<br>        &#123;<br>            <span class="hljs-string">&quot;question&quot;</span>: <span class="hljs-string">&quot;谁活得更久，穆罕默德·阿里还是艾伦·图灵？&quot;</span>,<br>            <span class="hljs-string">&quot;answer&quot;</span>:<br>                <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">                这里需要进一步的问题吗：是的。</span><br><span class="hljs-string">                追问：穆罕默德·阿里去世时多大了？</span><br><span class="hljs-string">                中间答案：穆罕默德·阿里去世时74岁。</span><br><span class="hljs-string">                追问：艾伦·图灵去世时多大了？</span><br><span class="hljs-string">                中间答案：艾伦·图灵去世时41岁。</span><br><span class="hljs-string">                所以最终答案是：穆罕默德·阿里</span><br><span class="hljs-string">                &quot;&quot;&quot;</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-string">&quot;question&quot;</span>: <span class="hljs-string">&quot;craigslist的创始人是什么时候出生的？&quot;</span>,<br>            <span class="hljs-string">&quot;answer&quot;</span>:<br>                <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">                这里需要进一步的问题吗：是的。</span><br><span class="hljs-string">                追问：谁是craigslist的创始人？</span><br><span class="hljs-string">                中间答案：Craigslist是由Craig Newmark创办的。</span><br><span class="hljs-string">                追问：Craig Newmark是什么时候出生的？</span><br><span class="hljs-string">                中间答案：Craig Newmark出生于1952年12月6日。</span><br><span class="hljs-string">                所以最终答案是：1952年12月6日</span><br><span class="hljs-string">                &quot;&quot;&quot;</span><br>        &#125;,<br>        &#123;<br>            <span class="hljs-string">&quot;question&quot;</span>: <span class="hljs-string">&quot;乔治·华盛顿的外祖父是谁？&quot;</span>,<br>            <span class="hljs-string">&quot;answer&quot;</span>:<br>                <span class="hljs-string">&quot;&quot;&quot;</span><br><span class="hljs-string">                这里需要进一步的问题吗：是的。</span><br><span class="hljs-string">                追问：谁是乔治·华盛顿的母亲？</span><br><span class="hljs-string">                中间答案：乔治·华盛顿的母亲是Mary Ball Washington。</span><br><span class="hljs-string">                追问：Mary Ball Washington的父亲是谁？</span><br><span class="hljs-string">                中间答案：Mary Ball Washington的父亲是Joseph Ball。</span><br><span class="hljs-string">                所以最终答案是：Joseph Ball</span><br><span class="hljs-string">                &quot;&quot;&quot;</span><br>        &#125;<br>    ]<br><br>    example_prompt = PromptTemplate(<br>        input_variables=[<span class="hljs-string">&quot;question&quot;</span>, <span class="hljs-string">&quot;answer&quot;</span>],<br>        template=<span class="hljs-string">&quot;Question: &#123;question&#125;\n&#123;answer&#125;&quot;</span><br>    )<br>    <span class="hljs-comment"># print(example_prompt.format(**examples[0]))</span><br><br>    <span class="hljs-comment"># 创建一个 FewShotPromptTemplate 对象</span><br>    few_shot_prompt = FewShotPromptTemplate(<br>        examples=examples,  <span class="hljs-comment"># 使用 examples 作为范例</span><br>        example_prompt=example_prompt,  <span class="hljs-comment"># 使用 example_prompt 作为提示模板</span><br>        suffix=<span class="hljs-string">&quot;Question: &#123;input&#125;&quot;</span>,  <span class="hljs-comment"># 后缀模板，其中 &#123;input&#125; 会被替换为实际输入</span><br>        input_variables=[<span class="hljs-string">&quot;input&quot;</span>]  <span class="hljs-comment"># 定义输入变量的列表</span><br>    )<br><br>    <span class="hljs-built_in">print</span>(few_shot_prompt.<span class="hljs-built_in">format</span>(<span class="hljs-built_in">input</span>=<span class="hljs-string">&quot;玛丽·波尔·华盛顿的父亲是谁?&quot;</span>))<br></code></pre></td></tr></table></figure><h6 id="b.-example-selectors">b. Example Selectors</h6><p>　　如果有大量的参考示例，就得选择哪些要包含在提示中。最好是根据某种条件或者规则来自动选择，ExampleSelector 就是负责这个任务的类。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseExampleSelector</span>(<span class="hljs-params">ABC</span>):</span><br>    <span class="hljs-string">&quot;&quot;&quot;Interface for selecting examples to include in prompts.&quot;&quot;&quot;</span><br>    <span class="hljs-comment"># Add new example to store.</span><br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">add_example</span>(<span class="hljs-params">self, example: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">Any</span>:</span><br><br>    <span class="hljs-comment"># Select which examples to use based on the inputs.</span><br><span class="hljs-meta">    @abstractmethod</span><br>    <span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">select_examples</span>(<span class="hljs-params">self, input_variables: <span class="hljs-type">Dict</span>[<span class="hljs-built_in">str</span>, <span class="hljs-built_in">str</span>]</span>) -&gt; <span class="hljs-type">List</span>[<span class="hljs-built_in">dict</span>]:</span><br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain_community.vectorstores <span class="hljs-keyword">import</span> Chroma<br><span class="hljs-keyword">from</span> langchain_core.example_selectors <span class="hljs-keyword">import</span> SemanticSimilarityExampleSelector<br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> PromptTemplate, FewShotPromptTemplate<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> OpenAIEmbeddings<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    example_prompt = PromptTemplate(<br>        input_variables=[<span class="hljs-string">&quot;input&quot;</span>, <span class="hljs-string">&quot;output&quot;</span>],  <span class="hljs-comment"># 输入变量的名字</span><br>        template=<span class="hljs-string">&quot;Input: &#123;input&#125;\nOutput: &#123;output&#125;&quot;</span>,  <span class="hljs-comment"># 实际的模板字符串</span><br>    )<br><br>    <span class="hljs-comment"># 这是一个假设的任务示例列表，用于创建反义词</span><br>    examples = [<br>        &#123;<span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-string">&quot;happy&quot;</span>, <span class="hljs-string">&quot;output&quot;</span>: <span class="hljs-string">&quot;sad&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-string">&quot;tall&quot;</span>, <span class="hljs-string">&quot;output&quot;</span>: <span class="hljs-string">&quot;short&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-string">&quot;energetic&quot;</span>, <span class="hljs-string">&quot;output&quot;</span>: <span class="hljs-string">&quot;lethargic&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-string">&quot;sunny&quot;</span>, <span class="hljs-string">&quot;output&quot;</span>: <span class="hljs-string">&quot;gloomy&quot;</span>&#125;,<br>        &#123;<span class="hljs-string">&quot;input&quot;</span>: <span class="hljs-string">&quot;windy&quot;</span>, <span class="hljs-string">&quot;output&quot;</span>: <span class="hljs-string">&quot;calm&quot;</span>&#125;,<br>    ]<br><br>    <span class="hljs-comment"># 从给定的示例中创建一个语义相似性选择器</span><br>    example_selector = SemanticSimilarityExampleSelector.from_examples(<br>        examples,  <span class="hljs-comment"># 可供选择的示例列表</span><br>        OpenAIEmbeddings(),  <span class="hljs-comment"># 用于生成嵌入向量的嵌入类，用于衡量语义相似性</span><br>        Chroma,  <span class="hljs-comment"># 用于存储嵌入向量并进行相似性搜索的 VectorStore 类</span><br>        k=<span class="hljs-number">1</span>  <span class="hljs-comment"># 要生成的示例数量</span><br>    )<br><br>    <span class="hljs-comment"># 创建一个 FewShotPromptTemplate 对象</span><br>    similar_prompt = FewShotPromptTemplate(<br>        example_selector=example_selector,  <span class="hljs-comment"># 提供一个 ExampleSelector 替代示例</span><br>        example_prompt=example_prompt,  <span class="hljs-comment"># 提示模板</span><br>        prefix=<span class="hljs-string">&quot;Give the antonym of every input&quot;</span>,  <span class="hljs-comment"># 前缀模板</span><br>        suffix=<span class="hljs-string">&quot;Input: &#123;adjective&#125;\nOutput:&quot;</span>,  <span class="hljs-comment"># 后缀模板</span><br>        input_variables=[<span class="hljs-string">&quot;adjective&quot;</span>],  <span class="hljs-comment"># 输入变量的名字</span><br>    )<br><br>    <span class="hljs-built_in">print</span>(similar_prompt.<span class="hljs-built_in">format</span>(adjective=<span class="hljs-string">&quot;worried&quot;</span>))<br></code></pre></td></tr></table></figure><h3 id="output-parser">3. Output Parser</h3><p>　　很多时候，希望获得<strong>更结构化的信息</strong>。这就是输出解析器的价值所在。</p><p>　　输出解析器是帮助结构化语言模型响应的类。它们必须实现两种主要方法：</p><ul><li>get_format_instructions：返回一个包含有关如何格式化语言模型输出的字符串的方法。</li><li>parse：接受一个字符串，并将其解析成某种结构。</li></ul><h4 id="列表解析-list-parser">3.1 列表解析 List Parser</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain_core.output_parsers <span class="hljs-keyword">import</span> NumberedListOutputParser<br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> PromptTemplate<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> OpenAI<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    <span class="hljs-comment"># 创建一个输出解析器，用于处理带数字编号的列表输出</span><br>    output_parser = NumberedListOutputParser()<br><br>    <span class="hljs-comment"># 获取格式化指令，该指令告诉模型如何格式化其输出</span><br>    format_instructions = output_parser.get_format_instructions()<br><br>    <span class="hljs-comment"># 创建一个提示模板，它会基于给定的模板和变量来生成提示</span><br>    prompt = PromptTemplate(<br>        template=<span class="hljs-string">&quot;List five &#123;subject&#125;.\n&#123;format_instructions&#125;&quot;</span>,  <span class="hljs-comment"># 模板内容</span><br>        input_variables=[<span class="hljs-string">&quot;subject&quot;</span>],  <span class="hljs-comment"># 输入变量</span><br>        partial_variables=&#123;<span class="hljs-string">&quot;format_instructions&quot;</span>: format_instructions&#125;  <span class="hljs-comment"># 预定义的变量，这里我们传入格式化指令</span><br>    )<br><br>    <span class="hljs-comment"># 使用提示模板和给定的主题来格式化输入</span><br>    _<span class="hljs-built_in">input</span> = prompt.<span class="hljs-built_in">format</span>(subject=<span class="hljs-string">&quot;ice cream flavors&quot;</span>)<br>    <span class="hljs-built_in">print</span>(_<span class="hljs-built_in">input</span>)<br>    output = OpenAI(temperature=<span class="hljs-number">0</span>).invoke(_<span class="hljs-built_in">input</span>)<br>    <span class="hljs-built_in">print</span>(output)<br>    <span class="hljs-comment"># 使用之前创建的输出解析器来解析模型的输出</span><br>    result = output_parser.parse(output)<br>    <span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><h4 id="日期解析-datatime-parser">3.2 日期解析 Datatime Parser</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain.output_parsers <span class="hljs-keyword">import</span> DatetimeOutputParser<br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> PromptTemplate<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> OpenAI<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    output_parser = DatetimeOutputParser()<br>    template = <span class="hljs-string">&quot;&quot;&quot;Answer the users question:</span><br><span class="hljs-string">    &#123;question&#125;</span><br><span class="hljs-string">    &#123;format_instructions&#125;&quot;&quot;&quot;</span><br><br>    prompt = PromptTemplate.from_template(<br>        template,<br>        partial_variables=&#123;<span class="hljs-string">&quot;format_instructions&quot;</span>: output_parser.get_format_instructions()&#125;,<br>    )<br><br>    llm = OpenAI()<br>    chain = prompt | llm<br>    output = chain.invoke(&#123;<span class="hljs-string">&quot;question&quot;</span>: <span class="hljs-string">&quot;around when was bitcoin founded?&quot;</span>&#125;)<br>    <span class="hljs-built_in">print</span>(output)<br>    result = output_parser.parse(output)<br>    <span class="hljs-built_in">print</span>(result)<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>LangChain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>OpenAI——embedding</title>
    <link href="/2024/08/22/OpenAI%E2%80%94%E2%80%94embedding/"/>
    <url>/2024/08/22/OpenAI%E2%80%94%E2%80%94embedding/</url>
    
    <content type="html"><![CDATA[<h3 id="生成-embedding">1. 生成 Embedding</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408222057053.png" style="zoom:60%;" /></p><p>　　基于 text-embedding-ada-002模型对亚马逊美食评论数据集(amazon-fine-food-reviews)进行 embedding。</p><p>　　该数据集包含截至2012年10月用户在亚马逊上留下的共计568,454条美食评论。为了说明目的，我们将使用该数据集的一个子集，其中包括最近1,000条评论。这些评论都是用英语撰写的，并且倾向于积极或消极。每个评论都有一个产品ID、用户ID、评分、标题（摘要）和正文。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">import</span> os<br><span class="hljs-keyword">import</span> ast<br><span class="hljs-keyword">import</span> matplotlib<br><span class="hljs-keyword">import</span> numpy <span class="hljs-keyword">as</span> np<br><span class="hljs-keyword">import</span> pandas <span class="hljs-keyword">as</span> pd<br><span class="hljs-keyword">import</span> tiktoken<br><span class="hljs-keyword">from</span> matplotlib <span class="hljs-keyword">import</span> pyplot <span class="hljs-keyword">as</span> plt<br><span class="hljs-keyword">from</span> openai <span class="hljs-keyword">import</span> OpenAI<br><span class="hljs-keyword">from</span> sklearn.cluster <span class="hljs-keyword">import</span> KMeans<br><span class="hljs-keyword">from</span> sklearn.manifold <span class="hljs-keyword">import</span> TSNE<br><br>os.environ[<span class="hljs-string">&quot;OPENAI_API_KEY&quot;</span>] = <span class="hljs-string">&#x27;xxxx&#x27;</span><br>os.environ[<span class="hljs-string">&quot;OPENAI_BASE_URL&quot;</span>] = <span class="hljs-string">&#x27;xxxx&#x27;</span><br><br>client = OpenAI()<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">embedding_text</span>(<span class="hljs-params">text, model=<span class="hljs-string">&quot;text-embedding-ada-002&quot;</span></span>):</span><br>    resp = client.embeddings.create(<span class="hljs-built_in">input</span>=text, model=model)<br>    <span class="hljs-built_in">print</span>(resp)<br>    <span class="hljs-keyword">return</span> resp.data[<span class="hljs-number">0</span>].embedding<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">embedding_to_vector</span>(<span class="hljs-params">input_file_path, output_datapath</span>):</span><br>    <span class="hljs-comment"># 将第一列作为索引</span><br>    df = pd.read_csv(input_file_path, index_col=<span class="hljs-number">0</span>)<br>    <span class="hljs-comment"># 保留指定列</span><br>    df = df[[<span class="hljs-string">&quot;Time&quot;</span>, <span class="hljs-string">&quot;ProductId&quot;</span>, <span class="hljs-string">&quot;UserId&quot;</span>, <span class="hljs-string">&quot;Score&quot;</span>, <span class="hljs-string">&quot;Summary&quot;</span>, <span class="hljs-string">&quot;Text&quot;</span>]]<br>    <span class="hljs-comment"># 删除有空值的行</span><br>    df = df.dropna()<br><br>    <span class="hljs-comment"># 将 &quot;Summary&quot; 和 &quot;Text&quot; 字段组合成新的字段 &quot;combined&quot;</span><br>    df[<span class="hljs-string">&quot;combined&quot;</span>] = (<span class="hljs-string">&quot;Title: &quot;</span> + df.Summary.<span class="hljs-built_in">str</span>.strip() + <span class="hljs-string">&quot;; Content: &quot;</span> + df.Text.<span class="hljs-built_in">str</span>.strip())<br>    <span class="hljs-built_in">print</span>(df.head(<span class="hljs-number">2</span>)[<span class="hljs-string">&quot;combined&quot;</span>])<br><br>    <span class="hljs-comment"># 设置要筛选的评论数量为100</span><br>    top_n = <span class="hljs-number">100</span><br>    df = df.head(top_n * <span class="hljs-number">2</span>)<br>    <span class="hljs-comment"># 丢弃&quot;Time&quot;列，因为我们在这个分析中不再需要它。</span><br>    <span class="hljs-comment"># axis=1: 这个参数指定了删除的是列（axis=1）而不是行（axis=0）。</span><br>    <span class="hljs-comment"># inplace=True: 表示修改应该直接应用于原始 DataFrame df，而不是返回一个新的 DataFrame。</span><br>    df.drop(<span class="hljs-string">&quot;Time&quot;</span>, axis=<span class="hljs-number">1</span>, inplace=<span class="hljs-literal">True</span>)<br>    <span class="hljs-comment"># 从&#x27;embedding_encoding&#x27;获取编码</span><br>    encoding = tiktoken.get_encoding(<span class="hljs-string">&quot;cl100k_base&quot;</span>)<br>    <span class="hljs-comment"># 自动加载给定模型名称的正确编码</span><br>    <span class="hljs-comment"># encoding = tiktoken.encoding_for_model(&quot;gpt-3.5-turbo&quot;)</span><br><br>    <span class="hljs-comment"># 计算每条评论的token数量。我们通过使用encoding.encode方法获取每条评论的token数，然后把结果存储在新的&#x27;n_tokens&#x27;列中。</span><br>    df[<span class="hljs-string">&quot;n_tokens&quot;</span>] = df.combined.apply(<span class="hljs-keyword">lambda</span> x: <span class="hljs-built_in">len</span>(encoding.encode(x)))<br><br>    <span class="hljs-comment"># 如果评论的token数量超过最大允许的token数量，我们将忽略（删除）该评论。</span><br>    <span class="hljs-comment"># 我们使用.tail方法获取token数量在允许范围内的最后top_n（1000）条评论。</span><br>    <span class="hljs-built_in">print</span>(df.head(<span class="hljs-number">2</span>)[<span class="hljs-string">&quot;n_tokens&quot;</span>])<br>    <span class="hljs-comment"># 中过滤 Token 超过 8000 的文本</span><br>    df = df[df.n_tokens &lt;= <span class="hljs-number">8000</span>].head(top_n)<br>    <span class="hljs-comment"># 打印出剩余评论的数量。</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(df))<br><br>    df[<span class="hljs-string">&quot;embedding&quot;</span>] = df.combined.apply(embedding_text)<br>    df.to_csv(output_datapath)<br>    <br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    input_datapath = <span class="hljs-string">&quot;../data/fine_food_reviews_1k.csv&quot;</span><br>    embedding_datapath = <span class="hljs-string">&quot;../data/fine_food_reviews_with_embeddings_1k_1126.csv&quot;</span><br>    embedding_to_vector(input_datapath, embedding_datapath)<br></code></pre></td></tr></table></figure><p><ahref="https://github.com/DjangoPeng/openai-quickstart/blob/main/openai_api/data/fine_food_reviews_1k.csv">fine_food_reviews_1k.csv</a></p><h3 id="读取向量">2. 读取向量</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">read_embedding</span>(<span class="hljs-params">embedding_file_path</span>):</span><br>    df_embedded = pd.read_csv(embedding_file_path, index_col=<span class="hljs-number">0</span>)<br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(df_embedded[<span class="hljs-string">&quot;embedding&quot;</span>][<span class="hljs-number">0</span>]))<br>    <span class="hljs-comment"># str</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(df_embedded[<span class="hljs-string">&quot;embedding&quot;</span>][<span class="hljs-number">0</span>]))<br>    <span class="hljs-comment"># 将字符串转换为向量</span><br>    df_embedded[<span class="hljs-string">&quot;embedding_vec&quot;</span>] = df_embedded[<span class="hljs-string">&quot;embedding&quot;</span>].apply(ast.literal_eval)<br>    <span class="hljs-comment"># 1536</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">len</span>(df_embedded[<span class="hljs-string">&quot;embedding_vec&quot;</span>][<span class="hljs-number">0</span>]))<br>    <span class="hljs-comment"># pandas.core.series.Series</span><br>    <span class="hljs-built_in">print</span>(<span class="hljs-built_in">type</span>(df_embedded[<span class="hljs-string">&quot;embedding_vec&quot;</span>]))<br>    <span class="hljs-keyword">return</span> df_embedded<br></code></pre></td></tr></table></figure><h3 id="使用-t-sne-可视化-1536-维-embedding">3. 使用 t-SNE 可视化 1536维 Embedding</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">show_embedding</span>(<span class="hljs-params">df_embedded</span>):</span><br>    <span class="hljs-comment"># 确保嵌入向量都是等长的</span><br>    <span class="hljs-keyword">assert</span> df_embedded[<span class="hljs-string">&#x27;embedding_vec&#x27;</span>].apply(<span class="hljs-built_in">len</span>).nunique() == <span class="hljs-number">1</span><br><br>    <span class="hljs-comment"># 将嵌入向量列表转换为二维 numpy 数组</span><br>    matrix = np.vstack(df_embedded[<span class="hljs-string">&#x27;embedding_vec&#x27;</span>].values)<br><br>    <span class="hljs-comment"># 创建一个 t-SNE 模型，t-SNE 是一种非线性降维方法，常用于高维数据的可视化。</span><br>    <span class="hljs-comment"># n_components 表示降维后的维度（在这里是2D）</span><br>    <span class="hljs-comment"># perplexity 可以被理解为近邻的数量</span><br>    <span class="hljs-comment"># random_state 是随机数生成器的种子</span><br>    <span class="hljs-comment"># init 设置初始化方式</span><br>    <span class="hljs-comment"># learning_rate 是学习率。</span><br>    tsne = TSNE(n_components=<span class="hljs-number">2</span>, perplexity=<span class="hljs-number">15</span>, random_state=<span class="hljs-number">42</span>, init=<span class="hljs-string">&#x27;random&#x27;</span>, learning_rate=<span class="hljs-number">200</span>)<br><br>    <span class="hljs-comment"># 使用 t-SNE 对数据进行降维，得到每个数据点在新的2D空间中的坐标</span><br>    vis_dims = tsne.fit_transform(matrix)<br><br>    <span class="hljs-comment"># 定义了五种不同的颜色，用于在可视化中表示不同的等级</span><br>    colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;darkorange&quot;</span>, <span class="hljs-string">&quot;gold&quot;</span>, <span class="hljs-string">&quot;turquoise&quot;</span>, <span class="hljs-string">&quot;darkgreen&quot;</span>]<br><br>    <span class="hljs-comment"># 从降维后的坐标中分别获取所有数据点的横坐标和纵坐标</span><br>    x = [x <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> vis_dims]<br>    y = [y <span class="hljs-keyword">for</span> x, y <span class="hljs-keyword">in</span> vis_dims]<br><br>    <span class="hljs-comment"># 根据数据点的评分（减1是因为评分是从1开始的，而颜色索引是从0开始的）获取对应的颜色索引</span><br>    color_indices = df_embedded.Score.values - <span class="hljs-number">1</span><br>    <span class="hljs-comment"># 确保你的数据点和颜色索引的数量匹配</span><br>    <span class="hljs-keyword">assert</span> <span class="hljs-built_in">len</span>(vis_dims) == <span class="hljs-built_in">len</span>(df_embedded.Score.values)<br><br>    <span class="hljs-comment"># 创建一个基于预定义颜色的颜色映射对象</span><br>    colormap = matplotlib.colors.ListedColormap(colors)<br>    <span class="hljs-comment"># 使用 matplotlib 创建散点图，其中颜色由颜色映射对象和颜色索引共同决定，alpha 是点的透明度</span><br>    plt.scatter(x, y, c=color_indices, cmap=colormap, alpha=<span class="hljs-number">0.3</span>)<br><br>    <span class="hljs-comment"># 为图形添加标题</span><br>    plt.title(<span class="hljs-string">&quot;Amazon ratings visualized in language using t-SNE&quot;</span>)<br>    plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408222107847.png" style="zoom:40%;" /></p><h3 id="使用-k-means-聚类然后使用-t-sne-可视化">4. 使用 K-Means聚类，然后使用 t-SNE 可视化</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">k_means_show_embedding</span>(<span class="hljs-params">df_embedded</span>):</span><br>    matrix = np.vstack(df_embedded[<span class="hljs-string">&#x27;embedding_vec&#x27;</span>].values)<br><br>    <span class="hljs-comment"># 创建一个 KMeans 对象，用于进行 K-Means 聚类。</span><br>    <span class="hljs-comment"># n_clusters 参数指定了要创建的聚类的数量；</span><br>    <span class="hljs-comment"># init 参数指定了初始化方法（在这种情况下是 &#x27;k-means++&#x27;）；</span><br>    <span class="hljs-comment"># random_state 参数为随机数生成器设定了种子值，用于生成初始聚类中心。</span><br>    <span class="hljs-comment"># n_init=10 消除警告 &#x27;FutureWarning: The default value of `n_init` will change from 10 to &#x27;auto&#x27; in 1.4&#x27;</span><br>    kmeans = KMeans(n_clusters=<span class="hljs-number">4</span>, init=<span class="hljs-string">&#x27;k-means++&#x27;</span>, random_state=<span class="hljs-number">42</span>, n_init=<span class="hljs-number">10</span>)<br>    kmeans.fit(matrix)<br><br>    <span class="hljs-comment"># kmeans.labels_ 属性包含每个输入数据点所属的聚类的索引。</span><br>    <span class="hljs-comment"># 这里，我们创建一个新的 &#x27;Cluster&#x27; 列，在这个列中，每个数据点都被赋予其所属的聚类的标签。</span><br>    df_embedded[<span class="hljs-string">&#x27;Cluster&#x27;</span>] = kmeans.labels_<br><br>    <span class="hljs-comment"># 首先为每个聚类定义一个颜色。</span><br>    colors = [<span class="hljs-string">&quot;red&quot;</span>, <span class="hljs-string">&quot;green&quot;</span>, <span class="hljs-string">&quot;blue&quot;</span>, <span class="hljs-string">&quot;purple&quot;</span>]<br><br>    <span class="hljs-comment"># 然后，你可以使用 t-SNE 来降维数据。这里，我们只考虑 &#x27;embedding_vec&#x27; 列。</span><br>    tsne_model = TSNE(n_components=<span class="hljs-number">2</span>, random_state=<span class="hljs-number">42</span>)<br>    vis_data = tsne_model.fit_transform(matrix)<br><br>    <span class="hljs-comment"># 现在，你可以从降维后的数据中获取 x 和 y 坐标。</span><br>    x = vis_data[:, <span class="hljs-number">0</span>]<br>    y = vis_data[:, <span class="hljs-number">1</span>]<br><br>    <span class="hljs-comment"># &#x27;Cluster&#x27; 列中的值将被用作颜色索引。</span><br>    color_indices = df_embedded[<span class="hljs-string">&#x27;Cluster&#x27;</span>].values<br><br>    <span class="hljs-comment"># 创建一个基于预定义颜色的颜色映射对象</span><br>    colormap = matplotlib.colors.ListedColormap(colors)<br>    <span class="hljs-comment"># 使用 matplotlib 创建散点图，其中颜色由颜色映射对象和颜色索引共同决定</span><br>    plt.scatter(x, y, c=color_indices, cmap=colormap)<br>    <span class="hljs-comment"># 为图形添加标题</span><br>    plt.title(<span class="hljs-string">&quot;Clustering visualized in 2D using t-SNE&quot;</span>)<br><br>    <span class="hljs-comment"># 显示图形</span><br>    plt.show()<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408222133685.png" style="zoom:40%;" /></p><h3 id="使用-embedding-进行文本搜索">5. 使用 Embedding 进行文本搜索</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-comment"># cosine_similarity 函数计算两个嵌入向量之间的余弦相似度。</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">cosine_similarity</span>(<span class="hljs-params">a, b</span>):</span><br>    <span class="hljs-keyword">return</span> np.dot(a, b) / (np.linalg.norm(a) * np.linalg.norm(b))<br><br><br><span class="hljs-comment"># n 输出结果数</span><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">embedding_search</span>(<span class="hljs-params">df_embedded, question, n=<span class="hljs-number">3</span></span>):</span><br>    question_embedding = embedding_text(question)<br><br>    df_embedded[<span class="hljs-string">&quot;similarity&quot;</span>] = df_embedded.embedding_vec.apply(<span class="hljs-keyword">lambda</span> x: cosine_similarity(x, question_embedding))<br><br>    results = (<br>        df_embedded.sort_values(<span class="hljs-string">&quot;similarity&quot;</span>, ascending=<span class="hljs-literal">False</span>)<br>        .head(n)<br>        .combined<br>    )<br><br>    <span class="hljs-keyword">for</span> r <span class="hljs-keyword">in</span> results:<br>        <span class="hljs-built_in">print</span>(r[:<span class="hljs-number">200</span>])<br>        <span class="hljs-built_in">print</span>()<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>OpenAI</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NLP——GPT&amp;BERT</title>
    <link href="/2024/08/16/NLP%E2%80%94%E2%80%94GPT/"/>
    <url>/2024/08/16/NLP%E2%80%94%E2%80%94GPT/</url>
    
    <content type="html"><![CDATA[<h3 id="gpt">1. GPT</h3><h4 id="gpt发展史">1.1 GPT发展史</h4><p>　　<strong>NLP</strong> 语言模型技术发展一览：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408170652074.png" style="zoom:50%;" /></p><p>　　GPT 发展史：GPT 即 Generative Pre-training Transformer，是 Google在 2018 年提出的一种预训练语言模型。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408162112282.png" style="zoom:50%;" /></p><h4 id="gpt1">1.2 GPT1</h4><p><ahref="https://cdn.openai.com/research-covers/language-unsupervised/language_understanding_paper.pdf">ImprovingLanguage Understanding by Generative Pre-Training</a></p><h5 id="模型结构">1. 模型结构</h5><p>　　Transformer Decoder 和 GPT Decoder对比：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408181036364.png" style="zoom:35%"/></p><p>　　在模型结构方面， GPT 仅使用了 Transformer 的 Decoder 结构，并对Transformer Decoder 进行了一些改动。如上图所示，原本的 Decoder 包含了MHA 和 MMHA，而 GPT 只保留了 MMHA，这确保了 GPT只能关注上文的信息，从而达到单向模型的目的。</p><p>　　它使用了掩码多头注意力和前馈神经网络两种层，并且增加了网络的规模。它的层数从原来的6层增加到了12层，注意力的维度从原来的512 增加到了 768，注意力的头数从原来的 8 个增加到了 12个，前馈层的隐层维度从原来的 2048 增加到了 3072 ，总参数达到了 1.5亿。</p><p>　　除了上面提到的，GPT-1 和 Transformer 还有以下三点差异：</p><ol type="1"><li>GPT-1是一种单向的语言模型，它只利用上文来预测当前位置的值。为了实现这一点，GPT-1采用了掩码多头注意力，它可以屏蔽掉下文的信息。</li><li>Transforme需要对输入的词嵌入加入位置嵌入，以便捕获文本的位置信息。Transformer使用了正弦和余弦函数来计算位置嵌入，而 GPT-1则使用了一种不同的方法。GPT-1的位置嵌入是随机初始化的，并且可以在训练过程中进行更新，这使得它更像词向量。</li><li>GPT-1 的训练分为两个阶段：预训练和微调。在预训练阶段，GPT-1模型学习文本的语义向量；在微调阶段，GPT-1模型根据具体任务进行调整，以解决下游任务。</li></ol><h5 id="无监督-pre-training">2. 无监督 Pre-training</h5><p>　　初代 GPT 的无监督 Pre-training是基于语言模型进行的，给定一个无监督语料 <span class="math display">\[u=\{u_1,...,u_n\}\]</span> 　　GPT 利用标准的语言建模目标最大化以下似然： <spanclass="math display">\[L_1(u)=∑_i㏒P(u_i|u_{i-k},...,u_{i-1};θ)　　(1)\]</span> 　　其中 <span class="math inline">\(k\)</span>是上下文窗口的大小。</p><p>　　GPT-1 模型由 12 个 Transformer 模块组成，每个 Transformer模块只包含解码器中的掩码多头注意力和后面的前馈层，它们的计算公式如下所示：<span class="math display">\[h_0=UW_e+W_p\]</span></p><blockquote><p>这个是嵌入层的计算，其中 <spanclass="math inline">\(U=(u_k,...,u_1)\)</span> 是当前单词 <spanclass="math inline">\(u\)</span> 的上文单词向量，<spanclass="math inline">\(W_e\)</span> 是词向量矩阵， <spanclass="math inline">\(W_P\)</span> 是 position embedding。<spanclass="math inline">\(h_0\)</span>是嵌入层的输出，也是模型的输入。嵌入层本质上是将离散的输入符号映射到连续的向量空间，同时考虑了每个符号在序列中的位置。</p></blockquote><p><span class="math display">\[h_l=transformer\_block(h_{l−1})∀i∈[1,n]\]</span></p><blockquote><p>这是 Transformer 模块的计算过程，其中 n 是 Transformer 层数，<spanclass="math inline">\(h_{l−1}\)</span> 是第 l-1 层的输出，<spanclass="math inline">\(h_l\)</span> 是第 l 层的输出。transformer_block指的是 Transformer模型的主要组成部分，包含了自注意力机制和前馈神经网络。每一层都会对输入进行处理并产生输出，然后这个输出变成下一层的输入。</p></blockquote><p><span class="math display">\[P(u)=softmax(h_nW_e^T)\]</span></p><blockquote><p>这个公式表示了最后的输出层，其中 <spanclass="math inline">\(h_n\)</span> 是最后一个 Transformer模块的输出，<span class="math inline">\(W_e^T\)</span>是嵌入矩阵的转置。(为了保持权重一致，输出层通常与嵌入层共享权重。) 应用softmax 函数使得输出变成概率分布，以此预测下一个词。</p></blockquote><p>　　概率描述的是已知模型参数，预测特定结果的可能性，而似然则是已知特定结果，推测模型参数的可能性。</p><p>　　“似然”是指在训练过程中用来评估模型参数好坏的一种度量。上面似然<span class="math inline">\(L_1(u)\)</span> 被定义为基于无监督语料 <spanclass="math inline">\(u\)</span>训练语言模型时所使用的损失函数。在这个场景中，似然实际上指的是<strong>负对数似然</strong>（NegativeLog Likelihood,NLL），它是用来衡量模型预测概率分布与实际数据之间的匹配程度的一个指标。</p><h5 id="有监督fine-tuning">3. 有监督Fine-tuning</h5><p>　　在利用无监督 Pre-training得到模型后，将其直接应用到有监督任务中。假设有一个有标注的数据集 <spanclass="math inline">\(C\)</span>，其中每个样本的 inputs 包含一系列的token，即 <span class="math inline">\(x^1,...,x^m\)</span> 和一个 label<span class="math inline">\(y\)</span>。将 inputs 输入 Pre-training的模型得到最后一个 transformer decoder block 的状态表征（staterepresentation） <spanclass="math inline">\(h^m_l\)</span>，然后将状态表征输入到在 Fine-tuning阶段新加入的线性输出层预测 <span class="math inline">\(y\)</span>: <spanclass="math display">\[P(y|x^1,...,x^m)=softmax(h_l^mW_y)\]</span></p><blockquote><ol type="1"><li><span class="math inline">\(h_l^m\)</span>：表示经过 m 个 token后的最终状态表征，即最后一个 token 的状态表征。这个状态包含了输入序列<span class="math inline">\(x_1,...,x_m\)</span> 的信息。<spanclass="math inline">\(l\)</span> 表示最后一个解码器块（last decoderblock）,<span class="math inline">\(m\)</span> 表示输入序列中的最后一个token 的位置，即 <spanclass="math inline">\(x^m\)</span>。状态表征是一个向量。</li><li><spanclass="math inline">\(W_y\)</span>：是一个可学习的权重矩阵，它连接了预训练模型的输出<span class="math inline">\(h_l^m\)</span>和最终的分类输出。这个权重矩阵在微调阶段被引入，并通过反向传播进行更新。</li><li>softmax：是一个非线性激活函数，通常用于多分类任务中，将模型的输出转换为概率分布。它确保输出是一个有效的概率分布，即所有类别的概率之和为1。</li></ol></blockquote><p>　　因此，Fine-tuning 阶段最大化以下目标： <spanclass="math display">\[L_2(C)=\sum\limits_{(x,y)}㏒P(y|x^1,...,x^m)\]</span> 　　此外，初代 GPT 将语言建模作为微调的辅助目标以帮助Fine-tuning阶段<strong>提升泛化性</strong>，<strong>加速模型收敛</strong>。具体地，整个Fine-tuning 阶段的优化目标为： <span class="math display">\[L_3(C)=L_2(C)+λ*L_1(C)\]</span> 　　相比 Pre-training 阶段，Fine-tuning 引入了额外的参数包含delimiter tokens（分隔符） 的 embeddings。而 delimiter tokens 是针对Fine-tuning 阶段不同的下游 tasks 进行设计的，目的是为了使得 Pre-training得到的模型能在 Fine-tuning 的时候适配不同的 tasks。</p><p><strong>微调过程</strong>:</p><ol type="1"><li><strong>前向传播</strong>：将输入序列 <spanclass="math inline">\(x^1,...,x^m\)</span>送入预训练模型，得到最后一个解码器块的状态表征 <spanclass="math inline">\(h_l^m\)</span>。</li><li><strong>计算损失</strong>：使用 softmax 函数和权重矩阵 <spanclass="math inline">\(W_y\)</span> 得到预测概率分布，并与真实的标签 y计算交叉熵损失。</li><li><strong>反向传播</strong>：通过计算梯度来更新权重矩阵 <spanclass="math inline">\(W_y\)</span> 以及其他需要微调的参数。</li></ol><h5 id="下游任务微调">4. 下游任务微调</h5><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408191014373.png" style="zoom:35%;" /></p><p>　　某些任务（如文本分类），GPT可以对其进行直接如上所述的模型微调。而某些其他任务（如问答或文本蕴涵）和具有结构化输入的任务，如有序的句子对或文档、问题和答案的三元组，由于GPT的预训练模型是在连续的文本序列上训练的，因此需要一些修改才能将其应用于这些任务。初代GPT 之前的工作提出了基于 transferred representations的学习任务特定的结构。这种方法重新引入了大量特定于任务的定制，并且不对这些额外的结构组件使用迁移学习。相反，GPT使用遍历式方法（traversal-style approach）将结构化输入转换为Pre-training模型可以处理的有序序列。这种输入转换避免了针对不同任务对模型结构进行大量更改。</p><p>　　所有的输入转换都包含了随机初始化的起始（Start）和结尾（End）token，分别用&lt;S&gt; 和 &lt;e&gt; 表示。具体于不同任务：</p><ul><li>对于文本蕴含任务，GPT 在 Fine-tuning 阶段将前提 p（premise ）和假设h （hypothesis）的 token 序列拼接，并在二者中间添加分隔（delimiter）token ,用 $ 表示。</li><li>对于相似度任务，两个句子之间没有固有的顺序。为了反映这一点，GPT将输入的两个句子以两个可能的排列顺序拼接两次，同样需要将 delimiter token添加在两个句子中间。这样两个句子就能获得两个不同顺序的输入转换。然后将两个转换后的输入独立地输入Pre-trianing 得到的模型，再将得到两个序列表征进行 element-wise加法得到最终的表征 <spanclass="math inline">\(h_l^m\)</span>，最后将其输入到线性输出层。</li><li>Question Answering and Commonsense Reasoning 对于这两个任务，给定context document <span class="math inline">\(z\)</span>，question <spanclass="math inline">\(q\)</span> 和可能的 answer 集合 <spanclass="math inline">\({a_k}\)</span>，GPT 先将 document context 和question 拼接（二者中间没有 delimiter），然后再将其与每个 answer进行拼接（中间有 delimiter），得到 <spanclass="math inline">\(k\)</span> 个序列 <spanclass="math inline">\([z;q;a_k]\)</span>。每个序列都被 Pre-training 模型+ Linear 层独立地处理得到相应的分数，最终通过 softmax层进行归一化，以产生可能答案的输出分布。</li></ul><h4 id="gpt2">1.3 GPT2</h4><h5 id="背景">1. 背景</h5><p>　　GPT-2 论文：<ahref="https://cdn.openai.com/better-language-models/language_models_are_unsupervised_multitask_learners.pdf">LanguageModels are Unsupervised MultitaskLearners</a>，语言模型是一种无监督多任务学习。</p><p>　　这里的多任务学习与有监督学习中的多任务不太一样，指模型从大规模数据中学到的能力能够直接在多个任务之间进行迁移，而不需要额外提供特定任务的数据，因此引出了GPT-2 的主要观点：zero-shot。</p><p>　　不论是 GPT-1 还是 BERT，NLP 任务中比较主流的 pre-train +fine-tuning始终还是需要一定量的下游任务有监督数据去进行额外的训练，在模型层面也需要额外的模块去进行预测，仍然存在较多人工干预的成本。GPT-2通过zero-shot，在迁移到其他任务上的时候不需要额外的标注数据，也不需要额外的模型训练。</p><p>　　在 GPT-1中，下游任务需要对不同任务的输入序列进行改造，在序列中加入了开始符、分隔符和结束符之类的特殊标识符，但是在zero-shot前提下，我们无法根据不同的下游任务去添加这些标识符，因为不进行额外的微调训练，模型在预测的时候根本不认识这些特殊标记。所以在zero-shot的设定下，不同任务的输入序列应该与训练时见到的文本长得一样，也就是以自然语言的形式去作为输入。</p><p>　　GPT-2的核心思想就是，<strong>当模型的容量非常大且数据量足够丰富时，仅仅靠语言模型的学习便可以完成其他有监督学习的任务，不需要在下游任务微调</strong>。</p><h5 id="模型结构-1">2. 模型结构</h5><p>　　在模型结构方面，整个 GPT-2 的模型框架与 GPT-1相同，只是做了几个地方的调整：</p><ol type="1"><li>后置层归一化（ post-norm ）改为前置层归一化（ pre-norm ）;</li><li>在模型最后一个自注意力层之后，额外增加一个层归一化（LayerNormalization）；</li><li>调整参数的初始化方式，按残差层个数进行缩放，缩放比例为 <spanclass="math inline">\(1 : \sqrt n\)</span> ;</li><li>输入序列的最大长度从 512 扩充到 1024，batch_size 从 64 增加到512;</li></ol><p>　　其中，关于 post-norm 和 pre-norm 可以参考《Learning DeepTransformer Models for MachineTranslation》。两者的主要区别在于，post-norm 将 transformer 中每一个block 的层归一化放在了残差层之后，而 pre-norm 将层归一化放在了每个 block的输入位置，如下图所示：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408192030710.png" style="zoom:50%;" /></p><p>　　最终 GPT-2 提供了四种规模的模型：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408192037299.png" /></p><p>　　GPT-2的核心是一个语言模型，语言具有天然的顺序性。和监督模型类似，语言模型是对序列的条件概率建模，通常可以表示为如下形式。<span class="math display">\[p(x)=\prod_{i=1}^{n}p(s_n|s_1,...,s_{n−1})\]</span> 　　可以泛化为： <span class="math display">\[p(s_{n−k},...,s_n|s_1,...,s_{n−k−1})\]</span></p><p>　　任何有监督的任务，都是在估计：<em>P</em>(output|input)。通常我们会用特定的网络结构去给任务建模，但如果要做通用模型，它需要对下面的目标进行建模：<em>P</em>(output|input,task)。</p><p>　　有很多方法可以建模 <em>P</em>(output|input,task)，比如特定任务的编码器和解码器。语言模型提供了一种灵活的方式来指定任务、输入、输出。比如对于机器翻译任务，训练样本可以表示为序列（翻译为法语,英语文本, 法语文本）；对于阅读理解任务，训练样本可以表示为（回答问题,文档,问题，答案）。可以训练单一模型，使用这种格式的样本，对不同的任务做推断。按照上面的方法，语言模型也能够学习某些监督任务，并且不需要明确具体的监督符号。</p><h4 id="gpt3">1.4 GPT3</h4><h5 id="背景-1">1. 背景</h5><p>　　GPT-3不再去追求那种极致的不需要任何样本就可以表现很好的模型，而是考虑像人类的学习方式那样，仅仅使用<strong>极少数样本</strong>就可以掌握某一个任务，GPT-3论文：<ahref="https://proceedings.neurips.cc/paper/2020/file/1457c0d6bfcb4967418bfb8ac142f64a-Paper.pdf"><em>LanguageModels are <strong>Few-Shot</strong> Learners</em></a>。</p><p>　　few-shot不是像之前的方式那样，使用少量样本在下游任务上去做微调。</p><h5 id="模型结构-2">2. 模型结构</h5><p>　　在模型结构上，GPT-3 延续使用 GPT 模型结构，但是引入了 SparseTransformer 中的 sparse attention 模块（稀疏注意力）。</p><p>　　sparse attention 与传统 self-attention（称为 dense attention）的区别在于：</p><blockquote><p>dense attention：每个 token 之间两两计算 attention，复杂度 O(n²)sparse attention：每个 token 只与其他 token 的一个子集计算attention，复杂度 O(n*logn)</p></blockquote><p>　　具体来说，sparse attention 除了相对距离不超过 k 以及相对距离为k，2k，3k，... 的 token，其他所有 token 的注意力都设为0，如下图所示：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408192121089.png" style="zoom:70%;" /></p><p>　　使用 sparse attention 的好处主要有以下两点：</p><ol type="1"><li><strong>减少注意力层的计算复杂度</strong>，节约显存和耗时，从而能够处理更长的输入序列；</li><li><strong>具有“局部紧密相关和远程稀疏相关”的特性</strong>，对于距离较近的上下文关注更多，对于距离较远的上下文关注较少；</li></ol><h5 id="下游任务评估方法">3. 下游任务评估方法</h5><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408192125147.png" style="zoom:50%;" /></p><p>　　如上图所示，GPT-3在下游任务的评估与预测时，提供了三种不同的方法：</p><blockquote><p><strong>Zero-shot</strong>：仅使用当前任务的自然语言描述，不进行任何梯度更新；<strong>One-shot</strong>：当前任务的自然语言描述，加上一个简单的输入输出样例，不进行任何梯度更新；<strong>Few-shot</strong>：当前任务的自然语言描述，加上几个简单的输入输出样例，不进行任何梯度更新；</p></blockquote><p>　　其中 Few-shot 也被称为 in-context learning，虽然它与 fine-tuning一样都需要一些有监督标注数据，但是两者的区别是：</p><ol type="1"><li>fine-tuning 基于标注数据对模型参数进行更新，而 in-context learning使用标注数据时不做任何的梯度回传，模型参数不更新；</li><li>in-context learning 依赖的数据量（10～100）远远小于 fine-tuning一般的数据量；</li></ol><p>　　最终通过大量下游任务实验验证，Few-shot 效果最佳，One-shot效果次之，Zero-shot 效果最差：</p><h4 id="instructgpt">1.5 InstructGPT</h4><p>　　<a href="https://arxiv.org/pdf/2203.02155">Training languagemodels to follow instructions with human feedback</a></p><p>　　InstructGPT 是为解决 LM有时不能遵循用户意图而诞生的。“不能遵循用户意图”表示LM可能会生成不真实或对用户毫无帮助的输出。主要原因是 LM的训练目标是预测下一个 token而不是有帮助地和安全地遵循用户的指令。换句话说，这些模型与其用户没有对齐。这是由于模型的偏见性和数据中存在的一些有毒内容导致模型会输出无用的、有毒的输出（LM并没有对输出是否无用、是否有毒的监督）。因此，InstructGPT要做的就是是模型的输出符合人类的意图。具体而言，InstructGPT的优化目标有三个（3H）：</p><ul><li>Helpful，模型应该帮助用户解决他们的任务；</li><li>Honest，模型不应该编造信息来误导用户；</li><li>Harmless，模型不应对人或环境造成身体、心理或社会伤害。</li></ul><p>　　关于 InstructGPT的技术方案，分为了三个步骤：有监督微调，奖励模型训练，强化学习训练；实际上可以把它拆分成两种技术方案，一个是有监督微调（SFT），一个是基于人类反馈的强化学习（RLHF）。</p><h5 id="instruct-learning-和-prompt-learning">1. Instruct Learning 和Prompt Learning</h5><p>　　Instruct Learning 和 Prompt Learning的目的都是去深入挖掘已经具备的知识，并激发出更强的能力。不同的是，Prompt是激发LM 的补全能力，例如根据上半句生成下半句，或者是 Cloze；而 InstructLearning是激发语言模型的理解力，通过给出明显的指令，让模型去做出正确的行动。</p><ul><li><strong>PromptLearning</strong>：给女朋友买了这个项链，她很喜欢，这个项链太__了。</li><li><strong>InstructLearning</strong>：判断这句话的情感：给女朋友买了这个项链，她很喜欢。选项：A=好；B=一般；C=差。</li></ul><p>　　Fine-tuning、Prompt Learning 和 Instruction tuning 的对比：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408201129123.png" style="zoom:60%;" /></p><ul><li><strong>传统Fine-tuning</strong>：需要大量任务特定的样本；每个任务都需要Fine-tuning 一个特别的模型；</li><li><strong>Prompt</strong>：通过少数示例或 prompt 工程提升性能；</li><li><strong>Instructiontuning</strong>：通过自然语言指令学习执行多个任务。</li></ul><h5 id="有监督微调sft">2. 有监督微调SFT</h5><p>　　Supervised Fine-Tuning</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408202027656.png" style="zoom:40%;" /></p><p>　　本质上来说，SFT 可以理解为人工标注了一批数据，然后去微调GPT-3。</p><h5 id="训练奖励模型">3. 训练奖励模型</h5><p>　　这个阶段的主要目的是通过人工标注数据来训练奖励模型（Reward Model,RM）。具体而言，从用户提交的问题中随机抽取一部分（大部分和第一阶段的相同），使用第一阶段微调好的模型，对每个问题生成<em>K</em> 个不同的答案（这里 <em>K</em> 是 4 到 9之间的一个数）。这样就得到了&lt;问题, 回答1&gt;, &lt;问题,回答2&gt;,…,&lt; 问题,回答<em>K</em>&gt;数据。然后，标注人员根据多个标准（例如相关性、信息量、有害性等）综合考虑，对<em>K</em> 个回答进行排序，给出 <em>K</em>个回答的排名顺序，这就是这个阶段人工标注的数据。</p><p>　　接下来，利用这个排序数据来训练奖励模型，采用的训练方法是成对学习（pair-wiselearning）。对于 <em>K</em>个排序结果，两两组合，形成训练数据对，ChatGPT采用成对学习损失值来训练奖励模型。奖励模型接受一个输入&lt;问题,回答&gt;，输出一个评价答案质量高低的分数（score）。对于一对训练数据&lt;回答1,回答2&gt;，假设人工排序中回答1排在回答2前面，那么损失函数就鼓励奖励模型对&lt;问题,回答1&gt; 的分数要高于&lt;问题, 回答2&gt;的分数。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408202034965.png" style="zoom:40%;" /></p><p>　　奖励模型的损失值可以表示为如下的形式： <spanclass="math display">\[loss(θ)=−\frac{1}{\binom{k}{2}}E_{(x,y_w,y_l)∼D}[log(σ(r_θ(x,y_w)−r_θ(x,y_l)))]\]</span> 　　其中：</p><ul><li><p><span class="math inline">\(r_θ(x,y)\)</span>表示奖励模型的输出</p></li><li><p><span class="math inline">\(y_w\)</span>：偏好的语句（wanted）。</p></li><li><p><span class="math inline">\(y_l\)</span> ：不偏好的语句（lesswanted）。</p></li><li><p>σ ：Sigmoid 函数，将实数映射到 (0, 1) 之间。如果奖励模型认为<span class="math inline">\(y_w\)</span> 应该排在 $ y_l$ 的前面，那么 σ(rθ(x,yw) - rθ(x,yl) ) 就接近 1，反之则接近 0。</p></li><li><p>-log：使之单调递减（损失越小越好）。</p></li><li><p>K：一组样本的数量，在计算损失前，样本是以组存在的，从组中抽样一对。</p></li><li><p><spanclass="math inline">\(\binom{k}{2}\)</span>：组合的另一种表达，从 K中选择 2 个组合，中学课本排列组合中的 C（combination）</p></li></ul><p>　　总结第二阶段的过程，首先，监督模型根据每个提示生成 <em>K</em>个回答，并按照质量从高到低排序。然后，人工将这些回答作为训练数据，采用成对学习的方法来训练奖励模型。最后，对于训练好的奖励模型，它可以接收&lt;问题,回答&gt;作为输入，输出回答的质量得分。得分越高，说明回答的质量越高。</p><h5 id="rlhfreinforcement-learning-from-human-feedback">4.RLHF（Reinforcement Learning from Human Feedback）</h5><p>　　第三阶段是使用强化学习微调预训练模型，无需人工标注数据，只需借助上一阶段训练好的奖励模型作为奖励函数。</p><p>　　首先，从用户提交的问题中随机抽取一些新的命令（即与前两个阶段不同的问题），并用第一阶段经过监督微调的模型初始化近端策略优化（ProximalPolicy Optimization,PPO）模型的参数。然后，对于每个抽取的问题，用近端策略优化模型生成回答，并用奖励模型评估回答的质量得分。这个得分就是奖励模型给出的回答的整体收益。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408202102667.png" style="zoom:50%;" /></p><p>　　强化学习的优化目标可以表示为如下形式:</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408202119185.png" style="zoom:50%;" /></p><p>　　第一项是最大化奖励模型的得分，第二项是让强化学习的输出不要偏离有监督微调（SFT）太多，最后一项是保证微调效果的同时，原有语言模型的效果不会变差。</p><p>　　RLHF 的流程如下图所示：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408202105184.png" style="zoom:40%;" /></p><ul><li><strong>Initial Language Model</strong>：Pre-trianing 或者 Instructtuning 后的模型；</li><li><strong>Tuned Language Model</strong>：Initial Lanugage Model的副本，将在 RLHF 中更新参数，也是RL中的Policy；</li><li><strong>Policy</strong>：是给TunedLM（例如GPT-3）输入文本后输出结果的过程；</li><li><strong>Action Space：</strong>全词表，大约 50K；</li><li><strong>Observation Space</strong>：输入的文本序列空间；</li><li><strong>Reward Function</strong>：一个打分模型 Reward Model，和一个KL 的梯度惩罚项</li></ul><p><span class="math display">\[λ_{KL}D_{KL}(π_{ppo}(y|x)||π_{base}(y|x))\]</span></p><p>，目的是为了使 Policy 的输出文本不要和 Initial LM差太多，防止模型为了迎合 Reward 模型输出不连贯的文本或着胡言乱语。</p><h3 id="bert">2. BERT</h3><h4 id="模型结构-3">2.1 模型结构</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408202140065.png" style="zoom:40%;" /></p><p>　　BERT（Bidirectional Encoder Representations from Transformers ）的模型结构采用了原始 Transformer 的 Encoder（如图六所示）。由于没有MMHA，因此在建模时允许每个 token 访问其前后两个方向的 context，因此 BERT是双向的语言模型。</p><p>　　为什么需要选择支持双向的Encoder，在这里引用作者原文的话<em>："The major limitation is thatstandard language models are unidirectional, and this limits the choiceof architectures that can be used during pre-training. For example, inOpenAI GPT, the authors use a left-to-right architecture, where everytoken can only attend to previous tokens in the self-attention layers ofthe Transformer. Such restrictions are sub-optimal for sentence-leveltasks and could be very harmful when applying finetuning-basedapproaches to token-level tasks such as question answering, where it iscrucial to incorporate context from both directions."</em>　　大概的意思是：<strong>标准语言模型是单向的，这限制了在预训练期间可以使用的结构选择。</strong>例如，在OpenAI GPT 中，作者使用从左到右的架构，其中在 Self-attention 中每个token 只能访问先前的token。这种限制对于句子级任务来说是次优的，并且在将基于微调的方法应用于token-level任务（如问题回答）时可能非常有害，因为在这些任务中，从两个方向结合上下文是至关重要的。</p><h4 id="bert-输入构造">2.2 BERT 输入构造</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408202144588.png" style="zoom:50%;" /></p><p>　　为了使 BERT 能够处理不同的下游任务，对于每一个输入的Sequence（在BERT的原文中，作者用" Sentence"表示任意跨度的连续文本，而不是语言意义上的句子；用" Sequence "表示输入BERT 的 tokens序列，可以是一个句子也可以是被打包在一起的两个句子），在其最前面拼接一个特殊的分类token <span class="math inline">\([CLS]\)</span>，<spanclass="math inline">\([CLS]\)</span> 对应位置的最后一层的 Hidden state将被用作分类任务的序列聚合表征。</p><p>　　对于被打包成一个 Sequence 的 Sentence pair,通过两种机制来区分不同句子</p><ul><li>用特殊 token <span class="math inline">\([SEP]\)</span>将两个句子分隔</li><li>为每个 token 添加一个可学习的 Embedding（SegmentEmbedding），来指示其属于前句还是后句。</li></ul><p>　　如上图所示，对于每一个 token，其 Input representation通过将其对应的 Token embedding、Position embedding 和 Segment embedding求和得到。值得注意的是，特殊 token <spanclass="math inline">\([CLS]\)</span> 和 <spanclass="math inline">\([SEP]\)</span>是在预训练的时候就引入了，并且参与预训练中的参数更新，而初代 GPT 的特殊token 只有在 Fine-tuning 阶段才引入。</p><h4 id="bert训练方法">2.3 BERT训练方法</h4><p>　　无监督 Pre-training + 有监督 Fine-tuning</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408202335672.png" style="zoom:30%;" /></p><h5 id="无监督-pre-training-1">1. 无监督 Pre-training</h5><p>　　与 GPT和其它预训练语言模型从左到右或是从右到左的标准预训练方式不同，BERT提出了两个新的预训练任务：</p><table><thead><tr><th style="text-align: center;">预训练任务</th><th style="text-align: left;">训练方式</th></tr></thead><tbody><tr><td style="text-align: center;">Task-1 MASK LM</td><tdstyle="text-align: left;">        作者在直觉上相信，双向模型比单项模型或是只在浅层拼接从左到右和从右到左的表征更强大。为此，作者提出随机遮蔽一定比例的token，被遮蔽的 token 用代替，然后用未遮蔽的部分作为 context预测遮蔽的部分。作者将其称为 MASK LM ，也被称为 Clozetask（完形填空）。在实际实现中，将被遮蔽的 token在最后一层对应位置上的表征输入分类器；对于每一个句子，随机屏蔽 15% 的token。<br /> 　　尽管 MASK LM 能够得到双向的预训练 LM，然而Pre-training 练阶段引入的特殊 token 不会在 Fine-tuning阶段出现，这就产生了一个新的问题：Pre-training 和 Fine-tuning 输入 token的不匹配。为了缓解这一问题， 对与15%被遮蔽的token，不总是用替换，而是采用了如下策略：假设一个 token被选中遮蔽，其（a）有80%的概率用替换，（b）有10%的概率用随机 token进行替换，（c）有10%的概率保持不变。</td></tr><tr><td style="text-align: center;">Task-2 Next Sentence Prediction(NSP)</td><td style="text-align: left;">        QA 和 Natural Language Inference(NLI)等许多重要的下游任务都是基于理解两个句子之间的关系，而语言建模并不能直接捕捉到这种关系。为了训练BERT能够理解句子的关系，作者提出一个预测下一句的二分类任务，这种任务很容易在任何语料中生成。对于NSP 中的句子对儿（A，B），有 50% 的句子 B 在语料中是紧跟句子 A的下一句，有50%的句子 B是在语料中随机选择的。如上图所示，在最后一层输出的 Hiddenstate将被输入分类器预测 B 是否是 A 的下一句。</td></tr></tbody></table><h5 id="有监督fine-tuning-1">2. <strong>有监督Fine-tuning</strong></h5><p>　　在 Fine-tuning阶段，将所有任务的输入构造成句子对（A，B）的形式。例如</p><ul><li>Paraphrasing 中的句子对</li><li>Entailment 中的 hypothesis-premise 对</li><li>QA中的 question-passage 对</li><li>文本分类和序列标注任务中的 text -∅对。</li></ul><p>　　对于输出，在 token- level 的任务里，将所有 token的对应位置最后一层的 hidden states输入相应的输出层（例如序列标注和QA）；在 sentence-level 的任务里，将<span class="math inline">\([CLS]\)</span> 对应位置最后一层的 hiddenstate 输入到分类层进行分类（例如 Entailment 和 SentimentAnalysis）。</p><h4 id="初代gpt和bert的对比">2.4 初代GPT和BERT的对比</h4><p>差异：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408210021336.png" style="zoom:50%;" /></p><p>共识：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408210021956.png" style="zoom:50%;" /></p><h3 id="prompt-learning-vs-in-context-learning">3. Prompt Learning vsIn-context Learning</h3><ul><li>Prompt learning是一种使用预训练语言模型的方法，它不会修改模型的权重。在这种方法中，模型被给予一个提示（prompt），这个提示是模型输入的一部分，它指导模型产生特定类型的输出。这个过程不涉及到对模型权重的修改，而是利用了模型在预训练阶段学习到的知识和能力。</li><li>In-context learning是指模型在处理一系列输入时，使用前面的输入和输出作为后续输入的上下文。这是Transformer 模型（如 GPT系列）的一种基本特性。例如，当模型在处理一个对话任务时，它会使用对话中的前几轮内容作为上下文，来生成下一轮的回答。这个过程也不涉及到对模型权重的修改。</li></ul><p>　　总的来说，prompt learning 和 in-context learning都是利用预训练语言模型的方法，它们都不会修改模型的权重。它们的主要区别在于，promptlearning关注的是如何通过设计有效的提示来<strong>引导模型的输出</strong>，而in-context learning则关注的是如何<strong>利用输入序列中的上下文信息</strong>来影响模型的输出。</p><h3 id="prompt-learning-vs-prompt-tuning">4. Prompt Learning vs PromptTuning</h3><p>　　Prompt learning 和prompt tuning都是自然语言处理（NLP）中的概念，它们都与如何使用和优化预训练语言模型（例如GPT-3 或 GPT-4）有关。</p><ul><li>Promptlearning：是一种方法，其中模型<strong>被训练以响应特定的提示</strong>（prompt）。在这种情况下，提示是模型输入的一部分，它指导模型产生特定类型的输出。例如，如果你向模型提供了"Translatethe following English text to French: {text}"这样的提示，模型就会学习到这是一个翻译任务，并尝试将 {text}从英语翻译成法语。这种方法的关键在于找到能够引导模型正确响应的有效提示。</li><li>Prompt tuning，又称为 "prompt engineering"，是一种<strong>优化技术</strong>，它涉及到寻找或生成能够最大限度提高模型性能的提示。这可能涉及到使用启发式方法、人工智能搜索算法，或者甚至是人工选择和优化提示。Prompttuning的目标是找到一种方式，使得当给定这个提示时，模型能够生成最准确、最相关的输出。</li></ul><p>　　总的来说，prompt learning 和 prompt tuning都与如何使用和优化模型的输入提示有关。它们的主要区别在于，promptlearning 更关注于如何训练模型以响应特定的提示，而 prompt tuning则更关注于如何找到或生成最优的提示以提高模型的性能。</p><h3 id="prompt-learning">5. Prompt Learning</h3><h4 id="chain-of-thought-cot">5.1 Chain-of-Thought, CoT</h4><p>　　实际上是对输入的 Prompt 采用 Chain-of-thought的思想进行改写。传统的 Prompt中，对于一个复杂或者需要多步计算推导的问题样例，会直接给出答案作为In-context learning的学习范例与新任务的测试样例输入到大模型中。这样做往往不能得到正确的结果，如图所示：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408211042859.png" style="zoom:50%;" /></p><p>　　然而，当我们将上述问题范例中的答案再细化一些，给出得到答案的每一个步骤，再将测试样例一起输入到模型中，此时模型居然能够正确回答了，而且也能够参照范例中的样例进行一定的推理，如图所示：</p><p><img src="https://pic1.zhimg.com/80/v2-ef69c6f8d7ee056f0f7aed9c56dd0b40_1440w.webp" alt="img" style="zoom:30%;" /></p><p>　　CoT Prompting 作为一种促进语言模型推理的方法具有几个特点：</p><ul><li>首先，从原则上讲，CoT允许模型将多步问题分解为中间步骤，这意味着可以将额外计算资源分配给需要更多推理步骤的问题。</li><li>其次，CoT提供了对模型行为的可解释窗口，提示了它可能是如何得出特定答案的，并提供了调试推理路径错误之处的机会（尽管完全描述支持答案的模型计算仍然是一个未解决问题）。</li><li>第三，在数学应用题、常识推理和符号操作等任务中都可以使用思维链推理（CoTReasoning），并且在原则上适用于任何人类能够通过语言解决的任务。</li><li>最后，在足够大规模现成语言模型中很容易引发 CoT Reasoning，只需在少样本提示示例中包含一些连贯思路序列即可。</li></ul><p><strong>CoT Prompt 黑魔法：Think step-by-step</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408211056071.png" style="zoom:50%;" /></p><h4 id="self-consistency">5.2 Self-Consistency</h4><p>　　人类在解决复杂问题时，往往会慎重考虑，并可能会尝试使用多种推理路径来解决从而保证得到的答案的正确性。self-consistency就是基于这种思想，让 LLM在解决复杂推理问题时，让他尝试多个推理路径，每个推理路径就是一次 CoT的解决过程，每个可以得到一个答案，最终的答案就是其中出现次数最多的答案。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408211121696.png" style="zoom:60%;" /></p><p>　　普通的 CoT 与使用了 self-consistency 解码策略的对比如下：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408211121727.png" style="zoom:50%;" /></p><p>　　self-consistency 的解码过程主要就是“sample-and-marginalize”：</p><ul><li>让 LLM 的 decoder 去产生多个推理路径，每个推理路径会导致一个 finalanswer（区别于普通 CoT 的 greedy decode）</li><li>marginalize out 这些推理路径，在 final answer set 中找出 the mostconsistent answer</li></ul><h4 id="tree-of-thoughts-tot">5.3 Tree-of-Thoughts, ToT</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408211123908.png" style="zoom:50%;" /></p><h5 id="step-1思维分解">Step 1：思维分解</h5><p>　　虽然 CoT 样本以连贯的方式呈现思维，没有明确的分解过程，但 ToT利用问题属性来设计和分解中间思维步骤。如下表所示，根据不同的问题，一个思维可以是几个词（填字游戏），一行方程式（24点游戏），或者是整段写作计划（创意写作）。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408211130793.png" style="zoom:50%;" /></p><h5 id="step-2思维生成">Step 2：思维生成</h5><p>　　<strong>定义思维生成器 G(pθ, s, k)</strong>：给定一个树状态 s =[x, z1···i]，我们考虑两种策略来为下一个思维步骤生成 k 个候选项：</p><ul><li>从 CoT 提示（创意写作）中独立同分布地抽样思维：z(j) ∼ pCoT (zi+1|s)= pCoT(zi+1|x, z1···i) (j = 1 · · ·k)。当思维空间丰富时（例如每个思维是一段落），独立同分布的样本能够带来多样性；</li><li>使用“提议提示”逐个提出思维（24点游戏和迷你填字游戏）：[z(1), · · · ,z(k)] ∼ppropose(z(1···k)|s)。当思维 θ i+1空间更受限制时（例如每个思维只是一个词或一行），在相同语境中提出不同的想法可以避免重复。</li></ul><h5 id="step-3状态评估">Step 3：状态评估</h5><p>　　<strong>定义状态评估器V(pθ,S)</strong>：给定一组不同状态的前沿，状态评估器评估它们解决问题的进展情况，作为搜索算法确定哪些状态继续探索以及以何种顺序进行的启发式方法。</p><h5 id="step-4搜索算法">Step 4：搜索算法</h5><p>　　最后，在 ToT框架内，可以根据树结构插入和使用不同的搜索算法。作者探索了两种相对简单的搜索算法：</p><ul><li><strong>广度优先搜索（ToT-BFS</strong>）每步维护一组最有希望的状态集合b 个。这适用于 24 点游戏和创意写作等树深度受限制（T ≤3），并且初始思考步骤可以评估和修剪为一个小集合（b ≤ 5）。</li><li><strong>深度优先搜索（ToT-DFS）</strong>首先探索最有希望的状态，直到达到最终输出结果(t&gt; T)，或者状态评估器认为无法解决当前问题。在后一种情况下，从 s开始的子树被修剪以进行开发与利用之间的权衡。在这两种情况下，DFS 会回溯到s 的父状态以继续探索。</li></ul><p>【参考资料】</p><p><ahref="https://zhuanlan.zhihu.com/p/613698929">真·万字长文:可能是全网最晚的chatgpt技术总结</a></p><p><ahref="https://zhuanlan.zhihu.com/p/678912290">深入浅出ChatGPT：技术原理一探究竟</a></p><p><a href="https://zhuanlan.zhihu.com/p/609716668">GPT / GPT-2 / GPT-3/ InstructGPT 进化之路</a></p><p><ahref="https://zhuanlan.zhihu.com/p/623879917">ChatGPT深度解析：GPT家族进化史</a></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>LangChain——开篇</title>
    <link href="/2024/08/14/LangChain%E2%80%94%E2%80%94%E5%BC%80%E7%AF%87/"/>
    <url>/2024/08/14/LangChain%E2%80%94%E2%80%94%E5%BC%80%E7%AF%87/</url>
    
    <content type="html"><![CDATA[<h3 id="整体架构">1. 整体架构</h3><p>　　<strong>LangChain</strong>是一个用于开发由大型语言模型（LLM）驱动的应用程序的框架。</p><ul><li><strong><code>langchain-core</code></strong>: 基础抽象和 LangChain表达式语言。</li><li><strong><code>langchain-community</code></strong>：第三方集成。<ul><li>例如 langchain-openai、langchain-anthropic 等。</li></ul></li><li><strong><code>langchain</code></strong>: Chains, agents, andretrieval strategies that make up an application's cognitivearchitecture.</li><li><strong><code>LangGraph</code></strong>: Build robust and statefulmulti-actor applications with LLMs by modeling steps as edges and nodesin a graph.</li><li><strong><code>LangServe</code></strong>: Deploy LangChain chains asREST APIs.</li><li><strong><code>LangSmith</code></strong>: A developer platform thatlets you debug, test, evaluate, and monitor LLM applications.</li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408142057648.svg" /></p><p><ahref="https://python.langchain.com/v0.2/docs/introduction/">【传送门】</a></p><h3 id="使用llm">2. 使用LLM</h3><p><ahref="https://python.langchain.com/v0.2/docs/tutorials/llm_chain/">【传送门】</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    model = ChatOpenAI(model=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>)<br><br>    messages = [<br>        SystemMessage(content=<span class="hljs-string">&quot;Translate the following from English into chinese&quot;</span>),<br>        HumanMessage(content=<span class="hljs-string">&quot;hi!&quot;</span>),<br>    ]<br><br>    llmResult = model.invoke(messages)<br>    parser = StrOutputParser()<br>    result = parser.invoke(llmResult)<br>    <span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p>链式调用：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain_core.messages <span class="hljs-keyword">import</span> HumanMessage, SystemMessage<br><span class="hljs-keyword">from</span> langchain_core.output_parsers <span class="hljs-keyword">import</span> StrOutputParser<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> OpenAI, ChatOpenAI<br><br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    model = ChatOpenAI(model=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>)<br><br>    messages = [<br>        SystemMessage(content=<span class="hljs-string">&quot;Translate the following from English into chinese&quot;</span>),<br>        HumanMessage(content=<span class="hljs-string">&quot;hi!&quot;</span>),<br>    ]<br><br>    parser = StrOutputParser()<br>    chain = model | parser<br>    result = chain.invoke(messages)<br>    <span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><h3 id="prompttemplates">2. PromptTemplates</h3><p>　　PromptTemplates are a concept in LangChain designed to assistwith this transformation. They take in raw user input and return data (aprompt) that is ready to pass into a language model.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs python">system_template = <span class="hljs-string">&quot;Translate the following into &#123;language&#125;:&quot;</span><br>prompt_template = ChatPromptTemplate.from_messages(<br>    [(<span class="hljs-string">&quot;system&quot;</span>, system_template), (<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;&#123;text&#125;&quot;</span>)]<br>)<br><span class="hljs-comment"># 查看转换结果</span><br>messages = prompt_template.invoke(&#123;<span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;chinese&quot;</span>, <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;hi&quot;</span>&#125;)<br><span class="hljs-built_in">print</span>(messages.to_messages())<br></code></pre></td></tr></table></figure><p><strong>Chaining together components with LCEL(LangChain ExpressionLanguage )</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    model = ChatOpenAI(model=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>)<br>    parser = StrOutputParser()<br><br>    system_template = <span class="hljs-string">&quot;Translate the following into &#123;language&#125;:&quot;</span><br>    prompt_template = ChatPromptTemplate.from_messages(<br>        [(<span class="hljs-string">&quot;system&quot;</span>, system_template), (<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-string">&quot;&#123;text&#125;&quot;</span>)]<br>    )<br><br>    chain = prompt_template | model | parser<br>    result = chain.invoke(&#123;<span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;chinese&quot;</span>, <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;hi&quot;</span>&#125;)<br>    <span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure><p><strong>MessagesPlaceholder 方式：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    model = ChatOpenAI(model=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>)<br><br>    prompt = ChatPromptTemplate.from_messages(<br>        [(<span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;You are a helpful assistant. Answer all questions to the best of your ability.&quot;</span>),<br>         MessagesPlaceholder(variable_name=<span class="hljs-string">&quot;messages&quot;</span>)]<br>    )<br><br>    chain = prompt | model<br>    response = chain.invoke(&#123;<span class="hljs-string">&quot;messages&quot;</span>: [HumanMessage(content=<span class="hljs-string">&quot;hi! I&#x27;m bob&quot;</span>)]&#125;)<br>    <span class="hljs-built_in">print</span>(response.content)<br></code></pre></td></tr></table></figure><p><strong>两种方式结合：</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    model = ChatOpenAI(model=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>)<br><br>    prompt = ChatPromptTemplate.from_messages(<br>        [(<span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;Answer all questions to the best of your ability in &#123;language&#125;.&quot;</span>),<br>         MessagesPlaceholder(variable_name=<span class="hljs-string">&quot;messages&quot;</span>)]<br>    )<br><br>    chain = prompt | model<br>    response = chain.invoke(<br>        &#123;<span class="hljs-string">&quot;messages&quot;</span>: [HumanMessage(content=<span class="hljs-string">&quot;debug the world&quot;</span>)], <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;chinese&quot;</span>&#125;<br>    )<br>    <span class="hljs-built_in">print</span>(response.content)<br></code></pre></td></tr></table></figure><h3 id="server">3. Server</h3><h4 id="服务端">1. 服务端</h4><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> fastapi <span class="hljs-keyword">import</span> FastAPI<br><span class="hljs-keyword">from</span> langchain_core.prompts <span class="hljs-keyword">import</span> ChatPromptTemplate<br><span class="hljs-keyword">from</span> langchain_core.output_parsers <span class="hljs-keyword">import</span> StrOutputParser<br><span class="hljs-keyword">from</span> langchain_openai <span class="hljs-keyword">import</span> ChatOpenAI<br><span class="hljs-keyword">from</span> langserve <span class="hljs-keyword">import</span> add_routes<br><br><span class="hljs-comment"># 1. Create prompt template</span><br>system_template = <span class="hljs-string">&quot;Translate the following into &#123;language&#125;:&quot;</span><br>prompt_template = ChatPromptTemplate.from_messages([<br>    (<span class="hljs-string">&#x27;system&#x27;</span>, system_template),<br>    (<span class="hljs-string">&#x27;user&#x27;</span>, <span class="hljs-string">&#x27;&#123;text&#125;&#x27;</span>)<br>])<br><br><span class="hljs-comment"># 2. Create model</span><br>model = ChatOpenAI()<br><br><span class="hljs-comment"># 3. Create parser</span><br>parser = StrOutputParser()<br><br><span class="hljs-comment"># 4. Create chain</span><br>chain = prompt_template | model | parser<br><br><span class="hljs-comment"># 4. App definition</span><br>app = FastAPI(<br>    title=<span class="hljs-string">&quot;LangChain Server&quot;</span>,<br>    version=<span class="hljs-string">&quot;1.0&quot;</span>,<br>    description=<span class="hljs-string">&quot;A simple API server using LangChain&#x27;s Runnable interfaces&quot;</span>,<br>)<br><br><span class="hljs-comment"># 5. Adding chain route</span><br>add_routes(<br>    app,<br>    chain,<br>    path=<span class="hljs-string">&quot;/chain&quot;</span>,<br>)<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&quot;__main__&quot;</span>:<br>    <span class="hljs-keyword">import</span> uvicorn<br>    uvicorn.run(app, host=<span class="hljs-string">&quot;localhost&quot;</span>, port=<span class="hljs-number">8000</span>)<br></code></pre></td></tr></table></figure><h4 id="客户端">2. 客户端</h4><ol type="1"><li><p><strong>服务调用</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langserve <span class="hljs-keyword">import</span> RemoteRunnable<br><br>remote_chain = RemoteRunnable(<span class="hljs-string">&quot;http://localhost:8000/chain/&quot;</span>)<br>result = remote_chain.invoke(&#123;<span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;chinese&quot;</span>, <span class="hljs-string">&quot;text&quot;</span>: <span class="hljs-string">&quot;debug&quot;</span>&#125;)<br><span class="hljs-built_in">print</span>(result)<br></code></pre></td></tr></table></figure></li><li><p><strong>Playground</strong></p></li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408142032208.png" style="zoom:25%;" /></p><h3 id="message-history">4. Message History</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">from</span> langchain_core.chat_history <span class="hljs-keyword">import</span> (<br>    BaseChatMessageHistory,<br>    InMemoryChatMessageHistory,<br>)<br><span class="hljs-keyword">from</span> langchain_core.runnables.history <span class="hljs-keyword">import</span> RunnableWithMessageHistory<br><br>store = &#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">def</span> <span class="hljs-title">get_session_history</span>(<span class="hljs-params">session_id: <span class="hljs-built_in">str</span></span>) -&gt; BaseChatMessageHistory:</span><br>    <span class="hljs-keyword">if</span> session_id <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> store:<br>        store[session_id] = InMemoryChatMessageHistory()<br>    <span class="hljs-keyword">return</span> store[session_id]<br><br><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    model = ChatOpenAI(model=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>)<br><br>    with_message_history = RunnableWithMessageHistory(model, get_session_history)<br><br>    config = &#123;<span class="hljs-string">&quot;configurable&quot;</span>: &#123;<span class="hljs-string">&quot;session_id&quot;</span>: <span class="hljs-string">&quot;abc2&quot;</span>&#125;&#125;<br>    response = with_message_history.invoke(<br>        [HumanMessage(content=<span class="hljs-string">&quot;Hi! I&#x27;m Bob&quot;</span>)],<br>        config=config,<br>    )<br>    <span class="hljs-built_in">print</span>(response.content)<br><br>    response = with_message_history.invoke(<br>        [HumanMessage(content=<span class="hljs-string">&quot;What&#x27;s my name?&quot;</span>)],<br>        config=config,<br>    )<br>    <span class="hljs-built_in">print</span>(response.content)<br></code></pre></td></tr></table></figure><p><strong>结合 MessagesPlaceholder:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    model = ChatOpenAI(model=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>)<br><br>    prompt = ChatPromptTemplate.from_messages([<br>        (<span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;You are a helpful assistant. Answer all questions to the best of your ability in &#123;language&#125;.&quot;</span>),<br>        MessagesPlaceholder(variable_name=<span class="hljs-string">&quot;messages&quot;</span>),<br>    ])<br><br>    chain = prompt | model<br>    with_message_history = RunnableWithMessageHistory(<br>        chain, get_session_history, input_messages_key=<span class="hljs-string">&quot;messages&quot;</span>,<br>    )<br>    config = &#123;<span class="hljs-string">&quot;configurable&quot;</span>: &#123;<span class="hljs-string">&quot;session_id&quot;</span>: <span class="hljs-string">&quot;abc11&quot;</span>&#125;&#125;<br>    response = with_message_history.invoke(<br>        &#123;<span class="hljs-string">&quot;messages&quot;</span>: [HumanMessage(content=<span class="hljs-string">&quot;hi! I&#x27;m bob&quot;</span>)], <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;chinese&quot;</span>&#125;,<br>        config=config,<br>    )<br>    <span class="hljs-built_in">print</span>(response.content)<br>    response = with_message_history.invoke(<br>        &#123;<span class="hljs-string">&quot;messages&quot;</span>: [HumanMessage(content=<span class="hljs-string">&quot;whats my name?&quot;</span>)], <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;chinese&quot;</span>&#125;,<br>        config=config,<br>    )<br>    <span class="hljs-built_in">print</span>(response.content)<br></code></pre></td></tr></table></figure><h3 id="managing-conversation-history">5. Managing ConversationHistory</h3><p>　　LangChain comes with a few built-in helpers for <ahref="https://python.langchain.com/v0.2/docs/how_to/#messages">managinga list of messages</a>. In this case we'll use the <ahref="https://python.langchain.com/v0.2/docs/how_to/trim_messages/">trim_messages</a>helper to reduce how many messages we're sending to the model. Thetrimmer allows us to specify how many tokens we want to keep, along withother parameters like if we want to always keep the system message andwhether to allow partial messages:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    model = ChatOpenAI(model=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>)<br><br>    messages = [<br>        SystemMessage(content=<span class="hljs-string">&quot;you&#x27;re a good assistant&quot;</span>),<br>        HumanMessage(content=<span class="hljs-string">&quot;hi! I&#x27;m bob&quot;</span>),<br>        AIMessage(content=<span class="hljs-string">&quot;hi!&quot;</span>),<br>        HumanMessage(content=<span class="hljs-string">&quot;I like vanilla ice cream&quot;</span>),<br>        AIMessage(content=<span class="hljs-string">&quot;nice&quot;</span>),<br>        HumanMessage(content=<span class="hljs-string">&quot;whats 2 + 2&quot;</span>),<br>        AIMessage(content=<span class="hljs-string">&quot;4&quot;</span>),<br>        HumanMessage(content=<span class="hljs-string">&quot;thanks&quot;</span>),<br>        AIMessage(content=<span class="hljs-string">&quot;no problem!&quot;</span>),<br>        HumanMessage(content=<span class="hljs-string">&quot;having fun?&quot;</span>),<br>        AIMessage(content=<span class="hljs-string">&quot;yes!&quot;</span>),<br>    ]<br><br>    trimmer = trim_messages(<br>        max_tokens=<span class="hljs-number">65</span>, strategy=<span class="hljs-string">&quot;last&quot;</span>, token_counter=model, include_system=<span class="hljs-literal">True</span>, allow_partial=<span class="hljs-literal">False</span>, start_on=<span class="hljs-string">&quot;human&quot;</span>,<br>    )<br>    <span class="hljs-comment">#result = trimmer.invoke(messages)</span><br>    <span class="hljs-comment">#print(result)</span><br><br>    prompt = ChatPromptTemplate.from_messages([<br>        (<span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;You are a helpful assistant. Answer all questions to the best of your ability in &#123;language&#125;.&quot;</span>),<br>        MessagesPlaceholder(variable_name=<span class="hljs-string">&quot;messages&quot;</span>),<br>    ])<br><br>    chain = (RunnablePassthrough.assign(messages=itemgetter(<span class="hljs-string">&quot;messages&quot;</span>) | trimmer) | prompt | model)<br><br>    response = chain.invoke(&#123;<br>        <span class="hljs-string">&quot;messages&quot;</span>: messages + [HumanMessage(content=<span class="hljs-string">&quot;what&#x27;s my name?&quot;</span>)],<br>        <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;English&quot;</span>,<br>    &#125;)<br>    <span class="hljs-built_in">print</span>(response.content)<br></code></pre></td></tr></table></figure><p><strong>结合 Message History：</strong></p><figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs routeros"><span class="hljs-keyword">if</span> __name__ == <span class="hljs-string">&#x27;__main__&#x27;</span>:<br>    model = ChatOpenAI(<span class="hljs-attribute">model</span>=<span class="hljs-string">&quot;gpt-3.5-turbo&quot;</span>)<br><br>    trimmer = trim_messages(<br>        <span class="hljs-attribute">max_tokens</span>=200, <span class="hljs-attribute">strategy</span>=<span class="hljs-string">&quot;last&quot;</span>, <span class="hljs-attribute">token_counter</span>=model, <span class="hljs-attribute">include_system</span>=<span class="hljs-literal">True</span>, <span class="hljs-attribute">allow_partial</span>=<span class="hljs-literal">False</span>,<br>        <span class="hljs-attribute">start_on</span>=<span class="hljs-string">&quot;human&quot;</span>,<br>    )<br><br>    prompt = ChatPromptTemplate.from_messages([<br>        (<span class="hljs-string">&quot;system&quot;</span>, <span class="hljs-string">&quot;You are a helpful assistant. Answer all questions to the best of your ability in &#123;language&#125;.&quot;</span>),<br>        MessagesPlaceholder(<span class="hljs-attribute">variable_name</span>=<span class="hljs-string">&quot;messages&quot;</span>),<br>    ])<br><br>    chain = (RunnablePassthrough.assign(<span class="hljs-attribute">messages</span>=itemgetter(&quot;messages&quot;) | trimmer) | prompt | model)<br>    with_message_history = RunnableWithMessageHistory(<br>        chain, get_session_history, <span class="hljs-attribute">input_messages_key</span>=<span class="hljs-string">&quot;messages&quot;</span>,<br>    )<br><br>   <span class="hljs-built_in"> config </span>= &#123;<span class="hljs-string">&quot;configurable&quot;</span>: &#123;<span class="hljs-string">&quot;session_id&quot;</span>: <span class="hljs-string">&quot;debuggingWorld&quot;</span>&#125;&#125;<br><br>    <span class="hljs-keyword">while</span> <span class="hljs-literal">True</span>:<br>        question = input(<span class="hljs-string">&quot;请输入: &quot;</span>)<br>        response = with_message_history.invoke(<br>            &#123;<br>                <span class="hljs-string">&quot;messages&quot;</span>: [HumanMessage(<span class="hljs-attribute">content</span>=question)],<br>                <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;English&quot;</span>,<br>            &#125;,<br>            <span class="hljs-attribute">config</span>=config,<br>        )<br>        <span class="hljs-builtin-name">print</span>(response.content)<br>        msgs = trimmer.invoke(get_session_history(<span class="hljs-string">&quot;debuggingWorld&quot;</span>).messages)<br>        <span class="hljs-builtin-name">print</span>(msgs)<br></code></pre></td></tr></table></figure><h3 id="streaming">6. Streaming</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs python"><span class="hljs-keyword">for</span> resp <span class="hljs-keyword">in</span> with_message_history.stream(<br>        &#123;<br>            <span class="hljs-string">&quot;messages&quot;</span>: [HumanMessage(content=question)],<br>            <span class="hljs-string">&quot;language&quot;</span>: <span class="hljs-string">&quot;English&quot;</span>,<br>        &#125;,<br>        config=config,<br>):<br>    <span class="hljs-built_in">print</span>(resp.content)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>LangChain</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NLP——Transformer模型</title>
    <link href="/2024/08/11/NLP%E2%80%94%E2%80%94Transformer%E6%A8%A1%E5%9E%8B/"/>
    <url>/2024/08/11/NLP%E2%80%94%E2%80%94Transformer%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="transformer整体结构">1. Transformer整体结构</h3><p>　　以机器翻译为例子详细剖析 Transformer的结构，在机器翻译中，Transformer 可概括为如下图：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408112114679.png" style="zoom:50%;" /></p><p>　　Transformer　的本质上是一个 Encoder-Decoder 的结构。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408112116285.png" style="zoom:50%;" /></p><p>　　如论文中所设置的，编码器由 6 个编码 block 组成，同样解码器是 6个解码 block组成。与所有的生成模型相同的是，编码器的输出会作为解码器的输入，图下所示：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408112119323.png" style="zoom:35%;" /></p><p>　　每个 encoder 的详细结构：在 Transformer 的 encoder中，数据首先会经过一个叫做<code>self-attention</code>的模块得到一个加权之后的特征向量 <spanclass="math inline">\(Z\)</span>，这个<spanclass="math inline">\(Z\)</span>便是论文中的 <spanclass="math inline">\(Attension(Q,K,V)\)</span> 公式： <spanclass="math display">\[Attension(Q,K,V)=softmax(\frac{QK^T}{d^{1/2}_k})V\]</span> 　　【备注】<span class="math inline">\(K^T\)</span> 表示对 K进行转置。</p><p>　　得到 <span class="math inline">\(Z\)</span> 之后，它会被送到encoder 的下一个模块，即 Feed Forward NeuralNetwork。这个全连接有两层，第一层的激活函数是ReLU，第二层是一个线性激活函数，可以表示为： <spanclass="math display">\[FFN=max(0,ZW_1+b_1)W_2+b_2\]</span> 　　Encoder的结构下图所示：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408112134556.png" style="zoom:30%;" /></p><p>　　Decoder 的结构如下图所示，它和 encoder 的不同之处在于 Decoder多了一个 Encoder-Decoder Attention，两个 Attention分别用于计算输入和输出的权值：</p><ol type="1"><li>Self-Attention：当前翻译和已经翻译的前文之间的关系；</li><li>Encoder-Decoder Attention：当前翻译和编码的特征向量之间的关系。</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408112137552.png" style="zoom:70%;" /></p><h3 id="输入编码">2. 输入编码</h3><p>　　输入编码如下图所示，首先通过 Word2Vec等词嵌入方法将输入语料转化成特征向量，论文中使用的词嵌入的维度为 <spanclass="math inline">\(d_{model}=512\)</span></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408112141059.png" style="zoom:70%;" /></p><p>　　在最底层的 block 中，<span class="math inline">\(x\)</span>将直接作为 Transformer 的输入，而在其他层中，输入则是上一个 block的输出。为了画图更简单，我们使用更简单的例子来表示接下来的过程，如下图所示：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408112148546.png" style="zoom:50%;" /></p><h3 id="self-attention">3 Self-Attention</h3><p>　　Self-Attention 是 Transformer 最核心的内容。回想 Bahdanau等人提出的用Attention，其核心内容是为输入向量的每个单词学习一个权重，例如在下面的例子中我们判断it 代指的内容</p><blockquote><p>The animal didn't cross the street because it was too tired</p></blockquote><p>　　通过加权之后可以得到类似下图的加权情况，在讲解 self-attention的时候我们也会使用下图类似的表示方式：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408112149420.png" /></p><p>　　在 self-attention 中，每个单词有 3 个不同的向量，它们分别是 Query向量（Q），Key 向量（K）和 Value 向量（V），长度均是64。它们是通过嵌入向量 X 乘以三个不同的权值矩阵 <spanclass="math inline">\(W^Q\)</span>, <spanclass="math inline">\(W^K\)</span>, <spanclass="math inline">\(W^V\)</span>得到，其中三个矩阵的尺寸也是相同的，均是512×64 。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408112205174.png" style="zoom:60%;" /></p><p>　　那么 Query，Key，Value 是什么意思呢？它们在 Attention的计算中扮演着什么角色呢？我们先看一下 Attention的计算方法，整个过程可以分成7步：</p><ol type="1"><li>如上文，将输入单词转化成嵌入向量；</li><li>根据嵌入向量得到 <span class="math inline">\(q, k, v\)</span>三个向量；</li><li>为每个向量计算一个 score：<spanclass="math inline">\(score=q∗k\)</span>；</li><li>为了梯度的稳定，Transformer 使用了 score 归一化，即除以 <spanclass="math inline">\(d^{1/2}_k\)</span>；</li><li>对 score 施以 softmax 激活函数；</li><li>softmax 点乘 Value 值 <span class="math inline">\(v\)</span>，得到加权的每个输入向量的评分 <span class="math inline">\(v\)</span>；</li><li>相加之后得到最终的输出结果 <spanclass="math inline">\(z=∑v\)</span>。</li></ol><p>　　上面步骤的可以表示为下图的形式。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408112224146.png" style="zoom:70%;" /></p><p>　　实际计算过程中是采用基于矩阵的计算方式，那么论文中的 <spanclass="math inline">\(Q, V, K\)</span> 的计算方式如下图：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408112226087.png" style="zoom:67%;" /></p><p>　　softmax归一化过程：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408112231745.png" style="zoom:55%;" /></p><p>　　softmax分数决定了每个单词对编码当下位置（“Thinking”）的贡献。显然，已经在这个位置上的单词将获得最高的softmax 分数，上述第 3 步和第 4 步是将分数除以 8 (8是论文中使用的键向量的维数 64的平方根，这会让梯度更稳定。这里也可以使用其它值，8只是默认值)，然后通过 softmax 传递结果。softmax的作用是使所有单词的分数归一化，得到的分数都是正值且和为 1。</p><p>　　这里也就是 <span class="math inline">\(Attension\)</span>公式的计算方式。在 self-attention需要强调的最后一点是其采用了残差网络中的 short-cut结构，目的当然是解决深度学习中的退化问题，得到的最终结果下图（Self-Attention中的 short-cut连接）:</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408112237118.png" style="zoom:60%;" /></p><h3 id="multi-head-attention">4 Multi-Head Attention</h3><p>　　Multi-Head Attention 相当于 h 个不同的 self-attention的集成（ensemble），在这里我们以 h=8 举例说明。Multi-Head Attention的输出分成 3 步：</p><ol type="1"><li>将数据 <span class="math inline">\(X\)</span> 分别输入到上图所示的 8个 self-attention 中，得到 8 个加权后的特征矩阵 $Z_i,i∈1,2,...,8。</li><li>将 8 个 <span class="math inline">\(Z_i\)</span>按列拼成一个大的特征矩阵 <spanclass="math inline">\(512,64×8\)</span>。</li><li>特征矩阵经过一层全连接后得到输出 <spanclass="math inline">\(Z\)</span>。</li></ol><p>　　整个过程如下图所示：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408112326772.png" style="zoom:50%;" /></p><p>　　同 self-attention 一样，multi-head attention 也加入了 short-cut机制。现在我们已经触及了注意力的头，让我们重新审视之前的例子，不同的attention heads （注意力头）对应的 “it” attention了哪些内容。下图中的绿色和橙色线条分别表示 2 组不同的 attentinheads：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408112329630.png" /></p><p>　　当我们编码单词 "it" 时，其中一个 attention head（橙色注意力头）最关注的是"the animal"，另外一个绿色 attention head关注的是 "tired"。因此在某种意义上，"it" 在模型中的表示，融合了 "animal"和 "tire" 的部分表达。</p><h3 id="位置编码">5 位置编码</h3><p>　　截止目前为止，我们介绍的 Transformer模型并没有捕捉顺序序列的能力，也就是说无论句子的结构怎么打乱，Transformer都会得到类似的结果。换句话说，Transformer只是一个功能更强大的词袋模型而已。</p><p>　　为了解决这个问题，论文中在编码词向量时引入了位置编码（PositionEmbedding）的特征。具体地说，位置编码会在词向量中加入了单词的位置信息，这样Transformer 就能区分不同位置的单词了。</p><p>　　那么怎么编码这个位置信息呢？常见的模式有：a. 根据数据学习；b.自己设计编码规则。在这里作者采用了第二种方式。那么这个位置编码该是什么样子呢？通常位置编码是一个长度为<span class="math inline">\(d_{model}\)</span>的特征向量，这样便于和词向量进行单位加的操作，如下图：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408112341659.png" style="zoom:25%;" /></p><p>　　论文给出的编码公式如下： <span class="math display">\[PE(pos,2i)=sin(\frac{pos}{10000^\frac{2i}{d_{model}}})\]</span></p><p><span class="math display">\[PE(pos,2i+1)=cos(\frac{pos}{10000^\frac{2i}{d_{model}}})\]</span></p><p>　　在上式中，<span class="math inline">\(pos\)</span>表示单词的位置， <span class="math inline">\(i\)</span>表示单词的维度。关于位置编码的实现可在 Google开源的算法中<code>get_timing_signal_1d()</code>函数找到对应的代码。</p><p>　　自己设计编码规则的优点是不需要训练参数，而且即使在训练集中没有出现过的句子长度上也能用。作者这么设计的原因是考虑到在NLP 任务中，除了单词的绝对位置，单词的相对位置也非常重要。根据公式 <spanclass="math inline">\(sin(α+β)=sinαcosβ+cosαsinβ\)</span> 以及 <spanclass="math inline">\(cos(α+β)=cosαcosβ−sinαsinβ\)</span> ，这表明位置k+p 的位置向量可以表示为位置 k的特征向量的线性变化，这为模型捕捉单词之间的相对位置关系提供了非常大的便利。并且<strong>由于三角公式不受序列长度的限制，</strong>因此可以允许模型推断比训练期间遇到的更长的序列。（偶数位置用正弦，奇数位置用余弦）</p><p>　　如果我们假设嵌入的维数为 4，那么实际的位置编码将如下所示：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408120006778.png" style="zoom:70%;" /></p><p>　　在下图中，每行对应矢量的位置编码。因此第一行将是我们添加到输入序列中嵌入第一个单词的向量。每行包含512 个值 ，每个值介于 1 和 -1之间。我们对它们进行了颜色编码，使图案可见。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408120007651.png" style="zoom:50%;" /></p><p>　　嵌入大小为 512（列）的 20个字（行）的位置编码的真实示例。你可以看到它在中心区域分成两半。这是因为左半部分的值由一个函数（使用正弦）生成，而右半部分由另一个函数（使用余弦）生成。然后将它们连接起来以形成每个位置编码矢量。</p><h3 id="残差结构">6. 残差结构</h3><p>　　到目前为止，我们计算得到了 self-attention 的输出向量。而单层encoder里后续还有两个重要的操作：残差链接、标准化。编码器的每个子层（SelfAttention 层和FFNN）都有一个残差连接和层标准化（layer-normalization），如下图所示。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408122059434.png" style="zoom:70%;" /></p><p>　　将 Self-Attention层的层标准化（layer-normalization）和涉及的向量计算细节都进行可视化，如下所示：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408122100526.png" style="zoom:67%;" /></p><p>　　编码器和和解码器的子层里面都有层标准化（layer-normalization）。假设一个Transformer 是由 2层编码器和两层解码器组成的，将全部内部细节展示起来如下图所示。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408122102816.png" style="zoom:70%;" /></p><h3 id="解码器结构">7. 解码器结构</h3><p>　　现在我们已经介绍了编码器中的大部分概念，我们也基本知道了编码器的原理。现在让我们来看下，编码器和解码器是如何协同工作的。</p><p>　　编码器一般有多层，第一个编码器的输入是一个序列文本，最后一个编码器输出是一组序列向量，这组序列向量会作为解码器的K、V输入，其中K = V =解码器输出的序列向量表示。这些注意力向量将会输入到每个解码器的Encoder-Decoder Attention层，这有助于解码器把注意力集中到输入序列的合适位置，如下图所示。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408122115214.gif" style="zoom:50%;" /></p><p>　　解码（decoding）阶段的每一个时间步都输出一个翻译后的单词（这里的例子是英语翻译），解码器当前时间步的输出又重新作为输入Q和编码器的输出K、V共同作为下一个时间步解码器的输入。然后重复这个过程，直到输出一个结束符。如下图所示：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408122121219.gif" style="zoom:45%;" /></p><p>　　解码器中的 Self Attention 层，和编码器中的 Self Attention层的区别：</p><ol type="1"><li>在解码器里，Self Attention层只允许关注到输出序列中早于当前位置之前的单词。具体做法是：在 SelfAttention 分数经过 Softmax 层之前，屏蔽当前位置之后的那些位置（将attention score设置成负无穷）（编码器中的自注意力层中的每个单词在进行注意力运算时，可以看到整个序列中所有的单词）。</li><li>解码器 self-attention 层是使用前一层的输出来构造 Query 矩阵，而 Key矩阵和 Value 矩阵来自于编码器最终的输出。</li></ol><h3 id="线性层和softmax">8. 线性层和softmax</h3><p>　　Decoder最终的输出是一个向量，其中每个元素是浮点数。我们怎么把这个向量转换为单词呢？这是线性层和softmax 完成的。</p><p>　　线性层就是一个普通的全连接神经网络，可以把解码器输出的向量，映射到一个更大的向量，这个向量称为logits 向量：假设我们的模型有 10000 个英语单词（模型的输出词汇表），此logits 向量便会有 10000 个数字，每个数表示一个单词的分数。然后，Softmax层会把这些分数转换为概率（把所有的分数转换为正数，并且加起来等于1）。然后选择最高概率的那个数字对应的词，就是这个时间步的输出单词。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408131014310.png" style="zoom:60%;" /></p><h3 id="损失函数">9. 损失函数</h3><p>　　损失函数（LossFunction）是一种衡量模型预测输出与实际目标之间的不匹配程度的方法，它将预测误差转化为一个非负实数值，这个值越小，说明模型的预测效果越好。在机器学习和深度学习中，通过优化算法（如梯度下降）最小化损失函数来调整模型参数，从而提升模型的性能。</p><p>　　Transformer 训练的时候，需要将解码器的输出和 label一同送入损失函数，以获得 loss，最终模型根据 loss进行方向传播。我们用一个简单的例子来说明训练过程的loss计算：把“merci”翻译为“thanks”。</p><p>　　我们希望模型解码器最终输出的概率分布，会指向单词 ”thanks“（在“thanks”这个词的概率最高）。但是，一开始模型还没训练好，它输出的概率分布可能和我们希望的概率分布相差甚远，如下图所示，正确的概率分布应该是“thanks”单词的概率最大。但是，由于模型的参数都是随机初始化的，所示一开始模型预测所有词的概率几乎都是随机的。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408131040981.png" style="zoom:40%;" /></p><p>　　只要 Transformer解码器预测了组概率，我们就可以把这组概率和正确的输出概率做对比，然后使用反向传播来调整模型的权重，使得输出的概率分布更加接近整数输出。</p><p>　　那我们要怎么比较两个概率分布呢？：我们可以简单的用两组概率向量的空间距离作为loss（向量相减，然后求平方和，再开方），当然也可以使用交叉熵(cross-entropy) 和 KL 散度(Kullback–Leibler divergence)。</p><p>　　我们可以再看一个复杂一点的句子。句子输入是：“je suis étudiant”，输出是：“i am a student”。这意味着，我们的 transformer模型解码器要多次输出概率分布向量：</p><ul><li>每次输出的概率分布都是一个向量，长度是 vocab_size</li><li>第1次输出的概率分布中，最高概率对应的单词是 “i”</li><li>第2次输出的概率分布中，最高概率对应的单词是 “am”</li><li>以此类推，直到第 5 个概率分布中，最高概率对应的单词是“&lt;eos&gt;”，表示没有下一个单词了</li></ul><p>于是我们目标的概率分布长下面这个样子：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408131044021.png" style="zoom:60%;" /></p><p>　　我们用例子中的句子训练模型，希望产生图中所示的概率分布，我们的模型在一个足够大的数据集上，经过足够长时间的训练后，希望输出的概率分布如下图所示：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408131046633.png" style="zoom:60%;" /></p><p>　　我们希望模型经过训练之后可以输出的概率分布也就对应了正确的翻译。当然，如果你要翻译的句子是训练集中的一部分，那输出的结果并不能说明什么。我们希望模型在没见过的句子上也能够准确翻译。</p><p>额外提一下 greedy decoding 和 beam search 的概念：</p><ul><li>Greedydecoding：由于模型每个时间步只产生一个输出，我们这样看待：模型是从概率分布中选择概率最大的词，并且丢弃其他词。这种方法叫做贪婪解码（greedydecoding）。</li><li>Beam search：每个时间步保留 k个最高概率的输出词，然后在下一个时间步，根据上一个时间步保留的 k个词来确定当前应该保留哪 k个词。假设k=2，第一个位置概率最高的两个输出的词是”I“和”a“，这两个词都保留，然后根据第一个词计算第2 个位置的词的概率分布，再取出第 2 个位置上 2个 概率最高的词。对于第 3个位置和第 4 个位置，我们也重复这个过程。这种方法称为集束搜索(beamsearch)。</li></ul><p><ahref="https://www.cnblogs.com/liuxiaochong/p/14380224.html#26-%E6%AE%8B%E5%B7%AE%E7%BB%93%E6%9E%84">【参考1】</a></p><p><ahref="https://github.com/datawhalechina/learn-nlp-with-transformers/blob/main/docs/%E7%AF%87%E7%AB%A02-Transformer%E7%9B%B8%E5%85%B3%E5%8E%9F%E7%90%86/2.2-%E5%9B%BE%E8%A7%A3transformer.md">【参考2】</a></p><ul><li>《Attention Is All You Need》链接地址：https://arxiv.org/abs/1706.03762</li><li>《Transformer: A Novel Neural Network Architecture for LanguageUnderstanding》链接地址：https://ai.googleblog.com/2017/08/transformer-novel-neural-network.html阅读《Tensor2Tensor announcement》</li></ul>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NLP——Encoder-Decoder &amp; Attention 机制</title>
    <link href="/2024/08/10/NLP%E2%80%94%E2%80%94Encoder-Decoder&amp;Attention-%E6%9C%BA%E5%88%B6/"/>
    <url>/2024/08/10/NLP%E2%80%94%E2%80%94Encoder-Decoder&amp;Attention-%E6%9C%BA%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="encoder-decoder">1. Encoder-Decoder</h3><h4 id="encoder-decoder结构">1.1 Encoder-Decoder结构</h4><p>　　目前大多数的注意力模型都是依附在 Encoder-Decoder框架下，但并不是只能运用在该模型中，注意力机制作为一种思想可以和多种模型进行结合，其本身不依赖于任何一种框架。</p><p>　　具体实现 Encoder-Decoder的时候，编码器和解码器都不是固定的，可选的有 CNN/RNN/BiRNN/GRU/LSTM等等，你可以自由组合。比如说，你在编码时使用BiRNN，解码时使用RNN，或者在编码时使用 RNN，解码时使用 LSTM 等等。例如在Image Caption 的应用中 Encoder-Decoder 就是 CNN-RNN 的编码 -解码框架；在神经网络机器翻译中 Encoder-Decoder 往往就是 LSTM-LSTM 的编码- 解码框架，在机器翻译中也被叫做 <ahref="https://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf">Sequenceto Sequence learning</a> 。</p><blockquote><p>所谓编码，就是将输入的序列编码成一个固定长度的向量；解码，就是将之前生成的固定向量再解码成输出序列。这里的输入序列和输出序列正是机器翻译的结果和输出。</p></blockquote><p>　　为了说明 Attention 机制的作用，以 Encoder-Decoder框架下的机器翻译的应用为例，该框架的抽象表示如下图：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408101856639.png" style="zoom:70%;" /></p><p>　　为了方便阐述，在选取 Encoder 和 Decoder 时都假设其为 RNN。在 RNN中，当前时刻隐藏状态 h<sub>t</sub> 是由上一时刻的隐藏状态h<sub>t−1</sub> 和当前时刻的输入 x<sub>t</sub>决定的，如下公式所示：</p><p><span class="math display">\[h_t=f(h_{t−1},x_t)\]</span></p><p>　　在<strong>编码阶段</strong>，获得各个时刻的隐藏层状态后，通过把这些隐藏层的状态进行汇总，可以生成最后的语义编码向量C，如下公式所示，其中 q 表示某种非线性神经网络，此处表示多层 RNN 。<span class="math display">\[C=q(h_1,h_2,⋯,h_{T_x})\]</span>　　在一些应用中，也可以直接将最后的隐藏层编码状态作为最终的语义编码<span class="math inline">\(C\)</span>，即满足： <spanclass="math display">\[C=q(h1,h2,⋯,h_{T_x})=h_{T_x}\]</span> 　　在 <strong>解码阶段</strong>，需要根据给定的语义向量 C和之前已经生成的输出序列 $ y1,y2,⋯,y_{t−1}$ 来预测下一个输出的单词 <spanclass="math inline">\(y_t\)</span>，即满足公式： <spanclass="math display">\[y_t=arg\ maxP(y_t)=∏^T_{t=1}p(y_t|y_1,y_2,⋯,y_{t−1},C)\]</span> 　　由于我们此处使用的 Decoder 是 RNN，所以当前状态的输出只与上一状态和当前的输入相关，所以可以将公式简写成如下形式：<span class="math display">\[y_t=g(y_{t−1},s_{t−1},C)\]</span> 　　在上面公式中，<span class="math inline">\(s_{t−1}\)</span>表示 Decoder 中 RNN 神经元的隐藏层状态，<spanclass="math inline">\(y_{t−1}\)</span> 表示前一时刻的输出，C代表的是编码后的语义向量，而 <span class="math inline">\(g(⋅)\)</span>则是一个非线性的多层神经网络，可以输出 <spanclass="math inline">\(y_t\)</span> 的概率，一般情况下是由多层 RNN 和softmax 层组成。</p><h4 id="局限性">1.2 局限性</h4><p>　　Encoder-Decoder框架虽然应用广泛，但是其存在的局限性也比较大。最大的局限性就是 Encoder和 Decoder 之间只通过一个固定长度的语义向量 C来唯一联系。也就是说，Encoder必须要将输入的整个序列的信息都压缩进一个固定长度的向量中，存在两个弊端：</p><ol type="1"><li>语义向量 C 可能无法完全表示整个序列的信息。</li><li>先输入到网络的内容携带的信息会被后输入的信息覆盖掉，输入的序列越长，该现象就越严重。</li></ol><p>这两个弊端使得 Decoder在解码时一开始就无法获得输入序列最够多的信息，因此导致解码的精确度不够准确。</p><h3 id="attention-机制">2. Attention 机制</h3><h4 id="什么是注意力机制">2.1 什么是注意力机制</h4><p>　　注意力机制是指人类的神经系统在面对复杂的感知信息时，通过选择性的关注和集中注意力来处理特定的刺激。注意力机制可以帮助我们过滤掉不相关或无用的信息，并专注于重要的刺激、任务或目标。这种机制可以通过自主调控或受到外界环境的影响而发生变化。例如，注意力可以集中于一个特定的刺激或任务，也可以在多个刺激之间进行转移和分配。注意力机制在认知过程中起着重要的作用，影响感知、思维、决策和行为等方面的表现。</p><p>　　<strong>基于注意力机制的深度学习，核心在于让机器学会去感知数据中的重要和不重要的部分</strong>。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408101812406.png" style="zoom:50%;" /></p><h4 id="attention-机制的作用">2.2 Attention 机制的作用</h4><p>　　在上述的模型中，Encoder-Decoder 框架将输入 X 都编码转化为语义表示C，这就导致翻译出来的序列的每一个字都是同权地考虑了输入中的所有的词。例如输入的英文句子是：<code>Tom chase Jerry</code>，目标的翻译结果是：<code>汤姆追逐杰瑞</code>。在未考虑注意力机制的模型当中，模型认为<code>汤姆</code> 这个词的翻译受到 <code>Tom</code>，<code>chase</code>和 <code>Jerry</code>这三个词的同权重的影响。但是实际上显然不应该是这样处理的，<code>汤姆</code>这个词应该受到输入的 <code>Tom</code>这个词的影响最大，而其它输入的词的影响则应该是非常小的。显然，在未考虑注意力机制的Encoder-Decoder模型中，这种不同输入的重要程度并没有体现处理，一般称这样的模型为<strong>分心模型</strong>。</p><p>　　而带有 Attention 机制的 Encoder-Decoder模型则是要从序列中学习到每一个元素的重要程度，然后按重要程度将元素合并。因此，注意力机制可以看作是Encoder 和 Decoder 之间的接口，它向 Decoder 提供来自每个 Encoder隐藏状态的信息。通过该设置，模型能够选择性地关注输入序列的有用部分，从而学习它们之间的“对齐”。这就表明，在Encoder 将输入的序列元素进行编码时，得到的不在是一个固定的语义编码 C，而是存在多个语义编码，且不同的语义编码由不同的序列元素以不同的权重参数组合而成。一个简单地体现Attention 机制运行的示意图如下：</p><blockquote><p><strong>定义：对齐</strong></p><p>对齐是指将原文的片段与其对应的译文片段进行匹配。</p></blockquote><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408110009932.png" style="zoom:80%;" /></p><p>　　在 Attention 机制下，语义编码 C 就不在是输入序列 X的直接编码了，而是各个元素按其重要程度加权求和得到的，即： <spanclass="math display">\[Ci=∑^{T_x}_{j=0}a_{ij}f(x_j)\]</span> 　　上面公式中，参数 i 表示时刻， j 表示序列中的第 j 个元素，<span class="math inline">\(T_x\)</span> 表示序列的长度， <spanclass="math inline">\(f(⋅)\)</span> 表示对元素 <spanclass="math inline">\(x_j\)</span> 的编码。<spanclass="math inline">\(a_{ij}\)</span> 可以看作是一个概率，反映了元素<span class="math inline">\(h_j\)</span> 对 <spanclass="math inline">\(C_i\)</span> 的重要性，可以使用 softmax 来表示：<span class="math display">\[a_{ij}=\frac{exp(e_{ij})}{∑^{T_x}_{k=1}exp(e_{ik})}\]</span> 　　这里 <span class="math inline">\(e_{ij}\)</span>正是反映了待编码的元素和其它元素之间的匹配度，当匹配度越高时，说明该元素对其的影响越大，则<span class="math inline">\(a_{ij}\)</span> 的值也就越大。</p><p>　　因此，得出 aijaij 的过程如下图：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408110021709.png" style="zoom:80%;" /></p><p>　　其中，<span class="math inline">\(h_i\)</span> 表示 Encoder的转换函数，<span class="math inline">\(F(h_j,H_i)\)</span>表示预测与目标的匹配打分函数。将以上过程串联起来，则注意力模型的结构如下图所示：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408110024233.png" /></p><h4 id="attention-原理">2.3 Attention 原理</h4><p>　　Attention 机制的一个重点就是获得 attentionvalue，即机器翻译中的语义编码 <spanclass="math inline">\(C_i\)</span>。在上一节中我们知道该值是通过输入元素按照不同的权重参数组合而成的，所以我们可以将其定义为一个attention 函数，比较主流的 attention函数的机制是采用键值对查询的方式，其工作实质如下图所示：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408110029239.png" style="zoom:80%;" /></p><p>　　在自然语言任务中，往往 Key 和 Value是相同的。需要注意的是，计算出来的 attention value是一个向量，代表序列元素 <span class="math inline">\(x_j\)</span>的编码向量，包含了元素 <span class="math inline">\(x_j\)</span>的上下文关系，即同时包含全局联系和局部联系。全局联系很好理解，因为在计算时考虑了该元素与其他所有元素的相似度计算；而局部联系则是因为在对元素<span class="math inline">\(x_j\)</span>进行编码时，重点考虑与其相似度较高的局部元素，尤其是其本身。</p><p>　　阅读到一篇有关 <ahref="https://mp.weixin.qq.com/s?__biz=Mzg5ODAzMTkyMg==&amp;mid=2247485860&amp;idx=1&amp;sn=e926a739784090b3779711164217b968&amp;chksm=c06981f9f71e08efb5f57441444f71a09f1d27fc667af656a5ad1173e32ad394201d02195a3a&amp;mpshare=1&amp;scene=1&amp;srcid=0618HMAYi4gzzwWfedLoOuSD&amp;key=cb6098335ab487a8ec84c95399379f16f975d33ce91588d73ecf857c54b543666b5927e231ad3a9b17bff0c20fff20fc49c262912dca050dee9465801de8a4cdc79e3d8f4fbc058345331fb691bcbacb&amp;ascene=1&amp;uin=MTE3NTM4MTY0NA%3D%3D&amp;devicetype=Windows+10&amp;version=62060833&amp;lang=zh_CN&amp;pass_ticket=ikhBXxX7PL%2Fal9hbIGXbRFA96ei74EF%2BcP8KdbP6UcV6mIpOfPWzVuju%2Bqw86q5r">动画图解Attention机制</a>的文章，这里主要是对 Attention层的实现做下总结，详细内容请查看原文。注意力机制可以看作是神经网络架构中的一层神经网络，注意力层的实现可以分为6 个步骤。</p><p>　　<strong>Step 0：准备隐藏状态</strong></p><p>　　首先准备第一个 Decoder 的隐藏层状态（红色）和所有可用的 Encoder隐藏层状态（绿色）。在示例中，有 4 个 Encoder 隐藏状态和 1 个 Decoder隐藏状态。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408110033730.gif" style="zoom:80%;" /></p><p>　　<strong>Step 1：得到每一个 Encoder 隐藏状态的得分</strong></p><p>　　分值（score）由 <code>score</code>函数来获得，最简单的方法是直接用 Decoder 隐藏状态和 Encoder中的每一个隐藏状态进行点积。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408110035322.gif" style="zoom:80%;" /></p><p>　　假设 Decoder 中的隐藏状态为 <code>[5, 0, 1]</code>，分别与Encoder中的每个隐藏状态做点积，得到第二个隐藏状态的分值最高，说明下一个要解码的元素将受到当前这种隐藏状态的严重影响。</p><figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs inform7">decoder_hidden = <span class="hljs-comment">[10, 5, 10]</span><br>encoder_hidden score<br>---------------------<br>     <span class="hljs-comment">[0, 1, 1]</span>     15 (= 10×0 + 5×1 + 10×1, the dot product)<br>     <span class="hljs-comment">[5, 0, 1]</span>     60<br>     <span class="hljs-comment">[1, 1, 0]</span>     15<br>     <span class="hljs-comment">[0, 5, 1]</span>     35<br></code></pre></td></tr></table></figure><p><strong>Step 2：将所有得分送入 softmax 层</strong></p><p>　　该部分实质上就是对得到的所有分值进行归一化，这样<code>softmax</code> 之后得到的所有分数相加为1。而且能够使得原本分值越高的隐藏状态，其对应的概率也越大，从而抑制那些无效或者噪音信息。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408110041387.gif" style="zoom:80%;" /></p><p>　　通过 softmax层后，可以得到一组新的隐藏层状态分数，其计算方法即为公式 <spanclass="math inline">\(a_{ij}=\frac{exp(e_{ij})}{∑^{T_x}_{k=1}exp(e_{ik})}\)</span>。注意，此处得到的分值应该是浮点数，但是由于无限接近于0 和 1，所以做了近似。</p><figure class="highlight asciidoc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs asciidoc"><span class="hljs-section">encoder_hidden score score^</span><br><span class="hljs-section">-----------------------------</span><br><span class="hljs-code">     [0, 1, 1]     15       0</span><br><span class="hljs-code">     [5, 0, 1]     60       1</span><br><span class="hljs-code">     [1, 1, 0]     15       0</span><br><span class="hljs-code">     [0, 5, 1]     35       0</span><br></code></pre></td></tr></table></figure><p><strong>Step 3：用每个 Encoder 的隐藏状态乘以 softmax之后的得分</strong></p><p>　　通过将每个编码器的隐藏状态与其 softmax之后的分数(标量)相乘，我们得到 对齐向量或标注向量。这正是对齐产生的机制</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408110045703.gif" style="zoom:80%;" /></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs css">encoder score score^ alignment<br> ---------------------------------<br> <span class="hljs-selector-attr">[0, 1, 1]</span>   <span class="hljs-number">15</span>     <span class="hljs-number">0</span>   <span class="hljs-selector-attr">[0, 0, 0]</span><br> <span class="hljs-selector-attr">[5, 0, 1]</span>   <span class="hljs-number">60</span>     <span class="hljs-number">1</span>   <span class="hljs-selector-attr">[5, 0, 1]</span><br> <span class="hljs-selector-attr">[1, 1, 0]</span>   <span class="hljs-number">15</span>     <span class="hljs-number">0</span>   <span class="hljs-selector-attr">[0, 0, 0]</span><br> <span class="hljs-selector-attr">[0, 5, 1]</span>   <span class="hljs-number">35</span>     <span class="hljs-number">0</span>   <span class="hljs-selector-attr">[0, 0, 0]</span><br></code></pre></td></tr></table></figure><p><strong>Step 4：将所有对齐的向量进行累加</strong></p><p>　　对对齐向量进行求和，生成 <em>上下文向量</em>。上下文向量是前一步的对齐向量的聚合信息。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408110047508.gif" style="zoom:80%;" /></p><p>　　该步骤其实就对应了公式<spanclass="math inline">\(Ci=∑^{T_x}_{j=0}a_{ij}f(x_j)\)</span>，得到最终的编码后的向量来作为Decoder 的输入，其编码后的向量为 <code>[5, 0, 1]</code>。</p><p><strong>Step 5：把上下文向量送到 Decoder 中</strong></p><p>　　通过将上下文向量和 Decoder的上一个隐藏状态一起送入当前的隐藏状态，从而得到解码后的输出。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408110050506.gif" style="zoom:80%;" /></p><p>　　最终得到完整的注意力层结构如下图所示：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408110051647.png" style="zoom:80%;" /></p><h4 id="attention-机制的优劣">2.4 Attention 机制的优劣</h4><p>　　相比于传统的 RNN 和 CNN，attention 机制具有如下优点：</p><ul><li>一步到位的全局联系捕捉，且关注了元素的局部联系；attention 函数在计算attention value时，是进行序列的每一个元素和其它元素的对比，在这个过程中每一个元素间的距离都是一；而在时间序列RNNs中，元素的值是通过一步步递推得到的长期依赖关系获取的，而越长的序列捕捉长期依赖关系的能力就会越弱。</li><li>并行计算减少模型训练时间；Attention机制每一步的计算都不依赖于上一步的计算结果，因此可以并行处理。</li><li>模型复杂度小，参数少</li></ul><p>　　但 attention机制的缺点也比较明显，因为是对序列的所有元素并行处理的，所以无法考虑输入序列的元素顺序，这在自然语言处理任务中比较糟糕。因为在自然语言中，语言的顺序是包含了十分多的信息的，如果缺失了该部分的信息，则得到的结果往往会大大折扣。</p><h4 id="总结">2.5 总结</h4><p>　　简而言之，Attention机制就是对输入的每个元素考虑不同的权重参数，从而更加关注与输入的元素相似的部分，而抑制其它无用的信息。其最大的优势就是能一步到位的考虑全局联系和局部联系，且能并行化计算，这在大数据的环境下尤为重要。同时，我们需要注意的是Attention 机制作为一种思想，并不是只能依附在 Encoder-Decoder框架下的，而是可以根据实际情况和多种模型进行结合。</p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>NLP——RNN、LSTM、GRU、CNN、Seq2Seq</title>
    <link href="/2024/08/10/NLP%E2%80%94%E2%80%94RNN%E3%80%81LSTM%E3%80%81GRU%E3%80%81CNN%E3%80%81Seq2Seq/"/>
    <url>/2024/08/10/NLP%E2%80%94%E2%80%94RNN%E3%80%81LSTM%E3%80%81GRU%E3%80%81CNN%E3%80%81Seq2Seq/</url>
    
    <content type="html"><![CDATA[<h3 id="seq2seq">1. Seq2Seq</h3><p>　　Seq2Seq（即Sequence-to-sequence），输入一个序列，输出另一个序列。这种结构最重要的地方在于输入序列和输出序列的长度是可变的。例如下图：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408092150188.gif" style="zoom:70%;" /></center><p>　　如上图：输入了 6 个汉字，输出了 3个英文单词。输入和输出的长度不同。</p><p><strong>Seq2Seq 的由来</strong></p><p>　　在 Seq2Seq框架提出之前，深度神经网络在图像分类等问题上取得了非常好的效果。在其擅长解决的问题中，输入和输出通常都可以表示为固定长度的向量，如果长度稍有变化，会使用补零等操作。</p><p>　　然而许多重要的问题，例如机器翻译、语音识别、自动对话等，表示成序列后，其长度事先并不知道。因此如何突破先前深度神经网络的局限，使其可以适应这些场景，成为了13年以来的研究热点，Seq2Seq框架应运而生。</p><p><strong>「Seq2Seq」和「Encoder-Decoder」的关系</strong></p><p>　　Seq2Seq（强调目的）不特指具体方法，满足「输入序列、输出序列」的目的，都可以统称为Seq2Seq 模型。而 Seq2Seq 使用的具体方法基本都属于 Encoder-Decoder模型（强调方法）的范畴。</p><p>　　总结一下的话：</p><ul><li>Seq2Seq 属于 Encoder-Decoder 的大范畴</li><li>Seq2Seq 更强调目的，Encoder-Decoder 更强调方法</li></ul><p>　　<ahref="https://easyai.tech/ai-definition/encoder-decoder-seq2seq/">传送门</a></p><h3 id="rnn">2. RNN</h3><p>　　RNN 即 Recurrent NeuralNetwork，循环神经网络，也有人将它翻译为递归神经网络。从这个名字就可以想到，它的结构中存在着“环”。确实，RNN和 NN/DNN 的数据单一方向传递不同。RNN的神经元接受的输入除了“前辈”的输出，还有自身的状态信息，其状态信息在网络中循环传递。</p><h4 id="单层网络">2.1 单层网络</h4><p>　　首先来了解一下最基本的单层网络，它的结构如图：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082027402.png" style="zoom:33%;" /></center><p>　　<code>输入是 x</code>，经过<code>变换Wx+b</code> 和<code>激活函数f</code> 得到<code>输出y</code>。</p><blockquote><p><code>w</code>是模型的权重参数，它决定了每个输入特征对输出的贡献程度。<code>b</code>是模型的偏置参数，它控制着输出的整体水平。</p></blockquote><h4 id="rnn结构n-vs-n">2.2 RNN结构（N vs N）</h4><p>　　在实际应用中，我们还会遇到很多序列型的数据：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082035078.png" style="zoom:33%;" /></center><p>　　如：</p><ul><li>自然语言处理问题。x1 可以看做是第一个单词，x2可以看做是第二个单词，依次类推。</li><li>语音处理。此时，x1、x2、x3……是每帧的声音信号。</li></ul><p>　　序列型的数据就不太好用原始的神经网络处理了。为了建模序列问题，RNN引入了隐状态 h（hidden state）的概念，h可以对序列形的数据提取特征，接着再转换为输出。先从h1的计算开始看：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082041437.png" style="zoom:33%;" /></center><ul><li>h1: 表示 t=1 时刻的隐状态</li><li>U: 输入层到隐含层的权值矩阵</li><li>x1: t=1 时刻的输入状态</li><li>W: 隐含层到隐含层的权值矩阵</li><li>b: 偏置元</li><li>f: 激活函数</li></ul><p>　　图示中记号的含义是：</p><ul><li>圆圈或方块表示的是向量。</li><li><code>一个箭头就表示对该向量做一次变换</code>。如上图中 h0 和 x1分别有一个箭头连接，就表示对 h0 和 x1 各做了一次变换。</li></ul><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082100270.png" style="zoom:33%;" /></center><p>　　h2 的计算和h1类似。要注意的是，<code>在计算时，每一步使用的参数 U、W、b 都是一样的，也就是说每个步骤的参数都是共享的</code>，这是RNN 的重要特点，一定要牢记。</p><blockquote><p>注意：图中的 h并不是一个神经元，而是一个神经网络块，可以简单理解为神经网络的一个隐层。</p></blockquote><p>　　依次计算剩下来的 h3、h4（使用相同的参数U、W、b）：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082101771.png" style="zoom:33%;" /></center><p>　　目前我们的 RNN 还没有输出，得到输出值的方法就是直接通过 h进行计算。正如之前所说，一个箭头就表示对对应的向量做一次类似于 f(Wx+b)的变换，这里的这个箭头就表示对 h1进行一次变换，得到输出 y1：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082102386.png" style="zoom:33%;" /></center><ul><li>y1：表示 t=1 时刻的输出状态</li><li>softmax：是一种激活函数，它可以把输入转化为概率分布的形式</li><li>V：隐含层到输出层的权值矩阵</li><li>h1：t=1 时刻的隐状态</li><li>c：偏置元</li></ul><p>　　剩下的输出类似进行（使用和y1同样的参数V和c）：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082106129.png" style="zoom: 33%;" /></center><p>　　OK！大功告成！这种输入序列长度为 N 且输出序列长度也为 N 的 RNN就是最经典的 RNN 结构，我们像搭积木一样把它搭好了。它的输入是 x1, x2,…xn，输出为 y1, y2, …yn，也就是说，输入和输出序列必须要是等长的。</p><p>　　由于这个限制的存在，经典 RNN的适用范围比较小，但也有一些问题适合用经典的 RNN 结构建模，如：</p><ul><li>计算视频中每一帧的分类标签。因为要对每一帧进行计算，因此输入和输出序列等长。</li><li>输入为字符，输出为下一个字符的概率。</li></ul><h4 id="n-vs-1">2.3 N VS 1</h4><p>　　有的时候，我们要处理的问题输入是一个序列，输出是一个单独的值而不是序列，应该怎样建模呢？实际上，我们只在最后一个h上进行输出变换就可以了：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082113077.png" style="zoom:33%;" /></center><p>　　这种结构通常用来处理序列分类问题。如输入一段文字判别它所属的类别，输入一个句子判断其情感倾向，输入一段视频并判断它的类别等等。</p><h4 id="vs-n">2.4 1 VS N</h4><p>　　输入不是序列而输出为序列的情况怎么处理？我们可以只在序列开始进行输入计算：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082115557.png" style="zoom:33%;" /></center><p>　　还有一种结构是把输入信息X作为每个阶段的输入（右图省略了一些X的圆圈，是一个等价表示）：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082118203.png" style="zoom:33%;" /></center><p>　　这种1 VS N的结构可以处理的问题有：</p><ul><li>从图像生成文字（imagecaption），此时输入的X就是图像的特征，而输出的y序列就是一段句子</li><li>从类别生成语音或音乐等</li></ul><h4 id="n-vs-m">2.5 N vs M</h4><p>　　下面我们来介绍 RNN 最重要的一个变种：N vs M。</p><p>　　原始的 N vs N RNN要求序列等长，然而我们遇到的大部分问题序列都是不等长的，如机器翻译中，源语言和目标语言的句子往往并没有相同的长度。</p><p>　　为此，Encoder-Decoder结构先将输入数据编码成一个上下文向量c（context vector）：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082119369.png" style="zoom:30%;" /></center><p>　　得到 c 有多种方式，最简单的方法就是把 Encoder的最后一个隐状态赋值给c，还可以对最后的隐状态做一个变换得到c，也可以对所有的隐状态做变换，可以表示为下面三种方式：</p><ul><li>c = h <sub>4</sub></li><li>c = f(h <sub>4</sub>)</li><li>c= g(h <sub>1</sub>,h <sub>2</sub>,h <sub>3</sub>,h<sub>4</sub>)</li></ul><p>　　拿到 c 之后，就用另一个 RNN 网络对其进行解码，这部分 RNN网络被称为 Decoder。具体做法就是将 c 当做之前的初始状态 h0 输入到Decoder中：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082128634.png" style="zoom:50%;" /></center><p>　　还有一种做法是将c当做每一步的输入：</p><center><img src="https://i-blog.csdnimg.cn/blog_migrate/a94c808e4734a3b0482c20e027b2c88c.png" alt="decoder" style="zoom:50%;" /></center><p>　　Decoder 是 Encoder 的逆过程，每个状态由之前的状态和 contextvector 决定，即：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082131791.png" style="zoom:50%;" /></center><p>　　由于这种 Encoder-Decoder结构不限制输入和输出的序列长度，因此应用的范围非常广泛，比如：</p><ul><li>机器翻译。Encoder-Decoder 的最经典应用，事实上这一结构就是在机器翻译- 领域最先提出的</li><li>文本摘要。输入是一段文本序列，输出是这段文本序列的摘要序列。</li><li>阅读理解。将输入的文章和问题分别编码，再对其进行解码得到问题的答案。</li><li>语音识别。输入是语音信号序列，输出是文字序列。 ……</li></ul><p>　　上面提到：Encoder 和 Decoder 之间只有一个「向量 C」来传递信息，且C 的长度固定。这样做有两个弊端：</p><ol type="1"><li>语义向量无法完全表示整个序列的信息。</li><li>当句子长度较大时，容易丢失信息。</li></ol><p>　　针对信息丢失这个问题，后面提出了 Seq2Seq+Attention 的模型。</p><h3 id="lstm">3. LSTM</h3><p>　　长短时记忆（Long Short Term Memory，LSTM）</p><p>　　LSTM也是一种RNN，因此它也是一种循环结构，不同的是RNN神经元内部只用tan层进行计算，而LSTM是有4个全连接层进行计算的，LSTM的内部结构如下图所示。</p><p>　　相较于构造简单的 RNN 神经元，LSTM的神经元要复杂得多，每个神经元接受的输入除了当前时刻样本输入，上一个时刻的输出，还有一个元胞状态（CellState），LSTM 神经元结构请参见下图：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408092042460.png" style="zoom:80%;" /></center><p>　　上图中符号的含义如下图所示，黄色方框类似于CNN中的激活函数操作，粉色圆圈表示点操作，单箭头表示数据流向，下图中第四个符号表示两个向量的连接操作，第五个符号表示向量的拷贝操作，且上图中的σ表示sigmoid层(该层的输出时0-1的值，0表示不能通过，1表示能通过)。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408092043785.png" style="zoom:80%;" /></center><p>　　现在来描述LSTM的内部操作，具体内容如下图所示：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408092044477.png" style="zoom:60%;" /></center><p>　　LSTM的核心是细胞状态——最上层的横穿整个细胞的水平线，它通过门来控制信息的增加或者删除。</p><p>　　那么什么是门呢？门是一种用来选择信息通过与否的方式，它由一个sigmoid层和点乘操作组成。LSTM共有三个门，分别是遗忘门，输入门和输出门，具体内容如下所述：</p><p>　　(1)遗忘门：遗忘门决定丢弃哪些信息，输入是上一个神经元细胞的计算结果ht-1以及当前的输入向量xt,二者联接并通过遗忘门后(sigmoid会决定哪些信息留下，哪些信息丢弃)，会生成一个0-1向量Γft(维度与上一个神经元细胞的输出向量Ct-1相同)，Γft与Ct-1进行点乘操作后，就会获取上一个神经元细胞经过计算后保留的信息。遗忘门控制前一步记忆单元中的信息有多大程度被遗忘掉。</p><p>　　(2)输入门：表示要保存的信息或者待更新的信息，如上图所示是ht-1与xt的连接向量，经过sigmoid层后得到的结果Γit，这就是输入门的输出结果了。但是接下来我们要计算该神经元细胞的输出结果，即新细胞的更新状态：Ct，Ct= Ct-1· Γft + Γit · <sub>ct(其中</sub>ct =tanh(ht-1，xt))，文字描述是：输入门的计算结果点乘ht-1与xt的连接向量经过tanh层计算的结果后，再与上一个神经元细胞经过计算后保留的信息进行相加，则是最终要输出的Ct。输入门控制当前计算的新状态以多大程度更新到记忆单元中。</p><p>　　(3)输出门：输出门决定当前神经原细胞输出的隐向量ht，ht与Ct不同，ht要稍微复杂一点，它是Ct进过tanh计算后与输出门的计算结果进行点乘操作后的结果，用公式描述是：ht= tanh(ct) ·Γot。输出门控制当前的输出有多大程度上取决于当前的记忆单元。</p><p>　　在一个训练好的网络中，当输入的序列中没有重要信息时，LSTM的遗忘门的值接近于1，输入门的值接近于0，此时过去的记忆会被保存，从而实现了长期记忆的功能；当输入的序列中出现了重要的信息时，LSTM应当把其存入记忆中，此时其输入门的值会接近于1；当输入的序列中出现了重要信息，且该信息意味着之前的记忆不再重要时，输入门的值接近于1，而遗忘门的值接近于0，这样旧的记忆被遗忘，新的重要信息被记忆。经过这样的设计，整个网络更容易学习到序列之间的长期依赖。</p><h4 id="lstm如何避免梯度消失与梯度爆炸">3.1LSTM如何避免梯度消失与梯度爆炸</h4><p>　　RNN 中的梯度消失/爆炸与 CNN 中的含义不同，CNN中不同的层有不同的参数，每个参数都有自己的梯度；而 RNN中同样的权重在各个时间步中共享，所以最终的梯度等于各个时间步的梯度和。因此，RNN中的梯度不会消失，它只会遗忘远距离的依赖关系，而被近距离的梯度所主导。但是LSTM中的梯度传播有很多条路径，最主要的一条是当前细胞的状态更新这一过程，该过程中只有逐元素的相乘和相加操作，梯度流最稳定，因此基本不会发生梯度消失或者梯度爆炸；但是其他的传播路径依然有梯度消失或者爆炸风险，而最终的梯度计算是各个梯度路径的和，因此LSTM 仍然有梯度消失或者爆炸的风险，只是这个风险被大幅降低了。</p><h4 id="总结">3.2 总结</h4><p>LSTM 优点：</p><p>　　LSTM 降低了梯度消失或者梯度爆炸的风险，并且比 RNN具有更强的长距离依赖能力。</p><p>LSTM 缺点：</p><ul><li>LSTM 处理长距离依赖的能力依然不够，因此 Transformer横空出世，它具有比 LSTM 更强的长距离依赖处理能力。</li><li>它的计算很费时。每个细胞中都有 4 个全连接层 (MLP)，因此如果 LSTM的时间跨度很大的话，计算量会很大也很费时。</li></ul><p>　　<ahref="https://www.cnblogs.com/liuxiaochong/p/13423872.html">LSMT理解</a></p><p>　　<ahref="http://zh.gluon.ai/chapter_recurrent-neural-networks/lstm.html">（传送门）</a></p><h3 id="gru">4. GRU</h3><p>　　GRU（Gate Recurrent Unit，循环门单元）是循环神经网络（RecurrentNeural Network, RNN）的一种。和LSTM（Long-Short TermMemory）一样，也是为了解决长期记忆和反向传播中的梯度等问题而提出来的。</p><p>　　在LSTM中引入了三个门函数：输入门、遗忘门和输出门来控制输入值、记忆值和输出值。而在GRU模型中只有两个门：分别是更新门和重置门。具体结构如下图所示：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408092202261.png" style="zoom:60%;" /></center><p>　　图中的zt和rt分别表示更新门和重置门。更新门用于控制前一时刻的状态信息被带入到当前状态中的程度，更新门的值越大说明前一时刻的状态信息带入越多。重置门控制前一状态有多少信息被写入到当前的候选集ℎ̃<em>t</em>上，重置门越小，前一状态的信息被写入的越少。</p><p>　　GRU组合了遗忘门和输入门到一个单独的更新门当中，也合并了细胞状态C和隐藏状态h，并且还做了一些其他的改变，使得其模型比标准LSTM模型更简单，其数学表达式为：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408092204759.png" /></p><p>　　其中，门控信号zt的范围为0~1。门控信号越接近1，代表”记忆“下来的数据越多；而越接近0则代表”遗忘“的越多。</p><h3 id="cnn">5. CNN</h3><p>　　CNN 是一种前馈神经网络，通常由一个或多个卷积层（ConvolutionalLayer）和全连接层（Fully Connected Layer，对应经典的NN）组成，此外也会包括池化层（Pooling Layer）。</p><p>　　CNN 的结构使得它易于利用输入数据的二维结构。</p><blockquote><p>注意：前馈神经网络（FeedforwardNN）指每个神经元只与前一层的神经元相连，数据从前向后单向传播的NN。其内部结构不会形成有向环（对比后面要讲到的 RNN/LSTM）。它是最早被发明的简单 NN 类型，前面讲到的 NN、DNN 都是前馈神经网络。</p></blockquote><p>　　每个卷积层由若干卷积单元组成——可以想象成经典 NN的神经元，只不过激活函数变成了卷积运算。</p><p>　　卷积运算是有其严格的数学定义的。不过在 CNN的应用中，卷积运算的形式是数学中卷积定义的一个特例，它的目的是提取输入的不同特征。</p><p>　　一般情况下，从直观角度来看，CNN 的卷积运算，就是下图这样：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408092145683.gif" style="zoom:80%;" /></center><blockquote><p>上图中左侧的蓝色大矩阵表示输入数据，在蓝色大矩阵上不断运动的绿色小矩阵叫做卷积核，每次卷积核运动到一个位置，它的每个元素就与其覆盖的输入数据对应元素相乘求积，然后再将整个卷积核内求积的结果累加，结果填注到右侧红色小矩阵中。卷积核横向每次平移一列，纵向每次平移一行。最后将输入数据矩阵完全覆盖后，生成完整的红色小矩阵就是卷积运算的结果。</p></blockquote><p>　　CNN经常被用于处理图像，那么对应的输入数据就是一张图片的像素信息。</p><p>　　对于这样的输入数据，第一层卷积层可能只能提取一些低级的特征，如边缘、线条、角等，更多层的网络再从低级特征中迭代提取更复杂的特征。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408092154742.png" style="zoom:80%;" /></center><p>　　<ahref="https://www.cnblogs.com/liuxiaochong/p/13463723.html">（传送门）</a></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Debug Mysql</title>
    <link href="/2023/11/05/Debug-Mysql/"/>
    <url>/2023/11/05/Debug-Mysql/</url>
    
    <content type="html"><![CDATA[<p>合集：https://www.cnblogs.com/tianyiliang/articles/17723527.html</p><p>https://www.codenong.com/cs106145348/</p><p>https://www.bilibili.com/read/cv15187227/?spm_id_from=333.999.0.0</p><h3 id="mysql基本架构">1. mysql基本架构</h3><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202311051804221.png" style="zoom:40%;" /></center><p>https://zhuanlan.zhihu.com/p/587101147</p><h3 id="查询sql执行过程">2. 查询SQL执行过程</h3><p>（1）连接器--首先客户端（python/java的mysql客户端包）创建连接，连接器为每个客户端连接创建一个新的连接线程，并校验账号密码和权限。</p><p>（2）查询缓存--如果最近已经查询过该SQL，会将 sql 和结果以 key-value的形式保存到缓存中。执行 select查询语句时，会先查询缓存，有的话直接返回结果。</p><p>（3）分析器--对 SQL 语句进行词法分析，语法分析。通过这一步，可以知道sql 要做的事情。</p><p>（4）优化器--知道 sql要做的事情，但可能有好几种方法实现。比如可以使用两个索引联合查询，到底先走哪个索引呢？这是优化器要做的事情，尽可能提高查询速度。制定一个查询扫描行数较少的执行计划。</p><p>（5）执行器--执行优化器得出的执行计划。调用存储引擎，并返回查询结果。</p><p>（6）存储引擎--存储数据，并提供读写接口</p><center><img src="https://pic2.zhimg.com/80/v2-d169d02aad0bcf7fdb825a913d4c53c5_1440w.webp" alt="img" style="zoom:40%;" /></center><p>https://zhuanlan.zhihu.com/p/589592690</p><h3 id="更新sql执行过程">3. 更新SQL执行过程</h3><p>　　(update T set c=c+1 where ID=2;)</p><p>（1）更新流程和查询流程从连接器到执行器基本都是一样流程，区别在于更新或修改数据时还涉及到两个日志模块。（redolog--重做日志 和 bin log--归档日志）</p><p>（2）mysql 有个 wal 技术（write-aheadlogging），它的关键点在于先写日志，再写磁盘。</p><p>（3）redo log 仅仅在 innodb 存储引擎存在。当执行一条update/delete/insert SQL 时，会先把记录写到 redo log里面，并更新到内存，这个时候就算完成，后面找个空闲时间将操作记录（从内存中）更新到磁盘中。</p><p>（4）有了redo log，innodb引擎可以保证即使数据库发生异常重启，之前提交的记录都不会丢失。这个能力称之为crash-safe。即使数据库突然宕机了，可以通过 redo log将数据从文件中恢复到数据库（磁盘）中。保证了四大特性中的持久性。</p><p>（5）bin log 是 server 层的，redo log 是 innodb存储引擎特有的。两个日志的区别：</p><blockquote><ol type="a"><li><p>redo log是物理日志，记录的是”在某个数据页某个值做了什么修改“。binlog是逻辑日志，记录的是SQL语句的原始逻辑，如”给id=2的那一行c字段数值+1“</p></li><li><p>redo log空间是固定的，是循环使用的。binlog是可以追加写入的，文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。binlog默认是关闭的，需要手动修改为开启。</p></li><li><p>bin log可以用于数据恢复（到某一时刻）使用，主从复制搭建。redolog作为异常宕机或者介质故障后的数据恢复使用。</p></li></ol></blockquote><p>（6）update sql执行流程图</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202311051735153.png" style="zoom:40%;" /></center><blockquote><p>这里将 redo log 的写入拆分成 prepare 和 commit两个阶段，称为“二阶段提交”。</p><p><strong>为什么必须有两阶段提交？</strong></p><p><strong>这是为了让两份日志之间的逻辑一致。</strong></p><p>可以换个角度考虑，如果不采用两阶段提交，而是先写一个日志，再写另一个日志。此时如果第一个日志写成功了，在写第二个时mysql服务器宕机了，导致第二个写入失败了。会导致binlog和redo log所记录的数据不一致。在后面使用binlog进行数据恢复时，或者使用redolog进行宕机后的数据重新写入数据库，状态不一致。</p><p><strong>所以，“两阶段提交”的提交就像原子性的作用一样，让这两个日志保持逻辑上的一致。</strong></p></blockquote><p>　　https://blog.csdn.net/Huangjiazhen711/article/details/127861169</p><h3 id="redo-logundo-log和binlog">4. redo log、undo log和binlog</h3><p>　　https://zhuanlan.zhihu.com/p/647473227</p><h3 id="redo-log-崩溃恢复过程">5. Redo Log 崩溃恢复过程</h3><p>　　https://blog.csdn.net/m0_71777195/article/details/130842268</p><p>　　<code>两次写</code><code>double write</code>，它包含<code>内存缓冲区</code>和<code>dblwr 文件</code>两个部分，InnoDB脏页刷盘前，都会先把脏页写入内存缓冲区，再写入 dblwr文件，成功之后才会把脏页刷盘。</p><h3 id="索引">6. 索引</h3><ul><li>索引类型</li><li>索引失效</li></ul><p>　　https://zhuanlan.zhihu.com/p/635230263</p><p>　　https://zhuanlan.zhihu.com/p/430626707</p><p>　　索引优化：</p><p>　　https://zhuanlan.zhihu.com/p/258467069</p><p>　　https://zhuanlan.zhihu.com/p/613108218</p><p>　　<strong>深度分页慢sql原因：</strong></p><p>　　https://blog.csdn.net/xiaoshitou_2015/article/details/130027651</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202311122052642.png" style="zoom:50%;" /></center><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202311122053442.png" style="zoom:50%;" /></center><p>　　MySQL索引失效原理是什么？</p><p>　　https://www.zhihu.com/question/421944348/answer/3075704071</p><h3 id="事务">7. 事务</h3><p>　　https://zhuanlan.zhihu.com/p/425443526</p><p>　　https://zhuanlan.zhihu.com/p/129860691</p><p>　　https://zhuanlan.zhihu.com/p/117476959</p><h3 id="锁">８.锁</h3><p>　　https://zhuanlan.zhihu.com/p/570570330</p><p>　　https://blog.csdn.net/Prior_SX/article/details/124567724</p><h3 id="ddldmldqldcl">９.DDL、DML、DQL、DCL</h3><p>　　https://www.jianshu.com/p/9ccf80bad7c6</p><p>　　DDL 优化</p><h3 id="mysql是如何保证主从库数据一致性的">10.MySQL是如何保证主从库数据一致性的？</h3><p>https://mp.weixin.qq.com/s?__biz=MzAxOTc1OTY4NA==&amp;mid=2650858366&amp;idx=1&amp;sn=0aaef3c4877bd605afbb71c25324125c&amp;chksm=80365455b741dd43e99953638695a73b432d44b8362d1be4034029be387e800a0ad54abdb15c&amp;scene=27</p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Debug 算法</title>
    <link href="/2023/10/31/Debug-%E7%AE%97%E6%B3%95/"/>
    <url>/2023/10/31/Debug-%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="数组的最大连续子数组之和kadane算法">1.数组的最大连续子数组之和——kadane算法</h3><p>https://zhuanlan.zhihu.com/p/85188269</p><h3 id="另一棵树的子树">2. <ahref="https://leetcode.cn/problems/subtree-of-another-tree/">另一棵树的子树</a></h3><h3 id="买卖股票的最佳时机">3. <ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></h3><h3 id="买卖股票的最佳时机-ii">4. <ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机II</a></h3><h3 id="买卖股票的最佳时机-iii">5. <ahref="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机III</a></h3><h3 id="寻找峰值">6. <ahref="https://leetcode.cn/problems/find-peak-element/">寻找峰值</a></h3><h3 id="最小路径和">7. <ahref="https://leetcode.cn/problems/minimum-path-sum/">最小路径和</a></h3><h3 id="最长递增子序列">8. <ahref="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a></h3><h3 id="寻找明星">9. 寻找明星</h3><p>https://www.cnblogs.com/bvac/p/6382761.html</p><p>红黑树</p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Debug web</title>
    <link href="/2023/10/24/Debug-web/"/>
    <url>/2023/10/24/Debug-web/</url>
    
    <content type="html"><![CDATA[<h3 id="http-版本">1. http 版本</h3><p>参考：https://zhuanlan.zhihu.com/p/594274411</p><p>1.0 版本：链接无法复用，即不支持长链接。</p><h4 id="http1.---http1.1">1.1 HTTP/1. -&gt; HTTP/1.1</h4><p>　　HTTP/1.1 是目前最常见的 HTTP 版本，其相对于 HTTP/1.0有以下改进。</p><h5 id="持久连接">① 持久连接</h5><p>　　HTTP/1.0 中一个 TCP 连接只能发送一个请求和响应，而 HTTP/1.1进行了优化，同一个 TCP 连接可以发送多次 HTTP请求，减少了建立和关闭连接的性能开销。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240041289.png" style="zoom:70%;" /></center><p>HTTP（1.1 及之后）默认采用<strong>持续连接</strong>方式，但也可配置成非持续连接方式。在报文中使用<code>Connection</code> 字段来表示是否使用持久连接。</p><ul><li>如果 <code>Connection</code> 字段的值为<code>keep-alive</code>，则表明此连接为持久连接，HTTP1.1及以后可默认不写。</li><li>如果 <code>Connection</code> 字段的值为<code>close</code>，则表明要关闭连接。</li></ul><p>Web 服务软件一般都会提供 <code>keepalive_timeout</code>参数，用来指定 HTTP 持久连接的超时时间。比如设置了 HTTP持久连接的超时时间是 60 秒，Web 服务软件就会启动一个定时器，如果完成某个HTTP 请求后，在 60秒内都没有再发起新的请求，就会触发回调函数来释放该连接。</p><h5 id="管道机制">② 管道机制</h5><p>　　持久连接虽然可以多个请求复用同一个连接，但是每次都需要等到上一个请求响应完成后，才能发送下一个请求。</p><p>　　管道机制中，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，即相当于同时发出多个请求，因而可以减少整体的响应时间。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240046998.png" style="zoom:70%;" /></center><p>　　<strong>虽然客户端可以同时发出多个 HTTP请求，不用⼀个个等待响应，但是服务器必须按照接收请求的顺序依次发送对这些管道化请求的响应</strong>，以保证客户端能够区分出每次请求的响应内容。这存在下面问题：</p><ol type="1"><li><p>如果服务端在处理一个请求时耗时比较长，那么后续请求的处理都会被阻塞住，会导致客户端迟迟收不到数据，这称为「<strong>队头堵塞</strong>」。</p></li><li><p>实际上，虽然管道机制的想法很好，但实现却非常困难，因而很多浏览器根本不支持它。一般为了提升性能，采用并行多个TCP 连接的形式来实现请求的同时发送。</p><center><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240048537.png" style="zoom:70%;" /></p></center></li></ol><h5 id="缓存控制">③ 缓存控制</h5><p>　　HTTP/1.1 在 HTTP/1.0基础之上，增加了一些请求响应头，以更好的实现对缓存的控制。比如</p><ul><li>新增 <code>Cache-Control</code> 代替原先的<code>Expires</code>；</li><li>新增 <code>If-None-Match</code> 和 <code>Etag</code> 代替原先的<code>If-Modified-Since</code>和 <code>Last-Modified</code> 。</li></ul><h5 id="断点续传">④ 断点续传</h5><p>　　利⽤ HTTP 消息头使⽤分块传输编码，将实体主体分块传输。</p><h4 id="http1.1---http2">1.2 HTTP/1.1 -&gt; HTTP/2</h4><p>HTTP/2 协议本身是基于 HTTPS 的，因此更加安全，其相对于 HTTP/1.1有以下改进。</p><h5 id="头部压缩">① 头部压缩</h5><p>　　HTTP/1.1中的请求头携带大量信息，而且每次都要重复发送，即使是同样的内容，每次请求都需要附带，这会造成性能的损耗。HTTP/2进行了优化，引入了<strong>头信息压缩机制</strong>。</p><p>客户端和服务器<strong>同时维护一张头信息表</strong>，高频出现的字段会存入这个表，生成一个索引号。发送报文时直接使用索引号替代字段。另外，索引表中不存在的字段使用哈夫曼编码<strong>压缩</strong>。</p><p>　　同时，多个请求中，如果请求头相同，则后续请求只需要发送差异的部分，<strong>重复的部分无需再发送</strong>。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240058555.png" style="zoom:70%;" /></center><h5 id="二进制帧">② 二进制帧</h5><p>　　HTTP/1.1 的报文为纯文本格式，而 HTTP/2的报文全面采用二进制格式，并将原始的报文拆分为头信息帧（HeadersFrame）和数据帧（DataFrame）。采用二进制格式有利于提升数据传输效率。</p><h5 id="多路复用">③ 多路复用</h5><p>　　在 HTTP/2中定义了<strong>流（Stream）</strong>的概念，它是二进制帧的双向传输序列，一个数据流对应着一个完整的请求-响应过程，在同一个请求响应过程中，往返的帧会分配一个<strong>唯一的流编号</strong>（StreamID）。</p><p>　　在流的支持下，HTTP/2 可以在<strong>一个 TCP连接中传输多个请求或响应，而不用按照顺序一一对应（即实现多路复用</strong>），因为它们属于不同的流，所发送的帧头部都会携带Stream ID，可以通过此 Stream ID 有效区分不同的请求-响应。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240100176.png" style="zoom:70%;" /></center><p>因而 HTTP/2 解决了 HTTP/1.1 的『队头阻塞』问题，多个请求 -响应之间没有了顺序关系，不需要排队等待，降低了延迟，大幅度提高了连接的利用率。</p><p>　　举个栗子：在一个 TCP 连接里面，服务器同时收到了 A 请求和 B请求，于是先回应 A 请求，结果发现处理过程非常耗时，于是就发送 A请求已经处理好的部分，接着回应 B 请求，完成后，再发送 A请求剩下的部分。</p><h5 id="服务端推送">④ 服务端推送</h5><p>在 HTTP/1.1 中，只能客户端发起请求，服务器对请求进行响应。</p><p>　　而在 HTTP/2中，服务端可以<strong>主动</strong>给客户端推送必要的资源，以减少请求延迟时间。</p><p>　　比如当客户端向服务器请求一个 <code>HTML</code>文件后，服务器除了将此 <code>HTML</code>文件响应给客户端外，还可以提前主动将此 <code>HTML</code> 中所依赖的<code>JS</code> 和 <code>CSS</code> 文件推送给客户端，这样客户端在解析<code>HTML</code> 时，无需耗费额外的请求去得到相应的 <code>JS</code> 和<code>CSS</code> 文件。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240103641.png" style="zoom:70%;" /></center><h4 id="http3-相比-http2-性能上的改进">1.3 HTTP/3 相比 HTTP/2性能上的改进</h4><p>　　Google 公司为了解决 HTTP/2 存在的一些问题，提出了 QUIC 协议，而HTTP-over-QUIC 就是 HTTP/3，其相对于 HTTP/2 有以下改进。</p><h5 id="无队头阻塞">① 无队头阻塞</h5><p>前面提到，HTTP/2 通过<strong>多路复用</strong>解决了 HTTP1.1的『队头阻塞』问题，但其只是解决了 HTTP这一层面的『队头阻塞』问题，底层仍然采用的 TCP 连接，HTTP/2 并没有解决TCP 的『队头阻塞』问题。</p><p>　　TCP 是可靠的、面向字节流的协议。HTTP/2的多个请求虽然可以跑在同一个 TCP 连接中，但如果出现丢包现象，TCP就需要进行重传，这可能就会导致整个 TCP连接上的所有流阻塞，直到丢的包重传成功，这就是 TCP的『队头阻塞』问题。</p><p>　　为了解决此问题，<strong>HTTP/3 底层不再使用 TCP，而是采用UDP</strong>！而 UDP是无连接的，多个流互相独立，之间不再有依赖，因而即使某个流发生了丢包，只会对该流产生影响，并不会使得其他流阻塞！</p><p>　　这时候有的小伙伴可能会问了，HTTP/3 底层不采用TCP，那怎么保证可靠传输呢？答案就是 HTTP/3在应用层自己重新实现了可靠性机制。也就是说，<strong>HTTP/3 将原先 TCP协议提供的部分功能上移至 QUIC，而且进行了改进。</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240106547.png" style="zoom:70%;" /></p><h5 id="优化重传机制">② 优化重传机制</h5><p>　　TCP采用<strong>序号+确认号+超时重传</strong>机制来保证消息的可靠性，即如果某条消息超过一定时间还没有得到确认，则重新发送此消息。</p><p>　　由于网络拥堵情况不断变化，因而消息的超时时间并不是固定的，而是通过不断采样消息的往返时间不断调整的，但<strong>TCP 超时采样存在不准确的问题</strong>。</p><p>　　举个栗子：</p><p>　　客户端发送一个序号为 N的包，然后超时了（可能丢了，也可能网络堵塞了），于是重新发送一个序号为 N的包，之后服务器收到后返回一个确认号 ACK 为 N+1的包。但此时客户端并无法判断这个确定包是对原始报文的确认还是重传报文的确认，那么此时往返时间应该如何计算呢？</p><ul><li>如果认为确认包是对原始报文的确认，则可能把时间算长了；</li><li>如果认为确认包是对重传报文的确认，则可能把时间算短了。</li></ul><p>　　因而 TCP的重传超时时间计算不准确，如果计算偏大，则效率慢，很久才会重传，而如果计算偏小，则可能确认报文已经在路上了，但却重传了！</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240113095.png" style="zoom:70%;" /></center><p>　　<a href="https://zhuanlan.zhihu.com/p/588744727">QUIC</a>是如何解决此问题呢？其定义了一个<strong>递增</strong>的序列号（不再叫Seq，而是 PacketNumber），每个序列号的包只发送一次，<strong>即使重传相同的包，其序列号也不一样</strong>。</p><p>　　举个栗子：</p><p>　　客户端发送一个序号为 N的包，然后超时了，于是重新发送一个相同的包，但序号不再是 N，而是N+1；那么如果返回的确认包 ACK 为 N+1，就是对原始报文的响应，如果 ACK 为N+2，就是对重传报文的响应，因而采样时间计算相对更加准确！</p><center><img src="https://pic3.zhimg.com/80/v2-7bb38ed37d1d9503a753700365b35ece_1440w.webp" alt="img" style="zoom:70%;" /></center><p>　　那此时怎么知道包 N 和包 N+1 是同一个包呢？<strong>QUIC 定义了一个Offset 概念</strong>。发送的数据有个偏移量 Offset，可以通过 Offset知道数据目前发送到了哪里，因而如果某个 Offset的包没有收到确认，就重发。</p><h5 id="连接迁移">③ 连接迁移</h5><p>众所周知，一条 TCP连接是由<code>四元组</code>标识的，分别是<strong>源 IP、源端口、目的IP、目的端口</strong>。一旦其中一个元素发生了变化，就需要断开重连。</p><p>　　当手机信号不稳定或者在 WIFI与移动网络切换时，都将会导致重连，而重连就意味着需要重新进行三次握手，将产生一定的时延，用户感到卡顿，体验不友好。</p><p>　　而 QUIC 不采用<code>四元组</code>的方式标识连接，而是以一个<strong>64 位的随机数作为 ID</strong> 来标识，通过此连接 ID标记通信的两端，之后即使网络发生变化，IP 或端口变了，但只要 ID不变，则无需重连，只需要复用原先连接即可，时延低，减少了用户的卡顿感，实现连接迁移。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240117413.png" /></p><h4 id="总结">1.4 总结</h4><center><img src="https://pic3.zhimg.com/80/v2-665f8dceea786ebadafc64787bc879ba_1440w.webp" alt="img" style="zoom:70%;" /></center><h3 id="http-缓存">2. HTTP 缓存</h3><p>　　HTTP设计中也有缓存的概念，主要是为了<strong>加快响应速度</strong>，HTTP缓存的实现依赖于请求报文和响应报文中的一些字段，分为强缓存和协商缓存。</p><h4 id="强缓存">2.1 强缓存</h4><p>　　<strong>强缓存</strong>指的是在缓存数据未失效的情况下，那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求，逻辑类似于Redis、TLB 快表。</p><p>　　具体实现主要是通过 <code>Cache-Control</code>字段和<code>Expires</code>字段。</p><p>　　Cache-Control 是一个相对时间（即多长时间后过期，http1.1规范），Expires 是一个绝对时间（即在某个时间点过期，http1.0规范），如果两个字段同时存在，Cache-Control 的优先级更高。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240124122.png" style="zoom:70%;" /></center><p>　　由于服务器端时间和客户端时间可能不同步，存在偏差，这也就是导致了使用Expires 可能会存在时间误差，因此<strong>一般更推荐使用 Cache-Control来实现强缓存</strong>。</p><p>　　以 Cache-Control 为例，强缓存的具体的实现流程如下：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240125101.png" style="zoom:70%;" /></center><ul><li><p>当浏览器第一次请求访问服务器资源时，<strong>服务器会在响应头中加上Cache-Control</strong>。Cache-Control 中可以设置以下内容。</p></li><li><ul><li><code>max-age=秒</code>，表示缓存将于指定毫秒值后过期。比如：<code>cache-control: max-age=31536000</code>，表示缓存将于365 天后过期。</li><li><code>no-store</code>，表示不允许缓存（包括强缓存和协商缓存）。</li><li><code>no-cache</code>，表示不使用强缓存，而是<strong>使用协商缓存</strong>，即使用之前必须要先去服务器端验证是否失效，如果没失效，则再使用缓存，如果失效了，则返回最新数据。等价于<code>max-age=0, must-revalidate</code>。</li><li><code>must-revalidate</code>，表示允许缓存，并且如果缓存不过期的话，先使用缓存，如果缓存过期的话，再去服务器端进行验证缓存是否还有效。这里很多小伙伴可能会有疑问，即使没有加上 must-revalidate，有了 max-age后，缓存过期了不也会去服务器验证吗，加不加 must-revalidate有什么区别呢？ 在 HTTP协议规范中，允许客户端在某些特殊情况下直接使用过期缓存，比如校验请求错误时（如无法再次连通服务器），而加上了must-revalidate 后，在校验请求错误时，会返回 504错误码，而不是使用过期缓存。</li></ul></li><li><p>浏览器再次请求访问服务器中的该资源时，根据请求资源的时间与Cache-Control 中设置的过期时间大小，计算出该资源是否过期，</p></li></ul><ol type="1"><li>如果没有过期（且 Cache-Control 没有设置 no-cache 属性和 no-store属性），则使用该缓存，结束；</li><li>否则重新请求服务器；</li></ol><h4 id="协商缓存">2.2 协商缓存</h4><p>　　<strong>协商缓存</strong>指的是当第一次请求后，服务器响应头Cache-Control 字段属性设置为 no-cache或者缓存时间过期了，那么浏览器再次请求时就会与服务器进行协商，判断缓存资源是否有效，即资源是否进行了修改更新。</p><ul><li>如果资源没有更新，那么服务器返回 304状态码，表明缓存仍然可用，而不需要再次发送资源，减少了服务器的数据传输压力，并更新缓存时间。</li><li>如果数据有更新，服务器返回 200 状态码，新资源存放在请求体中。</li></ul><center><img src="https://pic4.zhimg.com/80/v2-5b294a5c2412dda0118b6669a27affc3_1440w.webp" alt="img" style="zoom:70%;" /></center><p>　　协商缓存可以基于以下两种方式来实现：</p><h5 id="http1.0-规范">1. HTTP/1.0 规范</h5><p>　　请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的<code>Last-Modified</code> 字段：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240132948.png" style="zoom:70%;" /></center><ul><li><p><code>Last-Modified</code>：标示这个响应资源的最后修改时间。第一次请求资源后，服务器将在响应头中带上此信息。</p></li><li><p><code>If-Modified-Since</code>：当资源过期了，浏览器再次发起请求的时候带上Last-Modified 的时间（放在请求头 If-Modified-Since中），服务器将此时间与被请求资源的最后修改时间进行对比，</p></li><li><ul><li>如果最后修改时间较大，说明资源有被修改过，则返回最新资源和 200状态码；</li><li>否则说明资源无新修改，返回 304 状态码。</li></ul></li><li><p>此种方式存在以下问题：</p></li><li><ul><li>基于时间实现，可能会由于时间误差而出现不可靠问题，并且只能精确到秒级，在同一秒内，Last-Modified无感知。</li><li>如果某些文件被修改了，但是内容并没有任何变化（比如只是修改时间发生了变化），而Last-Modified 却改变了，导致文件没法使用缓存。</li></ul></li></ul><h5 id="http1.1-规范">2. HTTP/1.1 规范</h5><p>　　请求头部中的 <code>If-None-Match</code> 字段与响应头部中的<code>ETag</code> 字段：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240135284.png" style="zoom:70%;" /></center><ul><li><p><code>Etag</code>：唯一标识响应资源，是一个 hash值；第一次请求资源后，服务器将在响应头中带上此信息。</p></li><li><p><code>If-None-Match</code>：当资源过期了，浏览器再次向服务器发起请求时，会将请求头If-None-Match 值设置为 Etag 中的值。服务器将此值与资源的 hash值进行比对，</p></li><li><ul><li>如果二者相等，则资源没有变化，则返回 304 状态码。</li><li>如果资源变化了，则返回新资源和 200 状态码。</li></ul></li><li><p>此种方式存在的问题在于计算 Etag会消耗系统性能，但可以解决第一种方式所存在的问题，推荐使用。</p></li></ul><p>注意 ：</p><ul><li>如果 HTTP 响应头部同时有 Etag 和 Last-Modified字段的时候，<strong>Etag 的优先级更高</strong>，也就是先会判断 Etag是否变化了，如果 Etag 没有变化，然后再看 Last-Modified。</li><li><code>Ctrl + F5</code> 强制刷新，会直接向服务器提取数据。</li><li>按 <code>F5</code> 刷新或浏览器的刷新按钮，默认加上Cache-Control：max-age=0，即会走协商缓存。</li></ul><h3 id="https">3. HTTPS</h3><ol type="1"><li>加密算法</li><li>摘要算法</li><li>数字证书</li><li><strong>SSL/TLS 握手</strong></li></ol><p>https://zhuanlan.zhihu.com/p/597168426</p><h3 id="浏览器输入-url-后回车发生了什么">4. 浏览器输入 URL后回车发生了什么？</h3><p>https://zhuanlan.zhihu.com/p/591749021</p><h3 id="计算机网络体系结构">5. 计算机网络体系结构</h3><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310302041764.png" style="zoom:50%;" /></center><h4 id="五层协议">1. 五层协议</h4><blockquote><p><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如HTTP、DNS 等协议。数据单位为报文。 <strong>传输层</strong>：为进程提供通用数据传输服务。运输层包括两种协议：传输控制协议TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP主要提供完整性服务，UDP 主要提供及时性服务。 <strong>网络层</strong>：负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据包封装成分组或包进行传送。<strong>数据链路层</strong>：网络层针对的是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。<strong>物理层</strong>：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p></blockquote><h4 id="osi">2. OSI</h4><blockquote><p>其中表示层和会话层用途如下： <strong>表示层</strong>：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。<strong>会话层</strong> ：建立及管理会话。五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p></blockquote><h4 id="tcpip">3. TCP/IP</h4><blockquote><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP层或者网络接口层</p></blockquote><h3 id="tcp-首部格式">6. TCP 首部格式</h3><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310302048102.png" style="zoom:50%;" /></center><ol type="1"><li><strong>序号</strong> ：用于对字节流进行编号，例如序号为301，表示第一个字节的编号为 301，如果携带的数据长度为100字节，那么下一个报文段的序号应为 401。</li><li><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A的确认报文段中确认号就为 701。</li><li><strong>数据偏移</strong>：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP规定，在连接建立后所有传送的报文段都必须把ACK 置 1。</li><li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当SYN=1，ACK=0时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中SYN=1，ACK=1。</li><li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li><li><strong>窗口</strong>：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li></ol><h3 id="三次握手">7. 三次握手</h3><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310302107433.png" style="zoom:60%;" /></center><blockquote><p><strong>第一次握手</strong>：Client 将标志位 SYN置为1，随机产生一个值seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。<strong>第二次握手</strong>：Server收到数据包后由标志位 SYN=1 知道Client请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。<strong>第三次握手</strong>：Client 收到确认后，检查 ack 是否为J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p></blockquote><h4 id="三次握手的原因">7.1 三次握手的原因</h4><blockquote><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p></blockquote><h3 id="四次挥手">8. 四次挥手</h3><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310302110816.png" style="zoom:50%;" /></center><blockquote><p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server进入 CLOSE_WAIT状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。第三次挥手：Server 发送一个FIN，用来关闭 Server 到 Client的数据传送，Server 进入 LAST_ACK 状态。第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p></blockquote><h4 id="为什么在-time-wait-状态必须等待-2msl最长报文段寿命-的时间">8.1为什么在 TIME-WAIT 状态必须等待 2MSL（最长报文段寿命） 的时间?</h4><blockquote><p><strong>第一</strong>，为了保证 A发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK报文段的确认。B会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL时间内收到这个重传的 FIN+ACK 报文段。接着 A 重传一次确认，重新启动 2MSL计时器。最后，A和B都正常进入到 CLOSED 状态。如果 A在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到B重传的FIN+ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常步骤进入CLOSED状态。<strong>第二</strong>，防止上一节“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下-一个新的连接中不会出现这种旧的连接请求报文段。</p></blockquote><h3 id="udp-首部格式">9. UDP 首部格式</h3><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310302052769.png" style="zoom:50%;" /></center><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。</p><h3 id="地址解析协议-arp网络层">10. 地址解析协议 ARP（网络层）</h3><blockquote><p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP地址到 MAC 地址的映射表。如果主机 A 知道主机 B 的 IP 地址，但是 ARP高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC地址的映射</p></blockquote><h3 id="udp-和-tcp-的特点">11. UDP 和 TCP 的特点</h3><blockquote><p>用户数据报协议 UDP（User DatagramProtocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加UDP 首部），支持一对一、一对多、多对一和多对多的交互通信首部开销小。传输控制协议 TCP（Transmission ControlProtocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条TCP 连接只能是点对点的（一对一）。</p></blockquote><h3 id="滑动窗口机制">12. 滑动窗口机制</h3><blockquote><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过TCP报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为{31, 34, 35}，其中 {31}按序到达，而 {34, 35} 就不是，因此只对字节 31进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310302115004.png" style="zoom:50%;" /></center><p>具体通过三个指针来实现的</p><ul><li>P1左部：已经发送并且收到了确认的字节，即滑动窗口的开始</li><li>P1~P2:已经发送,但未收到确认的字节</li><li>P3右侧：不能发送的字节，即滑动窗口的结束</li></ul></blockquote><h3 id="拆包和粘包">13. 拆包和粘包</h3><blockquote><p>UCP是基于报文发送的，UDP报文的首部会有16bit来表现UDP数据的长度，所以不同的报文之间是可以区别隔离出来的，所以应用层接收传输层的报文时，不会存在拆包和粘包的问题；而TCP是基于字节流传的，应用层和传输层之前数据交互是大小不等的数据块，但TCP对这些数据块只是一连串的数据流，它并不知道哪些数据块跟哪些数据块是该一起发，哪个数据块是应该单独一块的，因为TCP并没有像UDP那样首部有数据长度，所以TCP存在拆包和粘包的问题。<strong>产生粘包场景</strong> 发送端需要等缓冲区满才发送出去，造成粘包接收方不及时接收缓冲区的包，造成多个包接收 <strong>解决</strong>1.发送端给数据包增加首部，首部包含数据包中数据的长度，这样接收端的应用层接收数据后，根据首部中的长度就知道数据的实际长度了，可以很好处理数据了。通常设计思路，比如第1个字段使用32int表示数据的长度，接着是数据内容。2.设置数据包的长度为固定的长度，不够数据则以空格填补；3.应用层在发送每个数据包时，给每个数据包加分界标记，比如回车换行，</p></blockquote><h3 id="tcp短连接长连接">14. TCP短连接、长连接</h3><blockquote><p><strong>TCP短连接</strong>：client 向 server 发起连接请求，server接到请求，然后双方建立连接。client向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。短连接一般只会在client/server 间传递一次读写操作。短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段<strong>TCP长连接</strong>：长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。长连接的优点是：减少连接建立过程的耗时。方便实现push数据<strong>心跳</strong>心跳是用来检测一个系统是否存活或者网络链路是否通畅的一种方式，做法是定时向被检测系统发送心跳包，被检测系统收到心跳包进行回复，收到回复说明对方存活。心跳能够给长连接提供保活功能，能够检测长连接是否正常，一旦链路死了，不可用了，能够尽快知道，然后做些其他的高可用措施，来保证系统的正常运行。<strong>长连接保活</strong> 操作系统实现： TCP 的 KeepAlive机制（此机制并不是TCP协议规范中的内容，由操作系统去实现）KeepAlive机制开启后，在一定时间内（一般时间为7200s，参数tcp_keepalive_time）在链路上没有数据传送的情况下，TCP层将发送相应的KeepAlive探针以确定连接可用性，探测失败后重试10（参数tcp_keepalive_probes）次，每次间隔时间75s（参数tcp_keepalive_intvl），所有探测失败后，才认为当前连接已经不可用。这些参数是机器级别，可以调整。KeepAlive的保活机制只在链路空闲的情况下才会起到作用。<strong>心跳包使用</strong> 方案一最简单的策略当然是客户端定时n秒发送心跳包，服务端收到心跳包后，回复客户端的心跳，如果客户端连续m秒没有收到心跳包，则主动断开连接，然后重连，将正常的业务请求暂时不发送的该台服务器上。方案二这样传送一些无效的数据包有点多，可以做些优化。因为心跳就是一种探测请求，业务上的正常请求除了做业务处理外，还可以用作探测的功能，比如此时有请求需要发送到服务端，这个请求就可以当作是一次心跳，服务端收到请求，处理后回复，只要服务端有回复，就表明链路还是通的，如果客户端请求比较空闲的时候，服务端一直没有数据回复，就使用心跳进行探测，这样就有效利用了正常的请求来作为心跳的功能，减少无效的数据传输。</p></blockquote><h3 id="tcp-流量控制">15. TCP 流量控制</h3><blockquote><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。</p></blockquote><h3 id="tcp-拥塞控制">16. TCP 拥塞控制</h3><blockquote><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。1. 慢开始与拥塞避免 发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1个报文段；当收到确认后，将 cwnd加倍，因此之后发送方能够发送的报文段数量为：2、4、8...设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh时，进入拥塞避免，每个轮次只将 cwnd 加 1。 如果出现了超时，则令 ssthresh= cwnd / 2，然后重新执行慢开始。 2. 快重传与快恢复在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到M1 和 M2，此时收到 M4，应当发送对 M2 的确认。在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个M2，则 M3 丢失，立即重传 M3。在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令ssthresh = cwnd / 2 ，cwnd =ssthresh，注意到此时直接进入拥塞避免。慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始cwnd 设定为 1，而快恢复 cwnd设定为 ssthresh</p></blockquote><h3 id="http请求中的8种请求方法">17. http请求中的8种请求方法</h3><p>1、opions 返回服务器针对特定资源所支持的HTML请求方法或web服务器发送*测试服务器功能（允许客户端查看服务器性能）</p><p>2、Get 向特定资源发出请求（请求指定页面信息，并返回实体主体）</p><p>3、Post向指定资源提交数据进行处理请求（提交表单、上传文件），又可能导致新的资源的建立或原有资源的修改</p><p>4、Put向指定资源位置上上传其最新内容（从客户端向服务器传送的数据取代指定文档的内容）</p><p>5、Head与服务器索与get请求一致的相应，响应体不会返回，获取包含在小消息头中的原信息（与get请求类似，返回的响应中没有具体内容，用于获取报头）</p><p>6、Delete请求服务器删除request-URL所标示的资源*（请求服务器删除页面）</p><p>7、Trace 回显服务器收到的请求，用于测试和诊断</p><p>8、Connect HTTP/1.1协议中能够将连接改为管道方式的代理服务器</p><h3 id="幂等性">18. 幂等性</h3><p>幂等的 HTTP方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。所有的安全方法也都是幂等的。在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST方法不是</p><h3 id="get和post的区别">19. GET和POST的区别</h3><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310302117884.png" style="zoom:50%;" /></center><h3 id="http的状态码">20. http的状态码</h3>状态码如 200 OK，以 3 位数字和原因短语组成。数字中的第一位指定了响应类别，后两位无分类。响应类别有以下 5 种。<center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310302215632.png" style="zoom:50%;" /></center><p>200：OK 服务器成功处理了请求</p><p>301:（永久移动）请求的网页已永久移动到新位置，服务器返回此响应时，会自动将请求者转到新位置。</p><p>302:（临时移动）服务器目前从不同位置的网页响应请求，但请求者之后还是以原来的位置来进行以后的请求。</p><p>400:（错误请求）服务器不理解请求的语法。</p><p>403:（禁止）服务器拒绝请求。</p><p>404:（未找到）服务器找不到请求的网页。</p><p>500:（服务器内部错误)服务器遇到错误，无法完成请求。</p><h3 id="https与http的区别">21. https与http的区别</h3><p>　　HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure SocketsLayer）通信，再由 SSL 和 TCP通信，相当于SSL被嵌在了HTTP和TCP之间。鉴于HTTP的缺点，HTTPS在HTTP的基础上增加了：</p><ul><li>通信加密（防窃听）</li><li>证书认定（防伪装）</li><li>完整性保护</li></ul><p>　　HTTPS和HTTP的区别主要如下：</p><ol type="1"><li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><p>HTTP的缺点:</p><ul><li>通信内容为明文，容易被窃听。</li><li>通信双方身份没有进行验证，可能出现伪装身份的情况。</li><li>接受报文完整性无法确定，可能中途被改动。</li></ul><p>HTTPS的缺点</p><ul><li>通信速率降低。除了进行TCP连接，发送请求外，还要进行SSL通信。通信信息量增加。</li><li>加密过程消耗资源。每个报文都要进行加密和解密的运算处理。比起HTTP消耗了更多资源。</li><li>证书开销。需要支付证书授权的高额费用</li></ul><ol type="1"><li><p>共享（对称）密钥加密：加密解密使用同一密钥。</p><p>优点：运算速度快。 缺点：无法安全的将密钥传输给通信方。</p></li><li><p>公开（非对称）密钥加密：加密和解密使用不同的密钥。一把是公有密钥，一把是私有密钥公有密钥是对通信双方公开的，任何人都可以获取，而私有的不公开。</p></li></ol><p>　　优点：可以更安全的将公开密钥传输给通信发送方。　　缺点：运算速度慢。</p><ol start="3" type="1"><li><p>HTTPS采用的加密方式</p><p>HTTPS采用了混合加密的方式。即先通过公开密钥（非对称）对共享密钥（对称）进行加密来保证传输过程的安全性，当共享密钥安全传输给对方后，双方则采用共享密钥的方式来加密报文，以此提高传输的效率。</p></li></ol><h3 id="dns的解析过程">22. DNS的解析过程</h3><p>　　1） 浏览器缓存</p><p>　　当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；</p><p>　　2） 系统缓存</p><p>　　当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP；</p><p>　　3） 路由器缓存</p><p>　　当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存；</p><p>　　4） ISP（互联网服务提供商）DNS缓存</p><p>　　当在用户客服端查找不到域名对应IP地址，则将进入ISPDNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；</p><p>　　5） 根域名服务器</p><p>　　当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后给出顶级域名服务器的地址。</p><p>　　6） 顶级域名服务器</p><p>　　顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器；</p><p>　　7） 主域名服务器</p><p>　　主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；</p><p>　　8）保存结果至缓存</p><p>　　本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。</p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Debug GO</title>
    <link href="/2023/10/18/Debug-GO/"/>
    <url>/2023/10/18/Debug-GO/</url>
    
    <content type="html"><![CDATA[<p>面试题汇总：</p><p>https://zhuanlan.zhihu.com/p/519979757</p><p>https://www.zhihu.com/people/itsanmao/posts</p><h3 id="golang-调度器设计思想gmp-协程调度模型详解">1. Golang调度器设计思想、GMP 协程调度模型详解</h3><p>https://zhuanlan.zhihu.com/p/617420622</p><ol type="1"><li>GM</li><li>GMP</li><li>work stealing 机制和 hand off 机制</li><li>抢占式调度</li></ol><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310182358164.png" style="zoom:50%;" /></center><p>　</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310190006013.png" style="zoom:50%;" /></center><h3 id="go内存管理和分配策略">2. Go内存管理和分配策略</h3><p>https://zhuanlan.zhihu.com/p/619865411</p><ol type="1"><li>TCMalloc：Thread Cache Malloc</li><li>Mspan、mcache、mcentral、mheap</li></ol><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310190018997.png" style="zoom:50%;" /></center><p>内存对齐：</p><p>https://zhuanlan.zhihu.com/p/621129832</p><h3 id="go-gc分析">3. GO GC分析</h3><p>GC触发机制：</p><p>Go语言中有三种GC的触发时机：</p><ul><li><strong>系统的定时触发</strong>：如果两分钟内没有触发GC，则会每隔两分钟进行触发一次GC。</li><li><strong>用户显示调用</strong>：用户调用runtime.GC方法，进行强制触发</li><li><strong>申请内存时触发</strong>：给对象申请堆空间的时候，可能会触发GC，调用mallocgc的方法。</li></ul><p>GO使用的GC算法：</p><ul><li>GO 1.3 mark and sweep</li><li>GO 1.5 三色并发标记法</li><li>GO 1.8混合写屏障</li></ul><p><strong>GC 中 stw 时机，各个阶段是如何解决的？</strong></p><p>https://zhuanlan.zhihu.com/p/356930881</p><p>https://blog.51cto.com/u_10983441/5357639</p><h3 id="golang-的-goroutine-是如何实现的">4. Golang 的 goroutine是如何实现的？</h3><ul><li>GMP</li><li>调度</li><li>内存分配</li><li>GC</li></ul><p>https://www.zhihu.com/question/20862617/answer/921061289</p><h3 id="深入分析golang的mutex">5. 深入分析Golang的Mutex</h3><p>https://zhuanlan.zhihu.com/p/501972241</p><ol type="1"><li>state<code>和</code>sema</li><li><code>state</code>字段为<code>int32</code>类型，其低三位分别代表了锁的一些状态：<ul><li><code>mutexLocked</code>是<code>state</code>中的<code>低1位</code>，用二进制表示为<code>0001</code>（为了方便，这里只描述后4位），它代表该互斥锁是否被加锁。</li><li><code>mutexWoken</code>是<code>低2位</code>，用二进制表示为<code>0010</code>，它代表互斥锁上是否有被唤醒的goroutine。</li><li><code>mutexStarving</code>是<code>低3位</code>，用二进制表示为<code>0100</code>，它代表当前互斥锁是否处于饥饿模式。</li><li><code>state</code>剩下的29位用于统计在互斥锁上的等待队列中<code>goroutine</code>数目（<code>waiter</code>）。</li></ul></li></ol><p><strong>自旋的条件如下：</strong></p><p>1）还没自旋超过 4 次,</p><p>2）多核处理器，</p><p>3）GOMAXPROCS &gt; 1，</p><p>4）p 上本地 goroutine 队列为空。</p><h3 id="切片">6. 切片</h3><ol type="1"><li>结构</li><li>扩容</li><li>作为函数参数传参</li></ol><p>https://zhuanlan.zhihu.com/p/598973739</p><h3 id="channel">7. channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br>    qcount   <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// 当前队列中剩余元素个数</span><br>    dataqsiz <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// 环形队列长度，即可以存放的元素个数</span><br>    buf      unsafe.Pointer <span class="hljs-comment">// 环形队列指针</span><br>    elemsize <span class="hljs-keyword">uint16</span>         <span class="hljs-comment">// 每个元素的大小</span><br>    closed   <span class="hljs-keyword">uint32</span>         <span class="hljs-comment">// 标识关闭状态</span><br>    elemtype *_type         <span class="hljs-comment">// 元素类型</span><br>    sendx    <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// 队列下标，指示元素写入时存放到队列中的位置</span><br>    recvx    <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// 队列下标，指示元素从队列的该位置读出</span><br>    recvq    waitq          <span class="hljs-comment">// 等待读消息的goroutine队列，即等待接收队列</span><br>    sendq    waitq          <span class="hljs-comment">// 等待写消息的goroutine队列，即等待发送队列</span><br>    lock     mutex          <span class="hljs-comment">// 互斥锁，chan不允许并发读写</span><br>&#125;<br></code></pre></td></tr></table></figure><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310192212948.png" style="zoom:50%;" /></br></br><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310192303076.png" style="zoom:50%;" /></center><p>发送流程：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310192237574.png" style="zoom:50%;" /></center><p>接受流程：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310192253540.png" style="zoom:50%;" /></center><p>关闭流程：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310192254999.png" style="zoom:70%;" /></center><p>https://zhuanlan.zhihu.com/p/604907917</p><p>https://zhuanlan.zhihu.com/p/605991429</p><h3 id="map">8. Map</h3><ul><li>任何可比较的类型都可以是键——所有简单的标量类型（布尔、整数、浮点、复数、字符串）、指针、通道、数组、接口。</li><li>不可比较的类型——切片、映射、函数（ slice、map、function）。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A header for a Go map.</span><br><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.</span><br>    <span class="hljs-comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span><br>    count     <span class="hljs-keyword">int</span> <span class="hljs-comment">// 元素个数，调用 len(map) 时，直接返回此值</span><br>    flags     <span class="hljs-keyword">uint8</span> <span class="hljs-comment">//代表当前 map 的状态（是否处于正在写入的状态等）</span><br>    B         <span class="hljs-keyword">uint8</span>  <span class="hljs-comment">// buckets 的对数 log_2</span><br>    noverflow <span class="hljs-keyword">uint16</span> <span class="hljs-comment">// 为 map 中溢出桶的数量。当溢出的桶太多时，map 会进行 same-size map growth，其实质是避免桶过大导致内存泄露</span><br>    hash0     <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// 代表生成 hash 的随机数种子</span><br><br>    buckets    unsafe.Pointer <span class="hljs-comment">// 指向 buckets 数组，大小为 2^B，如果元素个数为0，就为 nil</span><br>    oldbuckets unsafe.Pointer <span class="hljs-comment">// 是在 map 扩容时存储旧桶的，当所有旧桶中的数据都已经转移到了新桶中时，则清空</span><br>    nevacuate  <span class="hljs-keyword">uintptr</span>        <span class="hljs-comment">// 在扩容时使用，用于标记当前旧桶中小于 nevacuate 的数据都已经转移到了新桶中</span><br>    extra *mapextra <span class="hljs-comment">// 存储 map 中的溢出桶</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mapextra <span class="hljs-keyword">struct</span> &#123;<br>  overflow    *[]*bmap  <span class="hljs-comment">// 指向已经使用的溢出桶数组</span><br>  oldoverflow *[]*bmap  <span class="hljs-comment">// 指向扩容阶段旧桶使用的溢出桶数组</span><br>  nextOverflow *bmap  <span class="hljs-comment">// 指向下个空闲溢出桶</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A bucket for a Go map.</span><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// tophash generally contains the top byte of the hash value</span><br><span class="hljs-comment">// for each key in this bucket. If tophash[0] &lt; minTopHash,</span><br><span class="hljs-comment">// tophash[0] is a bucket evacuation state instead.</span><br>tophash [bucketCnt]<span class="hljs-keyword">uint8</span><br><span class="hljs-comment">// Followed by bucketCnt keys and then bucketCnt elems.</span><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> packing all the keys together and then all the elems together makes the</span><br><span class="hljs-comment">// code a bit more complicated than alternating key/elem/key/elem/... but it allows</span><br><span class="hljs-comment">// us to eliminate padding which would be needed for, e.g., map[int64]int8.</span><br><span class="hljs-comment">// Followed by an overflow pointer.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>编译期动态地创建一个新的结构:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    topbits  [<span class="hljs-number">8</span>]<span class="hljs-keyword">uint8</span><br>    keys     [<span class="hljs-number">8</span>]keytype<br>    values   [<span class="hljs-number">8</span>]valuetype<br>    pad      <span class="hljs-keyword">uintptr</span><br>    overflow <span class="hljs-keyword">uintptr</span><br>&#125;<br><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>  tophash [bucketCnt]<span class="hljs-keyword">uint8</span>     <span class="hljs-comment">// 8个key的hash值的高8位，用于快速定位桶内的key</span><br>  keys    [bucketCnt]keytype   <span class="hljs-comment">// 8个key</span><br>  elems   [bucketCnt]valuetype <span class="hljs-comment">// 8个value</span><br>  padding <span class="hljs-keyword">uintptr</span>              <span class="hljs-comment">// 对齐使用，按照源码的注释可以省略。</span><br>  <span class="hljs-comment">// 当发生碰撞时，一个桶里最多放8个键值对。</span><br>  <span class="hljs-comment">// 当有第9个key被hash到该桶时，由于没有多余的位置，需要放到溢出桶</span><br>  <span class="hljs-comment">// overflow即为指向溢出桶的指针，溢出桶和桶的内部结构是一样的。</span><br>  overflow *bmap<br>&#125;<br></code></pre></td></tr></table></figure><p>不使用预分配的溢出桶：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310211648358.png" style="zoom:50%;" /></center><p>bmap 的内存布局:</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310211632410.png" style="zoom:50%;" /></center><p>最上面蓝色区域的HOBHash即为每个对应key的hash值的高8位，也即tophash数组。</p><p>https://zhuanlan.zhihu.com/p/652191566</p><p>https://www.jianshu.com/p/e1f380c4ae48</p><p>https://blog.51cto.com/u_13539/6761128</p><p><strong>不支持缩容</strong>：https://blog.csdn.net/EDDYCJY/article/details/120465701</p><h4 id="map并发安全">8.1 map并发安全</h4><p>https://blog.csdn.net/weixin_43973689/article/details/127986224</p><p>https://www.jb51.net/jiaoben/285704yj5.htm</p><p>sync.Map 实现：</p><p>https://zhuanlan.zhihu.com/p/599178236</p><h3 id="select">9. select</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> scase <span class="hljs-keyword">struct</span> &#123;<br>  c    *hchan         <span class="hljs-comment">// case中使用的chan</span><br>  elem unsafe.Pointer <span class="hljs-comment">// 指向case包含数据的指针</span><br>&#125;<br></code></pre></td></tr></table></figure><p>第一，Go select 语句采用的多路复用思想。</p><p>第二，select的基本用法是：通过多个case监听多个Channel的读写操作，任何一个case可以执行则选择该case执行，否则执行default。如果没有default，且所有的case均不能执行，则当前的goroutine阻塞。</p><p>第三，编译器会对select有不同的case的情况进行优化以提高性能。首先，编译器对select没有case、有单case和单case+default的情况进行单独处理。这些处理或者直接调用运行时函数，或者直接转成对channel的操作，或者以非阻塞的方式访问channel，多种灵活的处理方式能够提高性能，尤其是避免对channel的加锁。</p><p>第四，对最常出现的select有多case的情况，会调用 runtime.selectgo()函数来获取执行 case 的索引，并生成 if 语句执行该case的代码。</p><p>第五，selectgo函数的执行分为四个步骤：首先，随机生成一个遍历case的轮询顺序pollorder 并根据 channel 地址生成加锁顺序lockorder，随机顺序能够避免channel饥饿，保证公平性，加锁顺序能够避免死锁；然后，根据pollorder 的顺序查找 scases是否有可以立即收发的channel，如果有则获取case索引进行处理；再次，如果pollorder顺序上没有可以直接处理的case，则将当前goroutine 加入各 case 的 channel 对应的收发队列上并等待其他 goroutine的唤醒；最后，当调度器唤醒当前 goroutine 时，会再次按照 lockorder遍历所有的case，从中查找需要被处理的case索引进行读写处理，同时从所有case的发送接收队列中移除掉当前goroutine。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310212149797.png" /></p><p>https://blog.csdn.net/QcloudCommunity/article/details/128556748</p><h3 id="new和make的区别">10. new和make的区别</h3><p>https://zhuanlan.zhihu.com/p/648748855</p><h3 id="逃逸分析">11. 逃逸分析</h3><p>https://cloud.tencent.com/developer/article/2206329</p><p>逃逸分析原则：</p><ul><li>不同于JAVAJVM的运行时逃逸分析，Go的逃逸分析是在编译期完成的：编译期无法确定的参数类型<strong>必定</strong>放到堆中；</li><li>如果变量在函数外部存在引用，则<strong>必定</strong>放在堆中；</li><li>如果变量占用内存较大时，则<strong>优先</strong>放到堆中；</li><li>如果变量在函数外部没有引用，则<strong>优先</strong>放到栈中；</li></ul><h3 id="内存泄漏">12. 内存泄漏</h3><p>https://blog.51cto.com/u_16099296/6700430</p><h3 id="go-中-uintptr-和-unsafe.pointer-的区别">13. Go 中 uintptr 和unsafe.Pointer 的区别</h3><p>https://blog.csdn.net/lengyue1084/article/details/133127480</p><h3 id="go-多返回值怎么实现的">14. Go 多返回值怎么实现的</h3><p>Go 传参和返回值是通过 FP+offset 实现，并且存储在调用函数的栈帧中。FP栈底寄存器，指向一个函数栈的顶部;PC 程序计数器，指向下一条执行指令;SB指向静态数据的基指针，全局符号;SP 栈顶寄存器。</p><p>http://caibaojian.com/go/03.2.html</p><h3 id="协程池">15. 协程池</h3><ul><li>channel 实现</li><li>go-playground/pool</li><li><strong>ants</strong></li></ul><p>https://blog.csdn.net/finghting321/article/details/106492915/</p><h3 id="安全读写共享变量">16. 安全读写共享变量</h3><ul><li><p>将共享变量的读写放到一个 goroutine 中，其它 goroutine 通过channel 进行读写操作。</p></li><li><p>可以用个数为 1 的信号量（semaphore）实现互斥</p></li><li><p>通过 Mutex 锁实现</p></li></ul><p>semaphore：</p><p>https://zhuanlan.zhihu.com/p/389718532</p><p>WaitGroup：</p><p>https://blog.csdn.net/zhanggqianglovec/article/details/127905793</p><h3 id="context">17. context</h3><p>context 结构：</p><p>答：Go 的 Context 的数据结构包含 Deadline，Done，Err，Value，Deadline方法返回一个 time.Time，表示当前 Context 应该结束的时间，ok则表示有结束时间，Done 方法当 Context 被取消或者超时时候返回的一个 close的 channel，告诉给 context 相关的函数要停止当前工作然后返回了，Err 表示context 被取消的原因，Value 方法表示 context实现共享数据存储的地方，是协程安全的。context在业务中是经常被使用的，</p><p>其主要的应用 ：</p><p>1：上下文控制，2：多个 goroutine之间的数据交互等，3：超时控制：到某个时间点超时，过多久超时。</p><p>https://www.cnblogs.com/juanmaofeifei/p/14439957.html</p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty——粘包/半包、编解码器、序列化</title>
    <link href="/2023/10/11/Netty%E2%80%94%E2%80%94%E7%B2%98%E5%8C%85-%E5%8D%8A%E5%8C%85%E3%80%81%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2023/10/11/Netty%E2%80%94%E2%80%94%E7%B2%98%E5%8C%85-%E5%8D%8A%E5%8C%85%E3%80%81%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="粘包半包">1. 粘包半包</h3><h4 id="什么是tcp粘包半包">1.1 什么是TCP粘包半包</h4><p>　　假设客户端分别发送了两个数据包 D1 和 D2给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下 4种情况。</p><ol type="1"><li>服务端分两次读取到了两个独立的数据包，分别是 D1 和D2，没有粘包和拆包；</li><li>服务端一次接收到了两个数据包，D1 和 D2 粘合在一起，被称为 TCP粘包；</li><li>服务端分两次读取到了两个数据包，第一次读取到了完整的 D1 包和 D2包的部分内容，第二次读取到了 D2 包的剩余内容，这被称为 TCP 拆包；</li><li>服务端分两次读取到了两个数据包，第一次读取到了 D1 包的部分内容D1_1，第二次读取到了 D1 包的剩余内容 D1_2 和 D2 包的整包。</li></ol><p>　　如果此时服务端 TCP 接收滑窗非常小，而数据包 D1 和 D2比较大，很有可能会发生第五种可能，即服务端分多次才能将 D1 和 D2包接收完全，期间发生多次拆包。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310112242486.png" /></p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoStickyHalfServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger counter = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ByteBuf in = (ByteBuf) msg;<br>        String request = in.toString(CharsetUtil.UTF_8);<br>        System.out.println(<span class="hljs-string">&quot;Server accept: &quot;</span> + request);<br>        System.out.println(<span class="hljs-string">&quot;accept counter:&quot;</span> + counter.incrementAndGet());<br><br>        String resp = <span class="hljs-string">&quot;Hello &quot;</span> + request + System.lineSeparator();<br>        ctx.writeAndFlush(Unpooled.copiedBuffer(resp.getBytes()));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端接收结果：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310112337815.png" style="zoom:50%;" /></center><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoStickyHalfClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger counter = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;client Accept&quot;</span> + msg.toString(CharsetUtil.UTF_8));<br>        System.out.println(<span class="hljs-string">&quot;accept counter is&quot;</span> + counter.incrementAndGet());<br>    &#125;<br><br>    <span class="hljs-comment">/*channel活跃后，做业务处理*/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String request = <span class="hljs-string">&quot;debuggingWorld&quot;</span> + System.lineSeparator();<br>        ByteBufAllocator byteBufAllocator = ctx.alloc();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            ByteBuf byteBuf = byteBufAllocator.buffer(request.length());<br>            byteBuf.writeBytes(request.getBytes());<br>            ctx.writeAndFlush(byteBuf);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端接收结果：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310112339961.png" style="zoom:50%;" /></center><h4 id="tcp粘包半包发生的原因">1.2 TCP粘包/半包发生的原因</h4><p>　　由于 TCP协议本身的机制（面向连接的可靠地协议-三次握手机制）客户端与服务器会维持一个连接（Channel），数据在连接不断开的情况下，可以持续不断地将多个数据包发往服务器，但是如果发送的网络数据包太小，那么他本身会启用Nagle 算法（可配置是否启用）对较小的数据包进行合并（基于此，TCP的网络延迟要 UDP的高些）然后再发送（超时或者包大小足够）。那么这样的话，服务器在接收到消息（数据流）的时候就无法区分哪些数据包是客户端自己分开发送的，这样产生了粘包；服务器在接收到数据库后，放到缓冲区中，如果消息没有被及时从缓存区取走，下次在取数据的时候可能就会出现一次取出多个数据包的情况，造成粘包现象</p><p>　　UDP：本身作为无连接的不可靠的传输协议（适合频繁发送较小的数据包），他不会对数据包进行合并发送（也就没有Nagle算法之说了），他直接是一端发送什么数据，直接就发出去了，既然他不会对数据合并，每一个数据包都是完整的（数据+UDP头+IP头等等发一次数据封装一次）也就没有粘包一说了。</p><p>　　更具体的原因至少包括：</p><ol type="1"><li>应用程序写入数据的字节大小大于套接字发送缓冲区的大小</li><li>进行 MSS 大小的 TCP 分段。MSS 是最大报文段长度的缩写。MSS 是 TCP报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP报文段。所以 MSS 并不是 TCP 报文段的最大长度，而是：MSS = TCP报文段长度- TCP首部长度。</li></ol><h4 id="解决粘包半包">1.3 解决粘包半包</h4><p>　　由于底层的 TCP无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，可以归纳如下。</p><h5 id="增加分割符">1. 增加分割符</h5><p>　　比如回车换行符进行分割，例如 FTP 协议；</p><p>　　<strong>使用回车换行符进行分割</strong></p><p>Netty 提供了 LineBasedFrameDecoder，以换行符（ "" 或""）作为分隔符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">bootstrap.group(group)<br>        .channel(NioServerSocketChannel.class)<span class="hljs-comment">/*指定使用NIO的通信模式*/</span><br>        .localAddress(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-keyword">this</span>.port))<span class="hljs-comment">/*指定监听端口*/</span><br>        .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> LineBasedFrameDecoder(<span class="hljs-number">1024</span>));<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> EchoStickyHalfServerHandler());<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310112357687.png" style="zoom:50%;" /></center><p>　　【注】LineBasedFrameDecoder 要在接收数据的 ChannelHandler之前</p><p>　　<strong>自定义分割符</strong></p><p>　　发送数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    String request = <span class="hljs-string">&quot;debuggingWorld&quot;</span> + EchoStickyHalfServer.DELIMITER_SYMBOL;<br>    ByteBufAllocator byteBufAllocator = ctx.alloc();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        ByteBuf byteBuf = byteBufAllocator.buffer(request.length());<br>        byteBuf.writeBytes(request.getBytes());<br>        ctx.writeAndFlush(byteBuf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　使用 DelimiterBasedFrameDecoder 自定义分隔符分隔：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DELIMITER_SYMBOL = <span class="hljs-string">&quot;@＃&quot;</span>;<br><br>bootstrap.group(group)<br>        .channel(NioServerSocketChannel.class)<span class="hljs-comment">/*指定使用NIO的通信模式*/</span><br>        .localAddress(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-keyword">this</span>.port))<span class="hljs-comment">/*指定监听端口*/</span><br>        .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                ByteBuf byteBuf = Unpooled.copiedBuffer(DELIMITER_SYMBOL.getBytes());<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> DelimiterBasedFrameDecoder(<span class="hljs-number">1024</span>,byteBuf));<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> EchoStickyHalfServerHandler());<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><h5 id="消息定长">2. 消息定长</h5><p>例如每个报文的大小为固定长度 200 字节，如果不够，空位补空格；</p><p>　　使用 FixedLengthFrameDecoder 解码器。</p><p>发送数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        ByteBuf byteBuf = Unpooled.buffer(REQUEST_Length);<br>        byteBuf.writeBytes(REQUEST.getBytes());<br>        ctx.writeAndFlush(byteBuf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　接受数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">bootstrap.group(eventLoopGroup)<br>        .channel(NioSocketChannel.class)<br>        .remoteAddress(<span class="hljs-keyword">new</span> InetSocketAddress(host, port))<span class="hljs-comment">/*指定服务器的IP地址和端口*/</span><br>        .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> FixedLengthFrameDecoder(REQUEST_Length));<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> EchoStickyHalfClientHandler());<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><h5 id="指定长度">3. 指定长度</h5><p>　　将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用int32 来表示消息的总长度，使用 LengthFieldBasedFrameDecoder。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LengthFieldBasedFrameDecoder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxFrameLength, <span class="hljs-keyword">int</span> lengthFieldOffset, <span class="hljs-keyword">int</span> lengthFieldLength,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">int</span> lengthAdjustment, <span class="hljs-keyword">int</span> initialBytesToStrip, <span class="hljs-keyword">boolean</span> failFast)</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>maxFrameLength：包的最大长度</li><li>lengthFieldOffset：长度域的偏移量，表示跳过指定个数字节之后的才是长度域</li><li>lengthFieldLength：记录该帧数据长度的字段，也就是长度域本身的长度</li><li>lengthAdjustment：长度的一个修正值，可正可负，Netty在读取到数据包的长度值 N 后，认为接下来的 N个字节都是需要读取的，但是根据实际情况，有可能需要增加 N的值，也有可能需要减少 N 的值。</li><li>initialBytesToStrip：从数据帧中跳过的字节数，表示得到一个完整的数据包之后，扔掉这个数据包中多少字节数，才是后续业务实际需要的业务数据（往后传的时候，丢掉多少字节）。</li><li>failFast：如果为 true，则表示读取到长度域，TA 的值的超过maxFrameLength，就抛出一个 TooLongFrameException，而为 false表示只有当真正读取完长度域的值表示的字节之后，才会抛出TooLongFrameException，默认情况下设置为true，建议不要修改，否则可能会造成内存溢出。</li></ul><p>　　示例：以下用四元组表示以下编码（lengthFieldOffset，lengthFieldLength，lengthAdjustment，initialBytesToStrip）</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310170001704.png" style="zoom:50%;" /><br/>(0,2,0,0)</center><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310162312629.png" style="zoom:50%;" /><br/>(0,2,0,2)</center><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310162317041.png" style="zoom:50%;" /><br/>(0,2,-2,0)</center><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310162320446.png" style="zoom:50%;" /><br/>(2,3,0,0)</center><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310162322306.png" style="zoom:50%;" /><br/>(0,3,2,0)</center><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310162326365.png" style="zoom:50%;" /><br/>(1,2,1,3)</center><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310162329958.png" style="zoom:50%;" /><br/>(1,2,-3,3)</center><p>　　<strong>使用示例：</strong></p><p>　　见：3.3.2 MessagePack</p><p>　　发送：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310162338583.png" style="zoom:50%;" /></p><p>　　接收：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310162340436.png" style="zoom:50%;" /></center><h4 id="辨析channelread和channelreadcomplete">1.4辨析channelRead和channelReadComplete</h4><p>两者的区别：</p><p>　　Netty 是在读到完整的业务请求报文后才调用一次业务 ChannelHandler的 channelRead 方法，无论这条报文底层经过了几次 SocketChannel 的 read调用（一包业务数据调用一次，不管分了多少包）。</p><p>　　但是 channelReadComplete方法并不是在业务语义上的读取消息完成后被触发的，而是在每次从SocketChannel 成功读到消息后，由系统触发，也就是说如果一个业务消息被 TCP协议栈发送了 N 次，则服务端的 channelReadComplete 方法就会被调用 N次（也就是读取 ByteBuf 的次数）。</p><h3 id="编解码器">2. 编解码器</h3><h4 id="什么是编解码器">2.1 什么是编解码器</h4><p>　　每个网络应用程序都必须定义如何解析在两个节点之间来回传输的原始字节，以及如何将其和目标应用程序的数据格式做相互转换。这种转换逻辑由编解码器处理，编解码器由编码器和解码器组成，它们每种都可以将字节流从一种格式转换为另一种格式。那么它们的区别是什么呢？</p><p>　　如果将消息看作是对于特定的应用程序具有具体含义的结构化的字节序列，那么编码器是将消息转换为适合于传输的格式（最有可能的就是字节流）；而对应的解码器则是将网络字节流转换回应用程序的消息格式。因此，编码器操作出站数据，而解码器处理入站数据。解决粘包半包其实也是编解码器框架的一部分。</p><h4 id="解码器">2.2 解码器</h4><p>　　+ ByteToMessageDecoder——将字节解码为消息 　　+MessageToMessageDecoder——将一种消息类型解码为另一种消息类型</p><p>　　因为解码器是负责将入站数据从一种格式转换到另一种格式的，所以Netty 的解码器实现了 ChannelInboundHandler。</p><p>　　什么时候会用到解码器呢？很简单：每当需要为 ChannelPipeline中的下一个 ChannelInboundHandler 转换入站数据时会用到。此外，得益于ChannelPipeline的设计，可以将多个解码器链接在一起，以实现任意复杂的转换逻辑。</p><blockquote><p>例如通过 JSON 交换信息，而且 JSON 文本需要加密，接收端就可以：</p><ol type="1"><li>网络加密报文 -&gt; 经过 ByteToMessageDecoder -&gt; String 类型的JSON 明文</li><li>String 类型的 JSON 文本-&gt; 经过 MessageToMessageDecoder -&gt; Java中的对象</li></ol></blockquote><p>　　所以我们可以把 ByteToMessageDecoder看成一次解码器，MessageToMessageDecoder 看成二次或者多次解码器。</p><h5 id="将字节解码为消息">1. 将字节解码为消息</h5><p>　　<strong>抽象类 ByteToMessageDecoder</strong></p><p>　　将字节解码为消息（或者另一个字节序列）是一项如此常见的任务，Netty为它提供了一个抽象的基类：ByteToMessageDecoder。由于你不可能知道远程节点是否会一次性地发送一个完整的消息，所以这个类会对入站数据进行缓冲，直到它准备好处理。</p><p>　　它最重要方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteToMessageDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>  ......<br>&#125;<br></code></pre></td></tr></table></figure><p>　　是必须实现的唯一抽象方法。decode()方法被调用时将会传入一个包含了传入数据的ByteBuf，以及一个用来添加解码消息的List。对这个方法的调用将会重复进行，直到确定没有新的元素被添加到该List，或者该 ByteBuf 中没有更多可读取的字节时为止。然后，如果该 List不为空，那么它的内容将会被传递给 ChannelPipeline 中的下一个ChannelInboundHandler。</p><h5 id="将一种消息类型解码为另一种">2. 将一种消息类型解码为另一种</h5><p>　　在两个消息格式之间进行转换（例如，从 String-&gt;Integer）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageToMessageDecoder</span>&lt;<span class="hljs-title">I</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    ....<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, I msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>　　对于每个需要被解码为另一种格式的入站消息来说，该方法都将会被调用。解码消息随后会被传递给ChannelPipeline 中的下一个 ChannelInboundHandler。</p><p>　　MessageToMessageDecoder&lt;I&gt; 其中 I 代表源数据的类型。</p><h5 id="toolongframeexception">3. TooLongFrameException</h5><p>　　由于 Netty是一个异步框架，所以需要在字节可以解码之前在内存中缓冲它们。因此，不能让解码器缓冲大量的数据以至于耗尽可用的内存。为了解除这个常见的顾虑，Netty提供了 TooLongFrameException类，其将由解码器在帧超出指定的大小限制时抛出。</p><p>　　为了避免这种情况，你可以设置一个最大字节数的阈值，如果超出该阈值，则会导致抛出一个TooLongFrameException（随后会被 ChannelHandler.exceptionCaught()方法捕获）。然后，如何处理该异常则完全取决于该解码器的用户。某些协议（如HTTP）可能允许你返回一个特殊的响应。而在其他的情况下，唯一的选择可能就是关闭对应的连接。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310142346167.png" style="zoom:50%;" /></center><h4 id="编码器">2.3 编码器</h4><p>　　解码器的功能正好相反。Netty提供了一组类，用于编写具有以下功能的编码器：</p><ul><li>MessageToByteEncoder&lt;I&gt;——将消息编码为字节</li><li>MessageToMessageEncoder&lt;T&gt;——将消息编码为消息，T代表源数据的类型</li></ul><blockquote><p>还是上面的业务场景，两端通信，通过 JSON 交换信息，而且 JSON文本需要加密，发送端就可以：</p><p>Java 中的对象-&gt; 经过 MessageToMessageEncoder -&gt; String 类型的JSON 文本</p><p>String 类型的 JSON 明文 -&gt; 经过 MessageToByteEncoder -&gt;网络加密报文</p></blockquote><p>　　所以我们可以把 MessageToByteEncoder看成网络报文编码器，MessageToMessageEncoder 看成业务编码器。</p><h5 id="将消息编码为字节">1. 将消息编码为字节</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">I</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelOutboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, I msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>　　encode()方法是你需要实现的唯一抽象方法。它被调用时将会传入要被该类编码为 ByteBuf的出站消息（类型为 I ）。该 ByteBuf 随后将会被转发给 ChannelPipeline中的下一个 ChannelOutboundHandler。</p><h5 id="将消息编码为消息">2. 将消息编码为消息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageToMessageEncoder</span>&lt;<span class="hljs-title">I</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelOutboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, I msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>　　这是需要实现的唯一方法。每个通过 write()方法写入的消息都将会被传递给 encode()方法，以编码为一个或者多个出站消息。随后，这些出站消息将会被转发给ChannelPipeline 中的下一个 ChannelOutboundHandler。</p><h4 id="编解码器类">2.4 编解码器类</h4><p>　　我们一直将解码器和编码器作为单独的实体讨论，但是有时在同一个类中管理入站和出站数据和消息的转换是很有用的。Netty的抽象编解码器类正好用于这个目的，因为它们每个都将捆绑一个解码器/编码器对。这些类同时实现了ChannelInboundHandler 和 ChannelOutboundHandler 接口。</p><p>　　为什么我们并没有一直优先于单独的解码器和编码器使用这些复合类呢？因为通过尽可能地将这两种功能分开，最大化了代码的可重用性和可扩展性，这是Netty 设计的一个基本原则。</p><p>　　相关的类：</p><p>　　抽象类 <strong>ByteToMessageCodec</strong></p><p>　　抽象类 <strong>MessageToMessageCodec</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteToMessageCodec</span>&lt;<span class="hljs-title">I</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelDuplexHandler</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> MessageToByteEncoder#encode(ChannelHandlerContext, Object, ByteBuf)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, I msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> ByteToMessageDecoder#decode(ChannelHandlerContext, ByteBuf, List)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实现ssltls和web服务">2.5 实现SSL/TLS和Web服务</h4><h5 id="通过ssltls-保护netty-应用程序">1. 通过SSL/TLS 保护Netty应用程序</h5><p>　　SSL 和 TLS这样的安全协议，它们层叠在其他协议之上，用以实现数据安全。我们在访问安全网站时遇到过这些协议，但是它们也可用于其他不是基于HTTP 的应用程序，如安全SMTP（SMTPS）邮件服务器甚至是关系型数据库系统。</p><p>　　为了支持 SSL/TLS，Java 提供了 javax.net.ssl 包，它的 SSLContext和 SSLEngine 类使得实现解密和加密相当简单直接。Netty 通过一个名为SslHandler 的 ChannelHandler 实现利用了这个 API，其中 SslHandler在内部使用 SSLEngine 来完成实际的工作。</p><p>　　在大多数情况下，SslHandler 将是 ChannelPipeline 中的第一个ChannelHandler。</p><h5 id="http-系列">2 HTTP 系列</h5><p>　　HTTP 是基于请求/响应模式的：客户端向服务器发送一个 HTTP请求，然后服务器将会返回一个 HTTP 响应。Netty提供了多种编码器和解码器以简化对这个协议的使用。</p><p>　　一个 HTTP 请求/响应可能由多个数据部分组成，FullHttpRequest 和FullHttpResponse消息是特殊的子类型，分别代表了完整的请求和响应。所有类型的 HTTP消息（FullHttpRequest、LastHttpContent 等等）都实现了HttpObject接口。</p><ol type="1"><li>HttpRequestEncoder 将 HttpRequest、HttpContent 和 LastHttpContent消息编码为字节</li><li>HttpResponseEncoder 将 HttpResponse、HttpContent 和 LastHttpContent消息编码为字节</li><li>HttpRequestDecoder 将字节解码为 HttpRequest、HttpContent 和LastHttpContent 消息</li><li>HttpResponseDecoder 将字节解码为 HttpResponse、HttpContent 和LastHttpContent 消息</li></ol><p>　　HttpClientCodec 和 HttpServerCodec则将请求和响应做了一个组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpClientCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CombinedChannelDuplexHandler</span>&lt;<span class="hljs-title">HttpResponseDecoder</span>, <span class="hljs-title">HttpRequestEncoder</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpClientUpgradeHandler</span>.<span class="hljs-title">SourceCodec</span> </span>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServerCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CombinedChannelDuplexHandler</span>&lt;<span class="hljs-title">HttpRequestDecoder</span>, <span class="hljs-title">HttpResponseEncoder</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpServerUpgradeHandler</span>.<span class="hljs-title">SourceCodec</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="聚合http消息">3 聚合HTTP消息</h5><p>　　由于 HTTP的请求和响应可能由许多部分组成，因此你需要聚合它们以形成完整的消息。为了消除这项繁琐的任务，Netty提供了一个聚合器 HttpObjectAggregator，它可以将多个消息部分合并为FullHttpRequest 或者 FullHttpResponse消息。通过这样的方式，你将总是看到完整的消息内容。</p><h5 id="http-压缩">4 HTTP 压缩</h5><p>　　当使用 HTTP时，建议开启压缩功能以尽可能多地减小传输数据的大小。虽然压缩会带来一些CPU时钟周期上的开销，但是通常来说它都是一个好主意，特别是对于文本数据来说。Netty为压缩和解压缩提供了 ChannelHandler 实现，它们同时支持 gzip 和 deflate编码。</p><h5 id="使用https">5 使用HTTPS</h5><p>　　启用 HTTPS 只需要将 SslHandler 添加到 ChannelPipeline 的ChannelHandler 组合中。</p><h5 id="示例">6. 示例</h5><p>　　<strong>服务端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServer</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port = <span class="hljs-number">6789</span>; <span class="hljs-comment">//设置服务端端口</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EventLoopGroup LOOP_GROUP = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ServerBootstrap BOOTSTRAP = <span class="hljs-keyword">new</span> ServerBootstrap();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> SSL = <span class="hljs-keyword">true</span>;<span class="hljs-comment">/*是否开启SSL模式*/</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">final</span> SslContext sslCtx;<br>        <span class="hljs-keyword">if</span> (SSL) &#123;<br>            SelfSignedCertificate ssc = <span class="hljs-keyword">new</span> SelfSignedCertificate();<br>            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sslCtx = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            BOOTSTRAP.group(LOOP_GROUP).channel(NioServerSocketChannel.class)<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            ChannelPipeline pipeline = ch.pipeline();<br>                            <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-keyword">null</span>) &#123;<br>                                pipeline.addLast(sslCtx.newHandler(ch.alloc()));<br>                            &#125;<br>                            <span class="hljs-comment">/*把应答报文 编码*/</span><br>                            pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> HttpResponseEncoder());<br>                            <span class="hljs-comment">/*把请求报文 解码*/</span><br>                            pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> HttpRequestDecoder());<br>                            <span class="hljs-comment">// 以上两个 ChannelHandler 相当于 new HttpServerCodec()</span><br>                            <span class="hljs-comment">/*聚合http为一个完整的报文*/</span><br>                            pipeline.addLast(<span class="hljs-string">&quot;aggregator&quot;</span>, <span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>));<br>                            <span class="hljs-comment">/*把应答报文压缩,非必要*/</span><br>                            pipeline.addLast(<span class="hljs-string">&quot;compressor&quot;</span>, <span class="hljs-keyword">new</span> HttpContentCompressor());<br>                            pipeline.addLast(<span class="hljs-keyword">new</span> BusinessHandler());<br>                        &#125;<br>                    &#125;);<br>            <span class="hljs-comment">// 服务器绑定端口监听</span><br>            ChannelFuture channelFuture = BOOTSTRAP.bind(port).sync();<br>            System.out.println(<span class="hljs-string">&quot;服务端启动成功,端口是:&quot;</span> + port);<br>            System.out.println(<span class="hljs-string">&quot;服务器启动模式： &quot;</span> + (SSL ? <span class="hljs-string">&quot;SSL安全模式&quot;</span> : <span class="hljs-string">&quot;普通模式&quot;</span>));<br>            <span class="hljs-comment">// 监听服务器关闭监听</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            LOOP_GROUP.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　服务端业务 handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BusinessHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发送的返回值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx     返回</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> status  状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(ChannelHandlerContext ctx, String context, HttpResponseStatus status)</span> </span>&#123;<br>        FullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(<br>                HttpVersion.HTTP_1_1, status,<br>                Unpooled.copiedBuffer(context, CharsetUtil.UTF_8)<br>        );<br>        response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="hljs-string">&quot;text/plain;charset=UTF-8&quot;</span>);<br>        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String result = <span class="hljs-string">&quot;&quot;</span>;<br>        FullHttpRequest httpRequest = (FullHttpRequest) msg;<br>        System.out.println(httpRequest.headers());<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取路径</span><br>            String path = httpRequest.uri();<br>            <span class="hljs-comment">//获取body</span><br>            String body = httpRequest.content().toString(CharsetUtil.UTF_8);<br>            <span class="hljs-comment">//获取请求方法</span><br>            HttpMethod method = httpRequest.method();<br>            System.out.println(<span class="hljs-string">&quot;接收到:&quot;</span> + method + <span class="hljs-string">&quot; 请求&quot;</span>);<br>            <span class="hljs-comment">//如果不是这个路径，就直接返回错误</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;/test&quot;</span>.equalsIgnoreCase(path)) &#123;<br>                result = <span class="hljs-string">&quot;非法请求!&quot;</span> + path;<br>                send(ctx, result, HttpResponseStatus.BAD_REQUEST);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//如果是GET请求</span><br>            <span class="hljs-keyword">if</span> (HttpMethod.GET.equals(method)) &#123;<br>                <span class="hljs-comment">//接受到的消息，做业务逻辑处理...</span><br>                System.out.println(<span class="hljs-string">&quot;body:&quot;</span> + body);<br>                result = <span class="hljs-string">&quot;GET请求,应答:&quot;</span> + RespConstant.getNews();<br>                send(ctx, result, HttpResponseStatus.OK);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//如果是其他类型请求，如post</span><br>            <span class="hljs-keyword">if</span> (HttpMethod.POST.equals(method)) &#123;<br>                <span class="hljs-comment">//接受到的消息，做业务逻辑处理...</span><br>                <span class="hljs-comment">//....</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;处理请求失败!&quot;</span>);<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//释放请求</span><br>            httpRequest.release();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 建立连接时，返回消息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;连接的客户端地址:&quot;</span> + ctx.channel().remoteAddress());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　<strong>客户端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpClient</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HOST = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap().group(workerGroup).channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> HttpClientCodec())<br>                                    <span class="hljs-comment">/*聚合http为一个完整的报文*/</span><br>                                    .addLast(<span class="hljs-string">&quot;aggregator&quot;</span>, <span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>))<br>                                    <span class="hljs-comment">/*解压缩*/</span><br>                                    .addLast(<span class="hljs-string">&quot;decompressor&quot;</span>, <span class="hljs-keyword">new</span> HttpContentDecompressor())<br>                                    .addLast(<span class="hljs-keyword">new</span> BusinessClientInboundHandler());<br>                        &#125;<br>                    &#125;);<br><br>            ChannelFuture future = bootstrap.connect(host, port).sync();<br>            future.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">if</span> (HttpServer.SSL) &#123;<br>            System.out.println(<span class="hljs-string">&quot;服务器处于SSL模式，本客户端不支持，退出&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        HttpClient client = <span class="hljs-keyword">new</span> HttpClient();<br>        client.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, HttpServer.port);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　客户端端业务 handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BusinessClientInboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        FullHttpResponse httpResponse = (FullHttpResponse) msg;<br>        System.out.println(httpResponse.status());<br>        System.out.println(httpResponse.headers());<br>        ByteBuf buf = httpResponse.content();<br>        System.out.println(buf.toString(CharsetUtil.UTF_8));<br>        httpResponse.release();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        URI uri = <span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;/test&quot;</span>);<br>        String msg = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        DefaultFullHttpRequest request =<br>                <span class="hljs-keyword">new</span> DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri.toASCIIString(),<br>                        Unpooled.wrappedBuffer(msg.getBytes(StandardCharsets.UTF_8)));<br><br>        <span class="hljs-comment">// 构建http请求</span><br>        request.headers().set(HttpHeaderNames.HOST, HttpClient.HOST);<br>        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);<br>        request.headers().set(HttpHeaderNames.CONTENT_LENGTH, request.content().readableBytes());<br>        <span class="hljs-comment">// 发送http请求</span><br>        ctx.writeAndFlush(request);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="根据客户端的访问来决定是否启用ssl">7.根据客户端的访问来决定是否启用SSL</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoSSLServerHandlerInit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SslContext sslCtx;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AutoSSLServerHandlerInit</span><span class="hljs-params">(SslContext sslCtx)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sslCtx = sslCtx;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ChannelPipeline pipeline = ch.pipeline();<br><br>        <span class="hljs-comment">/*根据客户端的访问来决定是否启用SSL*/</span><br>        pipeline.addLast(<span class="hljs-keyword">new</span> OptionalSslHandler(sslCtx));<br>        <span class="hljs-comment">/*把应答报文 编码*/</span><br>        pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> HttpResponseEncoder());<br>        <span class="hljs-comment">/*把请求报文 解码*/</span><br>        pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> HttpRequestDecoder());<br><br>        <span class="hljs-comment">/*聚合http为一个完整的报文*/</span><br>        pipeline.addLast(<span class="hljs-string">&quot;aggregator&quot;</span>, <span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>));<br>        <span class="hljs-comment">/*把应答报文 压缩,非必要*/</span><br>        pipeline.addLast(<span class="hljs-string">&quot;compressor&quot;</span>, <span class="hljs-keyword">new</span> HttpContentCompressor());<br>        pipeline.addLast(<span class="hljs-keyword">new</span> BusinessHandler());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="序列化问题">3. 序列化问题</h3><p>　　序列化的目的主要有两个：</p><ol type="1"><li>网络传输</li><li>对象持久化</li></ol><p>　　当选行远程跨迸程服务调用时，需要把被传输的 Java对象编码为字节数组或者 ByteBuffer 对象。而当远程服务读取到 ByteBuffer对象或者字节数组时，需要将其解码为发送时的 Java 对象。</p><p>　　Java 序列化仅仅是 Java编解码技术的一种，由于它的种种缺陷，衍生出了多种编解码技术和框架</p><h4 id="java序列化的缺点">3.1 Java序列化的缺点</h4><p>　　Java 序列化从 JDK1.1版本就已经提供，它不需要添加额外的类库，只需实现 java.io.Serializable并生成序列 ID 即可，因此，它从诞生之初就得到了广泛的应用。</p><p>　　但是在远程服务调用（RPC）时，很少直接使用 Java序列化进行消息的编解码和传输，这又是什么原因呢？下面通过分析.Tava序列化的缺点来找出答案。</p><ol type="1"><li>无法跨语言</li></ol><p>　　对于跨进程的服务调用，服务提供者可能会使用 C++或者其他语言开发，当我们需要和异构语言进程交互时 Java序列化就难以胜任。由于 Java 序列化技术是 Java语言内部的私有协议，其他语言并不支持，对于用户来说它完全是黑盒。对于Java序列化后的字节数组，别的语言无法进行反序列化，这就严重阻碍了它的应用。</p><ol start="2" type="1"><li>序列化后的码流太大</li><li>序列化性能太低</li></ol><p>　　无论是序列化后的码流大小，还是序列化的性能，JDK默认的序列化机制表现得都很差。因此，我们通常不会选择 Java序列化作为远程跨节点调用的编解码框架。</p><h4 id="如何选择序列化框架">3.2 如何选择序列化框架</h4><p>　　<strong>选择四要点：</strong></p><ol type="1"><li>是否需要跨语言的支持</li><li>空间:编码后占用空间</li><li>时间:编解码速度</li><li>是否追求可读性</li></ol><p><strong>序列化框架比较</strong></p><p>　　<ahref="https://developer.aliyun.com/article/783611?utm_content=g_1000268438">（传送门：阿里开发者社区）</a></p><p>　　空间比较：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310152155741.png" style="zoom:50%;" /></center><p>　　时间比较：</p><p>　　kryo preregister 和 fst preregister 都能提供优异的性能，其中 fstpre 序列化时间就最佳，而 kryo pre在序列化和反序列化时间开销上基本一致。所以，如果序列化时间是主要的考虑指标，可以选择Kryo 或 FST，都能提供不错的性能体验。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310152157946.png" style="zoom:50%;" /></center><h4 id="序列化示例">3.3 序列化示例</h4><p>　　Netty 内置了对 JBoss Marshalling 和 Protocol Buffers 的支持。</p><h5 id="protocol-buffers-示例">1. Protocol Buffers 示例</h5><p>　　<strong>添加依赖：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.protobuf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>protobuf-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.16.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>　　<strong>服务端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProtoBufServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            bootstrap.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>                            <span class="hljs-comment">/*去除消息长度部分，同时根据这个消息长度读取实际的数据*/</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtobufVarint32FrameDecoder())<br>                                    <span class="hljs-comment">// 反序列化</span><br>                                    .addLast(<span class="hljs-keyword">new</span> ProtobufDecoder(PersonProto.Person.getDefaultInstance()))<br>                                    .addLast(<span class="hljs-keyword">new</span> ProtoBufServerHandler());<br>                        &#125;<br>                    &#125;);<br><br>            ChannelFuture f = bootstrap.bind(port).sync();<br>            System.out.println(<span class="hljs-string">&quot;init start&quot;</span>);<br>            f.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 优雅退出，释放线程池资源</span><br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">8080</span>;<br>        <span class="hljs-keyword">new</span> ProtoBufServer().bind(port);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　服务端业务 handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProtoBufServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        PersonProto.Person req = (PersonProto.Person) msg;<br>        System.out.println(<span class="hljs-string">&quot;get data name = &quot;</span> + req.getName());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cause <span class="hljs-keyword">instanceof</span> IOException) &#123;<br>            System.out.println(<span class="hljs-string">&quot;远程客户端强迫关闭了一个现有的连接。&quot;</span>);<br>        &#125;<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　<strong>客户端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProtoBufClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port, String host)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.group(group)<br>                    .channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            <span class="hljs-comment">/*加一个消息长度，由netty自动计算*/</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtobufVarint32LengthFieldPrepender());<br>                            <span class="hljs-comment">/*负责编码,序列化*/</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtobufEncoder());<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtoBufClientHandler());<br>                        &#125;<br>                    &#125;);<br><br>            ChannelFuture future = bootstrap.connect(host, port).sync();<br>            future.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">8080</span>;<br>        <span class="hljs-keyword">new</span> ProtoBufClient().connect(port, <span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　客户端端业务 handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProtoBufClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Prepare to make data........&quot;</span>);<br>        PersonProto.Person.Builder builder = PersonProto.Person.newBuilder();<br>        builder.setName(<span class="hljs-string">&quot;debuggingWorld&quot;</span>);<br>        builder.setId(<span class="hljs-number">1</span>);<br>        builder.setEmail(<span class="hljs-string">&quot;debuggingWorld@xxx.com&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;send data........&quot;</span>);<br>        ctx.writeAndFlush(builder.build());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="集成第三方messagepack">2. 集成第三方MessagePack</h5><p>　　<strong>添加依赖：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.msgpack<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>msgpack<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.6.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>　　<strong>发送对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ToString</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@Message</span><span class="hljs-comment">//MessagePack 提供的注解，表明这是一个需要序列化的实体类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> UserContact userContact;<br>&#125;<br><br><span class="hljs-meta">@ToString</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Message</span><span class="hljs-comment">//MessagePack 提供的注解，表明这是一个需要序列化的实体类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserContact</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String mail;<br>    <span class="hljs-keyword">private</span> String phone;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　<strong>服务端 handler：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelInitializerImp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ch.pipeline().addLast(<span class="hljs-keyword">new</span> LengthFieldBasedFrameDecoder(<span class="hljs-number">65535</span>,<br>                <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>        ch.pipeline().addLast(<span class="hljs-keyword">new</span> MsgPackDecoder());<br>        ch.pipeline().addLast(<span class="hljs-keyword">new</span> MsgPackServerHandler());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　<strong>MessagePack 解码器：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*基于MessagePack的解码器，反序列化*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgPackDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageDecoder</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> length = msg.readableBytes();<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];<br>        msg.getBytes(msg.readerIndex(), array, <span class="hljs-number">0</span>, length);<br>        MessagePack messagePack = <span class="hljs-keyword">new</span> MessagePack();<br>        out.add(messagePack.read(array, User.class));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　服务端业务 handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgPackServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger counter = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/*** 服务端读取到网络数据后的处理*/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//将上一个handler生成的数据强制转型</span><br>        User user = (User) msg;<br>        System.out.println(<span class="hljs-string">&quot;Server Accept[&quot;</span> + user + <span class="hljs-string">&quot;] and the counter is:&quot;</span> + counter.incrementAndGet());<br>        <span class="hljs-comment">//服务器的应答</span><br>        String resp = <span class="hljs-string">&quot;I process user :&quot;</span> + user.getUserName() + System.getProperty(<span class="hljs-string">&quot;line.separator&quot;</span>);<br>        ctx.writeAndFlush(Unpooled.copiedBuffer(resp.getBytes()));<br>        ctx.fireChannelRead(user);<br>    &#125;<br><br>    <span class="hljs-comment">/*** 发生异常后的处理*/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　<strong>客户端 handler：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelInitializerImp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">/*告诉netty，计算一下报文的长度，然后作为报文头加在前面*/</span><br>        ch.pipeline().addLast(<span class="hljs-keyword">new</span> LengthFieldPrepender(<span class="hljs-number">2</span>));<br>        <span class="hljs-comment">/*对服务器的应答也要解码，解决粘包半包*/</span><br>        ch.pipeline().addLast(<span class="hljs-keyword">new</span> LineBasedFrameDecoder(<span class="hljs-number">1024</span>));<br><br>        <span class="hljs-comment">/*对我们要发送的数据做编码-序列化*/</span><br>       ch.pipeline().addLast(<span class="hljs-keyword">new</span> MsgPackEncode());<br>       ch.pipeline().addLast(<span class="hljs-keyword">new</span> MsgPackClientHandler(<span class="hljs-number">5</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　<strong>MessagePack 编码器：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*基于MessagePack的编码器，序列化*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgPackEncode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, User msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        MessagePack messagePack = <span class="hljs-keyword">new</span> MessagePack();<br>        <span class="hljs-keyword">byte</span>[] raw = messagePack.write(msg);<br>        out.writeBytes(raw);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　客户端端业务 handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgPackClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> sendNumber;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MsgPackClientHandler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sendNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sendNumber = sendNumber;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger counter = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/*客户端读取到网络数据后的处理*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;client Accept[&quot;</span> + msg.toString(CharsetUtil.UTF_8)<br>                + <span class="hljs-string">&quot;] and the counter is:&quot;</span> + counter.incrementAndGet());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        User[] users = makeUsers();<br>        <span class="hljs-comment">//发送数据</span><br>        <span class="hljs-keyword">for</span> (User user : users) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Send user:&quot;</span> + user);<br>            ctx.write(user);<br>        &#125;<br>        ctx.flush();<br>    &#125;<br><br>    <span class="hljs-comment">/*发生异常后的处理*/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br><br>    <span class="hljs-comment">/*生成用户实体类的数组，以供发送*/</span><br>    <span class="hljs-keyword">private</span> User[] makeUsers() &#123;<br>        User[] users = <span class="hljs-keyword">new</span> User[sendNumber];<br>        User user = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sendNumber; i++) &#123;<br>            user = <span class="hljs-keyword">new</span> User();<br>            user.setAge(i);<br>            String userName = <span class="hljs-string">&quot;debug&quot;</span> + i;<br>            user.setUserName(userName);<br>            user.setId(<span class="hljs-string">&quot;No:&quot;</span> + (sendNumber - i));<br>            user.setUserContact(<br>                    <span class="hljs-keyword">new</span> UserContact(userName + <span class="hljs-string">&quot;@xxx.com&quot;</span>, <span class="hljs-string">&quot;133&quot;</span>));<br>            users[i] = user;<br>        &#125;<br>        <span class="hljs-keyword">return</span> users;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty——Netty常用组件</title>
    <link href="/2023/10/08/Netty%E2%80%94%E2%80%94Netty%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6/"/>
    <url>/2023/10/08/Netty%E2%80%94%E2%80%94Netty%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="eventloop和eventloopgroup">1. EventLoop和EventLoopGroup</h3><p>　　回想一下在 NIO 中是如何处理我们关心的事件的？在一个 while 循环中select 出事件，然后依次处理每种事件。我们可以把它称为事件循环，这就是EventLoop。interface io.netty.channel. EventLoop 定义了Netty的核心抽象，用于处理网络连接的生命周期中所发生的事件。</p><p>　　io.netty.util.concurrent 包构建在 JDK 的 java.util.concurrent包上。而 io.netty.channel 包中的类，为了与 Channel的事件进行交互，扩展了这些接口/类。一个 EventLoop将由一个永远都不会改变的 Thread 驱动，同时任务（Runnable 或者Callable）可以直接提交给 EventLoop 实现，以立即执行或者调度执行。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082221379.png" style="zoom:67%;" /></center><p><strong>线程的分配</strong></p><p>　　服务于 Channel 的 I/O 和事件的 EventLoop 包含在 EventLoopGroup中。</p><p>　　异步传输实现只使用了少量的 EventLoop（以及和它们相关联的Thread），而且在当前的线程模型中，它们可能会被多个 Channel所共享。这使得可以通过尽可能少量的 Thread 来支撑大量的Channel，而不是每个 Channel 分配一个 Thread。EventLoopGroup负责为每个新创建的 Channel 分配一个EventLoop。在当前实现中，使用顺序循环（round-robin）的方式进行分配以获取一个均衡的分布，并且相同的EventLoop 可能会被分配给多个 Channel。</p><p>　　一旦一个 Channel 被分配给一个EventLoop，它将在它的整个生命周期中都使用这个EventLoop（以及相关联的Thread）。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082230815.png" style="zoom:50%;" /></center><p>　　需要注意，EventLoop 的分配方式对 ThreadLocal的使用的影响。因为一个 EventLoop 通常会被用于支撑多个Channel，所以对于所有相关联的 Channel 来说，ThreadLocal都将是一样的。这使得它对于实现状态追踪等功能来说是个糟糕的选择。然而，在一些无状态的上下文中，它仍然可以被用于在多个Channel 之间共享一些重度的或者代价昂贵的对象，甚至是事件。</p><p><strong>线程管理</strong></p><p>　　在内部，当提交任务时如果<strong>（</strong>当前）调用线程正是支撑EventLoop 的线程，那么所提交的代码块将会被（直接）执行。否则，EventLoop将调度该任务以便稍后执行，并将它放入到内部队列中。当EventLoop下次处理它的事件时，它会执行队列中的那些任务/事件。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082234192.png" style="zoom:50%;" /></center><h3 id="channeleventloopgroup和channelfuture">2.Channel、EventLoop(Group)和ChannelFuture</h3><p>Netty 网络抽象的代表：</p><blockquote><ul><li><p>Channel—Socket；</p></li><li><p>EventLoop—控制流、多线程处理、并发；</p></li><li><p>ChannelFuture—异步通知。</p></li></ul></blockquote><p>　　Channel 和 EventLoop关系如图：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082250245.png" style="zoom:80%;" /></center><p>　　从图上我们可以看出 Channel 需要被注册到某个 EventLoop 上，在Channel 整个生命周期内都由这个 EventLoop 处理 IO 事件，也就是说一个Channel 和一个 EventLoop 进行了绑定，但是一个 EventLoop 可以同时被多个Channel 绑定。</p><h4 id="channel-接口">2.1 Channel 接口</h4><p>　　基本的 I/O 操作（bind()、connect()、read() 和write()）依赖于底层网络传输所提供的原语。在基于 Java的网络编程中，其基本的构造是类 Socket。Netty 的 Channel 接口所提供的API，被用于所有的 I/O 操作。大大地降低了直接使用 Socket类的复杂性。此外， Channel也是拥有许多预定义的、专门化实现的广泛类层次结构的根。</p><p>　　由于 Channel 是独一无二的，所以为了保证顺序将 Channel 声明为java.lang.Comparable 的一个子接口。因此，如果两个不同的 Channel实例都返回了相同的散列码，那么 AbstractChannel 中的 compareTo()方法的实现将会抛出一个 Error。</p><h5 id="channel-的生命周期状态">1. Channel 的生命周期状态</h5><ul><li><p>ChannelUnregistered ：Channel 已经被创建，但还未注册到EventLoop</p></li><li><p>ChannelRegistered ：Channel 已经被注册到了 EventLoop</p></li><li><p>ChannelActive ：Channel处于活动状态（已经连接到它的远程节点）,它现在可以接收和发送数据了</p></li><li><p>ChannelInactive ：Channel 没有连接到远程节点</p></li></ul><p>　　当这些状态发生改变时，将会生成对应的事件。这些事件将会被转发给ChannelPipeline 中的ChannelHandler，其可以随后对它们做出响应。在我们的编程中，关注ChannelActive 和 ChannelInactive 会更多一些。</p><h5 id="channel-的重要方法">2. Channel 的重要方法</h5><ul><li><p>eventLoop： 返回分配给 Channel 的 EventLoop</p></li><li><p>pipeline： 返回 Channel 的 ChannelPipeline，也就是说每个 Channel都有自己的 ChannelPipeline。</p></li><li><p>isActive： 如果 Channel 是活动的，则返回true。活动的意义可能依赖于底层的传输。例如，一个 Socket传输一旦连接到了远程节点便是活动的，而一个 Datagram传输一旦被打开便是活动的。</p></li><li><p>localAddress： 返回本地的 SokcetAddress</p></li><li><p>remoteAddress： 返回远程的 SocketAddress</p></li><li><p>write： 将数据写到远程节点，注意，这个写只是写往 Netty内部的缓存，还没有真正写往 socket。</p></li><li><p>flush： 将之前已写的数据冲刷到底层 socket 进行传输。</p></li><li><p>writeAndFlush： 一个简便的方法，等同于调用 write() 并接着调用flush()</p></li></ul><h3 id="channelpipeline和channelhandlercontext">3.ChannelPipeline和ChannelHandlerContext</h3><h4 id="channelpipeline-接口">3.1 ChannelPipeline 接口</h4><p>当 Channel 被创建时，它将会被自动地分配一个新的 ChannelPipeline，每个Channel 都有自己的 ChannelPipeline。这项关联是永久性的。在 Netty组件的生命周期中，这是一项固定的操作，不需要开发人员的任何干预。</p><p>　　ChannelPipeline 提供了 ChannelHandler链的容器，并定义了用于在该链上传播<strong>入站</strong>（也就是从网络到业务处理）和<strong>出站</strong>（也就是从业务处理到网络）各种事件流的 API。这些ChannelHandler对象接收事件、执行它们所实现的处理逻辑，并将数据传递给链中的下一个ChannelHandler，而且 ChannelHandler对象也完全可以拦截事件不让事件继续传递。它们的执行顺序是由它们被添加的顺序所决定的。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082307737.png" style="zoom:50%;" /></center><h5 id="channelhandler-的生命周期">1. ChannelHandler 的生命周期</h5><p>在 ChannelHandler 被添加到 ChannelPipeline 中或者被从 ChannelPipeline中移除时会调用下面这些方法。这些方法中的每一个都接受一个ChannelHandlerContext 参数。</p><ul><li><p><strong>handlerAdded</strong> 当把 ChannelHandler 添加到ChannelPipeline 中时被调用</p></li><li><p><strong>handlerRemoved</strong> 当从 ChannelPipeline 中移除ChannelHandler 时被调用</p></li><li><p><strong>exceptionCaught</strong> 当处理过程中在 ChannelPipeline中有错误产生时被调用</p></li></ul><h5 id="channelpipeline中的channelhandler">２.ChannelPipeline中的ChannelHandler</h5><p>　　入站和出站 ChannelHandler 被安装到同一个 ChannelPipeline中，ChannelPipeline以双向链表的形式进行维护管理。比如下图，我们在网络上传递的数据，要求加密，但是加密后密文比较大，需要压缩后再传输，而且按照业务要求，需要检查报文中携带的用户信息是否合法，于是我们实现了5个Handler：解压（入）Handler、压缩（出）handler、解密（入）Handler、加密（出） Handler、授权（入） Handler。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082314428.png" style="zoom:50%;" /></center><p>　　如果一个消息或者任何其他的入站事件被读取，那么它会从ChannelPipeline 的头部开始流动，但是只被处理入站事件的 Handler处理，也就是解压（入）Handler、解密（入） Handler、授权（入）Handler，最终，数据将会到达 ChannelPipeline的尾端，届时，所有处理就都结束了。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082316079.png" style="zoom:50%;" /></center><p>　　数据的出站运动（即正在被写的数据）在概念上也是一样的。在这种情况下，数据将从链的尾端开始流动，但是只被处理出站事件的Handler 处理，也就是加密（出）Handler、压缩（出）handler，直到它到达链的头部为止。在这之后，出站数据将会到达网络传输层，也就是我们的Socket。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082317165.png" style="zoom:50%;" /></center><p>　　Netty 能区分入站事件的 Handler 和出站事件的Handler，并确保数据只会在具有相同定向类型的两个 ChannelHandler之间传递。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310102218508.png" style="zoom:50%;" /></center><p>　</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310102222602.png" style="zoom:50%;" /></center><p>　　所以在我们编写 Netty 应用程序时要注意，分属出站和入站不同的Handler，<strong>在业务没特殊要求的情况下</strong>是无所谓顺序的，而同属一个方向的Handler 则是有顺序的，因为上一个 Handler 处理的结果往往是下一个 Handler的要求的输入。</p><h5 id="channelpipeline上的方法">3. ChannelPipeline上的方法</h5><p>　　既然 ChannelPipeline 以双向链表的形式进行维护管理Handler，自然也提供了对应的方法在 ChannelPipeline 中增加或者删除、替换Handler。</p><ul><li><strong>addFirst、addBefore、addAfter、addLast：</strong> 将一个ChannelHandler 添加到 ChannelPipeline 中</li><li><strong>remove：</strong> 将一个 ChannelHandler 从 ChannelPipeline中移除</li><li><strong>replace：</strong> 将 ChannelPipeline 中的一个ChannelHandler 替换为另一个 ChannelHandler</li><li><strong>get：</strong> 通过类型或者名称返回 ChannelHandler</li><li><strong>context：</strong> 返回和 ChannelHandler 绑定的ChannelHandlerContext</li><li><strong>names：</strong> 返回 ChannelPipeline 中所有 ChannelHandler的名称</li></ul><h4 id="channelhandlercontext">3.2 ChannelHandlerContext</h4><p>　　ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline之间的关联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建ChannelHandlerContext，为什么需要这个 ChannelHandlerContext？ChannelPipeline 以双向链表的形式进行维护管理Handler，毫无疑问，Handler 在放入 ChannelPipeline 的时候必须要有两个指针pre 和 next 来说明它的前一个元素和后一个元素，但是 Handler本身来维护这两个指针合适吗？想想我们在使用 JDK 的 LinkedList的时候，我们放入 LinkedList 的数据是不会带这两个指针的，LinkedList内部会用类 Node 对我们的数据进行包装，而类 Node 则带有两个指针 pre 和next。所以，ChannelHandlerContext 的主要作用就和 LinkedList 内部的类Node 类似。</p><p>不过 ChannelHandlerContext不仅仅只是个包装类，它还提供了很多的方法，比如让事件从当前ChannelHandler 传递给链中的下一个 ChannelHandler，还可以被用于获取底层的Channel，还可以用于写出站数据。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082337365.png" style="zoom:50%;" /></center><h5 id="channelchannelpipeline和channelhandlercontext上的事件传播">1.Channel、ChannelPipeline和ChannelHandlerContext上的事件传播</h5><p>　　ChannelHandlerContext 有很多的方法，其中一些方法也存在于 Channel和 Channel-Pipeline本身上，<strong>但是有一点重要的不同。</strong>如果调用 Channel 或者ChannelPipeline 上的这些方法，它们将沿着整个 ChannelPipeline进行传播。而调用位于 ChannelHandlerContext上的相同方法，则将从当前所关联的 ChannelHandler开始，并且只会传播给位于该 ChannelPipeline中的下一个（入站下一个，出站上一个）能够处理该事件的ChannelHandler。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082341270.png" style="zoom:50%;" /></center><p>　　我们用一个实际例子来说明，比如服务器收到对端发过来的报文，解压后需要进行解密，结果解密失败，要给对端一个应答。</p><p>　　如果发现解密失败原因是服务器和对端的加密算法不一致，应答报文只能以明文的压缩格式发送，就可以在解密handler 中直接使用 ctx.write 给对端应答，这样应答报文就只经过压缩Handler 就发往了对端；</p><p>　　其他情况下，应答报文要以加密和压缩格式发送，就可以在解密 handler中使用 channel.write() 或者 channelpipeline.write()给对端应答，这样应答报文就会流经整个出站处理过程。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082352986.png" style="zoom:50%;" /></center><h5 id="channelhandlercontext-的api">2. ChannelHandlerContext 的API</h5><ul><li><strong>alloc</strong> 返回和这个实例相关联的 Channel 所配置的ByteBufAllocator</li><li><strong>bind</strong> 绑定到给定的 SocketAddress，并返回ChannelFuture</li><li><strong>channel</strong> 返回绑定到这个实例的 Channel</li><li><strong>close</strong> 关闭 Channel，并返回 ChannelFuture</li><li><strong>connect</strong> 连接给定的 SocketAddress，并返回ChannelFuture</li><li><strong>deregister</strong> 从之前分配的 EventExecutor 注销，并返回ChannelFuture</li><li><strong>disconnect</strong> 从远程节点断开，并返回ChannelFuture</li><li><strong>executor</strong> 返回调度事件的 EventExecutor</li><li><strong>fireChannelActive</strong> 触发对下一个ChannelInboundHandler 上的 channelActive() 方法（已连接）的调用</li><li><strong>fireChannelInactive</strong> 触发对下一个ChannelInboundHandler 上的 channelInactive() 方法（已关闭）的调用</li><li><strong>fireChannelRead</strong> 触发对下一个 ChannelInboundHandler上的 channelRead() 方法（已接收的消息）的调用</li><li><strong>fireChannelReadComplete</strong> 触发对下一个ChannelInboundHandler 上的 channelReadComplete() 方法的调用</li><li><strong>fireChannelRegistered</strong> 触发对下一个ChannelInboundHandler 上的 fireChannelRegistered() 方法的调用</li><li><strong>fireChannelUnregistered</strong> 触发对下一个ChannelInboundHandler 上的fire ChannelUnregistered() 方法的调用</li><li><strong>fireChannelWritabilityChanged</strong> 触发对下一个ChannelInboundHandler 上的 fireChannelWritabilityChanged()方法的调用</li><li><strong>fireExceptionCaught</strong> 触发对下一个ChannelInboundHandler 上的 fireExceptionCaught(Throwable)方法的调用</li><li><strong>fireUserEventTriggered</strong> 触发对下一个ChannelInboundHandler 上的 fireUserEventTriggered(Object evt)方法的调用</li><li><strong>handler</strong> 返回绑定到这个实例的 ChannelHandler</li><li><strong>isRemoved</strong> 如果所关联的 ChannelHandler 已经被从ChannelPipeline 中移除则返回 true</li><li><strong>name</strong> 返回这个实例的唯一名称</li><li><strong>pipeline</strong> 返回这个实例所关联的 ChannelPipeline</li><li><strong>read</strong> 将数据从 Channel读取到第一个入站缓冲区；如果读取成功则触发一个 channelRead事件，并（在最后一个消息被读取完成后）通知 ChannelInboundHandler 的channelReadComplete(ctx) 方法</li><li><strong>write</strong> 通过这个实例写入消息并经过ChannelPipeline</li><li><strong>writeAndFlush</strong> 通过这个实例写入并冲刷消息并经过ChannelPipeline</li></ul><p>　　当使用 ChannelHandlerContext 的 API 的时候，有以下两点：</p><blockquote><ul><li>ChannelHandlerContext 和 ChannelHandler之间的关联（绑定）是永远不会改变的，所以缓存对它的引用是安全的；</li><li>相对于其他类的同名方法，ChannelHandlerContext的方法将产生更短的事件</li></ul></blockquote><h3 id="channelhandler">4. ChannelHandler</h3><h4 id="channelhandler-接口">4.1 ChannelHandler 接口</h4><p>从应用程序开发人员的角度来看，Netty的主要组件是ChannelHandler，它充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandler的方法是由网络事件触发的。事实上，ChannelHandler可专门用于几乎任何类型的动作，例如将数据从一种格式转换为另外一种格式，例如各种编解码，或者处理转换过程中所抛出的异常。</p><p>　　举例来说，ChannelInboundHandler是一个你将会经常实现的子接口。这种类型的 ChannelHandler接收入站事件和数据，这些数据随后将会被你的应用程序的业务逻辑所处理。当你要给连接的客户端发送响应时，也可以从ChannelInboundHandler直接冲刷数据然后输出到对端。应用程序的业务逻辑通常实现在一个或者多个ChannelInboundHandler 中。</p><p>　　Netty 定义了下面两个重要的 ChannelHandler 子接口：</p><blockquote><ul><li><p>ChannelInboundHandler——处理入站数据以及各种状态变化；</p></li><li><p>ChannelOutboundHandler——处理出站数据并且允许拦截所有的操作。</p></li></ul></blockquote><h4 id="channelinboundhandler-接口">4.2 ChannelInboundHandler 接口</h4><p>　　下面列出了接口 ChannelInboundHandler的生命周期方法。这些方法将会在数据被接收时或者与其对应的 Channel状态发生改变时被调用。正如我们前面所提到的，这些方法和 Channel的生命周期密切相关。</p><ul><li><strong>channelRegistered</strong> 当 Channel 已经注册到它的EventLoop 并且能够处理 I/O 时被调用</li><li><strong>channelUnregistered</strong> 当 Channel 从它的 EventLoop注销并且无法处理任何 I/O 时被调用</li><li><strong>channelActive</strong> 当 Channel处于活动状态时被调用；Channel 已经连接/绑定并且已经就绪</li><li><strong>channelInactive</strong> 当 Channel离开活动状态并且不再连接它的远程节点时被调用</li><li><strong>channelReadComplete</strong> 当Channel上的一个读操作完成时被调用</li><li><strong>channelRead</strong> 当从 Channel 读取数据时被调用</li><li><strong>ChannelWritabilityChanged</strong> 当 Channel的可写状态发生改变时被调用。可以通过调用 Channel 的 isWritable()方法来检测 Channel 的可写性。与可写性相关的阈值可以通过Channel.config().setWriteHighWaterMark() 和Channel.config().setWriteLowWaterMark() 方法来设置</li><li><strong>userEventTriggered</strong> 当ChannelnboundHandler.fireUserEventTriggered() 方法被调用时被调用。</li></ul><h4 id="channeloutboundhandler-接口">4.3 ChannelOutboundHandler接口</h4><p>　　出站操作和数据将由 ChannelOutboundHandler 处理。它的方法将被Channel、Channel-Pipeline 以及 ChannelHandlerContext 调用。</p><p>　　所有由 ChannelOutboundHandler 本身所定义的方法：</p><ul><li><strong>bind(ChannelHandlerContext,SocketAddress,ChannelPromise)</strong>当请求将 Channel 绑定到本地地址时被调用</li><li><strong>connect(ChannelHandlerContext,SocketAddress,SocketAddress,ChannelPromise)</strong>当请求将 Channel 连接到远程节点时被调用</li><li><strong>disconnect(ChannelHandlerContext,ChannelPromise)</strong>当请求将 Channel 从远程节点断开时被调用</li><li><strong>close(ChannelHandlerContext,ChannelPromise)</strong>当请求关闭 Channel 时被调用</li><li><strong>deregister(ChannelHandlerContext,ChannelPromise)</strong>当请求将 Channel 从它的 EventLoop 注销时被调用</li><li><strong>read(ChannelHandlerContext)</strong> 当请求从 Channel读取更多的数据时被调用</li><li><strong>flush(ChannelHandlerContext) </strong> 当请求通过 Channel将入队数据冲刷到远程节点时被调用</li><li><strong>write(ChannelHandlerContext,Object,ChannelPromise)</strong>当请求通过 Channel 将数据写到远程节点时被调用</li></ul><h4 id="channelhandler的适配器">4.4 ChannelHandler的适配器</h4><p>　　有一些适配器类可以将编写自定义的 ChannelHandler所需要的工作降到最低限度，因为它们提供了定义在对应接口中的所有方法的默认实现。因为你有时会忽略那些不感兴趣的事件，所以Netty 提供了抽象基类 ChannelInboundHandlerAdapter（处理入站）和ChannelOutboundHandlerAdapter（处理出站）。</p><p>　　我们可以使用 ChannelInboundHandlerAdapter 和ChannelOutboundHandlerAdapter 类作为自己的 ChannelHandler的起始点。这两个适配器分别提供了 ChannelInboundHandler 和ChannelOutboundHandler 的基本实现。通过扩展抽象类ChannelHandlerAdapter，它们获得了它们共同的超接口 ChannelHandler的方法。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310092217678.png" style="zoom:25%;" /></center><p>　　不过 ChannelOutboundHandler 有个非常让人迷惑的 read方法，ChannelOutboundHandler 不是处理出站事件的吗？怎么会有 read方法呢？其实这个 read方法不是表示读数据，而是表示业务发出了读（read）数据的要求，这个要求也会封装为一个事件进行传播，这个事件因为是业务发出到网络的，自然就是个出站事件，而且这个事件触发的就是ChannelOutboundHandler 中 read 方法。</p><p>　　如果我们的 Handler既要处理入站又要处理出站怎么办呢？这个时候就可以使用类ChannelDuplexHandler，当然也可以同时实现 ChannelOutboundHandler,ChannelInboundHandler 这两个接口，自然就要麻烦很多了。</p><h4 id="handler的共享和并发安全性">4.5 Handler的共享和并发安全性</h4><p>　　ChannelHandlerAdapter 还提供了实用方法isSharable()。如果其对应的实现被标注为 Sharable，那么这个方法将返回true，表示它可以被添加到多个 ChannelPipeline。</p><p>　　这就牵涉到了我们实现的 Handler 的共享性和线程安全性。回顾我们的Netty 代码，在往 pipeline 安装 Handler的时候，基本上是 new 出 Handler的实例。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310092223763.png" style="zoom:50%;" /></center><p>　　因为每个 socketChannel 有自己的 pipeline 而且每个 socketChannel又是和线程绑定的，所以这些 Handler 的实例之间完全独立的，只要 Handler的实例之间不是共享了全局变量，Handler 的实例是线程安全的。</p><p>　　但是如果业务需要我们在多个 socketChannel 之间共享一个 Handler的实例怎么办呢？比如统计服务器接受到和发出的业务报文总数，我们就需要用一个Handler 的实例来横跨所有的 socketChannel 来统计所有 socketChannel业务报文数。</p><p>　　为了实现这一点，我们可以实现一个 MessageCountHandler，并且在MessageCountHandler 上使用 Netty 的 <span class="citation"data-cites="Sharable">@Sharable</span> 注解，然后在安装MessageCountHandler 实例到 pipeline 时，共用一个即可。当然，因为MessageCountHandler 实例是共享的，所以在实现 MessageCountHandler的统计功能时，请务必注意线程安全，我们在具体实现时就使用了 Java并发编程里的 Atomic 类来保证这一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageCountHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelDuplexHandler</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> AtomicLong inCount = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> AtomicLong outCount = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;收到报文总数：&quot;</span>+inCount.incrementAndGet());<br>        <span class="hljs-keyword">super</span>.channelRead(ctx, msg);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;发出报文总数：&quot;</span>+outCount.incrementAndGet());<br>        <span class="hljs-keyword">super</span>.flush(ctx);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310092252768.png" style="zoom:50%;" /></center><h4 id="资源管理和simplechannelinboundhandler">4.6资源管理和SimpleChannelInboundHandler</h4><p>　　<ahref="https://www.skjava.com/series/article/1720220745">（传送门）</a></p><p>　　回想一下我们在 NIO中是如何接收和发送网络数据的？都是首先创建了一个Buffer，应用程序中的业务部分和 Channel 之间通过 Buffer进行数据的交换：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310092255016.png" style="zoom:50%;" /></center><p>　　Netty 在处理网络数据时，同样也需要 Buffer，在 Read 网络数据时由Netty 创建 Buffer，Write 网络数据时 Buffer往往是由业务方创建的。不管是读和写，Buffer用完后都必须进行释放，否则可能会造成内存泄露。</p><h5 id="出站buffer">1. 出站Buffer</h5><p>　　在 Write 网络数据时，可以确保数据被写往网络了，Netty 会自动进行Buffer 的释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    String request = <span class="hljs-string">&quot;debuggingWorld&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        ByteBuf byteBuf = Unpooled.buffer(request.length());<br>        byteBuf.writeBytes(request.getBytes());<br>        ctx.writeAndFlush(byteBuf); <span class="hljs-comment">// writeAndFlush 会自动释放</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　Netty 默认会在 ChannelPipeline 的收尾加上 HeadContext 和TailContext。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310122246484.png" style="zoom:50%;" /></center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeadContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractChannelHandlerContext</span></span><br><span class="hljs-class">            <span class="hljs-keyword">implements</span> <span class="hljs-title">ChannelOutboundHandler</span>, <span class="hljs-title">ChannelInboundHandler</span> </span>&#123;<br>  ....<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> </span>&#123;<br>            unsafe.write(msg, promise);<br>        &#125;<br>  .....<br>&#125;<br></code></pre></td></tr></table></figure><p>　　HeadContext 实现了入站和出站 ChannelHandler，在 write() 中调用unsafe.write()，其内部会进行释放（转传送门）。</p><p>　　但是如果 Write 网络数据时，我们有 outBoundHandler 处理了 write()操作并丢弃了数据，没有继续往下传递 Handler，要由我们负责释放这个Buffer，就必须调用 ReferenceCountUtil.release方法，否则就可能会造成内存泄露。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerOutReadHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelOutboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// super.write(ctx, msg, promise);</span><br>        ReferenceCountUtil.release(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="入站buffer">2. 入站Buffer</h5><p>　　在 Read 网络数据时，如果我们可以确保每个 InboundHandler都把数据往后传递了，也就是调用了相关的 fireChannelRead 方法，Netty也会帮我们释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.DefaultChannelPipeline.TailContext#channelRead</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>    onUnhandledInboundMessage(ctx, msg);<br>&#125;<br><br><span class="hljs-comment">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUnhandledInboundMessage</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>    onUnhandledInboundMessage(msg);<br>    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>        logger.debug(<span class="hljs-string">&quot;Discarded message pipeline : &#123;&#125;. Channel : &#123;&#125;.&quot;</span>,<br>                     ctx.pipeline().names(), ctx.channel());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUnhandledInboundMessage</span><span class="hljs-params">(Object msg)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        logger.debug(<br>                <span class="hljs-string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot;</span> +<br>                        <span class="hljs-string">&quot;Please check your pipeline configuration.&quot;</span>, msg);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        ReferenceCountUtil.release(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　同样的，如果我们有 InboundHandler处理了数据，又不继续往后传递，又不调用负责释放的ReferenceCountUtil.release方法，就可能会造成内存泄露（比如入站数据在解密失败后应该终止传递）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    ByteBuf in = (ByteBuf) msg;<br>    String request = in.toString(CharsetUtil.UTF_8);<br>    System.out.println(<span class="hljs-string">&quot;Server accept: &quot;</span> + request);<br>    <span class="hljs-comment">// ctx.fireChannelRead(msg);</span><br>    <span class="hljs-comment">// ReferenceCountUtil.release(msg);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>　　但是由于消费入站数据是一项常规任务，所以 Netty提供了一个特殊的被称为 SimpleChannelInboundHandler 的ChannelInboundHandler 实现。这个实现会在数据被 channelRead0()方法消费之后自动释放数据。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310092300232.png" style="zoom:50%;" /></center><p>　　同时系统为我们提供的各种预定义 Handler实现，都实现了数据的正确处理，所以我们自行在编写业务 Handler时，也需要注意这一点：<strong>要么继续传递，要么自行释放</strong>。</p><h3 id="内置通信传输模式">5. 内置通信传输模式</h3><ul><li><p><strong>NIO</strong> io.netty.channel.socket.nio 使用java.nio.channels 包作为基础——基于选择器的方式</p></li><li><p><strong>Epoll</strong> io.netty.channel.epoll 由 JNI 驱动的epoll() 和非阻塞 IO。这个传输支持只有在 Linux 上可用的多种特性，如SO_REUSEPORT，比 NIO 传输更快，而且是完全非阻塞的。将 NioEventLoopGroup替换为 EpollEventLoopGroup ， 并且将 NioServerSocketChannel.class 替换为EpollServerSocketChannel.class 即可。</p></li><li><p><strong>OIO</strong> io.netty.channel.socket.oio 使用 java.net包作为基础——使用阻塞流</p></li><li><p><strong>Local</strong> io.netty.channel.local 可以在 VM内部通过管道进行通信的本地传输</p></li><li><p><strong>Embedded</strong> io.netty.channel.embedded Embedded传输，允许使用 ChannelHandler 而又不需要一个真正的基于网络的传输。在测试ChannelHandler 实现时非常有用</p></li></ul><h3 id="引导bootstrap">6. 引导Bootstrap</h3><p>　　有两种类型的引导：一种用于客户端（简单地称为Bootstrap），而另一种（ServerBootstrap）用于服务器。无论你的应用程序使用哪种协议或者处理哪种类型的数据，唯一决定它使用哪种引导类的是它是作为一个客户端还是作为一个服务器。</p><table><thead><tr><th></th><th><strong>Bootstrap</strong></th><th><strong>ServerBootstrap</strong></th></tr></thead><tbody><tr><td>网络编程中的作用</td><td>连接到远程主机和端口</td><td>绑定到一个本地端口</td></tr><tr><td>EventLoopGroup 的数目</td><td>1</td><td>2</td></tr></tbody></table><p>ServerBootstrap将绑定到一个端口，因为服务器必须要监听连接，而Bootstrap则是由想要连接到远程节点的客户端应用程序所使用的。</p><p>　　第二个区别可能更加明显。引导一个客户端只需要一个EventLoopGroup，但是一个 ServerBootstrap则需要两个（也可以是同一个实例）。因为服务器需要两组不同的Channel。第一组将只包含一个ServerChannel，代表服务器自身的已绑定到某个本地端口的正在监听的套接字。而第二组将包含所有已创建的用来处理传入客户端连接（对于每个服务器已经接受的连接都有一个）的Channel。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310102246292.png" style="zoom:70%;" /></center><p>　　与 ServerChannel 相关联的 EventLoopGroup将分配一个负责为传入连接请求创建 Channel 的EventLoop。一旦连接被接受，第二个 EventLoopGroup 就会给它的 Channel分配一个 EventLoop。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310102248220.png" style="zoom:50%;" /></center><h3 id="channelinitializer">7. ChannelInitializer</h3><p>　　Netty 提供了一个特殊的 ChannelInboundHandlerAdapter 子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Channel</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(C ch)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">if</span> (initMap.add(ctx)) &#123; <span class="hljs-comment">// Guard against re-entrance.</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                initChannel((C) ctx.channel());<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable cause) &#123;<br>                exceptionCaught(ctx, cause);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (!ctx.isRemoved()) &#123;<br>                    ctx.pipeline().remove(<span class="hljs-keyword">this</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>  <br>  ……<br>&#125;<br></code></pre></td></tr></table></figure><p>　　initChannel 方法提供了一种将多个 ChannelHandler 添加到一个ChannelPipeline 中的简便方法。你只需要简单地向 Bootstrap 或ServerBootstrap 的实例提供你的 ChannelInitializer 实现即可，并且一旦Channel 被注册到了它的 EventLoop 之后，就会调用你的 initChannel()版本。在该方法返回之后，ChannelInitializer 的实例将会从 ChannelPipeline中移除它自己。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310102301446.png" style="zoom:50%;" /></center><p>　　所以，在我们自己的应用程序中，如果存在着某个 handler只使用一次的情况，也可以仿造 ChannelInitializer，用完以后将自己从ChannelPipeline 中移除自己，比如授权handler，某客户端第一次连接登录以后，进行授权检查，检查通过后就可以把这个授权handler移除了。如果客户端关闭连接下线，下次再连接的时候，就是一个新的连接，授权handler 依然会被安装到 ChannelPipeline ，依然会进行授权检查。</p><h3 id="channeloption">8. ChannelOption</h3><p>　　ChannelOption 的各种属性在套接字选项中都有对应。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310102316410.png" /></p><h4 id="channeloption.so_backlog">8.1 ChannelOption.SO_BACKLOG</h4><p>　　ChannelOption.SO_BACKLOG 对应的是 tcp/ip 协议 listen 函数中的backlog参数，服务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接，多个客户端来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理。所以操作系统里一般有两个队列，一个是ACCEP T队列，保存着已经完成了 TCP 的三次握手的连接，一个 SYN队列，服务器正在等待 TCP 的三次握手完成的队列。</p><p>　　BSD 派生系统里 backlog 指的就是 SYN 队列的大小，在 Linux 的实现里backlog 相对来说，就含糊不清了，有些内核版本指的是 ACCEPT 队列 + SYN队列合起来的大小，有的是指 SYN 队列的大小。</p><p>　　但是从 Linux 2.2 开始，backlog 的参数行为在 Linux 2.2中发生了变化，现在它指定等待接受的完全建立的套接字的队列长度，而不是不完整的连接请求的数量。不完整套接字队列的最大长度可以使用/proc/sys/net/ipv4/tcp_max_syn_backlog 设置，默认值为 128。</p><p>　　如果 backlog 参数大于 /proc/sys/net/core/somaxconn中的值，那么它会被静默截断为值128。在 2.4.25之前的内核中，此限制是硬编码值，后续内核版本也可以通过 vim/etc/sysctl.conf 来修改，包括我们前面所说的 tcp_max_syn_backlog也可以在此处修改，然后通过命令 sysctl -p 生效。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310102311569.png" style="zoom:60%;" /></center><h4 id="channeloption.so_reuseaddr">8.2 ChannelOption.SO_REUSEADDR</h4><p>　　ChanneOption.SO_REUSEADDR 对应于套接字选项中的SO_REUSEADDR，这个参数表示允许重复使用本地地址和端口，比如，多网卡（IP）绑定相同端口，比如某个进程非正常退出，该程序占用的端口可能要被占用一段时间才能允许其他进程使用，而且程序死掉以后，内核一需要一定的时间才能够释放此端口，不设置SO_REUSEADDR 就无法正常使用该端口。</p><p>　　但是注意，这个参数无法做到让应用绑定完全相同 IP + Port来重复启动。</p><p>8.3 ChannelOption.SO_KEEPALIVE</p><p>　　Channeloption.SO_KEEPALIVE 参数对应于套接字选项中的SO_KEEPALIVE，该参数用于设置 TCP连接，当设置该选项以后，连接会测试链接的状态，这个选项用于可能长时间没有数据交流的连接。当设置该选项以后，如果在两小时内没有数据的通信时，TCP会自动发送一个活动探测数据报文。</p><h4 id="channeloption.so_sndbuf和channeloption.so_rcvbuf">8.4ChannelOption.SO_SNDBUF和ChannelOption.SO_RCVBUF</h4><p>　　ChannelOption.SO_SNDBUF 参数对应于套接字选项中的SO_SNDBUF，ChannelOption.SO_RCVBUF 参数对应于套接字选项中的SO_RCVBUF，这两个参数用于操作接收缓冲区和发送缓冲区的大小，接收缓冲区用于保存网络协议站内收到的数据，直到应用程序读取成功，发送缓冲区用于保存发送数据，直到发送成功。</p><h4 id="channeloption.so_linger">8.5 ChannelOption.SO_LINGER</h4><p>ChannelOption.SO_LINGER 参数对应于套接字选项中的 SO_LINGER，Linux内核默认的处理方式是当用户调用close（）方法的时候，函数返回，在可能的情况下，尽量发送数据，不一定保证会发生剩余的数据，造成了数据的不确定性，使用SO_LINGER 可以阻塞 close() 的调用时间，直到数据完全发送</p><h4 id="channeloption.tcp_nodelay">8.6 ChannelOption.TCP_NODELAY</h4><p>　　ChannelOption.TCP_NODELAY 参数对应于套接字选项中的TCP_NODELAY，该参数的使用与 Nagle 算法有关，Nagle算法是将小的数据包组装为更大的帧然后进行发送，而不是输入一次发送一次，因此在数据包不足的时候会等待其他数据的到了，组装成大的数据包进行发送，虽然该方式有效提高网络的有效负载，但是却造成了延时，而该参数的作用就是禁止使用Nagle 算法，使用于小数据即时传输，于 TCP_NODELAY 相对应的是TCP_CORK，该选项是需要等到发送的数据量最大的时候，一次性发送数据，适用于文件传输。</p><h3 id="bytebuf">9. ByteBuf</h3><p>　　ByteBuf API 的优点：</p><blockquote><ul><li>它可以被用户自定义的缓冲区类型扩展；</li><li>通过内置的复合缓冲区类型实现了透明的零拷贝；</li><li>容量可以按需增长（类似于JDK 的StringBuilder）；</li><li>在读和写这两种模式之间切换不需要调用ByteBuffer 的flip()方法；</li><li>读和写使用了不同的索引；</li><li>支持方法的链式调用；</li><li>支持引用计数；</li><li>支持池化。</li></ul></blockquote><p>　　ByteBuf 维护了两个不同的索引，名称以 read 或者 write 开头的ByteBuf 方法，将会推进其对应的索引，而名称以 set 或者 get开头的操作则不会。</p><p>　　如果打算读取字节直到 readerIndex 达到和 writerIndex同样的值时会发生什么。在那时，你将会到达“可以读取的”数据的末尾。就如同试图读取超出数组末尾的数据一样，试图读取超出该点的数据将会触发一个IndexOutOf-BoundsException。</p><p>　　可以指定 ByteBuf的最大容量。试图移动写索引（即writerIndex）超过这个值将会触发一个异常。（默认的限制是Integer.MAX_VALUE。）</p><h4 id="使用模式">9.1 使用模式</h4><h5 id="堆缓冲区">1. 堆缓冲区</h5><p>　　最常用的 ByteBuf 模式是将数据存储在 JVM的堆空间中。这种模式被称为支撑数组（backingarray），它能在没有使用池化的情况下提供快速的分配和释放。可以由hasArray() 来判断检查 ByteBuf是否由数组支撑。如果不是，则这是一个直接缓冲区。</p><h5 id="直接缓冲区">2. 直接缓冲区</h5><p>　　直接缓冲区是另外一种 ByteBuf 模式。</p><p>直接缓冲区的主要缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。</p><h5 id="复合缓冲区">3. 复合缓冲区</h5><p>　　复合缓冲区 CompositeByteBuf，它为多个 ByteBuf提供一个聚合视图。比如 HTTP协议，分为消息头和消息体，这两部分可能由应用程序的不同模块产生，各有各的ByteBuf，将会在消息被发送的时候组装为一个 ByteBuf，此时可以将这两个ByteBuf 聚合为一个 CompositeByteBuf，然后使用统一和通用的 ByteBuf API来操作。</p><h4 id="分配">9.2 分配</h4><p>　　如何在我们的程序中获得 ByteBuf 的实例，并使用它呢？Netty提供了两种方式</p><h5 id="bytebufallocator-接口">1. ByteBufAllocator 接口</h5><p>　　Netty 通过 interface ByteBufAllocator分配我们所描述过的任意类型的 ByteBuf 实例。</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>buffer()</td><td>返回一个基于堆或者直接内存存储的 ByteBuf</td></tr><tr><td>heapBuffer()</td><td>返回一个基于堆内存存储的 ByteBuf</td></tr><tr><td>directBuffer()</td><td>返回一个基于直接内存存储的 ByteBuf</td></tr><tr><td>compositeBuffer()</td><td>返回一个可以通过添加最大到指定数目的基于堆的或者直接内存存储的缓冲区来扩展的CompositeByteBuf</td></tr><tr><td>ioBuffer()</td><td>返回一个用于套接字的 I/O 操作的 ByteBuf，当所运行的环境具有sun.misc.Unsafe 支持时，返回基于直接内存存储的ByteBuf，否则返回基于堆内存存储的 ByteBuf；当指定使用PreferHeapByteBufAllocator 时，则只会返回基于堆内存存储的 ByteBuf。</td></tr></tbody></table><p>　　可以通过 Channel（每个都可以有一个不同的 ByteBufAllocator实例）或者绑定到 ChannelHandler 的 ChannelHandlerContext 获取一个到ByteBufAllocator 的引用。</p><p>　　Netty 提供了两种 ByteBufAllocator 的实现：PooledByteBufAllocator和 Unpooled-ByteBufAllocator。前者池化了 ByteBuf的实例以提高性能并最大限度地减少内存碎片。后者的实现不池化 ByteBuf实例，并且在每次它被调用时都会返回一个新的实例。</p><p>　　Netty4.1 默认使用了 PooledByteBufAllocator。</p><h5 id="unpooled-缓冲区">2. Unpooled 缓冲区</h5><p>　　Netty 提供了一个简单的称为 Unpooled的工具类，它提供了静态的辅助方法来创建未池化的 ByteBuf 实例。</p><table><thead><tr><th>buffer()</th><th>返回一个未池化的基于堆内存存储的 ByteBuf</th></tr></thead><tbody><tr><td>directBuffer()</td><td>返回一个未池化的基于直接内存存储的 ByteBuf</td></tr><tr><td>wrappedBuffer()</td><td>返回一个包装了给定数据的 ByteBuf</td></tr><tr><td>copiedBuffer()</td><td>返回一个复制了给定数据的 ByteBuf</td></tr></tbody></table><p>　　Unpooled 类可用于 ByteBuf，同样可用于那些并不需要 Netty的其他组件的非网络项目。</p><h5 id="随机访问索引顺序访问索引读写操作">3.随机访问索引/顺序访问索引/读写操作</h5><p>　　如同在普通的 Java 字节数组中一样，ByteBuf的索引是从零开始的：第一个字节的索引是 0，最后一个字节的索引总是capacity() -1。使用那些需要一个索引值参数(<strong>随机访问</strong>,也即是数组下标)的方法（的其中）之一来访问数据既不会改变readerIndex 也不会改变 writerIndex。如果有需要，也可以通过调用readerIndex(index) 或者 writerIndex(index)来手动移动这两者。<strong>顺序访问</strong>通过索引访问</p><p>有两种类别的读/写操作：</p><p>　　get() 和 set()操作，从给定的索引开始，并且保持索引不变；get+数据字长（bool.byte,int,short,long,bytes）</p><p>　　read() 和 write()操作，从给定的索引开始，并且会根据已经访问过的字节数对索引进行调整。</p><p><strong>更多的操作：</strong></p><table><thead><tr><th>isReadable()</th><th>如果至少有一个字节可供读取，则返回true</th></tr></thead><tbody><tr><td>isWritable()</td><td>如果至少有一个字节可被写入，则返回true</td></tr><tr><td>readableBytes()</td><td>返回可被读取的字节数</td></tr><tr><td>writableBytes()</td><td>返回可被写入的字节数</td></tr><tr><td>capacity()</td><td>capacity() 返回ByteBuf可容纳的字节数。在此之后，它会尝试再次扩展直到达到maxCapacity()</td></tr><tr><td>maxCapacity()</td><td>返回 ByteBuf 可以容纳的最大字节数</td></tr><tr><td>hasArray()</td><td>如果 ByteBuf 由一个字节数组支撑，则返回 true</td></tr><tr><td>array()</td><td>array() 如果 ByteBuf由一个字节数组支撑则返回该数组；否则，它将抛出一个UnsupportedOperationException异常</td></tr></tbody></table><p><strong>可丢弃字节：</strong></p><p>　　可丢弃字节的分段包含了已经被读过的字节。通过调用discardReadBytes() 方法，可以丢弃它们并回收空间。这个分段的初始大小为0，存储在 readerIndex 中，会随着 read 操作的执行而增加（get*操作不会移动 readerIndex）。</p><p>　　缓冲区上调用 discardReadBytes()方法后，可丢弃字节分段中的空间已经变为可写的了。频繁地调用discardReadBytes()方法以确保可写分段的最大化，但是请注意，这将极有可能会导致内存复制，因为可读字节必须被移动到缓冲区的开始位置。建议只在有真正需要的时候才这样做。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310112203093.png" style="zoom:60%;" /></center><p><strong>可读字节：</strong></p><p>　　ByteBuf的可读字节分段存储了实际数据。新分配的、包装的或者复制的缓冲区的默认的readerIndex 值为 0。</p><p><strong>可写字节：</strong></p><p>　　可写字节分段是指一个拥有未定义内容的、写入就绪的内存区域。新分配的缓冲区的writerIndex 的默认值为0。任何名称以 write 开头的操作都将从当前的writerIndex 处开始写数据，并将它增加已经写入的字节数。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310112206687.png" style="zoom:30%;" /></center><h5 id="索引管理">4. 索引管理</h5><p>　　调用 markReaderIndex()、markWriterIndex()、resetWriterIndex() 和resetReaderIndex() 来标记和重置 ByteBuf 的 readerIndex 和writerIndex。</p><p>　　也可以通过调用 readerIndex(int) 或者 writerIndex(int)来将索引移动到指定位置。试图将任何一个索引设置到一个无效的位置都将导致一个IndexOutOfBoundsException。</p><p>　　可以通过调用 clear() 方法来将 readerIndex 和 writerIndex都设置为0。注意，这并不会清除内存中的内容。</p><h5 id="查找操作">5. 查找操作</h5><p>　　在 ByteBuf 中有多种可以用来确定指定值的索引的方法。最简单的是使用indexOf() 方法。</p><p>　　较复杂的查找可以通过调用 forEachByte()。</p><p>　　下面的代码展示了一个查找回车符（的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf buffer = .. .;<br><br><span class="hljs-keyword">int</span> index = buffer.forEachByte(ByteBufProcessor.FIND_CR);<br></code></pre></td></tr></table></figure><h5 id="派生缓冲区">6. 派生缓冲区</h5><p>　　派生缓冲区为 ByteBuf提供了以专门的方式来呈现其内容的视图。这类视图是通过以下方法被创建的：</p><p>　　duplicate()；slice()；slice(int,int)；Unpooled.unmodifiableBuffer(…)；order(ByteOrder)；readSlice(int)。</p><p>　　每个这些方法都将返回一个新的 ByteBuf实例，它具有自己的读索引、写索引和标记索引。其内部存储和 JDK 的ByteBuffer 一样也是共享的。</p><p>　　<strong>ByteBuf</strong>复制：如果需要一个现有缓冲区的真实副本，请使用 copy() 或者 copy(int,int) 方法。不同于派生缓冲区，由这个调用所返回的 ByteBuf拥有独立的数据副本。</p><h5 id="引用计数">7. 引用计数</h5><p>　　引用计数是一种通过在某个对象所持有的资源不再被其他对象引用时释放该对象所持有的资源来优化内存使用和性能的技术。Netty在第4 版中为 ByteBuf 引入了引用计数技术， interfaceReferenceCounted。</p><h5 id="工具类">8. 工具类</h5><p>　　<strong>ByteBufUtil</strong> 提供了用于操作 ByteBuf的静态的辅助方法。因为这个 API是通用的，并且和池化无关，所以这些方法已然在分配类的外部实现。</p><p>　　这些静态方法中最有价值的可能就是 hexdump()方法，它以十六进制的表示形式打印 ByteBuf的内容。这在各种情况下都很有用，例如，出于调试的目的记录ByteBuf的内容。十六进制的表示通常会提供一个比字节值的直接表示形式更加有用的日志条目，此外，十六进制的版本还可以很容易地转换回实际的字节表示。</p><p>　　另一个有用的方法是 boolean equals(ByteBuf,ByteBuf)，它被用来判断两个 ByteBuf 实例的相等性。</p><h5 id="资源释放">9. 资源释放</h5><p>　　当某个 ChannelInboundHandler 的实现重写 channelRead()方法时，它要负责显式地释放与池化的 ByteBuf 实例相关的内存。Netty为此提供了一个实用方法 ReferenceCountUtil.release()</p><p>　　Netty 将使用 WARN级别的日志消息记录未释放的资源，使得可以非常简单地在代码中发现违规的实例。但是以这种方式管理资源可能很繁琐。一个更加简单的方式是使用SimpleChannelInboundHandler，SimpleChannelInboundHandler会自动释放资源。</p><p>　　1、对于入站请求，Netty 的 EventLoop 在处理 Channel的读操作时进行分配 ByteBuf，对于这类ByteBuf，需要我们自行进行释放，有三种方式：</p><blockquote><ol type="1"><li><p>使用 SimpleChannelInboundHandler；</p></li><li><p>在重写 channelRead() 方法使用ReferenceCountUtil.release()</p></li><li><p>在重写 channelRead() 方法使用使用 ctx.fireChannelRead继续向后传递</p></li></ol></blockquote><p>　　2、对于出站请求，不管 ByteBuf 是否由我们的业务创建的，当调用了write 或者 writeAndFlush 方法后，Netty会自动替我们释放，不需要我们业务代码自行释放。</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty——初识Netty</title>
    <link href="/2023/10/05/Netty%E2%80%94%E2%80%94%E5%88%9D%E8%AF%86Netty/"/>
    <url>/2023/10/05/Netty%E2%80%94%E2%80%94%E5%88%9D%E8%AF%86Netty/</url>
    
    <content type="html"><![CDATA[<h3 id="netty的优势">1. Netty的优势</h3><ol type="1"><li>API 使用简单，开发门槛低；</li><li>功能强大，预置了多种编解码功能，支持多种主流协议；</li><li>定制能力强，可以通过 ChannelHandler 对通信框架进行灵活地扩展；</li><li>性能高，通过与其他业界主流的 NIO框架对比，Netty的综合性能最优；</li><li>成熟、稳定，Netty 修复了已经发现的所有 JDK NIOBUG，业务开发人员不需要再为 NIO 的 BUG 而烦恼；</li><li>社区活跃，版本迭代周期短，发现的 BUG可以被及时修复，同时，更多的新功能会加入；</li><li>经历了大规模的商业应用考验，质量得到验证。</li></ol><p><strong>为什么 Netty 使用 NIO 而不是 AIO？</strong></p><p>　　Netty 不看重 Windows 上的使用，在 Linux 系统上，AIO的底层实现仍使用 EPOLL，没有很好实现AIO，因此在性能上没有明显的优势，而且被 JDK封装了一层不容易深度优化。</p><p>　　AIO 还有个缺点是接收数据需要预先分配缓存, 而不是 NIO那种需要接收时才需要分配缓存, 所以对连接数量非常大但流量小的情况,内存浪费很多。而且 Linux 上 AIO不够成熟，处理回调结果速度跟不上处理需求。</p><p>作者原话：</p><blockquote><p>Not faster than NIO (epoll) on unix systems (which is true)</p><p>There is no daragram suppport</p><p>Unnecessary threading model (too much abstraction without usage)</p></blockquote><h3 id="hello-netty">2. Hello Netty</h3><h4 id="基础组件">2.1 基础组件</h4><h5 id="bootstrapeventloopgroup-channel">1. Bootstrap、EventLoop(Group)、Channel</h5><p>Bootstrap 是 Netty 框架的启动类和主入口类，分为客户端类 Bootstrap和服务器类 ServerBootstrap 两种。</p><p>　　Channel 是 Java NIO的一个基本构造。它代表一个到实体（如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同的I/O 操作的程序组件）的开放连接，如读操作和写操作。目前，可以把 Channel看作是传入（入站）或者传出（出站）数据的载体。因此，它可以被打开或者被关闭，连接或者断开连接。</p><p>EventLoop 暂时可以看成一个线程、EventLoopGroup自然就可以看成线程组。</p><h5 id="事件和-channelhandlerchannelpipeline">2. 事件和ChannelHandler、ChannelPipeline</h5><p>　　Netty使用不同的事件来通知我们状态的改变或者是操作的状态。这使得我们能够基于已经发生的事件来触发适当的动作。</p><p>Netty事件是按照它们与入站或出站数据流的相关性进行分类的。可能由入站数据或者相关的状态更改而触发的事件包括：<strong>连接已被激活或者连接失活；数据读取；用户事件；错误事件</strong>。出站事件是未来将会触发的某个动作的操作结果，这些动作包括：<strong>打开或者关闭到远程节点的连接；将数据写到或者冲刷到套接字</strong>。</p><p>每个事件都可以被分发给 ChannelHandler类中的某个用户实现的方法，既然事件分为入站和出站，用来处理事件的ChannelHandler 也被分为可以处理入站事件的 Handler 和出站事件的Handler，当然有些 Handler 既可以处理入站也可以处理出站。</p><p>　　Netty 提供了大量预定义的可以开箱即用的 ChannelHandler实现，包括用于各种协议（如 HTTP 和 SSL/TLS）的 ChannelHandler。</p><p>基于 Netty 的网络应用程序中根据业务需求会使用 Netty 已经提供的ChannelHandler 或者自行开发 ChannelHandler，这些 ChannelHandler 都放在ChannelPipeline 中统一管理，事件就会在 ChannelPipeline中流动，并被其中一个或者多个 ChannelHandler 处理。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310052050776.png" style="zoom:50%;" /></center><h5 id="channelfuture">3. ChannelFuture</h5><p>Netty 中所有的 I/O操作都是异步的，我们知道“异步的意思就是不需要主动等待结果的返回，而是通过其他手段比如，状态通知、回调函数等”，那就是说至少我们需要一种获得异步执行结果的手段。</p><p>　　JDK 预置了 interface java.util.concurrent.Future，Future提供了一种在操作完成时通知应用程序的方式。这个对象可以看作是一个异步操作的结果的占位符；它将在未来的某个时刻完成，并提供对其结果的访问。但是其所提供的实现，只允许手动检查对应的操作是否已经完成，或者一直阻塞直到它完成。这是非常繁琐的，所以Netty 提供了它自己的实现ChannelFuture，用于在执行异步操作的时候使用。</p><p>一般来说，每个 Netty 的出站 I/O 操作都将返回一个ChannelFuture<strong>。</strong></p><h4 id="服务端">2.2 服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServer</span> </span>&#123;<br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EchoServer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.port = port;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">/*线程组*/</span><br>        NioEventLoopGroup eventLoopGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-comment">/*服务端启动必备*/</span><br>        ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>        bootstrap.group(eventLoopGroup)<br>                .channel(NioServerSocketChannel.class)<span class="hljs-comment">/*指定使用NIO的通信模式*/</span><br>                .localAddress(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-keyword">this</span>.port))<span class="hljs-comment">/*指定监听端口*/</span><br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> EchoServerHandler());<br>                    &#125;<br>                &#125;);<br>        <span class="hljs-keyword">try</span> &#123;<br>            ChannelFuture channelFuture = bootstrap.bind().sync();<span class="hljs-comment">/*异步绑定到服务器，sync()会阻塞到完成*/</span><br>            channelFuture.channel().closeFuture().sync();<span class="hljs-comment">/*阻塞当前线程，直到服务器的ServerChannel被关闭*/</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            eventLoopGroup.shutdownGracefully().sync();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">9999</span>;<br>        EchoServer echoServer = <span class="hljs-keyword">new</span> EchoServer(port);<br>        System.out.println(<span class="hljs-string">&quot;服务器即将启动&quot;</span>);<br>        echoServer.start();<br>        System.out.println(<span class="hljs-string">&quot;服务器关闭&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端 ChannelHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ByteBuf in = (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;Server accept: &quot;</span>+in.toString(CharsetUtil.UTF_8));<br>        ctx.writeAndFlush(in);<br>        <span class="hljs-comment">// ctx.close();</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="客户端">2.3 客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoClient</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String host;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EchoClient</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port, String host)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.port = port;<br>        <span class="hljs-keyword">this</span>.host = host;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        NioEventLoopGroup eventLoopGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-comment">/*客户端启动必备*/</span><br>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>        bootstrap.group(eventLoopGroup)<br>                .channel(NioSocketChannel.class)<br>                .remoteAddress(<span class="hljs-keyword">new</span> InetSocketAddress(host, port))<span class="hljs-comment">/*指定服务器的IP地址和端口*/</span><br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> EchoClientHandler());<br>                    &#125;<br>                &#125;);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            ChannelFuture channelFuture = bootstrap.connect().sync();<span class="hljs-comment">/*异步连接到服务器，sync()会阻塞到完成*/</span><br>            channelFuture.channel().closeFuture().sync();<span class="hljs-comment">/*阻塞当前线程，直到客户端的Channel被关闭*/</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            eventLoopGroup.shutdownGracefully().sync();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> EchoClient(<span class="hljs-number">9999</span>, <span class="hljs-string">&quot;127.0.0.1&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端 ChannelHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;client Accept&quot;</span> + msg.toString(CharsetUtil.UTF_8));<br>        <span class="hljs-comment">// ctx.close();</span><br>    &#125;<br><br>    <span class="hljs-comment">/*channel活跃后，做业务处理*/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;Hello,Netty&quot;</span>, CharsetUtil.UTF_8));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty——直接内存、零拷贝、epoll模型</title>
    <link href="/2023/10/04/Netty%E2%80%94%E2%80%94%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E3%80%81%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%81epoll%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/10/04/Netty%E2%80%94%E2%80%94%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E3%80%81%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%81epoll%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="直接内存">1. 直接内存</h3><p>　　在所有的网络通信和应用程序中，每个 TCP 的 Socket内核中都有一个发送缓冲区（SO_SNDBUF）和一个接收缓冲区（SO_RECVBUF），可以使用相关套接字选项来更改该缓冲区大小。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042044616.png" style="zoom:80%;" /></center><p>　　当某个应用进程调用write时，内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区。如果该套接字的发送缓冲区容不下该应用进程的所有数据(或是应用进程的缓冲区大于套接字的发送缓冲区，或是套接字的发送缓冲区中已有其他数据)，假设该套接字是阻塞的，则该应用进程将被投入睡眠。内核将不从write系统调用返回，直到应用进程缓冲区中的所有数据都复制到套接字发送缓冲区。因此，从写一个TCP 套接字的 write调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区，并不表明对端的TCP 或应用进程已接收到数据。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042051030.png" style="zoom:50%;" /></center><p>　　Java 程序自然也要遵守上述的规则。但在 Java中存在着堆、垃圾回收等特性，所以在实际的 IO 中，在 JVM内部的存在着这样一种机制：</p><p>　　在 IO 读写上，如果是使用堆内存，JDK 会先创建一个DirectBuffer，再去执行真正的写操作。这是因为，当我们把一个地址通过 JNI传递给底层的 C库的时候，有一个基本的要求，就是这个地址上的内容不能失效。然而，在 GC管理下的对象是会在 Java堆中移动的。也就是说，有可能我把一个地址传给底层的write，但是这段内存却因为 GC整理内存而失效了。所以必须要把待发送的数据放到一个 GC管不着的地方。这就是调用 native方法之前，数据—定要在堆外内存的原因。</p><p>　　可见，站在网络通信的角度 DirectBuffer并没有节省什么内存拷贝，只是 Java 网络通信里因为 HeapBuffer必须多做一次拷贝，使用 DirectBuffer就会少一次内存拷贝。相比没有使用堆内存的 Java 程序，使用直接内存的 Java程序当然更快一点。</p><p>　　从垃圾回收的角度而言，直接内存不受 GC(新生代的 Minor GC)影响，只有当执行老年代的 Full GC时候才会顺便回收直接内存，整理内存的压力也比数据放到 HeapBuffer要小。</p><p><strong>堆外内存的优点和缺点：</strong></p><p>优点：</p><ol type="1"><li>减少了垃圾回收的工作</li><li>加快了复制的速度。因为堆内在 flush到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略掉了这个工作。</li></ol><p>缺点：</p><ol type="1"><li>堆外内存难以控制，如果内存泄漏很难排查</li><li>堆外内存相对来说，不适合存储很复杂的对象。一般简单的对象或者扁平化的比较适合。</li></ol><h3 id="零拷贝">2. 零拷贝</h3><h4 id="什么是零拷贝">2.1 什么是零拷贝</h4><p>　　零拷贝(英语: Zero-copy) 技术是指计算机执行操作时，CPU不需要先将数据从某处内存复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省CPU 周期和内存带宽。</p><p>➢零拷贝技术可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效地提高数据传输效率</p><p>➢零拷贝技术减少了用户进程地址空间和内核地址空间之间因为上:下文切换而带来的开销</p><p>　　可以看出没有说不需要拷贝，只是说减少冗余[不必要]的拷贝。</p><p>　　使用零拷贝的组件、框架：Kafka、Netty、Rocketmq、Nginx、Apache。</p><h4 id="linux的io机制与dma">2.2 Linux的I/O机制与DMA</h4><p>在早期计算机中，用户进程需要读取磁盘数据，需要 CPU 中断和 CPU参与，因此效率比较低，发起 IO 请求，每次的 IO 中断，都带来 CPU的上下文切换，因此出现了——DMA。</p><p>DMA(Direct Memory Access，直接内存存取)是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于CPU 的大量中断负载。</p><p>　　DMA 控制器，接管了数据读写请求，减少 CPU 的负担。这样一来，CPU能高效工作了。现代硬盘基本都支持 DMA。</p><p>实际因此 IO 读取，涉及两个过程：</p><ol type="1"><li>DMA 等待数据准备好，把磁盘数据读取到操作系统内核缓冲区；</li><li>用户进程，将内核缓冲区的数据 copy 到用户空间。</li></ol><p><a href="https://www.jianshu.com/p/3a26e8c9f402">（传送门）</a></p><h4 id="传统数据传送机制">2.3 传统数据传送机制</h4><p>比如读取文件，再用 socket 发送出去，实际经过四次 copy。</p><p>伪码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">buffer = File.read() <br>Socket.send(buffer)<br></code></pre></td></tr></table></figure><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042117088.png" style="zoom:50%;" /></center><p>1、第一次：将磁盘文件，读取到操作系统内核缓冲区；</p><p>2、第二次：将内核缓冲区的数据，copy 到应用程序的 buffer；</p><p>3、第三步：将 application 应用程序 buffer 中的数据，copy 到 socket网络发送缓冲区(属于操作系统内核的缓冲区)；</p><p>4、第四次：将 socket buffer 的数据，copy到网卡，由网卡进行网络传输。</p><p>分析上述的过程，虽然引入 DMA 来接管 CPU 的中断请求，但四次 copy是存在“不必要的拷贝”的。实际上并不需要第二个和第三个数据副本。应用程序除了缓存数据并将其传输回套接字缓冲区之外什么都不做。相反，数据可以直接从读缓冲区传输到套接字缓冲区。</p><p>　　显然，第二次和第三次数据 copy其实在这种场景下没有什么帮助反而带来开销，这也正是零拷贝出现的背景和意义。</p><p>　　同时，read 和 send都属于系统调用，每次调用都牵涉到两次上下文切换：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042138197.png" style="zoom:50%;" /></center><p>　　</p><p>　　总结下，传统的数据传送所消耗的成本：4 次拷贝，4次上下文切换。</p><p>　　4 次拷贝，其中两次是 DMA copy，两次是 CPU copy。</p><h4 id="linux支持的常见零拷贝">2.4 Linux支持的(常见)零拷贝</h4><p>　　目的：减少 IO 流程中不必要的拷贝，当然零拷贝需要 OS支持，也就是需要 kernel 暴露　api。</p><h5 id="mmap内存映射">1. mmap内存映射</h5><p>　　硬盘上文件的位置和应用程序缓冲区(applicationbuffers)进行映射（建立一种一一对应关系），由于 mmap()将文件直接映射到用户空间，所以实际文件读取时根据这个映射关系，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝，不再有文件内容从硬盘拷贝到内核空间的一个缓冲区。</p><p>　　mmap 内存映射将会经历：3次拷贝: 1次 cpu copy，2次 DMA copy；</p><p>　　以及4次上下文切换，调用 mmap 函数2次，write 函数2次。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042150357.png" style="zoom:50%;" /></center><h5 id="sendfile">2. sendfile</h5><p>　　linux 2.1 支持的 sendfile</p><p>　　当调用 sendfile() 时，DMA 将磁盘数据复制到 kernelbuffer，然后将内核中的 kernel buffer 直接拷贝到 socketbuffer；但是数据并未被真正复制到 socket关联的缓冲区内。取而代之的是，只有记录数据位置和长度的描述符被加入到socket 缓冲区中。DMA模块将数据直接从内核缓冲区传递给协议引擎，从而消除了遗留的最后一次复制。但是要注意，这个需要DMA 硬件设备支持，如果不支持，CPU 就必须介入进行拷贝。</p><p>　　一旦数据全都拷贝到 socket buffer，sendfile() 系统调用将会return、代表数据转化的完成。socket buffer 里的数据就能在网络传输了。</p><p>　　sendfile会经历：3（2，如果硬件设备支持）次拷贝，1（0，如果硬件设备支持）次 CPUcopy， 2次 DMA copy；以及2次上下文切换</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042155284.png" style="zoom:60%;" /></center><h5 id="splice">3. splice</h5><p>　　Linux 从 2.6.17 支持 splice</p><p>　　数据从磁盘读取到 OS内核缓冲区后，在内核缓冲区直接可将其转成内核空间其他数据buffer，而不需要拷贝到用户空间。</p><p>　　如下图所示，从磁盘读取到内核 buffer 后，在内核空间直接与 socketbuffer 建立 pipe 管道。</p><p>　　和 sendfile() 不同的是，splice() 不需要硬件支持。</p><p>　　注意 splice 和 sendfile 的不同，sendfile 是 DMA硬件设备不支持的情况下将磁盘数据加载到 kernel buffer 后，需要一次 CPUcopy，拷贝到 socket buffer。而 splice 是更进一步，连这个 CPU copy也不需要了，直接将两个内核空间的 buffer进行 pipe。</p><p>　　splice 会经历2次拷贝: 0次 cpu copy，2次 DMAcopy；以及2次上下文切换</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042208186.png" style="zoom:60%;" /></center><h4 id="java生态圈中的零拷贝">2.5 Java生态圈中的零拷贝</h4><p>　　Linux 提供的零拷贝技术 Java并不是全支持，支持2种(内存映射mmap、sendfile)；</p><h5 id="nio提供的内存映射-mappedbytebuffer">1. NIO提供的内存映射MappedByteBuffer</h5><p>　　NIO 中的 FileChannel.map()方法其实就是采用了操作系统中的内存映射方式，底层就是调用 Linux mmap()实现的。</p><p>　　将内核缓冲区的内存和用户缓冲区的内存做了一个地址映射。这种方式适合读取大文件，同时也能对文件内容进行更改，但是如果其后要通过SocketChannel 发送，还是需要 CPU 进行数据的拷贝。</p><h5 id="nio提供的sendfile">2. NIO提供的sendfile</h5><p>　　Java NIO 中提供的 FileChannel 拥有 transferTo 和 transferFrom两个方法，可直接把 FileChannel 中的数据拷贝到另外一个Channel，或者直接把另外一个 Channel 中的数据拷贝到FileChannel。该接口常被用于高效的网络 /文件的数据传输和大文件拷贝。在操作系统支持的情况下，通过该方法传输数据并不需要将源数据从内核态拷贝到用户态，再从用户态拷贝到目标通道的内核态，同时也避免了两次用户态和内核态间的上下文切换，也即使用了“零拷贝”，所以其性能一般高于Java IO 中提供的方法。</p><h5 id="kafka中的零拷贝">3. Kafka中的零拷贝</h5><p>　　Kafka两个重要过程都使用了零拷贝技术，且都是操作系统层面的狭义零拷贝，一是Producer 生产的数据存到 broker，二是 Consumer 从 broker 读取数据。</p><p>　　Producer 生产的数据持久化到 broker，broker 里采用 mmap文件映射，实现顺序的快速写入；</p><p>　　Customer 从 broker 读取数据，broker 里采用sendfile，将磁盘文件读到 OS 内核缓冲区后，直接转到 socket buffer进行网络发送。</p><h5 id="netty的零拷贝实现">4. Netty的零拷贝实现</h5><p>　　Netty 的零拷贝主要包含三个方面：</p><p>　　在网络通信上，Netty 的接收和发送 ByteBuffer 采用 DIRECTBUFFERS，使用堆外直接内存进行 Socket读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAPBUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer拷贝一份到直接内存中，然后才写入 Socket中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p><p>　　在缓存操作上，Netty 提供了 CompositeByteBuf 类，它可以将多个ByteBuf 合并为一个逻辑上的 ByteBuf，避免了各个 ByteBuf 之间的拷贝。</p><p>　　通过 wrap 操作，我们可以将 byte[] 数组、ByteBuf、 ByteBuffer等包装成一个 Netty ByteBuf 对象，进而避免了拷贝操作。</p><p>　　ByteBuf 支持 slice 操作，因此可以将 ByteBuf分解为多个共享同一个存储区域的 ByteBuf，避免了内存的拷贝。</p><p>　　在文件传输上，Netty 的通过 FileRegion 包装的FileChannel.tranferTo实现文件传输，它可以直接将文件缓冲区的数据发送到目标Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。</p><h3 id="linux网络io模型">3. Linux网络IO模型</h3><p><strong>同步和异步</strong></p><p>　　关注的是调用方是否主动获取结果</p><p>　　同步：同步的意思就是调用方需要主动等待结果的返回</p><p>　　异步：异步的意思就是不需要主动等待结果的返回，而是通过其他手段比如，状态通知，回调函数等。</p><p><strong>阻塞和非阻塞</strong></p><p>　　关注的是等待结果返回调用方的状态</p><p>　　阻塞：是指结果返回之前，当前线程被挂起，不做任何事</p><p>　　非阻塞：是指结果在返回之前，线程可以做一些其他事，不会被挂起。</p><p><strong>Linux下的五种I/O模型</strong></p><p><ahref="https://blog.51cto.com/u_15467009/7063136">（传送门）</a></p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042252521.png" style="zoom:50%;" /></center><p>　　总的来说，阻塞 IO 就是 JDK 里的 BIO 编程，IO 复用就是 JDK 里的NIO 编程，Linux下异步 IO 的实现建立在 epoll之上，是个伪异步实现，而且相比 IO复用，没有体现出性能优势，使用不广。非阻塞 IO使用轮询模式，会不断检测是否有数据到达，大量的占用 CPU的时间，是绝不被推荐的模型。信号驱动 IO需要在网络通信时额外安装信号处理函数，使用也不广泛。</p><p>阻塞式 I/O 模型：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042232204.png" style="zoom:50%;" /></center><p>I/O复用模型：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042236640.png" style="zoom:50%;" /></center><p>　　比较上面两张图，IO 复用需要使用两个系统调用（select 和recvfrom），而 blocking IO 只调用了一个系统调用（recvfrom）。但是，用select 的优势在于它可以同时处理多个connection。所以，如果处理的连接数不是很高的话，使用 select/epoll 的 webserver 不一定比使用 multi-threading + blocking IO 的 web server性能更好，可能延迟还更大。select/epoll的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p><h3 id="linux下的io复用编程">4. Linux下的IO复用编程</h3><p>　　select，poll，epoll 都是 IO 多路复用的机制。I/O多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但select，poll，epoll 本质上都是同步I/O，因为他们都需要在读写事件就绪后自己负责进行读写，并等待读写完成。</p><h4 id="文件描述符fd">4.1 文件描述符FD</h4><p>　　在 Linux操作系统中，可以将一切都看作是文件，包括普通文件，目录文件，字符设备文件（如键盘，鼠标…），块设备文件（如硬盘，光驱…），套接字等等，所有一切均抽象成文件，提供了统一的接口，方便应用程序调用。</p><p>既然在 Linux操作系统中，你将一切都抽象为了文件，那么对于一个打开的文件，我应用程序怎么对应上呢？文件描述符应运而生。</p><p>　　文件描述符：File descriptor，简称fd，当应用程序请求内核打开/新建一个文件时，内核会返回一个文件描述符用于对应这个打开/新建的文件，其fd本质上就是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p><p>　　系统为了维护文件描述符建立了3个表：进程级的文件描述符表、系统级的文件描述符表、文件系统的i-node表。所谓进程级的文件描述符表，指操作系统为每一个进程维护了一个文件描述符表，该表的索引值都从0开始的，所以在不同的进程中可以看到相同的文件描述符，这种情况下相同的文件描述符可能指向同一个实际文件，也可能指向不同的实际文件。</p><h4 id="select">4.2 select</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">select</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;<br></code></pre></td></tr></table></figure><p>　　select 函数监视的文件描述符分 3 类，分别是 writefds、readfds、和exceptfds。调用后 select 函数会阻塞，直到有描述副就绪（有数据可读、可写、或者有错误发生），或者超时（ timeout指定等待时间，如果立即返回设为 null 即可）函数返回。当 select函数返回后，可以通过遍历 fdset，来找到就绪的描述符。</p><p>　　select目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在 Linux上一般为1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p><h4 id="poll">4.3 poll</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">poll</span> <span class="hljs-params">(struct pollfd *fds, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nfds, <span class="hljs-keyword">int</span> timeout)</span></span>;<br></code></pre></td></tr></table></figure><p>　　不同于 select 使用三个位图来表示三个 fdset 的方式，poll 使用一个pollfd 的指针实现。</p><p>　　pollfd 结构包含了要监视的 event 和发生的 event，不再使用 select“参数-值”传递的方式。同时，pollfd并没有最大数量限制（但是数量过大后性能也是会下降）。 和 select函数一样，poll 返回后，需要轮询 pollfd 来获取就绪的描述符。</p><h4 id="epoll">4.4 epoll</h4><p>　　epoll 是在 2.6 内核中提出的，是之前的 select 和 poll的增强版本。相对于 select 和 poll 来说，可以看到 epoll做了更细致的分解，包含了三个方法，使用上更加灵活。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span>；</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd, <span class="hljs-keyword">int</span> op, <span class="hljs-keyword">int</span> fd, struct epoll_event *event)</span>；</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd, struct epoll_event * events, <span class="hljs-keyword">int</span> maxevents, <span class="hljs-keyword">int</span> timeout)</span></span>;<br></code></pre></td></tr></table></figure><p>　　① <strong>epoll_create()</strong>　创建一个 epoll 的句柄，size用来告诉内核这个监听的数目一共有多大，这个参数不同于 select()中的第一个参数，给出最大监听的 fd+1 的值，参数 size 并不是限制了 epoll所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。当创建好epoll 句柄后，它就会占用一个 fd 值，在 linux 下如果查看/proc/进程id/fd/，是能够看到这个 fd 的，所以在使用完 epoll 后，必须调用close() 关闭，否则可能导致 fd 被耗尽。</p><p>　　作为类比，可以理解为　JDK NIO　编程里的　selector =Selector.open();</p><p>　　② <strong>epoll_ctl</strong>　函数是对指定描述符 fd 执行 op操作。</p><blockquote><p>epfd：是 epoll_create() 的返回值。</p><p>op：表示操作，用三个宏来表示：添加 EPOLL_CTL_ADD，删除EPOLL_CTL_DEL，修改 EPOLL_CTL_MOD。分别添加、删除和修改对 fd的监听事件。</p><p>fd：是需要监听的 fd（文件描述符）</p><p>epoll_event：是告诉内核需要监听什么事，有具体的宏可以使用，比如EPOLLIN ：表示对应的文件描述符可以读（包括对端 SOCKET正常关闭）；EPOLLOUT：表示对应的文件描述符可以写；</p></blockquote><p>　　作为类比，可以理解为 JDK NIO 编程里的socketChannel.register();</p><p>　　③ <strong>epoll_wait</strong> 等待 epfd 上的 io 事件，最多返回maxevents 个事件。</p><blockquote><p>events：用来从内核得到事件的集合</p><p>maxevents：告诉内核 events有多大，这个maxevents的值不能大于创建epoll_create()时的size。</p><p>timeout：超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p></blockquote><p>　　作为类比，可以理解为对应于 JDK NIO 编程里的selector.select();</p><h4 id="selectpollepoll-的比较">4.5 select、poll、epoll 的比较</h4><p>　　select，poll，epoll 都是操作系统实现 IO 多路复用的机制。 I/O多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。那么这三种机制有什么区别呢。</p><table><thead><tr><th style="text-align: center;">\</th><th style="text-align: center;">select</th><th style="text-align: center;">poll</th><th style="text-align: center;">epoll</th></tr></thead><tbody><tr><td style="text-align: center;">操作方式</td><td style="text-align: center;">遍历</td><td style="text-align: center;">遍历</td><td style="text-align: center;">回调</td></tr><tr><td style="text-align: center;">底层实现</td><td style="text-align: center;">数组</td><td style="text-align: center;">链表</td><td style="text-align: center;">哈希表</td></tr><tr><td style="text-align: center;">IO效率</td><tdstyle="text-align: center;">每次调用都进行线性遍历，时间复杂度为O(n)</td><tdstyle="text-align: center;">每次调用都进行线性遍历，时间复杂度为O(n)</td><tdstyle="text-align: center;">事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到rdllist里面。时间复杂度O(1)</td></tr><tr><td style="text-align: center;">最大连接数</td><td style="text-align: center;">1024（x86）或 2048（x64）</td><td style="text-align: center;">无上限</td><td style="text-align: center;">无上限</td></tr><tr><td style="text-align: center;">fd拷贝</td><td style="text-align: center;">每次调用 select，都需要把 fd集合从用户态拷贝到内核态</td><td style="text-align: center;">每次调用 poll，都需要把 fd集合从用户态拷贝到内核态</td><td style="text-align: center;">调用 epoll_ctl时拷贝进内核并保存，之后每次 epoll_wait 不拷贝</td></tr></tbody></table><p>1、支持一个进程所能打开的最大连接数</p><table><thead><tr><th>select</th><th>单个进程所能打开的最大连接数有 FD_SETSIZE 宏定义，其大小是 32个整数的大小（在32位的机器上，大小就是32<em>32，同理64位机器上FD_SETSIZE为32</em>64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响。</th></tr></thead><tbody><tr><td>poll</td><td>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</td></tr><tr><td>epoll</td><td>虽然连接数基本上只受限于机器的内存大小</td></tr></tbody></table><p>2、FD 剧增后带来的 IO 效率问题</p><table><thead><tr><th>select</th><th>因为每次调用时都会对连接进行线性遍历，所以随着 FD的增加会造成遍历速度慢的“线性下降性能问题”。</th></tr></thead><tbody><tr><td>poll</td><td>同上</td></tr><tr><td>epoll</td><td>因为 epoll 内核中实现是根据每个 fd 上的 callback函数来实现的，只有活跃的 socket 才会主动调用 callback，所以在活跃 socket较少的情况下，使用 epoll 没有前面两者的线性下降的性能问题，但是所有socket 都很活跃的情况下，可能会有性能问题。</td></tr></tbody></table><p>3、 消息传递方式</p><table><thead><tr><th>select</th><th>内核需要将消息传递到用户空间，都需要内核拷贝动作</th></tr></thead><tbody><tr><td>poll</td><td>同上</td></tr><tr><td>epoll</td><td>epoll 通过内核和用户空间共享一块内存来实现的。</td></tr></tbody></table><p><strong>总结：</strong></p><p>综上，在选择 select，poll，epoll时要根据具体的使用场合以及这三种方式的自身特点。</p><p>1、表面上看 epoll的性能最好，但是在连接数少并且连接都十分活跃的情况下，select 和 poll的性能可能比 epoll 好，毕竟 epoll 的通知机制需要很多函数回调。</p><p>2、select低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善。</p><h3 id="epoll-原理和底层机制分析">5. epoll 原理和底层机制分析</h3><p>　　了解 epoll本质的第一步，要从硬件的角度看计算机怎样接收网络数据。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051505722.png" style="zoom:50%;" /></center><p>　　网卡收到网线传来的数据，经过硬件电路的传输，最终将数据写入到内存中的某个地址上。</p><h4 id="如何知道接收了数据">5.1 如何知道接收了数据？</h4><p>　　CPU和操作系统如何知道网络上有数据要接收？很简单，使用中断机制。</p><p>　　<strong>中断、上半部、下半部</strong></p><p>　　内核和设备驱动是通过中断的方式来处理的。所谓中断，可以理解为当设备上有数据到达的时候，会给CPU 的相关引脚上触发一个电压变化，以通知 CPU 来处理数据。</p><p>　　计算机执行程序时，会有优先级的需求。比如，当计算机收到断电信号时（电容可以保存少许电量，供CPU运行很短的一小段时间），它应立即去保存数据，保存数据的程序具有较高的优先级。</p><p>　　一般而言，由硬件产生的信号需要 cpu立马做出回应（不然数据可能就丢失），所以它的优先级很高。cpu理应中断掉正在执行的程序，去做出响应；当 cpu完成对硬件的响应后，再重新执行用户程序。中断的过程如下图，和函数调用差不多。只不过函数调用是事先定好位置，而中断的位置由“信号”决定。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051511531.png" style="zoom:50%;" /></center><p>　　当网卡把数据写入到内存后，网卡向 cpu发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。</p><p>　　对于网络模块来说，由于处理过程比较复杂和耗时，如果在中断函数中完成所有的处理，将会导致中断处理函数（优先级过高）将过度占据CPU，将导致 CPU 无法响应其它设备，例如鼠标和键盘的消息。</p><p>　　因此 Linux中断处理函数是分上半部和下半部的。上半部是只进行最简单的工作，快速处理然后释放CPU，接着 CPU就可以允许其它中断进来。剩下将绝大部分的工作都放到下半部中，可以慢慢从容处理。2.4以后的内核版本采用的下半部实现方式是软中断，由 ksoftirqd内核线程全权处理。和硬中断不同的是，硬中断是通过给 CPU物理引脚施加电压变化，而软中断是通过给内存中的一个变量的二进制值以通知软中断处理程序。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051516121.png" style="zoom:50%;" /></center><p>　　当网卡上收到数据以后，Linux 中第一个工作的模块是网络驱动。网络驱动会以 DMA 的方式把网卡上收到的帧写到内存里。再向 CPU发起一个中断，以通知 CPU 有数据到达。第二，当 CPU收到中断请求后，会去调用网络驱动注册的中断处理函数。网卡的中断处理函数并不做过多工作，发出软中断请求，然后尽快释放CPU。ksoftirqd 检测到有软中断请求到达，调用 poll开始轮询收包，收到后交由各级协议栈处理。最后会被放到用户 socket的接收队列中。</p><h4 id="进程阻塞">5.2 进程阻塞</h4><p>了解 epoll本质，要从操作系统进程调度的角度来看数据接收。阻塞是进程调度的关键一环，指的是进程在等待某事件（如接收到网络数据）发生之前的等待状态，recv、select和 epoll 都是阻塞方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//创建socket</span><br><span class="hljs-keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);   <br><span class="hljs-comment">//绑定</span><br>bind(s, ...)<br><span class="hljs-comment">//监听</span><br>listen(s, ...)<br><span class="hljs-comment">//接受客户端连接</span><br><span class="hljs-keyword">int</span> c = accept(s, ...)<br><span class="hljs-comment">//接收客户端数据</span><br>recv(c, ...);<br><span class="hljs-comment">//将数据打印出来</span><br><span class="hljs-built_in">printf</span>(...)<br></code></pre></td></tr></table></figure><p>　　这是一段最基础的网络编程代码，先新建 socket 对象，依次调用bind、listen、accept，最后调用 recv 接收数据。recv是个阻塞方法，当程序运行到 recv时，它会一直等待，直到接收到数据才往下执行。</p><p>那么阻塞的原理是什么？</p><p>　　操作系统为了支持多任务，实现了进程调度的功能，会把进程分为“运行”和“等待”等几种状态。运行状态是进程获得cpu 使用权，正在执行代码的状态；等待状态是阻塞状态，比如上述程序运行到recv时，程序会从运行状态变为等待状态，接收到数据后又变回运行状态。操作系统会分时执行各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。</p><p>　　下图中的计算机中运行着 A、B、C 三个进程，其中进程 A执行着上述基础网络程序，一开始，这3个进程都被操作系统的工作队列所引用，处于运行状态，会分时执行。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051535749.png" style="zoom:70%;" /></center><p>　　当进程 A 执行到创建 socket的语句时，操作系统会创建一个由文件系统管理的 socket 对象。这个 socket对象包含了发送缓冲区、接收缓冲区、等待队列等成员。等待队列是个非常重要的结构，它指向所有需要等待该socket 事件的进程。</p><p>　　当程序执行到 recv 时，操作系统会将进程 A 从工作队列移动到该socket 的等待队列中（如下图）。由于工作队列只剩下了进程 B 和C，依据进程调度，cpu 会轮流执行这两个进程的程序，不会执行进程 A的程序。所以进程 A 被阻塞，不会往下执行代码，也不会占用 cpu 资源。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051539517.png" style="zoom:70%;" /></center><p>　　操作系统添加等待队列只是添加了对这个“等待中”进程的引用，以便在接收到数据时获取进程对象、将其唤醒，而非直接将进程管理纳入自己之下。上图为了方便说明，直接将进程挂到等待队列之下。</p><p>　　当 socket 接收到数据后，操作系统将该 socket等待队列上的进程重新放回到工作队列，该进程变成运行状态，继续执行代码。也由于socket 的接收缓冲区已经有了数据，recv 可以返回接收到的数据。</p><h4 id="内核接收网络数据">5.3 内核接收网络数据</h4><p>　　进程在 recv阻塞期间，计算机收到了对端传送的数据（步骤①）。数据经由网卡传送到内存（步骤②），然后网卡通过中断信号通知cpu 有数据到达，cpu执行中断程序（步骤③）。此处的中断程序主要有两项功能，先将网络数据写入到对应socket 的接收缓冲区里面（步骤④），再唤醒进程 A（步骤⑤），重新将进程 A放入工作队列中。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051543056.png" style="zoom:60%;" /></center><p>　　操作系统如何知道网络数据对应于哪个 socket？因为一个 socket对应着一个端口号，而网络数据包中包含了 ip和端口的信息，内核可以通过端口号找到对应的socket。当然，为了提高处理速度，操作系统会维护端口号到 socket的索引结构，以快速读取。</p><h4 id="同时监视多个-socket-的简单方法">5.4 同时监视多个 socket的简单方法</h4><p>　　服务端需要管理多个客户端连接，而 recv 只能监视单个socket，这种矛盾下，人们开始寻找监视多个 socket 的方法。epoll的要义是高效的监视多个socket。从历史发展角度看，必然先出现一种不太高效的方法，人们再加以改进。只有先理解了不太高效的方法，才能够理解epoll 的本质。</p><p>　　假如能够预先传入一个 socket 列表，如果列表中的 socket都没有数据，挂起进程，直到有一个 socket收到数据，唤醒进程。这种方法很直接，也是 select 的设计思想。</p><p>　　为方便理解，我们先看看 Linux 中 select的用法。在如下的代码中，先准备一个数组（下面代码中的 fds），让 fds存放着所有需要监视的 socket。然后调用 select，如果 fds 中的所有 socket都没有数据，select 会阻塞，直到有一个 socket 接收到数据，select返回，唤醒进程。用户可以遍历 fds，通过 FD_ISSET 判断具体哪个 socket收到数据，然后做出处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> fds[] =  存放需要监听的socket<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">int</span> n = select(..., fds, ...)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; fds.count; i++)&#123;<br>        <span class="hljs-keyword">if</span>(FD_ISSET(fds[i], ...))&#123;<br>            <span class="hljs-comment">//fds[i]的数据处理</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　select 的实现思路很直接。假如程序同时监视 sock1、sock2 和 sock3三个 socket，那么在调用 select 之后，操作系统把进程 A 分别加入这三个socket 的等待队列中。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051551762.png" style="zoom:67%;" /></center><p>　　当任何一个 socket收到数据后，中断程序将唤起进程。所谓唤起进程，就是将进程从所有的等待队列中移除，加入到工作队列里面。当进程A 被唤醒后，它知道至少有一个 socket 接收了数据。程序只需遍历一遍 socket列表，就可以得到就绪的 socket。</p><p>　　这种简单方式行之有效，在几乎所有操作系统都有对应的实现。但是简单的方法往往有缺点，主要是：</p><p>　　其一，每次调用 select 都需要将进程加入到所有被监视 socket的等待队列，每次唤醒都需要从每个队列中移除，都必须要进行遍历。而且每次都要将整个fds列表传递给内核，有一定的开销。正是因为遍历操作开销大，出于效率的考量，才会规定select 的最大监视数量，默认只能监视 1024 个socket。</p><p>　　其二，进程被唤醒后，程序并不知道哪些 socket收到数据，还需要遍历一次。</p><p>　　那么，有没有减少遍历的方法？有没有保存就绪 socket的方法？这两个问题便是 epoll 技术要解决的。</p><h4 id="epoll的设计思路">5.5 epoll的设计思路</h4><p>　　epoll 是在 select 出现 N 多年后才被发明的，是 select 和 poll的增强版本。epoll 通过以下一些措施来改进效率。</p><p>　　措施一：功能分离</p><p>　　select低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一。每次调用select 都需要这两步操作，然而大多数应用场景中，需要监视的 socket相对固定，并不需要每次都修改。epoll 将这两个操作分开，先用 epoll_ctl维护等待队列，再调用 epoll_wait阻塞进程。显而易见的，效率就能得到提升。</p><p>　　如下的代码中，先用 epoll_create 创建一个 epoll 对象 epfd，再通过epoll_ctl 将需要监视的 socket 添加到 epfd 中，最后调用 epoll_wait等待数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> epfd = epoll_create(...);<br>epoll_ctl(epfd, ...); <span class="hljs-comment">//将所有需要监听的socket添加到epfd中</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">int</span> n = epoll_wait(...)<br>    <span class="hljs-keyword">for</span>(接收到数据的socket)&#123;<br>        <span class="hljs-comment">//处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　措施二：就绪列表</p><p>　　select 低效的另一个原因在于程序不知道哪些 socket收到数据，只能一个个遍历。如果内核维护一个“就绪列表”，引用收到数据的socket，就能避免遍历。</p><h4 id="epoll的原理和流程">5.6 epoll的原理和流程</h4><p>　　当某个进程调用 epoll_create 方法时，内核会创建一个 eventpoll对象（也就是程序中 epfd 所代表的对象）。eventpoll对象也是文件系统中的一员，和 socket 一样，它也会有等待队列。</p><p>　　创建 epoll 对象后，可以用 epoll_ctl 添加或删除所要监听的socket。以添加 socket 为例，如下图，如果通过 epoll_ctl 添加 sock1、sock2和 sock3 的监视，内核会将 eventpoll 添加到这三个 socket的等待队列中。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051606421.png" style="zoom:67%;" /></center><p>　　当 socket 收到数据后，中断程序会操作 eventpoll对象，而不是直接操作进程。中断程序会给 eventpoll 的“就绪列表”添加 socket引用。如下图展示的是 sock2 和 sock3 收到数据后，中断程序让 rdlist引用这两个 socket。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051608264.png" style="zoom:67%;" /></center><p>　　eventpoll 对象相当于是 socket 和进程之间的中介，socket的数据接收并不直接影响进程，而是通过改变 eventpoll的就绪列表来改变进程状态。</p><p>　　当程序执行到 epoll_wait 时，如果 rdlist 已经引用了socket，那么epoll_wait 直接返回，如果 rdlist 为空，阻塞进程。</p><p>　　假设计算机中正在运行进程 A 和进程 B，在某时刻进程 A运行到了epoll_wait语句。如下图所示，内核会将进程 A 放入 eventpoll的等待队列中，阻塞进程。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051610330.png" style="zoom:67%;" /></center><p>　　当 socket 接收到数据，中断程序一方面修改 rdlist，另一方面唤醒eventpoll 等待队列中的进程，进程 A 再次进入运行状态。也因为 rdlist的存在，进程 A 可以知道哪些 socket 发生了变化。</p><h4 id="epoll的实现细节">5.7 epoll的实现细节</h4><p>　　现在对 epoll的本质已经有一定的了解。但我们还留有一个问题，eventpoll的数据结构是什么样子？</p><p>　　就绪队列应该应使用什么数据结构？eventpoll应使用什么数据结构来管理通过 epoll_ctl 添加或删除的 socket？</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051619847.png" /></p><p>　　就绪列表引用着就绪的socket，所以它应能够快速的插入数据。程序可能随时调用 epoll_ctl 添加监视socket，也可能随时删除。当删除时，若该 socket已经存放在就绪列表中，它也应该被移除，所以就绪列表应是一种能够快速插入和删除的数据结构。epoll使用双向链表来实现就绪队列（即 rdllist）。</p><p>　　既然 epoll将“维护监视队列”和“进程阻塞”分离，也意味着需要有个数据结构来保存监视的socket。至少要方便的添加和移除，还要便于搜索，以避免重复添加。红黑树是一种自平衡二叉查找树，搜索、插入和删除时间复杂度都是O(log(N))，效率较好。epoll使用了红黑树作为索引结构（即 rb_root_cached）。</p><h4 id="总结">5.8总结</h4><p>　　当某一进程调用 epoll_create 方法时，Linux 内核会创建一个eventpoll 结构体，在内核 cache 里建了个红黑树用于存储以后 epoll_ctl传来的 socket 外，还会再建立一个 rdllist双向链表，用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个rdllist 双向链表里有没有数据即可。有数据就返回，没有数据就 sleep，等到timeout 时间到后即使链表没数据也返回。</p><p>　　同时，所有添加到 epoll中的事件都会与设备(如网卡)驱动程序建立回调关系，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做ep_poll_callback，它会把这样的事件放到上面的 rdllist 双向链表中。</p><p>　　当调用 epoll_wait 检查是否有发生事件的连接时，只是检查 eventpoll对象中的 rdllist 双向链表是否有 epitem 元素而已，如果 rdllist链表不为空，则这里的事件复制到用户态内存（使用共享内存提高效率）中，同时将事件数量返回给用户。因此epoll_waitx 效率非常高，可以轻易地处理百万级别的并发连接。</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty——BIO、NIO</title>
    <link href="/2023/10/03/Netty%E2%80%94%E2%80%94BIO%E3%80%81NIO/"/>
    <url>/2023/10/03/Netty%E2%80%94%E2%80%94BIO%E3%80%81NIO/</url>
    
    <content type="html"><![CDATA[<h3 id="bio">1. BIO</h3><p>在 BIO 中 ServerSocket 类负责绑定 IP地址，启动监听端口，等待客户连接；客户端 Socket类的实例发起连接操作，ServerSocket 接受连接后产生一个新的服务端 socket实例负责和客户端 socket 实例通过输入和输出流进行通信。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310031809953.png" style="zoom:50%;" /></center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerSingle</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket();<br>        serverSocket.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8888</span>));<br>        System.out.println(<span class="hljs-string">&quot;Start Server ....&quot;</span>);<br>        <span class="hljs-keyword">int</span> connectCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                Socket socket = serverSocket.accept();<br>                System.out.println(<span class="hljs-string">&quot;accept client socket ....total =&quot;</span> + (++connectCount));<br>                <span class="hljs-keyword">try</span> (ObjectInputStream inputStream = <span class="hljs-keyword">new</span> ObjectInputStream(socket.getInputStream());<br>                     ObjectOutputStream outputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(socket.getOutputStream())) &#123;<br><br>                    String input = inputStream.readUTF();<br>                    System.out.println(<span class="hljs-string">&quot;Accept client message:&quot;</span> + input);<br>                    outputStream.writeUTF(<span class="hljs-string">&quot;Hello,&quot;</span> + input);<br>                    outputStream.flush();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        socket.close();<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            serverSocket.close();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>客户端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Socket socket = <span class="hljs-keyword">null</span>;<br>        ObjectOutputStream output = <span class="hljs-keyword">null</span>;<br>        ObjectInputStream input = <span class="hljs-keyword">null</span>;<br>        InetSocketAddress addr = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8888</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            socket = <span class="hljs-keyword">new</span> Socket();<br>            socket.connect(addr);<br>            System.out.println(<span class="hljs-string">&quot;Connect Server success!!&quot;</span>);<br>            output = <span class="hljs-keyword">new</span> ObjectOutputStream(socket.getOutputStream());<br>            input = <span class="hljs-keyword">new</span> ObjectInputStream(socket.getInputStream());<br>            System.out.println(<span class="hljs-string">&quot;Ready send message.....&quot;</span>);<br>            <br>            output.writeUTF(<span class="hljs-string">&quot;debug&quot;</span>);<br>            output.flush();<br>            System.out.println(input.readUTF());<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (socket != <span class="hljs-keyword">null</span>) socket.close();<br>            <span class="hljs-keyword">if</span> (output != <span class="hljs-keyword">null</span>) output.close();<br>            <span class="hljs-keyword">if</span> (input != <span class="hljs-keyword">null</span>) input.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>BIO 的阻塞，主要体现在两个地方：</p><ol type="1"><li>若一个服务器启动就绪，那么主线程就一直在等待着客户端的连接，这个等待过程中主线程就一直在阻塞。</li><li>在连接建立之后，在读取到 socket信息之前，线程也是一直在等待，一直处于阻塞的状态下的。</li></ol><p>所以在 BIO通信里，我们往往会在服务器的实现上结合线程来处理连接以及和客户端的通信。</p><p>传统 BIO 通信模型：采用 BIO 通信模型的服务端，通常由一个独立的Acceptor线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成后，通过输出流返回应答给客户端，线程销毁。即典型的一请求一应答模型，同时数据的读取写入也必须阻塞在一个线程内等待其完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket();<br>        serverSocket.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8888</span>));<br>        System.out.println(<span class="hljs-string">&quot;Start Server ....&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> ServerTask(serverSocket.accept())).start();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            serverSocket.close();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> Socket socket = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServerTask</span><span class="hljs-params">(Socket socket)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.socket = socket;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> (ObjectInputStream inputStream = <span class="hljs-keyword">new</span> ObjectInputStream(socket.getInputStream());<br>                 ObjectOutputStream outputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(socket.getOutputStream())) &#123;<br><br>                String input = inputStream.readUTF();<br>                System.out.println(<span class="hljs-string">&quot;Accept client message:&quot;</span> + input);<br>                outputStream.writeUTF(<span class="hljs-string">&quot;Hello,&quot;</span> + input);<br>                outputStream.flush();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    socket.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈1:1的正比关系，Java中的线程也是比较宝贵的系统资源，线程数量快速膨胀后，系统的性能将急剧下降，随着访问量的继续增大，系统最终就<strong>死-掉-了</strong>。</p><p>为了改进这种一连接一线程的模型，我们可以使用线程池来管理这些线程，实现1个或多个线程处理N个客户端的模型（但是底层还是使用的同步阻塞I/O），通常被称为“伪异步I/O模型“。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerPool</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket();<br>        serverSocket.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8888</span>));<br>        System.out.println(<span class="hljs-string">&quot;Start Server ....&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                executorService.execute(<span class="hljs-keyword">new</span> ServerTask(serverSocket.accept()));<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            serverSocket.close();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> Socket socket = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServerTask</span><span class="hljs-params">(Socket socket)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.socket = socket;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> (ObjectInputStream inputStream = <span class="hljs-keyword">new</span> ObjectInputStream(socket.getInputStream());<br>                 ObjectOutputStream outputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(socket.getOutputStream())) &#123;<br><br>                String input = inputStream.readUTF();<br>                System.out.println(<span class="hljs-string">&quot;Accept client message:&quot;</span> + input);<br>                outputStream.writeUTF(<span class="hljs-string">&quot;Hello,&quot;</span> + input);<br>                outputStream.flush();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    socket.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用 CachedThreadPool线程池，其实除了能自动帮我们管理线程（复用），看起来也就像是1:1的客户端：线程数模型，而使用FixedThreadPool我们就有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N:M的伪异步I/O 模型。</p><h3 id="nio">2.NIO</h3><p>NIO 库是在 JDK 1.4 中引入的。NIO 弥补了原来的 BIO 的不足，它在标准Java 代码中提供了高速的、面向块的 I/O。</p><h4 id="和-bio-的主要区别">2.1 和 BIO 的主要区别</h4><p><strong>面向流与面向缓冲</strong></p><p>Java NIO 和 IO 之间第一个最大的区别是，IO 是面向流的，NIO是面向缓冲区的。 Java IO面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。Java NIO的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p><p><strong>阻塞与非阻塞 IO</strong></p><p>Java IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write()时，该线程被阻塞，直到有一些数据被读取或完全写入。该线程在此期间不能再干任何事情了。</p><p>Java NIO的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p><h4 id="nio-三大核心组件">2.2 NIO 三大核心组件</h4><p>NIO 三大核心组件：Selector 选择器、Channel 管道、buffer 缓冲区。</p><p><strong>Selector</strong></p><p>Java NIO的选择器允许一个单独的线程来监视多个输入通道，可以注册多个通道使用一个选择器(Selectors)，然后使用一个单独的线程来操作这个选择器，进而“选择”通道：通道里已经有可以处理的输入，或者选择已准备写入的通道。</p><p>应用程序将向 Selector 对象注册需要它关注的 Channel，以及具体的某一个Channel 会对哪些 IO 事件感兴趣。Selector 中也会维护一个“已经注册的Channel ”的容器。</p><p><strong>Channels</strong></p><p>通道，被建立的一个应用程序和操作系统交互事件、传递内容的渠道（注意是连接到操作系统）。那么既然是和操作系统进行内容的传递，那么说明应用程序可以通过通道读取数据，也可以通过通道向操作系统写数据，而且可以同时进行读写。</p><ul><li>所有被 Selector（选择器）注册的通道，只能是继承了 SelectableChannel类的子类。</li><li>ServerSocketChannel：应用服务器程序的监听通道。只有通过这个通道，应用程序才能向操作系统注册支持“多路复用IO”的端口监听。同时支持 UDP 协议和 TCP 协议。</li><li>ScoketChannel：TCP Socket 套接字的监听通道，一个 Socket套接字对应了一个客户端IP:端口 到 服务器IP:端口 的通信连接。</li></ul><p>通道中的数据总是要先读到一个 Buffer，或者总是要从一个 Buffer中写入。</p><p><strong>buffer 缓冲区</strong></p><p>JDK NIO 是面向缓冲的。Buffer 就是这个缓冲，用于和 NIO通道进行交互。数据是从通道读入缓冲区，从缓冲区写入到通道中的。以写为例，应用程序都是将数据写入缓冲，再通过通道把缓冲的数据发送出去，读也是一样，数据总是先从通道读到缓冲，应用程序再读缓冲的数据。</p><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存（其实就是数组）。这块内存被包装成NIO Buffer 对象，并提供了一组方法，用来方便的访问该块内存。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310032157431.png" /></p><h4 id="示例">2.3 示例</h4><p><strong>服务端：</strong></p><p>NioServer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioServerHandle nioServerHandle = <span class="hljs-keyword">new</span> NioServerHandle(DEFAULT_PORT);<br>        <span class="hljs-keyword">new</span> Thread(nioServerHandle, <span class="hljs-string">&quot;Server&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>NioServerHandle</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioServerHandle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> started;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> port 指定要监听的端口号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioServerHandle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">/*创建选择器的实例*/</span><br>            selector = Selector.open();<br>            <span class="hljs-comment">/*创建ServerSocketChannel的实例*/</span><br>            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<br>            <span class="hljs-comment">/*设置通道为非阻塞模式*/</span><br>            serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">/*绑定端口*/</span><br>            serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> InetSocketAddress(port));<br>            <span class="hljs-comment">/*注册事件，表示关心客户端连接*/</span><br>            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<br><br>            started = <span class="hljs-keyword">true</span>;<br>            System.out.println(<span class="hljs-string">&quot;服务器已启动，端口号：&quot;</span> + port);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (started) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">/*获取当前有哪些事件*/</span><br>                selector.select(<span class="hljs-number">1000</span>);<br>                <span class="hljs-comment">/*获取事件的集合*/</span><br>                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br>                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                    SelectionKey key = iterator.next();<br>                    <span class="hljs-comment">/*我们必须首先将处理过的 SelectionKey 从选定的键集合中删除。</span><br><span class="hljs-comment">                    如果我们没有删除处理过的键，那么它仍然会在主集合中以一个激活</span><br><span class="hljs-comment">                    的键出现，这会导致我们尝试再次处理它。*/</span><br>                    iterator.remove();<br>                    handleInput(key);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*处理事件的发生*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleInput</span><span class="hljs-params">(SelectionKey selectionKey)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (selectionKey.isValid()) &#123;<br>            <span class="hljs-comment">/*处理新接入的客户端的请求*/</span><br>            <span class="hljs-keyword">if</span> (selectionKey.isAcceptable()) &#123;<br>                <span class="hljs-comment">/*获取关心当前事件的Channel*/</span><br>                ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.channel();<br>                <span class="hljs-comment">/*接受连接*/</span><br>                SocketChannel socketChannel = serverSocketChannel.accept();<br>                System.out.println(<span class="hljs-string">&quot;==========建立连接=========&quot;</span>);<br>                socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>                <span class="hljs-comment">/*关注读事件*/</span><br>                socketChannel.register(selector, SelectionKey.OP_READ);<br>            &#125;<br>            <span class="hljs-comment">/*处理对端的发送的数据*/</span><br>            <span class="hljs-keyword">if</span> (selectionKey.isReadable()) &#123;<br>                SocketChannel socketChannel = (SocketChannel) selectionKey.channel();<br>                <span class="hljs-comment">/*创建ByteBuffer，开辟一个缓冲区*/</span><br>                ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                <span class="hljs-comment">/*从通道里读取数据，然后写入buffer*/</span><br>                <span class="hljs-keyword">int</span> readBytes = socketChannel.read(buffer);<br>                <span class="hljs-keyword">if</span> (readBytes &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">/*将缓冲区当前的limit设置为position,position=0，</span><br><span class="hljs-comment">                    用于后续对缓冲区的读取操作*/</span><br>                    buffer.flip();<br>                    <span class="hljs-comment">/*根据缓冲区可读字节数创建字节数组*/</span><br>                    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buffer.remaining()];<br>                    <span class="hljs-comment">/*将缓冲区可读字节数组复制到新建的数组中*/</span><br>                    buffer.get(bytes);<br>                    String message = <span class="hljs-keyword">new</span> String(bytes, StandardCharsets.UTF_8);<br>                    System.out.println(<span class="hljs-string">&quot;服务器收到消息：&quot;</span> + message);<br>                    <span class="hljs-comment">/*处理数据*/</span><br>                    String result = Const.response(message);<br>                    <span class="hljs-comment">/*发送应答消息*/</span><br>                    doWrite(socketChannel, result);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readBytes &lt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">/*取消特定的注册关系*/</span><br>                    selectionKey.cancel();<br>                    <span class="hljs-comment">/*关闭通道*/</span><br>                    socketChannel.close();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*发送应答消息*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(SocketChannel sc, String response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] bytes = response.getBytes();<br>        ByteBuffer buffer = ByteBuffer.allocate(bytes.length);<br>        buffer.put(bytes);<br>        buffer.flip();<br>        sc.write(buffer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        started = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端：</strong></p><p>NioClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioClient</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> NioClientHandle nioClientHandle;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        nioClientHandle = <span class="hljs-keyword">new</span> NioClientHandle(DEFAULT_SERVER_IP, DEFAULT_PORT);<br>        <span class="hljs-keyword">new</span> Thread(nioClientHandle, <span class="hljs-string">&quot;client&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-comment">//向服务器发送消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        nioClientHandle.sendMsg(msg);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        start();<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">while</span> (NioClient.sendMsg(scanner.next())) ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>NioClientHandle</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioClientHandle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String host;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;<br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> SocketChannel socketChannel;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> started;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioClientHandle</span><span class="hljs-params">(String ip, <span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.host = ip;<br>        <span class="hljs-keyword">this</span>.port = port;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">/*创建选择器的实例*/</span><br>            selector = Selector.open();<br>            <span class="hljs-comment">/*创建SocketChannel的实例*/</span><br>            socketChannel = SocketChannel.open();<br>            <span class="hljs-comment">/*设置通道为非阻塞模式*/</span><br>            socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>            started = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            doConnect();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            System.exit(<span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//循环遍历selector</span><br>        <span class="hljs-keyword">while</span> (started) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//无论是否有读写事件发生，selector每隔1s被唤醒一次</span><br>                selector.select(<span class="hljs-number">1000</span>);<br>                <span class="hljs-comment">//获取当前有哪些事件可以使用</span><br>                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>                Iterator&lt;SelectionKey&gt; selectionKeyIterator = keys.iterator();<br>                SelectionKey selectionKey;<br>                <span class="hljs-keyword">while</span> (selectionKeyIterator.hasNext()) &#123;<br>                    selectionKey = selectionKeyIterator.next();<br>                    selectionKeyIterator.remove();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        handleInput(selectionKey);<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        <span class="hljs-keyword">if</span> (selectionKey != <span class="hljs-keyword">null</span>) &#123;<br>                            selectionKey.cancel();<br>                            <span class="hljs-keyword">if</span> (selectionKey.channel() != <span class="hljs-keyword">null</span>) &#123;<br>                                selectionKey.channel().close();<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>                System.exit(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//selector关闭后会自动释放里面管理的资源</span><br>        <span class="hljs-keyword">if</span> (selector != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">try</span> &#123;<br>                selector.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//具体的事件处理方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleInput</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (!key.isValid()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//获得关心当前事件的channel</span><br>        SocketChannel socketChannel = (SocketChannel) key.channel();<br>        <span class="hljs-comment">//连接事件</span><br>        <span class="hljs-keyword">if</span> (key.isConnectable()) &#123;<br>            <span class="hljs-keyword">if</span> (socketChannel.finishConnect()) &#123;<br>                <span class="hljs-keyword">this</span>.socketChannel.register(selector, SelectionKey.OP_READ);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.exit(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//有数据可读事件</span><br>        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            <span class="hljs-keyword">int</span> readBytes = socketChannel.read(buffer);<br>            <span class="hljs-keyword">if</span> (readBytes &gt; <span class="hljs-number">0</span>) &#123;<br>                buffer.flip();<br>                <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buffer.remaining()];<br>                buffer.get(bytes);<br>                String result = <span class="hljs-keyword">new</span> String(bytes, StandardCharsets.UTF_8);<br>                System.out.println(<span class="hljs-string">&quot;客户端收到消息：&quot;</span> + result);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readBytes &lt; <span class="hljs-number">0</span>) &#123;<br>                key.cancel();<br>                socketChannel.close();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(SocketChannel channel, String request)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] bytes = request.getBytes();<br>        ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);<br>        writeBuffer.put(bytes);<br>        writeBuffer.flip();<br>        <span class="hljs-comment">/*关心事件和读写网络并不冲突*/</span><br>        channel.write(writeBuffer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doConnect</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">/*非阻塞的连接*/</span><br>        <span class="hljs-keyword">if</span> (socketChannel.connect(<span class="hljs-keyword">new</span> InetSocketAddress(host, port))) &#123;<br>            socketChannel.register(selector, SelectionKey.OP_READ);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            socketChannel.register(selector, SelectionKey.OP_CONNECT);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//写数据对外暴露的API</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        doWrite(socketChannel, msg);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        started = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="selectionkey">2.4 SelectionKey</h4><p>SelectionKey 是一个抽象类，表示 selectableChannel 在 Selector中注册的标识。每个 Channel 向 Selector 注册时，都将会创建一个SelectionKey。SelectionKey 将 Channel 与 Selector 建立了关系，并维护了channel 事件。</p><p>可以通过 cancel 方法取消键，取消的键不会立即从 selector中移除，而是添加到 cancelledKeys 中,在下一次 select操作时移除它。所以在调用某个 key 时，需要使用 isValid 进行校验。</p><p><strong>SelectionKey 类型和就绪条件：</strong></p><p>在向 Selector 对象注册感兴趣的事件时，JAVA NIO共定义了四种：OP_READ、OP_WRITE、OP_CONNECT、OP_ACCEPT（定义在SelectionKey 中），分别对应读、写、请求连接、接受连接等网络 Socket操作。</p><table><thead><tr><th><strong>操作类型</strong></th><th><strong>就绪条件及说明</strong></th></tr></thead><tbody><tr><td>OP_READ</td><td>当操作系统读缓冲区有数据可读时就绪。并非时刻都有数据可读，所以一般需要注册该操作，仅当有就绪时才发起读操作，有的放矢，避免浪费CPU。</td></tr><tr><td>OP_WRITE</td><td>当操作系统写缓冲区有空闲空间时就绪。一般情况下写缓冲区都有空闲空间，小块数据直接写入即可，没必要注册该操作类型，否则该条件不断就绪浪费CPU；但如果是写密集型的任务，比如文件下载等，缓冲区很可能满，注册该操作类型就很有必要，同时注意写完后取消注册。</td></tr><tr><td>OP_CONNECT</td><td>当SocketChannel.connect()请求连接成功后就绪。该操作只给客户端使用。</td></tr><tr><td>OP_ACCEPT</td><td>当接收到一个客户端连接请求时就绪。该操作只给服务器使用。</td></tr></tbody></table><p><strong>服务端和客户端分别感兴趣的类型：</strong></p><p>ServerSocketChannel 和 SocketChannel可以注册自己感兴趣的操作类型，当对应操作类型的就绪条件满足时 OS 会通知channel，下表描述各种 Channel 允许注册的操作类型，Y 表示允许注册，N表示不允许注册，其中服务器 SocketChannel指由服务器ServerSocketChannel.accept() 返回的对象。</p><table><thead><tr><th></th><th>OP_READ</th><th>OP_WRITE</th><th>OP_CONNECT</th><th>OP_ACCEPT</th></tr></thead><tbody><tr><td>服务器ServerSocketChannel</td><td></td><td></td><td></td><td><strong>Y</strong></td></tr><tr><td>服务器 SocketChannel</td><td><strong>Y</strong></td><td><strong>Y</strong></td><td></td><td></td></tr><tr><td>客户端SocketChannel</td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td></td></tr></tbody></table><p>服务器启动 ServerSocketChannel，关注 OP_ACCEPT 事件。</p><p>客户端启动 SocketChannel，连接服务器，关注 OP_CONNECT事件</p><p>服务器接受连接，启动一个服务器的 SocketChannel，这个 SocketChannel可以关注 OP_READ、OP_WRITE 事件，一般连接建立后会直接关注 OP_READ事件</p><p>客户端 SocketChannel 发现连接建立后，可以关注 OP_READ、OP_WRITE事件。</p><h4 id="写事件监听示例">2.5 写事件监听示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioServerHandleWriteable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> started;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioServerHandleWriteable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            selector = Selector.open();<br>            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<br>            serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<span class="hljs-comment">//开启非阻塞模式</span><br>            serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> InetSocketAddress(port), <span class="hljs-number">1024</span>);<br>            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<br>            started = <span class="hljs-keyword">true</span>;<br>            System.out.println(<span class="hljs-string">&quot;服务器已启动，端口号：&quot;</span> + port);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            System.exit(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (started) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//阻塞,只有当至少一个注册的事件发生的时候才会继续.</span><br>                selector.select();<br>                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>                Iterator&lt;SelectionKey&gt; selectionKeyIterator = selectionKeys.iterator();<br>                SelectionKey selectionKey = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">while</span> (selectionKeyIterator.hasNext()) &#123;<br>                    selectionKey = selectionKeyIterator.next();<br>                    selectionKeyIterator.remove();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        handleInput(selectionKey);<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        <span class="hljs-keyword">if</span> (selectionKey != <span class="hljs-keyword">null</span>) &#123;<br>                            selectionKey.cancel();<br>                            <span class="hljs-keyword">if</span> (selectionKey.channel() != <span class="hljs-keyword">null</span>) &#123;<br>                                selectionKey.channel().close();<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                t.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//selector关闭后会自动释放里面管理的资源</span><br>        <span class="hljs-keyword">if</span> (selector != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">try</span> &#123;<br>                selector.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleInput</span><span class="hljs-params">(SelectionKey selectionKey)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;当前通道的事件：&quot;</span> + selectionKey.interestOps());<br>        <span class="hljs-keyword">if</span> (selectionKey.isValid()) &#123;<br>            <span class="hljs-keyword">if</span> (selectionKey.isAcceptable()) &#123;<br>                ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.channel();<br>                <span class="hljs-comment">//通过ServerSocketChannel的accept创建SocketChannel实例</span><br>                <span class="hljs-comment">//完成该操作意味着完成TCP三次握手，TCP物理链路正式建立</span><br>                SocketChannel sc = serverSocketChannel.accept();<br>                System.out.println(<span class="hljs-string">&quot;======socket channel 建立连接=======&quot;</span>);<br>                <span class="hljs-comment">//设置为非阻塞的</span><br>                sc.configureBlocking(<span class="hljs-keyword">false</span>);<br>                <span class="hljs-comment">//连接已经完成了，可以开始关心读事件了</span><br>                sc.register(selector, SelectionKey.OP_READ);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (selectionKey.isReadable()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;======socket channel 数据准备完成，可以去读取=======&quot;</span>);<br>                SocketChannel socketChannel = (SocketChannel) selectionKey.channel();<br>                ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                <span class="hljs-keyword">int</span> readBytes = socketChannel.read(buffer);<br>                <span class="hljs-keyword">if</span> (readBytes &gt; <span class="hljs-number">0</span>) &#123;<br>                    buffer.flip();<br>                    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buffer.remaining()];<br>                    buffer.get(bytes);<br>                    String message = <span class="hljs-keyword">new</span> String(bytes, StandardCharsets.UTF_8);<br>                    System.out.println(<span class="hljs-string">&quot;服务器收到消息：&quot;</span> + message);<br>                    String result = response(message);<br>                    doWrite(socketChannel, result);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readBytes &lt; <span class="hljs-number">0</span>) &#123;<br>                    selectionKey.cancel();<br>                    socketChannel.close();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (selectionKey.isWritable()) &#123;<br>                SocketChannel socketChannel = (SocketChannel) selectionKey.channel();<br>                ByteBuffer buffer = (ByteBuffer) selectionKey.attachment();<br>                <span class="hljs-keyword">if</span> (buffer.hasRemaining()) &#123;<br>                    <span class="hljs-keyword">int</span> count = socketChannel.write(buffer);<br>                    System.out.println(<span class="hljs-string">&quot;write :&quot;</span> + count + <span class="hljs-string">&quot;byte, remaining:&quot;</span> + buffer.hasRemaining());<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">/*取消对写的注册*/</span><br>                    selectionKey.interestOps(SelectionKey.OP_READ);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//发送应答消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(SocketChannel channel, String response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] bytes = response.getBytes();<br>        ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);<br>        writeBuffer.put(bytes);<br>        writeBuffer.flip();<br>        channel.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, writeBuffer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        started = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>写操作完成之后需要取消OP_WRITE的注册。</p><h4 id="buffer">2.6 Buffer</h4><h5 id="重要属性">1. 重要属性</h5><p><strong>capacity</strong></p><p>作为一个内存块，Buffer有一个固定的大小值，也叫“capacity”。你只能往里写 capacity 个byte、long，char 等类型。一旦 Buffer满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</p><p><strong>position</strong></p><p>当你写数据到 Buffer 中时，position 表示当前能写的位置。初始的position 值为 0。当一个 byte、long 等数据写到 Buffer 后， position会向前移动到下一个可插入数据的 Buffer 单元。position 最大可为 capacity –1.</p><p>当读取数据时，也是从某个特定位置读。当将 Buffer从写模式切换到读模式，position 会被重置为 0。当从 Buffer 的 position处读取数据时，position 向前移动到下一个可读的位置。</p><p><strong>limit</strong></p><p>在写模式下，Buffer 的 limit 表示你最多能往 Buffer 里写多少数据。写模式下，limit 等于 Buffer 的 capacity。当切换 Buffer 到读模式时，limit 表示你最多能读到多少数据。因此，当切换 Buffer 到读模式时，limit会被设置成写模式下的 position值。</p><h5 id="buffer的分配">2. Buffer的分配</h5><p>要想获得一个 Buffer 对象首先要进行分配。 每一个 Buffer 类都有<strong>allocate</strong>方法(可以在堆上分配，也可以在直接内存上分配)。</p><p>分配48字节 capacity 的 ByteBuffer 的例子: ByteBuffer buf =ByteBuffer.allocate(48);</p><p>分配一个可存储1024个字符的CharBuffer：CharBuffer buf =CharBuffer.allocate(1024);</p><p><strong>wrap方法</strong>：把一个 byte 数组或 byte 数组的一部分包装成ByteBuffer：</p><p>ByteBuffer wrap(byte [] array)</p><p>ByteBuffer wrap(byte [] array, int offset, int length)</p><h5 id="直接内存">3. 直接内存</h5><p>HeapByteBuffer 与 DirectByteBuffer，在原理上，前者可以看出分配的buffer 是在 heap 区域的，其实真正 flush到远程的时候会先拷贝到直接内存，再做下一步操作；在 NIO的框架下，很多框架会采用 DirectByteBuffer 来操作，这样分配的内存不再是在java heap上，经过性能测试，可以得到非常快速的网络交互，在大量的网络交互下，一般速度会比HeapByteBuffer 要快速好几倍。</p><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是Java虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致OutOfMemoryError 异常出现。</p><p>NIO 可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java堆里面的 DirectByteBuffer对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在Java 堆和 Native 堆中来回复制数据。</p><p><strong>直接内存（堆外内存）与堆内存比较：</strong></p><p>直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显</p><p>直接内存 IO读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显</p><h5 id="buffer的读写">4. Buffer的读写</h5><p><strong>向 Buffer 中写数据：</strong></p><ul><li>读取 Channel 写到 Buffer</li><li>通过 Buffer 的 put() 方法写到 Buffer 里</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从Channel写到Buffer的例子</span><br><span class="hljs-keyword">int</span> readBytes = socketChannel.read(buffer);<br><span class="hljs-comment">//通过put方法写Buffer的例子：</span><br>buffer.put(bytes);<br></code></pre></td></tr></table></figure><p>put 方法有很多版本，允许你以不同的方式把数据写入到 Buffer 中。例如，写到一个指定的位置，或者把一个字节数组写入到 Buffer。在比如：put(byteb)，向 position 的位置写入一个 byte，并将postion+1，为下次读写作准备。</p><p><strong>flip()方法</strong></p><p>flip方法将 Buffer 从写模式切换到读模式。调用 flip() 方法会将 position设回 0，并将 limit 设置成之前 position 的值。</p><p><strong>从 Buffer 中读取数据</strong></p><ol type="1"><li>从 Buffer 读取数据写入到 Channel</li><li>使用 get() 方法从 Buffer 中读取数据</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">socketChannel.write(writeBuffer);<br>buffer.get(bytes);<br></code></pre></td></tr></table></figure><p>get 方法有很多版本，允许你以不同的方式从 Buffer中读取数据。例如，从指定 position 读取，或者从 Buffer中读取数据到字节数组，再比如 get() 属于相对读，从 position 位置读取一个byte，并将 position+1，为下次读写作准备;</p><p><strong>使用 Buffer 读写数据常见步骤：</strong></p><ol type="1"><li>写入数据到 Buffer</li><li>调用flip()方法</li><li>从 Buffer 中读取数据</li><li>调用 clear() 方法或者 compact() 方法，准备下一次的写入</li></ol><p>当向 buffer 写入数据时，buffer会记录下写了多少数据。一旦要读取数据，需要通过 flip() 方法将 Buffer从写模式切换到读模式。在读模式下，可以读取之前写入到 buffer的所有数据。一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用clear() 或 compact() 方法。clear() 方法会清空整个缓冲区。compact()方法只会清除已经读过的数据。</p><h5 id="其他常用操作">5. 其他常用操作</h5><p><strong>绝对读写</strong></p><p>put(int index, byte b) 绝对写，向 byteBuffer 底层的 bytes 中下标为index 的位置插入 byte b，不改变 position 的值。</p><p>get(int index) 属于绝对读，读取 byteBuffer 底层的 bytes 中下标为index 的 byte，不改变 position。</p><p><strong>rewind()</strong></p><p>Buffer.rewind() 将 position 设回 0，所以你可以重读 Buffer中的所有数据。limit 保持不变，仍然表示能从 Buffer中读取多少个元素（byte、char等）。</p><p><strong>clear() 与 compact()</strong></p><p>一旦读完 Buffer 中的数据，需要让 Buffer 准备好再次被写入。可以通过clear() 或 compact() 方法来完成。</p><p>如果调用的是 clear() 方法，position 将被设回 0，limit 被设置成capacity 的值。换句话说，Buffer 被清空了。Buffer中的数据并未清除，只是这些标记告诉我们可以从哪里开始往 Buffer里写数据。compact() 方法将所有未读的数据拷贝到 Buffer 起始处。然后将position 设到最后一个未读元素正后面。现在 Buffer准备好写数据了，但是不会覆盖未读的数据。</p><p><strong>mark() 与 reset() 方法</strong></p><p>通过调用 Buffer.mark() 方法，可以标记 Buffer 中的一个特定position。之后可以通过调用 Buffer.reset() 方法恢复到这个position。</p><p><strong>equals() 与 compareTo() 方法</strong></p><p>equals()：</p><p>当满足下列条件时，表示两个Buffer相等：</p><ol type="1"><li>有相同的类型（byte、char、int等）。</li><li>Buffer 中剩余的 byte、char 等的个数相等。</li><li>Buffer 中所有剩余的 byte、char 等都相同。</li></ol><p>compareTo()：</p><p>compareTo() 方法比较两个 Buffer 的剩余元素(byte、char等)，如果满足下列条件，则认为一个 Buffer “小于”另一个 Buffer：</p><ol type="1"><li>第一个不相等的元素小于另一个Buffer中对应的元素 。</li><li>所有元素都相等，但第一个 Buffer 比另一个先耗尽(第一个 Buffer的元素个数比另一个少)。</li></ol><h5 id="buffer方法总结">6. Buffer方法总结</h5><table><thead><tr><th>limit(), limit(10)等</th><th>其中读取和设置这4个属性的方法的命名和jQuery中的val(),val(10)类似，一个负责get，一个负责set</th></tr></thead><tbody><tr><td>reset()</td><td>把 position 设置成 mark的值，相当于之前做过一个标记，现在要退回到之前标记的地方</td></tr><tr><td>clear()</td><td>position = 0;limit = capacity;mark = -1</td></tr><tr><td>flip()</td><td>limit = position;position = 0;mark = -1</td></tr><tr><td>rewind()</td><td>把 position 设为 0，mark 设为 -1，不改变 limit 的值</td></tr><tr><td>remaining()</td><td>返回 limit 和position 之间相对位置差</td></tr><tr><td>hasRemaining()</td><td>返回是否还有未读内容</td></tr><tr><td>compact()</td><td>把从 position 到 limit 中的内容移到 0 到 limit-position的区域内</td></tr><tr><td>get()</td><td>相对读，从 position 位置读取一个 byte，并将position+1，为下次读写作准备</td></tr><tr><td>get(int index)</td><td>绝对读，读取 byteBuffer 底层的 bytes 中下标为 index 的 byte，不改变position</td></tr><tr><td>get(byte[] dst, int offset, int length)</td><td>从 position 位置开始相对读，读 length 个 byte，并写入 dst 下标从offset 到 offset+length 的区域</td></tr><tr><td>put(byte b)</td><td>相对写，向 position 的位置写入一个 byte，并将postion+1，为下次读写作准备</td></tr><tr><td>put(int index, byte b)</td><td>绝对写，向 byteBuffer 底层的 bytes 中下标为 index 的位置插入byteb，不改变 position</td></tr><tr><td>put(ByteBuffer src)</td><td>用相对写，把src中可读的部分（也就是 position 到 limit）写入此byteBuffer</td></tr><tr><td>put(byte[] src, int offset, int length)</td><td>从 src 数组中的 offset 到 offset+length区域读取数据并使用相对写写入此 byteBuffer</td></tr></tbody></table><h4 id="reactor模式类型">2.7 Reactor模式类型</h4><h5 id="单线程reactor模式流程">1. 单线程Reactor模式流程</h5><ul><li>服务器端的 Reactor 是一个线程对象，该线程会启动事件循环，并使用Selector (选择器)来实现 IO 的多路复用。注册一个 Acceptor 事件处理器到Reactor 中，Acceptor 事件处理器所关注的事件是 ACCEPT 事件，这样 Reactor会监听客户端向服务器端发起的连接请求事件(ACCEPT事件)。</li><li>客户端向服务器端发起一个连接请求，Reactor 监听到了该 ACCEPT事件的发生并将该 ACCEPT 事件派发给相应的 Acceptor处理器来进行处理。Acceptor 处理器通过 accept()方法得到与这个客户端对应的连接(SocketChannel)，然后将该连接所关注的 READ事件以及对应的 READ 事件处理器注册到 Reactor 中，这样一来 Reactor就会监听该连接的 READ 事件了。</li><li>当 Reactor监听到有读或者写事件发生时，将相关的事件派发给对应的处理器进行处理。比如，读处理器会通过SocketChannel 的 read() 方法读取数据，此时 read()操作可以直接读取到数据，而不会堵塞与等待可读的数据到来。</li><li>每当处理完所有就绪的感兴趣的 I/O 事件后，Reactor 线程会再次执行select() 阻塞等待新的事件就绪并将其分派给对应处理器进行处理。</li></ul><p>注意，Reactor 的单线程模式的单线程主要是针对于 I/O操作而言，也就是所有的 I/O 的 accept()、read()、write() 以及 connect()操作都在一个线程上完成的。</p><p>但在目前的单线程 Reactor 模式中，不仅 I/O 操作在该 Reactor线程上，连非 I/O 的业务操作也在该线程上进行处理了，这可能会大大延迟 I/O请求的响应。所以我们应该将非 I/O 的业务逻辑操作从 Reactor线程上卸载，以此来加速 Reactor 线程对 I/O 请求的响应。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042006610.png" style="zoom:50%;" /></center><h5 id="单线程reactor工作者线程池">2. 单线程Reactor，工作者线程池</h5><p>与单线程 Reactor 模式不同的是，添加了一个工作者线程池，并将非 I/O操作从 Reactor 线程中移出转交给工作者线程池来执行。这样能够提高 Reactor线程的 I/O 响应，不至于因为一些耗时的业务逻辑而延迟对后面 I/O请求的处理。</p><p>使用线程池的优势：</p><p>①通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程产生的巨大开销。</p><p>②当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。</p><p>③通过适当调整线程池的大小，可以创建足够多的线程以便使处理器保持忙碌状态。同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。</p><p>改进的版本中，I/O 操作依旧由一个 Reactor 来完成，包括 I/O 的accept()、read()、write() 以及 connect() 操作。</p><p>对于一些小容量应用场景，可以使用单线程模型。但是对于高负载、大并发或大数据量的应用场景却不合适，主要原因如下：</p><p>① 一个 NIO 线程同时处理成百上千的链路，性能上无法支撑，即便 NIO线程的 CPU 负荷达到100%，也无法满足海量消息的读取和发送；</p><p>② 当 NIO线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重了NIO线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈；</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042014630.png" style="zoom:50%;" /></center><h5 id="多线程主从reactor模式">3. 多线程主从Reactor模式</h5><p>Reactor 线程池中的每一 Reactor 线程都会有自己的Selector、线程和分发的事件循环逻辑。</p><p>mainReactor 可以只有一个，但 subReactor 一般会有多个。mainReactor线程主要负责接收客户端的连接请求，然后将接收到的 SocketChannel 传递给subReactor，由 subReactor 来完成和客户端的通信。</p><p>流程：</p><p>① 注册一个 Acceptor 事件处理器到 mainReactor 中，Acceptor事件处理器所关注的事件是 ACCEPT 事件，这样 mainReactor会监听客户端向服务器端发起的连接请求事件(ACCEPT事件)。启动 mainReactor的事件循环。</p><p>② 客户端向服务器端发起一个连接请求，mainReactor 监听到了该 ACCEPT事件并将该 ACCEPT 事件派发给 Acceptor 处理器来进行处理。Acceptor处理器通过 accept()方法得到与这个客户端对应的连接(SocketChannel)，然后将这个 SocketChannel传递给 subReactor 线程池。</p><p>③ subReactor 线程池分配一个 subReactor 线程给这个SocketChannel，即，将 SocketChannel 关注的 READ 事件以及对应的 READ事件处理器注册到 subReactor 线程中。Reactor 线程池中的每一 Reactor线程都会有自己的 Selector、线程和分发的循环逻辑。</p><p>④ 当有 I/O 事件就绪时，相关的 subReactor就将事件派发给响应的处理器处理。注意，这里 subReactor 线程只负责完成 I/O的 read()操作，在读取到数据后将业务逻辑的处理放入到线程池中完成，若完成业务逻辑后需要返回数据给客户端，则相关的I/O 的 write 操作还是会被提交回 subReactor 线程来完成。</p><p>注意，所有的 I/O 操作(包括，I/O 的 accept()、read()、write() 以及connect() 操作)依旧还是在 Reactor 线程( mainReactor 线程 或 subReactor线程)中完成的。Thread Pool(线程池)仅用来处理非 I/O 操作的逻辑。</p><p>多 Reactor线程模式将“接受客户端的连接请求”和“与该客户端的通信”分在了两个 Reactor线程来完成。mainReactor完成接收客户端连接请求的操作，它不负责与客户端的通信，而是将建立好的连接转交给subReactor 线程来完成与客户端的通信，这样一来就不会因为 read()数据量太大而导致后面的客户端连接请求得不到即时处理的情况。并且多 Reactor线程模式在海量的客户端并发请求的情况下，还可以通过实现 subReactor线程池来将海量的连接分发给多个 subReactor线程，在多核的操作系统中这能大大提升应用的负载和吞吐量。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042023285.png" style="zoom:50%;" /></center><h5 id="和观察者模式的区别">4. 和观察者模式的区别</h5><p><strong>观察者模式：</strong>也可以称为为 发布-订阅模式，主要适用于多个对象依赖某一个对象的状态，并且当某对象状态发生改变时，要通知其他依赖对象做出更新。是一种一对多的关系。当然，如果依赖的对象只有一个时，也是一种特殊的一对一关系。通常，观察者模式适用于消息事件处理，监听者监听到事件时通知事件处理者对事件进行处理。</p><p><strong>Reactor模式：</strong> 即反应器模式，是一种高效的异步 IO模式，特征是回调，当 IO完成时，回调对应的函数进行处理。这种模式并非是真正的异步，而是运用了异步的思想，当IO 事件触发时，通知应用程序作出 IO 处理。模式本身并不调用系统的异步 IO函数。</p><p>reactor模式与观察者模式有点像。不过，观察者模式与单个事件源关联，而反应器模式则与多个事件源关联。当一个主体发生改变时，所有依属体都得到通知。</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo——服务导出和服务引入</title>
    <link href="/2023/06/15/Dubbo%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E5%AF%BC%E5%87%BA%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%BC%95%E5%85%A5/"/>
    <url>/2023/06/15/Dubbo%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E5%AF%BC%E5%87%BA%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%BC%95%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>不管是服务导出还是服务引入，都发生在应用启动过程中。在启动类上加上<span class="citation" data-cites="EnableDubbo">@EnableDubbo</span>时，该注解上有一个 <span class="citation"data-cites="DubboComponentScan">@DubboComponentScan</span> 注解，<spanclass="citation"data-cites="DubboComponentScan">@DubboComponentScan</span> 注解 Import了一个 DubboComponentScanRegistrar，DubboComponentScanRegistrar 中会调用DubboSpringInitializer.initialize()，该方法中会注册一个DubboDeployApplicationListener，而 DubboDeployApplicationListener 会监听Spring 容器启动完成事件ContextRefreshedEvent，一旦接收到这个事件后，就会开始 Dubbo的启动流程，就会执行 DefaultModuleDeployer 的 start()进行<strong>服务导出</strong>与<strong>服务引入</strong>。</p><p>Dubbo3.0源码：https://gitee.com/archguide/dubbo-dubbo-3.0.7</p><p>服务导出和引入整体流程：https://www.processon.com/view/link/62c441e80791293dccaebded</p><p>在启动过程中，在做完<strong>服务导出</strong>与<strong>服务引入</strong>后，还会做几件非常重要的事情：</p><ol type="1"><li>导出一个应用元数据服务（就是一个 MetadataService服务，这个服务也会注册到注册中心），或者将应用元数据注册到元数据中心。</li><li>生成当前应用的实例信息对象 ServiceInstance，比如应用名、实例ip、实例 port，并将实例信息注册到注册中心，也就是应用级注册。</li></ol><h3 id="服务导出">1. 服务导出</h3><p>在<strong>某个接口的实现类</strong>上加上 <strong><spanclass="citation" data-cites="DubboService">@DubboService</span></strong>后，就表示定义了一个 Dubbo 服务，应用启动时 Dubbo 只要扫描到了 <spanclass="citation"data-cites="DubboService">@DubboService</span>，就会解析对应的类，得到服务相关的配置信息，比如：</p><ol type="1"><li>服务的类型，也就是接口，接口名就是服务名</li><li>服务的具体实现类，也就是当前类</li><li>服务的 version、timeout 等信息，就是 <span class="citation"data-cites="DubboService">@DubboService</span> 中所定义的各种配置</li></ol><p>解析完服务的配置信息后，就会把这些配置信息封装成为一个 ServiceConfig对象，并调用其 export() 进行服务导出，此时一个 ServiceConfig对象就表示一个 Dubbo 服务。</p><p>而所谓的服务导出，主要就是完成三件事情：</p><ol type="1"><li>确定服务的最终参数配置</li><li>按不同协议启动对应的 Server（<strong>服务暴露</strong>）</li><li>将服务注册到注册中心（<strong>服务注册</strong>）</li></ol><h4 id="确定服务参数">1.1 确定服务参数</h4><p>一个 Dubbo服务，除开服务的名字，也就是接口名，还会有很多其他的属性，比如超时时间、版本号、服务所属应用名、所支持的协议及绑定的端口等众多信息。</p><p>但是，通常这些信息并不会全部在 <span class="citation"data-cites="DubboService">@DubboService</span> 中进行定义，比如，一个Dubbo 服务肯定是属于某个应用的，而一个应用下可以有多个 Dubbo服务，所以我们可以在应用级别定义一些通用的配置，比如协议。</p><p>我们在 application.yml 中定义：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dubbo:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">order-application</span><br>  <span class="hljs-attr">protocol:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">tri</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">20880</span><br></code></pre></td></tr></table></figure><p>表示当前应用下所有的 Dubbo 服务都支持通过 tri协议进行访问，并且访问端口为20880，所以在进行<strong>某个服务</strong>的服务导出时，就需要将应用中的这些配置信息合并到当前服务的配置信息中。</p><h4 id="服务注册">1.2 服务注册</h4><p>当确定好了最终的服务配置后，Dubbo就会根据这些配置信息生成对应的<strong>服务 URL</strong>，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tri://192.168.110.140:50051/com.debuggingWorld.mall.service.OrderService?anyhost=true&amp;application=order-application<br></code></pre></td></tr></table></figure><p>这个 URL 就表示了一个 Dubbo 服务，服务消费者只要能获得到这个服务URL，就知道了关于这个 Dubbo服务的全部信息，包括服务名、支持的协议、ip、port、各种配置。</p><p>确定了服务 URL 之后，服务注册要做的事情就是把这个服务 URL存到注册中心（比如 Zookeeper）中去，说的再简单一点，就是把这个字符串存到Zookeeper 中去，这个步骤其实是非常简单的，实现这个功能的源码在RegistryProtocol 中的 export() 方法中，最终服务 URL 存在了 Zookeeper 的<strong>/dubbo/ 接口名 /providers</strong> 目录下。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306210156440.png" /></p><p>但是服务注册并不仅仅就这么简单，既然上面的这个 URL表示一个服务，并且还包括了服务的一些配置信息，那这些配置信息如果改变了呢？比如利用Dubbo管理台中的动态配置功能（注意，并不是配置中心）来修改服务配置，动态配置可以应用运行过程中动态的修改服务的配置，并实时生效。</p><p>如果利用动态配置功能修改了服务的参数，那此时就要重新生成服务 URL并重新注册到注册中心，这样服务消费者就能及时的获取到服务配置信息。</p><p>而对于服务提供者而言，在服务注册过程中，还需要能监听到动态配置的变化，一旦发生了变化，就根据最新的配置重新生成服务URL，并重新注册到中心。</p><h4 id="应用级注册">1.3 应用级注册</h4><p>在 Dubbo3.0 之前，Dubbo是接口级注册，服务注册就是把接口名以及服务配置信息注册到注册中心中，注册中心存储的数据格式大概为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">接口名1：tri://192.168.110.140:50051/接口名1?application=应用名<br>接口名2：tri://192.168.110.140:50051/接口名2?application=应用名<br>接口名3：tri://192.168.110.140:50051/接口名3?application=应用名<br></code></pre></td></tr></table></figure><p>key 是接口名，value 就是服务URL，上面的内容就表示现在有一个应用，该应用下有 3 个接口，应用实例部署在192.168.110.140，此时，如果给该应用增加一个实例，实例 ip 为192.168.110.141，那么新的实例也需要进行服务注册，会向注册中心新增 3条数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">接口名1：tri://192.168.110.140:50051/接口名1?application=应用名<br>接口名2：tri://192.168.110.140:50051/接口名2?application=应用名<br>接口名3：tri://192.168.110.140:50051/接口名3?application=应用名<br><br>接口名1：tri://192.168.110.141:50051/接口名1?application=应用名<br>接口名2：tri://192.168.110.141:50051/接口名2?application=应用名<br>接口名3：tri://192.168.110.141:50051/接口名3?application=应用名<br></code></pre></td></tr></table></figure><p>可以发现，如果一个应用中有 3 个 Dubbo服务，那么每增加一个实例，就会向注册中心增加 3条记录，那如果一个应用中有 10 个 Dubbo服务，那么每增加一个实例，就会向注册中心增加 10条记录，注册中心的压力会随着应用实例的增加而剧烈增加。</p><p>反过来，如果一个应用有 3 个 Dubbo 服务，5 个实例，那么注册中心就有 15条记录，此时增加一个 Dubbo 服务，那么注册中心就会新增 5条记录，注册中心的压力也会剧烈增加。</p><p>注册中心的数据越多，数据就变化的越频繁，比如修改服务的timeout，那么对于注册中心和应用都需要消耗资源用来处理数据变化。</p><p>所以为了降低注册中心的压力，Dubbo3.0支持了应用级注册，同时也兼容接口级注册，用户可以逐步迁移成应用级注册，而一旦采用应用级注册，最终注册中心的数据存储就变成为：</p><blockquote><p>应用名：192.168.110.140:20880 应用名：192.168.110.141:20880</p></blockquote><p>表示在注册中心中，只记录应用所对应的实例信息（IP+绑定的端口），这样只有一个应用的实例增加了，那么注册中心的数据才会增加，而不关心一个应用中到底有多少个Dubbo 服务。</p><p>这样带来的好处就是，注册中心存储的数据变少了，注册中心中数据的变化频率变小了，并且使用应用级注册，使得Dubbo3 能实现与异构微服务体系如 Spring Cloud、Kubernetes Service等在地址发现层面更容易互通， 为连通 Dubbo与其他微服务体系提供可行方案。</p><p>应用级注册带来了好处，但是对于 Dubbo来说又出现了一些新的问题，比如：原本，服务消费者可以直接从注册中心就知道某个Dubbo服务的所有服务提供者以及相关的协议、ip、port、配置等信息，那现在注册中心上只有ip、port，那对于服务消费者而言：<strong>服务消费者怎么知道现在它要用的某个Dubbo 服务，也就是某个接口对应的应用是哪个呢？</strong></p><p>对于这个问题，在进行服务导出的过程中，会在 Zookeeper中存一个映射关系，在服务导出的最后一步，在 ServiceConfig 的 exported()方法中，会保存这个映射关系：</p><blockquote><p>接口名：应用名</p></blockquote><p>这个映射关系存在 Zookeeper 的 <strong>/dubbo/mapping目录</strong>下，存了这个信息后，消费者就能根据接口名找到所对应的应用名了。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306210239652.png" /></p><p>消费者知道了要使用的 Dubbo服务在哪个应用，那也就能从注册中心中根据应用名查到应用的所有实例信息（ip+port），也就是可以发送方法调用请求了，但是在真正发送请求之前，还得知道服务的配置信息，对于消费者而言，它得知道当前要调用的这个Dubbo服务支持什么协议、timeout是多少，<strong>那服务的配置信息从哪里获取呢？</strong></p><p>之前的服务配置信息是直接从注册中心就可以获取到的，就是服务 URL后面，但是现在不行了，现在需要从服务提供者的元数据服务获取，前面提到过，在应用启动过程中会进行服务导出和服务引入，然后就会暴露一个<strong>应用元数据服务</strong>，其实这个应用元数据服务就是一个Dubbo服务（Dubbo框架内置的，自己实现的），消费者可以调用这个服务来获取某个应用中所提供的所有Dubbo 服务以及服务配置信息，这样也就能知道服务的配置信息了。</p><h5 id="实现过程">实现过程</h5><p>首先，可以通过配置 <strong>dubbo.application.register-mode</strong>来控制：</p><ol type="1"><li>instance：表示只进行应用级注册</li><li>interface：表示只进行接口级注册</li><li>all：表示应用级注册和接口级注册都进行，默认</li></ol><p>不管是什么注册，都需要存数据到注册中心，而 Dubbo3的源码实现中会根据所配置的注册中心生成两个 URL（不是服务URL，可以理解为注册中心 URL，用来访问注册中心的）:</p><blockquote><ol type="1"><li>service-discovery-registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=order-application&amp;dubbo=2.0.2&amp;pid=13072&amp;qos.enable=false®istry=zookeeper×tamp=1651755501660</li><li>registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=order-application&amp;dubbo=2.0.2&amp;pid=13072&amp;qos.enable=false®istry=zookeeper×tamp=1651755501660</li></ol></blockquote><p>这两个 URL 只有 schema 不一样，一个是service-discovery-registry，一个是 registry，而 registry 是 Dubbo3之前就存在的，也就代表接口级服务注册，而 service-discovery-registry就表示应用级服务注册。</p><p>在服务注册相关的源码中，当调用 RegistryProtocol 的 export() 方法处理registry:// 时，会利用 ZookeeperRegistry 把服务 URL 注册到 Zookeeper中去，这就是接口级注册。</p><p>而类似，当调用 RegistryProtocol 的 export() 方法处理service-discovery-registry:// 时，会利用 ServiceDiscoveryRegistry来进行相关逻辑的处理，那是不是就是在这里把应用信息注册到注册中心去呢？并没有这么简单。</p><ol type="1"><li>首先，不可能每导出一个服务就进行一次应用注册，太浪费了，应用注册只要做一次就行了</li><li>另外，如果一个应用支持了多个端口，那么应用注册时只要挑选其中一个端口作为实例端口就可以了（该端口只要能接收到数据就行）</li><li>前面提到，应用启动过程中要暴露应用元数据服务，所以在此处也还是要收集当前所暴露的服务配置信息，以提供给应用元数据服务</li></ol><p>所以 ServiceDiscoveryRegistry 在注册一个服务 URL时，并不会往注册中心存数据，而只是把服务 URL 存到到一个 MetadataInfo对象中，MetadataInfo 对象中就保存了当前应用中所有的 Dubbo服务信息（服务名、支持的协议、绑定的端口、timeout 等）</p><p>前面提到过，在应用启动的最后，才会进行应用级注册，而应用级注册就是当前的应用实例上相关的信息存入注册中心，包括：</p><ol type="1"><li>应用的名字</li><li>获取应用元数据的方式</li><li>当前实例的 ip 和 port</li><li>当前实例支持哪些协议以及对应的 port</li></ol><p>例如：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306300014867.png" /></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;order-application&quot;</span>,<br><span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;192.168.110.140:50051&quot;</span>,<br><span class="hljs-attr">&quot;address&quot;</span>: <span class="hljs-string">&quot;192.168.110.140&quot;</span>,<br><span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">50051</span>,<br><span class="hljs-attr">&quot;sslPort&quot;</span>: <span class="hljs-literal">null</span>,<br><span class="hljs-attr">&quot;payload&quot;</span>: &#123;<br><span class="hljs-attr">&quot;@class&quot;</span>: <span class="hljs-string">&quot;org.apache.dubbo.registry.zookeeper.ZookeeperInstance&quot;</span>,<br><span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;192.168.110.140:50051&quot;</span>,<br><span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;order-application&quot;</span>,<br><span class="hljs-attr">&quot;metadata&quot;</span>: &#123;<br><span class="hljs-attr">&quot;dubbo.endpoints&quot;</span>: <span class="hljs-string">&quot;[&#123;\&quot;port\&quot;:50051,\&quot;protocol\&quot;:\&quot;tri\&quot;&#125;]&quot;</span>,<br><span class="hljs-attr">&quot;dubbo.metadata-service.url-params&quot;</span>: <span class="hljs-string">&quot;&#123;\&quot;connections\&quot;:\&quot;1\&quot;,\&quot;version\&quot;:\&quot;1.0.0\&quot;,\&quot;dubbo\&quot;:\&quot;2.0.2\&quot;,\&quot;release\&quot;:\&quot;3.1.9\&quot;,\&quot;side\&quot;:\&quot;provider\&quot;,\&quot;ipv6\&quot;:\&quot;2408:8270:1038:5f20:0:0:0:e7d9\&quot;,\&quot;port\&quot;:\&quot;50052\&quot;,\&quot;protocol\&quot;:\&quot;tri\&quot;&#125;&quot;</span>,<br><span class="hljs-attr">&quot;dubbo.metadata.revision&quot;</span>: <span class="hljs-string">&quot;0b944e47ab5cd306cd6ffa9ba20633b4&quot;</span>,<br><span class="hljs-attr">&quot;dubbo.metadata.storage-type&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,<br><span class="hljs-attr">&quot;ipv6&quot;</span>: <span class="hljs-string">&quot;2408:8270:1038:5f20:0:0:0:e7d9&quot;</span>,<br><span class="hljs-attr">&quot;timestamp&quot;</span>: <span class="hljs-string">&quot;1687276820990&quot;</span><br>&#125;<br>&#125;,<br><span class="hljs-attr">&quot;registrationTimeUTC&quot;</span>: <span class="hljs-number">1687276823174</span>,<br><span class="hljs-attr">&quot;serviceType&quot;</span>: <span class="hljs-string">&quot;DYNAMIC&quot;</span>,<br><span class="hljs-attr">&quot;uriSpec&quot;</span>: <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个实例上可能支持多个协议以及多个端口，<strong>那如何确定实例的 ip和端口呢？</strong></p><p>答案是：获取 MetadataInfo 对象中保存的所有服务URL，优先取 dubbo协议对应 ip 和 port，没有 dubbo 协议则所有服务 URL 中的第一个 URL 的 ip和 port。</p><p>另外一个协议一般只会对应一个端口，但是如果就是对应了多个，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dubbo:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">order-application</span><br>  <span class="hljs-attr">protocols:</span><br>    <span class="hljs-attr">p1:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">dubbo</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">20881</span><br>    <span class="hljs-attr">p2:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">dubbo</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">20882</span><br>    <span class="hljs-attr">p3:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">tri</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">50051</span><br></code></pre></td></tr></table></figure><p>如果是这样，最终存入 endpoint中的会保证一个协议只对应一个端口，另外那个将被忽略，最终服务消费者在进行服务引入时将会用到这个endpoint 信息。</p><p>确定好实例信息后之后，就进行最终的应用注册了，就把实例信息存入注册中心的<strong>/services/ 应用名目录</strong>下：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306292103819.png" /></p><p>可以看出 services 节点下存的是应用名，应用名的节点下存的是实例 ip和实例 port，而 ip 和 port 这个节点中的内容就是实例的一些基本信息。</p><p>另外，可以配置 dubbo.metadata.storage-type，默认是local，可以通过配置改为 remote：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dubbo:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">order-application</span><br>    <span class="hljs-attr">metadata-type:</span> <span class="hljs-string">remote</span><br></code></pre></td></tr></table></figure><p>这个配置其实跟应用元数据服务（MetadataService 服务，用于返回metadata）有关系：</p><ol type="1"><li>如果为local，那就会启用<strong>应用元数据服务</strong>，最终服务消费者就会调用元数据服务获取到应用元数据信息（接口注册的方式调用，将接口注册到注册中心）</li><li>如果为remote，那就不会暴露应用元数据服务，那么服务消费者从<strong>元数据中心</strong>获取应用元数据呢？</li></ol><p>在 Dubbo2.7中就有了元数据中心，它其实就是用来减轻注册中心的压力的，Dubbo会把服务信息完整的存一份到元数据中心，元数据中心也可以用 Zookeeper来实现，在暴露完元数据服务之后，在注册实例信息到注册中心之前，就会把MetadataInfo 存入元数据中心，比如：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306292122160.png" /></p><p>节点内容为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;app&quot;</span>: <span class="hljs-string">&quot;order-application&quot;</span>,<br><span class="hljs-attr">&quot;revision&quot;</span>: <span class="hljs-string">&quot;3ea21c46ac0131239cf39512bc691907&quot;</span>,<br><span class="hljs-attr">&quot;services&quot;</span>: &#123;<br><span class="hljs-attr">&quot;com.debuggingWorld.mall.service.OrderService:tri&quot;</span>: &#123;<br><span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;com.debuggingWorld.mall.service.OrderService&quot;</span>,<br><span class="hljs-attr">&quot;params&quot;</span>: &#123;<br><span class="hljs-attr">&quot;side&quot;</span>: <span class="hljs-string">&quot;provider&quot;</span>,<br><span class="hljs-attr">&quot;release&quot;</span>: <span class="hljs-string">&quot;3.1.9&quot;</span>,<br><span class="hljs-attr">&quot;methods&quot;</span>: <span class="hljs-string">&quot;getOrderByUserId&quot;</span>,<br><span class="hljs-attr">&quot;deprecated&quot;</span>: <span class="hljs-string">&quot;false&quot;</span>,<br><span class="hljs-attr">&quot;dubbo&quot;</span>: <span class="hljs-string">&quot;2.0.2&quot;</span>,<br><span class="hljs-attr">&quot;interface&quot;</span>: <span class="hljs-string">&quot;com.debuggingWorld.mall.service.OrderService&quot;</span>,<br><span class="hljs-attr">&quot;service-name-mapping&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>,<br><span class="hljs-attr">&quot;generic&quot;</span>: <span class="hljs-string">&quot;false&quot;</span>,<br><span class="hljs-attr">&quot;metadata-type&quot;</span>: <span class="hljs-string">&quot;remote&quot;</span>,<br><span class="hljs-attr">&quot;application&quot;</span>: <span class="hljs-string">&quot;order-application&quot;</span>,<br><span class="hljs-attr">&quot;background&quot;</span>: <span class="hljs-string">&quot;false&quot;</span>,<br><span class="hljs-attr">&quot;dynamic&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>,<br><span class="hljs-attr">&quot;anyhost&quot;</span>: <span class="hljs-string">&quot;true&quot;</span><br>&#125;,<br><span class="hljs-attr">&quot;path&quot;</span>: <span class="hljs-string">&quot;com.debuggingWorld.mall.service.OrderService&quot;</span>,<br><span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">50051</span>,<br><span class="hljs-attr">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;tri&quot;</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面就记录了当前实例上提供了哪些服务以及对应的协议，注意并没有保存对应的端口，所以后面服务消费者得利用实例信息中的endpoint，因为 endpoint中记录了协议对应的端口。</p><p>其实元数据中心和元数据服务提供的功能是一样的，都可以用来获取某个实例的MetadataInfo，上面中的 UUID表示实例编号，只不过元数据中心是<strong>集中</strong>式的，元数据服务式<strong>分散</strong>在各个提供者实例中的，如果整个微服务集群压力不大，那么效果差不多，如果微服务集群压力大，那么元数据中心的压力就大，此时单个元数据服务就更适合，所以默认也是采用的元数据服务。</p><p>注册中心和元数据中心也可以分别设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dubbo:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">order-application</span><br>    <span class="hljs-attr">metadata-type:</span> <span class="hljs-string">remote</span><br>    <span class="hljs-attr">register-mode:</span> <span class="hljs-string">instance</span><br>  <span class="hljs-attr">protocol:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">tri</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">address:</span> <span class="hljs-string">zookeeper://127.0.0.1:2181</span><br>  <span class="hljs-attr">metadata-report:</span><br>    <span class="hljs-attr">address:</span> <span class="hljs-string">zookeeper://127.0.0.1:2182</span><br></code></pre></td></tr></table></figure><p>至此，应用级服务注册的原理就分析完了，总结一下：</p><ol type="1"><li>在导出某个 Dubbo 服务URL时，会把服务 URL 存入 MetadataInfo 中</li><li>导出完某个 Dubbo服务后，就会把<strong>服务接口名:应用名</strong>存入元数据中心（可以用Zookeeper 实现）</li><li>导出所有服务后，完成服务引入后</li><li>判断要不要启动元数据服务，如果要就进行导出，固定使用 Dubbo 协议</li><li>将 MetadataInfo 存入元数据中心</li><li>确定当前实例信息（应用名、ip、port、endpoint）</li><li>将实例信息存入注册中心，完成应用注册</li></ol><p>应用注册查找过程：</p><p>OrderService ---&gt; mapping ---&gt; 应用名----&gt;实例1---&gt;实例ip+ port ---&gt; 实例元数据 ---&gt; endpoints ---&gt;OrderService:tri----&gt;tri协议端口 ---&gt; tri://示例端口：tri协议端口/OrderService---&gt; TripleInvoker</p><p>OrderService ---&gt; mapping ---&gt; 应用名----&gt;实例2---&gt;实例ip+ port ---&gt;实例元数据 ---&gt; endpoints ---&gt; OrderService:dubbo----&gt;dubbo协议端口 ---&gt;dubbo://示例端口：dubbo协议端口/OrderService ---&gt; DubboInvoker</p><p>ClusterInvoker ---&gt; OrderService 代理对象</p><p>ClusterInvoker .invoke(Invovation) ---&gt; TripleInvoker.invoke()---&gt; tri ---&gt; 实例ip：tri协议端口</p><h4 id="服务暴露">1.4 服务暴露</h4><p>服务暴露就是根据不同的协议启动不同的 Server，比如 dubbo 和 tri协议启动的都是 Netty，像 Dubbo2.7 中的 http 协议启动的就是Tomcat，这块在服务调用的时候再来分析。</p><p>1：10：00</p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo——Dubbo3.0新特性</title>
    <link href="/2023/06/01/Dubbo%E2%80%94%E2%80%94Dubbo3-0%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2023/06/01/Dubbo%E2%80%94%E2%80%94Dubbo3-0%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是-dubbo">1. 什么是 Dubbo</h3><p>Apache Dubbo 是一款 RPC服务开发框架，用于解决微服务架构下的服务治理与通信问题，官方提供了Java、Golang 等多语言 SDK 实现。使用 Dubbo开发的微服务原生具备相互之间的远程地址发现与通信能力， 利用 Dubbo提供的丰富服务治理特性，可以实现诸如服务发现、负载均衡、流量调度等服务治理诉求。Dubbo被设计为高度可扩展，用户可以方便的实现流量拦截、选址的各种定制逻辑</p><p>官网地址：http://dubbo.apache.org/zh/</p><h3 id="快速开始">2. 快速开始</h3><ol type="1"><li>添加 dubbo 核心依赖</li><li>添加要使用的注册中心依赖</li><li>添加要使用的协议的依赖</li><li>配置 dubbo 相关的基本信息</li><li>配置注册中心地址</li><li>配置所使用的协议</li></ol><h4 id="添加依赖">2.1 添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-rpc-dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-registry-nacos<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="公共服务">2.2 公共服务</h4><p>OrderService接口在服务提供者和服务调用方都使用到了，所以提取为公共服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderService</span> </span>&#123;<br>    <span class="hljs-function">ResponseEntity <span class="hljs-title">getOrderByUserId</span><span class="hljs-params">(Integer userId)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306012143825.png" /></p><h4 id="provider">2.3 provider</h4><ol type="1"><li><p><font color="red"><strong><span class="citation"data-cites="DubboService">@DubboService</span></strong></font>标注该类为 Dubbo Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DubboService</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">getOrderByUserId</span><span class="hljs-params">(Integer userId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><font color="red"><strong><span class="citation"data-cites="EnableDubbo">@EnableDubbo</span></strong> </font>开启Dubbo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDubbo(scanBasePackages = &quot;com.debuggingWorld.service&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(Application.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">dubbo.application.name</span>=<span class="hljs-string">order-application</span><br><span class="hljs-meta">dubbo.protocol.name</span>=<span class="hljs-string">dubbo</span><br><span class="hljs-meta">dubbo.protocol.port</span>=<span class="hljs-string">20880</span><br><span class="hljs-comment">#dubbo.registry.address=zookeeper://127.0.0.1:2181</span><br><span class="hljs-meta">dubbo.registry.address</span>=<span class="hljs-string">nacos://192.168.60.10:8848</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306012153165.png" /></p></li><li><p>兼容</p><p>但是在开发过程中，很有可能有其他多个应用在调用 provider 应用，对于provider 应用要做到，既要能支持 dubbo 协议调用，也要能支持 http 调用（和controller 效果一样），所以，要么仍然保留 SpringMVC那一套，如果不想保留那一套，就可以开启 dubbo 中的 rest 协议。</p><p><strong>添加依赖：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-rpc-rest<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>修改配置：</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">dubbo.application.name</span>=<span class="hljs-string">order-application</span><br><br><span class="hljs-meta">dubbo.protocols.p1.name</span>=<span class="hljs-string">dubbo</span><br><span class="hljs-meta">dubbo.protocols.p1.port</span>=<span class="hljs-string">20880</span><br><br><span class="hljs-meta">dubbo.protocols.p2.name</span>=<span class="hljs-string">rest</span><br><span class="hljs-meta">dubbo.protocols.p2.port</span>=<span class="hljs-string">8082</span><br><br><span class="hljs-meta">dubbo.registry.address</span>=<span class="hljs-string">nacos://192.168.60.10:8848</span><br></code></pre></td></tr></table></figure><p><strong>改造接口实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DubboService</span><br><span class="hljs-meta">@Path(&quot;/user&quot;)</span><br><span class="hljs-meta">@Produces</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@GET</span><br>    <span class="hljs-meta">@Path(&quot;/&#123;userId&#125;&quot;)</span><br>    <span class="hljs-meta">@Produces(MediaType.APPLICATION_JSON)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">getOrderByUserId</span><span class="hljs-params">(<span class="hljs-meta">@PathParam(&quot;userId&quot;)</span> Integer userId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试：</strong></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306012212007.png" /></p></li></ol><h4 id="consumer">2.4 consumer</h4><ol type="1"><li><p>引入服务</p><p>通过 <font color="red"><span class="citation"data-cites="DubboReference">@DubboReference</span> </font>注解来引入一个Dubbo 服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-meta">@DubboReference</span><br>    OrderService orderService;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">getUser</span><span class="hljs-params">(Integer userId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> orderService.getOrderByUserId(userId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8081</span><br><span class="hljs-meta">dubbo.application.name</span>=<span class="hljs-string">user-application</span><br><span class="hljs-meta">dubbo.registry.address</span> =<span class="hljs-string">nacos://192.168.60.10:8848</span><br></code></pre></td></tr></table></figure></li><li><p>开启 Dubbo</p><p>启动类添加 <span class="citation"data-cites="EnableDubbo">@EnableDubbo</span></p></li></ol><h3 id="dubbo3.0-新特性介绍">3. Dubbo3.0 新特性介绍</h3><h4 id="注册模型的改变">3.1 注册模型的改变</h4><p>　　在服务注册领域，有两种模型，一种是应用级注册，一种是接口级注册，在SpringCloud中，一个应用是一个微服务，而在 Dubbo2.7中，一个接口是一个微服务。</p><p>　　Spring Cloud 在进行服务注册时，是把应用名以及应用所在服务器的 IP地址和应用所绑定的端口注册到注册中心，相当于 key 是应用名，value 是ip+port，而在 Dubbo2.7 中，是把接口名以及对应应用的 IP地址和所绑定的端口注册到注册中心，相当于 key 是接口名，value 是ip+port。所以在 Dubbo2.7 中，一个应用如果提供了 10 个 Dubbo服务，那么注册中心中就会存储 10 对 keyvalue，而 Spring Cloud就只会存一对 keyvalue，所以以 Spring Cloud为首的应用级注册是更加适合的。</p><p>　　所以 Dubbo3.0中将注册模型也改为了应用级注册，提升效率节省资源的同时，通过统一注册模型，也为各个微服务框架的互通打下了基础。</p><h4 id="triple-协议">3.2 Triple 协议</h4><ol type="1"><li>HTTP1.x协议中，多余无用的字符太多了，比如回车符、换行符，这些字符占用了网络带宽，降低了网络IO 的效率。</li><li>HTTP1.x 协议中，一条 Socket 连接，一次只能发送一个 HTTP请求，因为如果连续发送两个 HTTP请求，然后收到了一个响应，那怎么知道这个响应对应的是哪个请求呢，这样导致Socket 连接的利用低，并发、吞吐量低。</li></ol><p>　　dubbo 协议相比于 http1.x协议，性能会更好，因为请求中没有多余的无用的字节，都是必要的字节，并且每个Dubbo 请求和响应中都有一个请求 ID，这样可以基于一个 Socket连接同时发送多个 Dubbo 请求，不用担心请求和响应对不上，所以 dubbo协议成为了 Dubbo 框架中的默认协议。</p><p>dubbo 协议格式：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306020027164.png" /></p><p>　　但是 dubbo 协议一旦涉及到跨 RPC 框架，比如一个 Dubbo 服务要调用gPRC 服务，就比较麻烦了，因为发一个 dubbo 协议的请求给一个 gPRC服务，gPRC 服务只会按照 gRPC的格式来解析字节流，最终肯定会解析不成功的。dubbo协议虽好，但是不够通用，所以这就出现了 Triple 协议。</p><p>　　Triple 协议是基于 HTTP2，没有性能问题，另外 HTTP协议非常通用，全世界都认它，兼容起来也比较简单，而且还有很多额外的功能，比如流式调用。</p><p>triple、dubbo、rest 协议对比：</p><ul><li>triple 协议基于的是 HTTP2，rest 协议目前基于的是HTTP1，都可以做到跨语言。</li><li>triple 协议兼容了 gPRC（Triple 服务可以直接调用 gRPC服务，反过来也可以），rest 协议不行</li><li>triple 协议支持流式调用，rest 协议不行</li><li>rest 协议更方便浏览器、客户端直接调用，triple协议不行（原理上支持，当得对 triple协议的底层实现比较熟悉才行，得知道具体的请求头、请求体是怎么生成的）</li><li>dubbo 协议是 Dubbo3.0 之前的默认协议，triple 协议是 Dubbo3.0之后的默认协议，优先用 Triple 协议</li><li>dubbo 协议不是基于的 HTTP，不够通用，triple 协议底层基于 HTTP所以更通用（比如跨语言、跨异构系统实现起来比较方便）</li><li>dubbo 协议不支持流式调用</li></ul><p><strong>Triple 协议的使用：</strong></p><ol type="1"><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-rpc-triple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>修改配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">dubbo.protocol.name</span>=<span class="hljs-string">tri</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="triple-协议的流式调用">3.3 Triple 协议的流式调用</h4><p>StreamObserver 在 dubbo-common 模块下，所以添加 dubbo-common依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>公共服务中的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloService</span> </span>&#123;<br>    <span class="hljs-comment">// UNARY</span><br>    <span class="hljs-function">String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>;<br><br>    <span class="hljs-comment">// SERVER_STREAM</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHelloServerStream</span><span class="hljs-params">(String name, StreamObserver&lt;String&gt; response)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">// CLIENT_STREAM / BI_STREAM</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> StreamObserver&lt;String&gt; <span class="hljs-title">sayHelloStream</span><span class="hljs-params">(StreamObserver&lt;String&gt; response)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="unary">1. UNARY</h5><p>就是正常的调用方法</p><p>服务实现类对应的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello &quot;</span> + name;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务消费者调用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String result = helloService.sayHello(<span class="hljs-string">&quot;debuggingWorld&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="server_stream">2. SERVER_STREAM</h5><p>服务实现类对应的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHelloServerStream</span><span class="hljs-params">(String name, StreamObserver&lt;String&gt; response)</span> </span>&#123;<br>    response.onNext(<span class="hljs-string">&quot;hello:&quot;</span> + name);<br>    response.onNext(<span class="hljs-string">&quot;bye:&quot;</span> + name);<br>    response.onCompleted();<br>&#125;<br></code></pre></td></tr></table></figure><p>服务消费者调用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">helloService.sayHelloServerStream(<span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-keyword">new</span> StreamObserver&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String data)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;收到结果：&quot;</span>+data);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;接收结束&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="client_stream">3. CLIENT_STREAM</h5><p>也叫双端流</p><p>服务实现类对应的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> StreamObserver&lt;String&gt; <span class="hljs-title">sayHelloStream</span><span class="hljs-params">(StreamObserver&lt;String&gt; response)</span> </span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StreamObserver&lt;String&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String data)</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;服务端接收：&quot;</span>+data);<br>            <span class="hljs-comment">// 服务端响应</span><br>            response.onNext(<span class="hljs-string">&quot;hello &quot;</span>+ data);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;服务端接收结束&quot;</span>);<br>            response.onCompleted();<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务消费者调用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">StreamObserver&lt;String&gt; streamObserver = helloService.sayHelloStream(<span class="hljs-keyword">new</span> StreamObserver&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String data)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;客户端收到：&quot;</span>+data);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;客户端接收结束&quot;</span>);<br><br>    &#125;<br>&#125;);<br>streamObserver.onNext(<span class="hljs-string">&quot;debugging&quot;</span>);<br>streamObserver.onNext(<span class="hljs-string">&quot;world&quot;</span>);<br>streamObserver.onCompleted();<br></code></pre></td></tr></table></figure><p>测试：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306020224620.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306020238672.png" /></p><h5 id="bi_stream">4 BI_STREAM</h5><p>和 CLIENT_STREAM 一样</p><h3 id="dubbo3.0-跨语言调用">4. Dubbo3.0 跨语言调用</h3><p>Dubbo 一开始是用 Java 语言实现的，那现在就需要一个 go 语言实现的Dubbo 框架，也就是现在的 dubbo-go，然后在 go 项目中引入dubbo-go，从而可以在 go 项目中使用 dubbo，比如使用 go 语言去暴露和使用Dubbo 服务。</p><p>在使用 Java 语言开发一个 Dubbo服务时，会把服务接口和相关类，单独抽象成为一个 Maven项目，实际上就相当于一个单独的 jar 包，这个 jar 能被 Java项目所使用，但不能被 go 项目所使用，所以 go 项目中该如何使用 Java语言所定义的接口呢？直接用是不太可能的，只能通过间接的方式来解决这个问题，除开Java 语言之外，那有没有其他技术也能定义接口呢？并且该技术也是 Java 和 go都支持，这就是 protobuf。</p><h4 id="protobuf">4.1 protobuf</h4><p>我们可以通过 protobuf 来定义接口，然后通过 protobuf的编译器将接口编译为特定语言的实现。</p><p>在 provider 项目中定义一个 orderservice.proto 文件，路径为src/main/proto/userservorderservicece.proto</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">package</span> api;<br><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;./;api&quot;</span>;<br><span class="hljs-keyword">option</span> java_multiple_files = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">option</span> java_package = <span class="hljs-string">&quot;com.debuggingWorld&quot;</span>;<br><span class="hljs-keyword">option</span> java_outer_classname = <span class="hljs-string">&quot;OrderServiceProto&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">OrderService</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> GetOrderByUserId (OrderRequest ) <span class="hljs-keyword">returns</span> (OrderResponse) </span>&#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">OrderRequest</span> </span>&#123;<br>  <span class="hljs-built_in">string</span> userId = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">OrderResponse</span> </span>&#123;<br>  <span class="hljs-built_in">int32</span> code = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">string</span> msg = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义 OrderService 服务，并且定义了一个 GetOrderByUserId 方法，接收OrderRequest 类型的参数，返回 OrderResponse 类型的对象。</p><h4 id="编译成-java">4.2 编译成 Java</h4><p>在 provider 项目中的 pom 文件中添加相关 maven 插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">extension</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>kr.motd.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>os-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">extension</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">extensions</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.7.1:exe:$&#123;os.detected.classifier&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">protocArtifact</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>&gt;</span>build/generated/source/proto/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">outputDirectory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">clearOutputDirectory</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">clearOutputDirectory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">protocPlugins</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">protocPlugin</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-compiler<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>org.apache.dubbo.gen.dubbo.Dubbo3Generator<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">protocPlugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">protocPlugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>test-compile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>build-helper-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>generate-sources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>add-source<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">sources</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>build/generated/source/proto/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">sources</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>并且把 common 依赖去掉，然后运行 provider 中 lifecycle 的compile，就会进行编译了。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306132230080.png" /></p><p>其中就包括了一个 OrderService 接口，所以我们的 OrderServiceImpl就可以实现这个接口了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DubboService</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OrderResponse <span class="hljs-title">getOrderByUserId</span><span class="hljs-params">(OrderRequest request)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> OrderResponse.newBuilder().setCode(<span class="hljs-number">1</span>).setMsg(<span class="hljs-string">&quot;success&quot;</span>).build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="go-消费者调用-java-服务">4.3 go 消费者调用 java 服务</h4><p>首先，新建一个 go 模块，然后把 orderservice.proto 复制到go-consumer/proto下，然后进行编译，编译成为 go语言对应的服务代码，只不过 go 语言中没有 maven可以帮助我们编译，只能用原生的 protobuf 的编译器进行编译。</p><p>下载、安装 protobuf的编译器：protoc</p><ol type="1"><li>下载地址：https://github.com/protocolbuffers/protobuf/releases/download/v3.20.1/protoc-3.20.1-win64.zip</li><li>解压之后，把 protoc-3.20.1-win64添加到环境变量中</li><li>在 cmd 中执行 protoc --version，能正常看到版本号即表示安装成功</li></ol><p>然后在 go-consumer 下新建文件夹 api，进入到go-consumer/proto下，运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">go env -w GO111MODULE=on<br>go env -w GOPROXY=https://goproxy.cn,direct<br><br>go get -u github.com/dubbogo/tools/cmd/protoc-gen-go-triple<br>go install github.com/golang/protobuf/protoc-gen-go<br>go install github.com/dubbogo/tools/cmd/protoc-gen-go-triple<br><br>protoc -I. orderservice.proto  --go_out=../api --go-triple_out=../api<br></code></pre></td></tr></table></figure><p>这样就会在 go-consumer/api 下生成一个 orderservice.pb.go 文件和orderservice_triple.pb.go 文件。</p><p>然后就可以写 go 语言的服务消费者了，新建一个 consumer.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;context&quot;</span><br>   <span class="hljs-string">&quot;dubbo.apache.org/dubbo-go/v3/common/logger&quot;</span><br>   <span class="hljs-string">&quot;dubbo.apache.org/dubbo-go/v3/config&quot;</span><br>   _ <span class="hljs-string">&quot;dubbo.apache.org/dubbo-go/v3/imports&quot;</span><br>   <span class="hljs-string">&quot;go-consumer/api&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> userServiceImpl = <span class="hljs-built_in">new</span>(api.OrderServiceClientImpl)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   config.SetConsumerService(userServiceImpl)<br>   config.Load()<br><br>   logger.Info(<span class="hljs-string">&quot;start to test dubbo&quot;</span>)<br>   req := &amp;api.OrderRequest&#123;<br>      UserId: <span class="hljs-string">&quot;1&quot;</span>,<br>   &#125;<br><br>   order, err := userServiceImpl.GetOrderByUserId(context.Background(), req)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      logger.Error(err)<br>   &#125;<br>   logger.Infof(<span class="hljs-string">&quot;client response result: %v\n&quot;</span>, order)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在 go-consumer 下新建 conf/dubbogo.yml，用来配置注册中心：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dubbo:</span><br>  <span class="hljs-attr">registries:</span><br>    <span class="hljs-attr">demoZK:</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">address:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.60</span><span class="hljs-number">.10</span><span class="hljs-string">:8848</span><br>  <span class="hljs-attr">consumer:</span><br>    <span class="hljs-attr">references:</span><br>      <span class="hljs-attr">OrderServiceClientImpl:</span><br>        <span class="hljs-attr">protocol:</span> <span class="hljs-string">tri</span><br>        <span class="hljs-attr">interface:</span> <span class="hljs-string">com.debuggingWorld.OrderService</span><br></code></pre></td></tr></table></figure><p>在 environment 中添加一个参数：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306140029900.png" /></p><p>运行测试：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306140030133.png" /></p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-Cloud-Alibaba——微服务调用Feign&amp;Dubbo</title>
    <link href="/2023/05/16/Spring-Cloud-Alibaba%E2%80%94%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8Feign-Dubbo/"/>
    <url>/2023/05/16/Spring-Cloud-Alibaba%E2%80%94%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8Feign-Dubbo/</url>
    
    <content type="html"><![CDATA[<h3 id="rpc-概述">1. RPC 概述</h3><p>RPC 全称是 Remote Procedure Call，即远程过程调用，与其对应的是本地调用。RPC的目的是：让调用远程方法像调用本地方法一样。</p><p><strong>RPC框架架构：</strong></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305160141779.png" /></p><h3 id="spring-cloud-整合-feign">2. Spring Cloud 整合 Feign</h3><p>Feign 是 Netflix 开发的声明式、模板化的 HTTP 客户端，Feign可帮助我们更加便捷、优雅地调用 HTTP API。</p><p>Feign 可以做到使用 HTTP请求远程服务时就像调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个HTTP 请求。它像 Dubbo 一样，consumer 直接调用接口方法调用provider，而不需要通过常规的 Http Client构造请求再解析返回数据。它解决了让开发者调用远程接口就跟调用本地方法一样，无需关注与远程的交互细节，更无需关注分布式环境开发。</p><p>Spring Cloud openfeign 对 Feign 进行了增强，使其支持 Spring MVC注解，另外还整合了Ribbon 和 Eureka，从而使得 Feign 的使用更加方便。</p><p><ahref="https://blog.csdn.net/qq_41573234/article/details/106663378">Feign和 OpenFeign 的区别</a></p><h4 id="feign-的设计架构">2.1 Feign 的设计架构</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305160147082.png" /></p><h4 id="spring-cloud-alibaba-快速整合-feign">2.2 Spring Cloud Alibaba快速整合 Feign</h4><ol type="1"><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- openfeign 远程调用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>【注】：openfeign 使用 Ribbon 作为负载均衡。</p></li><li><p>编写调用接口 + <span class="citation"data-cites="FeignClient">@FeignClient</span> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;mall-order&quot;, path = &quot;/order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderFeignService</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/findOrderByUserId/&#123;userId&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">findOrderByUserId</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;userId&quot;)</span> Integer userId)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>发起调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> OrderFeignService orderFeignService;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserController</span><span class="hljs-params">(OrderFeignService orderFeignService)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.orderFeignService = orderFeignService;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/getOrderByUserId/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">findOrderByUserId</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> orderFeignService.findOrderByUserId(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>启动类上添加 <span class="citation"data-cites="EnableFeignClients">@EnableFeignClients</span> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MallUserApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(MallUserApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="spring-cloud-feign-扩展">2.3 Spring Cloud Feign 扩展</h4><p>Feign 提供了很多的扩展机制，让用户可以更加灵活的使用。</p><h5 id="日志配置">1. 日志配置</h5><p>有时候我们遇到Bug，比如接口调用失败、参数没收到等问题，或者想看看调用性能，就需要配置Feign 的日志了，以此让 Feign 把请求信息输出来。</p><ol type="1"><li><p>全局配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> feign.Logger;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Logger.<span class="hljs-function">Level <span class="hljs-title">feignLoggerLevel</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Logger.Level.FULL;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305242331203.png" /></p><ul><li><strong>NONE</strong>【性能最佳，适用于生产】：不记录任何日志（默认值）。</li><li><strong>BASIC</strong>【适用于生产环境追踪问题】：仅记录请求方法、URL、响应状态代码以及执行时间。</li><li><strong>HEADERS</strong>：记录BASIC级别的基础上，记录请求和响应的header。</li><li><strong>FULL</strong>【比较适用于开发及测试环境定位问题】：记录请求和响应的header、body和元数据。</li></ul></li><li><p>局部配置</p><p>让调用的微服务生效</p><p><strong>方法一：</strong></p><p>在 <span class="citation"data-cites="FeignClient">@FeignClient</span> 注解中指定使用的配置类</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305242322235.png" /></p><p>【注】此时 FeignConfig 不能添加 <span class="citation"data-cites="Configuration">@Configuration</span></p><p><strong>方法二：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">mall-order:</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span><br></code></pre></td></tr></table></figure></li></ol><p>【注】在配置文件中配置 FeignClient 的日志级别才能正常输出日志。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.debuggingWorld.user.service:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h5 id="契约配置">2. 契约配置</h5><p>Spring Cloud 在 Feign 的基础上做了扩展，可以让 Feign 支持 Spring MVC的注解来调用。原生的 Feign 是不支持 Spring MVC 注解的，如果你想在 SpringCloud中使用原生的注解方式来定义客户端也是可以的，通过配置契约来改变这个配置，SpringCloud 中默认的是 SpringMvcContract。</p><ol type="1"><li><p>修改契约配置，支持 Feign 原生的注解</p><p><strong>全局配置：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Contract <span class="hljs-title">feignContract</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Contract.Default();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>局部配置：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">mall-order:</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span><br>        <span class="hljs-attr">contract:</span> <span class="hljs-string">feign.Contract.Default</span>   <span class="hljs-comment">#指定Feign原生注解契约配置</span><br></code></pre></td></tr></table></figure></li><li><p>使用 Feign 原生的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;mall-order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderFeignService</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@RequestLine(&quot;POST /order/findOrderByUserId/&#123;userId&#125;&quot;)</span><br>    <span class="hljs-function">ResponseEntity <span class="hljs-title">findOrderByUserId</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;userId&quot;)</span> Integer userId)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>【注】注意是 <span class="citation"data-cites="Param">@Param</span></p></li></ol><h5 id="通过拦截器实现参数传递">3. 通过拦截器实现参数传递</h5><p>通常我们调用的接口都是有权限控制的，很多时候可能认证的值是通过参数去传递的，还有就是通过请求头去传递认证信息，比如Basic 认证方式。<br />Feign 可以直接配置 Basic 认证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BasicAuthRequestInterceptor <span class="hljs-title">basicAuthRequestInterceptor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicAuthRequestInterceptor(<span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305282109435.png" /></p><p><strong>扩展点： feign.RequestInterceptor </strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RequestInterceptor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(RequestTemplate template)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicAuthRequestInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RequestInterceptor</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用场景：</strong></p><ol type="1"><li>统一添加 header 信息</li><li>对 body 中的信息做修改或替换</li></ol><p><strong>自定义拦截器实现认证逻辑：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignAuthRequestInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RequestInterceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(RequestTemplate requestTemplate)</span> </span>&#123;<br>        <span class="hljs-comment">// 业务逻辑</span><br>        String access_token = UUID.randomUUID().toString();<br>        requestTemplate.header(<span class="hljs-string">&quot;Authorization&quot;</span>,access_token);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FeignAuthRequestInterceptor <span class="hljs-title">feignAuthRequestInterceptor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FeignAuthRequestInterceptor();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可以在 yml 中配置：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">mall-order:</span><br>        <span class="hljs-string">requestInterceptors[0]:</span><br>          <span class="hljs-string">com.debuggingWorld.user.config.FeignAuthRequestInterceptor</span><br></code></pre></td></tr></table></figure><p>mall-order 端可以通过 <span class="citation"data-cites="RequestHeader">@RequestHeader</span> 获取请求参数，建议在filter,interceptor 中处理。</p><h5 id="超时时间配置">4. 超时时间配置</h5><p>通过 Options 可以配置连接超时时间和读取超时时间，Options的第一个参数是连接的超时时间（ms），默认值是2s；第二个是请求处理的超时时间（ms），默认值是 5s。</p><p><strong>全局配置：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Request.<span class="hljs-function">Options <span class="hljs-title">options</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Request.Options(<span class="hljs-number">5000</span>, <span class="hljs-number">4000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>局部配置：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">mall-order:</span><br>        <span class="hljs-attr">connectTimeout:</span> <span class="hljs-number">5000</span><br>        <span class="hljs-attr">readTimeout:</span> <span class="hljs-number">4000</span><br></code></pre></td></tr></table></figure><p>【注】Feign 的底层用的是 Ribbon，但超时时间以 Feign 配置为准。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305282248343.png" /></p><h5 id="客户端组件配置">5. 客户端组件配置</h5><p>Feign 中默认使用 JDK 原生的 URLConnection 发送 HTTP请求，我们可以集成别的组件来替换掉 URLConnection，比如 ApacheHttpClient，OkHttp。 Feign发起调用真正执行逻辑：<strong>feign.Client#execute（扩展点）</strong></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305282324338.png" /></p><p><strong>配置 Apache HttpClient</strong></p><ol type="1"><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>10.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在 yml 配置中启用 Feign 的 Apache HttpClient</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">httpclient:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol><p>关于配置可参考源码：org.springframework.cloud.openfeign.FeignAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnClass(ApacheHttpClient.class)</span><br><span class="hljs-meta">@ConditionalOnMissingClass(&quot;com.netflix.loadbalancer.ILoadBalancer&quot;)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(CloseableHttpClient.class)</span><br><span class="hljs-meta">@ConditionalOnProperty(value = &quot;feign.httpclient.enabled&quot;, matchIfMissing = true)</span><br><span class="hljs-meta">@Conditional(HttpClient5DisabledConditions.class)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpClientFeignConfiguration</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>配置 OkHttp</strong></p><ol type="1"><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-okhttp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在 yml 配置中禁用 Feign 的 HttpClient ，启用 OkHttp</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">httpclient:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">okhttp:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol><p>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnClass(OkHttpClient.class)</span><br><span class="hljs-meta">@ConditionalOnMissingClass(&quot;com.netflix.loadbalancer.ILoadBalancer&quot;)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(okhttp3.OkHttpClient.class)</span><br><span class="hljs-meta">@ConditionalOnProperty(&quot;feign.okhttp.enabled&quot;)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OkHttpFeignConfiguration</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="gzip-压缩配置">6. GZIP 压缩配置</h5><p>开启压缩可以有效节约网络资源，提升接口性能，我们可以配置 GZIP来压缩数据：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">compression:</span><br>    <span class="hljs-attr">request:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment"># 配置压缩的类型</span><br>      <span class="hljs-attr">mime-types:</span> <span class="hljs-string">text/xml,application/xml,application/json</span><br>      <span class="hljs-comment"># 最小压缩值</span><br>      <span class="hljs-attr">min-request-size:</span> <span class="hljs-number">2048</span><br>    <span class="hljs-attr">response:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305290137530.png" /></p><p>【注】<strong>只有当 Feign 的 Http Client 不是 okhttp3的时候</strong>，压缩才会生效，配置源码在FeignAcceptGzipEncodingAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@EnableConfigurationProperties(FeignClientEncodingProperties.class)</span><br><span class="hljs-meta">@ConditionalOnClass(Feign.class)</span><br><span class="hljs-meta">@ConditionalOnBean(Client.class)</span><br><span class="hljs-meta">@ConditionalOnProperty(value = &quot;feign.compression.response.enabled&quot;,</span><br><span class="hljs-meta">      matchIfMissing = false)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(type = &quot;okhttp3.OkHttpClient&quot;)</span><br><span class="hljs-meta">@AutoConfigureAfter(FeignAutoConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignAcceptGzipEncodingAutoConfiguration</span> </span>&#123;<br><br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> FeignAcceptGzipEncodingInterceptor <span class="hljs-title">feignAcceptGzipEncodingInterceptor</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">         FeignClientEncodingProperties properties)</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FeignAcceptGzipEncodingInterceptor(properties);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="编码器解码器配置">7. 编码器解码器配置</h5><p>Feign中提供了自定义的编码解码器设置，同时也提供了多种编码器的实现，比如Gson、Jaxb、Jackson。我们可以用不同的编码解码器来处理数据的传输。如果你想传输XML 格式的数据，可以自定义 XML 编码解码器来实现获取使用官方提供的Jaxb。</p><p>扩展点：Encoder &amp; Decoder</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Decoder</span> </span>&#123;<br>  <span class="hljs-function">Object <span class="hljs-title">decode</span><span class="hljs-params">(Response response, Type type)</span> <span class="hljs-keyword">throws</span> IOException, DecodeException, FeignException</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Encoder</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(Object object, Type bodyType, RequestTemplate template)</span> <span class="hljs-keyword">throws</span> EncodeException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Java配置方式：</strong></p><p>配置编码解码器只需要在 Feign 的配置类中注册 Decoder 和 Encoder这两个类即可:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Decoder <span class="hljs-title">decoder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JacksonDecoder();<br>&#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Encoder <span class="hljs-title">encoder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JacksonEncoder();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>yml配置方式：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">mall-order:</span><br>        <span class="hljs-comment"># 配置编解码器</span><br>        <span class="hljs-attr">encoder:</span> <span class="hljs-string">feign.jackson.JacksonEncoder</span><br>        <span class="hljs-attr">decoder:</span> <span class="hljs-string">feign.jackson.JacksonDecoder</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud Alibaba</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
      <tag>Spring Cloud Alibaba</tag>
      
      <tag>Feign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Alibaba——负载均衡器Ribbon&amp;LoadBalancer</title>
    <link href="/2023/05/14/Spring-Cloud-Alibaba%E2%80%94%E2%80%94%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8Ribbon-LoadBalancer/"/>
    <url>/2023/05/14/Spring-Cloud-Alibaba%E2%80%94%E2%80%94%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8Ribbon-LoadBalancer/</url>
    
    <content type="html"><![CDATA[<h3 id="负载均衡">1. 负载均衡</h3><p>负载均衡（LoadBalance），其含义就是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如FTP 服务器、Web服务器、企业核心应用服务器和其它主要任务服务器等，从而协同完成工作任务。</p><p>目前主流的负载均衡方案分为以下两种：</p><ul><li>集中式负载均衡，在消费者和服务提供方中间使用独立的代理方式进行负载，有硬件的（比如F5），也有软件的（比如 Nginx）。</li><li>客户端根据自己的请求情况做负载均衡，Ribbon就属于客户端自己做负载均衡。</li></ul><h4 id="客户端的负载均衡">1.1 客户端的负载均衡</h4><p>例如 spring cloud 中的ribbon，客户端会有一个服务器地址列表，在发送请求前通过负载均衡算法选择一个服务器，然后进行访问，这是客户端负载均衡；即在客户端就进行负载均衡算法分配。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305141316164.png" /></p><h4 id="服务端的负载均衡">1.2 服务端的负载均衡</h4><p>例如 Nginx，通过 Nginx进行负载均衡，先发送请求，然后通过负载均衡算法在多个服务器之间选择一个进行访问。即在服务器端再进行负载均衡算法分配。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305141318624.png" /></p><h4 id="常见负载均衡算法">1.3 常见负载均衡算法</h4><ul><li>随机：通过随机选择服务进行执行，一般这种方式使用较少;</li><li>轮训：负载均衡默认实现方式，请求来之后排队处理;</li><li>加权轮训：通过对服务器性能的分型，给高配置，低负载的服务器分配更高的权重，均衡各个服务器的压力;</li><li>地址 hash：通过客户端请求的地址的hash值取模映射进行服务器调度。</li><li>最小连接数：即使请求均衡了，压力不一定会均衡，最小连接数法就是根据服务器的情况，比如请求积压数等参数，将请求分配到当前压力最小的服务器上。</li></ul><h3 id="什么是-ribbon">2. 什么是 Ribbon</h3><p>Spring Cloud Ribbon 是基于 Netflix Ribbon实现的一套客户端的负载均衡工具，Ribbon客户端组件提供一系列的完善的配置，如超时，重试等。通过 Load Balancer获取到服务提供的所有机器实例，Ribbon会自动基于某种规则（轮询，随机）去调用这些服务。Ribbon也可以实现我们自己的负载均衡算法。</p><h4 id="spring-cloud-alibaba-整合-ribbon-快速开始">2.1 Spring CloudAlibaba 整合 Ribbon 快速开始</h4><ol type="1"><li><p>引入 ribbon 依赖</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--添加ribbon的依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p>【注】nacos-discovery 依赖了 ribbon，可以不用再引入 ribbon 依赖</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305141339692.png" /></p></li><li><p>RestTemplate 添加 <span class="citation"data-cites="LoadBalanced">@LoadBalanced</span> 注解，让 RestTemplate在请求时拥有客户端负载均衡的能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span>  <span class="hljs-comment">//开启负载均衡</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试，使用微服务名发起调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br><span class="hljs-meta">@RequestMapping(value = &quot;/getOrderByUserId/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">findOrderByUserId</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;<br>    String url = <span class="hljs-string">&quot;http://mall-order/order/findOrderByUserId/&quot;</span>+id;<br>    <span class="hljs-keyword">return</span> restTemplate.getForObject(url,ResponseEntity.class);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="ribbon-内核原理">2.2 Ribbon 内核原理</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305141346021.png" /></p><p><strong><span class="citation"data-cites="LoadBalanced">@LoadBalanced</span> 注解原理：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Qualifier</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> LoadBalanced &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>LoadBalancerAutoConfiguration 中拿到加了 <span class="citation"data-cites="LoadBalanced">@LoadBalanced</span> 的 RestTemplate。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadBalancerAutoConfiguration</span> </span>&#123;<br><br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-meta">@Autowired(required = false)</span><br><span class="hljs-keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SmartInitializingSingleton <span class="hljs-title">loadBalancedRestTemplateInitializerDeprecated</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">final</span> ObjectProvider&lt;List&lt;RestTemplateCustomizer&gt;&gt; restTemplateCustomizers)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SmartInitializingSingleton() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterSingletonsInstantiated</span><span class="hljs-params">()</span> </span>&#123;<br>                restTemplateCustomizers.ifAvailable((List&lt;RestTemplateCustomizer&gt; customizers) -&gt; &#123;<br>                    <span class="hljs-keyword">for</span> (RestTemplate restTemplate : LoadBalancerAutoConfiguration.<span class="hljs-keyword">this</span>.restTemplates) &#123;<br>                        <span class="hljs-keyword">for</span> (RestTemplateCustomizer customizer : customizers) &#123;<br>                            customizer.customize(restTemplate);<br>                        &#125;<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>被 <span class="citation"data-cites="LoadBalanced">@LoadBalanced</span> 注解的 restTemplate会被定制，添加 LoadBalancerInterceptor 拦截器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadBalancerInterceptorConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplateCustomizer <span class="hljs-title">restTemplateCustomizer</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplateCustomizer() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(RestTemplate restTemplate)</span> </span>&#123;<br>                List&lt;ClientHttpRequestInterceptor&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<br>                        restTemplate.getInterceptors());<br>                list.add(loadBalancerInterceptor);<br>                restTemplate.setInterceptors(list);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>LoadBalancerInterceptor 会获取 LoadBalancerClient，而RibbonLoadBalancerClient 是其实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadBalancerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ClientHttpRequestInterceptor</span> </span>&#123;<br><br>   <span class="hljs-keyword">private</span> LoadBalancerClient loadBalancer;<br>   <span class="hljs-keyword">private</span> LoadBalancerRequestFactory requestFactory;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoadBalancerInterceptor</span><span class="hljs-params">(LoadBalancerClient loadBalancer,</span></span><br><span class="hljs-params"><span class="hljs-function">         LoadBalancerRequestFactory requestFactory)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.loadBalancer = loadBalancer;<br>      <span class="hljs-keyword">this</span>.requestFactory = requestFactory;<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> ClientHttpResponse <span class="hljs-title">intercept</span><span class="hljs-params">(<span class="hljs-keyword">final</span> HttpRequest request, <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] body,</span></span><br><span class="hljs-params"><span class="hljs-function">         <span class="hljs-keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>      <span class="hljs-keyword">final</span> URI originalUri = request.getURI();<br>      String serviceName = originalUri.getHost();<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.loadBalancer.execute(serviceName,<br>            <span class="hljs-keyword">this</span>.requestFactory.createRequest(request, body, execution));<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RibbonLoadBalancerClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LoadBalancerClient</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red"> 注意： SmartInitializingSingleton 是在所有的 bean都实例化完成之后才会调用的，所以在 bean 的实例化期间使用 <spanclass="citation" data-cites="LoadBalanced">@LoadBalanced</span> 修饰的restTemplate 是不具备负载均衡作用的。</font></p><p>如果不使用 <span class="citation"data-cites="LoadBalanced">@LoadBalanced</span> 注解，也可以通过添加LoadBalancerInterceptor 拦截器让 restTemplate 起到负载均衡器的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">(LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;<br>    RestTemplate restTemplate = <span class="hljs-keyword">new</span> RestTemplate();<br>    <span class="hljs-comment">//注入loadBalancerInterceptor 拦截器</span><br>    restTemplate.setInterceptors(Collections.singletonList(loadBalancerInterceptor));<br>    <span class="hljs-keyword">return</span> restTemplate;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="ribbon-扩展功能">2.3 Ribbon 扩展功能</h4><h5 id="ribbon-相关接口">1. Ribbon 相关接口</h5><p>参考：org.springframework.cloud.netflix.ribbon.<strong>RibbonClientConfiguration</strong></p><p><font color="red"><strong>IRule</strong></font>：Ribbon的负载均衡策略，默认采用 <strong>ZoneAvoidanceRule</strong>实现，该策略能够在多区域环境下选出最佳区域的实例进行访问。</p><p><font color="red"><strong>ILoadBalancer</strong></font>：负载均衡器，默认采用<strong>ZoneAwareLoadBalancer</strong>实现，它具备了区域感知的能力。</p><p><strong>IClientConfig</strong>：Ribbon 的客户端配置，默认采用<strong>DefaultClientConfigImpl</strong> 实现。</p><p><strong>IPing</strong>：Ribbon 的实例检查策略，默认采用<strong>DummyPing</strong>实现，该检查策略是一个特殊的实现，实际上它并不会检查实例是否可用，而是始终返回true，默认认为所有服务实例都是可用的。</p><p><strong>ServerList</strong>：服务实例清单的维护机制，默认采用<strong>ConfigurationBasedServerList</strong> 实现。</p><p><strong>ServerListFilter</strong>：服务实例清单过滤机制，默认采<strong>ZonePreferenceServerListFilter</strong>，该策略能够优先过滤出与请求方处于同区域的服务实例。</p><h5 id="ribbon-负载均衡策略">2. Ribbon 负载均衡策略</h5><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305142220956.png" /></p><ol type="1"><li><strong>RandomRule</strong>： 随机选择一个 Server。</li><li><strong>RetryRule</strong>：对选定的负载均衡策略机上重试机制，在一个配置时间段内当选择 Server不成功，则一直尝试使用 subRule 的方式选择一个可用的 server。</li><li><strong>RoundRobinRule</strong>： 轮询选择， 轮询 index，选择 index对应位置的 Server。</li><li><strong>AvailabilityFilteringRule</strong>：过滤掉一直连接失败的被标记为 circuit tripped 的后端Server，并过滤掉那些高并发的后端 Server或者使用一个AvailabilityPredicate 来包含过滤 server 的逻辑，其实就是检查status 里记录的各个 Server 的运行状态。</li><li><strong>BestAvailableRule</strong>： 选择一个最小的并发请求的Server，逐个考察 Server，如果 Serve r被 tripped 了，则跳过。</li><li><strong>WeightedResponseTimeRule</strong>：根据响应时间加权，响应时间越长，权重越小，被选中的可能性越低。</li><li><strong>ZoneAvoidanceRule</strong>： 默认的负载均衡策略，即复合判断Server 所在区域和 Server 的可用性选择Server，在没有区域的环境下，类似于轮询 。</li><li><strong>NacosRule:</strong>优先调用同一集群的实例，基于随机权重。</li></ol><h5 id="修改默认负载均衡策略">3. 修改默认负载均衡策略</h5><p><strong>全局配置：</strong>调用的微服务，一律使用指定的负载均衡策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">ribbonRule</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 指定使用 Nacos 提供的负载均衡策略</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NacosRule();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>局部配置</strong>：调用指定微服务时，使用对应的负载均衡策略</p><p>修改 application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 被调用的微服务名</span><br><span class="hljs-attr">mall-order:</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-comment"># 指定使用 Nacos 提供的负载均衡策略</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.alibaba.cloud.nacos.ribbon.NacosRule</span><br></code></pre></td></tr></table></figure><p>【注】这消费者服务中添加</p><p><strong>实现原理：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// org.springframework.cloud.netflix.ribbon.RibbonClientConfiguration#ribbonRule</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">ribbonRule</span><span class="hljs-params">(IClientConfig config)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.propertiesFactory.get(IRule.class, config, name);<br>   &#125;<br>   ZoneAvoidanceRule rule = <span class="hljs-keyword">new</span> ZoneAvoidanceRule();<br>   rule.initWithNiwsConfig(config);<br>   <span class="hljs-keyword">return</span> rule;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertiesFactory</span> </span>&#123;<br><br>   <span class="hljs-keyword">private</span> Map&lt;Class, String&gt; classToProperty = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PropertiesFactory</span><span class="hljs-params">()</span> </span>&#123;<br>      classToProperty.put(ILoadBalancer.class, <span class="hljs-string">&quot;NFLoadBalancerClassName&quot;</span>);<br>      classToProperty.put(IPing.class, <span class="hljs-string">&quot;NFLoadBalancerPingClassName&quot;</span>);<br>      classToProperty.put(IRule.class, <span class="hljs-string">&quot;NFLoadBalancerRuleClassName&quot;</span>);<br>      classToProperty.put(ServerList.class, <span class="hljs-string">&quot;NIWSServerListClassName&quot;</span>);<br>      classToProperty.put(ServerListFilter.class, <span class="hljs-string">&quot;NIWSServerListFilterClassName&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="自定义负载均衡策略">4. 自定义负载均衡策略</h5><p>通过实现 IRule 接口可以自定义负载策略，主要的选择服务逻辑在 choose方法中。</p><ol type="1"><li><p>实现基于 Nacos 权重的负载均衡策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NacosRandomWithWeightRule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLoadBalancerRule</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> NacosDiscoveryProperties nacosDiscoveryProperties;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Server <span class="hljs-title">choose</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>        DynamicServerListLoadBalancer loadBalancer = (DynamicServerListLoadBalancer) getLoadBalancer();<br>        String serviceName = loadBalancer.getName();<br>        NamingService namingService = nacosDiscoveryProperties.namingServiceInstance();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//nacos 基于权重的算法</span><br>            Instance instance = namingService.selectOneHealthyInstance(serviceName);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NacosServer(instance);<br>        &#125; <span class="hljs-keyword">catch</span> (NacosException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initWithNiwsConfig</span><span class="hljs-params">(IClientConfig clientConfig)</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置自定义的策略</p><p><strong>全局配置：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">ribbonRule</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NacosRandomWithWeightRule();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>局部配置：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mall-order:</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.debuggingWorld.user.config.NacosRandomWithWeightRule</span><br></code></pre></td></tr></table></figure></li></ol><h5 id="饥饿加载">5. 饥饿加载</h5><p>Ribbon默认懒加载，意味着只有在发起调用的时候才会创建客户端。有可能会导致服务调用超时。</p><p>开启饥饿加载，解决第一次调用慢的问题。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">eager-load:</span><br>    <span class="hljs-attr">clients:</span> <span class="hljs-string">mall-order</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>ribbon.eager-load.enabled：开启 ribbon 的饥饿加载模式</li><li>ribbon.eager-load.clients：指定需要饥饿加载的服务名，也就是需要调用的服务，如果有多个服务，则用逗号隔开。</li></ul><h3 id="什么是-loadbalancer">3. 什么是 LoadBalancer</h3><p>Spring Cloud LoadBalancer 是 Spring Cloud官方自己提供的客户端负载均衡器, 用来替代 Ribbon。</p><p>Spring 官方提供了两种客户端都可以使用 loadbalancer：</p><p><strong>RestTemplate：</strong></p><p>RestTemplate 是 Spring 提供的用于访问 Rest 服务的客户端，RestTemplate提供了多种便捷访问远程 Http服务的方法，能够大大提高客户端的编写效率。默认情况下，RestTemplate默认依赖 jdk 的 HTTP 连接工具。</p><p><strong>WebClient：</strong></p><p>WebClient 是从 Spring WebFlux 5.0版本开始提供的一个非阻塞的基于响应式编程的进行 Http请求的客户端工具。它的响应式编程的基于 Reactor 的。WebClient中提供了标准 Http 请求方式对应的 get、post、put、delete等方法，可以用来发起相应的请求。</p><h4 id="resttemplate-整合-loadbalancer">3.1 RestTemplate 整合LoadBalancer</h4><ol type="1"><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- LoadBalancer --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 提供了RestTemplate支持 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- nacos服务注册与发现  移除ribbon支持--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意： nacos-discovery 中引入了 ribbon，需要移除 ribbon 的包。</p><p>如果不移除，也可以在 yml 中配置不使用ribbon。默认情况下，如果同时拥有 RibbonLoadBalancerClient 和BlockingLoadBalancerClient，为了保持向后兼容性，将使用RibbonLoadBalancerClient。要覆盖它，可以设置spring.cloud.loadbalancer.ribbon.enabled 属性为 false。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">mall-user</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.60</span><span class="hljs-number">.10</span><span class="hljs-string">:8848</span><br>    <span class="hljs-comment"># 不使用ribbon，使用loadbalancer</span><br>    <span class="hljs-attr">loadbalancer:</span><br>      <span class="hljs-attr">ribbon:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305150103332.png" /></p></li><li><p>使用 <span class="citation"data-cites="LoadBalanced">@LoadBalanced</span> 注解修饰RestTemplate，开启客户端负载均衡功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/getOrderByUserId/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">findOrderByUserId</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;<br>        String url = <span class="hljs-string">&quot;http://mall-order/order/findOrderByUserId/&quot;</span>+id;<br>        <span class="hljs-keyword">return</span> restTemplate.getForObject(url,ResponseEntity.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="webclient-整合-loadbalancer">3.2 WebClient 整合LoadBalancer</h4><ol type="1"><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- LoadBalancer --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- webflux --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- nacos服务注册与发现 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置 WebClient 作为负载均衡器的 client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebClientConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@LoadBalanced</span><br>    <span class="hljs-meta">@Bean</span><br>    WebClient.<span class="hljs-function">Builder <span class="hljs-title">webClientBuilder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> WebClient.builder();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function">WebClient <span class="hljs-title">webClient</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> webClientBuilder().build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> WebClient webClient;<br><br><span class="hljs-meta">@RequestMapping(value = &quot;/findOrderByUserId2/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&gt; <span class="hljs-title">findOrderByUserIdWithWebClient</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;<br><br>    String url = <span class="hljs-string">&quot;http://mall-order/order/findOrderByUserId/&quot;</span>+id;<br>    <span class="hljs-comment">//基于WebClient</span><br>    Mono&lt;ResponseEntity&gt; result = webClient.get().uri(url)<br>            .retrieve().bodyToMono(ResponseEntity.class);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>原理： 底层会使用ReactiveLoadBalancer</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305150153890.png" /></p><p>引入 webFlux：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> ReactorLoadBalancerExchangeFilterFunction lbFunction;<br><br><span class="hljs-meta">@RequestMapping(value = &quot;/findOrderByUserId3/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&gt; <span class="hljs-title">findOrderByUserIdWithWebFlux</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;<br><br>    String url = <span class="hljs-string">&quot;http://mall-order/order/findOrderByUserId/&quot;</span>+id;<br>    <span class="hljs-comment">//基于WebClient+webFlux</span><br>    Mono&lt;ResponseEntity&gt; result = WebClient.builder()<br>            .filter(lbFunction)<br>            .build()<br>            .get()<br>            .uri(url)<br>            .retrieve()<br>            .bodyToMono(ResponseEntity.class);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud Alibaba</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Cloud Alibaba</tag>
      
      <tag>负载均衡器</tag>
      
      <tag>Ribbon</tag>
      
      <tag>LoadBalancer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Alibaba——注册中心Nacos</title>
    <link href="/2023/05/10/Spring-Cloud-Alibaba%E2%80%94%E2%80%94%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83Nacos/"/>
    <url>/2023/05/10/Spring-Cloud-Alibaba%E2%80%94%E2%80%94%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83Nacos/</url>
    
    <content type="html"><![CDATA[<h3 id="注册中心">1. 注册中心</h3><h4 id="注册中心的作用">1.1 注册中心的作用</h4><p>服务注册中心的作用就是服务注册与发现</p><ul><li>服务注册：就是将提供某个服务的模块信息（通常是这个服务的 ip和端口）注册到一个公共的组件上去。</li><li>服务发现：就是新注册的这个服务模块能够及时的被其他调用者发现。不管是服务新增和服务删减都能实现自动发现。</li></ul><p>实现服务发现的设计思路：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305100029676.png" /></p><h4 id="注册中心设计思路分析">1.2 注册中心设计思路分析</h4><p>https://www.processon.com/view/link/5e71cc85e4b011fcce9d604d</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305100045698.png" /></p><h4 id="注册中心对比">1.3 注册中心对比</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305100053608.png" /></p><h3 id="什么是-nacos">2. 什么是 Nacos</h3><p>Nacos 是 Dynamic Naming and Configuration Service的首字母简称；一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p><p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><p>Nacos 的关键特性包括:</p><ul><li>服务发现和服务健康监测</li><li>动态配置服务</li><li>动态 DNS 服务</li><li>服务及其元数据管理</li></ul><p>官方文档： https://nacos.io/zh-cn/docs/what-is-nacos.html</p><p>OpenAPI文档：https://nacos.io/zh-cn/docs/open-api.html</p><p><strong>Nacos 优势</strong></p><ul><li><strong>易用</strong>：简单的数据模型，标准的restfulAPI，易用的控制台，丰富的使用文档。</li><li><strong>稳定</strong>：99.9% 高可用，脱胎于历经阿里巴巴 10年生产验证的内部产品，支持具有数百万服务的大规模场景，具备企业级 SLA的开源产品。</li><li><strong>实时</strong>：数据变更毫秒级推送生效；1w 级，SLA 承诺 1w实例上下线 1s，99.9% 推送完成；10w 级，SLA 承诺 1w 实例上下线 3s，99.9%推送完成；100w 级别，SLA 承诺 1w 实例上下线 9s 99.9% 推送完成。</li><li><strong>规模：</strong>十万级服务/配置，百万级连接，具备强大扩展性。</li></ul><h3 id="nacos-作为注册中心">3. Nacos 作为注册中心</h3><h4 id="nacos-注册中心架构和基本概念">3.1 Nacos注册中心架构和基本概念</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305100111058.png" /></p><ul><li><p><strong>服务 (Service)</strong></p><p>服务是指一个或一组软件功能（例如特定信息的检索或一组操作的执行），其目的是不同的客户端可以为不同的目的重用（例如通过跨进程的网络调用）。Nacos支持主流的服务生态，如 Kubernetes Service、gRPC|Dubbo RPC Service 或者Spring Cloud RESTful Service。</p></li><li><p><strong>服务注册中心 (Service Registry)</strong></p><p>服务注册中心，它是服务及其实例和元数据的数据库。服务实例在启动时注册到服务注册表，并在关闭时注销。服务和路由器的客户端查询服务注册表以查找服务的可用实例。服务注册中心可能会调用服务实例的健康检查API 来验证它是否能够处理请求。</p></li><li><p><strong>服务元数据 (Service Metadata)</strong></p><p>服务元数据是指包括服务端点(endpoints)、服务标签、服务版本号、服务实例权重、路由规则、安全策略等描述服务的数据。</p></li><li><p><strong>服务提供方 (Service Provider)</strong></p><p>是指提供可复用和可调用服务的应用方。</p></li><li><p><strong>服务消费方 (Service Consumer)</strong></p><p>是指会发起对某个服务调用的应用方。</p></li></ul><h4 id="nacos-注册中心核心功能">3.2 Nacos 注册中心核心功能</h4><p><strong>服务注册</strong>：Nacos Client 会通过发送 REST 请求的方式向Nacos Server 注册自己的服务，提供自身的元数据，比如 ip地址、端口等信息。Nacos Server接收到注册请求后，就会把这些元数据信息存储在一个双层的内存 Map 中。</p><p><strong>服务心跳</strong>：在服务注册后，Nacos Client会维护一个定时心跳来持续通知 NacosServer，说明服务一直处于可用状态，防止被剔除。默认5s发送一次心跳。</p><p><strong>服务同步</strong>：Nacos Server集群之间会互相同步服务实例，用来保证服务信息的一致性。</p><p><strong>服务发现</strong>：服务消费者（NacosClient）在调用服务提供者的服务时，会发送一个 REST 请求给 NacosServer，获取上面注册的服务清单，并且缓存在 Nacos Client 本地，同时会在Nacos Client本地开启一个定时任务定时拉取服务端最新的注册表信息更新到本地缓存。</p><p><strong>服务健康检查</strong>：Nacos Server会开启一个定时任务用来检查注册服务实例的健康情况，对于超过 15s没有收到客户端心跳的实例会将它的 healthy属性置为false(客户端服务发现时不会发现)，如果某个实例超过30秒没有收到心跳，直接剔除该实例(被剔除的实例如果恢复发送心跳则会重新注册)</p><h4 id="nacos-注册中心nacos-server环境搭建">3.3 Nacos 注册中心（NacosServer）环境搭建</h4><p>Nacos 版本： v2.1.0</p><h5 id="单机模式">1. 单机模式</h5><p>官方文档： https://nacos.io/zh-cn/docs/deployment.html</p><p>安装包下载地址：https://github.com/alibaba/nacos/releases/download/2.1.0/nacos-server-2.1.0.tar.gz</p><p>解压，进入 nacos 目录，单机模式启动 nacos：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">单机模式启动nacos</span><br>sh startup.sh -m standalone<br></code></pre></td></tr></table></figure><p>也可以修改启动脚本方式：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305100155240.png" /></p><p>访问 nacos 的管理端：192.168.60.10:8848/nacos/，默认的用户名/密码：nacos/nacos</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305100209397.png" /></p><h5 id="集群模式">2. 集群模式</h5><p>官网文档：https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html</p><p><strong>1）环境准备</strong></p><ul><li>JDK：需要 1.8 及其以上版本</li><li>建议: 2核 CPU / 4G 内存 及其以上</li><li>建议: 生产环境 3 个节点 及其以上</li></ul><p>注意：在单台服务器上搭建伪集群不能使用连续端口号（比如8848,8849,8850）， 因为使用 8848（grpc会占用9848，9849），8849（grpc会占用9849,9850），会导致端口冲突。</p><p>原因：Nacos2.x 版本相比 1.X 新增了 gRPC 的通信方式，因此需要增加 2个端口。新增端口是在配置的主端口（server.port）基础上，进行一定偏移量自动生成。</p><table><thead><tr><th>端口</th><th>与主端口的偏移量</th><th>描述</th></tr></thead><tbody><tr><td>9848</td><td>1000</td><td>客户端 gRPC 请求服务端端口，用于客户端向服务端发起连接和请求</td></tr><tr><td>9849</td><td>1001</td><td>服务端 gRPC 请求服务端端口，用于服务间同步等</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 准备三台服务器</span><br>192.168.60.10:8848<br>192.168.60.10:8858<br>192.168.60.10:8868<br></code></pre></td></tr></table></figure><p><strong>2）以 192.168.60.10:8848 为例，进入nacos目录</strong></p><ol type="1"><li><p>修改 conf/application.properties，使用外置数据源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## If use MySQL as datasource:</span></span><br>spring.datasource.platform=mysql<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## Count of DB:</span></span><br>db.num=1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## Connect URL of DB:</span></span><br>db.url.0=jdbc:mysql://192.168.60.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC<br>db.user.0=root<br>db.password.0=mysql<br></code></pre></td></tr></table></figure></li><li><p>将 conf/cluster.conf.example 改为 cluster.conf，添加节点配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">it is ip</span><br>192.168.60.10:8848<br>192.168.60.10:8858<br>192.168.60.10:8868        <br></code></pre></td></tr></table></figure><p>注意：不要使用 localhost 或 127.0.0.1，针对多网卡环境，nacos可以指定网卡或 ip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">多网卡选择</span><br><span class="hljs-meta">#</span><span class="bash">ip-address参数可以直接设置nacos的ip</span><br><span class="hljs-meta">#</span><span class="bash">该参数设置后，将会使用这个IP去cluster.conf里进行匹配，请确保这个IP的值在cluster.conf里是存在的</span><br>nacos.inetutils.ip-address=192.168.65.206<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">use-only-site-local-interfaces参数可以让nacos使用局域网ip，这个在nacos部署的机器有多网卡时很有用，可以让nacos选择局域网网卡</span><br>nacos.inetutils.use-only-site-local-interfaces=true<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">ignored-interfaces支持网卡数组，可以让nacos忽略多个网卡</span><br>nacos.inetutils.ignored-interfaces[0]=eth0<br>nacos.inetutils.ignored-interfaces[1]=eth1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">preferred-networks参数可以让nacos优先选择匹配的ip，支持正则匹配和前缀匹配</span><br>nacos.inetutils.preferred-networks[0]=30.5.124.             <br></code></pre></td></tr></table></figure><p>192.168.60.10:8858、192.168.60.10:8868 按同样的方式配置</p></li></ol><p><strong>3) mysql 中创建 nacos 配置数据库</strong></p><p>sql脚本：https://github.com/alibaba/nacos/blob/2.1.0/distribution/conf/nacos-mysql.sql</p><p><strong>4) 如果内存不够，可以调整jvm参数</strong></p><p>startup.sh：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305110002671.png" /></p><p><strong>5) 分别启动三个 nacos 实例</strong></p><p>以 192.168.60.10:8848 为例，启动 nacos：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./bin/startup.sh<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305102257075.png" /></p><p><strong>6) 访问 nacos 管理界面</strong></p><p>登录 http://192.168.60.10:8848/nacos，用户名和密码都是 nacos</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305110009140.png" /></p><h4 id="spring-cloud-alibaba-nacos-快速开始">3.4 Spring Cloud AlibabaNacos 快速开始</h4><h5 id="spring-cloud-alibaba-版本选型">1. Spring Cloud Alibaba版本选型</h5><p>版本说明：https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E</p><table><thead><tr><th>Spring Cloud Alibaba Version</th><th>Spring Cloud Version</th><th>Spring Boot Version</th><th>Nacos Version</th></tr></thead><tbody><tr><td>2.2.8.RELEASE</td><td>Spring Cloud Hoxton.SR12</td><td>2.3.12.RELEASE</td><td>2.1.0</td></tr></tbody></table><p><strong>父pom配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Hoxton.SR12<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud-alibaba.version</span>&gt;</span>2.2.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud-alibaba.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud-alibaba.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="微服务nacos-client整合-nacos-注册中心nacos-server">2.微服务（Nacos Client）整合 Nacos 注册中心（Nacos Server）</h5><p><strong>配置服务提供者 mall-order</strong></p><p>服务提供者可以通过 Nacos 的服务注册发现功能将其服务注册到 Nacosserver 上。</p><ol type="1"><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置 nacos 注册中心</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8050</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">mall-order</span>  <span class="hljs-comment">#微服务名称</span><br><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.60</span><span class="hljs-number">.10</span><span class="hljs-string">:8848</span><br></code></pre></td></tr></table></figure><p>更多配置：https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-discovery</p><table><thead><tr><th>配置项</th><th>Key</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>服务端地址</code></td><td><code>spring.cloud.nacos.discovery.server-addr</code></td><td><code>无</code></td><td><code>Nacos Server 启动监听的ip地址和端口</code></td></tr><tr><td><code>服务名</code></td><td><code>spring.cloud.nacos.discovery.service</code></td><td><code>$&#123;spring.application.name&#125;</code></td><td><code>给当前的服务命名</code></td></tr><tr><td><code>服务分组</code></td><td><code>spring.cloud.nacos.discovery.group</code></td><td><code>DEFAULT_GROUP</code></td><td><code>设置服务所处的分组</code></td></tr><tr><td><code>权重</code></td><td><code>spring.cloud.nacos.discovery.weight</code></td><td><code>1</code></td><td><code>取值范围 1 到 100，数值越大，权重越大</code></td></tr><tr><td><code>网卡名</code></td><td><code>spring.cloud.nacos.discovery.network-interface</code></td><td><code>无</code></td><td><code>当IP未配置时，注册的IP为此网卡所对应的IP地址，如果此项也未配置，则默认取第一块网卡的地址</code></td></tr><tr><td><code>注册的IP地址</code></td><td><code>spring.cloud.nacos.discovery.ip</code></td><td><code>无</code></td><td><code>优先级最高</code></td></tr><tr><td><code>注册的端口</code></td><td><code>spring.cloud.nacos.discovery.port</code></td><td><code>-1</code></td><td><code>默认情况下不用配置，会自动探测</code></td></tr><tr><td><code>命名空间</code></td><td><code>spring.cloud.nacos.discovery.namespace</code></td><td><code>无</code></td><td><code>常用场景之一是不同环境的注册的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</code></td></tr><tr><td><code>AccessKey</code></td><td><code>spring.cloud.nacos.discovery.access-key</code></td><td><code>无</code></td><td><code>当要上阿里云时，阿里云上面的一个云账号名</code></td></tr><tr><td><code>SecretKey</code></td><td><code>spring.cloud.nacos.discovery.secret-key</code></td><td><code>无</code></td><td><code>当要上阿里云时，阿里云上面的一个云账号密码</code></td></tr><tr><td><code>Metadata</code></td><td><code>spring.cloud.nacos.discovery.metadata</code></td><td><code>无</code></td><td><code>使用Map格式配置，用户可以根据自己的需要自定义一些和服务相关的元数据信息</code></td></tr><tr><td><code>日志文件名</code></td><td><code>spring.cloud.nacos.discovery.log-name</code></td><td><code>无</code></td><td></td></tr><tr><td><code>集群</code></td><td><code>spring.cloud.nacos.discovery.cluster-name</code></td><td><code>DEFAULT</code></td><td><code>配置成Nacos集群名称</code></td></tr><tr><td><code>接入点</code></td><td><code>spring.cloud.nacos.discovery.enpoint</code></td><td><code>UTF-8</code></td><td><code>地域的某个服务的入口域名，通过此域名可以动态地拿到服务端地址</code></td></tr><tr><td><code>是否集成Ribbon</code></td><td><code>ribbon.nacos.enabled</code></td><td><code>true</code></td><td><code>一般都设置成true即可</code></td></tr><tr><td><code>是否开启Nacos Watch</code></td><td><code>spring.cloud.nacos.discovery.watch.enabled</code></td><td><code>true</code></td><td><code>可以设置成false来关闭 watch</code></td></tr><tr><td><code>注册的IP地址类型</code></td><td><code>spring.cloud.nacos.discovery.ip-type</code></td><td><code>IPv4</code></td><td><code>可以配置IPv4和IPv6两种类型</code></td></tr></tbody></table></li><li><p>启动服务，查看是否注册成功</p><p>【注】启动类不需要：<span class="citation"data-cites="EnableDiscoveryClient">@EnableDiscoveryClient</span></p><p>启动两个实例：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305132353346.png" /></p><p>nacos 管理端界面查看是否成功注册：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305132357297.png" /></p><p>通过 <a href="https://nacos.io/zh-cn/docs/open-api.html">Open API</a>查询实例列表：</p><p>http://192.168.60.10:8848/nacos/v1/ns/instance/list?serviceName=mall-order</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305140001034.png" /></p></li></ol><p><strong>配置服务消费者 mall-user</strong></p><p>服务消费者可以通过 Nacos 的服务发现功能从 Nacos server上获取到它要调用的服务。</p><ol type="1"><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置 nacos 注册中心</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8060</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">mall-user</span>  <span class="hljs-comment">#微服务名称</span><br><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.60</span><span class="hljs-number">.10</span><span class="hljs-string">:8848</span><br></code></pre></td></tr></table></figure></li><li><p>启动 mall-user，nacos 管理端界面查看是否成功注册</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305140005347.png" /></p></li><li><p>使用 RestTemplate 进行服务调用</p><p>给 RestTemplate 实例添加 <span class="citation"data-cites="LoadBalanced">@LoadBalanced</span> 注解，开启 <spanclass="citation" data-cites="LoadBalanced">@LoadBalanced</span> 与Ribbon 的集成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span>  <span class="hljs-comment">// 微服务名替换为具体的ip:port</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/getOrderByUserId/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">findOrderByUserId</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;根据userId:&quot;</span> + id + <span class="hljs-string">&quot;查询订单信息&quot;</span>);<br>        <span class="hljs-comment">// mall-order  ip:port</span><br>        String url = <span class="hljs-string">&quot;http://mall-order/order/findOrderByUserId/&quot;</span> + id;<br>        <span class="hljs-keyword">return</span> restTemplate.getForObject(url, ResponseEntity.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305140013477.png" /></p></li></ol><h4 id="nacos-注册中心常见配置">3.5 Nacos 注册中心常见配置</h4><h5 id="服务分级存储模型">1. 服务分级存储模型</h5><p>​注册中心的核心数据是服务的名字和它对应的网络地址，当服务注册了多个实例时，我们需要对不健康的实例进行过滤或者针对实例的某些特征进行流量的分配，那么就需要在实例上存储一些例如：健康状态、权重等属性。随着服务规模的扩大，渐渐的又需要在整个服务级别设定一些权限规则、以及对所有实例都生效的一些开关，于是在服务级别又会设立一些属性。再往后，我们又发现单个服务的实例又会有划分为多个子集的需求，例如一个服务是多机房部署的，那么可能需要对每个机房的实例做不同的配置，这样又需要在服务和实例之间再设定一个数据级别。</p><p>Nacos在经过内部多年生产经验后提炼出的数据模型，则是一种：服务-集群-实例的三层模型。这样基本可以满足服务在所有场景下的数据存储和管理。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305140026153.png" /></p><h5 id="服务逻辑隔离">2. 服务逻辑隔离</h5><p>Nacos 数据模型 Key 由三元组唯一确定, Namespace默认是空串，公共命名空间（public），分组默认是 DEFAULT_GROUP。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305140039637.png" /></p><h5 id="namespace-隔离设计">3. Namespace 隔离设计</h5><p>命名空间（Namespace）用于进行租户（用户）粒度的隔离，Namespace的常用场景之一是不同环境的隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</p><p>新建命名空间：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305140041268.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305140044281.png" /></p><p>修改 yml 配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">mall-user</span><br><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.60</span><span class="hljs-number">.10</span><span class="hljs-string">:8848</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">0bf30700-cc40-48d9-83a1-83262a36324a</span><br></code></pre></td></tr></table></figure><p>启动 mall-user，进入 nacos 控制台可以看到 mall-user 注册成功，所属namespace 是 debug：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305140051776.png" /></p><p>测试：http://127.0.0.1:8060/user/getOrderByUserId/1，报错</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305140052003.png" /></p><p>原因：mall-order 和 mall-user 使用了不同的namespace，导致服务隔离。</p><h5 id="group-服务分组">4. group 服务分组</h5><p>不同的服务可以归类到同一分组，group 也可以起到服务隔离的作用。yml中可以通过 spring.cloud.nacos.discovery.group 参数配置</p><h5 id="设置集群">5. 设置集群</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">spring.cloud.nacos.discovery.cluster-name</span>: <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h5 id="临时实例和持久化实例">6. 临时实例和持久化实例</h5><p>​ 在定义上区分临时实例和持久化实例的关键是健康检查的方式。临时实例使用客户端上报模式，而持久化实例使用服务端反向探测模式。临时实例需要能够自动摘除不健康实例，而且无需持久化存储实例。持久化实例使用服务端探测的健康检查方式，因为客户端不会上报心跳，所以不能自动摘除下线的实例。</p><p>​在大中型的公司里，这两种类型的服务往往都有。一些基础的组件例如数据库、缓存等，这些往往不能上报心跳，这种类型的服务在注册时，就需要作为持久化实例注册。而上层的业务服务，例如微服务或者 Dubbo 服务，服务的 Provider端支持添加汇报心跳的逻辑，此时就可以使用动态服务的注册方式。</p><p>​ Nacos 1.x中持久化及非持久化的属性是作为实例的一个元数据进行存储和识别。Nacos 2.x中继续沿用了持久化及非持久化的设定，但是有了一些调整。在Nacos2.0中将是否持久化的数据抽象至服务级别，且不再允许一个服务同时存在持久化实例和非持久化实例，实例的持久化属性继承自服务的持久化属性。</p><p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 持久化实例</span><br><span class="hljs-meta">spring.cloud.nacos.discovery.ephemeral</span>: <span class="hljs-string">false </span><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud Alibaba</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Cloud Alibaba</tag>
      
      <tag>Nacos</tag>
      
      <tag>注册中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Alibaba——微服务架构</title>
    <link href="/2023/05/09/Spring-Cloud-Alibaba%E2%80%94%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/05/09/Spring-Cloud-Alibaba%E2%80%94%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p>https://www.processon.com/view/link/60519545f346fb348a97c9d5</p><h3 id="单体架构vs微服务架构">1. 单体架构vs微服务架构</h3><h4 id="单机架构">1.1 单机架构</h4><p>一个归档包（例如 war格式）包含了应用所有功能的应用程序，我们通常称之为单体应用。架构单体应用的方法论，我们称之为单体应用架构。</p><p><strong>单体架构示意图：</strong></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305090144235.png" /></p><p><strong>单体架构的优缺点：</strong></p><p><strong>优点:</strong></p><ul><li>架构简单明了</li><li>开发，测试，部署简单</li></ul><p><strong>缺点</strong>:</p><ul><li>随着业务扩展，代码越来越复杂，代码质量参差不齐(开发人员的水平不一)，会让你每次提交代码，修改每一个小bug都是心惊胆战的。</li><li>部署慢(由于单体架构，功能复杂)能想像下一个来自200W+代码部署的速度(15分钟)</li><li>扩展成本高，根据单体架构图 假设用户模块是一个 CPU密集型的模块(涉及到大量的运算)，那么我们需要替换更加牛逼的CPU，而我们的订单模块是一个IO密集模块（涉及大量的读写磁盘）,那我们需要替换更加牛逼的内存以及高效的磁盘。但是我们的单体架构上无法针对单个功能模块进行扩展，那么就需要替换更牛逼的CPU，更牛逼的内存，更牛逼的磁盘，价格蹭蹭的往上涨。</li><li>阻碍了新技术的发展。。。。。。比如我们的 web 架构模块从 struts2迁移到 springboot，那么就会成为灾难</li></ul><h4 id="微服务以及微服务架构">1.2 微服务以及微服务架构</h4><h5 id="微服务的定义">1. 微服务的定义</h5><p>①：英文:https://martinfowler.com/articles/microservices.html</p><p>②: 中文:http://blog.cuicc.com/blog/2015/07/22/microservices</p><p>微服务核心就是把传统的单机应用，根据业务将单机应用拆分为一个一个的服务，彻底的解耦，每一个服务都是提供特定的功能，一个服务只做一件事,类似进程，每个服务都能够单独部署，甚至可以拥有自己的数据库。这样的一个一个的小服务就是微服务。</p><p>①: 比如传统的单机电商应用，有订单/支付/库存/物流/积分等模块（理解为service）</p><p>②:我们根据业务模型来拆分，可以拆分为订单服务、支付服务、库存服务、物流服务、积分服务</p><p>③: 若不拆分的时候，我的非核心业务积分模块出现了重大bug，系统内存溢出，导致整个服务宕机。若拆分之后，只是积分微服务不可用，整个系统核心功能还是能使用</p><h5 id="微服务的特点">2. 微服务的特点</h5><ol type="1"><li><p>独立部署，灵活扩展</p><p>传统的单体架构是以整个系统为单位进行部署，而微服务则是以每一个独立组件（例如用户服务，商品服务）为单位进行部署。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305090153507.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305090154315.png" /></p></li><li><p>资源的有效隔离</p><p>微服务设计的原则之一，就是每一个微服务拥有独立的数据源，假如微服务 A想要读写微服务 B 的数据库，只能调用微服务 B对外暴露的接口来完成。这样有效避免了服务之间争用数据库和缓存资源所带来的问题。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305090156521.png" /></p></li><li><p>团队组织架构的调整</p><p>微服务设计的思想也改变了原有的企业研发团队组织架构。传统的研发组织架构是水平架构，前端有前端的团队，后端有后端的团队，DBA有DBA的团队，测试有测试的团队。而微服务的设计思想对团队的划分有着一定的影响，使得团队组织架构的划分更倾向于垂直架构，比如用户业务是一个团队来负责，支付业务是一个团队来负责。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305090158498.png" /></p></li></ol><h5 id="微服务架构是什么">3. 微服务架构是什么</h5><p>微服务架构风格是一种将单个应用程序作为一套小型服务开发的方法，每种应用程序都在自己的进程中运行，并与轻量级机制（通常是HTTP 资源 API）进行通信。这些服务是围绕业务功能构建的，可以通过全自动部署机制独立部署。这些服务的集中管理最少，可以用不同的编程语言编写，并使用不同的数据存储技术。</p><p>SOA架构强调的是异构系统之间的通信和解耦合，而微服务架构强调的是系统按业务边界做细粒度的拆分和部署。</p><p>微服务架构是一个架构风格, 提倡:</p><ul><li>将一个单一应用程序开发为一组小型服务</li><li>每个服务运行在自己的进程中</li><li>服务之间通过轻量级的通信机制(http rest api)</li><li>每个服务都能够独立的部署</li><li>每个服务甚至可以拥有自己的数据库</li></ul><p>微服务以及微服务架构的是二个完全不同的概念。微服务强调的是服务的大小和对外提供的单一功能，而微服务架构是指把一个一个的微服务组合管理起来，对外提供一套完整的服务。</p><h5 id="微服务的优缺点">4. 微服务的优缺点</h5><p><strong>优点</strong>:</p><ul><li>每个服务足够小，足够内聚，代码更加容易理解,专注一个业务功能点(对比传统应用，可能改几行代码需要了解整个系统)</li><li>开发简单，一个服务只干一个事情</li><li>按需伸缩，服务松耦合</li><li>前后端分离, 作为 java开发人员，我们只要关系后端接口的安全性以及性能，不要去关注页面的人机交互</li><li>一个服务可拥有自己的数据库，也可以多个服务连接同一个数据库。</li></ul><p><strong>缺点</strong>:</p><ul><li>增加了运维人员的工作量，以前只要部署一个war包，现在可能需要部署成百上千个war包(k8s+docker+jenkins )</li><li>服务之间相互调用，增加通信成本</li><li>数据一致性问题(分布式事务问题)</li><li>性能监控等,问题定位..........................</li></ul><h3 id="spring-cloud-微服务技术栈">2. Spring Cloud 微服务技术栈</h3><p>Spring Cloud是分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶。</p><p>Spring Cloud为开发人员提供了快速构建分布式系统中的一些常见模式的工具（例如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性令牌、全局锁、领导选举、分布式会话、集群状态）。</p><p>官网： https://spring.io/projects/spring-cloud</p><p>中文文档： https://www.springcloud.cc/</p><p>Spring Cloud中国社区：http://springcloud.cn/</p><h4 id="springcloud-微服务架构生态圈">2.1 SpringCloud微服务架构生态圈</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305090258232.png" /></p><h4 id="spring-cloud-netflix-包含的组件">2.2 Spring Cloud Netflix包含的组件</h4><ul><li>Eureka：服务注册和发现，它提供了一个服务注册中心、服务发现的客户端，还有一个方便查看所有注册服务的界面。</li><li>Zuul：网关，所有的客户端请求通过这个网关访问后台的服务。他可以使用一定的路由配置来判断某一个URL 由哪个服务来处理。并从 Eureka 获取注册的服务来转发请求。</li><li>Ribbon：即负载均衡，Zuul网关将一个请求发送给某一个服务的应用的时候，如果一个服务启动了多个实例，就会通过Ribbon 来通过一定的负载均衡策略来发送给某一个服务实例。</li><li>Feign：服务客户端，服务之间如果需要相互访问，可以使用RestTemplate，也可以使用 Feign 客户端访问。它默认会使用 Ribbon来实现负载均衡。</li><li>Hystrix：监控和断路器。我们只需要在服务接口上添加 Hystrix标签，就可以实现对这个接口的监控和断路器功能。</li><li>HystrixDashboard：监控面板，他提供了一个界面，可以监控各个服务上的服务调用所消耗的时间等。</li><li>Turbine：监控聚合，使用 Hystrix监控，我们需要打开每一个服务实例的监控信息来查看。而 Turbine可以帮助我们把所有的服务实例的监控信息聚合到一个地方统一查看。这样就不需要挨个打开一个个的页面一个个查看。</li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305090254966.png" /></p><h4 id="spring-cloud-alibaba-技术栈">2.3 Spring Cloud Alibaba技术栈</h4><p>同 Spring Cloud 一样，Spring Cloud Alibaba也是一套微服务解决方案，包含开发分布式应用微服务的必需组件，方便开发者通过Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将Spring Cloud应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><p>作为 Spring Cloud 体系下的新实现，Spring Cloud Alibaba跟官方的组件或其它的第三方实现如 Netflix, Consul，Zookeeper等对比，具备了更多的功能:</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305090230818.png" /></p><h5 id="spring-cloud-alibaba-包含组件">1. Spring Cloud Alibaba包含组件</h5><p>阿里开源组件</p><ul><li>Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li><li>Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li><li>RocketMQ：开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li><li>Dubbo：在国内应用非常广泛的一款高性能 Java RPC 框架。</li><li>Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li><li>Arthas：开源的Java动态追踪工具，基于字节码增强技术，功能非常强大。</li></ul><p>阿里商业化组件</p><ul><li>Alibaba CloudACM：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</li><li>Alibaba Cloud OSS：阿里云对象存储服务（Object Storage Service，简称OSS），是阿里云提供的云存储服务。</li><li>Alibaba CloudSchedulerX：阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准的定时（基于Cron 表达式）任务调度服务。</li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305090233845.png" /></p><h5 id="spring-cloud-alibaba-版本选择">2. Spring Cloud Alibaba版本选择</h5><p><ahref="https://github.com/alibaba/spring-cloud-alibaba/wiki/版本说明">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E</a></p><p>版本选择： Spring Cloud Alibaba 2.2.8.RELEASE</p><p>父 pom 如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debuggingWorld<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>debug-spring-cloud-alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Hoxton.SR12<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud-alibaba.version</span>&gt;</span>2.2.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud-alibaba.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud-alibaba.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud Alibaba</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Cloud Alibaba</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot——自定义starter</title>
    <link href="/2023/04/29/Spring-Boot%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89starter/"/>
    <url>/2023/04/29/Spring-Boot%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89starter/</url>
    
    <content type="html"><![CDATA[<p>SpringBoot 最强大的功能就是把我们常用的场景抽取成了一个个starter（场景启动器），我们通过引入 springboot提供的这些场景启动器，我们再进行少量的配置就能使用相应的功能。即使是这样，springboot也不能囊括我们所有的使用场景，往往我们需要自定义 starter，来简化我们对springboot 的使用。</p><h3 id="如何自定义-starter">1. 如何自定义 starter</h3><h4 id="实例">1.1 实例</h4><p>参照 <span class="citation"data-cites="WebMvcAutoConfiguration">@WebMvcAutoConfiguration</span>为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfiguration(after = &#123;DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span><br><span class="hljs-meta">        ValidationAutoConfiguration.class&#125;)</span><br><span class="hljs-meta">@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="hljs-meta">@ConditionalOnClass(&#123;Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class&#125;)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span><br><span class="hljs-meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcAutoConfiguration</span> </span>&#123;<br><br>    <span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br>    <span class="hljs-meta">@Import(org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration.EnableWebMvcConfiguration.class)</span><br>    <span class="hljs-meta">@EnableConfigurationProperties(&#123;WebMvcProperties.class, WebProperties.class&#125;)</span><br>    <span class="hljs-meta">@Order(0)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcAutoConfigurationAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span>, <span class="hljs-title">ServletContextAware</span> </span>&#123;<br><br>        <span class="hljs-meta">@Bean</span><br>        <span class="hljs-meta">@ConditionalOnBean(View.class)</span><br>        <span class="hljs-meta">@ConditionalOnMissingBean</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> BeanNameViewResolver <span class="hljs-title">beanNameViewResolver</span><span class="hljs-params">()</span> </span>&#123;<br>            BeanNameViewResolver resolver = <span class="hljs-keyword">new</span> BeanNameViewResolver();<br>            resolver.setOrder(Ordered.LOWEST_PRECEDENCE - <span class="hljs-number">10</span>);<br>            <span class="hljs-keyword">return</span> resolver;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p><span class="citation"data-cites="Configuration">@Configuration</span> //指定这个类是一个配置类 <span class="citation"data-cites="ConditionalOnXXX">@ConditionalOnXXX</span> //指定条件成立的情况下自动配置类生效 <span class="citation"data-cites="AutoConfigureOrder">@AutoConfigureOrder</span> //指定自动配置类的顺序 <span class="citation"data-cites="Bean">@Bean</span> // 向容器中添加组件 <spanclass="citation"data-cites="ConfigurationProperties">@ConfigurationProperties</span> //用于自动配置绑定，可以将配置中的值注入到bean对象上 <spanclass="citation"data-cites="EnableConfigurationProperties">@EnableConfigurationProperties</span>// 将使用@ConfigurationProperties注解对应的类加入Spring容器</p></blockquote><p>自动配置类要能加载，需要将自动配置类配置在 META‐INF/spring.factories中：</p><p><ahref="https://blog.csdn.net/weixin_38972910/article/details/123632630">Spring.factories</a></p><p>mybatis-spring-boot-starter：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305082130700.png" /></p><p>mybatis-spring-boot-starter pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>spring-boot-starter pom ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>启动器（starter）是一个空的 jar文件，仅仅提供辅助性依赖管理，这些依赖可能用于自动装配或其他类库。</li><li>需要专门写一个类似 spring-boot-autoconfigure 的配置模块。</li><li>用的时候只需要引入启动器 starter，就可以使用自动配置了。</li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305082144802.png" /></p><h4 id="命名规范">1.2 命名规范</h4><p>官方命名空间</p><pre><code class="hljs">+ 前缀：spring-boot-starter-+ 模式：spring-boot-starter-模块名+ 举例：spring-boot-starter-web、spring-boot-starter-jdbc</code></pre><p>自定义命名空间</p><pre><code class="hljs">+ 后缀：-spring-boot-starter+ 模式：模块-spring-boot-starter+ 举例：mybatis-spring-boot-starter</code></pre><h3 id="自定义-starter">2. 自定义 starter</h3><p>先创建一个父 maven 项目： springboot_custom_starter，两个Module：debuggingWorld_spring_boot_starter 和debuggingWorld_spring_boot_autoconfigure。</p><p>springboot_custom_starter 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debuggingWorld<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot_custom_starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>debuggingWorld_spring_boot_starter<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>debuggingWorld_spring_boot_autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="debuggingworld_spring_boot_starter">2.1debuggingWorld_spring_boot_starter</h4><ol type="1"><li>pom.xml <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debuggingWorld<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot_custom_starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>debuggingWorld_spring_boot_starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!--引入autoconfigure--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debuggingWorld<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>debuggingWorld_spring_boot_autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 如果当前starter 还需要其他的类库就在这里引用 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="debuggingworld_spring_boot_autoconfigure">2.2debuggingWorld_spring_boot_autoconfigure</h4><ol type="1"><li><p>pom.xml</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debuggingWorld<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot_custom_starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>debuggingWorld_spring_boot_autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p>添加 spring-boot-configuration-processor 后并开启：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305082256271.png" /></p></li><li><p>DebugProperties：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(&quot;debuggingworld.hello&quot;)</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugProperties</span> </span>&#123;<br><span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>IndexController：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;<br><span class="hljs-meta">@Autowired</span><br>DebugProperties debugProperties;<br><br><span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> debugProperties.getName()+<span class="hljs-string">&quot;欢迎您&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>MyAutoConfiguration：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConfigurationProperties(value = &quot;debuggingworld.hello.name&quot;)</span><br><span class="hljs-meta">@EnableConfigurationProperties(DebugProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAutoConfiguration</span> </span>&#123;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> IndexController <span class="hljs-title">indexController</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IndexController();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>spring.factories:</p><p>在 resources 下创建文件夹 META-INF 并在 META-INF 下创建文件spring.factories：</p><p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span><br><span class="hljs-string">com.starter.debuggingWorld.MyAutoConfiguration</span><br></code></pre></td></tr></table></figure></p></li></ol><h3 id="测试自定义-starter">3. 测试自定义 starter</h3><p>创建个Module: debugStarter，来测试自定义的 stater：</p><ol type="1"><li>pom.xml:</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debuggingWorld<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>debuggingWorld_spring_boot_starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>application.properties:</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">debuggingworld.hello.name</span>=<span class="hljs-string">debuggingWorld</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>访问</li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305082358805.png" /></p>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot——整合Druid&amp;MyBatis</title>
    <link href="/2023/04/27/Spring-Boot%E2%80%94%E2%80%94%E6%95%B4%E5%90%88Druid-MyBatis/"/>
    <url>/2023/04/27/Spring-Boot%E2%80%94%E2%80%94%E6%95%B4%E5%90%88Druid-MyBatis/</url>
    
    <content type="html"><![CDATA[<h3 id="整合-druid">1. 整合 Druid</h3><h4 id="原生整合">1.1 原生整合</h4><ol type="1"><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>application.yml 配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 数据源</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/debuggingworld?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br><br>    <span class="hljs-comment">#   数据源其他配置</span><br>    <span class="hljs-attr">initialSize:</span> <span class="hljs-number">5</span><br>    <span class="hljs-attr">minIdle:</span> <span class="hljs-number">5</span><br>    <span class="hljs-attr">maxActive:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">maxWait:</span> <span class="hljs-number">60000</span><br>    <span class="hljs-attr">timeBetweenEvictionRunsMillis:</span> <span class="hljs-number">60000</span><br>    <span class="hljs-attr">minEvictableIdleTimeMillis:</span> <span class="hljs-number">300000</span><br>    <span class="hljs-attr">validationQuery:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">DUAL</span><br>    <span class="hljs-attr">testWhileIdle:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">testOnBorrow:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">testOnReturn:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">poolPreparedStatements:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#   配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#x27;wall&#x27;用于防火墙</span><br>    <span class="hljs-attr">filters:</span> <span class="hljs-string">stat,wall</span><br>    <span class="hljs-attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">useGlobalDataSourceStat:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">connectionProperties:</span> <span class="hljs-string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br>    <span class="hljs-comment">#初始化时运行sql脚本</span><br>  <span class="hljs-attr">sql:</span><br>    <span class="hljs-attr">init:</span><br>      <span class="hljs-attr">schema-locations:</span> <span class="hljs-string">classpath:sql/schema.sql</span><br>      <span class="hljs-attr">mode:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></table></figure></li><li><p>配置类 DruidConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnProperty(&quot;spring.datasource.type&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidConfig</span> </span>&#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    @Bean</span><br><span class="hljs-comment">    // 自动绑定配置文件中 spring.datasource 开头的配置</span><br><span class="hljs-comment">    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br><span class="hljs-comment">    public DataSource dataSource()&#123;</span><br><span class="hljs-comment">        return new DruidDataSource();</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">(DataSourceProperties properties)</span></span>&#123;<br>        <span class="hljs-comment">// 根据配置动态构建一个 DataSource</span><br>        <span class="hljs-keyword">return</span> properties.initializeDataSourceBuilder().build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  监控台的servlet</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean&lt;StatViewServlet&gt; <span class="hljs-title">statViewServlet</span><span class="hljs-params">()</span> </span>&#123;<br>        ServletRegistrationBean&lt;StatViewServlet&gt; servletRegistrationBean = <span class="hljs-keyword">new</span> ServletRegistrationBean&lt;&gt;();<br>        servletRegistrationBean.setServlet(<span class="hljs-keyword">new</span> StatViewServlet());<br>        servletRegistrationBean.addUrlMappings(<span class="hljs-string">&quot;/druid/*&quot;</span>);<br>        <span class="hljs-comment">/* &lt;init-param&gt;</span><br><span class="hljs-comment">            &lt;param-name&gt;loginUsername&lt;/param-name&gt;</span><br><span class="hljs-comment">            &lt;param-value&gt;admin&lt;/param-value&gt;</span><br><span class="hljs-comment">        &lt;/init-param&gt; */</span><br>        <span class="hljs-comment">// 添加IP白名单</span><br>        servletRegistrationBean.addInitParameter(<span class="hljs-string">&quot;allow&quot;</span>, <span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>        <span class="hljs-comment">// 添加IP黑名单，当白名单和黑名单重复时，黑名单优先级更高</span><br>        <span class="hljs-comment">// servletRegistrationBean.addInitParameter(&quot;deny&quot;, &quot;127.0.0.1&quot;);</span><br>        <span class="hljs-comment">// 添加控制台管理用户</span><br>        servletRegistrationBean.addInitParameter(<span class="hljs-string">&quot;loginUsername&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>);<br>        servletRegistrationBean.addInitParameter(<span class="hljs-string">&quot;loginPassword&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-comment">// 是否能够重置数据</span><br>        servletRegistrationBean.addInitParameter(<span class="hljs-string">&quot;resetEnable&quot;</span>, <span class="hljs-string">&quot;false&quot;</span>);<br>        <span class="hljs-keyword">return</span> servletRegistrationBean;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 配置服务过滤器 :监控哪些访问</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回过滤器配置对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean&lt;WebStatFilter&gt; <span class="hljs-title">statFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        FilterRegistrationBean&lt;WebStatFilter&gt; filterRegistrationBean = <span class="hljs-keyword">new</span> FilterRegistrationBean&lt;&gt;();<br>        filterRegistrationBean.setFilter(<span class="hljs-keyword">new</span> WebStatFilter());<br><br>        <span class="hljs-comment">// 添加过滤规则</span><br>        filterRegistrationBean.addUrlPatterns(<span class="hljs-string">&quot;/*&quot;</span>);<br>        <span class="hljs-comment">// 忽略过滤格式</span><br>        filterRegistrationBean.addInitParameter(<span class="hljs-string">&quot;exclusions&quot;</span>, <span class="hljs-string">&quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*,&quot;</span>);<br>        <span class="hljs-keyword">return</span> filterRegistrationBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="通过启动器整合">1.2 通过启动器整合</h4><p>使用场景启动器无需配置，开箱即用。</p><ol type="1"><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/debuggingworld?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>    <span class="hljs-attr">druid:</span><br>      <span class="hljs-attr">stat-view-servlet:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>     <span class="hljs-comment"># 开启监控台</span><br>        <span class="hljs-attr">allow:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>        <span class="hljs-attr">login-username:</span> <span class="hljs-string">admin</span><br>        <span class="hljs-attr">login-password:</span> <span class="hljs-number">123456</span><br>      <span class="hljs-attr">web-stat-filter:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>     <span class="hljs-comment"># 开启过滤</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="整合-mybatis">2. 整合 MyBatis</h3><h4 id="生成-mybatis-代码">2.1 生成 MyBatis 代码</h4><p><ahref="https://debuggingworld.github.io/2022/12/28/Mybatis-Plus%E2%80%94%E2%80%94%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4-SQL%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BF%9D%E6%8A%A4-%E4%B9%90%E8%A7%82%E9%94%81-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/#6-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8">代码生成器</a></p><p><ahref="https://debuggingworld.github.io/2022/12/04/Mybatis%E2%80%94%E2%80%94%E2%80%94%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/#2-MyBatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B">MyBatis逆向工程</a></p><ol type="1"><li><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- Mybatis-Generator插件，自动生成代码 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configurationFile</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources/generatorConfig.xml<span class="hljs-tag">&lt;/<span class="hljs-name">configurationFile</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">verbose</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">verbose</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">overwrite</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">overwrite</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>                <span class="hljs-comment">&lt;!--必須要引入数据库驱动--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!--必须制定版本--&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>generatorConfig.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">generatorConfiguration</span> <span class="hljs-meta-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;simple&quot;</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3Simple&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressAllComments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--数据源 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/debuggingworld?serverTimezone=UTC&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;root&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/resources&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;XMLMAPPER&quot;</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Emp&quot;</span> <span class="hljs-attr">mapperName</span>=<span class="hljs-string">&quot;EmpMapper&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Dept&quot;</span> <span class="hljs-attr">mapperName</span>=<span class="hljs-string">&quot;DeptMapper&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>运行插件，生成代码</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304280051208.png" /></p></li></ol><h4 id="整合-mybatis-1">2.2 整合 Mybatis</h4><h5 id="整合方法">1. 整合方法</h5><ol type="1"><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置类：MybatisAutoConfiguration</p></li><li><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:com/debuggingWorld/mapper/*Mapper.xml</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.debuggingWorld.pojo</span><br></code></pre></td></tr></table></figure></li><li><p>启动类</p><p>添加 <span class="citation"data-cites="MapperScan">@MapperScan</span> 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.debuggingWorld.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(Application.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="mybatis-自动配置原理">2. MyBatis 自动配置原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.springframework.context.annotation.Configuration<br><span class="hljs-meta">@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)</span><br><span class="hljs-meta">@ConditionalOnSingleCandidate(DataSource.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(MybatisProperties.class)</span><br><span class="hljs-meta">@AutoConfigureAfter(DataSourceAutoConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisAutoConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-meta">@ConditionalOnMissingBean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">sqlSessionFactory</span><span class="hljs-params">(DataSource dataSource)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    SqlSessionFactoryBean factory = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();<br>    factory.setDataSource(dataSource);<br>    factory.setVfs(SpringBootVFS.class);<br>    <span class="hljs-comment">// 设置Mybaits的全局配置文件</span><br>    <span class="hljs-keyword">if</span> (StringUtils.hasText(<span class="hljs-keyword">this</span>.properties.getConfigLocation())) &#123;<br>      factory.setConfigLocation(<span class="hljs-keyword">this</span>.resourceLoader.getResource(<span class="hljs-keyword">this</span>.properties.getConfigLocation()));<br>    &#125;<br>    <span class="hljs-comment">// 另一种定制方式</span><br>    applyConfiguration(factory);<br>    <span class="hljs-comment">// 相当于mybatis全局配置文件中</span><br>    <span class="hljs-comment">/*&lt;properties&gt;</span><br><span class="hljs-comment">        &lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</span><br><span class="hljs-comment">    &lt;/properties&gt;*/</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.properties.getConfigurationProperties() != <span class="hljs-keyword">null</span>) &#123;<br>      factory.setConfigurationProperties(<span class="hljs-keyword">this</span>.properties.getConfigurationProperties());<br>    &#125;<br>    <span class="hljs-comment">// 就是配置插件‐拦截器 只需要配置一个实现了Interceptor的接口为Bean</span><br>    <span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(<span class="hljs-keyword">this</span>.interceptors)) &#123;<br>      factory.setPlugins(<span class="hljs-keyword">this</span>.interceptors);<br>    &#125;<br>    <span class="hljs-comment">// 设置数据库厂商id</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.databaseIdProvider != <span class="hljs-keyword">null</span>) &#123;<br>      factory.setDatabaseIdProvider(<span class="hljs-keyword">this</span>.databaseIdProvider);<br>    &#125;<br>    <span class="hljs-comment">// 设置别名：从application.yml中获取mybatis.typeAliasesPackage</span><br>    <span class="hljs-keyword">if</span> (StringUtils.hasLength(<span class="hljs-keyword">this</span>.properties.getTypeAliasesPackage())) &#123;<br>      factory.setTypeAliasesPackage(<span class="hljs-keyword">this</span>.properties.getTypeAliasesPackage());<br>    &#125;<br>    <span class="hljs-comment">// 可以通过父类过滤哪些类需要使用别名</span><br>    <span class="hljs-comment">// mybatis.typeAliasesSuperType: com.debuggingworld.pojo.basePojo</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.properties.getTypeAliasesSuperType() != <span class="hljs-keyword">null</span>) &#123;<br>      factory.setTypeAliasesSuperType(<span class="hljs-keyword">this</span>.properties.getTypeAliasesSuperType());<br>    &#125;<br>    <span class="hljs-comment">// 设置类型处理器</span><br>    <span class="hljs-comment">/*&lt;typeHandlers&gt;</span><br><span class="hljs-comment">        &lt;package name=&quot;&quot;/&gt;</span><br><span class="hljs-comment">    &lt;/typeHandlers&gt;*/</span><br>    <span class="hljs-keyword">if</span> (StringUtils.hasLength(<span class="hljs-keyword">this</span>.properties.getTypeHandlersPackage())) &#123;<br>      factory.setTypeHandlersPackage(<span class="hljs-keyword">this</span>.properties.getTypeHandlersPackage());<br>    &#125;<br>    <span class="hljs-comment">/*&lt;typeHandlers&gt;</span><br><span class="hljs-comment">        &lt;typeHandler handler=&quot;&quot; </span><br><span class="hljs-comment">    &lt;/typeHandlers&gt;*/</span><br>    <span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(<span class="hljs-keyword">this</span>.properties.resolveMapperLocations())) &#123;<br>      factory.setMapperLocations(<span class="hljs-keyword">this</span>.properties.resolveMapperLocations());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> factory.getObject();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>如果依然放不下 mybatis 全局配置文件， springboot 还是支持的：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">mybatis</span>:<span class="hljs-string"></span><br>  <span class="hljs-meta">config-location</span>: <span class="hljs-string">classpath:mybatis-config.xml</span><br></code></pre></td></tr></table></figure></li><li><p>mybatis-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--就是DOCTYPE后面对应的根节点--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--&lt;properties&gt;</span><br><span class="hljs-comment">        &lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</span><br><span class="hljs-comment">    &lt;/properties&gt;--&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- mybatis的设置选项  可以改变mybatis运行时行为--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>如果要设置 mybatis 的 settings 怎么设置呢？</p><ol type="1"><li><p>可以通过 mybatis 全局配置文件设置</p></li><li><p>也可以通过在 application.yml 中配置 configuration</p><p>configuration 封装 mybatis 所有信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p>定制 mybatis</p><ol type="1"><li>使用 mybatis 全局配置文件</li><li>可以使用 application.yml 中配置 configuration +ConfigurationCustomizer</li><li>要么使用 mybatis 的配置，要么使用 springboot 的配置，只能用一种</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyConfiguration</span><span class="hljs-params">(SqlSessionFactoryBean factory)</span> </span>&#123;<br>  Configuration configuration = <span class="hljs-keyword">this</span>.properties.getConfiguration();<br>  <span class="hljs-comment">// application.yml中没有配置configuration时为 null</span><br>  <span class="hljs-keyword">if</span> (configuration == <span class="hljs-keyword">null</span> &amp;&amp; !StringUtils.hasText(<span class="hljs-keyword">this</span>.properties.getConfigLocation())) &#123;<br>    <span class="hljs-comment">// 没有在application.yml中配置config-location才会 new</span><br>    configuration = <span class="hljs-keyword">new</span> Configuration();<br>  &#125;<br>  <span class="hljs-keyword">if</span> (configuration != <span class="hljs-keyword">null</span> &amp;&amp; !CollectionUtils.isEmpty(<span class="hljs-keyword">this</span>.configurationCustomizers)) &#123;<br>    <span class="hljs-keyword">for</span> (ConfigurationCustomizer customizer : <span class="hljs-keyword">this</span>.configurationCustomizers) &#123;<br>      customizer.customize(configuration);<br>    &#125;<br>  &#125;<br>  factory.setConfiguration(configuration);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li><p>ConfigurationCustomizer 方式配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfigurationCustomizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ConfigurationCustomizer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(Configuration configuration)</span> </span>&#123;<br>        configuration.setMapUnderscoreToCamelCase(<span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot——SpringBoot&amp;Servlet容器</title>
    <link href="/2023/04/25/Spring-Boot%E2%80%94%E2%80%94SpringBoot%E4%B8%8EServlet%E5%AE%B9%E5%99%A8/"/>
    <url>/2023/04/25/Spring-Boot%E2%80%94%E2%80%94SpringBoot%E4%B8%8EServlet%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>SpringBoot 默认的 Servlet 容器是：Tomcat</p><h3 id="嵌入式-servlet-容器配置修改">1. 嵌入式 Servlet 容器配置修改</h3><h4 id="通过全局配置文件修改">1.1 通过全局配置文件修改</h4><p>可以通过 server.xxx 来进行 web 服务配置，没有带服务器名称的则是通用配置，通过带了具体的服务器名称则是单独对该服务器进行设置，比如server.tomcat.xxx就是专门针对 tomcat 的配置。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8088</span><br><span class="hljs-meta">server.servlet.context-path</span>=<span class="hljs-string">/debugging</span><br></code></pre></td></tr></table></figure><p><ahref="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.server">（文档说明）</a></p><h4 id="通过-webserverfactorycustomizer-的-bean-修改">1.2 通过WebServerFactoryCustomizer 的 Bean 修改</h4><ul><li>修改 server.xxx 配置的相关内容</li><li>会跟配置文件形成互补</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomizationBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebServerFactoryCustomizer</span>&lt;<span class="hljs-title">ConfigurableServletWebServerFactory</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(ConfigurableServletWebServerFactory serverFactory)</span> </span>&#123;<br>        serverFactory.setPort(<span class="hljs-number">8088</span>);<br>        serverFactory.setContextPath(<span class="hljs-string">&quot;/debugging&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注册-servlet-三大组件">2. 注册 servlet 三大组件</h3><p>三大组件：servlet、listener、filter</p><h4 id="servlet3.0-规范提供的注解方式注册">2.1 servlet3.0规范提供的注解方式注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span><br><span class="hljs-meta">@WebListener</span><br><span class="hljs-meta">@WebFilter</span><br></code></pre></td></tr></table></figure><ol type="1"><li><p>声明 servlet 及映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(name = &quot;helloServlet&quot;, urlPatterns = &quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        PrintWriter writer = resp.getWriter();<br>        writer.println(<span class="hljs-string">&quot;hello debuggingWorld&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>添加 <span class="citation"data-cites="ServletComponentScan">@ServletComponentScan</span></p><p>加上 <span class="citation"data-cites="ServletComponentScan">@ServletComponentScan</span>才会扫描上面个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@ServletComponentScan</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(Application.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="springboot-提供的注册">2.2 SpringBoot 提供的注册</h4><p>使用 ServletRegistrationBean、FilterRegistrationBean 以及ServletListenerRegistrationBean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        PrintWriter writer = resp.getWriter();<br>        writer.println(<span class="hljs-string">&quot;hello BeanServlet&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServletRegistration</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean&lt;Servlet&gt; <span class="hljs-title">myServlet</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 声明一个servlet注册器Bean</span><br>        ServletRegistrationBean&lt;Servlet&gt; registrationBean = <span class="hljs-keyword">new</span> ServletRegistrationBean&lt;&gt;();<br>        <span class="hljs-comment">// 设置相应的servlet</span><br>        registrationBean.setServlet(<span class="hljs-keyword">new</span> BeanServlet());<br>        <span class="hljs-comment">// 设置名字</span><br>        registrationBean.setName(<span class="hljs-string">&quot;BeanServlet&quot;</span>);<br>        <span class="hljs-comment">// 添加映射规则</span><br>        registrationBean.addUrlMappings(<span class="hljs-string">&quot;/BeanServlet&quot;</span>);<br>        <span class="hljs-keyword">return</span> registrationBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="切换其他嵌入式-servlet-容器">3. 切换其他嵌入式 Servlet 容器</h3><p>Spring Boot 包含对嵌入式 Tomcat，Jetty 和 Undertow 服务器的支持</p><ul><li>tomcat（默认）</li><li>Jetty（socket）</li><li>Undertow（响应式）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--排除tomcat--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--jetty 依赖--&gt;</span><br><span class="hljs-comment">&lt;!--&lt;dependency&gt;</span><br><span class="hljs-comment">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="hljs-comment">    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;</span><br><span class="hljs-comment">&lt;/dependency&gt;--&gt;</span><br><br><span class="hljs-comment">&lt;!--undertow 依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="嵌入式-servlet-容器自动配置原理">4. 嵌入式 Servlet容器自动配置原理</h3><p>servlet 容器自动配置类：ServletWebServerFactoryAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfiguration</span><br><span class="hljs-meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="hljs-comment">// 只要依赖任意一个servlet容器都会存在该来ServletRequest</span><br><span class="hljs-meta">@ConditionalOnClass(ServletRequest.class)</span><br><span class="hljs-meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span><br><span class="hljs-comment">// 启用servet.xxx的所有的配置信息绑定到ServerProperties</span><br><span class="hljs-meta">@EnableConfigurationProperties(ServerProperties.class)</span><br><span class="hljs-meta">@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,</span><br><span class="hljs-meta">      ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,</span><br><span class="hljs-meta">      ServletWebServerFactoryConfiguration.EmbeddedJetty.class,</span><br><span class="hljs-meta">      ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServletWebServerFactoryAutoConfiguration</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="为什么可以根据配置的依赖自动使用对应的-servlet-容器">4.1为什么可以根据配置的依赖自动使用对应的 servlet 容器？</h4><ol type="1"><li><p>通过 <span class="citation" data-cites="Import">@Import</span>导入Embeddedxxxx</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,</span><br><span class="hljs-meta">      ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,</span><br><span class="hljs-meta">      ServletWebServerFactoryConfiguration.EmbeddedJetty.class,</span><br><span class="hljs-meta">      ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)</span><br></code></pre></td></tr></table></figure></li><li><p>每个 Embeddedxxxx 中都配置了相应的 <span class="citation"data-cites="ConditionalOnClass">@ConditionalOnClass</span>，会根据当前servlet 容器 start 依赖判断 classpath 是否存在对应的类，如果存在就使用对应的 servlet 容器。 比如 EmbeddedTomcat：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-comment">// 只要添加了tomcat的场景启动器 则该注解才会生效</span><br><span class="hljs-meta">@ConditionalOnClass(&#123; Servlet.class, Tomcat.class, UpgradeProtocol.class &#125;)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmbeddedTomcat</span> </span>&#123;<br><br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-function">TomcatServletWebServerFactory <span class="hljs-title">tomcatServletWebServerFactory</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">         ObjectProvider&lt;TomcatConnectorCustomizer&gt; connectorCustomizers,</span></span><br><span class="hljs-params"><span class="hljs-function">         ObjectProvider&lt;TomcatContextCustomizer&gt; contextCustomizers,</span></span><br><span class="hljs-params"><span class="hljs-function">         ObjectProvider&lt;TomcatProtocolHandlerCustomizer&lt;?&gt;&gt; protocolHandlerCustomizers)</span> </span>&#123;<br>      TomcatServletWebServerFactory factory = <span class="hljs-keyword">new</span> TomcatServletWebServerFactory();<br>      factory.getTomcatConnectorCustomizers()<br>            .addAll(connectorCustomizers.orderedStream().collect(Collectors.toList()));<br>      factory.getTomcatContextCustomizers()<br>            .addAll(contextCustomizers.orderedStream().collect(Collectors.toList()));<br>      factory.getTomcatProtocolHandlerCustomizers()<br>            .addAll(protocolHandlerCustomizers.orderedStream().collect(Collectors.toList()));<br>      <span class="hljs-keyword">return</span> factory;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果没有对应的 tomcat 场景启动器该注解就不会生效</p></li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304242235841.png" /></p><h4id="怎么根据配置文件中-server.xxx-和-webserverfactorycustomizer-设置-servlet-容器">4.2怎么根据配置文件中 server.xxx 和 WebServerFactoryCustomizer 设置 servlet容器？</h4><ol type="1"><li><p>Servlet 容器配置文件通用定制器</p><p>ServletWebServerFactoryAutoConfiguration#servletWebServerFactoryCustomizer：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ServletWebServerFactoryCustomizer <span class="hljs-title">servletWebServerFactoryCustomizer</span><span class="hljs-params">(ServerProperties serverProperties,</span></span><br><span class="hljs-params"><span class="hljs-function">  ObjectProvider&lt;WebListenerRegistrar&gt; webListenerRegistrars,</span></span><br><span class="hljs-params"><span class="hljs-function">  ObjectProvider&lt;CookieSameSiteSupplier&gt; cookieSameSiteSuppliers)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServletWebServerFactoryCustomizer(serverProperties,<br> webListenerRegistrars.orderedStream().collect(Collectors.toList()),<br> cookieSameSiteSuppliers.orderedStream().collect(Collectors.toList()));<br>&#125;<br></code></pre></td></tr></table></figure></p><p>ServletWebServerFactoryCustomizer：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServletWebServerFactoryCustomizer</span></span><br><span class="hljs-class">  <span class="hljs-keyword">implements</span> <span class="hljs-title">WebServerFactoryCustomizer</span>&lt;<span class="hljs-title">ConfigurableServletWebServerFactory</span>&gt;, <span class="hljs-title">Ordered</span> </span>&#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(ConfigurableServletWebServerFactory factory)</span> </span>&#123;<br>  PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties::getPort).to(factory::setPort);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties::getAddress).to(factory::setAddress);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties.getServlet()::getContextPath).to(factory::setContextPath);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties.getServlet()::getApplicationDisplayName).to(factory::setDisplayName);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties.getServlet()::isRegisterDefaultServlet).to(factory::setRegisterDefaultServlet);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties.getServlet()::getSession).to(factory::setSession);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties::getSsl).to(factory::setSsl);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties.getServlet()::getJsp).to(factory::setJsp);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties::getCompression).to(factory::setCompression);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties::getHttp2).to(factory::setHttp2);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties::getServerHeader).to(factory::setServerHeader);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties.getServlet()::getContextParameters).to(factory::setInitParameters);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties.getShutdown()).to(factory::setShutdown);<br>  <span class="hljs-keyword">for</span> (WebListenerRegistrar registrar : <span class="hljs-keyword">this</span>.webListenerRegistrars) &#123;<br> registrar.register(factory);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(<span class="hljs-keyword">this</span>.cookieSameSiteSuppliers)) &#123;<br> factory.setCookieSameSiteSuppliers(<span class="hljs-keyword">this</span>.cookieSameSiteSuppliers);<br>  &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>ServletWebServerFactoryCustomizer 实现了WebServerFactoryCustomizer，说明它也是定制 servlet 容器的。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304242259697.png" /></p><p>根据配置文件中 server.xxx 来进行定制 servlet 容器。</p></li><li><p>Tomcat 配置文件定制器</p></li></ol><p>ServletWebServerFactoryAutoConfiguration#tomcatServletWebServerFactoryCustomizer：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnClass(name = &quot;org.apache.catalina.startup.Tomcat&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> TomcatServletWebServerFactoryCustomizer <span class="hljs-title">tomcatServletWebServerFactoryCustomizer</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  ServerProperties serverProperties)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TomcatServletWebServerFactoryCustomizer(serverProperties);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TomcatServletWebServerFactoryCustomizer</span></span><br><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">WebServerFactoryCustomizer</span>&lt;<span class="hljs-title">TomcatServletWebServerFactory</span>&gt;, <span class="hljs-title">Ordered</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>根据配置文件中 servet.tomcat.xxxx 定制 servlet 容器。</p><p><strong>怎么让所有的 WebServerFactoryCustomizer Bean顺序调用的</strong></p><p>ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanPostProcessorsRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span>, <span class="hljs-title">BeanFactoryAware</span> </span>&#123;<br>   <span class="hljs-comment">// ....</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata,</span></span><br><span class="hljs-params"><span class="hljs-function">         BeanDefinitionRegistry registry)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory == <span class="hljs-keyword">null</span>) &#123;<br>         <span class="hljs-keyword">return</span>;<br>      &#125;<br>      registerSyntheticBeanIfMissing(registry, <span class="hljs-string">&quot;webServerFactoryCustomizerBeanPostProcessor&quot;</span>,<br>            WebServerFactoryCustomizerBeanPostProcessor.class,<br>            WebServerFactoryCustomizerBeanPostProcessor::<span class="hljs-keyword">new</span>);<br>      registerSyntheticBeanIfMissing(registry, <span class="hljs-string">&quot;errorPageRegistrarBeanPostProcessor&quot;</span>,<br>            ErrorPageRegistrarBeanPostProcessor.class, ErrorPageRegistrarBeanPostProcessor::<span class="hljs-keyword">new</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注册了：WebServerFactoryCustomizerBeanPostProcessor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebServerFactoryCustomizerBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span>, <span class="hljs-title">BeanFactoryAware</span> </span>&#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>      <span class="hljs-comment">// 判断当前创建的bean是不是WebServerFactory</span><br>      <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> WebServerFactory) &#123;<br>         postProcessBeforeInitialization((WebServerFactory) bean);<br>      &#125;<br>      <span class="hljs-keyword">return</span> bean;<br>   &#125;<br><br>   <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(WebServerFactory webServerFactory)</span> </span>&#123;<br>      <span class="hljs-comment">// 调用getCustomizers()</span><br>      LambdaSafe.callbacks(WebServerFactoryCustomizer.class, getCustomizers(), webServerFactory)<br>            .withLogger(WebServerFactoryCustomizerBeanPostProcessor.class)<br>            .invoke((customizer) -&gt; customizer.customize(webServerFactory));<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当对应 Embeddedxxxx 启用时， 就会在里面配置一个 WebServerFactory类型的一个 Bean, 负责创建对应的容器和启动。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304250105090.png" /></p><ol type="1"><li><p>调用 getCustomizers()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Collection&lt;WebServerFactoryCustomizer&lt;?&gt;&gt; getCustomizers() &#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.customizers == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-comment">// Look up does not include the parent context</span><br>      <span class="hljs-keyword">this</span>.customizers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(getWebServerFactoryCustomizerBeans());<br>      <span class="hljs-keyword">this</span>.customizers.sort(AnnotationAwareOrderComparator.INSTANCE);<br>      <span class="hljs-keyword">this</span>.customizers = Collections.unmodifiableList(<span class="hljs-keyword">this</span>.customizers);<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.customizers;<br>&#125;<br><br><span class="hljs-meta">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class="hljs-keyword">private</span> Collection&lt;WebServerFactoryCustomizer&lt;?&gt;&gt; getWebServerFactoryCustomizerBeans() &#123;<br>   <span class="hljs-keyword">return</span> (Collection) <span class="hljs-keyword">this</span>.beanFactory.getBeansOfType(WebServerFactoryCustomizer.class, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>).values();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>getWebServerFactoryCustomizerBeans() 就获取了所有实现了WebServerFactoryCustomizer 接口的 Bean。</p><p>此时会获取到自定义的、ServletWebServerFactoryCustomizer、TomcatServletWebServerFactoryCustomizer</p></li><li><p>在 invoke 方法中循环调用所有实现了 WebServerFactoryCustomizer接口的 Bean 的 customize 方法进行一一定制</p></li></ol><h4 id="嵌入式-servlet-容器是怎么启动的">4.3 嵌入式 servlet容器是怎么启动的</h4><p>自动配置中根据不同的依赖， 启动对应一个 Embeddedxxxx，然后配置一个对应的 servlet 容器工厂类， 比如tomcat:TomcatServletWebServerFactory。 在 springboot 应用启动的时候 ，就会调用容器 refresh 方法， onRefresh() --&gt; createWebServer() --&gt;getWebServer()， 创建 servlet 及启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> WebServer <span class="hljs-title">getWebServer</span><span class="hljs-params">(ServletContextInitializer... initializers)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.disableMBeanRegistry) &#123;<br>      Registry.disableRegistry();<br>   &#125;<br>   Tomcat tomcat = <span class="hljs-keyword">new</span> Tomcat();<br>   File baseDir = (<span class="hljs-keyword">this</span>.baseDirectory != <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">this</span>.baseDirectory : createTempDir(<span class="hljs-string">&quot;tomcat&quot;</span>);<br>   tomcat.setBaseDir(baseDir.getAbsolutePath());<br>   <span class="hljs-keyword">for</span> (LifecycleListener listener : <span class="hljs-keyword">this</span>.serverLifecycleListeners) &#123;<br>      tomcat.getServer().addLifecycleListener(listener);<br>   &#125;<br>   Connector connector = <span class="hljs-keyword">new</span> Connector(<span class="hljs-keyword">this</span>.protocol);<br>   connector.setThrowOnFailure(<span class="hljs-keyword">true</span>);<br>   tomcat.getService().addConnector(connector);<br>   customizeConnector(connector);<br>   tomcat.setConnector(connector);<br>   tomcat.getHost().setAutoDeploy(<span class="hljs-keyword">false</span>);<br>   configureEngine(tomcat.getEngine());<br>   <span class="hljs-keyword">for</span> (Connector additionalConnector : <span class="hljs-keyword">this</span>.additionalTomcatConnectors) &#123;<br>      tomcat.getService().addConnector(additionalConnector);<br>   &#125;<br>   prepareContext(tomcat.getHost(), initializers);<br>   <span class="hljs-keyword">return</span> getTomcatWebServer(tomcat);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> TomcatWebServer <span class="hljs-title">getTomcatWebServer</span><span class="hljs-params">(Tomcat tomcat)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TomcatWebServer(tomcat, getPort() &gt;= <span class="hljs-number">0</span>, getShutdown());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TomcatWebServer</span><span class="hljs-params">(Tomcat tomcat, <span class="hljs-keyword">boolean</span> autoStart, Shutdown shutdown)</span> </span>&#123;<br>   Assert.notNull(tomcat, <span class="hljs-string">&quot;Tomcat Server must not be null&quot;</span>);<br>   <span class="hljs-keyword">this</span>.tomcat = tomcat;<br>   <span class="hljs-keyword">this</span>.autoStart = autoStart;<br>   <span class="hljs-keyword">this</span>.gracefulShutdown = (shutdown == Shutdown.GRACEFUL) ? <span class="hljs-keyword">new</span> GracefulShutdown(tomcat) : <span class="hljs-keyword">null</span>;<br>   initialize();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> WebServerException </span>&#123;<br>   logger.info(<span class="hljs-string">&quot;Tomcat initialized with port(s): &quot;</span> + getPortsDescription(<span class="hljs-keyword">false</span>));<br>   <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.monitor) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>         addInstanceIdToEngineName();<br>         Context context = findContext();<br>         context.addLifecycleListener((event) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (context.equals(event.getSource()) &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) &#123;<br>               <span class="hljs-comment">// Remove service connectors so that protocol binding doesn&#x27;t</span><br>               <span class="hljs-comment">// happen when the service is started.</span><br>               removeServiceConnectors();<br>            &#125;<br>         &#125;);<br><br>         <span class="hljs-comment">// Start the server to trigger initialization listeners</span><br>         <span class="hljs-comment">// 启动tomcat</span><br>         <span class="hljs-keyword">this</span>.tomcat.start();<br><br>         rethrowDeferredStartupExceptions();<br>         ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());<br>         <br>         <span class="hljs-comment">// Unlike Jetty, all Tomcat threads are daemon threads. We create a</span><br>         <span class="hljs-comment">// blocking non-daemon to stop immediate shutdown</span><br>         startDaemonAwaitThread();<br>      &#125;<br>      <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>         stopSilently();<br>         destroySilently();<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> WebServerException(<span class="hljs-string">&quot;Unable to start embedded Tomcat&quot;</span>, ex);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="使用外部-servlet-容器">5. 使用外部 Servlet 容器</h3><ol type="1"><li><p>下载 tomcat 服务</p></li><li><p>设置当前 maven 项目的打包方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--默认是jar--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>排除 tomcat 依赖不参与打包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>Tomcat 支持 springboot</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TomcatStartSpringBoot</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SpringBootServletInitializer</span> </span>&#123;<br>    <span class="hljs-comment">// tomcat 启动的时候会调用 configure 方法，从而启动 SpringBoot</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title">configure</span><span class="hljs-params">(SpringApplicationBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> builder.sources(Application.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 idea 中运行</p></li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304252158486.png" /></p><h3 id="外部-servlet-容器启动-springboot-应用原理">6. 外部 Servlet容器启动 SpringBoot 应用原理</h3><p>Tomcat 不会主动去启动 springboot 应用 ，所以 tomcat启动的时候肯定调用了 SpringBootServletInitializer 的configure()，就会启动 springboot。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TomcatStartSpringBoot</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SpringBootServletInitializer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title">configure</span><span class="hljs-params">(SpringApplicationBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> builder.sources(Application.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>servlet3.0 规范官方文档： 8.2.4 节</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304252235673.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304252243192.png" /></p><p><ahref="https://debuggingworld.github.io/2022/11/06/SpringMVC%E2%80%94%E2%80%94%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#3-2-SPI%E6%96%B9%E5%BC%8F">SPI传送门</a></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304252303598.png" /></p><p>【注】 AbstractDispatcherServletInitializer 和AbstractContextLoaderInitializer 是用来注册 ContextLoaderListener 和DispatcherServlet 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @HandlesTypes 会将 WebApplicationInitializer 所有实现类传递到 onStartup()，包括上面的 </span><br><span class="hljs-meta">@HandlesTypes(WebApplicationInitializer.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringServletContainerInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContainerInitializer</span> </span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span></span><br><span class="hljs-function">         <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br><br>      List&lt;WebApplicationInitializer&gt; initializers = Collections.emptyList();<br><br>      <span class="hljs-keyword">if</span> (webAppInitializerClasses != <span class="hljs-keyword">null</span>) &#123;<br>         initializers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(webAppInitializerClasses.size());<br>         <span class="hljs-keyword">for</span> (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;<br>            <span class="hljs-comment">// 如果不是接口 不是抽象 跟WebApplicationInitializer有关系 就会实例化</span><br>            <span class="hljs-keyword">if</span> (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;<br>                  WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123;<br>                 initializers.add((WebApplicationInitializer)<br>                        ReflectionUtils.accessibleConstructor(waiClass).newInstance());<br>            &#125;<br>         &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (initializers.isEmpty()) &#123;<br>         servletContext.log(<span class="hljs-string">&quot;No Spring WebApplicationInitializer types detected on classpath&quot;</span>);<br>         <span class="hljs-keyword">return</span>;<br>      &#125;<br><br>      servletContext.log(initializers.size() + <span class="hljs-string">&quot; Spring WebApplicationInitializers detected on classpath&quot;</span>);<br>      <span class="hljs-comment">// 排序</span><br>      AnnotationAwareOrderComparator.sort(initializers);<br>      <span class="hljs-keyword">for</span> (WebApplicationInitializer initializer : initializers) &#123;<br>         <span class="hljs-comment">// 调用实例化对象的 onStartup()</span><br>         initializer.onStartup(servletContext);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SpringBootServletInitializer#onStartup：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(ServletContext servletContext)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>   servletContext.setAttribute(LoggingApplicationListener.REGISTER_SHUTDOWN_HOOK_PROPERTY, <span class="hljs-keyword">false</span>);<br>   WebApplicationContext rootApplicationContext = createRootApplicationContext(servletContext);<br>   <span class="hljs-keyword">if</span> (rootApplicationContext != <span class="hljs-keyword">null</span>) &#123;<br>      servletContext.addListener(<span class="hljs-keyword">new</span> SpringBootContextLoaderListener(rootApplicationContext, servletContext));<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title">createRootApplicationContext</span><span class="hljs-params">(ServletContext servletContext)</span> </span>&#123;<br>   SpringApplicationBuilder builder = createSpringApplicationBuilder();<br>   builder.main(getClass());<br>   ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);<br>   <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.logger.info(<span class="hljs-string">&quot;Root context already created (using as parent).&quot;</span>);<br>      servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="hljs-keyword">null</span>);<br>      builder.initializers(<span class="hljs-keyword">new</span> ParentContextApplicationContextInitializer(parent));<br>   &#125;<br>   builder.initializers(<span class="hljs-keyword">new</span> ServletContextApplicationContextInitializer(servletContext));<br>   builder.contextFactory((webApplicationType) -&gt; <span class="hljs-keyword">new</span> AnnotationConfigServletWebServerApplicationContext());<br>   <span class="hljs-comment">// 调用configure</span><br>   builder = configure(builder);<br>   builder.listeners(<span class="hljs-keyword">new</span> WebEnvironmentPropertySourceInitializer(servletContext));<br>   SpringApplication application = builder.build();<br>   <span class="hljs-keyword">if</span> (application.getAllSources().isEmpty()<br>         &amp;&amp; MergedAnnotations.from(getClass(), SearchStrategy.TYPE_HIERARCHY).isPresent(Configuration.class)) &#123;<br>      application.addPrimarySources(Collections.singleton(getClass()));<br>   &#125;<br>   Assert.state(!application.getAllSources().isEmpty(),<br>         <span class="hljs-string">&quot;No SpringApplication sources have been defined. Either override the &quot;</span><br>               + <span class="hljs-string">&quot;configure method or add an @Configuration annotation&quot;</span>);<br>   <span class="hljs-comment">// Ensure error pages are registered</span><br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.registerErrorPageFilter) &#123;<br>      application.addPrimarySources(Collections.singleton(ErrorPageFilterConfiguration.class));<br>   &#125;<br>   application.setRegisterShutdownHook(<span class="hljs-keyword">false</span>);<br>   <span class="hljs-keyword">return</span> run(application);<br>&#125;<br></code></pre></td></tr></table></figure><p>当调用 configure() 就会来到 TomcatStartSpringBoot.configure()。</p><ul><li><p>将 Springboot 启动类传入到 builder.source()，得到SpringApplicationBuilder。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title">configure</span><span class="hljs-params">(SpringApplicationBuilder builder)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> builder.sources(Application.class);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>builder.build() 就会根据传入的 Springboot启动类来构建一个SpringApplication。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> SpringApplication <span class="hljs-title">build</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>   configureAsChildIfNecessary(args);<br>   <span class="hljs-keyword">this</span>.application.addPrimarySources(<span class="hljs-keyword">this</span>.sources);<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.application;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>run(application) 就会启动 springboot 应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(SpringApplication application)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> (WebApplicationContext) application.run();<br>&#125;<br></code></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swagger</title>
    <link href="/2023/04/08/Swagger/"/>
    <url>/2023/04/08/Swagger/</url>
    
    <content type="html"><![CDATA[<h2 id="swagger2">1. Swagger2</h2><h3 id="使用">1.1 使用</h3><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(Application.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问：</p><p>http://localhost:8080/swagger-ui.html</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304090033563.png" /></p><p>【注】当的 spring-boot 版本是 2.6.x 的时候，项目启动会报错 Failed tostart bean 'documentationPluginsBootstrapper'; nested exception isjava.lang.NullPointerException</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304090038141.png" /></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mvc:</span><br>  <span class="hljs-attr">pathmatch:</span><br>    <span class="hljs-attr">matching-strategy:</span> <span class="hljs-string">ANT_PATH_MATCHER</span><br></code></pre></td></tr></table></figure><h3 id="配置">1.2 配置</h3><h4 id="基础信息配置">1. 基础信息配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Docket 是 Swagger 中的全局配置对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span></span>&#123;<br>    Docket docket = <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2);<br>    <span class="hljs-comment">// API文档描述信息</span><br>    ApiInfo apiInfo = <span class="hljs-keyword">new</span> ApiInfoBuilder()<br>            <span class="hljs-comment">// 文档主体信息</span><br>            .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">&quot;debuggingWorld文档&quot;</span>,<span class="hljs-string">&quot;https://debuggingworld.github.io&quot;</span>,<span class="hljs-string">&quot;admin@debug.com&quot;</span>))<br>            .title(<span class="hljs-string">&quot;debuggingWorld开发文档&quot;</span>)<br>            .description(<span class="hljs-string">&quot;debuggingWorld开发文档详细描述&quot;</span>)<br>            .version(<span class="hljs-string">&quot;2.1&quot;</span>)<br>            .build();<br>    docket.apiInfo(apiInfo);<br>    <span class="hljs-keyword">return</span> docket;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304090103163.png" /></p><h4 id="开关设置">2. 开关设置</h4><p>生产环境需要关闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).enable(<span class="hljs-keyword">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304092339074.png" /></p><h4 id="扫描包配置">3. 扫描包配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">docket<br>        .select()   <span class="hljs-comment">// 获取 Docket 中的选择器，返回 ApiSelectorBuilder 选择器构建器</span><br>        <span class="hljs-comment">// 设定扫描哪些包的注解</span><br>        .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.debuggingWorld.controller&quot;</span>)).build();<br></code></pre></td></tr></table></figure><h4 id="设置自定义注解不生成接口文档">4.设置自定义注解不生成接口文档</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@NotIncludeSwagger</span><br><span class="hljs-meta">@RequestMapping(&quot;/req&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">req</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;req&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">docket<br>        .select()   <span class="hljs-comment">// 获取 Docket 中的选择器，返回 ApiSelectorBuilder 选择器构建器</span><br>        <span class="hljs-comment">// 设定扫描哪些包的注解</span><br>        .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.debuggingWorld.controller&quot;</span>))<br>        <span class="hljs-comment">// 包含 NotIncludeSwagger 注解时不生成接口文档</span><br>        .apis(Predicates.not(RequestHandlerSelectors.withMethodAnnotation(NotIncludeSwagger.class))).build();;<br></code></pre></td></tr></table></figure><h4 id="路径范围配置">5. 路径范围配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">docket.select()<br>        <span class="hljs-comment">// 使用正则表达式约束生成接口文档的路径范围</span><br>        .paths(<br>                Predicates.or(<br>                        PathSelectors.regex(<span class="hljs-string">&quot;/debugging/.*&quot;</span>),<br>                        PathSelectors.regex(<span class="hljs-string">&quot;/debugging2/.*&quot;</span>)<br>                )).build();<br></code></pre></td></tr></table></figure><h3 id="常用注解">1.3 常用注解</h3><h4 id="api">1. Api</h4><p>作用域：类</p><p>属性：</p><ul><li>tags：给当前类定义别名，几个别名就在 UI中显示几个控制器访问菜单</li><li>description：当前类描述信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Api(tags = &#123;&quot;MyController&quot;, &quot;Swagger控制器&quot;&#125;,description = &quot;MyController 描述信息&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> </span>&#123;<br>    <span class="hljs-meta">@PostMapping(&quot;/debugging/post&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">post</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;post&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>UI 显示效果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304091110565.png" /></p><h4 id="apioperation">2. ApiOperation</h4><p>作用域：类、方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/debugging/post&quot;)</span><br><span class="hljs-meta">@ApiOperation(value = &quot;post 方法，用于数据新增&quot;,notes = &quot;MyController post 方法&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">post</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;post&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@PostMapping(&quot;/debugging/debug&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">debug</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;debug&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304091119092.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304091156831.png" /></p><h4 id="apiparam">3. ApiParam</h4><p>作用域：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ElementType.PARAMETER, ElementType.METHOD, ElementType.FIELD<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/debugging/post&quot;)</span><br><span class="hljs-meta">@ApiOperation(value = &quot;post 方法，用于数据新增&quot;, notes = &quot;MyController post 方法&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">post</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-meta">@ApiParam(name = &quot;用户名(name)&quot;, value = &quot;新增用户名称&quot;)</span> String name,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-meta">@ApiParam(name = &quot;密码(pwd)&quot;, value = &quot;新增用户密码&quot;)</span> String pwd)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;post&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@PostMapping(&quot;/debugging/debug&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">debug</span><span class="hljs-params">(String name, String pwd)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;debug&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304091204746.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304091207238.png" /></p><h4 id="apiignore">4. ApiIgnore</h4><p>作用域：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;ElementType.METHOD, ElementType.TYPE, ElementType.PARAMETER&#125;<br></code></pre></td></tr></table></figure><p>忽略当前方法或类型不生成接口文档。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiIgnore</span><br><span class="hljs-meta">@GetMapping(&quot;/debugging/get&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String name, String pwd)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;get&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="apiimplicitparam">5. ApiImplicitParam</h4><p>作用域：方法</p><p>参数说明：</p><ul><li>name：参数名</li><li>value：参数描述</li><li>required：是否必须参数</li><li>paramType：参数位置<ul><li>header：请求参数的获取 --&gt; <span class="citation"data-cites="RequestHeader">@RequestHeader</span></li><li>query：请求参数的获取 --&gt; <span class="citation"data-cites="RequestParam">@RequestParam</span>（get 方法默认值）</li><li>body ：请求参数的获取 --&gt;<span class="citation"data-cites="RequestBody">@RequestBody</span> （post 方法默认值）</li><li>path：请求参数的获取 --&gt; <span class="citation"data-cites="PathVariable">@PathVariable</span>（用于 restful 接口）</li><li>div</li><li>form</li></ul></li><li>dataType：参数类型，默认值：String</li><li>defaultValue：参数默认值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/debugging/debug&quot;)</span><br><span class="hljs-comment">//@ApiImplicitParam( name = &quot;name&quot;, value = &quot;新增用户名称&quot;,required = true,paramType = &quot;query&quot;,dataType = &quot;string&quot;)</span><br><span class="hljs-meta">@ApiImplicitParams(value = &#123;</span><br><span class="hljs-meta">        @ApiImplicitParam(name = &quot;name&quot;, value = &quot;新增用户名称&quot;, required = true, paramType = &quot;query&quot;, dataType = &quot;string&quot;),</span><br><span class="hljs-meta">        @ApiImplicitParam(name = &quot;pwd&quot;, value = &quot;新增用户密码&quot;, paramType = &quot;query&quot;, dataType = &quot;string&quot;)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">debug</span><span class="hljs-params">(String name, String pwd)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;debug&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304092309045.png" /></p><h4 id="apimodelapimodelproperty">6. ApiModel、ApiModelProperty</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 描述生成接口文档返回值类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@ApiModel(value = &quot;用户实体&quot;,description = &quot;保存用户数据&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserEntity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-meta">@ApiModelProperty(value = &quot;主键&quot;,name = &quot;主键(id)&quot;,required = false,example = &quot;1&quot;,hidden = true)</span><br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-meta">@ApiModelProperty(value = &quot;姓名&quot;,name = &quot;姓名(name)&quot;,required = true,example = &quot;debuggingWorld&quot;,hidden = false)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@ApiModelProperty(value = &quot;密码&quot;,name = &quot;密码(pwd)&quot;,required = true,example = &quot;admin&quot;,hidden = false)</span><br>    <span class="hljs-keyword">private</span> String pwd;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/debugging/user&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> UserEntity <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserEntity();<br>&#125;<br></code></pre></td></tr></table></figure><p>UI显示：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304091244743.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304091245156.png" /></p><h4 id="apiresponsesapiresponse">7. ApiResponses、ApiResponse</h4><p>描述响应信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/debugging/user/&#123;id&#125;&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;根据用户ID获取用户信息&quot;)</span><br><span class="hljs-meta">@ApiImplicitParam(name = &quot;id&quot;,value = &quot;用户编号&quot;,required = true,paramType = &quot;path&quot;)</span><br><span class="hljs-meta">@ApiResponses(&#123;</span><br><span class="hljs-meta">        @ApiResponse(code = 400,message = &quot;参数不合法&quot;),</span><br><span class="hljs-meta">        @ApiResponse(code = 410,message = &quot;获取用户信息失败&quot;),</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> UserEntity <span class="hljs-title">getUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String id)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserEntity(id,<span class="hljs-string">&quot;debuggingWorld&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304092326405.png" /></p><h2 id="swagger3">2. Swagger3</h2><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableOpenApi</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(Application.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问：</p><p>http://localhost:8080/swagger-ui/index.html</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304090014174.png" /></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swagger</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot——Web开发&amp;SpringMvc自动配置</title>
    <link href="/2023/04/06/Spring-Boot%E2%80%94%E2%80%94Web%E5%BC%80%E5%8F%91-SpringMvc%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/04/06/Spring-Boot%E2%80%94%E2%80%94Web%E5%BC%80%E5%8F%91-SpringMvc%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="springmvc-快速使用">1. SpringMVC 快速使用</h3><h4 id="基于-restful-接口的-crud">1.1 基于 restful 接口的 CRUD</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    UserService userService;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;User&gt; <span class="hljs-title">getUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> </span>&#123;<br>        User user = userService.getUserById(id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result&lt;&gt;(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;查询成功&quot;</span>, user);<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/add&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">addUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> </span>&#123;<br>        userService.add(user);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result&lt;&gt;(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;添加成功&quot;</span>, userService.getAllUser());<br>    &#125;<br><br>    <span class="hljs-meta">@PutMapping(&quot;/edit&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">editUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> </span>&#123;<br>        userService.update(user);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result&lt;&gt;(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;修改成功&quot;</span>, userService.getAllUser());<br>    &#125;<br><br>    <span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">deleteUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> </span>&#123;<br>        userService.delete(id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;删除成功&quot;</span>, userService.getAllUser());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="rest-接口调用">1.2 rest 接口调用</h4><h5 id="通过-resttemplate-调用">1. 通过 <strong>RestTemplate</strong>调用</h5><p>WebClient 也可以调用远程服务， 区别是 webclient 依赖 webflux ,webclient 请求远程服务是无阻塞的。 RestTemplate它是阻塞的，需要等待请求响应后才能执行下一句代码。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304070153213.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> RestTemplate restTemplate;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OrderController</span><span class="hljs-params">(RestTemplateBuilder restTemplateBuilder)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.restTemplate = restTemplateBuilder.build();<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/order&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 查询</span><br>        Result result = restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8080/user/&#123;id&#125;&quot;</span>, Result.class, <span class="hljs-number">1</span>);<br>        System.out.println(result);<br><br>        <br>        <span class="hljs-comment">// 增加</span><br>        <span class="hljs-comment">// object : post请求的参数</span><br>        <span class="hljs-comment">// Class&lt;T&gt;：返回的类型</span><br>        <span class="hljs-comment">// ...Object: 是@PathVariable占位符的参数</span><br>        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;QA&quot;</span>);<br>        ResponseEntity&lt;Result&gt; responseEntity = restTemplate.postForEntity(<span class="hljs-string">&quot;http://localhost:8080/user/add&quot;</span>, user, Result.class);<br>        <span class="hljs-comment">// 200 OK</span><br>        System.out.println(responseEntity.getStatusCode());<br>        <span class="hljs-comment">// 200</span><br>        System.out.println(responseEntity.getStatusCodeValue());<br>        <span class="hljs-comment">// Result(code=200, message=添加成功, data=null)</span><br>        System.out.println(responseEntity.getBody());<br><br><br>        <span class="hljs-comment">// 修改</span><br>        User user1 = <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;QA&quot;</span>);<br>        <span class="hljs-comment">// put 没有返回值</span><br>        <span class="hljs-comment">// restTemplate.put(&quot;http://localhost:8080/user/edit&quot;,user1);</span><br>        HttpEntity&lt;User&gt; userHttpEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(user1);<br>        ResponseEntity&lt;Result&gt; response = restTemplate.exchange(<span class="hljs-string">&quot;http://localhost:8080/user/edit&quot;</span>, HttpMethod.PUT, userHttpEntity, Result.class);<br><br><br>        <span class="hljs-comment">//删除  delete无返回值</span><br>        ResponseEntity&lt;Result&gt; response1 = restTemplate.exchange(<span class="hljs-string">&quot;http://localhost:8080/user/&#123;id&#125;&quot;</span>, HttpMethod.DELETE, <span class="hljs-keyword">null</span>, Result.class, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> response1.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以在单元测试下使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationTest</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>        TestRestTemplate restTemplate = <span class="hljs-keyword">new</span> TestRestTemplate();<br>        ResponseEntity&lt;Result&gt; response = restTemplate.exchange(<span class="hljs-string">&quot;http://localhost:8080/user/&#123;id&#125;&quot;</span>, HttpMethod.DELETE, <span class="hljs-keyword">null</span>, Result.class, <span class="hljs-number">1</span>);<br><br>        System.out.println(response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【注】在当前服务中增加单元测试，并且需要启动当前服务。</p><h5 id="通过-mockmvc-测试">2. 通过 MockMvc 测试</h5><p>MockMvc 是由 spring-test 包提供，实现了对 Http请求的模拟，能够直接使用网络的形式，转换到 Controller的调用，使得测试速度快、不依赖网络环境。同时提供了一套验证的工具，结果的验证十分方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@AutoConfigureMockMvc</span>   <span class="hljs-comment">// 依赖junit5,如果没有该注解需要通过代码构建MockMvc</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockMvcTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    MockMvc mockMvc;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testMockMvcGet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 发起一个模拟请求，不依赖 web 服务，不需要启动 web 应用</span><br>        mockMvc.perform(<br>                        MockMvcRequestBuilders.get(<span class="hljs-string">&quot;/user/&#123;id&#125;&quot;</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment">// 发送 get 请求</span><br>                                .accept(MediaType.APPLICATION_JSON) <span class="hljs-comment">// 设置响应的文本类型</span><br>                        <span class="hljs-comment">// .param(name,value)   ?name=xx&amp;age=xx</span><br>                )<br>                <span class="hljs-comment">// 设置断言</span><br>                .andExpect(MockMvcResultMatchers.status().isOk())  <span class="hljs-comment">// 设置断言</span><br>                .andExpect(MockMvcResultMatchers.jsonPath(<span class="hljs-string">&quot;$.data.username&quot;</span>).value(<span class="hljs-string">&quot;zhangsan&quot;</span>))<br>                .andDo(MockMvcResultHandlers.print());<br>    &#125;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testMockMvcPost</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        String user = <span class="hljs-string">&quot;&#123;\&quot;username\&quot;:\&quot;debuggingWorld\&quot;,\&quot;address\&quot;:\&quot;aaa\&quot;&#125;&quot;</span>;<br><br>        mockMvc.perform(<br>                        MockMvcRequestBuilders.post(<span class="hljs-string">&quot;/user/add&quot;</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment">// 发送 get 请求</span><br>                                .accept(MediaType.APPLICATION_JSON) <span class="hljs-comment">// 设置响应文本类型</span><br>                                .contentType(MediaType.APPLICATION_JSON)    <span class="hljs-comment">// 设置请求文本类型</span><br>                                .content(user)  <span class="hljs-comment">// json 数据</span><br>                )<br>                <span class="hljs-comment">// 设置断言</span><br>                .andExpect(MockMvcResultMatchers.status().isOk())  <span class="hljs-comment">// 设置断言</span><br>                .andExpect(MockMvcResultMatchers.jsonPath(<span class="hljs-string">&quot;$.data.length()&quot;</span>).value(<span class="hljs-number">6</span>))<br>                .andDo(MockMvcResultHandlers.print());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果打印：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304081227011.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304081228536.png" /></p><h3 id="springmvc-自动配置原理">2. SpringMVC 自动配置原理</h3><p>Spring Boot 为 Spring MVC提供了自动配置，可与大多数应用程序完美配合。</p><p>自动配置在 Spring 的默认值之上添加了以下功能：</p><ul><li>Inclusion of <code>ContentNegotiatingViewResolver</code> and<code>BeanNameViewResolver</code> beans.</li><li>Support for serving static resources, including support forWebJars</li><li>Automatic registration of <code>Converter</code>,<code>GenericConverter</code>, and <code>Formatter</code> beans.</li><li>Support for <code>HttpMessageConverters</code></li><li>Automatic registration of <code>MessageCodesResolver</code></li><li>Static <code>index.html</code> support.</li><li>Automatic use of a <code>ConfigurableWebBindingInitializer</code>bean</li></ul><h4 id="自动配置视图解析器">2.1 自动配置视图解析器</h4><p>包含 ContentNegotiatingViewResolver 和 BeanNameViewResolver，都是SpringMVC 内置的视图解析器。</p><ol type="1"><li><p>ContentNegotiatingViewResolver</p><p>他并不会解析视图、而是委派给其他视图解析器进行解析。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">resolveViewName</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>   RequestAttributes attrs = RequestContextHolder.getRequestAttributes();<br>   Assert.state(attrs <span class="hljs-keyword">instanceof</span> ServletRequestAttributes, <span class="hljs-string">&quot;No current ServletRequestAttributes&quot;</span>);<br>   List&lt;MediaType&gt; requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());<br>   <span class="hljs-keyword">if</span> (requestedMediaTypes != <span class="hljs-keyword">null</span>) &#123;<br>   <span class="hljs-comment">// 获得所有匹配的视图</span><br>  List&lt;View&gt; candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);<br>   <span class="hljs-comment">// 获取最终的这个</span><br>  View bestView = getBestView(candidateViews, requestedMediaTypes, attrs);<br>  <span class="hljs-keyword">if</span> (bestView != <span class="hljs-keyword">null</span>) &#123;<br> <span class="hljs-keyword">return</span> bestView;<br>  &#125;<br>   &#125;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>委派给其他视图解析器进行解析：</p><p>ContentNegotiatingViewResolver#initServletContext</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initServletContext</span><span class="hljs-params">(ServletContext servletContext)</span> </span>&#123;<br>   Collection&lt;ViewResolver&gt; matchingBeans =<br> BeanFactoryUtils.beansOfTypeIncludingAncestors(obtainApplicationContext(), ViewResolver.class).values();<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewResolvers == <span class="hljs-keyword">null</span>) &#123;<br>  <span class="hljs-keyword">this</span>.viewResolvers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(matchingBeans.size());<br>  <span class="hljs-keyword">for</span> (ViewResolver viewResolver : matchingBeans) &#123;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != viewResolver) &#123;<br><span class="hljs-keyword">this</span>.viewResolvers.add(viewResolver);<br> &#125;<br>  &#125;<br>   &#125;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>BeanNameViewResolver</p><p>会根据 handler 方法返回的视图名称 (DebugView), 去 ioc容器中到到名字叫 DebugView 的一个 Bean，并且这个 bean 要实现 VIew接口.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/test&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;debugView&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugView</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">View</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContentType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-string">&quot;text/html&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">render</span><span class="hljs-params">(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        response.getWriter().print(<span class="hljs-string">&quot;Welcome to debuggingWorld&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="静态资源支持">2.2 静态资源支持</h4><p>支持提供静态资源，包括对 WebJars 的支持。</p><p>以前要访问 jpg、css、js 等这些静态资源文件，需要在 web.xml 配置 。在springboot不需要配置，只需要放在约定文件夹中就可以（<strong>约定大于配置</strong>）。</p><p>WebMvcAutoConfigurationAdapter#addResourceHandlers：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.resourceProperties.isAddMappings()) &#123;<br>      logger.debug(<span class="hljs-string">&quot;Default resource handling disabled&quot;</span>);<br>      <span class="hljs-keyword">return</span>;<br>   &#125;<br>   addResourceHandler(registry, <span class="hljs-string">&quot;/webjars/**&quot;</span>, <span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);<br>   addResourceHandler(registry, <span class="hljs-keyword">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;<br>      registration.addResourceLocations(<span class="hljs-keyword">this</span>.resourceProperties.getStaticLocations());<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.servletContext != <span class="hljs-keyword">null</span>) &#123;<br>         ServletContextResource resource = <span class="hljs-keyword">new</span> ServletContextResource(<span class="hljs-keyword">this</span>.servletContext, SERVLET_LOCATION);<br>         registration.addResourceLocations(resource);<br>      &#125;<br>   &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>WebJars</p><p>WebJars 就是将静态资源放在 jar包中进行访问。官网：https://www.webjars.org/</p><p>当访问 /webjars/** 时就会映射到classpath:/META-INF/resources/webjars/</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jquery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.6.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304192316598.png" /></p><p>http://127.0.0.1:8080/webjars/jquery/3.6.4/jquery.js ===&gt;/META-INF/resources/webjars/juqery/3.6.4/jquery.js</p></li><li><p>静态文件映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <span class="hljs-string">&quot;classpath:/META-INF/resources/&quot;</span>,<br>      <span class="hljs-string">&quot;classpath:/resources/&quot;</span>, <span class="hljs-string">&quot;classpath:/static/&quot;</span>, <span class="hljs-string">&quot;classpath:/public/&quot;</span> &#125;;<br><br><span class="hljs-keyword">private</span> String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;<br><br><span class="hljs-keyword">public</span> String[] getStaticLocations() &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.staticLocations;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>配置欢迎页</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Optional&lt;Resource&gt; <span class="hljs-title">getWelcomePage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 拿到上面静态资源地址</span><br>    String[] locations = getResourceLocations(<span class="hljs-keyword">this</span>.resourceProperties.getStaticLocations());<br>    <span class="hljs-comment">// 去里面找一个index.html的首页</span><br>    <span class="hljs-keyword">return</span> Arrays.stream(locations).map(<span class="hljs-keyword">this</span>::getIndexHtml).filter(<span class="hljs-keyword">this</span>::isReadable).findFirst();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="自动注册-convertergenericconverter-和-formatter">2.3 自动注册Converter，GenericConverter 和 Formatter</h4><h4 id="支持-httpmessageconverters">2.4 支持 HttpMessageConverters</h4><p>HttpMessageConverters 负责 http 请求和响应的报文处理。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304202247507.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfiguration(</span><br><span class="hljs-meta">      after = &#123; GsonAutoConfiguration.class, JacksonAutoConfiguration.class, JsonbAutoConfiguration.class &#125;)</span><br><span class="hljs-meta">@ConditionalOnClass(HttpMessageConverter.class)</span><br><span class="hljs-meta">@Conditional(NotReactiveWebApplicationCondition.class)</span><br><span class="hljs-meta">@Import(&#123; JacksonHttpMessageConvertersConfiguration.class, GsonHttpMessageConvertersConfiguration.class,</span><br><span class="hljs-meta">      JsonbHttpMessageConvertersConfiguration.class &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpMessageConvertersAutoConfiguration</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="自动注册-messagecodesresolver">2.5 自动注册MessageCodesResolver</h4><p>修改 4xx 错误下类型转换错误的错误代码。</p><p>默认格式：errorCode + "." + object name + "." + field例：typeMismatch.user.birthday</p><p>可以通过 spring.mvc.message-codes-resolver-format=POSTFIX_ERROR_CODE修改为：object name + "." + field + "." + errorCode</p><h4 id="静态-index.html-支持">2.6 静态 index.html 支持</h4><p>在 springboot 中可以直接返回 html 的视图</p><p>因为在自动 WebMvcAutoConfiguration 配置类配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> InternalResourceViewResolver <span class="hljs-title">defaultViewResolver</span><span class="hljs-params">()</span> </span>&#123;<br>   InternalResourceViewResolver resolver = <span class="hljs-keyword">new</span> InternalResourceViewResolver();<br>   resolver.setPrefix(<span class="hljs-keyword">this</span>.mvcProperties.getView().getPrefix());<br>   resolver.setSuffix(<span class="hljs-keyword">this</span>.mvcProperties.getView().getSuffix());<br>   <span class="hljs-keyword">return</span> resolver;<br>&#125;<br></code></pre></td></tr></table></figure><p>在配置文件中配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">spring.mvc.view.prefix</span>=<span class="hljs-string">/pages/</span><br><span class="hljs-meta">spring.mvc.view.suffix</span>=<span class="hljs-string">.html</span><br></code></pre></td></tr></table></figure><h4 id="自动使用-configurablewebbindinginitializer">2.7 自动使用ConfigurableWebBindingInitializer</h4><h3 id="定制-springmvc-的自动配置">3. 定制 SpringMvc 的自动配置</h3><p>SpringMVC的自动配置类：WebMvcAutoConfiguration</p><p>在大多数情况，SpringBoot 在自动配置中标记了很多 <spanclass="citation"data-cites="ConditionalOnMissingBean">@ConditionalOnMissingBean</span>(xxxxxxxxx.class)(如果容器中没有，当前的 <span class="citation"data-cites="bean">@bean</span> 才会生效）。只需要在自己的配置类中配置对应的一个 <span class="citation"data-cites="Bean">@Bean</span> 就可以覆盖默认自动配置。</p><h4 id="通过-webmvcconfigurer-进行扩展">3.1 通过 WebMvcConfigurer进行扩展</h4><h5 id="扩展拦截器">1. 扩展拦截器</h5><p>拦截器定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>    LocalDateTime begin;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        begin = LocalDateTime.now();<br>        log.info(<span class="hljs-string">&quot;当前请求：&quot;</span> + request.getRequestURI() + <span class="hljs-string">&quot; 开始时间：&quot;</span> + begin);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        LocalDateTime end = LocalDateTime.now();<br>        Duration between = Duration.between(begin, end);<br>        <span class="hljs-keyword">long</span> time = between.toMillis();<br>        log.info(<span class="hljs-string">&quot;当前请求：&quot;</span> + request.getRequestURI() + <span class="hljs-string">&quot; 执行时间：&quot;</span> + time + <span class="hljs-string">&quot;毫秒&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        <span class="hljs-comment">// 添加拦截器</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> TimeInterceptor())<br>                <span class="hljs-comment">// 拦截映射规则</span><br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>                <span class="hljs-comment">//设置排除的映射规则</span><br>                .excludePathPatterns(<span class="hljs-string">&quot;/pages/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="扩展全局-cors">2. 扩展全局 CORS</h5><p>CORS：跨域资源访问</p><p>全局 CORS 配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> </span>&#123;<br>        <span class="hljs-comment">// 映射跨域访问的接口</span><br>        registry.addMapping(<span class="hljs-string">&quot;/user/*&quot;</span>)<br>                <span class="hljs-comment">// 配置哪些来源可以跨域访问</span><br>                .allowedOrigins(<span class="hljs-string">&quot;http://127.0.0.1:8081&quot;</span>)<br>                <span class="hljs-comment">// 配置跨域访问的请求方法</span><br>                .allowedMethods(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;DELETE&quot;</span>, <span class="hljs-string">&quot;PUT&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>指定接口 CORS 配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-meta">@CrossOrigin</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">deleteUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> </span>&#123;<br>    userService.delete(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;删除成功&quot;</span>, userService.getAllUser());<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="webmvcconfigurer-原理">3. WebMvcConfigurer 原理</h5><p>实现 WebMvcConfigurer 接口既可以扩展 Mvc 实现， 又可以保留 SpringBoot的自动配置。</p><ol type="1"><li><p>SpringMVC 的自动配置类 WebMvcAutoConfiguration 中有一个内部类WebMvcAutoConfigurationAdapter，实现了 WebMvcConfigurer。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@Import(EnableWebMvcConfiguration.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123; WebMvcProperties.class, WebProperties.class &#125;)</span><br><span class="hljs-meta">@Order(0)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcAutoConfigurationAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span>, <span class="hljs-title">ServletContextAware</span> </span>&#123;<br>   <span class="hljs-comment">// ……</span><br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>导入了 EnableWebMvcConfiguration。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnableWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ResourceLoaderAware</span> </span>&#123;<br><span class="hljs-comment">// ……</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>EnableWebMvcConfiguration 父类 DelegatingWebMvcConfiguration实现：</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebMvcConfigurerComposite configurers = <span class="hljs-keyword">new</span> WebMvcConfigurerComposite();<br><br>   <span class="hljs-meta">@Autowired(required = false)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setConfigurers</span><span class="hljs-params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;<br> <span class="hljs-keyword">this</span>.configurers.addWebMvcConfigurers(configurers);<br>  &#125;<br>   &#125;<br><br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>将容器中所有实现了 WebMvcConfigurer 接口的 Bean 都自动注入进来，添加到 configurers 变量中。</p><p>添加到 delegates 委派器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addWebMvcConfigurers</span><span class="hljs-params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;<br>      <span class="hljs-keyword">this</span>.delegates.addAll(configurers);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>底层调用 WebMvcConfigurer 对应的方法时，就是拿到之前注入到delegates 的 WebMvcConfigurer，依次调用。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>   <span class="hljs-keyword">for</span> (WebMvcConfigurer delegate : <span class="hljs-keyword">this</span>.delegates) &#123;<br>  delegate.addInterceptors(registry);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p></li></ol><p><strong>添加了 <span class="citation"data-cites="EnableWebMvc">@EnableWebMvc</span> 就不会使用 SpringMVC自动配置类的默认配置了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Import(DelegatingWebMvcConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableWebMvc &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li><p>在 <span class="citation"data-cites="EnableWebMvc">@EnableWebMvc</span> 中引入DelegatingWebMvcConfiguration。</p><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>在 WebMvcAutoConfiguration 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfiguration(after = &#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span><br><span class="hljs-meta">      ValidationAutoConfiguration.class &#125;)</span><br><span class="hljs-meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span><br><span class="hljs-meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span><br><span class="hljs-meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcAutoConfiguration</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><span class="citation"data-cites="ConditionalOnMissingBean">@ConditionalOnMissingBean</span>(WebMvcConfigurationSupport.class)当容器中不存在 WebMvcConfigurationSupport 这个 Bean的时候当前自动配置类才会生效。正因为通过 <span class="citation"data-cites="EnableWebMvc">@EnableWebMvc</span> 导入了DelegatingWebMvcConfiguration 从而使自动配置类失效。</p></li></ol><h4 id="json-开发">3.2 Json 开发</h4><p>Spring Boot 提供了与三个 JSON 映射库的集成：</p><ul><li>Gson</li><li>Jackson（默认）</li><li>JSON-B</li></ul><h5 id="jsckson-的使用">1. jsckson 的使用</h5><ol type="1"><li><p><span class="citation"data-cites="JsonIgnore">@JsonIgnore</span></p><p>进行排除 json 序列化，标注在不需要序列化的属性上。</p></li><li><p><span class="citation"data-cites="JsonFormat">@JsonFormat</span></p><p>日期格式化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br></code></pre></td></tr></table></figure></li><li><p><span class="citation"data-cites="JsonInclude">@JsonInclude</span></p><p>复合条件序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JsonInclude(JsonInclude.Include.NON_EMPTY)</span><br></code></pre></td></tr></table></figure></li><li><p><span class="citation"data-cites="JsonProperty">@JsonProperty</span></p><p>设置别名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JsonProperty(&quot;name&quot;)</span><br></code></pre></td></tr></table></figure></li></ol><h5 id="jsoncomponent">2. <span class="citation"data-cites="JsonComponent">@JsonComponent</span></h5><p>根据自己的业务需求进行 json 的序列化和反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JsonComponent</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserJsonCustom</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Serializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JsonObjectSerializer</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serializeObject</span><span class="hljs-params">(User user, JsonGenerator jsonGen, SerializerProvider provider)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>            jsonGen.writeObjectField(<span class="hljs-string">&quot;id&quot;</span>, user.getId());<br>            jsonGen.writeObjectField(<span class="hljs-string">&quot;uname&quot;</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>);<br>            <span class="hljs-comment">// 根据需求自定义。如二次查询、根据不同的权限序列化不同的数据</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deserializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JsonObjectDeserializer</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> User <span class="hljs-title">deserializeObject</span><span class="hljs-params">(JsonParser jsonParser, DeserializationContext context, ObjectCodec codec, JsonNode tree)</span> </span>&#123;<br>            User user = <span class="hljs-keyword">new</span> User();<br>            user.setId(tree.findValue(<span class="hljs-string">&quot;id&quot;</span>).asInt());<br>            <span class="hljs-keyword">return</span> user;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="国际化">3.3 国际化</h4><h5 id="添加国际化资源文件">1. 添加国际化资源文件</h5><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304210103875.png" /></p><h5 id="配置-messageresource">2. 配置 messageResource</h5><ol type="1"><li>在 Springboot 中提供了 MessageSourceAutoConfiguration所以，我们不需要去配置 messageResource。</li></ol><p>​ MessageSourceAutoConfiguration 定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfiguration</span><br><span class="hljs-comment">// 如果自己配置了名字叫 messageSource 的 bean 就会用自定义的</span><br><span class="hljs-meta">@ConditionalOnMissingBean(name = AbstractApplicationContext.MESSAGE_SOURCE_BEAN_NAME, search = SearchStrategy.CURRENT)</span><br><span class="hljs-meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="hljs-comment">// @Conditional 自定义条件匹配 会传入一个实现了Condition接口的类——ResourceBundleCondition</span><br><span class="hljs-comment">// ResourceBundleCondition 会重写matches， 自定义匹配规则 ， 如果该方法返回true 就匹配成功</span><br><span class="hljs-meta">@Conditional(ResourceBundleCondition.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageSourceAutoConfiguration</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;<br>   String classOrMethodName = getClassOrMethodName(metadata);<br>   <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// getMatchOutcome 具体的匹配规则就在这个里面</span><br>      ConditionOutcome outcome = getMatchOutcome(context, metadata);<br>      logOutcome(classOrMethodName, outcome);<br>      recordEvaluation(context, classOrMethodName, outcome);<br>      <span class="hljs-keyword">return</span> outcome.isMatch();<br>   &#125;<br>   <span class="hljs-keyword">catch</span> (RuntimeException ex) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Error processing condition on &quot;</span> + getName(metadata), ex);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ConditionOutcome <span class="hljs-title">getMatchOutcome</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;<br>   <span class="hljs-comment">//  获取配置文件中spring.messages.basename ，默认值是：messages</span><br>   String basename = context.getEnvironment().getProperty(<span class="hljs-string">&quot;spring.messages.basename&quot;</span>, <span class="hljs-string">&quot;messages&quot;</span>);<br>   ConditionOutcome outcome = cache.get(basename);<br>   <span class="hljs-keyword">if</span> (outcome == <span class="hljs-keyword">null</span>) &#123;<br>      outcome = getMatchOutcomeForBasename(context, basename);<br>      cache.put(basename, outcome);<br>   &#125;<br>   <span class="hljs-keyword">return</span> outcome;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ConditionOutcome <span class="hljs-title">getMatchOutcomeForBasename</span><span class="hljs-params">(ConditionContext context, String basename)</span> </span>&#123;<br>   ConditionMessage.Builder message = ConditionMessage.forCondition(<span class="hljs-string">&quot;ResourceBundle&quot;</span>);<br>   <span class="hljs-keyword">for</span> (String name : StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(basename))) &#123;<br>      <span class="hljs-comment">//  根据messages获取 该类路径下的所有propeties的资源文件</span><br>      <span class="hljs-keyword">for</span> (Resource resource : getResources(context.getClassLoader(), name)) &#123;<br>         <span class="hljs-comment">// 只要basename的类路径下有资源文件就会匹配成功</span><br>         <span class="hljs-keyword">if</span> (resource.exists()) &#123;<br>            <span class="hljs-keyword">return</span> ConditionOutcome.match(message.found(<span class="hljs-string">&quot;bundle&quot;</span>).items(resource));<br>         &#125;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> ConditionOutcome.noMatch(message.didNotFind(<span class="hljs-string">&quot;bundle with basename &quot;</span> + basename).atAll());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>生效条件：</strong></p><ul><li><p>必须保证在类路径下的 messages 文件夹中有国际化的资源文件</p></li><li><p>或者通过 spring.messages.basename 配置资源文件位置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">spring.messages.basename</span>=<span class="hljs-string">i18n.message</span><br></code></pre></td></tr></table></figure></li><li><p>只要找到了国际化的属性资源文件那就会设置ConditionOutcome.match=true</p></li><li><p>当 ConditionOutcome.match=true 那么 <span class="citation"data-cites="Conditional">@Conditional</span>(ResourceBundleCondition.class)就匹配成功</p></li><li><p>一旦匹配成功那自动配置类就会生效，就会帮我们配置一个meesageSource</p></li></ul><h5 id="解析语言类型">3. 解析语言类型</h5><p>需要去解析请求头中的 accept-language 或者解析 url 参数中 ?local=</p><p>其实 WebMvcAutoConfiguration 类也帮我配置了一个解析请求头中的accept-language 的 localResolver。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean(name = DispatcherServlet.LOCALE_RESOLVER_BEAN_NAME)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> LocaleResolver <span class="hljs-title">localeResolver</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-comment">// 当配置spring.mvc.locale‐resolver=fiexd</span><br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.webProperties.getLocaleResolver() == WebProperties.LocaleResolver.FIXED) &#123;<br>      <span class="hljs-comment">// 就会使用配置文件中指定的本地化语言：spring.mvc.locale=en_US</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FixedLocaleResolver(<span class="hljs-keyword">this</span>.webProperties.getLocale());<br>   &#125;<br>   <span class="hljs-comment">// 默认就是使用 AcceptHeaderLocaleResolver 作为本地化解析器</span><br>   AcceptHeaderLocaleResolver localeResolver = <span class="hljs-keyword">new</span> AcceptHeaderLocaleResolver();<br>   <span class="hljs-comment">// spring.mvc.locale=en_US 作为默认的本地化语言</span><br>   localeResolver.setDefaultLocale(<span class="hljs-keyword">this</span>.webProperties.getLocale());<br>   <span class="hljs-keyword">return</span> localeResolver;<br>&#125;<br></code></pre></td></tr></table></figure><p>org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver#resolveLocale</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Locale <span class="hljs-title">resolveLocale</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<br>   Locale defaultLocale = getDefaultLocale();<br>   <span class="hljs-comment">//  当Accept‐Languag为null 才会使用使用配置文件中设置的locale:spring.mvc.locale</span><br>   <span class="hljs-keyword">if</span> (defaultLocale != <span class="hljs-keyword">null</span> &amp;&amp; request.getHeader(<span class="hljs-string">&quot;Accept-Language&quot;</span>) == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> defaultLocale;<br>   &#125;<br>   Locale requestLocale = request.getLocale();<br>   List&lt;Locale&gt; supportedLocales = getSupportedLocales();<br>   <span class="hljs-keyword">if</span> (supportedLocales.isEmpty() || supportedLocales.contains(requestLocale)) &#123;<br>      <span class="hljs-keyword">return</span> requestLocale;<br>   &#125;<br>   Locale supportedLocale = findSupportedLocale(request, supportedLocales);<br>   <span class="hljs-keyword">if</span> (supportedLocale != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> supportedLocale;<br>   &#125;<br>   <span class="hljs-keyword">return</span> (defaultLocale != <span class="hljs-keyword">null</span> ? defaultLocale : requestLocale);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="缓存本地语言">4. 缓存本地语言</h5><p>覆盖原有 localeResolver。因为自动配置类中的 localeResovler 它只会从accept-language 中解析。</p><p>从请求参数 locale 中获取并保存到 cookie 中。</p><p>http://127.0.0.1:8080/user/1?locale=en_US</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        <span class="hljs-comment">//添加国际化拦截器</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> LocaleChangeInterceptor()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LocaleResolver <span class="hljs-title">localeResolver</span><span class="hljs-params">()</span> </span>&#123;<br>        CookieLocaleResolver localeResolver = <span class="hljs-keyword">new</span> CookieLocaleResolver();<br>        <span class="hljs-comment">// 设置过期时间</span><br>        localeResolver.setCookieMaxAge(<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>);<br>        localeResolver.setCookieName(<span class="hljs-string">&quot;locale&quot;</span>);<br>        <span class="hljs-keyword">return</span> localeResolver;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="通过-messageresource-获取国际化信息">5. 通过 messageResource获取国际化信息</h5><p><strong>方法一：</strong></p><p>自动注入：MessageSource</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>MessageSource messageSource;<br><br><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;User&gt; <span class="hljs-title">getUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> </span>&#123;<br>    String message = messageSource.getMessage(<span class="hljs-string">&quot;user.query.success&quot;</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());<br>    User user = userService.getUserById(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result&lt;&gt;(<span class="hljs-number">200</span>, message, user);<br>&#125;<br></code></pre></td></tr></table></figure><p>****方法二：****</p><p>使用定义工具类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Utils</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ResourceBundleMessageSource messageSource;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HttpServletRequest request;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">(String code, String... args)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> messageSource.getMessage(code, args, request.getLocale());<br>    &#125;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMessageSource</span><span class="hljs-params">(ResourceBundleMessageSource messageSource)</span> </span>&#123;<br>        Utils.messageSource = messageSource;<br>    &#125;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRequest</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<br>        Utils.request = request;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="统一异常处理">3.4 统一异常处理</h4><h5 id="springboot-统一异常处理自动配置类-errormvcautoconfiguration">1.SpringBoot 统一异常处理自动配置类 ErrorMvcAutoConfiguration</h5><p>重要组件：</p><ul><li>DefaultErrorAttributes</li><li>BasicErrorController</li><li>DefaultErrorViewResolver 用来解析错误视图页面</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicErrorController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractErrorController</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>BasicErrorController 就是一个处理 /error 请求的一个控制器。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304212219807.png" /></p><p><strong>处理过程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicErrorController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractErrorController</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>   <span class="hljs-meta">@RequestMapping(produces = MediaType.TEXT_HTML_VALUE)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">errorHtml</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>      HttpStatus status = getStatus(request);<br>      Map&lt;String, Object&gt; model = Collections<br>            .unmodifiableMap(getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.TEXT_HTML)));<br>      response.setStatus(status.value());<br>      ModelAndView modelAndView = resolveErrorView(request, response, status, model);<br>      <span class="hljs-keyword">return</span> (modelAndView != <span class="hljs-keyword">null</span>) ? modelAndView : <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;error&quot;</span>, model);<br>   &#125;<br><br>   <span class="hljs-meta">@RequestMapping</span><br>   <span class="hljs-keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;<br>      HttpStatus status = getStatus(request);<br>      <span class="hljs-keyword">if</span> (status == HttpStatus.NO_CONTENT) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(status);<br>      &#125;<br>      Map&lt;String, Object&gt; body = getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.ALL));<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(body, status);<br>   &#125;<br><br>   <span class="hljs-meta">@ExceptionHandler(HttpMediaTypeNotAcceptableException.class)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">mediaTypeNotAcceptable</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<br>      HttpStatus status = getStatus(request);<br>      <span class="hljs-keyword">return</span> ResponseEntity.status(status).build();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="a-页面请求">a) 页面请求</h6><p>RequestMapping 的 produces 会解析请求中 Accept。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304212240653.png" /></p><p>如果是浏览器请求，则交给 errorHtml() 处理。</p><p>除了 text/html 的其他请求都会交给 error() 方法处理。</p><p><strong>错误视图解析过程：</strong></p><p>getErrorAttributes() 用来获取所需要的异常信息。</p><p>resolveErrorView 解析视图，会调用 DefaultErrorViewResolver 的resolveErrorView 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">resolveErrorView</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, HttpStatus status,</span></span><br><span class="hljs-params"><span class="hljs-function">      Map&lt;String, Object&gt; model)</span> </span>&#123;<br>   <span class="hljs-comment">// ErrorViewResolver 即为：DefaultErrorViewResolver  </span><br>   <span class="hljs-keyword">for</span> (ErrorViewResolver resolver : <span class="hljs-keyword">this</span>.errorViewResolvers) &#123;<br>      ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);<br>      <span class="hljs-keyword">if</span> (modelAndView != <span class="hljs-keyword">null</span>) &#123;<br>         <span class="hljs-keyword">return</span> modelAndView;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 视图查找顺序</span><br><span class="hljs-comment"> * /&lt;templates&gt;/error/404.&lt;ext&gt;</span><br><span class="hljs-comment"> * /&lt;static&gt;/error/404.html</span><br><span class="hljs-comment"> * /&lt;templates&gt;/error/4xx.&lt;ext&gt;</span><br><span class="hljs-comment"> * /&lt;static&gt;/error/4xx.html</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveErrorView</span><span class="hljs-params">(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model)</span> </span>&#123;<br>   <span class="hljs-comment">// 先根据具体状态码查找视图</span><br>   ModelAndView modelAndView = resolve(String.valueOf(status.value()), model);<br>   <span class="hljs-keyword">if</span> (modelAndView == <span class="hljs-keyword">null</span> &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123;<br>      <span class="hljs-comment">// 如果没找到则通过状态码系列找视图，如：4xx</span><br>      modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);<br>   &#125;<br>   <span class="hljs-keyword">return</span> modelAndView;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> ModelAndView <span class="hljs-title">resolve</span><span class="hljs-params">(String viewName, Map&lt;String, Object&gt; model)</span> </span>&#123;<br>   String errorViewName = <span class="hljs-string">&quot;error/&quot;</span> + viewName;<br>   <span class="hljs-comment">// 先在模板视图中找</span><br>   TemplateAvailabilityProvider provider = <span class="hljs-keyword">this</span>.templateAvailabilityProviders.getProvider(errorViewName,<br>         <span class="hljs-keyword">this</span>.applicationContext);<br>   <span class="hljs-keyword">if</span> (provider != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(errorViewName, model);<br>   &#125;<br>   <span class="hljs-comment">// 模板视图不存在则在静态资源中查找</span><br>   <span class="hljs-keyword">return</span> resolveResource(errorViewName, model);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> ModelAndView <span class="hljs-title">resolveResource</span><span class="hljs-params">(String viewName, Map&lt;String, Object&gt; model)</span> </span>&#123;<br>   <span class="hljs-keyword">for</span> (String location : <span class="hljs-keyword">this</span>.resources.getStaticLocations()) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>         Resource resource = <span class="hljs-keyword">this</span>.applicationContext.getResource(location);<br>         resource = resource.createRelative(viewName + <span class="hljs-string">&quot;.html&quot;</span>);<br>         <span class="hljs-keyword">if</span> (resource.exists()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-keyword">new</span> HtmlResourceView(resource), model);<br>         &#125;<br>      &#125;<br>      <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304212331263.png" /></p><p><strong>定制错误页面：</strong></p><p>在上图所示路径下的 /error 目录下添加模板视图或 html 页面即可。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304232216361.png" /></p><h6 id="b-ajax-请求">b) ajax 请求</h6><p>error() 方法用来处理 ajax 请求。</p><p><strong>解析过程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Map&lt;String, Object&gt; <span class="hljs-title">getErrorAttributes</span><span class="hljs-params">(HttpServletRequest request, ErrorAttributeOptions options)</span> </span>&#123;<br>   WebRequest webRequest = <span class="hljs-keyword">new</span> ServletWebRequest(request);<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.errorAttributes.getErrorAttributes(webRequest, options);<br>&#125;<br><br><span class="hljs-comment">// DefaultErrorAttributes#getErrorAttributes()</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getErrorAttributes</span><span class="hljs-params">(WebRequest webRequest, ErrorAttributeOptions options)</span> </span>&#123;<br>   Map&lt;String, Object&gt; errorAttributes = getErrorAttributes(webRequest, options.isIncluded(Include.STACK_TRACE));<br>   <span class="hljs-keyword">if</span> (!options.isIncluded(Include.EXCEPTION)) &#123;<br>      errorAttributes.remove(<span class="hljs-string">&quot;exception&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">if</span> (!options.isIncluded(Include.STACK_TRACE)) &#123;<br>      errorAttributes.remove(<span class="hljs-string">&quot;trace&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">if</span> (!options.isIncluded(Include.MESSAGE) &amp;&amp; errorAttributes.get(<span class="hljs-string">&quot;message&quot;</span>) != <span class="hljs-keyword">null</span>) &#123;<br>      errorAttributes.remove(<span class="hljs-string">&quot;message&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">if</span> (!options.isIncluded(Include.BINDING_ERRORS)) &#123;<br>      errorAttributes.remove(<span class="hljs-string">&quot;errors&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">return</span> errorAttributes;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304232237418.png" /></p><p>根据配置文件中的配置进行控制输出哪些属性：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304232307606.png" /></p><p><strong>定制异常返回：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/error&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomErrorController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractErrorController</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomErrorController</span><span class="hljs-params">(ErrorAttributes errorAttributes, List&lt;ErrorViewResolver&gt; errorViewResolvers)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(errorAttributes, errorViewResolvers);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理浏览器请求</span><br><span class="hljs-comment">     * 增加日志记录</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(produces = MediaType.TEXT_HTML_VALUE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">errorHtml</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>        HttpStatus status = getStatus(request);<br>        Map&lt;String, Object&gt; model = Collections<br>                .unmodifiableMap(getErrorAttributes(request, getErrorAttributeOptions()));<br>        response.setStatus(status.value());<br>        ModelAndView modelAndView = resolveErrorView(request, response, status, model);<br>        log.error(model.get(<span class="hljs-string">&quot;trace&quot;</span>).toString());<br>        <span class="hljs-keyword">return</span> (modelAndView != <span class="hljs-keyword">null</span>) ? modelAndView : <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;error&quot;</span>, model);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理 Ajax 请求</span><br><span class="hljs-comment">     * 增加日志</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">error</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<br>        HttpStatus status = getStatus(request);<br>        <span class="hljs-keyword">if</span> (status == HttpStatus.NO_CONTENT) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-number">204</span>, <span class="hljs-string">&quot;No Content&quot;</span>);<br>        &#125;<br>        Map&lt;String, Object&gt; body = getErrorAttributes(request, getErrorAttributeOptions());<br>        String code = body.get(<span class="hljs-string">&quot;status&quot;</span>).toString();<br>        String message = body.get(<span class="hljs-string">&quot;message&quot;</span>).toString();<br>        log.error(body.get(<span class="hljs-string">&quot;trace&quot;</span>).toString());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(Integer.valueOf(code), message);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> ErrorAttributeOptions <span class="hljs-title">getErrorAttributeOptions</span><span class="hljs-params">()</span> </span>&#123;<br>        ErrorAttributeOptions of = ErrorAttributeOptions.of(ErrorAttributeOptions.Include.MESSAGE,<br>                ErrorAttributeOptions.Include.STACK_TRACE,<br>                ErrorAttributeOptions.Include.EXCEPTION);<br>        <span class="hljs-keyword">return</span> of;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="controlleradivce">2. <span class="citation"data-cites="ControllerAdivce">@ControllerAdivce</span></h5><p><ahref="https://debuggingworld.github.io/2022/10/23/SpringMVC%E2%80%94%E2%80%94%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD-%E6%8B%A6%E6%88%AA%E5%99%A8-%E5%9B%BD%E9%99%85%E5%8C%96-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/#6-2-%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">（传送门）</a></p>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Debug Java</title>
    <link href="/2023/03/10/Debug-Java/"/>
    <url>/2023/03/10/Debug-Java/</url>
    
    <content type="html"><![CDATA[<h3 id="jvm基础jvm-gc原理jvm怎么实现回收内存">1. JVM基础，JVMGC原理，JVM怎么实现回收内存。</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111541537.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111549143.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111549172.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111547045.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111547940.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111548119.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111550112.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111550197.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111551186.png" /></p><h3 id="java事件机制包括哪三个部分分别介绍">2.Java事件机制包括哪三个部分？分别介绍</h3><p>1、事件。一般继承自 java.util.EventObject类，封装了事件源对象及跟事件相关的信息。</p><p>2、事件监听器。实现 java.util.EventListener接口,注册在事件源上,当事件源的属性或状态改变时,取得相应的监听器调用其内部的回调方法。</p><p>3、事件源。事件发生的地方，由于事件源的某项属性或状态发生了改变(比如BUTTON被单击、TEXTBOX的值发生改变等等)导致某项事件发生。换句话说就是生成了相应的事件对象。因为事件监听器要注册在事件源上,所以事件源类中应该要有盛装监听器的<ahref="https://cloud.tencent.com/product/tke?from=10680">容器</a>(List,Set等等)。</p><h3 id="说说你对spring的ioc是怎么理解的">3.说说你对Spring的IOC是怎么理解的?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111607640.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303112141854.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303112143183.png" /></p><h3 id="spring框架中都用到了哪些设计模式">4.Spring框架中都用到了哪些设计模式?</h3><p>https://blog.csdn.net/m0_71777195/article/details/126519893</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111610194.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111610293.png" /></p><h3 id="说说mybatis的优点和缺点">5. 说说MyBatis的优点和缺点</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111611294.png" /></p><h3id="当实体类中的属性名和表中的字段名不一样怎么办mybatis是如何进行分页的">6.当实体类中的属性名和表中的字段名不一样，怎么办?Mybatis是如何进行分页的?</h3><p>不一样：</p><p>https://blog.csdn.net/finally_vince/article/details/126546045</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111613392.png" /></p><p>分页：</p><p>https://blog.csdn.net/web13618542420/article/details/126112972</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111614280.png" /></p><h3 id="spring-boot的核心配置文件有哪几个它们的区别是什么">7. SpringBoot的核心配置文件有哪几个?它们的区别是什么?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111615301.png" /></p><h3 id="什么时候不要使用索引说说什么是-mvcc">8.什么时候不要使用索引?说说什么是 MVCC?</h3><p>https://blog.csdn.net/weixin_69101491/article/details/125604214</p><p>mvcc:https://blog.csdn.net/lans_g/article/details/124232192</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111616325.png" /></p><h3 id="mvcc可以为数据库解决什么问题说说mvcc的实现原理">9.MVCC可以为数据库解决什么问题?说说MVCC的实现原理</h3><p>https://blog.csdn.net/pengfei1990/article/details/128885596</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111617447.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303112213427.png" /></p><h3 id="mysql事务隔离级别">10. MySQL事务隔离级别?</h3><p>https://blog.csdn.net/qq_34222160/article/details/124483303</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111617342.png" /></p><h3 id="请说说mysql-数据库的锁">11. 请说说MySQL 数据库的锁?</h3><p>https://blog.csdn.net/TABE_/article/details/122351648</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111618448.png" /></p><h3 id="常用的线程池有哪些">12. 常用的线程池有哪些?</h3><p>https://www.modb.pro/db/136334</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111618451.png" /></p><h3 id="简述一下你对线程池的理解">13. 简述一下你对线程池的理解</h3><p>https://baijiahao.baidu.com/s?id=1710374344849036345&amp;wfr=spider&amp;for=pc</p><p>https://blog.csdn.net/qq_28772075/article/details/119486482</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111619457.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303112231715.png" /></p><ul><li>ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</li><li>ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务。</li><li>ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</li></ul><h3 id="java程序是如何执行的锁的优化机制了解吗">14.Java程序是如何执行的锁的优化机制了解吗?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111621472.png" /></p><h3 id="说说进程和线程的区别">15.说说进程和线程的区别?</h3><p>进程（Process）是操作系统分配资源的基本单位，一个进程拥有的资源有自己的堆、栈、虚存空间（页表）、文件描述符等信息。</p><p>线程（Thread）是操作系统能够进行运算调度的基本单位。它包含在进程中，是进程中的实际运行单位。</p><p>https://blog.csdn.net/zhaohuodian/article/details/126268051</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111621446.png" /></p><h3 id="产生死锁的四个必要条件">16.产生死锁的四个必要条件?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111622484.png" /></p><p>https://blog.csdn.net/wy749929317/article/details/124075683</p><h3 id="如何避免死锁">17. 如何避免死锁?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111622488.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111623501.png" /></p><h3 id="线程池核心线程数怎么设置呢">18. 线程池核心线程数怎么设置呢?</h3><p>https://blog.csdn.net/qq_33333654/article/details/127015385</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111623583.png" /></p><h3 id="在zookeeper中zxid是什么有什么作用">19.在Zookeeper中Zxid是什么，有什么作用?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111624850.png" /></p><p>https://www.jianshu.com/p/68b45694026c/</p><h3 id="讲解一下zookeeper的持久化机制">20讲解一下ZooKeeper的持久化机制</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303110037889.png" /></p><p>https://www.cnblogs.com/zhangwanhua/p/9145071.html</p><h3 id="zookeeper选举中投票信息的五元组是什么">21.Zookeeper选举中投票信息的五元组是什么?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303110908423.png" /></p><h3 id="说说zookeeper中的脑裂">22 说说Zookeeper中的脑裂?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303110913879.png" /></p><h3 id="zookeeper脑裂是什么原因导致的">23.Zookeeper脑裂是什么原因导致的?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303110915744.png" /></p><h3 id="zookeeper-是如何解决脑裂问题的">24. Zookeeper是如何解决脑裂问题的?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111031167.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111031923.png" /></p><h3 id="说说redis的线程模型">25 说说Redis的线程模型</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111034331.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111037000.png" /></p><h3 id="为什么redis需要把所有数据放到内存中">26.为什么Redis需要把所有数据放到内存中?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111038356.png" /></p><h3 id="redis-的同步机制了解是什么">27. Redis 的同步机制了解是什么?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111039369.png" /></p><h3 id="说一下redis有什么优点和缺点">29.说一下Redis有什么优点和缺点</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111042412.png" /></p><h3 id="redis缓存刷新策略有哪些">30 Redis缓存刷新策略有哪些?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111044057.png" /></p><h3 id="redis持久化方式有哪些以及有什么区别">31.Redis持久化方式有哪些?以及有什么区别?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111047462.png" /></p><h3 id="什么是三阶段提交">32. 什么是三阶段提交?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111048726.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111052118.png" /></p><h3 id="什么是补偿事务">33. 什么是补偿事务?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111058576.png" /></p><h3 id="消息队列是怎么实现的">34. 消息队列是怎么实现的?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111101620.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111111879.png" /></p><h3 id="那你说说sagas事务模型">35 那你说说Sagas事务模型</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111120515.png" /></p><h3 id="分布式id生成有几种方案">36. 分布式ID生成有几种方案?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111127561.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111129992.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111130600.png" /></p><h3 id="幂等解决方法有哪些">37. 幂等解决方法有哪些?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111139889.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111718138.png" /></p><h3 id="常见负载均衡算法有哪些">38. 常见负载均衡算法有哪些?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111142912.png" /></p><h3 id="你知道哪些限流算法">39. 你知道哪些限流算法?</h3><p>限流算法有四种常见算法：</p><p>计数器算法（固定窗口）</p><p>滑动窗口</p><p>漏桶算法</p><p>令牌桶算法</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111144434.png" /></p><p><strong>滑动窗口算法</strong></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111146938.png" /></p><p><strong>漏桶算法</strong></p><p>漏桶算法是访问请求到达时直接放入漏桶，如当前容量已达到上限（限流值），则进行丢弃（触发限流策略）。漏桶以固定的速率进行释放访问请求（即请求通过），直到漏桶为空</p><p><strong>令牌桶算法</strong></p><p>令牌桶算法是程序以r（r=时间周期/限流值）的速度向令牌桶中增加令牌，直到令牌桶满，请求到达时向令牌桶请求令牌，如获取到令牌则通过请求，否则触发限流策略</p><h3 id="简述一下什么是nginx它有什么优势和功能">40.简述一下什么是Nginx，它有什么优势和功能?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111153155.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111156194.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111156678.png" /></p><h3 id="nginx是如何处理一个http请求的呢">41.Nginx是如何处理一个HTTP请求的呢?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111159573.png" /></p><h3 id="section"></h3><h3 id="怎么实现动态感知服务下线的呢">44.怎么实现动态感知服务下线的呢?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111204888.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111205219.png" /></p><h3 id="dubbo负载均衡策略">45. Dubbo负载均衡策略?</h3><p>随机（默认）：随机来</p><p>轮训：一个一个来</p><p>活跃度：机器活跃度来负载</p><p>一致性 hash：落到同一台机器上</p><h3 id="dubbo容错策略">46. Dubbo容错策略</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111206957.png" /></p><h3 id="什么是hystrix它如何实现容错">47.什么是Hystrix?它如何实现容错?</h3><p>服务雪崩 多个微服务之间调用的时候，假设微服务 A 调用微服务 B 和微服务C,微服务 B 和微服务 C又调用其它的微服务,这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引|起系统崩溃,所谓的“雪崩效应”。</p><p>Hystrix Hystrix是一个用于处理分布式系统延迟和容错的开源库。在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等,Hystrix 能够保证在一个依赖出问题的情况下，不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111452301.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111452209.png" /></p><h3 id="什么是hystrix断路器我们需要它吗">48.什么是Hystrix断路器?我们需要它吗?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111454485.png" /></p><h3 id="说说rpc的实现原理">49. 说说RPC的实现原理</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111502184.png" /></p><h3 id="eureka自我保护机制是什么">50. eureka自我保护机制是什么?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111502543.png" /></p><h3 id="什么是ribbon">51. 什么是Ribbon?</h3><p>ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。feign默认集成了ribbon。</p><h3 id="什么是feigin它的优点是什么">52.什么是feigin?它的优点是什么?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111504764.png" /></p><h3 id="ribbon和feign的区别">53. Ribbon和Feign的区别?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111508787.png" /></p><h3 id="说说tcp与udp的区别以及各自的优缺点说一下">54.说说TCP与UDP的区别，以及各自的优缺点说一下</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111510707.png" /></p><h3 id="http和https的区别">55. HTTP和HTTPS的区别</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111511596.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111513623.png" /></p><h3 id="说说httptcpsocket的关系是什么">56.说说HTTP、TCP、Socket的关系是什么?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111515826.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111516182.png" /></p><h3 id="说一下http的长连接与短连接的区别">57.说一下HTTP的长连接与短连接的区别</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111517857.png" /></p><h3 id="tcp为什么要三次握手两次不行吗为什么">58.TCP为什么要三次握手，两次不行吗?为什么?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111521296.png" /></p><h3 id="说一下tcp粘包是怎么产生的怎么解决粘包问题的">59.说一下TCP粘包是怎么产生的?怎么解决粘包问题的?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111523803.png" /></p><h3 id="在git中你如何还原已经-push并公开的提交">60.在Git中，你如何还原已经 push并公开的提交?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111524374.png" /></p><h3 id="git-pull和git-fetch有什么区别">61. git pull和gitfetch有什么区别?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111526916.png" /></p><h3 id="git中的staging-area或index是什么">62. git中的"stagingarea"或"index"是什么?</h3><p>在完成提交之前，可以在称为“stagingarea”或“index”的中间区域中对其进行格式化和审查。每个更改首先在暂存区域中进行验证，我将其称为“stagefifile”，然后将更改提交到存储库。</p><h3 id="什么是-git-stash">63. 什么是 git stash?</h3><p>首先应该解释 git stash的必要性。通常情况下，当你一直在处理项目的某一部分时，如果你想要在某个时候切换分支去处理其他事情，事情会处于混乱的状态。问题是，你不想把完成了一半的工作的提交，以便你以后就可以回到当前的工作。解决这个问题的答案是git stash。</p><p>再解释什么是git stash。</p><p>stash会将你的工作目录，即修改后的跟踪文件和暂存的更改保存在一堆未完成的更改中，你可以随时重新应用这些更改</p><h3 id="什么是git-stash-drop">64. 什么是git stash drop?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111531991.png" /></p><h3 id="如何找到特定提交中已更改的文件列表">65.如何找到特定提交中已更改的文件列表?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303120918835.png" /></p><h3 id="git-config的功能是什么">66. git config的功能是什么?</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111533015.png" /></p><h3 id="kafka-可以脱离-zookeeper-单独使用吗为什么">67. kafka 可以脱离zookeeper 单独使用吗？为什么？</h3><p>kafka 不能脱离 zookeeper 单独使用，</p><p>因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p><h3 id="kafka-有几种数据保留的策略">68. kafka有几种数据保留的策略？</h3><p>按照过期时间保留和按照存储的消息大小保留。</p><h3id="kafka-同时设置了7天河10g清除数据到第五天的时候消息达到了-10g这个时候-kafka-将如何处理">69.kafka 同时设置了7天河10G清除数据，到第五天的时候消息达到了 10G，这个时候kafka 将如何处理？</h3><p>这个时候 kafka会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p><h3 id="什么情况会导致-kafka-运行变慢">70. 什么情况会导致 kafka运行变慢？</h3><p>cpu 性能瓶颈</p><p>磁盘读写瓶颈</p><p>网络瓶颈</p><h3 id="使用-kafka-集群需要注意什么">80. 使用 kafka集群需要注意什么？</h3><p>集群的数量不是越多越好，最好不要超过 7 个，</p><p>因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。</p><h3 id="rabbitmq-的使用场景有哪些">81. rabbitmq 的使用场景有哪些？</h3><p>https://www.yukx.com/jing/article/details/1892.html</p><h3 id="rabbitmq-有哪些重要的角色">82. rabbitmq 有哪些重要的角色？</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303112052141.png" /></p><h3 id="rabbitmq-有哪些重要的组件">83. rabbitmq 有哪些重要的组件？</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303112052803.png" /></p><h3 id="rabbitmq-中-vhost-的作用是什么">84. rabbitmq 中 vhost的作用是什么？</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303112055436.png" /></p><h3 id="rabbitmq-的消息是怎么发送的">85. rabbitmq的消息是怎么发送的？</h3><p>https://blog.csdn.net/CaptHua/article/details/123410556</p><h3 id="rabbitmq-怎么保证消息的稳定性">86. rabbitmq怎么保证消息的稳定性？</h3><h3 id="rabbitmq-怎么避免消息丢失">87. rabbitmq 怎么避免消息丢失？</h3><h3 id="要保证消息持久化成功的条件有哪些">88.要保证消息持久化成功的条件有哪些？</h3><h3 id="rabbitmq-持久化有什么缺点">89. rabbitmq 持久化有什么缺点？</h3><p>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用ssd 硬盘来缓解吞吐量的问题。</p><h3 id="rabbitmq-有几种广播类型">90. rabbitmq 有几种广播类型？</h3><h3 id="rabbitmq-怎么实现延迟消息队列">91. rabbitmq怎么实现延迟消息队列？</h3><h3 id="rabbitmq-集群有什么用">92. rabbitmq 集群有什么用？</h3><h3 id="rabbitmq-节点的类型有哪些">93. rabbitmq 节点的类型有哪些？</h3><h3 id="rabbitmq-集群搭建需要注意哪些问题">94. rabbitmq集群搭建需要注意哪些问题？</h3><h3 id="rabbitmq-每个节点是其他节点的完整拷贝吗为什么">95. rabbitmq每个节点是其他节点的完整拷贝吗？为什么？</h3><p>rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？ rabbitmq对集群节点停止顺序有要求吗？</p><h3 id="异常类-httpswww.yukx.comjingarticledetails1839.html">异常类https://www.yukx.com/jing/article/details/1839.html</h3><p>throw 和 throws 的区别？ final、finally、finalize 有什么区别？try-catch-finally 中哪个部分可以省略？ try-catch-finally 中，如果 catch中 return 了，finally 还会执行吗？ 常见的异常类有哪些？</p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot——日志</title>
    <link href="/2023/03/04/Spring-Boot%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97/"/>
    <url>/2023/03/04/Spring-Boot%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h3 id="日志框架发展史">1. 日志框架发展史</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303050009016.png" /></p><h4 id="log4j">1.1 Log4J</h4><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>log4j.properties 配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#trace&lt;debug&lt;info&lt;warn&lt;error&lt;fatal</span><br><span class="hljs-meta">log4j.rootLogger</span>=<span class="hljs-string">trace, stdout</span><br><span class="hljs-meta">log4j.appender.stdout</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-meta">log4j.appender.stdout.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="hljs-string">%d %p [%c] - %m%n</span><br></code></pre></td></tr></table></figure><p>使用样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.log4j.Logger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Log4JTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Logger logger = Logger.getLogger(Log4JTest.class);<br>        logger.info(<span class="hljs-string">&quot;test log4j&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="jul">1. 2 JUL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.logging.Logger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JULLog</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Logger logger = Logger.getLogger(JULLog.class.getName());<br>        logger.info(<span class="hljs-string">&quot;JUL log message&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="jcl-日志门面">1.3 JCL 日志门面</h4><p><strong>JCL + JUL</strong></p><p>JCL动态查找机制进行日志实例化，执行顺序为：commons­logging.properties­­­­&gt; 系统环境变量 ­­­­­­&gt; log4j ­­­&gt; jul­­­ &gt; simplelog ­­­­&gt; nooplog</p><p>JCL 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>commons-logging.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">org.apache.commons.logging.Log</span> = <span class="hljs-string">org.apache.commons.logging.impl.Jdk14Logger</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303050122033.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.logging.Log;<br><span class="hljs-keyword">import</span> org.apache.commons.logging.LogFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JCLTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Log log = LogFactory.getLog(JCLTest.class);<br>        <span class="hljs-comment">// class org.apache.commons.logging.impl.Jdk14Logger</span><br>        System.out.println(log.getClass());<br>        log.info(<span class="hljs-string">&quot;JUL + JCL test&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="slf4j-日志门面">1.4 slf4j 日志门面</h4><p><strong>slf4j + log4j</strong></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303050129334.png" /></p><p><strong>Slf4j与其他各种日志组件的桥接说明：</strong></p><table><thead><tr><th>jar包名</th><th>说明</th></tr></thead><tbody><tr><td><strong>slf4j-log4j12-1.7.13.jar</strong></td><td>Log4j1.2 版本的桥接器，你需要将 Log4j.jar 加入 Classpath</td></tr><tr><td>log4j-slf4j-impl.jar</td><td>Log4j2 版本的桥接器,还需要 log4j­api.jar、log4j­core.jar</td></tr><tr><td><strong>slf4j-jdk14-1.7.13.jar</strong></td><td>java.util.logging 的桥接器，Jdk 原生日志框架</td></tr><tr><td><strong>slf4j-nop-1.7.13.jar</strong></td><td>NOP桥接器，默默丢弃一切日志</td></tr><tr><td><strong>slf4j-simple-1.7.13.jar</strong></td><td>一个简单实现的桥接器，该实现输出所有事件到 System.err. 只有 Info以及高于该级别的消息被打印</td></tr><tr><td><strong>slf4j-jcl-1.7.13.jar</strong></td><td>Jakarta Commons Logging 的桥接器. 这个桥接器将 Slf4j 所有日志委派给Jcl</td></tr><tr><td><strong>logback-classic-1.0.13.jar(requireslogback-core-1.0.13.jar)</strong></td><td>Slf4j 的原生实现，Logback 直接实现了 Slf4j 的接口，因此使用 Slf4j 与Logback 的结合使用也意味更小的内存与计算开销</td></tr></tbody></table><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--slf4j-log4j 桥接器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Slf4jTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Logger logger = LoggerFactory.getLogger(Slf4jTest.class);<br>        <span class="hljs-comment">// class org.slf4j.impl.Log4jLoggerAdapter</span><br>        System.out.println(logger.getClass());<br>        logger.info(<span class="hljs-string">&quot;test slf4t&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="jcl或jul-转为slf4j">1.5 JCL或JUL 转为slf4j</h4><p>日志适配器</p><p><strong>JCL 到 slf4j：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.logging.Log;<br><span class="hljs-keyword">import</span> org.apache.commons.logging.LogFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JCLTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Log log = LogFactory.getLog(JCLTest.class);<br>        <span class="hljs-comment">// class org.apache.commons.logging.impl.SLF4JLocationAwareLog</span><br>        System.out.println(log.getClass());<br>        log.info(<span class="hljs-string">&quot;JUL + JCL test&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303082355849.png" /></p><h4 id="实践">1.6 实践</h4><h5 id="案例一">案例一</h5><p>log4j 和 log2j2 如何实现统一输出，这里就要用上 slf4j 的适配器，slf4j提供了各种各样的适配器，用来将某种日志框架委托给slf4j。其最明显的集成工作方式有如下:</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303090028996.png" /></p><p>将条件填入,根据应该选 log4j-over-slf4j 适配器。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202307180153316.png" /></p><p>ps：根据适配器工作原理的不同，被适配的日志框架并不是一定要删除！以上图为例，log4j这个日志框架删不删都可以，你只要能保证 log4j 的加载顺序在log4j-over-slf4j 后即可。因为 log4j-over-slf4j这个适配器的工作原理是，内部提供了和 log4j 一模一样的 api接口，因此你在程序中调用 log4j 的 api 的时候，你必须想办法让其走适配器的api。如果你删了 log4j 这个框架，那你程序里肯定是走 log4j-over-slf4j这个组件里的 api。如果不删 log4j，只要保证其在 classpth 里的顺序比 log4j前即可！</p><h5 id="案例二">案例二</h5><p><strong>如何让 spring 以 log4j2 的形式输出？</strong></p><p>spring 默认使用的是 jcl 输出日志，由于此时并没有引入 Log4j的日志框架，jcl 会以 jul 做为日志框架。此时集成图如下：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303090039045.png" /></p><p>而应用中，采用了 slf4j+log4j-core，即 log4j2进行日志记录，那么此时集成图如下：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303090040712.png" /></p><p>第一种方案，走 jcl-over-slf4j适配器，此时集成图就变成下面这样了：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303090042072.png" /></p><p>第二种方案，走 jul-to-slf4j 适配器：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303090045752.png" /></p><p>ps：这种情况下，记得在代码中执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">SLF4JBridgeHandler.removeHandlersForRootLogger();<br>SLF4JBridgeHandler.install();<br></code></pre></td></tr></table></figure><p>这样 jul-to-slf4j 适配器才能正常工作。</p><h3 id="springboot-日志">2. SpringBoot 日志</h3><h4 id="介绍">2.1 介绍</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304022319951.png" /></p><ol type="1"><li>SpringBoot 底层使用 slf4j+logback 的方式进行日志记录。</li></ol><ol type="a"><li>logback 桥接：logback-classic</li></ol><ol start="2" type="1"><li>SpringBoot 把其他的日志都适配成了 slf4j。</li></ol><ol type="a"><li>log4j 适配： log4j-over-slf4j</li><li>JUL 适配：jul-to-slf4j</li><li>这两个适配器都是为了适配 Spring 的默认日志：JCL</li></ol><h4 id="使用">2.2 使用</h4><h5 id="日志级别">1. 日志级别</h5><p>可以设置 TRACE，DEBUG，INFO，WARN，ERROR，FATAL 或 OFF 之一。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">root:</span> <span class="hljs-string">error</span><br>    <span class="hljs-attr">com:</span><br>      <span class="hljs-attr">debugingLog:</span> <span class="hljs-string">trace</span><br></code></pre></td></tr></table></figure><h5 id="日志格式">2. 日志格式</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">pattern:</span><br>    <span class="hljs-attr">console:</span> <span class="hljs-string">&quot;%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSXXX&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&quot;</span><br></code></pre></td></tr></table></figure><ul><li><p>%clr(%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-ddHH:mm:ss.SSS}}){faint}</p><p>日期和时间：毫秒精度，易于排序。</p><ul><li><p><font color="red"><strong>%clr</strong></font>(要显示的内容)<font color="red"><strong>{faint}</strong></font></p></li><li><p><font color="red"><strong>%d</strong></font>{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-ddHH:mm:ss.SSS}}</p><ul><li><p>%d logbak 的日期显示方式</p></li><li><p>${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS}</p><ul><li><p>${value:value2} springboot 的占位符 + null 条件的表达式（如果value 为 null 使用 value2)</p></li><li><p>LOG_DATEFORMAT_PATTERN: 系统环境变量中的值，springboot底层会根据对应的配置项将值设置到对应的环境变量中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(System.getProperty(<span class="hljs-string">&quot;LOG_DATEFORMAT_PATTERN&quot;</span>));<br></code></pre></td></tr></table></figure><p><ahref="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.logging.custom-log-configuration">（传送门）</a></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304040113085.png" /></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">pattern:</span><br>    <span class="hljs-attr">dateformat:</span> <span class="hljs-string">yyyy-MM-dd</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>%clr(${LOG_LEVEL_PATTERN:-%5p})</p><ul><li>日志级别：ERROR，WARN，INFO，DEBUG，或TRACE。</li><li>会根据不同的日志级别输出对应的颜色</li><li>%5 代表当前内容所占字符长度</li><li>p 输出日志事件的级别</li></ul></li><li><p>PID</p><ul><li>进程ID</li><li>PID 是系统环境变量中的进程ID（由系统分配）</li></ul></li></ul><h5 id="文件输出">3. 文件输出</h5><p>默认情况下，Spring Boot仅记录到控制台，不写日志文件。如果除了控制台输出外还想写日志文件，则需要设置一个logging.file.name 或 logging.file.path 属性。</p><table><thead><tr><th style="text-align: left;"><code>logging.file.name</code></th><th style="text-align: left;"><code>logging.file.path</code></th><th style="text-align: left;">Example</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr><td style="text-align: left;"><em>(none)</em></td><td style="text-align: left;"><em>(none)</em></td><td style="text-align: left;"></td><td style="text-align: left;">仅控制台记录</td></tr><tr><td style="text-align: left;">指定文件名</td><td style="text-align: left;"><em>(none)</em></td><td style="text-align: left;"><code>my.log</code></td><td style="text-align: left;">写入指定的日志文件</td></tr><tr><td style="text-align: left;"><em>(none)</em></td><td style="text-align: left;">具体目录</td><td style="text-align: left;"><code>/var/log</code></td><td style="text-align: left;">写入指定的目录下 spring.log 文件</td></tr></tbody></table><ul><li>logging.file.name<ul><li>可以设置文件的名称， 如果没有设置路径会默认在项目的相对路径下。</li><li>还可以指定路径+文件名：name: D:/debuggingWorld.log。</li></ul></li><li>logging.file.path<ul><li>不可以指定文件名称， 必须要指定一个物理文件夹路径，会使用默认文件名spring.log 。</li></ul></li></ul><h5 id="日志迭代轮转">4. 日志迭代（轮转）</h5><p>如果使用的是 Logback，则可以使用 applicationl文件微调日志轮播设置。对于所有其他日志记录系统，则需要直接自己配置轮转设置（例如，如果使用Log4J2，则可以添加 log4j.xml文件）。</p><table><thead><tr><th style="text-align: left;">名称</th><th style="text-align: left;">描述</th></tr></thead><tbody><tr><tdstyle="text-align: left;"><code>logging.logback.rollingpolicy.file-name-pattern</code></td><td style="text-align: left;">归档的文件名</td></tr><tr><tdstyle="text-align: left;"><code>logging.logback.rollingpolicy.clean-history-on-start</code></td><tdstyle="text-align: left;">如果应在应用程序启动时进行日志归档清理</td></tr><tr><tdstyle="text-align: left;"><code>logging.logback.rollingpolicy.max-file-size</code></td><td style="text-align: left;">归档前日志文件的最大大小</td></tr><tr><tdstyle="text-align: left;"><code>logging.logback.rollingpolicy.total-size-cap</code></td><td style="text-align: left;">删除日志档案之前可以使用的最大大小</td></tr><tr><tdstyle="text-align: left;"><code>logging.logback.rollingpolicy.max-history</code></td><td style="text-align: left;">保留日志存档的天数（默认为7）</td></tr></tbody></table><p>默认文件名：${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz</p><ul><li>${LOG_FILE} 对应 logging.file.name</li><li>%d{yyyy-MM-dd} 日期 年-月-日</li><li>%i 索引， 当文件超出指定大小后进行的文件索引递增</li></ul><h5 id="自定义日志配置文件">5. 自定义日志配置文件</h5><p>可以通过在类路径中包含适日志配置文件来激活各种日志记录系统或使用logging.config。</p><table><thead><tr><th style="text-align: left;">Logging System</th><th style="text-align: left;">Customization</th></tr></thead><tbody><tr><td style="text-align: left;">Logback</td><td style="text-align: left;"><code>logback-spring.xml</code>,<code>logback-spring.groovy</code>, <code>logback.xml</code>, or<code>logback.groovy</code></td></tr><tr><td style="text-align: left;">Log4j2</td><td style="text-align: left;"><code>log4j2-spring.xml</code> or<code>log4j2.xml</code></td></tr><tr><td style="text-align: left;">JDK (Java Util Logging)</td><td style="text-align: left;"><code>logging.properties</code></td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>如果使用自定义日志配置文件，会使 springboot 中全局配置文件的 logging相关配置失效。</li><li>结合 SpringBoot 提供 Profile 来控制日志的生效。<ul><li>注意： 一定要将日志配置文件的文件名改成 logback-spring.xml, 因为logback.xml 会在 Springboot 容器加载前先被 logback 给加载到， 那么由于logback 无法解析 springProfile 将会报错。</li></ul></li></ul><p>logback-spring.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;100&#125; ---- %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;!dev&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;100&#125; ===== %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--控制跟细粒度的日志级别  根据包\根据类--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.debuggingLog&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;TRACE&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 将当前日志级别输出到哪个追加器上面 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>引用配置文件中的配置项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--可以使用SpringBoot全局配置文件中的配置项--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">springProperty</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;context&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dateformat&quot;</span> <span class="hljs-attr">source</span>=<span class="hljs-string">&quot;logging.pattern.dateformat&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">&quot;-yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSXXX&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;$&#123;dateformat&#125;&#125; [%thread] %-5level %logger&#123;100&#125; ---- %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;!dev&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;$&#123;dateformat&#125;&#125; [%thread] %-5level %logger&#123;100&#125; ===== %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="切换日志框架">6. 切换日志框架</h5><p><strong>将 logback 切换成 log4j2：</strong></p><ol type="1"><li><p>将 logback 的场景启动器排除（slf4j 只能运行有 1 个桥接器）</p><p>排除前：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304060115010.png" /></p><p>排除前报错信息：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304060120660.png" /></p><p>排除：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--starter‐web里面自动添加 starter‐logging 也就是 logback 的依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--排除starter‐logging 也就是 logback 的依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>添加 log4j2 的场景启动器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>添加 log4j2 的配置文件</p><p>log4j2.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;OFF&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appenders</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appenders</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">loggers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">loggers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>将 logback 切换成 log4j</strong></p><ol type="1"><li><p>将 logback 的桥接器排除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>添加 log4j 的桥接器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>添加 log4j 的配置文件</p></li></ol><p>log4j.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#trace&lt;debug&lt;info&lt;warn&lt;error&lt;fatal</span><br><span class="hljs-meta">log4j.rootLogger</span>=<span class="hljs-string">trace, stdout</span><br><span class="hljs-meta">log4j.appender.stdout</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-meta">log4j.appender.stdout.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="hljs-string">%d %p [%c] - %m%n</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot——开始&amp;配置文件</title>
    <link href="/2023/02/16/Spring-Boot%E2%80%94%E2%80%94%E5%BC%80%E5%A7%8B-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <url>/2023/02/16/Spring-Boot%E2%80%94%E2%80%94%E5%BC%80%E5%A7%8B-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="快速搭建">1. 快速搭建</h3><h4 id="优点">1. 优点</h4><ul><li>快速构建一个独立的 Spring 应用程序 ；</li><li>嵌入的 Tomcat 、 Jetty 或者 Undertow，无须部署 WAR 文件；</li><li>提供 starter POMs 来简化 Maven 配置和减少版本冲突所带来的问题；</li><li>对 Spring和第三方库提供默认配置，也可修改默认值，简化框架配置；</li><li>提供生产就绪型功能，如指标、健康检查和外部配置；</li><li>无需配置 XML，无代码生成，开箱即用；</li></ul><p><strong>SpringCloud 带动了 SpringBoot ，SpringBoot 成就了SpringCloud。</strong></p><h4 id="hello-world">2. hello world</h4><p><strong>1. 添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">引入父Maven项目，继承父项目的所有配置信息</span><br><span class="hljs-comment">spring-boot-starter-parent 有引入父项目 spring-boot-dependencies，其中管理了第三方组件版本</span><br><span class="hljs-comment">导入依赖不需要写版本号，解决版本冲突问题（SpringBoot 仲裁中心）</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    starter 场景启动器</span><br><span class="hljs-comment">    不同的场景启动器维护了对应的所有依赖，从而简化maven依赖</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2. 创建控制器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/world&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">helloWorld</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. 编写启动类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Spring 在解析配置类的时候会去解析 <span class="hljs-doctag">@ComponentScan</span>,得到 basePackages</span><br><span class="hljs-comment"> * 如果没有配置，则会将当前类所在包当做扫描包</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(Application.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4. 运行访问</strong></p><p>直接运行 main 方法即可。</p><p>SpringBoot 项目默认没有项目名。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302212310742.png" /></p><p><strong>5. 修改配置</strong></p><p>src/main/resources/application.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8088</span><br><span class="hljs-meta">server.servlet.context-path</span>=<span class="hljs-string">/debugging</span><br></code></pre></td></tr></table></figure><p>访问路径：http://127.0.0.1:8088/debugging/hello/world</p><p><strong>6. 打包部署</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>将应用打成 jar 包，直接使用 java -jar 命令进行执行。</p><p><strong>7. 代码结构</strong></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302220025248.png" /></p><h4 id="使用spring-initializer项目">3. 使用Spring Initializer项目</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302220057383.png" /></p><p>默认生成的 Spring Boot 项目；</p><ul><li>主程序已经生成</li><li>resources 文件夹中目录结构<ul><li><strong>static</strong>：保存所有的静态资源； js css images；</li><li><strong>templates</strong>：保存所有的模板页面；（Spring Boot 默认jar 包使用嵌入式的 Tomcat，默认不支持 JSP 页面）；可以使用模板引擎（freemarker、thymeleaf）</li><li><strong>application.properties</strong>：Spring Boot应用的配置文件，可以修改一些默认设置。</li></ul></li></ul><h4 id="自定义-springapplication">4. 自定义 SpringApplication</h4><p>可以创建一个本地实例对 SpringApplication 默认值进行自定义。</p><p>例如要关闭横幅：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication application = <span class="hljs-keyword">new</span> SpringApplication(Application.class);<br>    application.setBannerMode(Banner.Mode.OFF);<br>    application.run(args);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过构造者模式流式构造 SpringApplication:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> SpringApplicationBuilder(Application.class).bannerMode(Banner.Mode.OFF).run(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置文件">2. 配置文件</h3><h4 id="配置文件介绍">1 配置文件介绍</h4><p>SringBoot使用一个全局的配置文件，配置文件名<strong>在约定的情况下</strong>是固定的；</p><p>配置文件的作用：修改 SpringBoot 自动配置的默认值；</p><ul><li>application.properties</li><li>application.yml</li><li>application.yaml</li></ul><h5 id="a.-配置文件格式">a. 配置文件格式：</h5><p>在 springboot 框架中，resource文件夹里可以存放配置的文件有两种：properties 和 yml。</p><p><strong>1、application.properties 的用法：扁平的 k/v格式</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8088</span><br><span class="hljs-meta">server.servlet.context-path</span>=<span class="hljs-string">/debugging</span><br></code></pre></td></tr></table></figure><p><strong>2、application.yml的用法：树型结构</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8088</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/debugging</span><br></code></pre></td></tr></table></figure><p>建议使用后者，因为它的可读性更强。</p><h5 id="b.-yml-基本语法">b. yml 基本语法</h5><p>k:(空格)v：表示一对键值对（空格必须有）；以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的；属性和值也是大小写敏感； 如果有特殊字符% &amp;记得用单引号（‘）包起来。</p><h5 id="c.-配置文件的加载顺序">c. 配置文件的加载顺序</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/application*.yml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/application*.yaml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/application*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="外部约定配置文件加载顺序">2. 外部约定配置文件加载顺序</h4><p>springboot 启动还会扫描以下位置的 application.properties 或者application.yml 文件作为 Spring boot的默认配置文件。优先级从低到高。</p><ol type="1"><li>optional:classpath:/</li><li>optional:classpath:/config/</li><li>optional:file:./</li><li>optional:file:./config/*/</li><li>optional:file:./config/</li><li>optional:classpath:custom‐config/ ‐‐spring.config.location</li><li>optional:file:./custom‐config/ ‐‐spring.config.location</li></ol><h5 id="classpath-根目录下">1. classpath 根目录下</h5><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302232307746.png" /></p><h5 id="classpath-的-config-下">2. classpath 的 config/ 下</h5><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302232148706.png" /></p><h5 id="项目根目录">3. 项目根目录</h5><p>如果当前项目是继承/耦合关系 maven 项目的话，项目根目录就是父 maven项目的根目录。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302232154752.png" /></p><h5 id="项目根目录-config">4. 项目根目录 /config</h5><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302232159781.png" /></p><p><font color="red"><strong>【注】以上高优先级的配置会覆盖低优先级的配置，互补配置。</strong></font></p><h5 id="直接子目录-config">5. 直接子目录 /config</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar debugSpringBoot-1.0-SNAPSHOT.jar  --spring.config.location=d:/config/<br>或<br>java -jar debugSpringBoot-1.0-SNAPSHOT.jar  --spring.config.name=application-dev<br></code></pre></td></tr></table></figure><p><font color="red"><strong>此种方式只会生效指定的配置，不会互补，配有指定的使用默认值。</strong></font></p><h4 id="profile-文件的加载">3. Profile 文件的加载</h4><p>SpringBoot 框架提供了多 profile 的管理功能，可以使用 profile功能来区分不同环境的配置。</p><h5 id="多profile文件">1. 多Profile文件</h5><p>语法：<strong>application-{profile}.properties（.yaml/.yml）</strong></p><p>开发环境（application-dev.yml）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8088</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/debugging</span><br></code></pre></td></tr></table></figure><p>生产环境（application-prod.yml）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/hello</span><br></code></pre></td></tr></table></figure><h5 id="激活指定-profile">2. 激活指定 profile</h5><ol type="1"><li>在配置文件中指定 spring.profiles.active=dev</li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302232234285.png" /></p><ol start="2" type="1"><li><p>命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar debugSpringBoot-1.0-SNAPSHOT.jar  --spring.profiles.active=dev<br></code></pre></td></tr></table></figure></li></ol><h4 id="配置文件读取方式">4. 配置文件读取方式</h4><p>优先级：低­­­ ---&gt; 高</p><h5 id="默认属性">1. 默认属性</h5><p>（通过设置指定 SpringApplication.setDefaultProperties）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        SpringApplication springApplication = <span class="hljs-keyword">new</span> SpringApplication(Application.class);<br><br>        InputStream inputStream = Application.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;app.properties&quot;</span>);<br>        Properties properties = <span class="hljs-keyword">new</span> Properties();<br>        properties.load(inputStream);<br><br>        springApplication.setDefaultProperties(properties);<br>        springApplication.run(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>会和约定的配置文件形成互补</strong></p><h5 id="propertysource-configuration-注解">2. <span class="citation"data-cites="PropertySource">@PropertySource</span> <spanclass="citation" data-cites="Configuration">@Configuration</span>注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PropertySource(&quot;classpath:appSource.properties&quot;)</span><br></code></pre></td></tr></table></figure><p><strong>会和约定的配置文件形成互补</strong></p><h5 id="配置数据">3. 配置数据</h5><p>（例如 application.properties 文件）</p><p><strong>约定配置文件</strong>（即 2.2 内容）</p><h5 id="操作系统环境变量">4. 操作系统环境变量</h5><p><strong>会使约定配置文件失效（1，2 手动配置的不会失效）</strong></p><p><strong>a. idea：</strong></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302251919809.png" /></p><p><strong>b. windows</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> spring.config.location=D:/config/<br><br>java -jar debugSpringBoot-1.0-SNAPSHOT.jar<br></code></pre></td></tr></table></figure><h5 id="java-系统属性">5. Java 系统属性</h5><p>（System.getProperties()）</p><p><strong>会使约定配置文件失效</strong></p><p><strong>a. idea：</strong></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302251931983.png" /></p><p><strong>b. windows</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar -Dspring.config.location=D:\config\ debugSpringBoot-1.0-SNAPSHOT.jar<br></code></pre></td></tr></table></figure><h5 id="jndi-属性-javacompenv">6. JNDI 属性 java:comp/env</h5><h5 id="servletcontext-初始化参数">7. ServletContext 初始化参数</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">ServletContext 的配置标签需要写到 web‐app （根标签）中<br>&lt;context‐param&gt;<br>    &lt;param‐name&gt;spring.config.location&lt;/param‐name&gt;<br>    &lt;param‐value&gt;xxx.properties&lt;/param‐value&gt;<br>&lt;/context‐param&gt;<br></code></pre></td></tr></table></figure><h5 id="servletconfig-初始化参数">8. ServletConfig 初始化参数</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">ServletConfig 的配置标签需要写到 Servlet 标签中<br>&lt;init‐param&gt;<br>    &lt;param‐name&gt;spring.config.location&lt;/param‐name&gt;<br>    &lt;param‐value&gt;xxx.properties&lt;/param‐value&gt;<br>&lt;/init‐param&gt;<br></code></pre></td></tr></table></figure><h5 id="命令行参数">9. 命令行参数</h5><p><strong>会使约定配置文件失效</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar debugSpringBoot-1.0-SNAPSHOT.jar  --spring.config.location=d:/config/<br></code></pre></td></tr></table></figure><h5 id="testpropertysource">10. <span class="citation"data-cites="TestPropertySource">@TestPropertySource</span></h5><p>用在单元测试上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@TestPropertySource(&quot;classpath:appSource.properties&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationTest</span> </span>&#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String port;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testPropertySource</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(port);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="配置文件值注入">3. 配置文件值注入</h3><h4 id="value">3.1 <span class="citation"data-cites="Value">@Value</span></h4><p>通过 <span class="citation" data-cites="Value">@Value</span> + SPEL直接绑定 springBoot 配置文件中的值。</p><p>application.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">userName:</span> <span class="hljs-string">debugging</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;user.userName&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-meta">@Value(&quot;$&#123;user.age&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer age;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="configurationproperties">3.2 <span class="citation"data-cites="ConfigurationProperties">@ConfigurationProperties</span></h4><p><span class="citation"data-cites="ConfigurationProperties">@ConfigurationProperties</span>常用于 bean 属性和 yaml 配置文件的绑定。prefix可以指定配置文件中的一个节点，该节点的子节点将自动和属性进行绑定，并且支持松散绑定。</p><p><strong>松散绑定：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">userName:</span> <span class="hljs-string">debugging</span><br><br><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">user-Name:</span> <span class="hljs-string">debugging</span><br>  <br><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">user_Name:</span> <span class="hljs-string">debugging</span><br>  <br><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">username:</span> <span class="hljs-string">debugging</span><br>  <br><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">USERNAME:</span> <span class="hljs-string">debugging</span><br></code></pre></td></tr></table></figure><p>导入配置文件处理器，配置文件进行绑定就会有提示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--会生成 META-INF 元数据，用于自动提示--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--依赖不进行传递--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302262010904.png" /></p><p>生成的 META-INF：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302262012540.png" /></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Date birthday;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; hobbies;<br>    <span class="hljs-keyword">private</span> Map&lt;String,String&gt; friends;<br>    <span class="hljs-keyword">private</span> Address address;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String desc;<br>&#125;<br></code></pre></td></tr></table></figure><p>application.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">USERNAME:</span> <span class="hljs-string">debugging</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br>  <span class="hljs-attr">birthday:</span> <span class="hljs-number">2020</span><span class="hljs-string">/2/22</span><br>  <span class="hljs-attr">hobbies:</span> [ <span class="hljs-string">aa</span>,<span class="hljs-string">bb</span> ]<br>  <span class="hljs-attr">friends:</span> &#123; <span class="hljs-string">aa:aaa</span>,<span class="hljs-string">bb:bbb</span> &#125;<br>  <span class="hljs-attr">address:</span><br>    <span class="hljs-attr">id:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">desc:</span> <span class="hljs-string">bbb</span><br><span class="hljs-comment">#  friends:</span><br><span class="hljs-comment">#    aa: aaa</span><br><span class="hljs-comment">#    bb: bbb</span><br><span class="hljs-comment">#  hobbies:</span><br><span class="hljs-comment">#    - aa</span><br><span class="hljs-comment">#    - bb</span><br></code></pre></td></tr></table></figure><p><strong><span class="citation" data-cites="Value">@Value</span>获取值和 <span class="citation"data-cites="ConfigurationProperties">@ConfigurationProperties</span>获取值比较：</strong></p><table><thead><tr><th></th><th><span class="citation"data-cites="ConfigurationProperties">@ConfigurationProperties</span></th><th><span class="citation" data-cites="Value">@Value</span></th></tr></thead><tbody><tr><td>绑定</td><td>批量注入配置文件中的属性</td><td>一个个指定</td></tr><tr><td>松散绑定（松散语法）</td><td>支持</td><td>支持有限</td></tr><tr><td>SpEL</td><td>不支持</td><td>支持</td></tr><tr><td>自动提示</td><td>支持</td><td>不支持</td></tr></tbody></table><h5 id="propertysource"><span class="citation"data-cites="PropertySource">@PropertySource</span></h5><p>加载指定的配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;user&quot;)</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:data/user.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Date birthday;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302280032528.png" /></p><h4 id="配置文件占位符">3.3 配置文件占位符</h4><h5 id="随机数">1. 随机数</h5><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302272336902.png" /></p><h5 id="值引用">2. 值引用</h5><p>占位符获取之前配置的值，如果没有可以是用:指定默认值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">user-name:</span> <span class="hljs-string">debugging</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br>  <span class="hljs-attr">birthday:</span> <span class="hljs-number">2020</span><span class="hljs-string">/2/22</span><br>  <span class="hljs-attr">address:</span><br>    <span class="hljs-attr">id:</span> <span class="hljs-string">$&#123;user.scoe:100&#125;</span><br>    <span class="hljs-attr">desc:</span> <span class="hljs-string">$&#123;user.user-name&#125;</span><br></code></pre></td></tr></table></figure><h4 id="配置文件注入值数据校验">3.4 配置文件注入值数据校验</h4><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加校验注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;user&quot;)</span><br><span class="hljs-meta">@Validated</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@NotNull</span><br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Date birthday;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302280015019.png" /></p><p>【注】：</p><ul><li><span class="citation" data-cites="Validated">@Validated</span>需要使用在 <span class="citation"data-cites="ConfigurationProperties">@ConfigurationProperties</span>标注的类上。</li><li>校验注解使用 JSR-303 javax.validation 下的注解</li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302280007791.png" /></p>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper——典型使用场景实战</title>
    <link href="/2023/02/13/Zookeeper%E2%80%94%E2%80%94%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AE%9E%E6%88%98/"/>
    <url>/2023/02/13/Zookeeper%E2%80%94%E2%80%94%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p>命名服务是为系统中的资源提供标识能力。ZooKeeper 的命名服务主要是利用ZooKeeper节点的树形分层结构和子节点的顺序维护能力，来为分布式系统中的资源命名。</p><p>哪些应用场景需要用到分布式命名服务呢？典型的有：</p><ul><li>分布式API目录</li><li>分布式节点命名</li><li>分布式ID生成器</li></ul><h3 id="分布式api目录">1. 分布式API目录</h3><p>为分布式系统中各种 API 接口服务的名称、链接地址，提供类似JNDI（Java命名和目录接口）中的文件系统的功能。借助于 ZooKeeper的树形分层结构就能提供分布式的 API 调用功能。</p><p>著名的 Dubbo 分布式框架就是应用了 ZooKeeper 的分布式的 JNDI 功能。在Dubbo 中，使用 ZooKeeper 维护的全局服务接口 API的地址列表。大致的思路为：</p><ul><li>服务提供者（Service Provider）在启动的时候，向 ZooKeeper上的指定节点 /dubbo/${serviceName}/providers 写入自己的 API地址，这个操作就相当于服务的公开。</li><li>服务消费者（Consumer）启动的时候，订阅节点/dubbo/{serviceName}/providers 下的服务提供者的 URL地址，获得所有服务提供者的 API。</li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302132109236.png" /></p><h3 id="分布式节点的命名">2. 分布式节点的命名</h3><p>一个分布式系统通常会由很多的节点组成，节点的数量不是固定的，而是不断动态变化的。比如说，当业务不断膨胀和流量洪峰到来时，大量的节点可能会动态加入到集群中。而一旦流量洪峰过去了，就需要下线大量的节点。再比如说，由于机器或者网络的原因，一些节点会主动离开集群。</p><p>如何为大量的动态节点命名呢？一种简单的办法是可以通过配置文件，手动为每一个节点命名。但是，如果节点数据量太大，或者说变动频繁，手动命名则是不现实的，这就需要用到分布式节点的命名服务。</p><p>可用于生成集群节点的编号的方案：</p><p>（1）使用数据库的自增 ID 特性，用数据表存储机器的 MAC 地址或者 IP来维护。</p><p>（2）使用 ZooKeeper 持久顺序节点的顺序特性来维护节点的 NodeId编号。</p><p>在第2种方案中，集群节点命名服务的基本流程是：</p><ul><li>启动节点服务，连接ZooKeeper，检查命名服务根节点是否存在，如果不存在，就创建系统的根节点。</li><li>在根节点下创建一个临时顺序 ZNode 节点，取回 ZNode的编号把它作为分布式系统中节点的 NODEID。</li><li>如果临时节点太多，可以根据需要删除临时顺序 ZNode 节点。</li></ul><h3 id="分布式的id生成器">3. 分布式的ID生成器</h3><p>在分布式系统中，分布式 ID 生成器的使用场景非常之多：</p><ul><li>大量的数据记录，需要分布式 ID。</li><li>大量的系统消息，需要分布式 ID。</li><li>大量的请求日志，如 restful的操作记录，需要唯一标识，以便进行后续的用户行为分析和调用链路分析。</li><li>分布式节点的命名服务，往往也需要分布式 ID。</li><li>。。。</li></ul><p>传统的数据库自增主键已经不能满足需求。在分布式系统环境中，迫切需要一种全新的唯一ID 系统，这种系统需要满足以下需求：</p><p>（1）全局唯一：不能出现重复 ID。</p><p>（2）高可用：ID生成系统是基础系统，被许多关键系统调用，一旦宕机，就会造成严重影响。</p><p>有哪些分布式的 ID 生成器方案呢？大致如下：</p><ol type="1"><li>Java 的 UUID。</li><li>分布式缓存 Redis 生成 ID：利用 Redis 的原子操作 INCR 和INCRBY，生成全局唯一的 ID。</li><li>Twitter 的 SnowFlake 算法。</li><li>ZooKeeper 生成 ID：利用 ZooKeeper 的顺序节点，生成全局唯一的ID。</li><li>MongoDb 的 ObjectId：MongoDB 是一个分布式的非结构化 NoSQL数据库，每插入一条记录会自动生成全局唯一的一个 “_id” 字段值，它是一个 12字节的字符串，可以作为分布式系统中全局唯一的 ID。</li></ol><h4 id="基于-zookeeper-实现分布式-id-生成器">1. 基于 Zookeeper实现分布式 ID 生成器</h4><p>在 ZooKeeper节点的四种类型中，其中有以下两种类型具备自动编号的能力</p><ul><li>PERSISTENT_SEQUENTIAL 持久化顺序节点。</li><li>EPHEMERAL_SEQUENTIAL 临时顺序节点。</li></ul><p>ZooKeeper的每一个节点都会为它的第一级子节点维护一份顺序编号，会记录每个子节点创建的先后顺序，这个顺序编号是分布式同步的，也是全局唯一的。</p><p>可以通过创建 ZooKeeper 的临时顺序节点的方法，生成全局唯一的 ID。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String  <span class="hljs-title">makeId</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    String str = createSeqNode(path);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> != str)&#123;<br>        <span class="hljs-comment">//获取末尾的序号</span><br>        <span class="hljs-keyword">int</span> index = str.lastIndexOf(path);<br>        <span class="hljs-keyword">if</span>(index&gt;=<span class="hljs-number">0</span>)&#123;<br>            index+=path.length();<br>            <span class="hljs-keyword">return</span> index&lt;=str.length() ? str.substring(index):<span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">createSeqNode</span><span class="hljs-params">(String pathPrefix)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">//创建一个临时顺序节点</span><br>    String destPath = curatorFramework.create()<br>            .creatingParentsIfNeeded()<br>            .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)<br>            .forPath(pathPrefix);<br>    <span class="hljs-keyword">return</span> destPath;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testMarkId</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    IDMaker idMaker = <span class="hljs-keyword">new</span> IDMaker();<br>    String pathPrefix = <span class="hljs-string">&quot;/idmarker/id-&quot;</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    String id = idMaker.makeId(pathPrefix);<br>                    log.info(<span class="hljs-string">&quot;&#123;&#125;线程第&#123;&#125;个创建的id为&#123;&#125;&quot;</span>, Thread.currentThread().getName(), j, id);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;thread&quot;</span> + i).start();<br>    &#125;<br><br>    Thread.sleep(Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="基于zookeeper实现snowflakeid算法">2.基于Zookeeper实现SnowFlakeID算法</h4><p>Twitter（推特）的 SnowFlake 算法是一种著名的分布式服务器用户 ID生成算法。SnowFlake 算法所生成的 ID 是一个 64bit 的长整型数字。这个64bit 被划分成四个部分，其中后面三个部分分别表示时间戳、工作机器ID、序列号。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302132201729.png" /></p><p>SnowFlakeID 的四个部分：</p><p>（1）第一位 占用 1 bit，其值始终是0，没有实际作用。</p><p>（2）时间戳 占用 41 bit，精确到毫秒，总共可以容纳约 69 年的时间。</p><p>（3）工作机器 id 占用 10 bit，最多可以容纳 1024 个节点。</p><p>（4）序列号 占用 12 bit。这个值在同一毫秒同一节点上从 0开始不断累加，最多可以累加到 4095。</p><p>在工作节点达到 1024 顶配的场景下，SnowFlake算法在同一毫秒最多可以生成的 ID 数量为： 1024 * 4096=4194304，在绝大多数并发场景下都是够用的。</p><p>SnowFlake 算法的优点：</p><ul><li>生成 ID 时不依赖于数据库，完全在内存生成，高性能和高可用性。</li><li>容量大，每秒可生成几百万个 ID。</li><li>ID 呈趋势递增，后续插入数据库的索引树时，性能较高。</li></ul><p>SnowFlake 算法的缺点：</p><ul><li>依赖于系统时钟的一致性，如果某台机器的系统时钟回拨了，有可能造成 ID冲突，或者 ID 乱序。</li><li>在启动之前，如果这台机器的系统时间回拨过，那么有可能出现 ID重复的危险。</li></ul><p>基于 zookeeper 实现雪花算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SnowflakeIdGenerator</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SnowflakeIdGenerator instance = <span class="hljs-keyword">new</span> SnowflakeIdGenerator();<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化单例</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> workerId 节点Id,最大8091</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the 单例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">long</span> workerId)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (workerId &gt; MAX_WORKER_ID) &#123;<br>            <span class="hljs-comment">// zk分配的workerId过大</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;worker Id wrong: &quot;</span> + workerId);<br>        &#125;<br>        instance.workerId = workerId;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SnowflakeIdGenerator</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开始使用该算法的时间为: 2017-01-01 00:00:00</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> START_TIME = <span class="hljs-number">1483200000000L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * worker id 的bit数，最多支持8192个节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> WORKER_ID_BITS = <span class="hljs-number">13</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列号，支持单节点最高每毫秒的最大ID数1024</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> SEQUENCE_BITS = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 最大的 worker id ，8091</span><br><span class="hljs-comment">     * -1 的补码（二进制全1）右移13位, 然后取反</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> MAX_WORKER_ID = ~(-<span class="hljs-number">1L</span> &lt;&lt; WORKER_ID_BITS);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 最大的序列号，1023</span><br><span class="hljs-comment">     * -1 的补码（二进制全1）右移10位, 然后取反</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> MAX_SEQUENCE = ~(-<span class="hljs-number">1L</span> &lt;&lt; SEQUENCE_BITS);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * worker 节点编号的移位</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> WORKER_ID_SHIFT = SEQUENCE_BITS;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 时间戳的移位</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> TIMESTAMP_LEFT_SHIFT = WORKER_ID_BITS + SEQUENCE_BITS;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 该项目的worker 节点 id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> workerId;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上次生成ID的时间戳</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> lastTimestamp = -<span class="hljs-number">1L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前毫秒生成的序列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> sequence = <span class="hljs-number">0L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Next id long.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the nextId</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">nextId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> generateId();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成唯一id的具体实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">long</span> <span class="hljs-title">generateId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> current = System.currentTimeMillis();<br><br>        <span class="hljs-keyword">if</span> (current &lt; lastTimestamp) &#123;<br>            <span class="hljs-comment">// 如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过，出现问题返回-1</span><br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (current == lastTimestamp) &#123;<br>            <span class="hljs-comment">// 如果当前生成id的时间还是上次的时间，那么对sequence序列号进行+1</span><br>            sequence = (sequence + <span class="hljs-number">1</span>) &amp; MAX_SEQUENCE;<br><br>            <span class="hljs-keyword">if</span> (sequence == MAX_SEQUENCE) &#123;<br>                <span class="hljs-comment">// 当前毫秒生成的序列数已经大于最大值，那么阻塞到下一个毫秒再获取新的时间戳</span><br>                current = <span class="hljs-keyword">this</span>.nextMs(lastTimestamp);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 当前的时间戳已经是下一个毫秒</span><br>            sequence = <span class="hljs-number">0L</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 更新上次生成id的时间戳</span><br>        lastTimestamp = current;<br><br>        <span class="hljs-comment">// 进行移位操作生成int64的唯一ID</span><br><br>        <span class="hljs-comment">//时间戳右移动23位</span><br>        <span class="hljs-keyword">long</span> time = (current - START_TIME) &lt;&lt; TIMESTAMP_LEFT_SHIFT;<br><br>        <span class="hljs-comment">//workerId 右移动10位</span><br>        <span class="hljs-keyword">long</span> workerId = <span class="hljs-keyword">this</span>.workerId &lt;&lt; WORKER_ID_SHIFT;<br><br>        <span class="hljs-keyword">return</span> time | workerId | sequence;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 阻塞到下一个毫秒</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-title">nextMs</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeStamp)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> current = System.currentTimeMillis();<br>        <span class="hljs-keyword">while</span> (current &lt;= timeStamp) &#123;<br>            current = System.currentTimeMillis();<br>        &#125;<br>        <span class="hljs-keyword">return</span> current;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="分布式锁实战">4. 分布式锁实战</h3><p><strong>什么是分布式锁</strong></p><p>在单体的应用开发场景中涉及并发同步的时候，大家往往采用Synchronized（同步）或者其他同一个 JVM 内 Lock机制来解决多线程间的同步问题。在分布式集群工作的开发场景中，就需要一种更加高级的锁机制来处理跨机器的进程之间的数据同步问题，这种跨机器的锁就是分布式锁。</p><p>目前分布式锁，比较成熟、主流的方案：</p><p>（1）基于数据库的分布式锁。db操作性能较差，并且有锁表的风险，一般不考虑。</p><p>（2）基于 Redis的分布式锁。适用于并发量很大、性能要求很高而可靠性问题可以通过其他方案去弥补的场景。</p><p>（3）基于 ZooKeeper的分布式锁。适用于高可靠（高可用），而并发量不是太高的场景。</p><h4 id="基于数据库设计思路">1. 基于数据库设计思路</h4><p>可以利用数据库的唯一索引来实现，唯一索引天然具有排他性。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302142233561.png" /></p><p>缺陷：获取锁后宕机会造成死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Lock</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加锁，增加重试逻辑</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//尝试获取锁</span><br>        <span class="hljs-keyword">if</span> (tryLock()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;---------获取锁---------&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//等待锁 阻塞</span><br>            waitLock();<br>            <span class="hljs-comment">//重试</span><br>            lock();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//尝试获取锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//等待锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitLock</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MysqlDistributedLock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLock</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MethodlockMapper methodlockMapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//插入一条数据   insert into</span><br>            methodlockMapper.insert(<span class="hljs-keyword">new</span> Methodlock(<span class="hljs-string">&quot;lock&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">//插入失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//删除数据   delete</span><br>        methodlockMapper.deleteByMethodlock(<span class="hljs-string">&quot;lock&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;-------释放锁------&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Methodlock</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-comment">//保证唯一性</span><br>    <span class="hljs-keyword">private</span> String methodName;<br><br>    <span class="hljs-keyword">private</span> Date updateTime;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Methodlock</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Methodlock</span><span class="hljs-params">(String methodName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.methodName = methodName;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="基于zookeeper设计思路">2. 基于Zookeeper设计思路</h4><p><strong>思路一：</strong></p><p>使用临时 znode 来表示获取锁的请求，创建 znode 成功的用户拿到锁。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302142259764.png" /></p><p>缺陷：如果所有的锁请求者都 watch 锁持有者，当代表锁持有者的 znode被删除以后，所有的锁请求者都会通知到，但是只有一个锁请求者能拿到锁。这就是羊群效应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZkDistributedLock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IZkDataListener</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> ZkClient zkClient;<br>    <span class="hljs-keyword">private</span> String path = <span class="hljs-string">&quot;/lock&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> CountDownLatch countDownLatch;<br>    <span class="hljs-keyword">private</span> String config;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ZkDistributedLock</span><span class="hljs-params">(String config, String path)</span> </span>&#123;<br>        zkClient = <span class="hljs-keyword">new</span> ZkClient(config);<br>        <span class="hljs-keyword">this</span>.config = config;<br>        <span class="hljs-keyword">this</span>.path = path;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (zkClient == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//建立连接</span><br>                zkClient = <span class="hljs-keyword">new</span> ZkClient(config);<br>            &#125;<br>            <span class="hljs-comment">// 创建临时节点</span><br>            zkClient.createEphemeral(path);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">//存在节点</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//注册监听</span><br>        zkClient.subscribeDataChanges(path, <span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> (zkClient.exists(path)) &#123;<br>            countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                countDownLatch.await();  <span class="hljs-comment">//计数器变为0之前，都会阻塞</span><br>                <span class="hljs-comment">// 解除监听</span><br>                zkClient.unsubscribeDataChanges(path, <span class="hljs-keyword">this</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (zkClient != <span class="hljs-keyword">null</span>) &#123;<br>            zkClient.delete(path);<br>            System.out.println(<span class="hljs-string">&quot;-----释放锁资源----&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataChange</span><span class="hljs-params">(String dataPath, Object data)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataDeleted</span><span class="hljs-params">(String dataPath)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        countDownLatch.countDown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【注】以上使用的是 zkclient 组件。</p><p><strong>思路二：</strong></p><p>使用临时顺序 znode 来表示获取锁的请求，创建最小后缀数字 znode的用户成功拿到锁。</p><p>公平锁的实现</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302142312393.png" /></p><p>在实际的开发中，如果需要使用到分布式锁，不建议去自己“重复造轮子”，而建议直接使用Curator 客户端中的各种官方实现的分布式锁，例如其中的InterProcessMutex可重入锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZkDistributedLock2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IZkDataListener</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> ZkClient zkClient;<br>    <span class="hljs-keyword">private</span> String path;<br>    <span class="hljs-keyword">private</span> String config;<br><br>    <span class="hljs-keyword">private</span> CountDownLatch countDownLatch ;<br>    <span class="hljs-keyword">private</span> String beforePath; <span class="hljs-comment">// 当前节点前一个节点</span><br>    <span class="hljs-keyword">private</span> String currentPath; <span class="hljs-comment">// 当前节点</span><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ZkDistributedLock2</span><span class="hljs-params">(String config, String path)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.path = path;<br>        <span class="hljs-keyword">this</span>.config = config;<br>        zkClient = <span class="hljs-keyword">new</span> ZkClient(config);<br>        <span class="hljs-keyword">if</span> (!zkClient.exists(path)) &#123;<br>            <span class="hljs-comment">// 如果根节点不存在，则创建根节点</span><br>            zkClient.createPersistent(path);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//尝试获取锁</span><br>        <span class="hljs-keyword">boolean</span> locked = tryLock();<br>        <span class="hljs-keyword">if</span>(locked)&#123;<br>            System.out.println(<span class="hljs-string">&quot;---------获取锁---------&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!locked)&#123;<br>            <span class="hljs-comment">//等待锁 阻塞</span><br>            waitLock();<br>            <span class="hljs-comment">//重试</span><br>            <span class="hljs-comment">//获取等待的子节点列表</span><br>            List&lt;String&gt; children = zkClient.getChildren(path);<br>            <span class="hljs-comment">//判断，是否加锁成功</span><br>            <span class="hljs-keyword">if</span> (checkLocked(children)) &#123;<br>                locked = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建临时有序的节点  -e -s</span><br>            currentPath = zkClient.createEphemeralSequential(path+<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-keyword">null</span>);<br>            <span class="hljs-comment">//获取到所有子节点</span><br>            List&lt;String&gt; children = zkClient.getChildren(path);<br>            <span class="hljs-comment">//获取等待的子节点列表，判断自己是否第一个</span><br>            <span class="hljs-keyword">if</span> (checkLocked(children)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// 若不是第一个，则找到自己的前一个节点</span><br>            <span class="hljs-keyword">int</span> index =  Collections.binarySearch(children,<br>                    currentPath.substring(currentPath.lastIndexOf(<span class="hljs-string">&quot;/&quot;</span>) + <span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(currentPath+<span class="hljs-string">&quot;节点没有找到&quot;</span> );<br>            &#125;<br>            <span class="hljs-comment">//如果自己没有获得锁，则要监听前一个节点</span><br>            beforePath = path + <span class="hljs-string">&quot;/&quot;</span> + children.get(index-<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkLocked</span><span class="hljs-params">(List&lt;String&gt; children)</span> </span>&#123;<br><br>        <span class="hljs-comment">//节点按照编号，升序排列</span><br>        Collections.sort(children);<br>        <span class="hljs-comment">// 如果是第一个，代表自己已经获得了锁</span><br>        <span class="hljs-keyword">if</span> (currentPath.equals(path + <span class="hljs-string">&quot;/&quot;</span> +children.get(<span class="hljs-number">0</span>))) &#123;<br>            System.out.println(<span class="hljs-string">&quot;成功的获取分布式锁,节点为&quot;</span>+ currentPath);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(zkClient.exists(beforePath)) &#123;<br>                <span class="hljs-comment">//订阅比自己次小顺序节点的删除事件   index-1</span><br>                zkClient.subscribeDataChanges(beforePath, <span class="hljs-keyword">this</span>);<br>                countDownLatch.await();<br>                zkClient.unsubscribeDataChanges(beforePath, <span class="hljs-keyword">this</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(zkClient !=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//删除临时节点</span><br>            zkClient.delete(currentPath,-<span class="hljs-number">1</span>);<br>            System.out.println(currentPath+<span class="hljs-string">&quot; 节点释放锁资源&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataChange</span><span class="hljs-params">(String dataPath, Object data)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataDeleted</span><span class="hljs-params">(String dataPath)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        countDownLatch.countDown(); <span class="hljs-comment">//减1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="curator-可重入分布式锁工作流程">3. Curator可重入分布式锁工作流程</h4><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CuratorLockTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> CuratorFramework client = CuratorFrameworkFactory.builder()<br>            .connectString(<span class="hljs-string">&quot;192.168.60.10:2181&quot;</span>)<br>            .retryPolicy(<span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>)).build();<br>    <span class="hljs-keyword">private</span> OrderCodeGenerator orderCodeGenerator = <span class="hljs-keyword">new</span> OrderCodeGenerator();<br>    <span class="hljs-comment">//可重入互斥锁</span><br>    <span class="hljs-keyword">final</span> InterProcessMutex lock = <span class="hljs-keyword">new</span> InterProcessMutex(client, <span class="hljs-string">&quot;/curator_lock&quot;</span>);<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        client.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> CuratorLockTest()).start();<br>        &#125;<br>        Thread.currentThread().join();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 加锁</span><br>            lock.acquire();<br><br>            String orderCode = orderCodeGenerator.getOrderCode();<br>            System.out.println(<span class="hljs-string">&quot;生成订单号 &quot;</span> + orderCode);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 释放锁</span><br>                lock.release();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现流程：</p><p>https://www.processon.com/view/link/5cadacd1e4b0375afbef4320</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302150010468.png" /></p><h4 id="总结">4. 总结</h4><p>优点：ZooKeeper 分布式锁（如InterProcessMutex），具备高可用、可重入、阻塞锁特性，可解决失效死锁问题，使用起来也较为简单。</p><p>缺点：因为需要频繁的创建和删除节点，性能上不如 Redis。</p><p>在高性能、高并发的应用场景下，不建议使用 ZooKeeper 的分布式锁。而由于ZooKeeper 的高可用性，因此在并发量不是太高的应用场景中，还是推荐使用ZooKeeper 的分布式锁。</p><h3 id="注册中心实战">5. 注册中心实战</h3><p>用于服务注册和服务发现</p><p>基于 ZooKeeper 本身的特性可以实现注册中心。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302152252046.png" /></p><p>使用：https://blog.csdn.net/qq_41573234/article/details/106634475</p>]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper——java操作Zookeeper</title>
    <link href="/2023/02/09/Zookeeper%E2%80%94%E2%80%94java%E6%93%8D%E4%BD%9CZookeeper/"/>
    <url>/2023/02/09/Zookeeper%E2%80%94%E2%80%94java%E6%93%8D%E4%BD%9CZookeeper/</url>
    
    <content type="html"><![CDATA[<p>ZooKeeper 应用的开发主要通过 Java 客户端 API 去连接和操作 ZooKeeper集群。可供选择的 Java 客户端 API 有：</p><ul><li>ZooKeeper 官方的 Java 客户端 API。</li><li>第三方的 Java 客户端 API，比如 Curator。</li></ul><p>ZooKeeper 官方的客户端 API提供了基本的操作。例如，创建会话、创建节点、读取节点、更新数据、删除节点和检查节点是否存在等。不过，对于实际开发来说，ZooKeeper官方 API 有一些不足之处，具体如下：</p><ul><li>ZooKeeper 的 Watcher监测是一次性的，每次触发之后都需要重新进行注册。</li><li>会话超时之后没有实现重连机制。</li><li>异常处理烦琐，ZooKeeper提供了很多异常，对于开发人员来说可能根本不知道应该如何处理这些抛出的异常。</li><li>仅提供了简单的 byte[] 数组类型的接口，没有提供 Java POJO级别的序列化数据处理接口。</li><li>创建节点时如果抛出异常，需要自行检查节点是否存在。</li><li>无法实现级联删除。</li></ul><p>总之，ZooKeeper 官方 API功能比较简单，在实际开发过程中比较笨重，一般不推荐使用。</p><h3 id="zookeeper-原生-java-客户端使用">1. Zookeeper 原生 Java客户端使用</h3><p>添加 zookeeper client 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：保持与服务端版本一致，不然会有很多兼容性的问题</p><p>ZooKeeper 原生客户端主要使用 org.apache.zookeeper.ZooKeeper这个类来使用 ZooKeeper 服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ZooKeeper (connectString, sessionTimeout, watcher)<br></code></pre></td></tr></table></figure><ul><li>connectString：使用逗号分隔的列表，每个 ZooKeeper 节点是一个host.port 对，host 是机器名或者 IP 地址，port 是 ZooKeeper节点对客户端提供服务的端口号。客户端会任意选取 connectString中的一个节点建立连接。</li><li>sessionTimeout : session timeout 时间。</li><li>watcher：用于接收到来自 ZooKeeper 集群的事件。</li></ul><p>使用 zookeeper 原生 API,连接 zookeeper 集群：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZkClientDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CONNECT_STR = <span class="hljs-string">&quot;192.168.60.10:2181&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String CLUSTER_CONNECT_STR = <span class="hljs-string">&quot;192.168.65.156:2181,192.168.65.190:2181,192.168.65.200:2181&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-keyword">final</span> CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br>        ZooKeeper zooKeeper = <span class="hljs-keyword">new</span> ZooKeeper(CONNECT_STR, <span class="hljs-number">4000</span>, <span class="hljs-keyword">new</span> Watcher() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent event)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (Event.KeeperState.SyncConnected == event.getState() &amp;&amp; event.getType() == Event.EventType.None) &#123;<br>                    <span class="hljs-comment">//如果收到了服务端的响应事件，连接成功</span><br>                    countDownLatch.countDown();<br>                    System.out.println(<span class="hljs-string">&quot;连接建立&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        System.out.print(<span class="hljs-string">&quot;连接中&quot;</span>);<br>        countDownLatch.await();<br>        <span class="hljs-comment">//CONNECTED</span><br>        System.out.println(zooKeeper.getState());<br><br>        <span class="hljs-comment">//创建持久节点</span><br>        zooKeeper.create(<span class="hljs-string">&quot;/user&quot;</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br><br>        <span class="hljs-comment">//持久监听</span><br>        zooKeeper.addWatch(<span class="hljs-string">&quot;/user&quot;</span>, <span class="hljs-keyword">new</span> Watcher() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> </span>&#123;<br>                System.out.println(watchedEvent);<br>            &#125;<br>        &#125;, AddWatchMode.PERSISTENT);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Zookeeper 主要方法</strong></p><ul><li>create(path, data, acl,createMode): 创建一个给定路径的 znode，并在znode 保存 data[] 的数据，createMode 指定 znode 的类型。</li><li>delete(path, version)：如果给定 path 上的 znode 的版本和给定的version 匹配， 删除 znode。</li><li>exists(path, watch)：判断给定 path 上的 znode 是否存在，并在 znode设置一个 watch。</li><li>getData(path, watch)：返回给定 path 上的 znode 数据，并在 znode设置一个 watch。</li><li>setData(path, data, version)：如果给定 path 上的 znode的版本和给定的 version 匹配，设置 znode 数据。</li><li>getChildren(path, watch)：返回给定 path 上的 znode 的孩子 znode名字，并在 znode 设置一个 watch。</li><li>sync(path)：把客户端 session 连接节点和 leader 节点进行同步。</li></ul><p>方法特点：</p><ul><li>所有获取 znode 数据的 API 都可以设置一个 watch 用来监控 znode的变化。</li><li>所有更新 znode 数据的 API 都有两个版本:无条件更新版本和条件更新版本。如果 version 为-1，更新为无条件更新。否则只有给定的 version 和 znode 当前的 version一样，才会进行更新，这样的更新是条件更新。</li><li>所有的方法都有同步和异步两个版本。同步版本的方法发送请求给 ZooKeeper并等待服务器的响应。异步版本把请求放入客户端的请求队列，然后马上返回。异步版本通过callback 来接受来自服务端的响应。</li></ul><h4 id="同步创建节点">1. 同步创建节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> KeeperException, InterruptedException </span>&#123;<br>    String path = zooKeeper.create(ZK_NODE, <span class="hljs-string">&quot;data&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br>    log.info(<span class="hljs-string">&quot;created path: &#123;&#125;&quot;</span>,path);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="异步创建节点">2. 异步创建节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createAsycTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>     zooKeeper.create(ZK_NODE, <span class="hljs-string">&quot;data&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,<br>             CreateMode.PERSISTENT,<br>             (rc, path, ctx, name) -&gt; log.info(<span class="hljs-string">&quot;rc  &#123;&#125;,path &#123;&#125;,ctx &#123;&#125;,name &#123;&#125;&quot;</span>,rc,path,ctx,name),<span class="hljs-string">&quot;context&quot;</span>);<br>    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="修改节点数据">3. 修改节点数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> KeeperException, InterruptedException </span>&#123;<br><br>    Stat stat = <span class="hljs-keyword">new</span> Stat();<br>    <span class="hljs-keyword">byte</span>[] data = zooKeeper.getData(ZK_NODE, <span class="hljs-keyword">false</span>, stat);<br>    log.info(<span class="hljs-string">&quot;修改前: &#123;&#125;&quot;</span>,<span class="hljs-keyword">new</span> String(data));<br>    zooKeeper.setData(ZK_NODE, <span class="hljs-string">&quot;changed!&quot;</span>.getBytes(), stat.getVersion());<br>     <span class="hljs-keyword">byte</span>[] dataAfter = zooKeeper.getData(ZK_NODE, <span class="hljs-keyword">false</span>, stat);<br>    log.info(<span class="hljs-string">&quot;修改后: &#123;&#125;&quot;</span>,<span class="hljs-keyword">new</span> String(dataAfter));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="curator-开源客户端使用">2. Curator 开源客户端使用</h3><p>Curator 是 Netflix 公司开源的一套 ZooKeeper 客户端框架，和 ZkClient一样它解决了非常底层的细节开发工作，包括连接、重连、反复注册 Watcher的问题以及 NodeExistsException 异常等。</p><p>Curator 是 Apache 基金会的顶级项目之一，Curator具有更加完善的文档，另外还提供了一套易用性和可读性更强的 Fluent风格的客户端 API 框架。</p><p>Curator 还为 ZooKeeper客户端框架提供了一些比较普遍的、开箱即用的、分布式开发用的解决方案，例如Recipe、共享锁服务、Master选举机制和分布式计数器等，帮助开发者避免了“重复造轮子”的无效开发工作。</p><blockquote><p>Guava is to Java that Curator to ZooKeeper</p></blockquote><p>在实际的开发场景中，使用 Curator 客户端就足以应付日常的 ZooKeeper集群操作的需求。</p><p>官网：https://curator.apache.org/</p><p><strong>引入依赖</strong></p><p>Curator 包含了几个包：</p><ul><li>curator-framework 是对 ZooKeeper 的底层 API 的一些封装。</li><li>curator-client 提供了一些客户端的操作，例如重试策略等。</li><li>curator-recipes 封装了一些高级特性，如：Cache事件监听、选举、分布式锁、分布式计数器、分布式 Barrier 等。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="创建客户端">1. 创建客户端</h4><p>在使用 curator-framework 包操作 ZooKeeper前，首先要创建一个客户端实例。这是一个 CuratorFramework类型的对象，有两种方法：</p><ol type="1"><li>使用工厂类 CuratorFrameworkFactory 的静态 newClient() 方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 重试策略</span><br>RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br><span class="hljs-comment">//创建客户端实例</span><br>CuratorFramework client = CuratorFrameworkFactory.newClient(CLUSTER_CONNECT_STR, retryPolicy);<br><span class="hljs-comment">//启动客户端</span><br>client.start();<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>使用工厂类 CuratorFrameworkFactory 的静态 builder 构造者方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>CuratorFramework client = CuratorFrameworkFactory.builder()<br>        .connectString(<span class="hljs-string">&quot;192.168.60.10:2181,192.168.60.10:2182,192.168.60.10:2183&quot;</span>)<br>        .sessionTimeoutMs(<span class="hljs-number">5000</span>)  <span class="hljs-comment">// 会话超时时间</span><br>        .connectionTimeoutMs(<span class="hljs-number">5000</span>) <span class="hljs-comment">// 连接超时时间</span><br>        .retryPolicy(retryPolicy)<br>        .namespace(<span class="hljs-string">&quot;base&quot;</span>) <span class="hljs-comment">// 包含隔离名称</span><br>        .build();<br>client.start();<br></code></pre></td></tr></table></figure><ul><li><p>connectionString：服务器地址列表，在指定服务器地址列表的时候可以是一个地址，也可以是多个地址。如果是多个地址，那么每个服务器地址列表用逗号分隔,如 host1:port1,host2:port2,host3；port3 。</p></li><li><p>retryPolicy：重试策略，当客户端异常退出或者与服务端失去连接的时候，可以通过设置客户端重新连接ZooKeeper 服务端。而 Curator 提供了一次重试、多次重试等不同种类的实现方式。在 Curator内部，可以通过判断服务器返回的 keeperException的状态代码来判断是否进行重试处理，如果返回的是 OK表示一切操作都没有问题，而 SYSTEMERROR 表示系统或服务端错误。</p></li></ul><table><thead><tr><th>策略名称</th><th>描述</th></tr></thead><tbody><tr><td>ExponentialBackoffRetry</td><td>重试一组次数，重试之间的睡眠时间增加</td></tr><tr><td>RetryNTimes</td><td>重试最大次数</td></tr><tr><td>RetryOneTime</td><td>只重试一次</td></tr><tr><td>RetryUntilElapsed</td><td>在给定的时间结束之前重试</td></tr></tbody></table><ul><li>超时时间：Curator 客户端创建过程中，有两个超时时间的设置。一个是sessionTimeoutMs 会话超时时间，用来设置该条会话在 ZooKeeper服务端的失效时间。另一个是 connectionTimeoutMs客户端创建会话的超时时间，用来限制客户端发起一个会话连接到接收 ZooKeeper服务端应答的时间。sessionTimeoutMs 作用在服务端，而 connectionTimeoutMs作用在客户端。</li></ul><h4 id="创建节点">2. 创建节点</h4><p>描述一个节点要包括节点的类型，即临时节点还是持久节点、节点的数据信息、节点是否是有序节点等属性和性质。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCreate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    String path = curatorFramework.create().forPath(<span class="hljs-string">&quot;/curator-node&quot;</span>);<br>    curatorFramework.create().withMode(CreateMode.PERSISTENT).forPath(<span class="hljs-string">&quot;/curator-node1&quot;</span>, <span class="hljs-string">&quot;some-data&quot;</span>.getBytes());<br>    curatorFramework.create()<br>            <span class="hljs-comment">// protection 模式，防止由于异常原因呆滞僵尸节点</span><br>            .withProtection()<br>            .withMode(CreateMode.PERSISTENT).forPath(<span class="hljs-string">&quot;/curator-node2&quot;</span>, <span class="hljs-string">&quot;some-data&quot;</span>.getBytes());<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在 Curator 中，可以使用 create 函数创建数据节点，并通过 withMode函数指定节点类型（持久化节点，临时节点，顺序节点，临时顺序节点，持久化顺序节点等），默认是持久化节点，之后调用forPath 函数来指定节点的路径和数据信息。</p><p><strong>一次性创建带层级结构的节点：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCreateWithParent</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    String pathWithParent=<span class="hljs-string">&quot;/node-parent/sub-node-1&quot;</span>;<br>    String path = curatorFramework.create().creatingParentsIfNeeded().forPath(pathWithParent);<br>    log.info(<span class="hljs-string">&quot;curator create node :&#123;&#125;  successfully.&quot;</span>,path);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取数据">3. 获取数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="hljs-string">&quot;/curator-node1&quot;</span>);<br>    log.info(<span class="hljs-string">&quot;get data from  node :&#123;&#125;  successfully.&quot;</span>,<span class="hljs-keyword">new</span> String(bytes));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="更新节点">4. 更新节点</h4><p>我们通过客户端实例的 setData() 方法更新 ZooKeeper服务上的数据节点，在 setData 方法的后边，通过 forPath函数来指定更新的数据节点路径以及要更新的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSetData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    curatorFramework.setData().forPath(<span class="hljs-string">&quot;/curator-node&quot;</span>,<span class="hljs-string">&quot;changed!&quot;</span>.getBytes());<br>    <span class="hljs-keyword">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="hljs-string">&quot;/curator-node&quot;</span>);<br>    log.info(<span class="hljs-string">&quot;get data from  node /curator-node :&#123;&#125;  successfully.&quot;</span>,<span class="hljs-keyword">new</span> String(bytes));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除节点">5. 删除节点</h4><p>guaranteed：该函数的功能如字面意思一样，主要起到一个保障删除成功的作用，其底层工作方式是：只要该客户端的会话有效，就会在后台持续发起删除请求，直到该数据节点在ZooKeeper 服务端被删除。</p><p>deletingChildrenIfNeeded：指定了该函数后，系统在删除该数据节点的时候会以递归的方式直接删除其子节点，以及子节点的子节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    String pathWithParent=<span class="hljs-string">&quot;/node-parent&quot;</span>;<br>    curatorFramework.delete().guaranteed().deletingChildrenIfNeeded().forPath(pathWithParent);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="异步接口">6. 异步接口</h4><p>Curator 引入了BackgroundCallback接口，用来处理服务器端返回来的信息，这个处理过程是在异步线程中调用，默认在<strong>EventThread</strong> 中调用，也可以自定义线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BackgroundCallback</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processResult</span><span class="hljs-params">(CuratorFramework client, CuratorEvent event)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上接口，主要参数为 client 客户端， 和 服务端事件 event</p><p>inBackground 异步处理默认在 EventThread 中执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    curatorFramework.getData().inBackground((client, event) -&gt; &#123;<br>        log.info(<span class="hljs-string">&quot; background: &#123;&#125;&quot;</span>, event);<br>    &#125;).forPath(<span class="hljs-string">&quot;/curator-node&quot;</span>);<br><br>    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><p>指定线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInBackground</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();<br><br>    curatorFramework.getData().inBackground((client, event) -&gt; &#123;<br>        log.info(<span class="hljs-string">&quot; background: &#123;&#125;&quot;</span>, event);<br>    &#125;,singleThreadExecutor).forPath(<span class="hljs-string">&quot;/curator-node&quot;</span>);<br><br>    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="curator-监听器">7. Curator 监听器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CuratorListener</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>         <span class="hljs-title">eventReceived</span><span class="hljs-params">(CuratorFramework client, CuratorEvent event)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>针对 background 通知和错误通知。使用此监听器之后，调用inBackground方法会异步获得监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCuratorListener</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    curatorFramework.getCuratorListenable().addListener((CuratorFramework client, CuratorEvent event)-&gt;&#123;<br>        log.info(<span class="hljs-string">&quot; things changed1: event: &#123;&#125;,  &#123;&#125; &quot;</span>,event.getType().name(),event);<br>    &#125;);<br><br>    log.info(<span class="hljs-string">&quot;start to change data for path :&#123;&#125;&quot;</span> , <span class="hljs-string">&quot;/curator-node&quot;</span>);<br>    curatorFramework.setData().inBackground().forPath(<span class="hljs-string">&quot;/curator-node&quot;</span>,<span class="hljs-string">&quot;xxx1&quot;</span>.getBytes());<br>    log.info(<span class="hljs-string">&quot;start to change data for path :&#123;&#125; again&quot;</span> , <span class="hljs-string">&quot;/curator-node&quot;</span>);<br>    curatorFramework.setData().inBackground().forPath(<span class="hljs-string">&quot;/curator-node&quot;</span>,<span class="hljs-string">&quot;xxx2&quot;</span>.getBytes());<br><br>    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Watcher：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 watcher 机制， 为一次性监听</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWatcher</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    <span class="hljs-keyword">byte</span>[] bytes = curatorFramework.getData().usingWatcher(<span class="hljs-keyword">new</span> Watcher() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent event)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (event.getType() == Event.EventType.NodeDataChanged) &#123;<br>                log.info(<span class="hljs-string">&quot;node &#123;&#125; data changed!&quot;</span>, event.getPath());<br>            &#125;<br>        &#125;<br>    &#125;).forPath(<span class="hljs-string">&quot;/test&quot;</span>);<br><br>    log.info(<span class="hljs-string">&quot; original data: &#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> String(bytes));<br>    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="curator-caches">7. Curator Caches</h4><p>Curator 引入了 Cache 来实现对 Zookeeper 服务端事件监听，Cache事件监听可以理解为一个本地缓存视图与远程 Zookeeper 视图的对比过程。Cache提供了反复注册的功能。Cache 分为两类注册类型：节点监听和子节点监听。</p><p><strong>node cache:</strong></p><p>NodeCache对某一个节点进行监听，可以通过注册监听器来实现对当前节点数据变化的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testNodeCache</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    NodeCache nodeCache = <span class="hljs-keyword">new</span> NodeCache(curatorFramework, <span class="hljs-string">&quot;/node-cache&quot;</span>);<br>    nodeCache.getListenable().addListener(<span class="hljs-keyword">new</span> NodeCacheListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nodeChanged</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            <span class="hljs-keyword">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="hljs-string">&quot;/node-cache&quot;</span>);<br>            log.info(<span class="hljs-string">&quot;data: &#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> String(bytes));<br>        &#125;<br>    &#125;);<br>    nodeCache.start();<br><br>    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>path cache:</strong></p><p>PathChildrenCache会对子节点进行监听，但是不会对二级子节点进行监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathChildrenCache</span><span class="hljs-params">(CuratorFramework client,</span></span><br><span class="hljs-params"><span class="hljs-function">                         String path,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">boolean</span> cacheData)</span></span><br><span class="hljs-function"><span class="hljs-comment">/*</span></span><br><span class="hljs-comment"><span class="hljs-function">    Parameters:</span></span><br><span class="hljs-comment"><span class="hljs-function">    client - the client</span></span><br><span class="hljs-comment"><span class="hljs-function">    path - path to watch</span></span><br><span class="hljs-comment"><span class="hljs-function">    cacheData - if true, node contents are cached in addition to the stat</span></span><br><span class="hljs-comment"><span class="hljs-function">*/</span></span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPathCache</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    PathChildrenCache pathChildrenCache = <span class="hljs-keyword">new</span> PathChildrenCache(curatorFramework, <span class="hljs-string">&quot;/path-cache&quot;</span>, <span class="hljs-keyword">true</span>);<br>    pathChildrenCache.getListenable().addListener(<span class="hljs-keyword">new</span> PathChildrenCacheListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">childEvent</span><span class="hljs-params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            log.info(<span class="hljs-string">&quot;event:  &#123;&#125;&quot;</span>,event);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 如果设置为true则在首次启动时就会缓存节点内容到Cache中</span><br>    pathChildrenCache.start(<span class="hljs-keyword">true</span>);<br><br>    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>tree cache:</strong></p><p>TreeCache 使用一个内部类 TreeNode来维护这个一个树结构。并将这个树结构与 ZK 节点进行了映射。所以 TreeCache可以监听当前节点下所有节点的事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testTreeCache</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <br>    TreeCache treeCache = <span class="hljs-keyword">new</span> TreeCache(curatorFramework, <span class="hljs-string">&quot;/tree-path&quot;</span>);<br>    treeCache.getListenable().addListener(<span class="hljs-keyword">new</span> TreeCacheListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">childEvent</span><span class="hljs-params">(CuratorFramework client, TreeCacheEvent event)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            log.info(<span class="hljs-string">&quot; tree cache: &#123;&#125;&quot;</span>,event);<br>        &#125;<br>    &#125;);<br>    treeCache.start();<br><br>    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper——集群</title>
    <link href="/2023/02/08/Zookeeper%E2%80%94%E2%80%94%E9%9B%86%E7%BE%A4/"/>
    <url>/2023/02/08/Zookeeper%E2%80%94%E2%80%94%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="集群角色">1. 集群角色</h3><ul><li><p>Leader： 领导者</p><p>事务请求（写操作）的唯一调度者和处理者，保证集群事务处理的顺序性；集群内部各个服务器的调度者。对于create、setData、delete 等有写操作的请求，则要统一转发给 leader处理，leader 需要决定编号、执行操作，这个过程称为事务。</p></li><li><p>Follower: 跟随者</p><p>处理客户端非事务（读操作）请求（可以直接响应），转发事务请求给Leader；参与集群 Leader 选举投票。</p></li><li><p>Observer: 观察者</p><p>对于非事务请求可以独立处理（读操作），对于事务性请求会转发给 leader处理。Observer 节点接收来自 leader 的 inform信息，更新自己的本地存储，不参与提交和选举投票。通常在不影响集群事务处理能力的前提下提升集群的非事务处理能力。</p></li></ul><p>Observer 应用场景：</p><ul><li>提升集群的读性能。因为 Observer不参与提交和选举的投票过程，所以可以通过往集群里面添加 observer节点来提高整个集群的读性能。</li><li>跨数据中心部署。 比如需要部署一个北京和香港两地都可以使用的zookeeper集群服务，并且要求北京和香港客户的读请求延迟都很低。解决方案就是把香港的节点都设置为observer。</li></ul><h3 id="集群架构">2. 集群架构</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302082253398.png" /></p><p>leader 节点可以处理读写请求，follower 只可以处理读请求。follower在接到写请求时会把写请求转发给 leader 来处理。</p><p>Zookeeper 数据一致性保证：</p><ul><li>全局可线性化(Linearizable )写入∶先到达 leader的写请求会被先处理，leader 决定写请求的执行顺序。</li><li>客户端 FIFO 顺序∶来自给定客户端的请求按照发送顺序执行。</li></ul><h3 id="集群搭建">3. 集群搭建</h3><p>环境准备：三台虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">192.168.65.156<br>192.168.65.190<br>192.168.65.200<br></code></pre></td></tr></table></figure><p><strong>1) 修改 zoo.cfg 配置，添加 server 节点配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 修改数据存储目录</span><br>dataDir=/data/zookeeper<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">三台虚拟机 zoo.cfg 文件末尾添加配置</span><br>server.1=192.168.65.156:2888:3888<br>server.2=192.168.65.190:2888:3888<br>server.3=192.168.65.200:2888:3888<br></code></pre></td></tr></table></figure><blockquote><p>server.A=B:C:D</p><p>A 是一个数字，表示这个是第几号服务器； 集群模式下配置一个文件myid，这个文件在 dataDir 目录下，这个文件里面有一个数据就是 A的值，Zookeeper 启动时读取此文件，拿到里面的数据与 zoo.cfg里面的配置信息比较从而判断到底是哪个server。</p><p>B 是这个服务器的地址；</p><p>C 是这个服务器 Follower 与集群中的 Leader 服务器交换信息的端口；</p><p>D 是万一集群中的 Leader服务器挂了，需要一个端口来重新进行选举，选出一个新的Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</p></blockquote><p><strong>2）创建 myid 文件，配置服务器编号</strong></p><p>在 dataDir 对应目录下创建 myid 文件，内容为对应 ip 的 zookeeper服务器编号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /data/zookeeper<br><span class="hljs-meta">#</span><span class="bash"> 在文件中添加与 server 对应的编号（注意：上下不要有空行，左右不要有空格）</span><br>vim myid<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302082325693.png" /></p><p><strong>3）启动 zookeeper server 集群</strong></p><p>启动前需要关闭防火墙(生产环境需要打开对应端口)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 分别启动三个节点的zookeeper server</span><br>bin/zkServer.sh start<br><span class="hljs-meta">#</span><span class="bash"> 查看集群状态</span><br>bin/zkServer.sh status<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302082326970.png" /></p><h3 id="zookeeper-四字命令">4. Zookeeper 四字命令</h3><p>zookeeper 支持某些特定的四字命令与其交互，用户获取 zookeeper服务的当前状态及相关信息，用户在客户端可以通过 telenet 或者 nc（netcat）向 zookeeper 提交相应的命令。</p><p>安装 nc 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> centos</span><br>yum install nc <br></code></pre></td></tr></table></figure><p>四字命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo [command] | nc [ip] [port]<br></code></pre></td></tr></table></figure><p>ZooKeeper 常用四字命令主要如下：</p><table><thead><tr><th>四字命令</th><th>功能描述</th></tr></thead><tbody><tr><td>conf</td><td>3.3.0版本引入的。打印出服务相关配置的详细信息。</td></tr><tr><td>cons</td><td>3.3.0版本引入的。列出所有连接到这台服务器的客户端全部连接/会话详细信息。包括"接受/发送"的包数量、会话id、操作延迟、最后的操作执行等等信息。</td></tr><tr><td>crst</td><td>3.3.0版本引入的。重置所有连接的连接和会话统计信息。</td></tr><tr><td>dump</td><td>列出那些比较重要的会话和临时节点。这个命令只能在leader节点上有用。</td></tr><tr><td>envi</td><td>打印出服务环境的详细信息。</td></tr><tr><td>reqs</td><td>列出未经处理的请求</td></tr><tr><td>ruok</td><td>测试服务是否处于正确状态。如果确实如此，那么服务返回"imok"，否则不做任何相应。</td></tr><tr><td>stat</td><td>输出关于性能和连接的客户端的列表。</td></tr><tr><td>srst</td><td>重置服务器的统计。</td></tr><tr><td>srvr</td><td>3.3.0版本引入的。列出连接服务器的详细信息</td></tr><tr><td>wchs</td><td>3.3.0版本引入的。列出服务器watch的详细信息。</td></tr><tr><td>wchc</td><td>3.3.0版本引入的。通过session列出服务器watch的详细信息，它的输出是一个与watch相关的会话的列表。</td></tr><tr><td>wchp</td><td>3.3.0版本引入的。通过路径列出服务器watch的详细信息。它输出一个与session相关的路径。</td></tr><tr><td>mntr</td><td>3.4.0版本引入的。输出可用于检测集群健康状态的变量列表</td></tr></tbody></table><p><strong>开启四字命令:</strong></p><p>方法1： 在 zoo.cfg 文件里加入配置项让这些指令放行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">开启四字命令</span><br>4lw.commands.whitelist=*<br></code></pre></td></tr></table></figure><p>方法2：在 zk 的启动脚本 zkServer.sh 中新增放行指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">添加ＶＭ环境变量-Dzookeeper.4lw.commands.whitelist=*</span><br>ZOOMAIN=&quot;-Dzookeeper.4lw.commands.whitelist=* $&#123;ZOOMAIN&#125;&quot;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-built_in">stat</span> | nc 192.168.65.156 2181</span><br></code></pre></td></tr></table></figure><h3 id="leader-选举">5. Leader 选举</h3><p>zookeeper 的 leader 选举存在两个阶段，一个是服务器启动时 leader选举，另一个是运行过程中 leader 服务器宕机。</p><p>在分析选举原理前，先介绍几个重要的参数：</p><ul><li>服务器 ID(myid)：编号越大在选举算法中权重越大</li><li>事务 ID(zxid)：值越大说明数据越新，权重越大</li><li>逻辑时钟(epoch-logicalclock)：同一轮投票过程中的逻辑时钟值是相同的，每投完一次值会增加</li></ul><p>选举状态：</p><ul><li><p>LOOKING: 竞选状态</p></li><li><p>FOLLOWING: 随从状态，同步 leader 状态，参与投票</p></li><li><p>OBSERVING: 观察状态，同步 leader 状态，不参与投票</p></li><li><p>LEADING: 领导者状态</p></li></ul><h4 id="启动时的选举">1. 启动时的选举</h4><p>每个节点启动的时候都是 LOOKING观望状态，接下来就开始进行选举主流程。这里选取三台机器组成的集群为例。第一台服务器server1启动时，无法进行 leader 选举，当第二台服务器 server2启动时，两台机器可以相互通信，进入 leader 选举过程。</p><ul><li><p>（1）每台 server 发出一个投票，由于是初始情况，server1 和 server2都将自己作为 leader服务器进行投票，每次投票包含所推举的服务器myid、zxid、epoch，使用（myid，zxid）表示，此时server1 投票为（1,0），server2投票为（2,0），然后将各自投票发送给集群中其他机器。</p></li><li><p>（2）接收来自各个服务器的投票。集群中的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票（epoch）、是否来自LOOKING 状态的服务器。</p></li><li><p>（3）分别处理投票。针对每一次投票，服务器都需要将其他服务器的投票和自己的投票进行对比，对比规则如下：</p></li><li><ul><li><ol type="a"><li>优先比较 epoch</li></ol></li><li><ol start="2" type="a"><li>检查 zxid，zxid 比较大的服务器优先作为 leader</li></ol></li><li><ol start="3" type="a"><li>如果 zxid 相同，那么就比较 myid，myid 较大的服务器作为 leader服务器</li></ol></li></ul></li><li><p>（4）统计投票。每次投票后，服务器统计投票信息，判断是都有过半机器接收到相同的投票信息。server1、server2都统计出集群中有两台机器接受了（2,0）的投票信息，此时已经选出了 server2为 leader 节点。</p></li><li><p>（5）改变服务器状态。一旦确定了leader，每个服务器响应更新自己的状态，如果是 follower，那么就变更为FOLLOWING，如果是 Leader，变更为 LEADING。此时 server3继续启动，直接加入变更自己为 FOLLOWING。</p></li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302082346061.png" /></p><h4 id="运行过程中的选举">2. 运行过程中的选举</h4><p>当集群中 leader服务器出现宕机或者不可用情况时，整个集群无法对外提供服务，进入新一轮的leader 选举。</p><ul><li>（1）变更状态。leader 挂后，其他非 Oberver服务器将自身服务器状态变更为 LOOKING。</li><li>（2）每个 server 发出一个投票。在运行期间，每个服务器上 zxid可能不同。</li><li>（3）处理投票。规则同启动过程。</li><li>（4）统计投票。与启动过程相同。</li><li>（5）改变服务器状态。与启动过程相同。</li></ul><p>https://www.jianshu.com/p/639e48b80b32</p><h3 id="数据同步">6. 数据同步</h3><p>在 Zookeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性。</p><p>ZAB 协议分为两部分：</p><ul><li>消息广播</li><li>崩溃恢复</li></ul><h4 id="消息广播">1. 消息广播</h4><p>Zookeeper 使用单一的主进程 Leader来接收和处理客户端所有事务请求，并采用 ZAB协议的原子广播协议，将事务请求以 Proposal 提议广播到所有 Follower节点，当集群中有过半的 Follower 服务器进行正确的 ACK 反馈，那么 Leader就会再次向所有的 Follower 服务器发送 commit消息，将此次提案进行提交。这个过程可以简称为 2pc事务提交，整个流程可以参考下图，注意 Observer 节点只负责同步 Leader数据，不参与 2PC 数据同步过程。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302092126584.png" /></p><h4 id="崩溃恢复">2. 崩溃恢复</h4><p>在正常情况下消息广播能运行良好，但是一旦 Leader服务器出现崩溃，或者由于网络原因导致 Leader 服务器失去了与过半 Follower的通信，那么就会进入崩溃恢复模式，需要选举出一个新的 Leader服务器。在这个过程中可能会出现两种数据不一致性的隐患，需要 ZAB协议的特性进行避免。</p><ul><li>Leader 服务器将消息 commit 发出后，立即崩溃</li><li>Leader 服务器刚提出 proposal 后，立即崩溃</li></ul><p>ZAB 协议的恢复模式使用了以下策略：</p><ul><li>选举 zxid 最大的节点作为新的 leader</li><li>新 leader 将事务日志中尚未提交的消息进行处理</li></ul>]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper——特性与节点数据类型</title>
    <link href="/2023/02/02/Zookeeper%E2%80%94%E2%80%94%E7%89%B9%E6%80%A7%E4%B8%8E%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/02/02/Zookeeper%E2%80%94%E2%80%94%E7%89%B9%E6%80%A7%E4%B8%8E%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="capbase-理论">1. CAP&amp;Base 理论</h3><h4 id="cap-理论">1. 1 CAP 理论</h4><p>CAP 理论指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p><ul><li><strong>一致性</strong>：在分布式环境中，一致性是指数据在多个副本之间是否能够保持一致的特性，等同于所有节点访问同一份最新的数据副本。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。</li><li><strong>可用性</strong>：每次请求都能获取到正确的响应，但是不保证获取的数据为最新数据。</li><li><strong>分区容错性</strong>：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</li></ul><p>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partitiontolerance）这三项中的两项。在这三个基本需求中，最多只能同时满足其中的两项，P 是必须的，因此只能在CP 和 AP 中选择，zookeeper 保证的是 CP，而 eureka 实现的是 AP。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302022326136.png" /></p><h4 id="base-理论">1.2 BASE 理论</h4><p>BASE 是 Basically Available(基本可用)、Soft-state(软状态) 和Eventually Consistent(最终一致性) 三个短语的缩写。</p><ul><li>基本可用：在分布式系统出现故障，允许损失部分可用性（服务降级、页面降级）。</li><li>软状态：允许分布式系统出现中间状态。而且中间状态不影响系统的可用性。这里的中间状态是指不同的datareplication（数据备份节点）之间的数据更新可以出现延时的最终一致性。</li><li>最终一致性：data replications 经过一段时间达到一致性。</li></ul><p>BASE 理论是对 CAP中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</p><blockquote><p><strong>强一致性</strong>：又称线性一致性(linearizability )</p><ol type="1"><li>任意时刻，所有节点中的数据是一样的</li><li>一个集群需要对外部提供强一致性，所以只要集群内部某一台服务器的数据发生了改变，那么就需要等待集群内其他服务器的数据同步完成后，才能正常的对外提供服务</li><li>保证了强一致性，务必会损耗可用性</li></ol><p><strong>弱一致性：</strong></p><ol type="1"><li>系统中的某个数据被更新后，后续对该数据的读取操作可能得到更新后的值，也可能是更改前的值。</li><li>即使过了不一致时间窗口，后续的读取也不一定能保证一致。</li></ol><p><strong>最终一致性：</strong></p><ol type="1"><li>弱一致性的特殊形式，不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化</li><li>存储系统保证在没有新的更新的条件下，最终所有的访问都是最后更新的值</li></ol><p><strong>顺序一致性：</strong></p><ol type="1"><li>任何一次读都能读到某个数据的最近一次写的数据。</li><li>对其他节点之前的修改是可见(已同步)且确定的,并且新的写入建立在已经达成同步的基础上。</li></ol></blockquote><p><font color="red"><strong>Zookeeper写入是强一致性，读取是顺序一致性。</strong></font></p><h3 id="zookeeper-介绍">2. Zookeeper 介绍</h3><h4 id="什么是-zookeeper">2.1 什么是 Zookeeper：</h4><p>　　ZooKeeper 是一个开源的分布式协调框架，是 Apache Hadoop的一个子项目，主要用来解决分布式集群中应用系统的一致性问题。Zookeeper的设计目标是将复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p><p>官方：https://zookeeper.apache.org/</p><p>　　ZooKeeper本质上是一个分布式的小文件存储系统（Zookeeper=文件系统+监听机制）。提供基于类似于文件系统的目录树方式的数据存储，并且可以对树中的节点进行有效管理，从而用来维护和监控存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理、统一命名服务、分布式配置管理、分布式消息队列、分布式锁、分布式协调等功能。</p><p>　　Zookeeper从设计模式角度来理解：是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302022327914.png" /></p><h4 id="zookeeper-安装">2.2 Zookeeper 安装</h4><p>下载地址：https://zookeeper.apache.org/releases.html运行环境：jdk8</p><p><strong>1）修改配置文件</strong></p><p>解压安装包后进入 conf 目录，复制 zoo_sample.cfg，修改为 zoo.cfg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp zoo_sample.cfg  zoo.cfg <br></code></pre></td></tr></table></figure><p>修改 zoo.cfg 配置文件，将 dataDir=/tmp/zookeeper 修改为指定的 data目录</p><p>zoo.cfg中参数含义：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302022258432.png" /></p><p><strong>2）启动 zookeeper server</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 默认加载配置路径conf/zoo.cfg</span><br>bin/zkServer.sh start conf/zoo.cfg<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 查看zookeeper状态</span><br>bin/zkServer.sh status<br></code></pre></td></tr></table></figure><p><strong>3）启动 zookeeper client 连接 Zookeeper server</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">bin/zkCli.sh<br><span class="hljs-meta">#</span><span class="bash"> 连接远程的zookeeper server</span><br>bin/zkCli.sh -server ip:port<br></code></pre></td></tr></table></figure><h4 id="客户端命令行操作">2.3 客户端命令行操作</h4><p>输入命令 help 查看 zookeeper 支持的所有命令：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302022319076.png" /></p><p>常见 cli 命令：https://zookeeper.apache.org/doc/r3.8.0/zookeeperCLI.html</p><table><thead><tr><th>命令基本语法</th><th>功能描述</th></tr></thead><tbody><tr><td>help</td><td>显示所有操作命令</td></tr><tr><td>ls [-s] [-w] [-R] path</td><td>使用 ls 命令来查看当前 znode 的子节点 [可监听] -w: 监听子节点变化-s: 节点状态信息（时间戳、版本号、数据大小等）-R: 表示递归的获取</td></tr><tr><td>create [-s] [-e] [-c] [-t ttl] path [data] [acl]</td><td>创建节点-s : 创建有序节点。-e : 创建临时节点。-c :创建一个容器节点。t ttl] : 创建一个TTL节点， -t时间（单位毫秒）。data：节点的数据，可选，如果不使用时，节点数据就为null。acl：访问控制</td></tr><tr><td>get [-s] [-w] path</td><td>获取节点数据信息 -s: 节点状态信息（时间戳、版本号、数据大小等） -w:监听节点变化</td></tr><tr><td>set [-s] [-v version] path data</td><td>设置节点数据-s:表示节点为顺序节点-v: 指定版本号</td></tr><tr><td>getAcl [-s] path</td><td>获取节点的访问控制信息-s:节点状态信息（时间戳、版本号、数据大小等）</td></tr><tr><td>setAcl [-s] [-v version] [-R] path acl</td><td>设置节点的访问控制列表-s:节点状态信息（时间戳、版本号、数据大小等）-v:指定版本号-R:递归的设置</td></tr><tr><td>stat [-w] path</td><td>查看节点状态信息</td></tr><tr><td>delete [-v version] path</td><td>删除某一节点，只能删除无子节点的节点。-v： 表示节点版本号</td></tr><tr><td>deleteall path</td><td>递归的删除某一节点及其子节点</td></tr><tr><td>setquota -n|-b val path</td><td>对节点增加限制n:表示子节点的最大个数b:数据值的最大长度，-1表示无限制</td></tr></tbody></table><h3 id="zookeeper-使用">3. ZooKeeper 使用</h3><p>ZooKeeper 数据模型的结构与 Unix文件系统很类似，整体上可以看作是一棵树，每个节点称做一个 ZNode。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302032315172.png" /></p><p>ZooKeeper 的数据模型是层次模型，层次模型常见于文件系统。层次模型和key-value 模型是两种主流的数据模型。ZooKeeper使用文件系统模型主要基于以下两点考虑：</p><ol type="1"><li>文件系统的树形结构便于表达数据之间的层次关系</li><li>文件系统的树形结构便于为不同的应用分配独立的命名空间( namespace)</li></ol><p>ZooKeeper 的层次模型称作 Data Tree，Data Tree 的每个节点叫作Znode。不同于文件系统，每个节点都可以保存数据，每一个 ZNode 默认能够存储1MB 的数据，每个 ZNode都可以通过其路径唯一标识，每个节点都有一个版本(version)，版本从 0开始计数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataTree</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;String, DataNode&gt; nodes = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, DataNode&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WatchManager dataWatches = <span class="hljs-keyword">new</span> WatchManager();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WatchManager childWatches = <span class="hljs-keyword">new</span> WatchManager();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Record</span> </span>&#123;<br>    <span class="hljs-keyword">byte</span> data[];<br>    Long acl;<br>    <span class="hljs-keyword">public</span> StatPersisted stat;<br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; children = <span class="hljs-keyword">null</span>;<br> &#125;   <br></code></pre></td></tr></table></figure><h4 id="节点分类">3.1 节点分类</h4><p>一个 znode 可以使持久性的，也可以是临时性的： 1.持久节点(PERSISTENT): 在创建之后即使发生 ZooKeeper 集群宕机或者 client宕机也不会丢失。 2. 临时节点(EPHEMERAL ): client 宕机或者 client在指定的 timeout 时间内没有给 ZooKeeper 集群发消息，这样的 znode就会消失。</p><p>如果上面两种 znode 具备顺序性，又有以下两种 znode : 3.持久顺序节点(PERSISTENT_SEQUENTIAL): 除了具备持久节点的特点之外，znode的名字具备顺序性。</p><ol start="4" type="1"><li>临时顺序节点(EPHEMERAL_SEQUENTIAL):除了具备临时节点的特点之外，znode 的名字具备顺序性。</li></ol><p>zookeeper主要用到的是以上4种节点。</p><ol start="5" type="1"><li>Container 节点 (3.5.3版本新增)：Container容器节点，当容器中没有任何子节点，该容器节点会被 zk定期删除（定时任务默认60s 检查一次)。 和持久节点的区别是 ZK服务端启动后，会有一个单独的线程去扫描，所有的容器节点，当发现容器节点的子节点数量为0 时，会自动删除该节点。可以用于 leader 或者锁的场景中。</li><li>TTL 节点: 带过期时间节点，默认禁用，需要在 zoo.cfg 中添加extendedTypesEnabled=true 开启。 注意：ttl 不能用于临时节点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs she">#创建持久节点<br>create /servers  xxx<br>#创建临时节点<br>create -e /servers/host  xxx<br>#创建临时有序节点<br>create -e -s /servers/host  xxx<br>#创建容器节点<br>create -c /container xxx<br># 创建ttl节点<br>create -t 10 /ttl<br></code></pre></td></tr></table></figure><h4 id="节点状态信息">3.2 节点状态信息</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302052322192.png" /></p><ul><li><p>cZxid ：Znode 创建的事务 id。</p></li><li><p>ctime：节点创建时的时间戳。</p></li><li><p>mZxid ：Znode 被修改的事务 id，即每次对 Znode 的修改都会更新mZxid。 对于 zk 来说，每次的变化都会产生一个唯一的事务id，zxid（ZooKeeper Transaction Id），通过zxid，可以确定更新操作的先后顺序。例如，如果 zxid1 小于 zxid2，说明zxid1 操作先于 zxid2 发生，zxid 对于整个 zk都是唯一的，即使操作的是不同的 znode。</p></li><li><p>pZxid: 表示该节点的子节点列表最后一次修改的事务ID，添加子节点或删除子节点就会影响子节点列表，但是修改子节点的数据内容则不影响该ID（注意: 只有子节点列表变更了才会变更 pzxid，子节点内容变更不会影响pzxid）</p></li><li><p>mtime：节点最新一次更新发生时的时间戳。</p></li><li><p>cversion ：子节点的版本号。当 Znode 的子节点有变化时，cversion的值就会增加 1。</p></li><li><p>dataVersion：数据版本号，每次对节点进行 set 操作，dataVersion的值都会增加1（即使设置的是相同的数据），可有效避免了数据更新时出现的先后顺序问题。</p></li><li><p>ephemeralOwner：如果该节点为临时节点, ephemeralOwner值表示与该节点绑定的 session id。如果不是, ephemeralOwner值为0(持久节点)。 在 client 和 server通信之前,首先需要建立连接,该连接称为session。连接建立后,如果发生连接超时、授权失败,或者显式关闭连接，连接便处于closed 状态, 此时 session 结束。</p></li><li><p>dataLength ： 数据的长度</p></li><li><p>numChildren ：子节点的数量（只统计直接子节点的数量）</p></li></ul><h4 id="监听通知watcher机制">3.3 监听通知（watcher）机制</h4><ul><li><p>一个 Watch 事件是一个一次性的触发器，当被设置了 Watch的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch的客户端，以便通知它们。</p></li><li><p>Zookeeper 采用了 Watcher机制实现数据的发布订阅功能，多个订阅者可同时监听某一特定主题对象，当该主题对象的自身状态发生变化时，例如节点内容改变、节点下的子节点列表改变等，会实时、主动通知所有订阅者。</p></li><li><p>watcher机制与观察者模式类似，也可看作是一种观察者模式在分布式场景下的实现方式。</p></li></ul><p>watcher 的过程：</p><ol type="1"><li><p>客户端向服务端注册 watcher</p></li><li><p>服务端事件发生触发 watcher</p></li><li><p>客户端回调 watcher 得到触发事件情况</p><p>注意：Zookeeper 中的 watch机制，必须客户端先去服务端注册监听，这样事件发送才会触发监听，通知给客户端。</p></li></ol><p>支持的事件类型：</p><ul><li>None: 连接建立事件</li><li>NodeCreated： 节点创建</li><li>NodeDeleted： 节点删除</li><li>NodeDataChanged：节点数据变化</li><li>NodeChildrenChanged：子节点列表变化</li><li>DataWatchRemoved：节点监听被移除</li><li>ChildWatchRemoved：子节点监听被移除</li></ul><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>一次性触发</td><td>watcher是一次性的，一旦被触发就会移除，再次使用时需要重新注册</td></tr><tr><td>客户端顺序回调</td><td>watcher回调是顺序串行执行的，只有回调后客户端才能看到最新的数据状态。一个watcher回调逻辑不应该太多，以免影响别的watcher执行</td></tr><tr><td>轻量级</td><td>WatchEvent是最小的通信单位，结构上只包含通知状态、事件类型和节点路径，并不会告诉数据节点变化前后的具体内容</td></tr><tr><td>时效性</td><td>watcher只有在当前session彻底失效时才会无效，若在session有效期内快速重连成功，则watcher依然存在，仍可接收到通知；</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">监听节点数据的变化</span><br>get -w path <br>stat -w path<br><span class="hljs-meta">#</span><span class="bash">监听子节点增减的变化</span> <br>ls -w path <br></code></pre></td></tr></table></figure><p><font color="red"> <strong>永久性 Watch：</strong> </font></p><p>在被触发之后，仍然保留，可以继续监听 ZNode 上的变更，是 Zookeeper3.6.0 版本新增的功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">addWatch [-m mode] path              <br></code></pre></td></tr></table></figure><p>addWatch 的作用是针对指定节点添加事件监听，支持两种模式</p><ul><li>PERSISTENT，持久化订阅，针对当前节点的修改和删除事件，以及当前节点的子节点的删除和新增事件。</li><li>PERSISTENT_RECURSIVE，持久化递归订阅，在 PERSISTENT的基础上，增加了子节点修改的事件触发，以及子节点的子节点的数据变化都会触发相关事件（满足递归订阅特性）</li></ul><h4 id="使用案例">3.4 使用案例</h4><h5 id="协同服务">1. 协同服务</h5><p>设计一个 master-worker 的组成员管理系统，要求系统中只能有一个 master, master 能实时获取系统中 worker 的情况。</p><p>保证组里面只有一个 master 的设计思路：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">master1</span><br>create -e /master &quot;m1:2223&quot;  <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">master2</span><br>create -e /master &quot;m2:2223&quot;   # /master已经存在，创建失败<br>Node already exists: /master<br><span class="hljs-meta">#</span><span class="bash">监听/master节点</span><br>stat -w /master<br><span class="hljs-meta">#</span><span class="bash">当master2收到/master节点删除通知后可以再次发起创建节点操作</span><br>create -e /master &quot;m2:2223&quot;<br></code></pre></td></tr></table></figure><p>master 监控 worker 状态的设计思路：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">master服务</span><br>create /workers<br><span class="hljs-meta">#</span><span class="bash">让master服务监控/workers下的子节点,监控是一次性的</span><br>ls -w /workers<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">worker1</span><br>create -e /workers/w1 &quot;w1:2224&quot; #创建子节点，master服务会收到子节点变化通知<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">master服务</span><br>ls -w /workers<br><span class="hljs-meta">#</span><span class="bash">worker2</span><br>create -e /workers/w2 &quot;w2:2224&quot;  #创建子节点，master服务会收到子节点变化通知<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">master服务</span><br>ls -w /workers<br><span class="hljs-meta">#</span><span class="bash">worker2</span><br>quit  #worker2退出，master服务会收到子节点变化通知<br></code></pre></td></tr></table></figure><h5 id="条件更新">2. 条件更新</h5><p>设想用 znode /c 实现一个 counter，使用 set 命令来实现自增 1操作。条件更新场景∶ 1. 客户端 1 把 /c 更新到版本 1，实现 /c 的自增1。</p><ol start="2" type="1"><li><p>客户端 2 把 /c 更新到版本 2，实现 /c 的自增 1。</p></li><li><p>客户端 1 不知道 /c 已经被客户端 2 更新过了，还用过时的版本 1是去更新 /c，更新失败。如果客户端 1 使用的是无条件更新，/c 就会更新为2，没有实现自增 1。</p></li></ol><p>使用条件更新可以避免出现客户端基于过期的数据进行数据更新的操作。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302062135937.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302062135933.png" /></p><h4 id="节点特性">3.5 节点特性</h4><ol type="1"><li><p>同一级节点 key 名称是唯一的</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302062140944.png" /></p></li><li><p>创建节点时，必须要带上全路径</p></li><li><p>session 关闭，临时节点清除</p></li><li><p>自动创建顺序节点</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302062147023.png" /></p></li><li><p>watch 机制，监听节点变化 事件监听机制类似于观察者模式，watch流程是客户端向服务端某个节点路径上注册一个watcher，同时客户端也会存储特定的watcher，当节点数据或子节点发生变化时，服务端通知客户端，客户端进行回调处理。特别注意：监听事件被单次触发后，事件就失效了。</p></li><li><p>delete 命令只能一层一层删除。提示：新版本可以通过 deleteall命令递归删除。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302062150494.png" /></p></li></ol><h4 id="应用场景">3.6 应用场景</h4><p>ZooKeeper适用于存储和协同相关的关键数据，不适合用于大数据量存储。</p><p>有了上述众多节点特性，使得 zookeeper能开发不出不同的经典应用场景，比如：</p><ul><li>注册中心</li><li>数据发布/订阅（常用于实现配置中心）</li><li>负载均衡</li><li>命名服务</li><li>分布式协调/通知</li><li>集群管理</li><li>Master选举</li><li>分布式锁</li><li>分布式队列</li></ul><h5 id="统一命名服务">1. 统一命名服务</h5><p>在分布式环境下，经常需要对应用/服务进行统一命名，便于识别。</p><p>例如：IP不容易记住，而域名容易记住。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302062158069.png" /></p><p>利用 ZooKeeper 顺序节点的特性，制作分布式的序列号生成器，或者叫 id生成器。（分布式环境下使用作为数据库 id，另外一种是UUID（缺点：没有规律）），ZooKeeper可以生成有顺序的容易理解的同时支持分布式环境的编号。</p><h5 id="数据发布订阅">2. 数据发布/订阅</h5><p>数据发布/订阅的一个常见的场景是配置中心，发布者把数据发布到 ZooKeeper的一个或一系列的节点上，供订阅者进行数据订阅，达到动态获取数据的目的。</p><p>配置信息一般有几个特点:</p><ol type="1"><li>数据量小的 KV</li><li>数据内容在运行时会发生动态变化</li><li>集群机器共享，配置一致</li></ol><p>ZooKeeper 采用的是推拉结合的方式。</p><ol type="1"><li>推: 服务端会推给注册了监控节点的客户端 Watcher 事件通知</li><li>拉: 客户端获得通知后，然后主动到服务端拉取最新的数据</li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302062203095.png" /></p><h5 id="统一集群管理">3. 统一集群管理</h5><p>分布式环境中，实时掌握每个节点的状态是必要的，可根据节点实时状态做出一些调整。</p><p>ZooKeeper 可以实现实时监控节点状态变化：</p><ul><li>可将节点信息写入 ZooKeeper 上的一个 ZNode。</li><li>监听这个 ZNode 可获取它的实时状态变化。</li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302062207318.png" /></p><h5 id="负载均衡">4. 负载均衡</h5><p>在 Zookeeper中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302062211972.png" /></p><h4 id="acl权限控制">3.7 ACL权限控制</h4><p>zookeeper 的 ACL（Access ControlList，访问控制表）权限在生产环境是特别重要的，ACL权限可以针对节点设置相关读写等权限，保障数据安全性。</p><h5 id="acl-构成">1. ACL 构成</h5><p>zookeeper 的 acl 通过 <strong>[scheme : id : permissions]</strong>来构成权限列表。</p><ul><li><strong>scheme</strong>：授权的模式，代表采用的某种权限机制，包括world、auth、digest、ip、super 几种。</li><li><strong>id</strong>：授权对象，代表允许访问的用户。如果我们选择采用IP 方式，使用的授权对象可以是一个 IP 地址或 IP 地址段；而如果使用 Digest或 Super 方式，则对应于一个用户名。如果是 World模式，是授权系统中所有的用户。</li><li><strong>permissions</strong>：授权的权限，权限组合字符串，由 cdrwa组成，其中每个字母代表支持不同权限， 创建权限 create(c)、删除权限delete(d)、读权限 read(r)、写权限 write(w)、管理权限 admin(a)。</li></ul><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>world</td><td>授权对象只有一个anyone，代表登录到服务器的所有客户端都能对该节点执行某种权限</td></tr><tr><td>ip</td><td>对连接的客户端使用IP地址认证方式进行认证</td></tr><tr><td>auth</td><td>使用以添加认证的用户进行认证</td></tr><tr><td>digest</td><td>使用 用户:密码方式验证</td></tr></tbody></table><table><thead><tr><th>权限类型</th><th>ACL简写</th><th>描述</th></tr></thead><tbody><tr><td>read</td><td>r</td><td>读取节点及显示子节点列表的权限</td></tr><tr><td>write</td><td>w</td><td>设置节点数据的权限</td></tr><tr><td>create</td><td>c</td><td>创建子节点的权限</td></tr><tr><td>delete</td><td>d</td><td>删除子节点的权限</td></tr><tr><td>admin</td><td>a</td><td>设置该节点ACL权限的权限</td></tr></tbody></table><table><thead><tr><th>授权命令</th><th>用法</th><th>描述</th></tr></thead><tbody><tr><td>getAcl</td><td>getAcl path</td><td>读取节点的ACL</td></tr><tr><td>setAcl</td><td>setAcl path acl</td><td>设置节点的ACL</td></tr><tr><td>create</td><td>create path data acl</td><td>创建节点时设置acl</td></tr><tr><td>addAuth</td><td>addAuth scheme auth</td><td>添加认证用户，类似于登录操作</td></tr></tbody></table><h5 id="world-授权模式">2. world 授权模式</h5><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302081953541.png" /></p><h5 id="auth-授权模式">3. auth 授权模式</h5><p>需要先添加用户后授权。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302082045093.png" /></p><p>退出客户端重新进入后无权限，需重新添加：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302082048851.png" /></p><p>创建用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs she">addauth digest debug:12345<br></code></pre></td></tr></table></figure><h5 id="digest-授权模式">4. digest 授权模式</h5><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302082112881.png" /></p><p>加密：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs she">echo -n user:12345 | openssl dgst -binary -sha1 | openssl base64<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302082114350.png" /></p><p>auth 与 digest的区别就是，前者使用明文密码进行登录，后者使用密文密码进行登录。</p><h5 id="ip-授权模式">5. IP 授权模式</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">setAcl /node-ip ip:192.168.109.128:cdwra<br>create /node-ip  data  ip:192.168.109.128:cdwra<br></code></pre></td></tr></table></figure><p>多个指定 IP 可以通过逗号分隔， 如 setAcl /node-ipip:IP1:rw,ip:IP2:a</p><h5 id="super-超级管理员模式">6. Super 超级管理员模式</h5><p>这是一种特殊的 Digest 模式， 在 Super 模式下超级管理员用户可以对Zookeeper 上的节点进行任何的操作。</p><p>需要在启动脚本上通过添加 JVM 参数开启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs she">DigestAuthenticationProvider中定义<br>-Dzookeeper.DigestAuthenticationProvider.superDigest=admin:&lt;base64encoded(SHA1(123456))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis-Plus——逻辑删除&amp;自动填充&amp;SQL分析&amp;数据安全保护&amp;乐观锁&amp;代码生成器</title>
    <link href="/2022/12/28/Mybatis-Plus%E2%80%94%E2%80%94%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4-SQL%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BF%9D%E6%8A%A4-%E4%B9%90%E8%A7%82%E9%94%81-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2022/12/28/Mybatis-Plus%E2%80%94%E2%80%94%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4-SQL%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BF%9D%E6%8A%A4-%E4%B9%90%E8%A7%82%E9%94%81-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="逻辑删除">1. 逻辑删除</h3><p>逻辑删除： 从逻辑层面控制删除，通常会在表里添加一个逻辑删除的字段比如enabled 、is_delete，数据默认是有效的（值为1），当用户删除时将数据修改为 0，在查询的时候就只查 where enabled=1 的数据。</p><p>1、局部单表逻辑删除，需要在对应的 pojo类加入对应的逻辑删除标识字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * value:有效值 delval：无效值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableLogic(value = &quot;1&quot;,delval = &quot;0&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer enabled;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLogicDelete</span><span class="hljs-params">()</span> </span>&#123;<br>    userService.removeById(<span class="hljs-number">8</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212282227972.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testQuery</span><span class="hljs-params">()</span> </span>&#123;<br>    userService.list();<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212282229026.png" /></p><p>2、全局配置</p><p>application.yml：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">mybatis-plus</span>:<span class="hljs-string"></span><br>  <span class="hljs-meta">global-config</span>:<span class="hljs-string"></span><br>    <span class="hljs-meta">db-config</span>:<span class="hljs-string"></span><br>      <span class="hljs-meta">logic-delete-field</span>: <span class="hljs-string">enabled # 逻辑删除字段</span><br>      <span class="hljs-meta">logic-not-delete-value</span>: <span class="hljs-string">1   # 有效值</span><br>      <span class="hljs-meta">logic-delete-value</span>: <span class="hljs-string">0       # 无效值</span><br></code></pre></td></tr></table></figure><h3 id="自动填充">2. 自动填充</h3><p>数据库表必备三字段：id,gmt_create,gmt_modified。</p><p>1、注解填充字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span><br>    <span class="hljs-keyword">private</span> Date gmtCreate;<br>    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br>    <span class="hljs-keyword">private</span> Date gmtModified;<br>    <br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>2、自定义填充实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMetaObjectHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MetaObjectHandler</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;<br>        <span class="hljs-comment">// 插入时填充创建时间和修改时间</span><br>        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">&quot;gmtCreate&quot;</span>,<span class="hljs-keyword">new</span> Date(),metaObject);<br>        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">&quot;gmtModified&quot;</span>,<span class="hljs-keyword">new</span> Date(),metaObject);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">&quot;gmtModified&quot;</span>,<span class="hljs-keyword">new</span> Date(),metaObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【注】需要注入容器中。</p><p>3、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;aaa@bb.com&quot;</span>);<br>    userService.save(user);<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212282307524.png" /></p><h3 id="sql分析打印">3. SQL分析打印</h3><p>1、添加依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xm">&lt;dependency&gt;<br>    &lt;groupId&gt;p6spy&lt;/groupId&gt;<br>    &lt;artifactId&gt;p6spy&lt;/artifactId&gt;<br>    &lt;version&gt;3.9.1&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>2、application.yml 配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">datasource</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">url</span>: <span class="hljs-string">jdbc:p6spy:mysql://localhost:3306/debuggingworld</span><br>    <span class="hljs-meta">driver-class-name</span>: <span class="hljs-string">com.p6spy.engine.spy.P6SpyDriver</span><br>    <span class="hljs-attr">……</span><br></code></pre></td></tr></table></figure><p>3、spy.properties 配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#3.2.1以上使用</span><br><span class="hljs-attr">modulelist</span>=<span class="hljs-string">com.baomidou.mybatisplus.extension.p6spy.MybatisPlusLogFactory,com.p6spy.engine.outage.P6OutageFactory</span><br><span class="hljs-comment">#3.2.1以下使用或者不配置</span><br><span class="hljs-comment">#modulelist=com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory</span><br><span class="hljs-comment"># 自定义日志打印</span><br><span class="hljs-attr">logMessageFormat</span>=<span class="hljs-string">com.baomidou.mybatisplus.extension.p6spy.P6SpyLogger</span><br><span class="hljs-comment">#日志输出到控制台</span><br><span class="hljs-attr">appender</span>=<span class="hljs-string">com.baomidou.mybatisplus.extension.p6spy.StdoutLogger</span><br><span class="hljs-comment"># 使用日志系统记录 sql</span><br><span class="hljs-comment">#appender=com.p6spy.engine.spy.appender.Slf4JLogger</span><br><span class="hljs-comment"># 设置 p6spy driver 代理</span><br><span class="hljs-attr">deregisterdrivers</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 取消JDBC URL前缀</span><br><span class="hljs-attr">useprefix</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 配置记录 Log 例外,可去掉的结果集有error,info,batch,debug,statement,commit,rollback,result,resultset.</span><br><span class="hljs-attr">excludecategories</span>=<span class="hljs-string">info,debug,result,commit,resultset</span><br><span class="hljs-comment"># 日期格式</span><br><span class="hljs-attr">dateformat</span>=<span class="hljs-string">yyyy-MM-dd HH:mm:ss</span><br><span class="hljs-comment"># 实际驱动可多个</span><br><span class="hljs-comment">#driverlist=org.h2.Driver</span><br><span class="hljs-comment"># 是否开启慢SQL记录</span><br><span class="hljs-attr">outagedetection</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 慢SQL记录标准 2 秒</span><br><span class="hljs-attr">outagedetectioninterval</span>=<span class="hljs-string">2</span><br></code></pre></td></tr></table></figure><p>4、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMyBatisPlus</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tesQueryWrapper</span><span class="hljs-params">()</span> </span>&#123;<br><br>        QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();<br>        queryWrapper.lambda()<br>                .select(User::getName, User::getAge)<br>                .eq(User::getAge, <span class="hljs-number">18</span>);<br>        List&lt;User&gt; users = userService.list(queryWrapper);<br>        System.out.println(users);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212292232310.png" /></p><h3 id="数据安全保护">4. 数据安全保护</h3><p>1、密钥加密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 生成 16 位随机 AES 密钥</span><br>    String randomKey = AES.generateRandomKey();<br>    System.out.println(randomKey);<br>    <span class="hljs-comment">// 随机密钥加密</span><br>   String url = AES.encrypt(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/debuggingworld&quot;</span>, randomKey);<br>   String user = AES.encrypt(<span class="hljs-string">&quot;root&quot;</span>, randomKey);<br>   String pwd = AES.encrypt(<span class="hljs-string">&quot;mysql&quot;</span>, randomKey);<br>    System.out.println(url);<br>    System.out.println(user);<br>    System.out.println(pwd);<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202301052258686.png" /></p><p>2、配置文件</p><p>application-prod.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">mpw:wRoBmoVgn2n+b8ZxtSaJKQ==</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">mpw:rpKT+pzjYSdArnMgN8M2Qg==</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">mpw:p9nNvk6dwEvbvoh7qeKXUZAOMOMdzCISl1SQW9FJFK2ahVSBBjHYpDZD15YeofFo</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br></code></pre></td></tr></table></figure><p>application-dev.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/debuggingworld?serverTimezone=Asia/Shanghai</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br></code></pre></td></tr></table></figure><p>application.yml:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><p>生产环境执行：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202301052338408.png" /></p><h3 id="乐观锁">5. 乐观锁</h3><p>乐观锁实现方式：</p><ul><li>取出记录时，获取当前 version</li><li>更新时，带上这个 version</li><li>执行更新时， set version = newVersion where version =oldVersion</li><li>如果 version 不对，就更新失败</li></ul><p>1、配置插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title">mybatisPlusInterceptor</span><span class="hljs-params">()</span> </span>&#123;<br>    MybatisPlusInterceptor mybatisPlusInterceptor = <span class="hljs-keyword">new</span> MybatisPlusInterceptor();<br>    mybatisPlusInterceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> OptimisticLockerInnerInterceptor());<br>    <span class="hljs-keyword">return</span> mybatisPlusInterceptor;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在实体类的字段上加上<code>@Version</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Version</span><br><span class="hljs-keyword">private</span> Integer version;<br></code></pre></td></tr></table></figure><p>3、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tesCAS</span><span class="hljs-params">()</span> </span>&#123;<br>    User user1 = userService.getById(<span class="hljs-number">1</span>);<br>    User user2 = userService.getById(<span class="hljs-number">1</span>);<br>    user1.setAge(<span class="hljs-number">20</span>);<br>    user2.setAge(<span class="hljs-number">22</span>);<br><br>    <span class="hljs-comment">// 更新成功</span><br>    System.out.println(userService.updateById(user1));<br>    <span class="hljs-comment">// 更新失败</span><br>    System.out.println(userService.updateById(user2));<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202301071615201.png" /></p><h3 id="代码生成器">6. 代码生成器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.debuggingworld;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.toolkit.StringPool;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.toolkit.StringUtils;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.generator.InjectionConfig;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.generator.config.*;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.generator.config.po.LikeTable;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.generator.config.po.TableInfo;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.DateType;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneratorApp</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 读取控制台内容</span><br><span class="hljs-comment">     * &lt;/p&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">scanner</span><span class="hljs-params">(String tip)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        StringBuilder help = <span class="hljs-keyword">new</span> StringBuilder();<br>        help.append(<span class="hljs-string">&quot;请输入&quot;</span> + tip + <span class="hljs-string">&quot;：&quot;</span>);<br>        System.out.println(help.toString());<br>        <span class="hljs-comment">// 判断用户是否输入</span><br>        <span class="hljs-keyword">if</span> (scanner.hasNext()) &#123;<br>            <span class="hljs-comment">// 拿到输入内容</span><br>            String ipt = scanner.next();<br>            <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(ipt)) &#123;<br>                <span class="hljs-keyword">return</span> ipt;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MybatisPlusException(<span class="hljs-string">&quot;请输入正确的&quot;</span> + tip + <span class="hljs-string">&quot;！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">// pms</span><br>        String moduleName = scanner(<span class="hljs-string">&quot;模块名&quot;</span>);<br>        String tableName = scanner(<span class="hljs-string">&quot;表名（多个用，号分隔，或者按前缀（pms*））&quot;</span>);<br>        String prefixName = scanner(<span class="hljs-string">&quot;需要替换的表前缀&quot;</span>);<br><br><br>        <span class="hljs-comment">// 代码生成器</span><br>        AutoGenerator mpg = <span class="hljs-keyword">new</span> AutoGenerator();<br><br>        <span class="hljs-comment">// 全局配置</span><br>        GlobalConfig gc = <span class="hljs-keyword">new</span> GlobalConfig();<br>        <span class="hljs-comment">// 获得当前项目的路径</span><br>        String projectPath = System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>)+<span class="hljs-string">&quot;/generator&quot;</span>;<br>        <span class="hljs-comment">// 设置生成路径</span><br>        gc.setOutputDir(projectPath + <span class="hljs-string">&quot;/src/main/java&quot;</span>);<br>        <span class="hljs-comment">// 作者</span><br>        gc.setAuthor(<span class="hljs-string">&quot;debuggingWorld&quot;</span>);<br>        <span class="hljs-comment">// 代码生成是不是要打开所在文件夹</span><br>        gc.setOpen(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-comment">// 生成Swagger2注解</span><br>        gc.setSwagger2(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">// 会在mapper.xml 生成一个基础的&lt;ResultMap&gt; 映射所有的字段</span><br>        gc.setBaseResultMap(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">// 同文件生成覆盖</span><br>        gc.setFileOverride(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//gc.setDateType(DateType.ONLY_DATE)</span><br>        <span class="hljs-comment">// 实体名：直接用表名  %s=表名</span><br>        gc.setEntityName(<span class="hljs-string">&quot;%s&quot;</span>);<br>        <span class="hljs-comment">// mapper接口名</span><br>        gc.setMapperName(<span class="hljs-string">&quot;%sMapper&quot;</span>);<br>        <span class="hljs-comment">// mapper.xml 文件名</span><br>        gc.setXmlName(<span class="hljs-string">&quot;%sMapper&quot;</span>);<br>        <span class="hljs-comment">// 业务逻辑类接口名</span><br>        gc.setServiceName(<span class="hljs-string">&quot;%sService&quot;</span>);<br>        <span class="hljs-comment">// 业务逻辑类实现类名</span><br>        gc.setServiceName(<span class="hljs-string">&quot;%sImplService&quot;</span>);<br>        <span class="hljs-comment">// 将全局配置设置到AutoGenerator</span><br>        mpg.setGlobalConfig(gc);<br><br><br><br>        <span class="hljs-comment">// 数据源配置</span><br>        DataSourceConfig dsc = <span class="hljs-keyword">new</span> DataSourceConfig();<br>        dsc.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/debuggingworld?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;&quot;</span>);<br>        dsc.setDriverName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>        dsc.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>        dsc.setPassword(<span class="hljs-string">&quot;mysql&quot;</span>);<br>        mpg.setDataSource(dsc);<br><br>        <span class="hljs-comment">// 包配置</span><br>        PackageConfig pc = <span class="hljs-keyword">new</span> PackageConfig();<br>        <span class="hljs-comment">//  模块名</span><br>        pc.setModuleName(moduleName);<br>        <span class="hljs-comment">// 包名</span><br>        pc.setParent(<span class="hljs-string">&quot;com.debuggingworld&quot;</span>);<br>        <span class="hljs-comment">// 完整的包名： com.debuggingworld.pms</span><br>        mpg.setPackageInfo(pc);<br><br><br><br>        <span class="hljs-comment">// 自定义配置</span><br>        InjectionConfig cfg = <span class="hljs-keyword">new</span> InjectionConfig() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMap</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">// to do nothing</span><br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 如果模板引擎是 velocity</span><br>        String templatePath = <span class="hljs-string">&quot;/templates/mapper.xml.vm&quot;</span>;<br>        <span class="hljs-comment">// 自定义输出配置</span><br>        List&lt;FileOutConfig&gt; focList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 自定义配置会被优先输出</span><br>        focList.add(<span class="hljs-keyword">new</span> FileOutConfig(templatePath) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">outputFile</span><span class="hljs-params">(TableInfo tableInfo)</span> </span>&#123;<br>                <span class="hljs-comment">// 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！</span><br>                <span class="hljs-keyword">return</span> projectPath + <span class="hljs-string">&quot;/src/main/resources/mapper/&quot;</span> + pc.getModuleName()<br>                        + <span class="hljs-string">&quot;/&quot;</span> + tableInfo.getEntityName() + <span class="hljs-string">&quot;Mapper&quot;</span> + StringPool.DOT_XML;<br>            &#125;<br>        &#125;);<br><br>        cfg.setFileOutConfigList(focList);<br>        mpg.setCfg(cfg);<br><br>        <span class="hljs-comment">// 配置模板</span><br>        TemplateConfig templateConfig = <span class="hljs-keyword">new</span> TemplateConfig();<br><br>        <span class="hljs-comment">// 把已有的xml生成置空</span><br>        templateConfig.setXml(<span class="hljs-keyword">null</span>);<br>        mpg.setTemplate(templateConfig);<br><br>        <span class="hljs-comment">// 策略配置</span><br>        StrategyConfig strategy = <span class="hljs-keyword">new</span> StrategyConfig();<br>        <span class="hljs-comment">// 表名的生成策略：下划线转驼峰 pms_product -- PmsProduct</span><br>        strategy.setNaming(NamingStrategy.underline_to_camel);<br>        <span class="hljs-comment">// 列名的生成策略：下划线转驼峰 last_name -- lastName</span><br>        strategy.setColumnNaming(NamingStrategy.underline_to_camel);<br>        <span class="hljs-comment">//strategy.setSuperEntityClass(&quot;你自己的父类实体,没有就不用设置!&quot;);</span><br>        <span class="hljs-comment">//strategy.setEntityLombokModel(true);</span><br>        <span class="hljs-comment">// 在controller类上是否生成@RestController</span><br>        strategy.setRestControllerStyle(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">// 公共父类</span><br>        <span class="hljs-comment">//strategy.setSuperControllerClass(&quot;你自己的父类控制器,没有就不用设置!&quot;);</span><br><br>        <span class="hljs-keyword">if</span>(tableName.indexOf(<span class="hljs-string">&#x27;*&#x27;</span>)&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 按前缀生成表</span><br>            strategy.setLikeTable(<span class="hljs-keyword">new</span> LikeTable(tableName.replace(<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>)));<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 要生成的表名 多个用逗号分隔</span><br>             strategy.setInclude(tableName);<br>        &#125;<br>        <span class="hljs-comment">// 设置表替换前缀</span><br>        strategy.setTablePrefix(prefixName);<br>        <span class="hljs-comment">// 驼峰转连字符 比如 pms_product --&gt; controller @RequestMapping(&quot;/pms/Product&quot;)</span><br>        <span class="hljs-comment">//strategy.setControllerMappingHyphenStyle(true);</span><br>        mpg.setStrategy(strategy);<br><br>        <span class="hljs-comment">// 进行生成</span><br>        mpg.execute();<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis-Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis-Plus——CRUD&amp;分页&amp;条件构造器&amp;ID策略</title>
    <link href="/2022/12/14/Mybatis-Plus%E2%80%94%E2%80%94CRUD-%E5%88%86%E9%A1%B5-%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8-ID%E7%AD%96%E7%95%A5/"/>
    <url>/2022/12/14/Mybatis-Plus%E2%80%94%E2%80%94CRUD-%E5%88%86%E9%A1%B5-%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8-ID%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p><strong><a href="https://baomidou.com/">官网</a></strong></p><h3 id="特性">1. 特性</h3><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用Service，仅仅通过少量配置即可实现单表大部分 CRUD操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4种主键策略（内含分布式唯一 ID 生成器 -Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成Mapper 、 Model 、 Service 、 Controller层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List查询</li><li><strong>分页插件支持多种数据库</strong>：支持MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h3 id="mapper-crud">2. Mapper CRUD</h3><p>1、 添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>ps：切记不可再在 pom.xml 文件中引入mybatis 与 mybatis-spring 的 maven依赖</p><p>2、配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">datasource</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">username</span>: <span class="hljs-string">root</span><br>    <span class="hljs-attr">password</span>: <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">url</span>: <span class="hljs-string">jdbc:mysql://localhost:3306/debuggingworld</span><br>    <span class="hljs-meta">driver-class-name</span>: <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">type</span>: <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>  <span class="hljs-attr">sql</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">init</span>:<span class="hljs-string"></span><br>      <span class="hljs-attr">mode</span>: <span class="hljs-string">never</span><br>      <span class="hljs-meta">schema-locations</span>: <span class="hljs-string">classpath:sql/schema.sql</span><br><span class="hljs-attr">logging</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">level</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">root</span>: <span class="hljs-string">info</span><br>    <span class="hljs-meta">com.debugWorld.mapper</span>: <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><p>3、Mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMapper</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.debugWorld.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>5、实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@TableId(type = IdType.AUTO)</span><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps：默认开启蛇形命名转驼峰命名。</p><p>6、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMyBatisPlus</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSelect</span><span class="hljs-params">()</span> </span>&#123;<br>        User user = userMapper.selectById(<span class="hljs-number">1</span>);<br>        System.out.println(user);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAdd</span><span class="hljs-params">()</span> </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;debugWorld&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;mail&quot;</span>);<br>        userMapper.insert(user);<br>        <span class="hljs-comment">// 主键自动回填</span><br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212251210498.png" /></p><table><thead><tr><th></th><th>描述</th><th>使用位置</th><th>备注</th></tr></thead><tbody><tr><td><span class="citation" data-cites="TableName">@TableName</span></td><td>表名注解，标识实体类对应的表</td><td>实体类</td><td>默认表名和实体类名一致</td></tr><tr><td><span class="citation" data-cites="TableId">@TableId</span></td><td>主键注解</td><td>实体类主键字段</td><td></td></tr><tr><td><span class="citation"data-cites="TableField">@TableField</span></td><td>字段注解（非主键）</td><td>实体类字段</td><td>表字段名和实体类字段名不一致时使用<br /><span class="citation"data-cites="TableField">@TableField</span>(exist = false)表示非数据库字段</td></tr><tr><td><span class="citation" data-cites="Version">@Version</span></td><td>乐观锁标记注解</td><td></td><td></td></tr><tr><td><span class="citation"data-cites="KeySequence">@KeySequence</span></td><td>序列主键策略</td><td></td><td></td></tr></tbody></table><h3 id="service-crud">3. Service CRUD</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IService</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl</span>&lt;<span class="hljs-title">UserMapper</span>, <span class="hljs-title">User</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMyBatisPlus</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">()</span> </span>&#123;<br>        User user = userService.getById(<span class="hljs-number">6</span>);<br>        System.out.println(user);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAdd</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 先根据主键查询，如果存在就更新，不存在则插入。</span><br>        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;debugWorld&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;@mail&quot;</span>);<br>        userService.saveOrUpdate(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212251250390.png" style="zoom: 67%;" /></p><h3 id="分页">4. 分页</h3><p>1、添加插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title">mybatisPlusInterceptor</span><span class="hljs-params">()</span> </span>&#123;<br>    MybatisPlusInterceptor interceptor = <span class="hljs-keyword">new</span> MybatisPlusInterceptor();<br>    interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> PaginationInnerInterceptor(DbType.MYSQL));<br>    <span class="hljs-keyword">return</span> interceptor;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMyBatisPlus</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPage</span><span class="hljs-params">()</span> </span>&#123;<br>        IPage&lt;User&gt; iPage = <span class="hljs-keyword">new</span> Page&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br>        IPage&lt;User&gt; page = userService.page(iPage);<br>        System.out.println(page.getRecords());<br>        System.out.println(page.getTotal());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、自定义方法实现分页</p><p>mapper 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMapper</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>    <span class="hljs-function">IPage&lt;User&gt; <span class="hljs-title">selectUserByAge</span><span class="hljs-params">(IPage page,<span class="hljs-keyword">int</span> age)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>mapper xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.debugWorld.mapper.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserByAge&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.debugWorld.pojo.User&quot;</span>&gt;</span><br>        select * FROM user where age = #&#123;age&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMyBatisPlus</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPage</span><span class="hljs-params">()</span> </span>&#123;<br>        IPage&lt;User&gt; iPage = <span class="hljs-keyword">new</span> Page&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>        IPage&lt;User&gt; page = userMapper.selectUserByAge(iPage,<span class="hljs-number">18</span>);<br>        System.out.println(page.getRecords());<br>        System.out.println(page.getTotal());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212272153886.png" /></p><p>【注】mybatisPlus 默认mapper xml 路径：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212272147742.png" /></p><p>自定义路径：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">mybatis-plus</span>:<span class="hljs-string"></span><br>  <span class="hljs-meta">mapper-locations</span>: <span class="hljs-string">classpath:/com/debugWorld/mapper/*.xml</span><br></code></pre></td></tr></table></figure><h3 id="条件构造器">5. 条件构造器</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212272203875.png" /></p><p>AbstractWrapper ： 用于查询条件封装，生成 sql 的 where条件,QueryWrapper(LambdaQueryWrapper) 和UpdateWrapper(LambdaUpdateWrapper) 的父类用于生成 sql 的 where 条件,entity 属性也用于生成 sql 的 where 条件。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212272224290.png" style="zoom:80%;" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMyBatisPlus</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tesQueryWrapper</span><span class="hljs-params">()</span> </span>&#123;<br>        QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();<br>        <span class="hljs-comment">/*queryWrapper</span><br><span class="hljs-comment">                .select(&quot;name&quot;, &quot;age&quot;)</span><br><span class="hljs-comment">                .eq(&quot;age&quot;, 18);*/</span><br>        <span class="hljs-comment">// lambda 方式</span><br>        queryWrapper.lambda()<br>                .select(User::getName, User::getAge)<br>                .eq(User::getAge, <span class="hljs-number">18</span>);<br>        List&lt;User&gt; users = userService.list(queryWrapper);<br>        System.out.println(users);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tesUpdateWrapper</span><span class="hljs-params">()</span> </span>&#123;<br>        UpdateWrapper&lt;User&gt; updateWrapper = <span class="hljs-keyword">new</span> UpdateWrapper&lt;&gt;();<br>        <span class="hljs-comment">/*updateWrapper</span><br><span class="hljs-comment">                //.setSql(&quot;name = &#x27;debuggingWorld&#x27;&quot;)</span><br><span class="hljs-comment">                .set(&quot;name&quot;, &quot;debuggingWorld&quot;)</span><br><span class="hljs-comment">                .eq(&quot;id&quot;, 1);*/</span><br>        updateWrapper.lambda()<br>                .set(User::getName, <span class="hljs-string">&quot;debuggingWorld&quot;</span>)<br>                .eq(User::getId, <span class="hljs-number">1</span>);<br>        userService.update(updateWrapper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="全局id生成策略">6. 全局ID生成策略</h3><p>在全局配置文件中，就不需要再每个 Pojo 主键上配置了。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">mybatis-plus</span>:<span class="hljs-string"></span><br>  <span class="hljs-meta">global-config</span>:<span class="hljs-string"></span><br>    <span class="hljs-meta">db-config</span>:<span class="hljs-string"></span><br>      <span class="hljs-meta">id-type</span>: <span class="hljs-string">auto</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-comment">//@TableId(type = IdType.AUTO)</span><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis-Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lombok</title>
    <link href="/2022/12/12/Lombok/"/>
    <url>/2022/12/12/Lombok/</url>
    
    <content type="html"><![CDATA[<h3 id="gettersetter"><strong>1. <span class="citation"data-cites="Getter">@Getter</span>/<span class="citation"data-cites="Setter">@Setter</span></strong></h3><p>自动生成 getter/setter</p><p>​ <imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212122044356.png" /></p><h3 id="tostring">2. <span class="citation"data-cites="ToString">@ToString</span></h3><p>自动重写 toString() 方法。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212122045007.png" /></p><h3 id="equalsandhashcode">3. <span class="citation"data-cites="EqualsAndHashCode">@EqualsAndHashCode</span></h3><p>自动生成 equals(Object other) 和 hashcode()方法，包括所有非静态变量和非 transient 的变量。</p><p>如果某些变量不想要加进判断，可以透过 exclude 排除，也可以使用 of指定某些字段。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212122046405.png" /></p><h3 id="noargsconstructor-allargsconstructor-requiredargsconstructor">4.<span class="citation"data-cites="NoArgsConstructor">@NoArgsConstructor</span>, <spanclass="citation"data-cites="AllArgsConstructor">@AllArgsConstructor</span>, <spanclass="citation"data-cites="RequiredArgsConstructor">@RequiredArgsConstructor</span></h3><p>这三个很像，都是在自动生成该类的构造器，差别只在生成的构造器的参数不一样而已<span class="citation"data-cites="NoArgsConstructor">@NoArgsConstructor</span> :生成一个没有参数的构造器</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212122048025.png" /></p><p><span class="citation"data-cites="AllArgsConstructor">@AllArgsConstructor</span> :生成一个包含所有参数的构造器</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212122048011.png" /></p><p><span class="citation"data-cites="RequiredArgsConstructor">@RequiredArgsConstructor</span> :生成一个包含 "特定参数" 的构造器，特定参数指的是那些有加上 final修饰词的变量们。</p><p>如果没有用 final 修饰的变量，那就会生成一个没有参数的构造器。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212122049024.png" /></p><h3 id="data">5. <span class="citation"data-cites="Data">@Data</span></h3><p>整合包，只要加了 <span class="citation"data-cites="Data">@Data</span> 这个注解，等于同时加了以下注解 <spanclass="citation" data-cites="Getter">@Getter</span>/<spanclass="citation" data-cites="Setter">@Setter</span> <spanclass="citation" data-cites="ToString">@ToString</span> <spanclass="citation"data-cites="EqualsAndHashCode">@EqualsAndHashCode</span> <spanclass="citation"data-cites="RequiredArgsConstructor">@RequiredArgsConstructor</span></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212122051200.png" /></p><h3 id="value">6. <span class="citation"data-cites="Value">@Value</span></h3><p>也是整合包，但是他会把所有的变量都设成 final 的，其他的就跟 <spanclass="citation" data-cites="Data">@Data</span>一样，等于同时加了以下注解 <span class="citation"data-cites="Getter">@Getter</span> (注意没有setter) <spanclass="citation" data-cites="ToString">@ToString</span> <spanclass="citation"data-cites="EqualsAndHashCode">@EqualsAndHashCode</span> <spanclass="citation"data-cites="RequiredArgsConstructor">@RequiredArgsConstructor</span></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212122052401.png" /></p><h3 id="builder">7. <span class="citation"data-cites="Builder">@Builder</span></h3><p>生成建造器。</p><h3 id="singular">8. <span class="citation"data-cites="Singular">@Singular</span></h3><p>在建造器中向集合中添加单个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String  name;<br>    <span class="hljs-meta">@Singular(&quot;addHobby&quot;)</span><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; hobby;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        User user = User.builder().id(<span class="hljs-number">1</span>).name(<span class="hljs-string">&quot;debuggingWorld&quot;</span>).hobby(Arrays.asList(<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;bb&quot;</span>)).addHobby(<span class="hljs-string">&quot;cc&quot;</span>).addHobby(<span class="hljs-string">&quot;dd&quot;</span>).build();<br>        <span class="hljs-comment">// User(id=1, name=debuggingWorld, hobby=[aa, bb, cc, dd])</span><br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="slf4j">8. <span class="citation"data-cites="Slf4j">@Slf4j</span></h3><p>自动生成该类的 log 静态常量。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212122154797.png" /></p><h3 id="sneakythrows">9. <span class="citation"data-cites="SneakyThrows">@SneakyThrows</span></h3><p>将异常抛向外层。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SneakyThrows(UnsupportedEncodingException.class)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">utf8ToString</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(bytes, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@SneakyThrows</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Throwable();<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">utf8ToString</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(bytes, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException var3) &#123;<br>        <span class="hljs-keyword">throw</span> var3;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Throwable();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var2) &#123;<br>        <span class="hljs-keyword">throw</span> var2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="synchronized">10. <span class="citation"data-cites="Synchronized">@Synchronized</span></h3><p>将方法变为同步方法。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212132017723.png" /></p><h3 id="cleanup">11. <span class="citation"data-cites="Cleanup">@Cleanup</span></h3><p>自动关闭资源</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212132025300.png" /></p><h3 id="accessorschain-true">12. <span class="citation"data-cites="Accessors">@Accessors</span>(chain = true)</h3><p>链式设置属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String  name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        user.setId(<span class="hljs-number">1</span>).setName(<span class="hljs-string">&quot;debuggingWorld&quot;</span>);<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="fieldnameconstants">13. <span class="citation"data-cites="FieldNameConstants">@FieldNameConstants</span></h3><p>获取属性字段名字面值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FieldNameConstants</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String  name;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; hobby;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// name</span><br>        System.out.println(Fields.name);<br>        <span class="hljs-comment">// hobby</span><br>        System.out.println(User.Fields.hobby);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lombok</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSM框架整合</title>
    <link href="/2022/12/09/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/"/>
    <url>/2022/12/09/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>整合 SSM 框架内容：</p><ol type="1"><li><strong>SpringMVC</strong><ol type="1"><li>web.xml<ul><li>前端调度器 DispatcherServlet</li><li>编码过滤器 filter</li><li>支持 rest 的过滤器</li></ul></li><li>springmvc.xml<ul><li>扫描 controller 包</li><li>添加 &lt;annotation-driver&gt;</li><li>视图解析器</li><li>静态资源解析</li></ul></li><li>添加控制器类</li></ol></li><li><strong>Spring</strong><ol type="1"><li>web.xml<ul><li>监听器（在启动web容器时加载）</li></ul></li><li>spring.xml<ul><li>扫描所有除了controller包的其他包</li><li>声明式事</li></ul></li></ol></li><li><strong>MyBatis</strong><ol type="1"><li>和 spring 整合<ul><li>将 sqlSessionFactory 配置为 spring 的 bean</li><li>数据源配置为 spring 的 bean</li><li>全局配置文件</li><li>所有 mapper 映射文件</li><li>将 mapper 接口的包交给 spring</li></ul></li><li>加入全局配置文件</li></ol></li></ol><h3 id="添加依赖">1. 添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">SPRING.VERSION</span>&gt;</span>5.3.21<span class="hljs-tag">&lt;/<span class="hljs-name">SPRING.VERSION</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--springmvc--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;SPRING.VERSION&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--spring--&gt;</span><br>    <span class="hljs-comment">&lt;!--事务--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-orm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;SPRING.VERSION&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;SPRING.VERSION&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;SPRING.VERSION&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--spring-mybatis 适配器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--mybatis核心依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--连接池--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--mysql 对应版本的连接器驱动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="web.xml">2. web.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--‐配置 DispatcherServlet--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>debugSSM<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--关联 springmvc 的配置文件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--容器启动时加载 servlet--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--‐匹配servlet的请求，/标识匹配所有请求--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>debugSSM<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--‐/*和/都是拦截所有请求，/会拦截的请求不包含*.jsp,而/*的范围更大，还会拦截*.jsp这些请求--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--spring 基于web应用的启动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--全局参数：spring配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-core.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--编码过滤器filter--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--同时开启请求和响应的编码设置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>debugSSM<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--支持rest的过滤器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>hiddenHttpMethod<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>hiddenHttpMethod<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>debugSSM<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="spring-mvc.xml">3. spring-mvc.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--扫描controller包--&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;context:component-scan base-package=&quot;com.debuggingWorld.controller&quot;&gt;&lt;/context:component-scan&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.debuggingWorld&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 添加&lt;annotation-driver&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--视图解析器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--静态资源解析--&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;mvc:resources mapping=&quot;&quot; location=&quot;&quot;&gt;&lt;/mvc:resources&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="spring-core.xml">4. spring-core.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mybatis</span>=<span class="hljs-string">&quot;http://mybatis.org/schema/mybatis-spring&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsd&quot;</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--扫描所有除了controller包的其他包--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.debuggingWorld&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--引入外部属性资源文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:db.properties&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--创建Druid数据源--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.username&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.password&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.url&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.driverClassName&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--将mapper接口交给spring管理--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mybatis:scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--SqlSessionFactory--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 指定spring中的数据源 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:com/debuggingWorld/mapper/*.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--声明式事--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--基于驱动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="mybatis-config.xml">5. mybatis-config.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--mybatis的设置选项  可以改变mybatis运行时行为--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="db.properties">6. db.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">mysql.username</span> = <span class="hljs-string">root</span><br><span class="hljs-meta">mysql.password</span>=<span class="hljs-string">mysql</span><br><span class="hljs-meta">mysql.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/debuggingworld</span><br><span class="hljs-meta">mysql.driverClassName</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><h3 id="mapper接口">7. mapper接口</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212112226853.png" /></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
      <tag>Spring</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis———分页插件&amp;逆向工程</title>
    <link href="/2022/12/04/Mybatis%E2%80%94%E2%80%94%E2%80%94%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    <url>/2022/12/04/Mybatis%E2%80%94%E2%80%94%E2%80%94%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="分页插件">1. 分页插件</h3><p><ahref="https://mybatis.org/mybatis-3/zh/configuration.html#plugins">mybatis插件官方文档</a></p><p>Mybatis 插件典型适用场景：</p><ol type="1"><li>分页功能 mybatis的分页默认是基于内存分页的（查出所有再截取），数据量大的情况下效率较低，不过使用mybatis 插件可以改变该行为，只需要拦截 StatementHandler 类的 prepare方法，改变要执行的 SQL 语句为分页语句即可；</li><li>公共字段统一赋值一般业务系统都会有创建者，创建时间，修改者，修改时间四个字段，对于这四个字段的赋值，实际上可以在DAO 层统一拦截处理，可以用 mybatis 插件拦截 Executor 类的 update方法，对相关参数进行统一赋值即可</li><li>性能监控 对于 SQL 语句执行的性能监控，可以通过拦截 Executor 类的update, query 等方法，用日志记录每个方法执行的时间。</li><li>其它 其实 mybatis 扩展性还是很强的，基于插件机制基本上可以控制 SQL执行的各个阶段，如<strong>执行阶段，参数处理阶段，语法构建阶段，结果集处理阶段</strong>，具体可以根据项目业务来实现对应业务逻辑。</li></ol><h4 id="使用">1.1 使用</h4><p><ahref="https://github.com/pagehelper/Mybatis-PageHelper">Mybatis-PageHelpergithub 地址</a></p><p>1、添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、插件注册</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--设置当前数据库的方言，默认会自动检查当前数据库环境实用的数据库--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;helperDialect&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--该参数默认为false--&gt;</span><br>        <span class="hljs-comment">&lt;!--设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用--&gt;</span><br>        <span class="hljs-comment">&lt;!--和startPage中的pageNum效果一样--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;offsetAsPageNum&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--该参数默认为false--&gt;</span><br>        <span class="hljs-comment">&lt;!--设置为true时，使用RowBounds分页会进行count查询--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;rowBoundsWithCount&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果--&gt;</span><br>        <span class="hljs-comment">&lt;!--（相当于没有执行分页查询，但是返回结果仍然是Page类型）--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pageSizeZero&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--分页合理化参数，默认值为false。当该参数设置为 true 时，pageNum&lt;=0 时会查询第一页， pageNum&gt;pages（超过总数时）</span><br><span class="hljs-comment">            ，会查询最后一页。默认false 时，直接根据参数进行查询--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;reasonable&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--为了支持startPage(Object params)方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值，</span><br><span class="hljs-comment">             可以配置 pageNum,pageSize,count,pageSizeZero,reasonable，不配置映射的用默认值，</span><br><span class="hljs-comment">             默认值为pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero。--&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;property name=&quot;params&quot; value=&quot;pageNum=start;pageSize=limit;&quot; /&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        PageHelper.startPage(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br>        List&lt;User&gt; users = mapper.selectUser();<br><br>        PageInfo&lt;User&gt; info = <span class="hljs-keyword">new</span> PageInfo&lt;&gt;(users);<br>        System.out.println(<span class="hljs-string">&quot;当前页码：&quot;</span>+info.getPageNum());<br>        System.out.println(<span class="hljs-string">&quot;每页的记录数：&quot;</span>+info.getPageSize());<br>        System.out.println(<span class="hljs-string">&quot;总记录数：&quot;</span>+info.getTotal());<br>        System.out.println(<span class="hljs-string">&quot;总页码：&quot;</span>+info.getPages());<br>        System.out.println(<span class="hljs-string">&quot;是否第一页：&quot;</span>+info.isIsFirstPage());<br>        System.out.println(info);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212042102656.png" /></p><h4 id="原理分析">1.2 原理分析</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212052218331.png" /></p><p>可以被代理的四大对象都是什么时候被代理的呢？Executor 是 openSession()的时候创建的； StatementHandler 是 SimpleExecutor.doQuery()创建的；里面包含了处理参数的 ParameterHandler 和处理结果集的ResultSetHandler 的创建，创建之后即调用InterceptorChain.pluginAll()，返回层层代理后的对象。代理是由 Plugin类创建。在我们重写的 plugin() 方法里面可以直接调用returnPlugin.wrap(target, this) 返回代理对象。</p><p>因为代理类是 Plugin，所以最后调用的是 Plugin 的 invoke()方法。它先调用了定义的拦截器的 intercept() 方法。可以通过invocation.proceed() 调用到被代理对象被拦截的方法。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212052259417.png" /></p><p>调用流程时序图：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212052300892.png" /></p><p>首先实现 Interceptor 重写 intercept() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Intercepts(</span><br><span class="hljs-meta">        &#123;</span><br><span class="hljs-meta">                @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;),</span><br><span class="hljs-meta">                @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;),</span><br><span class="hljs-meta">        &#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorUtil.pageQuery(dialect, executor,ms, parameter, rowBounds, resultHandler, boundSql, cacheKey)<br>===&gt;<br>dialect.getPageSql(ms, boundSql, parameter, rowBounds, pageKey)<br>===&gt;<br>Page page = getLocalPage()<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Page&gt; LOCAL_PAGE = <span class="hljs-keyword">new</span> ThreadLocal&lt;Page&gt;();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Page&lt;T&gt; <span class="hljs-title">getLocalPage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> LOCAL_PAGE.get();<br>&#125;<br></code></pre></td></tr></table></figure><p>调用的是 PageHelper 的一个本地线程变量中的一个 Page对象，从其中获取我们所设置的 PageSize 与PageNum，那么他是怎么设置值的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">PageHelper.startPage(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br>===&gt;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function">Page&lt;E&gt; <span class="hljs-title">startPage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pageNum, <span class="hljs-keyword">int</span> pageSize, <span class="hljs-keyword">boolean</span> count, Boolean reasonable, Boolean pageSizeZero)</span> </span>&#123;<br>    Page&lt;E&gt; page = <span class="hljs-keyword">new</span> Page&lt;E&gt;(pageNum, pageSize, count);<br>    page.setReasonable(reasonable);<br>    page.setPageSizeZero(pageSizeZero);<br>    <span class="hljs-comment">//当已经执行过orderBy的时候</span><br>    Page&lt;E&gt; oldPage = getLocalPage();<br>    <span class="hljs-keyword">if</span> (oldPage != <span class="hljs-keyword">null</span> &amp;&amp; oldPage.isOrderByOnly()) &#123;<br>        page.setOrderBy(oldPage.getOrderBy());<br>    &#125;<br>    setLocalPage(page);<br>    <span class="hljs-keyword">return</span> page;<br>&#125;<br>===&gt;<br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLocalPage</span><span class="hljs-params">(Page page)</span> </span>&#123;<br>    LOCAL_PAGE.set(page);<br>&#125;<br></code></pre></td></tr></table></figure><p>在我们调用 PageHelper.startPage(2,4) 的时候，系统会调用LOCAL_PAGE.set(page)进行设置，从而在分页插件中可以获取到这个本地变量对象中的参数进行 SQL的改写，由于改写有很多实现，这里以 Mysql 的实现为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPageSql</span><span class="hljs-params">(String sql, RowBounds rowBounds, CacheKey pageKey)</span> </span>&#123;<br>    StringBuilder sqlBuilder = <span class="hljs-keyword">new</span> StringBuilder(sql.length() + <span class="hljs-number">14</span>);<br>    sqlBuilder.append(sql);<br>    <span class="hljs-keyword">if</span> (rowBounds.getOffset() == <span class="hljs-number">0</span>) &#123;<br>        sqlBuilder.append(<span class="hljs-string">&quot;\n LIMIT &quot;</span>);<br>        sqlBuilder.append(rowBounds.getLimit());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        sqlBuilder.append(<span class="hljs-string">&quot;\n LIMIT &quot;</span>);<br>        sqlBuilder.append(rowBounds.getOffset());<br>        sqlBuilder.append(<span class="hljs-string">&quot;,&quot;</span>);<br>        sqlBuilder.append(rowBounds.getLimit());<br>        pageKey.update(rowBounds.getOffset());<br>    &#125;<br>    pageKey.update(rowBounds.getLimit());<br>    <span class="hljs-keyword">return</span> sqlBuilder.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mybatis逆向工程">2. MyBatis逆向工程</h3><p><a href="http://mybatis.org/generator/">官方文档</a></p><p><a href="https://github.com/mybatis/generator">github 地址</a></p><p>1、添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">generatorConfiguration</span> <span class="hljs-meta-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--如果需要使用 command的方式生成需要配置数据库驱动的jar包路径</span><br><span class="hljs-comment">    &lt;classPathEntry location=&quot;指定数据驱动的磁盘路径&quot;/&gt;--&gt;</span><br><br>    <span class="hljs-comment">&lt;!--context 生成上下文 配置生成规则</span><br><span class="hljs-comment">           id 随意写</span><br><span class="hljs-comment">           targetRuntime 生成策略</span><br><span class="hljs-comment">                MyBatis3DynamicSql 默认的，会生成 动态生成sql的方式（没有xml)</span><br><span class="hljs-comment">                MyBatis3 生成通用的查询，可以指定动态where条件</span><br><span class="hljs-comment">                MyBatis3Simple 只生成简单的CRUD</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;simple&quot;</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3Simple&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--设置是否生成注释  true 不生成  注意： 如果不生成注释，下次生成代码就不会进行合并--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressAllComments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--数据源 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/debuggingworld&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;root&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br><br>        <span class="hljs-comment">&lt;!--pojo</span><br><span class="hljs-comment">        javaModelGenerator  java实体生成规则(POJO)</span><br><span class="hljs-comment">            targetPackage 生成到哪个包下</span><br><span class="hljs-comment">            targetProject 生成到当前文件的哪个相对路径下</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--mapper xml映射文件</span><br><span class="hljs-comment">            sqlMapGenerator mapper xml映射文件生成规则</span><br><span class="hljs-comment">            targetPackage 生成到哪个包下</span><br><span class="hljs-comment">            targetProject 生成到当前文件的哪个相对路径下</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/resources&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--mapper接口</span><br><span class="hljs-comment">            javaClientGenerator mapper mapper接口生成规则</span><br><span class="hljs-comment">            type 指定生成的方式</span><br><span class="hljs-comment">                1.使用注解的方式生成  ANNOTATEDMAPPER</span><br><span class="hljs-comment">                2.使用接口绑定的方式生成（要配置sqlMapGenerator）XMLMAPPER</span><br><span class="hljs-comment">            targetPackage 生成到哪个包下</span><br><span class="hljs-comment">            targetProject 生成到当前文件的哪个相对路径下--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;XMLMAPPER&quot;</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>/&gt;</span><br><br>        <span class="hljs-comment">&lt;!--配置哪些表需要进行代码生成</span><br><span class="hljs-comment">        tableName 表名</span><br><span class="hljs-comment">        domainObjectName pojo类名</span><br><span class="hljs-comment">        mapperName 对应mapper接口的类名 和 mapper xml文件名</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;t_user&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;User&quot;</span> <span class="hljs-attr">mapperName</span>=<span class="hljs-string">&quot;UserMapper&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;t_dept&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Dept&quot;</span> <span class="hljs-attr">mapperName</span>=<span class="hljs-string">&quot;DeptMapper&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、生成代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    List&lt;String&gt; warnings = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    <span class="hljs-keyword">boolean</span> overwrite = <span class="hljs-keyword">true</span>;<br>    File configFile = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;generatorConfig.xml&quot;</span>);<br>    ConfigurationParser cp = <span class="hljs-keyword">new</span> ConfigurationParser(warnings);<br>    Configuration config = cp.parseConfiguration(configFile);<br>    DefaultShellCallback callback = <span class="hljs-keyword">new</span> DefaultShellCallback(overwrite);<br>    MyBatisGenerator myBatisGenerator = <span class="hljs-keyword">new</span> MyBatisGenerator(config, callback, warnings);<br>     myBatisGenerator.generate(<span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212082139765.png" /></p><p>【注】配置文件任意位置均可，上图中位于 src 同级目录。</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis——动态SQL&amp;缓存</title>
    <link href="/2022/11/28/Mybatis%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81sql-%E7%BC%93%E5%AD%98/"/>
    <url>/2022/11/28/Mybatis%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81sql-%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="动态-sql">1. 动态 SQL</h2><p>动态 sql 是基于 OGNL 的表达式的。</p><h3 id="if">1.1 if</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span><br>    SELECT * FROM t_user WHERE<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;createTime != 0&quot;</span>&gt;</span><br>        create_time &gt;= #&#123;createTime&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deptId != null&quot;</span>&gt;</span><br>        AND dept_id = #&#123;deptId&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中的条件不成立会怎么样？这个时候拼接的 sql 语句就会变得有问题。</p><p>第一个不成立或者都不成立，那么语句中就会多一个 where 或者 and关键字。</p><p>where 问题可通过添加 “1 = 1" 恒等条件解决。但 mybatis中也给出了具体的解决方案（trim、where、set）。</p><h3 id="trimwhereset">1.2 trim（where、set）</h3><p><em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE”子句。而且，若子句的开头为 “AND” 或 “OR”，<em>where</em>元素也会将它们去除。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span><br>    SELECT * FROM t_user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;createTime != 0&quot;</span>&gt;</span><br>            create_time &gt;= #&#123;createTime&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deptId != null&quot;</span>&gt;</span><br>            AND dept_id = #&#123;deptId&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>用于动态更新语句的类似解决方案叫做 <em>set</em>。<em>set</em>元素可以用于动态包含需要更新的列，忽略其它不更新的列。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span>&gt;</span><br>    update t_user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;createTime != 0&quot;</span>&gt;</span>create_time = #&#123;createTime&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deptId != null&quot;</span>&gt;</span>dept_id = #&#123;deptId&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    where user_id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>set</em> 元素会动态地在行首插入 SET关键字，并会删掉额外的逗号（createTime 后面的逗号）。</p><p>也可以通过自定义 trim 元素来定制 。</p><p>和 <em>where</em> 元素等价的自定义 trim 元素为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">   prefix：前缀，为sql整体添加一个前缀</span><br><span class="hljs-comment">   prefixOverrides:去除整体字符串前面多余的字符</span><br><span class="hljs-comment">   suffixOverrides:去除后面多余的字符</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;WHERE&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;AND |OR &quot;</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br></code></pre></td></tr></table></figure><p>和 <em>where</em> 元素等价的自定义 trim 元素为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;SET&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="foreach">1.3 foreach</h3><p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN条件语句的时候）。</p><p><em>foreach</em>元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。</p><p>可以将任何可迭代对象（如 List、Set 等）、Map对象或者数组对象作为集合参数传递给<em>foreach</em>。当使用可迭代对象或者数组时，index是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者Map.Entry 对象的集合）时，index 是键，item 是值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    collection=&quot;deptNos&quot; 指定要遍历的集合</span><br><span class="hljs-comment">    close=&quot;&quot; 表示以什么结束</span><br><span class="hljs-comment">    index=&quot;&quot; 给定一个索引值</span><br><span class="hljs-comment">    item=&quot;&quot; 遍历的每一个元素的值</span><br><span class="hljs-comment">    open=&quot;&quot; 表示以什么开始</span><br><span class="hljs-comment">    separator=&quot;&quot; 表示多个元素的分隔符</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span><br>    SELECT * FROM t_user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;deptNos&quot;</span></span><br><span class="hljs-tag">                 <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;dept_id in (&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> &gt;</span><br>            #&#123;item&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="choose-when-otherwise">1.4 choose (when, otherwise)</h3><p>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis提供了 choose 元素，它有点像 Java 中的 switch 语句。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span><br>    SELECT * FROM t_user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deptId != null&quot;</span>&gt;</span><br>                dept_id = #&#123;deptId&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;createTime != 0&quot;</span>&gt;</span><br>                create_time &gt; #&#123;createTime&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span><br>                user_id &gt; 1<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>【注】只有一个条件会成立</p></blockquote><h3 id="bind">1.5 bind</h3><p><code>bind</code> 元素允许你在 OGNL表达式以外创建一个变量，并将其绑定到当前的上下文。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bind</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#x27;%&#x27; + user.getName() + &#x27;%&#x27;&quot;</span>/&gt;</span><br>    SELECT * FROM t_user<br>    WHERE<br>    user_name LIKE #&#123;pattern&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="sql">1.6 sql</h3><p>用来定义可重用的 SQL 代码片段，以便在其它语句中使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userColumns&quot;</span>&gt;</span> $&#123;alias&#125;.user_id,  $&#123;alias&#125;.user_name <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span><br>    SELECT<br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;userColumns&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;alias&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;t&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>    FROM t_user t<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="mybatis常用ognl表达式">2. MyBatis常用OGNL表达式</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">e1 <span class="hljs-keyword">or</span> e2<br>e1 <span class="hljs-keyword">and</span> e2<br>e1 == e2,e1 eq e2<br>e1 != e2,e1 neq e2<br>e1 lt e2：小于<br>e1 lte e2：小于等于，其他gt（大于）,gte（大于等于）<br>e1 <span class="hljs-keyword">in</span> e2<br>e1 <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> e2<br>e1 + e2,e1 * e2,e1/e2,e1 ‐ e2,e1%e2<br>!e,<span class="hljs-keyword">not</span> e：非，求反<br>e.method(args)调用对象方法<br>e.property对象属性值<br>e1[ e2 ]按索引取值，List,数组和Map<br>@<span class="hljs-keyword">class</span>@<span class="hljs-function"><span class="hljs-keyword">method</span><span class="hljs-params">(args)</span>调用类的静态方法</span><br><span class="hljs-function">@<span class="hljs-title">class</span>@<span class="hljs-title">field</span>调用类的静态字段值</span><br></code></pre></td></tr></table></figure><h2 id="缓存">3. 缓存</h2><h3 id="一级缓存">3.1 一级缓存</h3><h4 id="一级缓存的使用">1. 一级缓存的使用</h4><p>一级缓存是 sqlsession 级别的缓存，默认是开启的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>        System.out.println(user);<br>        user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211302155684.png" /></p><p>发送了两个相同的请求，但是sql语句仅仅执行了一次，那么就意味着第一次查询的时候已经将结果进行了缓存。</p><h4 id="一级缓存失效">2. 一级缓存失效</h4><p>1、一级缓存是 sqlSession 级别的缓存，如果在应用程序中开启了多个sqlsession，那么会造成缓存失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>        System.out.println(user);<br>    &#125;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = sqlSessionFactory.openSession())&#123;<br>        UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211302153203.png" /></p><p>2、同一 sqlSession，如果查询语句不一样或者同一语句查询参数不一样，那么也会缓存失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>        System.out.println(user);<br>        user = mapper.selectUserById(<span class="hljs-number">3</span>);<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、同一 sqlSession，中间执行增删改操作，则会缓存失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br><br>        DeptMapper deptMapper = session.getMapper(DeptMapper.class);<br>        deptMapper.deleteDeptById(<span class="hljs-number">2</span>);<br><br>        user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、同一 sqlSession，手动执行清除缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br><br>        session.clearCache();<br><br>        user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认缓存实现类： PerpetualCache</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211302306656.png" /></p><p>一级缓存的 key：hashcode + sqlid + sql+参数+环境</p><p>执行更新操作，当前 sqlSession 缓存全部清空（会直接调用 clear方法）。</p><h3 id="二级缓存">3.2 二级缓存</h3><p>二级缓存作用域是全局，即 Application级。默认是开启的（cacheEnabled默认值为 true )，但是没有实现。</p><p>Mybatis 提供二级缓存的接口以及实现，缓存实现的时候要求实体类实现Serializable 接口，二级缓存在 sqlSession 关闭或提交之后才会生效。</p><p>一级缓存时机：查询完成进行缓存</p><p>二级缓存时机：事务提交之后（sqlSession 关闭）进行缓存</p><p>缓存查询顺序：<strong>先二级缓存再一级缓存</strong></p><h4 id="二级缓存的使用">1. 二级缓存的使用</h4><p>1、开启二级缓存</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--默认为true，显式声明，增加可读性--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211302334260.png" /></p><p>2、Mapper 映射文件中添加 &lt;cache/&gt; 标签</p><p>二级缓存是基于 Mapper 映射文件实现缓存的，基于 Mapper映射文件的命名空间来存储的。</p><p>一级 map 的 key 是 Mapper 映射文件 namespace 命名空间，value 指向二级map（PerpetualCache 中的 map )</p><figure><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211302346921.png"alt="二级缓存" /><figcaption aria-hidden="true">二级缓存</figcaption></figure><p>默认缓存效果：</p><ul><li>映射语句文件中的所有 select 语句的结果将会被缓存。</li><li>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</li><li>缓存会使用最近最少使用算法（LRU, Least RecentlyUsed）算法来清除不需要的缓存。</li><li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</li><li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li><li>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span></span><br><span class="hljs-tag">  <span class="hljs-attr">eviction</span>=<span class="hljs-string">&quot;FIFO&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">flushInterval</span>=<span class="hljs-string">&quot;60000&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;512&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">readOnly</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>这个更高级的配置创建了一个 FIFO 缓存，每隔 60秒刷新，最多可以存储结果对象或列表的 512个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。</p><p>可用的清除策略有：</p><ul><li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象。</li><li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们。</li><li><code>SOFT</code> –软引用：基于垃圾回收器状态和软引用规则移除对象。</li><li><code>WEAK</code> –弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</li></ul><p>默认的清除策略是 LRU。</p><p>flushInterval（刷新间隔）属性可以被设置为任意的正整数，设置的值应该是一个以毫秒为单位的合理时间量。默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新。</p><p>size（引用数目）属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是1024。</p><p>readOnly（只读）属性可以被设置为 true 或false。只读的缓存会给所有调用者返回缓存对象的相同实例。因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。速度上会慢一些，但是更安全，因此默认值是 false。</p><p>type二级缓存实现类，默认值：org.apache.ibatis.cache.impl.PerpetualCache</p><p>3、使用到二级缓存的 javaBean 需要实现 Serializable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212012226849.png" /></p><h4 id="二级缓存失效">2. 二级缓存失效</h4><p>1、同一命名空间进行增删改，会导致二级缓存失效。</p><p>可以将 flushCache 设置为 false 不清空缓存，默认为true。谨慎设置！！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        mapper.updateUser(<span class="hljs-keyword">new</span> User(<span class="hljs-number">6</span>,<span class="hljs-string">&quot;aaa&quot;</span>,<span class="hljs-number">234</span>,<span class="hljs-string">&quot;1&quot;</span>));<br>        session.commit();<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、设置查询不缓存数据到二级缓存中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span> <span class="hljs-attr">useCache</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>useCache 默认为 true。</p><p>另外，查询语句也有 flushCache ，但是默认值为 false。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span> <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、使用 cache-ref 增删改的时候清空指定 nameSpace 的缓存。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache-ref</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper.DeptMapper&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>引用 nameSpace 所指定 mapper 映射文件的缓存机制，执行增删改会清空执行nameSpace 的缓存。</p><p>限制：只能引用一个 nameSpace。</p><h3 id="整合第三方缓存">3.3 整合第三方缓存</h3><p>https://github.com/hazendaz/redis-cache</p><p>1、添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.caches<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-beta2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、添加 redis 配置类</p><p>redis.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">redis.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-meta">redis.port</span>=<span class="hljs-string">6379</span><br><span class="hljs-meta">redis.connectionTimeout</span>=<span class="hljs-string">5000</span><br><span class="hljs-meta">redis.soTimeout</span>=<span class="hljs-string">5000</span><br><span class="hljs-meta">redis.password</span>=<span class="hljs-string"></span><br><span class="hljs-meta">redis.database</span>=<span class="hljs-string">0</span><br><span class="hljs-meta">redis.clientName</span>=<span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>3、设置 mybatis 二级缓存实现类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.acme.FooMapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.mybatis.caches.redis.RedisCache&quot;</span> /&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis——参数\查询结果处理&amp;高级结果映射</title>
    <link href="/2022/11/23/Mybatis%E2%80%94%E2%80%94%E5%8F%82%E6%95%B0-%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86-%E9%AB%98%E7%BA%A7%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84/"/>
    <url>/2022/11/23/Mybatis%E2%80%94%E2%80%94%E5%8F%82%E6%95%B0-%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86-%E9%AB%98%E7%BA%A7%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h3 id="参数处理">1. 参数处理</h3><h4 id="参数取值方式">1. 1 参数取值方式</h4><p>sql 语句有两种取值方式，分别是 <strong>#{}</strong> 和<strong>${}</strong>。</p><ul><li>#{} 是预编译处理，${} 是字符串替换。</li><li>Mybatis 在处理 #{} 时，会将 sql 中的 #{} 替换为 ? 号，调用PreparedStatement 的 set 方法来赋值；</li><li>Mybatis 在处理 ${} 替换成变量的值。</li><li>使用 #{} 可以有效的防止 SQL 注入，提高系统安全性。</li></ul><h5 id="方式">#{} 方式</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo.User&quot;</span>&gt;</span><br>SELECT * FROM t_user WHERE id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>执行过程：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211261150309.png" /></p><h5 id="方式-1">${} 方式</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo.User&quot;</span>&gt;</span><br>    SELECT * FROM t_user WHERE id = $&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>执行过程：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211261151527.png" /></p><p>特殊用法： + 调试时可以临时使用（打印完整 sql 语句）。 +实现一些特殊功能：前提一定要保证数据的安全性。比如：动态表、动态列。</p><p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo.User&quot;</span>&gt;</span><br>    SELECT * FROM $&#123;table&#125; WHERE id = 1<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211261151320.png" /></p><p>使用 #{} 将报错： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo.User&quot;</span>&gt;</span><br>    SELECT * FROM #&#123;table&#125; WHERE id = 1<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211261152526.png" /></p><h4 id="参数传递">1.2 参数传递</h4><h5 id="单个参数">1. 单个参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">User <span class="hljs-title">selectUser</span><span class="hljs-params">(Integer id)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>mybatis 不会做任何特殊要求</li><li>获取方式： #:{输入任何字符获取参数}</li><li>也可用 <span class="citation" data-cites="Param">@Param</span>()指定参数名</li></ul><p>##### 2. 多个参数 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">User <span class="hljs-title">selectUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Integer id, <span class="hljs-meta">@Param(&quot;username&quot;)</span> String userName)</span></span>;<br></code></pre></td></tr></table></figure></p><ul><li>mybatis 会进行封装，会将传进来的参数封装成 map，一个值对应两个map。</li><li>id ===&gt; { key:arg0, value:id 的值 }，{key:param1, value:id的值}</li><li>userName===&gt; {key:arg1, value:id 的值}, {key:param2 ,value:id的值}</li><li>获取方式<ul><li>id ===&gt; #{arg0} 或者 #{param1}</li><li>username ===&gt; #{arg1} 或者 #{param2}</li></ul></li><li>设置参数的别名：User selectUser(<span class="citation"data-cites="Param">@Param</span>("id") Integer id, <spanclass="citation" data-cites="Param">@Param</span>("username") StringuserName)</li><li>当使用了 <span class="citation" data-cites="Param">@Param</span>:<ul><li>id ===&gt; #{id} 或者 #{param1}</li><li>username ===&gt; #{username} 或者 #{param2}</li></ul></li></ul><h5 id="javabean-参数">3. javaBean 参数</h5><p><strong>单个参数:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">User <span class="hljs-title">selectUser</span><span class="hljs-params">(User user)</span></span><br></code></pre></td></tr></table></figure><ul><li>获取方式：可以直接使用属性名<ul><li>user.id ===&gt; #{id}</li><li>user.name ===&gt; #{name}</li></ul></li></ul><p><strong>多个参数:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">User <span class="hljs-title">selectUser</span><span class="hljs-params">(Integer num, User user)</span></span><br></code></pre></td></tr></table></figure><ul><li>num ===&gt; #{param1} 或者 <span class="citation"data-cites="Param">@Param</span>()</li><li>user===&gt; 必须加上对象别名<ul><li>user.id ===&gt; #{param2.id} 或者 <span class="citation"data-cites="Param">@Param</span>("user") User user ===&gt;#{user.id}</li><li>user.name ===&gt; #{param2.name} 或者 <span class="citation"data-cites="Param">@Param</span>("user") User user ===&gt;#{emp.username}</li></ul></li></ul><h5 id="集合或数组参数">4. 集合或数组参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">User <span class="hljs-title">selectUser</span><span class="hljs-params">(List&lt;String&gt; userNames)</span></span>;<br></code></pre></td></tr></table></figure><p>如果是 list，MyBatis 会自动封装为 map ： {key："list"；value：userNames}</p><ul><li>没用 <span class="citation" data-cites="Param">@Param</span>获取：userNames.get(0) ===&gt; #{ list[0] } / #{ arg0[0] }</li><li>有 <span class="citation"data-cites="Param">@Param</span>("userNames") 获取：userNames.get(0)===&gt; #{ userNames[0] } / #{ param1[0] }</li></ul><p>如果是数组，MyBatis 会自动封装为 map：{ key ："array"；value：userNames }</p><ul><li>没用 <span class="citation" data-cites="Param">@Param</span>获取：userNames.get(0) ===&gt; #{ array[0] } / #{ arg0[0] }</li><li>有 <span class="citation"data-cites="Param">@Param</span>("userNames") 获取：userNames.get(0)===&gt; #{ userNames[0] } / #{ param1[0] }</li></ul><h5 id="map-参数">5. map 参数</h5><p>和 javaBean 参数传递是一样。</p><h3 id="集合返回结果处理">2. 集合返回结果处理</h3><p>1、当返回值的结果是集合的时候，返回值的类型依然写的是集合中具体的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">selectAllUser</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAllUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo.User&quot;</span>&gt;</span><br>    SELECT * FROM t_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、在查询的时候可以设置返回值的类型为 map，mybatis 会把列的名作为key，列的值作为 value，转换到 map 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Map&lt;String,Object&gt; <span class="hljs-title">selectUser</span><span class="hljs-params">(Integer id)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>    SELECT * FROM t_user WHERE id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、使用 <span class="citation" data-cites="MapKey">@MapKey</span>将集合转为 map。</p><p><ahref="https://blog.csdn.net/qq_41057885/article/details/125824289"><spanclass="citation" data-cites="MapKey">@MapKey</span> 用法</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapKey(&quot;id&quot;)</span><br><span class="hljs-function">Map&lt;Integer,User&gt; <span class="hljs-title">selectAllUser</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAllUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo.User&quot;</span>&gt;</span><br>    SELECT * FROM t_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="自定义结果集-resultmap">3. 自定义结果集 ­­­resultMap</h3><p>resultType 和 resultMap 自定义结果集只能使用一个。</p><ul><li>id：唯一标识， 需要和 select 标签上的 resultMap 属性进行对应。</li><li>type：需要映射的 pojo 对象， 可以设置别名</li><li>autoMapping：自动映射（默认=true），只要字段名和属性名遵循映射规则就可以自动映射，但是不建议，哪怕属性名和字段名一一对应也要显式配置映射</li><li>extends 如果多个 resultMap 有重复映射，可以声明父resultMap，将公共的映射提取出来， 减少子 resultMap 的映射冗余</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;common_map&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">autoMapping</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>   <span class="hljs-comment">&lt;!-- &lt;id&gt; 主键必须使用，对底层存储有性能作用</span><br><span class="hljs-comment">        column 需要映射的数据库字段名</span><br><span class="hljs-comment">        property 需要映射的 pojo 属性名</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user_map&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">autoMapping</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">extends</span>=<span class="hljs-string">&quot;common_map&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;createTime&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;create_time&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAllUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;user_map&quot;</span>&gt;</span><br>    SELECT * FROM t_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="高级结果映射">4. 高级结果映射</h3><h4 id="联合查询">4.1 联合查询</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 实现表联结查询的方式： 可以映射: DTO --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userQueryDTO&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;userDTO&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;useId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 实现表联结查询的方式： 可以映射map --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userQueryMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;useId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userQueryDTO&quot;</span>&gt;</span><br>    SELECT u.user_id,u.user_name,d.dept_id,  d.dept_name FROM t_user u Inner JOIN  t_dept d  ON u.user_id = d.dept_id WHERE user_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser02&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userQueryMap&quot;</span>&gt;</span><br>    SELECT u.user_id,u.user_name,d.dept_id,  d.dept_name FROM t_user u Inner JOIN  t_dept d  ON u.user_id = d.dept_id WHERE user_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="嵌套结果">4.2 嵌套结果</h4><h5 id="多对一">1. 多对一</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> id;<br>    String name;<br>    Dept dept;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userQuery&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">         association 实现多对一中的 “一”</span><br><span class="hljs-comment">         property 指定对象中嵌套对象属性</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser03&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userQuery&quot;</span>&gt;</span><br>    SELECT u.user_id, u.user_name, d.dept_id, d.dept_name<br>    FROM t_user u<br>             Inner JOIN t_dept d ON u.user_id = d.dept_id<br>    WHERE user_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="一对多">2. 一对多</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dept</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> deptId;<br>    String deptName;<br>    List&lt;User&gt; users;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deptWithUser&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;dept&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">         collection 映射一对多中的 “多”</span><br><span class="hljs-comment">         property 指定需要映射的“多”的属性，一般声明为List</span><br><span class="hljs-comment">         ofType 需要指定list的类型</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;users&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="嵌套查询分步查询">4.3 嵌套查询（分步查询）</h4><h5 id="多对一-1">1. 多对一</h5><p>联合查询和分步查询区别：</p><ul><li>性能区别不大</li><li>分步查询支持懒加载（延迟加载）</li><li>需要设置懒加载，一定要使用嵌套查询的。</li><li>要启动懒加载可以在全局配置文件中设置 lazyLoadingEnabled=true</li><li>还可以单独为某个分步查询设置立即加载 association 标签fetchType="eager"</li></ul><p>UserMapper.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userQuery&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        property 指定对象中的嵌套对象属性</span><br><span class="hljs-comment">        column 指定将哪个字段传到分步查询中</span><br><span class="hljs-comment">        select 指定分步查询的 命名空间+ID</span><br><span class="hljs-comment">        以上3个属性是实现分步查询必须的属性</span><br><span class="hljs-comment">        fetchType 可选 eager|lazy ,指定属性后，将在映射中忽略全局配置参数 lazyLoadingEnabled 使用属性的值。</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span> <span class="hljs-attr">fetchType</span>=<span class="hljs-string">&quot;lazy&quot;</span></span><br><span class="hljs-tag">                 <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper.DeptMapper.selectDept&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser03&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userQuery&quot;</span>&gt;</span><br>    SELECT *<br>    FROM t_user<br>    WHERE user_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>DeptMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectDept&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;dept&quot;</span>&gt;</span><br>    SELECT * FROM t_dept where dept_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>未开启懒加载：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211271611984.png" /></p><p>开启懒加载：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211271602813.png" /></p><h5 id="一对多-1">2. 一对多</h5><p>DeptMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deptMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;dept&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;users&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span> <span class="hljs-attr">fetchType</span>=<span class="hljs-string">&quot;lazy&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper.UserMapper.selectUserByDept&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectDept&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;deptMap&quot;</span>&gt;</span><br>    SELECT * FROM t_dept where dept_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>UserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;users&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserByDept&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;users&quot;</span>&gt;</span><br>    SELECT *<br>    FROM t_user<br>    WHERE dept_id=#&#123;deptId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="延迟查询">5. 延迟查询</h3><p>当我们在进行表关联的时候，有可能查询结果不需要关联对象的属性值，那么此时可以通过延迟加载来实现该功能。在全局配置文件中添加如下属性：</p><p>mybatis­config.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--开启延迟加载，所有分步查询都是懒加载 （默认是立即加载）--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--当开启时， 使用pojo中任意属性都会加载延迟查询 ,默认是false（在 3.4.1 及之前的版本中默认为 true）--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;aggressiveLazyLoading&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--设置对象的哪些方法调用会加载延迟查询 默认： equals,clone,hashCode,toString--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>如果设置了全局懒加载，但是希望在某一个 sql语句查询的时候不使用延时策略，可以添加 fetchType 属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span> <span class="hljs-attr">fetchType</span>=<span class="hljs-string">&quot;eager&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper.DeptMapper.selectDept&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>【注】</p><p>默认 equals,clone,hashCode,toString 触发懒加载</p><p>使用lombok默认的@ToString 打印时会默认调用的是 getField()而非成员</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis——入门&amp;日志&amp;配置文件详解</title>
    <link href="/2022/11/16/Mybatis%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/11/16/Mybatis%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="简介">1. 简介</h3><p>MyBatis 是一款优秀的持久层框架/半自动的ORM，它支持自定义SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML或注解来配置和映射原始类型、接口和 Java POJO 为数据库中的记录。</p><p><strong>优点：</strong> 1. 与 JDBC 相比，减少了50%的代码量 2.最简单的持久化框架，简单易学 3. SQL代码从程序代码中彻底分离出来，可以重用 4. 提供 XML 标签，支持编写动态SQL 5. 提供映射标签，支持对象与数据库的 ORM 字段关系映射 6.支持缓存、连接池、数据库移植....</p><p><strong>缺点：</strong> 1. SQL 语句编写工作量大，熟练度要高 2.数据库移植性比较差，如果需要切换数据库的话，SQL 语句会有很大的差异</p><h4 id="执行流程">1.1 执行流程</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221116235420.png" /></p><ol type="1"><li>加载 mybatis全局配置文件（数据源、事务、mapper映射文件等），解析配置文件，MyBatis基于 XML 配置文件生成 Configuration，和一个个MappedStatement（包括了参数映射配置、动态SQL语句、结果映射配置），其对应着&lt;select | update | delete | insert&gt; 标签项。</li><li>SqlSessionFactoryBuilder 通过 Configuration 对象生成SqlSessionFactory，用来开启 SqlSession。</li><li>SqlSession 对象完成和数据库的交互：<ul><li>用户程序调用 mybatis 接口层 api（即 Mapper 接口中的方法）</li><li>SqlSession 通过调用 api 的 Statement ID 找到对应的 MappedStatemen对象</li><li>通过 Executor（负责动态SQL的生成和查询缓存的维护）将MappedStatement对象进行解析，sql 参数转化、动态 sql 拼接，生成 jdbc Statement 对象</li><li>JDBC 执行 sql。</li><li>借助 MappedStatement 中的结果映射关系，将返回结果转化成HashMap、JavaBean 等存储结构并返回。</li></ul></li></ol><h3 id="基本使用">2. 基本使用</h3><h4 id="pom-依赖">2.1 pom 依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>驱动版本和数据库版本对应关系：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221115202610.png" /></p><h4 id="创建数据表以及对应的实体类对象">2.2创建数据表以及对应的实体类对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> id;<br>    String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="创建对应的-mapper-接口">2.3 创建对应的 Mapper 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;<br>    <span class="hljs-function">User <span class="hljs-title">selectUser</span><span class="hljs-params">(Integer id)</span></span>;<br><br>    <span class="hljs-meta">@Select(&quot;select * from t_user where id = #&#123;id&#125; &quot;)</span><br>    <span class="hljs-function">User <span class="hljs-title">selectUser2</span><span class="hljs-params">(Integer id)</span></span>;<br><br>    <span class="hljs-function">Integer <span class="hljs-title">insertUser</span><span class="hljs-params">(User user)</span></span>;<br><br>    <span class="hljs-function">Integer <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span></span>;<br><br>    <span class="hljs-function">Integer <span class="hljs-title">deleteUser</span><span class="hljs-params">(Integer id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="编写配置文件">2.4 编写配置文件</h4><p><strong>mybatis-config.xml</strong> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/debuggingworld&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;mapper resource=&quot;com/debuggingWorld/mapper/UserMapper.xml&quot;/&gt;--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper.UserMapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure> 驱动路径</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221115215302.png" /></p><p><strong>UserMapper.xml</strong> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper.UserMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo.User&quot;</span>&gt;</span><br>        SELECT * FROM t_user WHERE id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span>&gt;</span><br>        insert into t_user (name) values (#&#123;name&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span>&gt;</span><br>        update t_user set name =  (#&#123;name&#125;) where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUser&quot;</span>&gt;</span><br>        delete from t_user where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure> #### 2.5 测试<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMybatis</span> </span>&#123;<br>    SqlSessionFactory sqlSessionFactory;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        InputStream inputStream = Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>        <span class="hljs-keyword">this</span>.sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基于 statementId 的方式执行 sql</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;mapper resource=&quot;com/debuggingWorld/mapper/UserMapper.xml&quot;/&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>            User user = session.selectOne(<span class="hljs-string">&quot;com.debuggingWorld.mapper.UserMapper.selectUser&quot;</span>, <span class="hljs-number">1</span>);<br>            System.out.println(user);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基于接口绑定的方式</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 1. 方法名要和 mapper 中对应操作节点 id 一致</span><br><span class="hljs-comment">     * 2. 方法返回类型要和 mapper 中对应操作节点 resultType 一致</span><br><span class="hljs-comment">     * 3. mapper 中对应操作节点的参数必须在方法参数中申明</span><br><span class="hljs-comment">     * 4. mapper 中的 namespace 必须和接口的完整限定名一致</span><br><span class="hljs-comment">     * 5. mybatis 全局配置文件 mappers 中添加申明   &lt;mapper class=&quot;com.debuggingWorld.mapper.UserMapper&quot;/&gt;</span><br><span class="hljs-comment">     * 6. 一定要将 mapper.xml 和接口放在同一级目录（maven 项目中只需要在 resources 中新建同样的目录结构即可，编译时会进行合并）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>            UserMapper mapper = session.getMapper(UserMapper.class);<br>            User user = mapper.selectUser(<span class="hljs-number">1</span>);<br>            System.out.println(user);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基于注解的方式</span><br><span class="hljs-comment">     * 1. 注解方式和xml方式可以共用，但是不能同一方法不能同时存在 xml id 和注解方式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>            UserMapper mapper = session.getMapper(UserMapper.class);<br>            User user = mapper.selectUser2(<span class="hljs-number">1</span>);<br>            System.out.println(user);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>            UserMapper mapper = session.getMapper(UserMapper.class);<br>            User user = <span class="hljs-keyword">new</span> User(<span class="hljs-number">17</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>);<br>            Integer result = mapper.updateUser(user);<br>            System.out.println(result);<br>            <span class="hljs-comment">// 默认手动提交</span><br>            session.commit();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221117214922.png" /></p><h3 id="日志">3. 日志</h3><p><a href="https://mybatis.org/mybatis-3/zh/logging.html">mybatis日志模块文档</a></p><p>Mybatis通过使用内置的日志工厂提供日志功能。内置日志工厂将会把日志工作委托给下面的实现之一：</p><ul><li>SLF4J</li><li>Apache Commons Logging</li><li>Log4j 2</li><li>Log4j （3.5.9 起废弃）</li><li>JDK logging</li></ul><p>MyBatis内置日志工厂基于运行时自省机制选择合适的日志工具。它会使用第一个查找得到的工具（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。如果你的应用部署在一个类路径已经包含 Commons Logging的环境中，而你又想使用其它日志工具，你可以通过在 MyBatis 配置文件mybatis-config.xml 里面添加一项 setting 来选择别的日志工具。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SLF4J&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="slf4j-logback">3.1 SLF4J + Logback</h4><p><a href="https://github.com/YLongo/logback-chinese-manual">logback中文文档</a></p><p>1、添加依赖 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.36<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure> 2、配置文件 应用的类路径中创建一个名称为logback.xml 的文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--为指定包、类设置日志级别--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;com.debuggingWorld.mapper.UserMapper&quot;</span> <span class="hljs-attr">level</span> = <span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--全局设置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>level 属性的值可以为：TRACE、DEBUG、INFO、WARN、ERROR、ALL、OFF。</p><p>3、测试</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221120201234.png" /></p><h3 id="配置文件">4. 配置文件</h3><h4 id="全局配置文件">4.1 全局配置文件</h4><p><a href="https://mybatis.org/mybatis-3/zh/configuration.html">mybatis配置文档</a></p><p>执行器类型： + SIMPLE：普通的执行器 +REUSE：执行器会重用预处理语句（PreparedStatement） +BATCH：执行器不仅重用语句还会执行批量更新。</p><p>内置别名</p><table><tbody><tr><td>_byte</td><td>byte</td></tr><tr><td>_char (since 3.5.10)</td><td>char</td></tr><tr><td>_character (since 3.5.10)</td><td>char</td></tr><tr><td>_long</td><td>long</td></tr><tr><td>_short</td><td>short</td></tr><tr><td>_int</td><td>int</td></tr><tr><td>_integer</td><td>int</td></tr><tr><td>_double</td><td>double</td></tr><tr><td>_float</td><td>float</td></tr><tr><td>_boolean</td><td>boolean</td></tr><tr><td>string</td><td>String</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>char (since 3.5.10)</td><td>Character</td></tr><tr><td>character (since 3.5.10)</td><td>Character</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>integer</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>date</td><td>Date</td></tr><tr><td>decimal</td><td>BigDecimal</td></tr><tr><td>bigdecimal</td><td>BigDecimal</td></tr><tr><td>biginteger</td><td>BigInteger</td></tr><tr><td>object</td><td>Object</td></tr><tr><td>date[]</td><td>Date[]</td></tr><tr><td>decimal[]</td><td>BigDecimal[]</td></tr><tr><td>bigdecimal[]</td><td>BigDecimal[]</td></tr><tr><td>biginteger[]</td><td>BigInteger[]</td></tr><tr><td>object[]</td><td>Object[]</td></tr><tr><td>map</td><td>Map</td></tr><tr><td>hashmap</td><td>HashMap</td></tr><tr><td>list</td><td>List</td></tr><tr><td>arraylist</td><td>ArrayList</td></tr><tr><td>collection</td><td>Collection</td></tr><tr><td>iterator</td><td>Iterator</td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--就是 DOCTYPE 后面对应的根节点--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--配置外部属性资源文件  通过$&#123;&#125;进行引用--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--可以在定义内部的属性  引用方式是一样的--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mysql.username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--mybatis的设置选项  可以改变mybatis运行时行为--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--是否允许在SQL中使用别名  默认是允许： 当设置别名后会根据 SQL 的别名和属性名进行映射  </span><br><span class="hljs-comment">（不会去设置该选项）</span><br><span class="hljs-comment">        &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;--&gt;</span><br><br>        <span class="hljs-comment">&lt;!--用于当字段名和属性名自动映射不匹配时 发生的动作</span><br><span class="hljs-comment">            默认：NONE      什么都不发生，没有映射上就不赋值</span><br><span class="hljs-comment">                 WARNING   发送一条级别为WARN的日志</span><br><span class="hljs-comment">                 FAILING   当映射不上直接报错</span><br><span class="hljs-comment">                 通常不会去设置</span><br><span class="hljs-comment">        &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;FAILING&quot;/&gt;</span><br><span class="hljs-comment">        --&gt;</span><br><br>        <span class="hljs-comment">&lt;!--设置默认执行器</span><br><span class="hljs-comment">        SIMPLE 就是普通的执行器； 默认</span><br><span class="hljs-comment">        REUSE 执行器会重用预处理语句（PreparedStatement）；</span><br><span class="hljs-comment">        BATCH 执行器不仅重用语句还会执行批量更新。</span><br><span class="hljs-comment">        &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;REUSE&quot;/&gt;</span><br><span class="hljs-comment">        --&gt;</span><br><br>        <span class="hljs-comment">&lt;!--设置查询的超时时间  单位：秒</span><br><span class="hljs-comment">        &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;1&quot;/&gt;</span><br><span class="hljs-comment">        --&gt;</span><br><br>        <span class="hljs-comment">&lt;!--是否将数据库的蛇形命名映射为驼峰命名</span><br><span class="hljs-comment">        可以支持 蛇形 debug_world   到驼峰 debugWorld  或 debugworld   的自动映射</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><br>        <span class="hljs-comment">&lt;!--当往数据库插入数据某个数据值为 null 时映射到数据库的类型</span><br><span class="hljs-comment">        默认：OTHER   mysql 是可以识别出 OTHER 类型的</span><br><span class="hljs-comment">             NULL    如果是 oracle 一定要设置成 NULL, ORACLE 识别不出 OTHER 类型</span><br><span class="hljs-comment">             VARCHAR 当属性值为空时为数据库设置一个空字符串</span><br><span class="hljs-comment">        &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt;--&gt;</span><br><br>        <span class="hljs-comment">&lt;!--加入 mybatis 框架中实现了多个日志框架， 可以使用 logImpl 来设置使用的日志框架</span><br><span class="hljs-comment">        &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&gt;</span><br><span class="hljs-comment">        --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--根据包设置包里面所有的类的别名 :会将类的名字作为别名（忽略大小写）</span><br><span class="hljs-comment">            还可以为包里面的类单独设置个性别名：@Alias   （默认的以类的名字作为别名就会失效）</span><br><span class="hljs-comment">            除了可以设置自定义的类的别名以为，mybatis 还内置很多常见类型的别名</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;typeAlias alias=&quot;User&quot; type=&quot;com.debuggingWorld.pojo.User&quot;/&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">     插件：可以把它理解成mybatis的拦截器，可以拦截4大对象，可以拦截SQL 给SQL去加一些公共的功能</span><br><span class="hljs-comment">     &lt;plugins&gt;</span><br><span class="hljs-comment">         &lt;plugin interceptor=&quot;org.mybatis.example.ExamplePlugin&quot;&gt;</span><br><span class="hljs-comment">             &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;</span><br><span class="hljs-comment">         &lt;/plugin&gt;</span><br><span class="hljs-comment">     &lt;/plugins&gt;--&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- environments 可以多个环境</span><br><span class="hljs-comment">       default 默认的数据库环境</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--environment  配置数据库环境  id 指定当前数据库环境的唯一表示，  会被父节点default所设置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--事务管理器 类型</span><br><span class="hljs-comment">              type = JDBC  使用jdbc的事务管理</span><br><span class="hljs-comment">                     MANAGED  不运用事务</span><br><span class="hljs-comment">            --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!--数据源</span><br><span class="hljs-comment">                type 指定连接池</span><br><span class="hljs-comment">                POOLED  指定使用mybatis的连接池</span><br><span class="hljs-comment">                UNPOOLED 不使用连接池</span><br><span class="hljs-comment">                JNDI JNDI连接池 可以在 tomcat 中使用</span><br><span class="hljs-comment">            --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.driver&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.url&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.username&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.password&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis_test&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    数据库厂商表示：mybatis 提供用于跨数据库平台，用于根据不同的数据库调用不同SQL</span><br><span class="hljs-comment">    type=&quot;DB_VENDOR&quot; 利用数据库的厂商名称来区分</span><br><span class="hljs-comment">    步骤：</span><br><span class="hljs-comment">        1.为需要跨越数据库设置不同的厂商名称</span><br><span class="hljs-comment">        2.编写不同的SQL   databaseId 必须指定厂商的value</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">databaseIdProvider</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;DB_VENDOR&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MySQL&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Oracle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;ora&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">databaseIdProvider</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--设置映射器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--4种映射方式</span><br><span class="hljs-comment">                1.&lt;mapper resource   设置MapperXml 这种方式适用根据statementId进行操作</span><br><span class="hljs-comment">                2.&lt;mapper class      设置Mapper接口 这种方式适用接口绑定的方式和注解</span><br><span class="hljs-comment">                3.&lt;mapper url        使用磁盘的绝对路径（基本不用）</span><br><span class="hljs-comment">                4.&lt;package           根据包设置包下面所有的Mapper接口, 这种方式适用接口绑定的方式和注解</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;mapper resource=&quot;com/debuggingWorld/mapper/UserMapper.xml&quot;/&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;mapper class=&quot;com.debuggingWorld.mapper.UserMapper&quot;/&gt;--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="sql-映射文件">4.2 SQL 映射文件</h4><p><a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html">xml映射文件文档</a></p><p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：</p><ul><li>cache – 该命名空间的缓存配置。</li><li>cache-ref – 引用其它命名空间的缓存配置。</li><li>resultMap –描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。</li><li>sql – 可被其它语句引用的可重用语句块。</li><li>insert – 映射插入语句。</li><li>update – 映射更新语句。</li><li>delete – 映射删除语句。</li><li>select – 映射查询语句。</li></ul><p><strong>insert、update、delete元素：</strong></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td>parameterType</td><td>将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为MyBatis可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</td></tr><tr><td>flushCache</td><td>将其设置为 true后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对insert、update 和 delete 语句）true。</td></tr><tr><td>timeout</td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td></tr><tr><td>statementType</td><td>可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用Statement，PreparedStatement 或CallableStatement，默认值：PREPARED。</td></tr><tr><td>useGeneratedKeys</td><td>（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQLServer 这样的关系型数据库管理系统的自动递增字段），默认值：false。</td></tr><tr><td>keyProperty</td><td>（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey子元素设置它的值，默认值：未设置（unset）。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr><tr><td>keyColumn</td><td>（仅适用于 insert 和update）设置生成键值在表中的列名，在某些数据库（像PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr><tr><td>databaseId</td><td>如果配置了数据库厂商标识（databaseIdProvider），MyBatis会加载所有不带 databaseId 或匹配当前 databaseId的语句；如果带和不带的语句都有，则不带的会被忽略。</td></tr></tbody></table><h5 id="主键回填">主键回填</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>    insert into user(user_name) values(#&#123;userName&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><span class="hljs-comment">&lt;!--如果数据库不支持自增的话，那么可以使用如下的方式进行赋值查询--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser2&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;integer&quot;</span>&gt;</span><br>        select max(id)+1 from user<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span><br>    insert into user(id,user_name) values(#&#123;id&#125;,#&#123;userName&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC——父子容器启动源码解析</title>
    <link href="/2022/11/06/SpringMVC%E2%80%94%E2%80%94%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/11/06/SpringMVC%E2%80%94%E2%80%94%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>https://www.processon.com/view/link/637251aa6376897f2b764170</p><h3 id="spi">1. SPI</h3><p>SPI 全称 Service Provider Interface，是 Java提供的一套用来被第三方实现或者扩展的接口，它可以用来启用框架扩展和替换组件。SPI 的作用就是为这些被扩展的 API 寻找服务实现。</p><h4 id="spi-和-api">1.1 SPI 和 API</h4><blockquote><p>API （Application ProgrammingInterface）在大多数情况下，都是实现方制定接口并完成对接口的实现，调用方仅仅依赖接口调用，且无权选择不同实现。从使用人员上来说，API 直接被应用开发人员使用。 SPI （Service ProviderInterface）是调用方来制定接口规范，提供给外部来实现，调用方在调用时则选择自己需要的外部实现。从使用人员上来说，SPI 被框架扩展人员使用。</p></blockquote><h4 id="使用">1.2 使用</h4><p>1、服务提供者 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserDao</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure> <imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221108201608.png" /></p><p>2、服务实现者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUserDao</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;spi_implementer UserDaoImpl&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>resources-INF.debuggingWorld.dao.IUserDao <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.debuggingWorld</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.impl</span>.UserDaoImpl<br></code></pre></td></tr></table></figure></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221108201909.png" /></p><p>3、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ServiceLoader&lt;IUserDao&gt; daos = ServiceLoader.load(IUserDao.class);<br>        <span class="hljs-keyword">for</span> (IUserDao dao : daos) &#123;<br>            dao.save();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="spring-整合-springmvc">2. Spring 整合 SpringMVC</h3><h4 id="特性">2.1 特性</h4><p>说到 Spring 整合 SpringMVC 唯一的体现就是父子容器： +通常设置父容器（Spring）管理 Service、Dao 层的 Bean,子容器（SpringMVC）管理 Controller 的 Bean + 子容器可以访问父容器的Bean, 父容器无法访问子容器的 Bean。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221107212226.png" /></p><h4 id="实现">2.2 实现</h4><p>相信大家在 SSM 框架整合的时候都曾在 web.xm l配置过这段：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--spring 基于web应用的启动--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br><span class="hljs-comment">&lt;!--全局参数：spring配置文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-core.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><span class="hljs-comment">&lt;!--前端调度器servlet--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--设置配置文件的路径--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--设置启动即加载--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>有人可能只知道 DispatcherServlet 叫前端控制器，是 SpringMVC处理前端请求的一个核心调度器。那它为什么能处理请求？处理之前做了什么准备工作呢？又是怎么和Spring 结合起来的呢？ 为什么有了 DispatcherServlet 还要个ContextLoaderListener， 配一个不行吗？干嘛要配俩啊？</p><h3 id="零配置整合-springmvc-的方式">3. 零配置整合 SpringMVC 的方式</h3><p>没有配置就需要省略掉 web.xml，怎么省略呢？</p><p>在 Servlet3.0 提供的规范文档中可以找到2种方式。</p><h4 id="注解方式">3.1 注解方式</h4><p><span class="citation" data-cites="WebServlet">@WebServlet</span><span class="citation" data-cites="WebFilter">@WebFilter</span> <spanclass="citation" data-cites="WebListener">@WebListener</span></p><p>但是这种方式不利于扩展， 并且如果编写在 jar 包中 tomcat是无法感知到的。</p><h4 id="spi方式">3.2 SPI方式</h4><p>在 Serlvet3-1的规范手册中：就提供了一种更加易于扩展可用于共享库可插拔的一种方式，参见8.2.4。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221108210913.png" /></p><p>也就是在应用 META-INF/services 路径下放一个javax.servlet.ServletContainerInitailizer</p><p>通过 ServletContext 就可以动态注册三大组件。 以 Servlet注册为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugServletContainerInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContainerInitializer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br><br>        <span class="hljs-comment">// 通过servletContext动态添加Servlet</span><br>        servletContext.addServlet(<span class="hljs-string">&quot;spiServlet&quot;</span>, <span class="hljs-keyword">new</span> HttpServlet() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>                resp.getWriter().write(<span class="hljs-string">&quot;spiServlet--doGet&quot;</span>);<br>            &#125;<br>        &#125;).addMapping(<span class="hljs-string">&quot;/spiServlet.do&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221108213454.png" /></p><h3 id="实现基于-spi-规范的-springmvc">4. 实现基于 SPI 规范的SpringMVC</h3><h4 id="启动类">4.1 启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugStarterInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * IOC 父容器的启动类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Class[]&#123;RootConfig.class&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ICO 子容器配置  web容器配置</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Class[]&#123;WebAppConfig.class&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 前端控制器拦截路径</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> String[] getServletMappings() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;/&quot;</span>&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="父容器配置类">4.2 父容器配置类</h4><p>扫描的包排除掉 <span class="citation"data-cites="Controller">@Controller</span> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.debuggingWorld&quot;,excludeFilters = &#123;</span><br><span class="hljs-meta">        @ComponentScan.Filter(type = FilterType.ANNOTATION,value = Controller.class),</span><br><span class="hljs-meta">        @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE,value = WebAppConfig.class)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RootConfig</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="子容器配置类">4.3 子容器配置类</h4><p>扫描包含 <span class="citation"data-cites="Controller">@Controller</span> 的 Bean。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(value = &quot;com.debuggingWorld&quot;, includeFilters = &#123;</span><br><span class="hljs-meta">        @ComponentScan.Filter(type = FilterType.ANNOTATION, value = &#123;RestController.class, Controller.class&#125;)</span><br><span class="hljs-meta">&#125;, useDefaultFilters = false)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等价于 &lt;mvc:annotation-driven/&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@EnableWebMvc</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebAppConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 配置拦截器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DebugInterceptor <span class="hljs-title">debugInterceptor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DebugInterceptor();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 文件上传下载的组件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MultipartResolver <span class="hljs-title">multipartResolver</span><span class="hljs-params">()</span> </span>&#123;<br>        CommonsMultipartResolver multipartResolver = <span class="hljs-keyword">new</span> CommonsMultipartResolver();<br>        multipartResolver.setDefaultEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        multipartResolver.setMaxUploadSize(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">return</span> multipartResolver;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册处理国际化资源的组件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AcceptHeaderLocaleResolver <span class="hljs-title">localeResolver</span><span class="hljs-params">()</span> </span>&#123;<br>        AcceptHeaderLocaleResolver acceptHeaderLocaleResolver = <span class="hljs-keyword">new</span> AcceptHeaderLocaleResolver();<br>        <span class="hljs-keyword">return</span> acceptHeaderLocaleResolver;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        registry.addInterceptor(debugInterceptor()).addPathPatterns(<span class="hljs-string">&quot;/*&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 配置视图解析器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> InternalResourceViewResolver <span class="hljs-title">internalResourceViewResolver</span><span class="hljs-params">()</span> </span>&#123;<br>        InternalResourceViewResolver viewResolver = <span class="hljs-keyword">new</span> InternalResourceViewResolver();<br>        viewResolver.setSuffix(<span class="hljs-string">&quot;.jsp&quot;</span>);<br>        viewResolver.setPrefix(<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>);<br>        <span class="hljs-keyword">return</span> viewResolver;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureMessageConverters</span><span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;<br>        converters.add(<span class="hljs-keyword">new</span> MappingJackson2HttpMessageConverter());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="spi-方式-springmvc-启动原理">5. SPI 方式 SpringMVC 启动原理</h3><h4 id="加载-servletcontainerinitializer-实现类">5.1 加载ServletContainerInitializer 实现类</h4><p>外置 Tomcat 启动的时候通过 SPI 找到我们应用中的/META-INF/service/javax.servlet.ServletContainerInitializer</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221108213905.png" /></p><p>1、调用 SpringServletContainerInitializer.onStartUp()</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221113202229.png" /></p><p>调用 onStartUp() 前会先通过 <span class="citation"data-cites="HandlesTypes">@HandlesTypes</span> 找到所有实现了WebApplicationInitializer 接口的类，传入到 OnStartup 的webAppInitializerClasses 参数中，并传入Servlet上下文对象。</p><p>启动类继承关系（组成了父子容器）：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/DebugStarterInitializer继承关系123werwre.png" /></p><p>2、找到所有 WebApplicationInitializer 接口的实现类后，不是接口、不是抽象类则通过反射进行实例化。</p><blockquote><p>所以，会发现内部实现类都是抽象的，想让其起作用必须添加一个自定义实现类。</p></blockquote><p>3、 调用上一步实例化对象的 onStartup() 方法</p><p>在这一步完成 父子容器的创建以及ContextLoaderListener、DispatcherServlet 的注册。</p><p>过程详见思维导图。</p><h4 id="初始化-contextloaderlistener">5.2 初始化ContextLoaderListener</h4><ul><li>外置 tomcat 会帮我们调用 ContextLoaderListener#contextInitialized进行初始化。</li><li>xml 的方式下判断容器为空时创建父容器。</li><li>在里面会调用父容器的 <strong>refresh()</strong> 方法</li><li>将父容器存入到 Servlet 域中供子容器使用</li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/初始化ContextLoaderListener.png" /></p><h4 id="初始化-dispatcherservlet">5.3 初始化 DispatcherServlet</h4><p>外置 tomcat 会帮我们调用 DispatcherServlet#init()   进行初始化</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221114212011.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221114220618.png" /></p><p>----&gt;FrameworkServlet.this.onApplicationEvent(event);--------&gt;onRefresh(event.getApplicationContext());--------------&gt;initStrategies(context);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initStrategies</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;<br><span class="hljs-comment">//初始化我们web上下文对象的 用于文件上传下载的解析器对象</span><br>initMultipartResolver(context);<br><span class="hljs-comment">//初始化我们web上下文对象用于处理国际化资源的</span><br>initLocaleResolver(context);<br><span class="hljs-comment">//主题解析器对象初始化</span><br>initThemeResolver(context);<br><span class="hljs-comment">//初始化我们的HandlerMapping</span><br>initHandlerMappings(context);<br><span class="hljs-comment">//实例化我们的HandlerAdapters</span><br>initHandlerAdapters(context);<br><span class="hljs-comment">//实例化我们处理器异常解析器对象</span><br>initHandlerExceptionResolvers(context);<br>initRequestToViewNameTranslator(context);<br><span class="hljs-comment">//给DispatcherServlet的ViewResolvers处理器</span><br>initViewResolvers(context);<br>initFlashMapManager(context);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面的每一个方法不用太细看， 就是给 SpringMVC 准备初始化的数据，为后续 SpringMVC 处理请求做准备</p><p>基本都是从容器中拿到已经配置的Bean（RequestMappingHandlerMapping、RequestMappingHandlerAdapter、HandlerExceptionResolver）放到 dispatcherServlet 中做准备。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221114221050.png" /></p><p>但是这些 Bean 又是从哪来的呢？？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(value = &quot;com.debuggingWorld&quot;, includeFilters = &#123;</span><br><span class="hljs-meta">        @ComponentScan.Filter(type = FilterType.ANNOTATION, value = &#123;RestController.class, Controller.class&#125;)</span><br><span class="hljs-meta">&#125;, useDefaultFilters = false)</span><br><span class="hljs-meta">@EnableWebMvc</span>  <span class="hljs-comment">// 等价于 &lt;mvc:annotation-driven/&gt;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebAppConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br>……<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在子容器配置类中使用了 <span class="citation"data-cites="EnableWebMvc">@EnableWebMvc</span> 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Import(DelegatingWebMvcConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableWebMvc &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>导入了 DelegatingWebMvcConfiguration。 DelegatingWebMvcConfiguration的父类配置了这些 Bean。 SpringBoot 也是用的这种方式，</p><p>https://www.processon.com/view/link/610e6a167d9c082be334ec49</p>]]></content>
    
    
    <categories>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMVC</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC——请求过程源码解析</title>
    <link href="/2022/11/03/SpringMVC%E2%80%94%E2%80%94%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/11/03/SpringMVC%E2%80%94%E2%80%94%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>https://www.processon.com/view/link/6367b742e401fd612f4d38c6</p><h3 id="从-servlet-到-springmvc">1. 从 Servlet 到 SpringMVC</h3><p>传统Servlet：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221103210258.png" /></p><p>弊端： 1.xml 下配置 servlet 映射非常麻烦，开发效率低。2.必须要继承父类、重写方法，侵入性强。 3.参数解析麻烦4.数据响应麻烦，手动转成 json 并设置 Content-type 5.跳转页面麻烦</p><h3 id="springmvc-的请求流程">2. SpringMVC 的请求流程</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221103212425.png" /></p><ul><li>DispatcherServlet： 前端调度器 ，负责将请求拦截下来分发到各控制器方法</li><li>HandlerMapping: 负责根据请求的 URL 和 <span class="citation"data-cites="RequestMapping">@RequestMapping</span> 映射去匹配，匹配到会返回Handler（具体控制器的方法）</li><li>HandlerAdaper: 负责调用 Handler具体方法，返回视图名字（ModelAndView）</li><li>ViewReslover: 根据 ModelAndView 里面的视图名去找到具体的 jsp 封装在View 对象中</li><li>View：进行视图渲染（将 jsp 转换成 html 内容，这是 Servlet容器的事情了） 最终 response 到的客户端</li></ul><ol type="1"><li>用户发送请求至前端控制器 DispatcherServlet</li><li>DispatcherServlet 收到请求调用处理器映射器 HandlerMapping。<ul><li>处理器映射器根据请求 url 找到具体的处理器，生成处理器执行链HandlerExecutionChain (包括处理器对象和处理器拦截器) 一并返回给DispatcherServlet。</li></ul></li><li>DispatcherServlet 根据处理器 Handler 获取处理器适配器HandlerAdapter，执行 HandlerAdapter处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作</li><li>执行处理器 Handler(Controller，也叫页面控制器)。<ul><li>Handler 执行完成返回 ModelAndView</li><li>HandlerAdapter 将 Handler 执行结果 ModelAndView 返回到DispatcherServlet</li></ul></li><li>DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器<ul><li>ViewReslover 解析后返回具体 View</li></ul></li><li>DispatcherServlet 对 View 进行渲染视图（即将模型数据 model填充至视图中）。</li><li>DispatcherServlet 响应用户。</li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221106171340.png" /></p><h3 id="requestmapping-解析">3. <span class="citation"data-cites="RequestMapping">@RequestMapping</span> 解析</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221106211203.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221106211337.png" /></p><h3 id="requestmapping-映射">4. <span class="citation"data-cites="RequestMapping">@RequestMapping</span> 映射</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221106212732.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221106212841.png" /></p>]]></content>
    
    
    <categories>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMVC</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC——上传下载&amp;拦截器&amp;国际化&amp;异常处理</title>
    <link href="/2022/10/23/SpringMVC%E2%80%94%E2%80%94%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD-%E6%8B%A6%E6%88%AA%E5%99%A8-%E5%9B%BD%E9%99%85%E5%8C%96-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2022/10/23/SpringMVC%E2%80%94%E2%80%94%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD-%E6%8B%A6%E6%88%AA%E5%99%A8-%E5%9B%BD%E9%99%85%E5%8C%96-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="文件下载">1. 文件下载</h3><h4 id="servlet-原生-api-实现下载">1.1 servlet 原生 API 实现下载</h4><p>【注】idea 需先添加 Tomcat 依赖</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221023223136.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/download&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DownloadServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-comment">//获取要下载的文件的绝对路径</span><br>        String realPath = <span class="hljs-keyword">this</span>.getServletContext().getRealPath(<span class="hljs-string">&quot;/file/debuggingWorld.jpg&quot;</span>);<br>        File tmpFile = <span class="hljs-keyword">new</span> File(realPath);<br>        resp.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=&quot;</span> + URLEncoder.encode(tmpFile.getName(), StandardCharsets.UTF_8.name()));<br>        InputStream in = <span class="hljs-keyword">new</span> FileInputStream(realPath);<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        OutputStream out = resp.getOutputStream();<br>        <span class="hljs-keyword">while</span> ((len = in.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;<br>            out.write(buffer, <span class="hljs-number">0</span>, len);<br>        &#125;<br>        in.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="spring-mvc-实现下载">1.2 Spring MVC 实现下载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DownloadController</span> </span>&#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/download&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">download</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String realPath = request.getServletContext().getRealPath(<span class="hljs-string">&quot;/file/debuggingWorld.jpg&quot;</span>);<br>        File tmpFile = <span class="hljs-keyword">new</span> File(realPath);<br>        response.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=&quot;</span> + URLEncoder.encode(tmpFile.getName(), StandardCharsets.UTF_8.name()));<br>        InputStream in = <span class="hljs-keyword">new</span> FileInputStream(realPath);<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        OutputStream out = response.getOutputStream();<br>        <span class="hljs-keyword">while</span> ((len = in.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;<br>            out.write(buffer, <span class="hljs-number">0</span>, len);<br>        &#125;<br>        in.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用-respsonseentity-定制响应内容">1.3 使用 RespsonseEntity定制响应内容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ResponseEntity 可以同时定制文件的响应内容，响应头， 响应状态码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;/responseEntity&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">responseEntity</span><span class="hljs-params">()</span></span>&#123;<br>    String body=<span class="hljs-string">&quot;Hello debuggingWorld&quot;</span>;<br>    HttpHeaders headers=<span class="hljs-keyword">new</span> HttpHeaders();<br>    headers.set(<span class="hljs-string">&quot;Set-Cookie&quot;</span>,<span class="hljs-string">&quot;name=debuggingWorld&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(body,headers, HttpStatus.OK);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="使用-respsonseentity-实现下载">1.4 使用 RespsonseEntity实现下载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于 spring ResponseEntity 的文件下载 不支持缓冲区</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;/download2&quot;)</span><br><span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt; download02(HttpServletRequest request) <span class="hljs-keyword">throws</span> IOException &#123;<br>    String realPath = request.getServletContext().getRealPath(<span class="hljs-string">&quot;/file/debuggingWorld.jpg&quot;</span>);<br>    String fileName = <span class="hljs-keyword">new</span> File(realPath).getName();<br>    HttpHeaders headers = <span class="hljs-keyword">new</span> HttpHeaders();<br>    headers.set(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=&quot;</span> + URLEncoder.encode(fileName, <span class="hljs-string">&quot;UTF-8&quot;</span>));<br>    InputStream in = <span class="hljs-keyword">new</span> FileInputStream(realPath);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[in.available()], headers, HttpStatus.OK);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文件上传">2. 文件上传</h3><p>Spring MVC 为文件上传提供了直接的支持，这种支持是通过即插即用的MultipartResolver 实现的。Spring 用 Jakarta Commons FileUpload技术实现了一个 MultipartResolver 实现类：CommonsMultipartResovler SpringMVC 上下文中默认没有装配MultipartResovler，因此默认情况下不能处理文件的上传工作，如果想使用Spring 的文件上传功能，需现在上下文中配置 MultipartResolver。</p><p>添加依赖： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure> Spring 配置 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxUploadSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;#&#123;1024*1024&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;utf-8&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></p><h4 id="idea-映射虚拟目录">2.1 idea 映射虚拟目录</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221024095201.png" /></p><p>【注】 /debugSpringMVC/img 为图片访问地址</p><h4 id="单文件上传">2.2 单文件上传</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于springmvc MultiPartResolver文件上传</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PostMapping(&quot;/upload01&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload01</span><span class="hljs-params">(MultipartFile file, String desc, Model model)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    String path = <span class="hljs-string">&quot;D:\\temp\\&quot;</span> + file.getOriginalFilename();<br>    file.transferTo(<span class="hljs-keyword">new</span> File(path));<br>    <span class="hljs-comment">// 上传后添加文件名到域中</span><br>    model.addAttribute(<span class="hljs-string">&quot;filename&quot;</span>, file.getOriginalFilename());<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>success.jsp <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br><br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>上传成功！<br>&lt;img src=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/img/$&#123;filename&#125;&quot;</span>&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure></p><h4 id="多文件上传">2.3 多文件上传</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于springmvc MultiPartResolver多文件文件上传</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PostMapping(&quot;/upload02&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload02</span><span class="hljs-params">(String desc, MultipartFile[] file)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">for</span> (MultipartFile multipartFile : file) &#123;<br>        String path = <span class="hljs-string">&quot;D:\\temp\\&quot;</span> + multipartFile.getOriginalFilename();<br>        multipartFile.transferTo(<span class="hljs-keyword">new</span> File(path));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="拦截器">3. 拦截器</h3><p>SpringMVC提供了拦截器机制，允许运行目标方法之前进行一些拦截工作或者目标方法运行之后进行一下其他相关的处理。自定义的拦截器必须实现HandlerInterceptor 接口。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221024212922.png" /></p><ul><li>preHandle：预处理回调方法，实现处理器的预处理（如登录检查），第三个参数为响应的处理器返回值：true表示继续流程（如调用下一个拦截器或处理器）；false表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过response 来产生响应；</li><li>postHandle：后处理回调方法，实现处理器的后处理（在渲染视图之前），此时可以通过 modelAndView对模型数据进行处理或对视图进行处理，modelAndView 也可能为null。如果处理器报错则不执行此方法。</li><li>afterCompletion：整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清理，类似于 try-catch-finally 中的 finally，但仅调用处理器执行链中preHandle 返回 true 的拦截器才会执行</li></ul><p>自定义拦截器： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.getClass().getName()+<span class="hljs-string">&quot;‐‐‐‐‐‐‐ &gt;preHandle&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.getClass().getName()+<span class="hljs-string">&quot;‐‐‐‐‐‐‐ &gt;postHandle&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.getClass().getName()+<span class="hljs-string">&quot;‐‐‐‐‐‐‐&gt;afterCompletion&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>在 spring 配置中配置拦截器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/user/**&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:exclude-mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/xxx&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.debuggingWorld.interceptor.DebugInterceptor&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><p>拦截器的执行顺序如下： preHandle方法 ===》执行目标方法===》执行拦截器的 postHandle 方法 ===》 执行页面跳转 ===》 执行拦截器的afterCompletion 方法</p><p>在配置拦截器的时候有两个需要注意的点： 1. 如果 prehandle 方法返回值为false，那么意味着不放行，那么后续的所有操作都中断 2.如果执行到方法中出现异常，那么后续流程不会处理但是 afterCompletion方法会执行</p><h3 id="过滤器">4. 过滤器</h3><p>实现过滤器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;过滤器 DebugFilter 初始化&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;过滤器 DebugFilter 执行前&quot;</span>);<br>        filterChain.doFilter(servletRequest, servletResponse);<br>        System.out.println(<span class="hljs-string">&quot;过滤器 DebugFilter 执行后&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;过滤器 DebugFilter 销毁&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 web.xml 中配置过滤器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>debugFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.debuggingWorld.Filter.DebugFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>debugFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--‐/*和/都是拦截所有请求，/会拦截的请求不包含*.jsp,而/*的范围更大，还会拦截*.jsp这些请求--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="拦截器和过滤器的区别">5. 拦截器和过滤器的区别</h3><ul><li>过滤器是基于函数回调的，而拦截器是基于j ava 反射的</li><li>过滤器依赖于 servlet 容器，而拦截器不依赖与 Servlet 容器，拦截器依赖SpringMVC</li><li>过滤器几乎对所有的请求都可以起作用（jsp等），而拦截器只能对SpringMVC 请求起作用</li><li>拦截器可以访问处理方法的上下文，而过滤器不可以</li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221024224851.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221024225052.png" /></p><p>https://blog.csdn.net/JokerLJG/article/details/121538821</p><h3 id="国际化">5. 国际化</h3><h4 id="基本用法">5.1 基本用法</h4><p>1、 添加国际化文件</p><p>在 resources 目录下添加国际化文件</p><p><strong>i18n_en_US.properties：</strong> <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">login.username</span>=Username<br><span class="hljs-attr">login.password</span>=Password<br></code></pre></td></tr></table></figure><strong>i18n_zh_CN.properties:</strong> <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">login.username</span>=用户名<br><span class="hljs-attr">login.password</span>=用户密码<br></code></pre></td></tr></table></figure></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221025224902.png" /></p><p>2、 在 Spring 容器中提供一个 ResourceBundleMessageSource 实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;</span> id=<span class="hljs-string">&quot;messageSource&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;basename&quot;</span> value=<span class="hljs-string">&quot;i18n&quot;</span>/&gt;<br>    &lt;property name=<span class="hljs-string">&quot;defaultEncoding&quot;</span> value=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>3、 jsp 中使用国际化</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ taglib prefix=<span class="hljs-string">&quot;spring&quot;</span> uri=<span class="hljs-string">&quot;http://www.springframework.org/tags&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;<br>&lt;body&gt;<br>&lt;spring:message code=<span class="hljs-string">&quot;login.username&quot;</span>/&gt; &lt;input type=<span class="hljs-string">&quot;text&quot;</span>&gt;<br>&lt;br&gt;<br>&lt;spring:message code=<span class="hljs-string">&quot;login.password&quot;</span>/&gt; &lt;input type=<span class="hljs-string">&quot;text&quot;</span>&gt;<br>&lt;br&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>通过 spring:message 标签来引用变量</p><p>4、 后端使用国际化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    MessageSource messageSource;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/login&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">()</span> </span>&#123;<br>        String username = messageSource.getMessage(<span class="hljs-string">&quot;login.username&quot;</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());<br>        String password = messageSource.getMessage(<span class="hljs-string">&quot;login.password&quot;</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());<br>        System.out.println(<span class="hljs-string">&quot;username = &quot;</span> + username);<br>        System.out.println(<span class="hljs-string">&quot;password = &quot;</span> + password);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【注意】注入 MessageSource 对象</p><h4 id="acceptheaderlocaleresolver">5.2 AcceptHeaderLocaleResolver</h4><ul><li>默认情况下，SpringMVC 根据 Accept-Language参数判断客户端的本地化类型。</li><li>当收到请求时，SpringMVC 会在上下文中查找-一个本地化解析器(LocalResolver) ，找到后使用它获取请求所对应的本地化类型信息：Localelocale = request.getLocale()</li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221025230651.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221025230801.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initLocaleResolver</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">this</span>.localeResolver = context.getBean(LOCALE_RESOLVER_BEAN_NAME, LocaleResolver.class);<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br><span class="hljs-comment">// We need to use the default.</span><br><span class="hljs-keyword">this</span>.localeResolver = getDefaultStrategy(context, LocaleResolver.class);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221025233443.png" /></p><p><strong>测试：</strong></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221025233337.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221025233417.png" /></p><p>有的时候希望语言环境直接通过请求参数来传递，而不是通过请求头来传递，可以通过SessionLocaleResolver 或 CookieLocaleResolver l来实现。</p><h4 id="sessionlocaleresolver">5.3 SessionLocaleResolver</h4><p>SessionLocaleResolver 负责区域解析。 拦截器 LocaleChangeInterceptor则主要是负责参数解析的，我们在配置拦截器的时候，设置了参数名为locale（默认即此），也就是说我们将来可以通过 locale参数来传递当前的环境信息。</p><p>在 Spring 配置文件中提供 SessionLocaleResolver的实例，同时配置一个拦截器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;paramName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;locale&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.i18n.SessionLocaleResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;localeResolver&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221025235215.png" /></p><p>此时可以直接通过 locale 参数来控制当前的语言环境，这个 locale参数就是在前面所配置的 LocaleChangeInterceptor拦截器中被自动解析的。</p><p>如果不想配置 LocaleChangeInterceptor 拦截器也是可以的，直接手动解析locale 参数然后设置 locale，像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    MessageSource messageSource;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/login&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String locale, HttpSession session)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;zh-CN&quot;</span>.equals(locale)) &#123;<br>            session.setAttribute(SessionLocaleResolver.LOCALE_SESSION_ATTRIBUTE_NAME, <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">&quot;zh&quot;</span>, <span class="hljs-string">&quot;CN&quot;</span>));<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;en-US&quot;</span>.equals(locale)) &#123;<br>            session.setAttribute(SessionLocaleResolver.LOCALE_SESSION_ATTRIBUTE_NAME, <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">&quot;en&quot;</span>, <span class="hljs-string">&quot;US&quot;</span>));<br>        &#125;<br>        String username = messageSource.getMessage(<span class="hljs-string">&quot;login.username&quot;</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());<br>        String password = messageSource.getMessage(<span class="hljs-string">&quot;login.password&quot;</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());<br>        System.out.println(<span class="hljs-string">&quot;username = &quot;</span> + username);<br>        System.out.println(<span class="hljs-string">&quot;password = &quot;</span> + password);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="cookielocaleresolver">5.4 CookieLocaleResolver</h4><p>SessionLocaleResolver 所实现的功能也可以通过 CookieLocaleResolver来实现，不同的是前者将解析出来的区域信息保存在 session中，而后者则保存在 Cookie 中。保存在 session 中，只要 session没有发生变化，后续就不用再次传递区域语言参数了，保存在 Cookie 中，只要Cookie 没变，后续也不用再次传递区域语言参数了。</p><p>使用 CookieLocaleResolver 的方式很简单，直接在 Spring 中提供CookieLocaleResolver 的实例即可，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;localeResolver&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>注意这里也需要使用到 LocaleChangeInterceptor拦截器，如果不使用该拦截器，则需要自己手动解析并配置语言环境，手动解析并配置的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    MessageSource messageSource;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/login&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String locale, HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;<br>        CookieLocaleResolver resolver = <span class="hljs-keyword">new</span> CookieLocaleResolver();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;zh-CN&quot;</span>.equals(locale)) &#123;<br>            resolver.setLocale(req, resp, <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">&quot;zh&quot;</span>, <span class="hljs-string">&quot;CN&quot;</span>));<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;en-US&quot;</span>.equals(locale)) &#123;<br>            resolver.setLocale(req, resp, <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">&quot;en&quot;</span>, <span class="hljs-string">&quot;US&quot;</span>));<br>        &#125;<br>        String username = messageSource.getMessage(<span class="hljs-string">&quot;login.username&quot;</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());<br>        String password = messageSource.getMessage(<span class="hljs-string">&quot;login.password&quot;</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());<br>        System.out.println(<span class="hljs-string">&quot;username = &quot;</span> + username);<br>        System.out.println(<span class="hljs-string">&quot;password = &quot;</span> + password);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="异常处理">6. 异常处理</h3><h4 id="内置异常处理解析器">6.1 内置异常处理解析器</h4><p>在 SpringMVC 中拥有一套非常强大的异常处理机制，SpringMVC 通过HandlerExceptionResolver处理程序的异常，包括请求映射，数据绑定以及目标方法的执行时发生的异常。</p><p>在容器启动好，进入 DispatcherServlet 之后，会对HandlerExceptionResolver 进行初始化操作：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221031225911.png" /></p><p>默认从 DispatcherServlet.properties 中找到对应的异常处理类：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span>.HandlerExceptionResolver=org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.mvc</span><span class="hljs-selector-class">.method</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.ExceptionHandlerExceptionResolver</span>,\<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.mvc</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.ResponseStatusExceptionResolver</span>,\<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.mvc</span><span class="hljs-selector-class">.support</span>.DefaultHandlerExceptionResolver<br></code></pre></td></tr></table></figure><p>AbstractHandlerMethodExceptionResolver 是ExceptionHandlerExcpetionResolver父 类。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221031230641.png" /></p><p><strong>SimpleMappingExceptionResolver</strong>：通过配置的异常类和view的对应关系解析异常https://blog.csdn.net/bingguang1993/article/details/104491542/</p><p>通过 <span class="citation"data-cites="ExceptionHandler">@ExceptionHandler</span> 处理异常 如果<span class="citation"data-cites="ExceptionHandler">@ExceptionHandler</span> 写在 <spanclass="citation" data-cites="Controller">@Controller</span>中只能处理当前控制器类的处理方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleException</span><span class="hljs-params">(Exception ex)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;@Controller异常处理&quot;</span>);<br>    ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView();<br>    modelAndView.setViewName(<span class="hljs-string">&quot;error&quot;</span>);<br>    modelAndView.addObject(<span class="hljs-string">&quot;ex&quot;</span>, ex);<br>    StringWriter sw = <span class="hljs-keyword">new</span> StringWriter();<br>    PrintWriter pw = <span class="hljs-keyword">new</span> PrintWriter(sw);<br>    ex.printStackTrace(pw);<br>    <span class="hljs-comment">// 日志记录</span><br>    System.out.println(sw.toString());<br>    <span class="hljs-keyword">return</span> modelAndView;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="统一异常处理">6.2 统一异常处理</h4><p><span class="citation"data-cites="ControllerAdvice">@ControllerAdvice</span> 是 Spring3.2提供的新注解，它是对 Controller 的增强,可对 controller 中被 <spanclass="citation" data-cites="RequestMapping">@RequestMapping</span>注解的方法加一些逻辑处理：</p><ol type="1"><li>全局异常处理</li><li>全局数据绑定</li><li>全局数据预处理</li></ol><p><span class="citation"data-cites="ExceptionHandler">@ExceptionHandler</span> 加在 Controller中，只处理当前控制器的异常，优先级比全局高。加在 ControllerAdvice 中，处理全局异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneralExceptionHandler</span> </span>&#123;<br><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleException</span><span class="hljs-params">(HttpServletRequest request,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        HttpServletResponse reponse, Exception ex,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        HandlerMethod handle)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;全局异常处理&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (request.getHeader(<span class="hljs-string">&quot;Accept&quot;</span>).contains(<span class="hljs-string">&quot;application/json&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 集成jackson的方式：</span><br>            <span class="hljs-comment">//ModelAndView 同时支持视图返回和json返回</span><br>            <span class="hljs-comment">// 这种方式就是返回json</span><br>            ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-keyword">new</span> MappingJackson2JsonView());<br>            <span class="hljs-comment">// 通常会根据不同的异常返回不同的编码</span><br>            modelAndView.addObject(<span class="hljs-string">&quot;code&quot;</span>, HttpStatus.INTERNAL_SERVER_ERROR.value());<br>            modelAndView.addObject(<span class="hljs-string">&quot;message&quot;</span>, ex.getMessage());<br>            <span class="hljs-keyword">return</span> modelAndView;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView();<br>            modelAndView.setViewName(<span class="hljs-string">&quot;error&quot;</span>);<br>            modelAndView.addObject(<span class="hljs-string">&quot;ex&quot;</span>, ex);<br>            StringWriter sw = <span class="hljs-keyword">new</span> StringWriter();<br>            PrintWriter pw = <span class="hljs-keyword">new</span> PrintWriter(sw);<br>            ex.printStackTrace(pw);<br>            System.out.println(sw.toString());   <span class="hljs-comment">// 日志记录</span><br>            <span class="hljs-keyword">return</span> modelAndView;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC——JSON处理&amp;数据格式化&amp;数据验证</title>
    <link href="/2022/10/06/SpringMVC%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96-%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81/"/>
    <url>/2022/10/06/SpringMVC%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96-%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h3 id="json-处理">1. JSON 处理</h3><p>pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>spring 配置</strong>： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure>https://www.jianshu.com/p/fc3bc70b9ed3https://blog.csdn.net/u011066470/article/details/112438252</p><p>【注】idea 开发 Spring MVC，需要手动将依赖添加到 lib 下。</p><h4 id="返回-json-数据">1.1 返回 JSON 数据</h4><h5 id="responsebody"><span class="citation"data-cites="ResponseBody">@ResponseBody</span></h5><p>使用 <span class="citation"data-cites="ResponseBody">@ResponseBody</span> 不跳转视图，返回 json字符串作为响应结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/debug&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;xxxxx&quot;</span>);<br>    <span class="hljs-keyword">return</span> user.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="restcontroller"><span class="citation"data-cites="RestController">@RestController</span></h5><p>将当前 controller 的所有接口定义为返回 json。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/debug&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;xxxxx&quot;</span>);<br>        <span class="hljs-keyword">return</span> user.toString();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取-json-数据">1.2 获取 JSON 数据</h4><p><span class="citation" data-cites="RequestBody">@RequestBody</span>用来接收前端传递给后端的 json 字符串中的数据(请求体中的数据)。</p><ol type="1"><li>以简单对象接收前端传过来的 json 数据</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/debug&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> user.toString();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221019085110.png" /></p><ol start="2" type="1"><li>用字符串接收 json 对象 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/debug&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String user)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221019231042.png" /></p><p>https://www.cnblogs.com/zzsuje/articles/10329948.html</p><h5 id="jsonproperty-jsonalias"><span class="citation"data-cites="JsonProperty">@JsonProperty</span> &amp; <spanclass="citation" data-cites="JsonAlias">@JsonAlias</span></h5><p><span class="citation" data-cites="JsonAlias">@JsonAlias</span>注解，为指定的属性添加别名。 <span class="citation"data-cites="JsonProperty">@JsonProperty</span>注解，为指定的属性修改名称。 <span class="citation"data-cites="JsonAlias">@JsonAlias</span> 注解需要依赖于setter、getter，而 <span class="citation"data-cites="JsonProperty">@JsonProperty</span> 注解不需要。</p><h3 id="数据格式化">2. 数据格式化</h3><h4 id="datetimeformat">2.1 <span class="citation"data-cites="DateTimeFormat">@DateTimeFormat</span></h4><p><span class="citation"data-cites="DateTimeFormat">@DateTimeFormat</span> 可以用来格式化java.util.Date、java.util.Calendar 和 java.util.Long 类型</p><p>DateTimeFormat 互斥属性： + iso。类型为 DateTimeFormat.ISO +DateTimeFormat.ISO.DATE: 格式 yyyy-MM-dd。 +DateTimeFormat.ISO.DATE_TIME: 格式 yyyy-MM- dd HH:mm:ss .SSSZ。 +DateTimeFormat.ISO.TIME: 格式 HH:mm:ss .SSSZ。 +DateTimeFormat.ISO.NONE: 表示不使用 ISO 格式的时间。 + pattern。类型为String，使用自定义的时间格式化字符串。 + style。类型为String，通过样式指定日期时间的格式，由两位字符组成，第 1位表示日期的样式，第 2 位表示时间的格式： + S: 短日期/时间的样式 + M:中日期/时间的样式 + L: 长日期/时间的样式 + F: 完整日期/时间的样式 + -:忽略日期/时间的样式</p><p>https://blog.csdn.net/imVainiycos/article/details/102712056</p><p>只有在 表单请求（application/x-www-form-urlencoded）中其作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Integer id;<br>    <span class="hljs-keyword">public</span> String userName;<br>    <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy/MM/dd&quot;)</span><br>    <span class="hljs-keyword">private</span> Calendar birthday;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221020200612.png" /></p><h4 id="numberformat">2.2 <span class="citation"data-cites="NumberFormat">@NumberFormat</span></h4><p><span class="citation" data-cites="NumberFormat">@NumberFormat</span>可以用来格式化任何数字的基本类型（如int，long）或java.lang.Number的实例（如 BigDecimal, Integer)。</p><p>NumberFormat 互斥属性：</p><ul><li>pattern：类型 String，使用自定义的数字格式化串，如 ##,### 表示50,000</li><li>style：类型 NumberFormat.Style，几个常用值<ul><li>Style.CURRENCY：货币类型</li><li>Style.NUMBER：正常数字类型</li><li>Style.PERCENT：百分比类型</li></ul></li></ul><p>https://blog.csdn.net/weixin_38192427/article/details/122270716</p><h3 id="数据校验">3. 数据校验</h3><p>https://blog.csdn.net/weixin_44335140/article/details/111152171</p><p>JSR303 是 Java 为 Bean 数据合法性校验提供的标准，它已经包含在 JavaEE6.0 中 。JSR 303 （Java Specification Requests 意思是Java 规范提案)通过在 Bean 属性上标注类似于 <span class="citation"data-cites="NotNull">@NotNull</span>、<span class="citation"data-cites="Max">@Max</span>等标准的注解指定校验规则，并通过标准的验证接口对 Bean 进行验证。Hibernate Validator 实现了JSR349 验证注解规范的技术。</p><p>JSR303:：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221019213246.png" /></p><p>Hibernate Validator 扩展注解:</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221019213510.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221020201058.png" /></p><p>添加依赖： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate.validator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-validator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.16.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Integer id;<br>    <span class="hljs-meta">@NotEmpty(message = &quot;用户名不能为空&quot;)</span><br>    <span class="hljs-keyword">public</span> String userName;<br>    <span class="hljs-meta">@Past</span><br>    <span class="hljs-keyword">private</span> Calendar birthday;<br>    <span class="hljs-meta">@Range(min = 1000, max = 100000)</span><br>    <span class="hljs-keyword">private</span> Integer salary;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/debug&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> <span class="hljs-meta">@RequestBody</span> User user, BindingResult result)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (result.hasErrors()) &#123;<br>        <span class="hljs-keyword">return</span> result.getFieldErrors().toString();<br>    &#125;<br>    <span class="hljs-keyword">return</span> user.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p><span class="citation"data-cites="RestControllerAdvice">@RestControllerAdvice</span> <ahref="https://blog.csdn.net/qq_36829919/article/details/101210250"><spanclass="citation" data-cites="ControllerAdvice">@ControllerAdvice</span>的介绍及三种用法</a></p>]]></content>
    
    
    <categories>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC——使用&amp;请求处理&amp;响应处理</title>
    <link href="/2022/09/14/SpringMVC%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8&amp;%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86&amp;%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86/"/>
    <url>/2022/09/14/SpringMVC%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8&amp;%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86&amp;%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="springmvc-执行流程">1. SpringMVC 执行流程</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/SpringMVC执行流程jhjzhcuuidhai.png" /></p><ol type="1"><li>DispatcherServlet：前端控制器，是整个 SpringMVC的控制中心。DispatcherServlet 接收用户发出的请求并拦截。</li><li>HandlerMapping：处理器映射。DispatcherServlet 调用HandlerMapping，HandlerMapping 根据请求 url 查找 Handler。</li><li>返回处理器执行链，根据 url 查找控制器，并且将解析后的信息传递给DispatcherServlet</li><li>HandlerAdapter：处理器适配器，其按照特定的规则去执行 handler找到的具体处理器</li><li>Controller 将具体的执行信息返回给 HandlerAdapter，如ModelAndView。</li><li>HandlerAdapter 将视图逻辑名或模型传递给 DispatcherServlet。</li><li>DispatcherServlet 调用视图解析器（ViewResolver）来解析HandlerAdapter 传递的逻辑视图名。</li><li>视图解析器将解析的逻辑视图名传给 DispatcherServlet。</li><li>DispatcherServlet根据视图解析器解析的视图结果，调用具体的视图，进行试图渲染</li><li>将响应数据返回给客户端</li></ol><h3 id="基于注解的-springmvc">2. 基于注解的 SpringMVC</h3><h4 id="添加-pom-依赖">2.1 添加 pom 依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220914224113.png" /></p><h4 id="web.xml-文件">2.2 web.xml 文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--‐配置 DispatcherServlet--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>debugSpringMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--关联 springmvc 的配置文件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--容器启动时加载 servlet--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--‐匹配servlet的请求，/标识匹配所有请求--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>debugSpringMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--‐/*和/都是拦截所有请求，/会拦截的请求不包含*.jsp,而/*的范围更大，还会拦截*.jsp这些请求--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="spring-配置文件">2.3 spring 配置文件</h4><p>springMVC.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.debuggingWorld&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="controller">2.4 Controller</h4><p>HelloController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【注】idea 创建 web 项目需要手动将依赖加入 WEB-INF/lib</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220914225230.png" /></p><h3 id="请求参数处理">3. 请求参数处理</h3><h4 id="springmvc-对请求参数的处理">3.1 SpringMVC 对请求参数的处理</h4><ul><li><span class="citation"data-cites="RequestParam">@RequestParam</span>：获取请求的参数</li><li><span class="citation"data-cites="RequestHeader">@RequestHeader</span>：获取请求头信息</li><li><span class="citation"data-cites="CookieValue">@CookieValue</span>：获取cookie中的值</li></ul><h5 id="requestparam-的基本使用"><span class="citation"data-cites="RequestParam">@RequestParam</span> 的基本使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认情况下，方法参数接收跟请求中参数名一致的参数值</span><br><span class="hljs-comment">     * 如果有值，直接赋值，如果没有，那么直接给空值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/param&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + name;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@RequestParam</span> 使用此注解之后，参数的名称不需要跟请求 的名称一致，但是必须有值</span><br><span class="hljs-comment">     * public String hello11(<span class="hljs-doctag">@RequestParam</span>(&quot;name&quot;) String name)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 此注解还包含三个参数：</span><br><span class="hljs-comment">     * value:表示要获取的参数值</span><br><span class="hljs-comment">     * required：表示此参数是否必须，默认是true，如果不写参数那么会报错， 如果值为false，那么不写参数不会有任何错误</span><br><span class="hljs-comment">     * defaultValue:如果在使用的时候没有传递参数，那么定义默认值即可</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/param1&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello1</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;name&quot;,required = false,defaultValue = &quot;debuggingWorld&quot;)</span> String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="requestheader-的基本使用"><span class="citation"data-cites="RequestHeader">@RequestHeader</span> 的基本使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 相当于 request.getHeader(&quot;Host&quot;)</span><br><span class="hljs-comment"> * 默认 required 为 true，没有值报错</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 注解中也包含三 个参数： value  required   defaultValue</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;/header&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">header</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader(value = &quot;Host&quot;,required = false)</span> String host)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + host;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="cookievalue-的基本使用"><span class="citation"data-cites="CookieValue">@CookieValue</span> 的基本使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 相当于 :</span><br><span class="hljs-comment"> * Cookie[] cookies = request.getCookies();</span><br><span class="hljs-comment"> * for (Cookie cookie : cookies) &#123;</span><br><span class="hljs-comment"> *     System.out.println(cookie.getValue());</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 默认 required 为 true，没有值报错</span><br><span class="hljs-comment"> * 注解中也包含三 个参数： value  required   defaultValue</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;/cookie&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">cookie</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(value = &quot;JSESSIONID&quot;, required = false)</span> String id)</span> </span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + id;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="复杂数据类型处理">复杂数据类型处理</h5><p><strong>application/x-www-form-urlencoded 类型请求</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/addUser&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">user</span><span class="hljs-params">( User user)</span> </span>&#123;<br>    System.out.println(user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello:&quot;</span> + user;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220921234714.png" /></p><h4 id="字符编码过滤器解决乱码">3.2 字符编码过滤器（解决乱码）</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--同时开启请求和响应的编码设置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意：如果配置了多个过滤器，那么字符编码过滤器一定要在最前面，否则失效。</strong></p><h4 id="springmvc-对原生-api-的支持">3.3 SpringMVC 对原生 API的支持</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * SpringMVC 也可以在参数上使用原生的 Servlet API</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * HttpSession</span><br><span class="hljs-comment"> * HttpServletRequest</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * java.security.Principal 安全协议相关</span><br><span class="hljs-comment"> * Locale：国际化相关的区域信息对象</span><br><span class="hljs-comment"> *  InputStream:</span><br><span class="hljs-comment"> *          ServletInputStream inputStream = request.getInputStream();</span><br><span class="hljs-comment"> *  OutputStream:</span><br><span class="hljs-comment"> *          ServletOutputStream outputStream = response.getOutputStream();</span><br><span class="hljs-comment"> *  Reader:</span><br><span class="hljs-comment"> *          BufferedReader reader = request.getReader();</span><br><span class="hljs-comment"> *  Writer:</span><br><span class="hljs-comment"> *          PrintWriter writer = response.getWriter();</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;api&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">api</span><span class="hljs-params">(HttpSession session, HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>    request.setAttribute(<span class="hljs-string">&quot;requestParam&quot;</span>, <span class="hljs-string">&quot;request&quot;</span>);<br>    session.setAttribute(<span class="hljs-string">&quot;sessionParam&quot;</span>, <span class="hljs-string">&quot;session&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="请求映射处理">4. 请求映射处理</h3><h4 id="requestmapping">4.1 <span class="citation"data-cites="RequestMapping">@RequestMapping</span></h4><p><span class="citation"data-cites="RequestMapping">@RequestMapping</span>用来匹配客户端发送的请求，可以在方法上使用， 也可以在类上使用。方法：表示用来匹配要处理的请求类上：表示为当前类的所有方法的请求地址添加一个前置路径，访问的时候必须要添加此路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/debugging&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/world&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><span class="citation"data-cites="RequestMapping">@RequestMapping</span>注解还可以添加很多额外的属性值，用来精确匹配请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * RequestMapping 的其他属性值：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * value:要匹配的请求路径</span><br><span class="hljs-comment"> * method:限制发送请求的方式： POST GET</span><br><span class="hljs-comment"> * params:表示请求要接受的参数,如果定义了这个属性，那么发送的时候必须要添加参数</span><br><span class="hljs-comment"> *    params 有几种匹配规则</span><br><span class="hljs-comment"> *      1. 包含某个参数,不包含则报错  params= &#123;&quot;name&quot;&#125;</span><br><span class="hljs-comment"> *      2. 不包含某个参数,包含则报错  params= &#123;&quot;!name&quot;&#125;</span><br><span class="hljs-comment"> *      3. 请求数据中指定参数名=值   params= &#123;&quot;name=tom&quot;&#125;</span><br><span class="hljs-comment"> *      4. 请求数据中指定参数名!=值  params= &#123;&quot;name!=tom&quot;&#125;</span><br><span class="hljs-comment"> *      5. 组合使用是&quot;且&quot;的关系  params= &#123;&quot;id&quot;,&quot;name!=tom&quot;&#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * headers:填写请求头需要包含或不包含的信息    https://blog.csdn.net/weixin_44137201/article/details/108567673</span><br><span class="hljs-comment"> * consumers:只接受内容类型是哪种的请求，相当于指定 Content‐Type</span><br><span class="hljs-comment"> * produces:返回的内容类型 Content‐Type：text/html;charset=utf‐8</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/world&quot;,params = &#123;&quot;name =aaa&quot;&#125; ,headers = &#123;&quot;Content-Type=application/json&quot;&#125;,</span><br><span class="hljs-meta">        consumes = &#123;&quot;application/json&quot;&#125;,produces = &#123;&quot;application/json&quot;&#125;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + name;<br>&#125;<br></code></pre></td></tr></table></figure><p><span class="citation"data-cites="RequestMapping">@RequestMapping</span>支持通配符的匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RequestMapping</span> 包含三种模糊匹配的方式：</span><br><span class="hljs-comment"> * ?：能替代任意一个字符</span><br><span class="hljs-comment"> * *：能替代任意多个字符和一层路径</span><br><span class="hljs-comment"> * **：能代替多层路径</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;/**/h*llo?&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + name;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="pathvariable">4.2 <span class="citation"data-cites="PathVariable">@PathVariable</span></h4><p><span class="citation" data-cites="PathVariable">@PathVariable</span>注解提供了对占位符 URL 的支持，就是将 URL中占位符参数绑定到控制器处理方法的参数中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer userId, <span class="hljs-meta">@PathVariable(&quot;name&quot;)</span> String userName)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(userId, userName, <span class="hljs-keyword">null</span>).toString();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态资源访问">4.3 静态资源访问</h4><p>Spring 配置中添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--此配置表示我们自己配置的请求由 controller 来处理，不能处理的请求交由 tomcat 来处理</span><br><span class="hljs-comment">    静态资源可以访问，但是动态请求无法访问</span><br><span class="hljs-comment"> --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><span class="hljs-comment">&lt;!--保证静态资源和动态请求都能够访问--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>http://www.yiidian.com/springmvc/static-resource.html</p><h3 id="响应处理">5. 响应处理</h3><h4 id="使用默认内置视图解析器viewresolver">5.1使用默认内置视图解析器（ViewResolver）</h4><p>【注】WEB-INF 下的 jsp 不能直接访问。</p><p>SpringMVC 默认视图解析器：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221003224751.png" /></p><p>添加自定义视图解析器前访问 jsp：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;debug&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/WEB-INF/index.jsp&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加自定义视图解析器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--默认视图解析器，简化逻辑视图名称--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加自定义视图解析器后访问 jsp：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/debug&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如果希望不执行自定义视图解析器,在方法返回值前面添加forward:或 redirect:</strong></p><h4 id="使用视图控制器-view-controller">5.2 使用视图控制器&lt;view-controller&gt;</h4><p>如果有些请求只是想跳转页面，不需要来后台处理什么逻辑，不需要在 Action中写 一个空方法来跳转，直接配置一个视图跳转控制器即可。</p><p>在 Spring 配置文件中添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">&quot;index&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="使用modelmapmodelmap传输数据到页面">5.3使用Model，Map，ModelMap传输数据到页面</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 servlet API 方式传输数据到视图</span><br><span class="hljs-meta">@RequestMapping(&quot;debug1&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello1</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<br>    request.setAttribute(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;servletAPI&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 使用 model 方式传输数据到视图</span><br><span class="hljs-meta">@RequestMapping(&quot;debug2&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">(Model model)</span> </span>&#123;<br>    <span class="hljs-comment">// 底层会将 model 中的数据复制一份到 request 域</span><br>    model.addAttribute(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;model&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 使用 ModelMap 方式传输数据到视图</span><br><span class="hljs-meta">@RequestMapping(&quot;debug3&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello3</span><span class="hljs-params">(ModelMap modelMap)</span> </span>&#123;<br>    modelMap.addAttribute(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;ModelMap&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 使用 Map 方式传输数据到视图</span><br><span class="hljs-meta">@RequestMapping(&quot;debug4&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello4</span><span class="hljs-params">(Map map)</span> </span>&#123;<br>    map.put(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;map&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用三个对象传递参数，会发现所有的参数值都设置到了 request作用域中，那么这三个对象是什么关系呢？</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221004001551.png" /></p><p>实际上三种对象的实际类型都是：<strong>BindingAwareModelMap</strong></p><h4 id="使用-modelandview-对象传输数据到页面">5.4 使用 ModelAndView对象传输数据到页面</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 ModelAndView 方式传输数据到视图</span><br><span class="hljs-meta">@RequestMapping(&quot;debug&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;index&quot;</span>);<br>    <span class="hljs-comment">// modelAndView.setViewName();</span><br>    modelAndView.addObject(<span class="hljs-string">&quot;type&quot;</span>,<span class="hljs-string">&quot;ModelAndView&quot;</span>);<br>    <span class="hljs-keyword">return</span> modelAndView;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ps: springmvc 处理以上几种设置 model 的 request域数据的几种方式以外，springmvc 还会隐式的将请求绑定参数自动设置到request 域</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/update&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">(User user)</span> </span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>jsp 页面：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;br&gt; requestScope:$&#123;requestScope.user&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221005131119.png" /></p><h4 id="使用-session-传输数据到页面">5.5 使用 session传输数据到页面</h4><h5 id="通过-servlet-api-读写-session">通过 servlet api 读写session</h5><ol type="1"><li>通过参数绑定的方式获取 servlet api</li><li>通过自动注入的方式获取 servlet api（推荐使用这种方式）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过参数绑定的方式获取 Servlet API——session</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;/debug01&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(HttpSession session)</span> </span>&#123;<br>    session.setAttribute(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;servletAPI——session&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@Autowired</span><br>HttpSession httpSession;<br><br><span class="hljs-meta">@RequestMapping(&quot;debug02&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    httpSession.setAttribute(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;Autowired——session&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="通过-springmvc-提供的注解读写-session">通过 springmvc提供的注解读写 session</h5><h6 id="sessionattributes">1. <span class="citation"data-cites="SessionAttributes">@SessionAttributes</span></h6><ol type="1"><li>用在类上，将 model 中指定的属性写入 session 。同时也会从 session中写入指定的属性到 model。</li><li>所以使用 <span class="citation"data-cites="SessionAttributes">@SessionAttributes</span> 的情况下 model和 session 是共通的。</li><li>使用该方式设置 session 依赖 model。</li><li>当前控制器下所有的处理方法都会将 model 指定的属性写入 session</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@SessionAttributes(&quot;type&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;debug&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;model&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>index.jsp:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;br&gt; requestScope:$&#123;requestScope.type&#125;<br>&lt;br&gt;<br>&lt;br&gt;sessionScope:$&#123;sessionScope.type&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221004223038.png" /></p><p>https://blog.csdn.net/abc997995674/article/details/80462450</p><p>https://blog.51cto.com/u_3631118/3124605</p><h6 id="sessionattribute">2. <span class="citation"data-cites="SessionAttribute">@SessionAttribute</span></h6><ol type="1"><li>用在请求方法参数上读取 session。</li><li>required 属性用来设置 session 中某个属性必须存在 ，不存在则会报错。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;debug2&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-meta">@SessionAttribute(required = false,value = &quot;type&quot;)</span> String type)</span> </span>&#123;<br>    System.out.println(type);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="modelattribute">3. <span class="citation"data-cites="ModelAttribute">@ModelAttribute</span></h6><h4 id="modelattribute-1">5.6 <span class="citation"data-cites="ModelAttribute">@ModelAttribute</span></h4><h5 id="写在方法上面">1. 写在方法上面</h5><p><span class="citation"data-cites="ModelAttribute">@ModelAttribute</span>的方法会在当前处理器中所有的处理方法之前调用</p><ol type="1"><li>通过 <span class="citation"data-cites="ModelAttribute">@ModelAttribute</span>来给全局变量赋值(不推荐） <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    HttpSession httpSession;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;debug&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;<br>        httpSession.setAttribute(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;ModelAttribute&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过 <span class="hljs-doctag">@ModelAttribute</span> 获取 Servlet API</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ModelAttribute</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello1</span><span class="hljs-params">(HttpSession httpSession)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.httpSession = httpSession;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>当调用执行全字段的更新数据库操作时，假如提供给用户的修改字段只有部分字段，这时候就会造成其他字段更新丢失&gt; 解决： &gt; + 自己定制 update 语句， 只更新指定的那些字段 &gt; +如果无法定制 sql 语句， 可以在更新之前进行查询，怎么在更新之前查询？只能在 springmvc 绑定请求参数之前查询， 利用 <spanclass="citation" data-cites="ModelAttribute">@ModelAttribute</span>就可以在参数绑定之前查询，但是怎么将查询出来的对象和参数的对象进行合并？ springmvc 具有该特性，会将 model中和参数名相同的属性拿出来进行合并，用参数中的属性值进行自动覆盖，没有的字段进行保留。这样就可以解决这个问题。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/update&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">(User user)</span> </span>&#123;<br>    <span class="hljs-comment">// update user set id = ? ,userName = ?,password = ? where id = ?</span><br>    <span class="hljs-keyword">return</span> user.toString();<br>&#125;<br><br><span class="hljs-meta">@ModelAttribute</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initUser</span><span class="hljs-params">(Model model)</span> </span>&#123;<br>    model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221005130607.png" /></p><ol start="3" type="1"><li>将返回值放进 ModelMap 里</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-meta">@ModelAttribute</span> <span class="hljs-function">User <span class="hljs-title">initUser</span><span class="hljs-params">()</span> </span>&#123;<br> <br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>+index, <span class="hljs-string">&quot;admin&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ModelAttribute</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">initUser</span><span class="hljs-params">()</span> </span>&#123;<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>+index, <span class="hljs-string">&quot;admin&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="写在参数上面">2. 写在参数上面</h5><p>可以省略，将请求参数合并到 model 中指定的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/update&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute(&quot;user&quot;)</span> User u)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@ModelAttribute</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initUser</span><span class="hljs-params">(Model model)</span> </span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为 mode l和 sessionAttribute 具有共通的特性，所以如果 session中有对应的属性也会进行合并。可以和 <span class="citation"data-cites="SessionAttributes">@SessionAttributes</span> 结合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@SessionAttributes(types = User.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/update&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute(&quot;user&quot;)</span> User u)</span> </span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@ModelAttribute</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">initUser</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>jsp: <figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;br&gt; requestScope:$&#123;requestScope.user&#125;<br>&lt;br&gt; sessionScope:$&#123;sessionScope.user&#125;<br></code></pre></td></tr></table></figure> 第一次访问：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221005210717.png" /></p><p>第二次访问：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221005210936.png" /></p><p>第三次访问：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221005210917.png" /></p><p>model 和 session 里的值<strong>没有被</strong> <span class="citation"data-cites="ModelAttribute">@ModelAttribute</span> 改变了。 因此对于<span class="citation"data-cites="ModelAttribute">@ModelAttribute</span> 和 <spanclass="citation"data-cites="SessionAttributes">@SessionAttributes</span>共同的使用的时候务必要注意的结论：已经添加进 session 的数据，在没用使用SessionStatus 清除过之前，<span class="citation"data-cites="ModelAttribute">@ModelAttribute</span>标注的非功能方法的返回值并不会被再次更新进 session 内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/update&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute(&quot;user&quot;)</span> User u, SessionStatus sessionStatus)</span> </span>&#123;<br><br>    sessionStatus.setComplete();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当给方法中的参数设置值的时候，如果添加了 <span class="citation"data-cites="ModelAttribute">@ModelAttribute</span>注解，那么在查找值的时候，是遵循以下方式： 1.方法的参数使用参数的类型首字母小写，或者使用 <span class="citation"data-cites="ModelAttribute">@ModelAttribute</span>("") 的值 2.先看之前是否在 model 中设置过该属性值，如果设置过就直接获取 3. 看 <spanclass="citation"data-cites="SessionAttributes">@SessionAttributes</span>注解标注类中的方法是否给 session中赋值，如果有的话，也是直接获取，没有报异常</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@SessionAttributes(types = User.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/session&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">(HttpSession session)</span> </span>&#123;<br>        session.setAttribute(<span class="hljs-string">&quot;u&quot;</span>, <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/update&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute(&quot;u&quot;)</span> User u)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>https://blog.51cto.com/u_3631118/3121661</p><p>https://blog.51cto.com/u_3631118/3121625</p><h4 id="spring-mvc-线程安全问题">5.7 Spring MVC 线程安全问题</h4><p>Spring MVC 的 Controller 默认是单例的。</p><p>以 servlet API 获取为例。</p><ol type="1"><li>通过参数绑定是线程安全的。因为参数绑定变量是方法级别，所以每次请求方法都会创建一个新的私有变量。</li><li>通过自动注入的方式@AutoWired 是线程安全的，spring 底层通过自动注入将servlet api 封装到 ThreadLocal 中。</li><li>.通过@ModelAttribute的方式不是线程安全的，控制器是单例的，并且变量声明在类的级别中（共享变量）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">HttpSession session;<br><span class="hljs-meta">@ModelAttribute</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(HttpSession session)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.session = session;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p>https://blog.csdn.net/weixin_42128429/article/details/119936833</p><h4 id="转发和重定向">5.8 转发和重定向</h4><h5 id="转发">1. 转发</h5><p>由服务器的页面进行跳转，不需要客户端重新发送请求：</p><p>特点如下： 1. 地址栏的请求不会发生变化，显示的还是第一次请求的地址 2.请求的次数，有且仅有一次请求 3. 请求域中的数据不会丢失 4.根目录：localhost:8080/项目地址/，包含了项目的访问地址</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221006000619.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认就是转发，会参与视图解析器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 当使用转发的时候可以添加前缀 forward:index.jsp,此时是不会经过视图解析器的，所以要添加完整的名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/debug&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">forword</span><span class="hljs-params">(HttpSession session)</span> </span>&#123;<br>        session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/WEB-INF/index.jsp&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/debug1&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">forword</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/debug&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="重定向">2. 重定向</h5><p>在浏览器端进行页面的跳转，需要发送两次请求（第一次是人为的，第二次是自动的）</p><p>特点如下： 1. 地址栏的地址发生变化，显示最新发送请求的地址 2.请求次数：2次 3. 请求域中的数据会丢失，因为是不同的请求 4.根目录：localhost:8080/ ，不包含项目的名称</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221006001601.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 重定向</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 必须加上 redirect。不会参与视图解析器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * springMVC 默认会加上项目名，而 servlet 不会</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 相当于 response.sendRedirect(&quot;login.jsp&quot;)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/debug&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">redirect</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/login.jsp&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/debug1&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">redirect1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/debug&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221006004530.png" /></p><h5 id="对比">3. 对比</h5><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221006001756.png" /></p>]]></content>
    
    
    <categories>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——事务源码解析</title>
    <link href="/2022/08/29/Spring%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/08/29/Spring%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>https://www.processon.com/view/link/631f3fa10e3e7420767c11fe</p><h3 id="enabletransactionmanagement工作原理">1. <span class="citation"data-cites="EnableTransactionManagement工作原理">@EnableTransactionManagement工作原理</span></h3><p>开启 Spring 事务本质上就是增加了一个 Advisor，但我们使用 <spanclass="citation"data-cites="EnableTransactionManagement">@EnableTransactionManagement</span>注解来开启 Spring 事务是该注解向 Spring 容器中添加了两个 Bean：</p><ol type="1"><li>AutoProxyRegistrar</li><li>ProxyTransactionManagementConfiguration</li></ol><p>AutoProxyRegistrar 主要的作用是向 Spring 容器中注册了一个<strong>InfrastructureAdvisorAutoProxyCreator</strong> 的 Bean。 而InfrastructureAdvisorAutoProxyCreator 继承了<strong>AbstractAdvisorAutoProxyCreator</strong>，所以这个类的主要作用就是<strong>开启自动代理</strong>的作用，也就是一个BeanPostProcessor，会在初始化后步骤中去寻找 Advisor 类型的Bean，并判断当前 Bean 是否有匹配的Advisor，是否需要利用动态代理产生一个代理对象。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220905220453.png" /></p><p>ProxyTransactionManagementConfiguration是一个配置类，它又定义了另外三个 bean：</p><ol type="1"><li>BeanFactoryTransactionAttributeSourceAdvisor：一个 Advisor</li><li>AnnotationTransactionAttributeSource：相当于BeanFactoryTransactionAttributeSourceAdvisor 中的 Pointcut</li><li>TransactionInterceptor：相当于BeanFactoryTransactionAttributeSourceAdvisor 中的 Advice</li></ol><p><strong>AnnotationTransactionAttributeSource</strong>就是用来判断某个类上是否存在 <span class="citation"data-cites="Transactional">@Transactional</span>注解，或者判断某个方法上是否存在 <span class="citation"data-cites="Transactional">@Transactional</span> 注解的。</p><p><strong>TransactionInterceptor</strong> 就是代理逻辑，当某个类中存在<span class="citation" data-cites="Transactional">@Transactional</span>注解时，到时就产生一个代理对象作为Bean，代理对象在执行某个方法时，最终就会进入到 TransactionInterceptor 的invoke() 方法。</p><h3 id="spring事务基本执行原理">2. Spring事务基本执行原理</h3><p>一个 Bean 在执行 Bean 的创建生命周期时，会经过InfrastructureAdvisorAutoProxyCreator 的初始化后的方法，会判断当前当前Bean 对象是否和 BeanFactoryTransactionAttributeSourceAdvisor匹配，匹配逻辑为判断该 Bean 的类上是否存在 <span class="citation"data-cites="Transactional">@Transactional</span>注解，或者类中的某个方法上是否存在 <span class="citation"data-cites="Transactional">@Transactional</span> 注解，如果存在则表示该Bean 需要进行动态代理产生一个代理对象作为 Bean 对象。</p><p>该代理对象在执行某个方法时，会再次判断当前执行的方法是否和BeanFactoryTransactionAttributeSourceAdvisor 匹配，如果匹配则执行该Advisor 中的 TransactionInterceptor 的 invoke()方法，执行基本流程为：</p><ol type="1"><li>利用所配置的 PlatformTransactionManager事务管理器新建一个数据库连接</li><li>修改数据库连接的 autocommit 为 false</li><li>执行 MethodInvocation.proceed() 方法，即执行业务方法，其中就会执行sql</li><li>如果没有抛异常，则提交</li><li>如果抛了异常，则回滚</li></ol><h3 id="spring事务详细执行流程">3. Spring事务详细执行流程</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/Spring_transaction_ab123123132.png" /></p><p>Spring事务执行流程图：<ahref="https://www.processon.com/view/link/5fab6edf1e0853569633cc06">https://www.processon.com/view/link/5fab6edf1e0853569633cc06</a></p><h3 id="spring事务传播机制">4. Spring事务传播机制</h3><p>在开发过程中，经常会出现一个方法调用另外一个方法，那么这里就涉及到了多种场景，比如a()调用b()：</p><ol type="1"><li>a() 和 b() 方法中的所有 sql 需要在同一个事务中吗？</li><li>a() 和 b() 方法需要单独的事务吗？</li><li>a() 需要在事务中执行，b() 还需要在事务中执行吗？</li><li>等等情况...</li></ol><p>所以，这就要求 Spring 事务能支持上面各种场景，这就是 Spring事务传播机制的由来。那 Spring 事务传播机制是如何实现的呢?</p><p>先来看上述几种场景中的一种情况，a() 在一个事务中执行，调用 b()方法时需要新开一个事务执行：</p><ol type="1"><li>首先，代理对象执行 a() 方法前，先利用事务管理器新建一个数据库连接a</li><li>将数据库连接 a 的 autocommit 改为 false</li><li>把数据库连接 a 设置到 ThreadLocal 中</li><li>执行 a() 方法中的 sql</li><li>执行 a() 方法过程中，调用了 b() 方法（注意用代理对象调用 b() 方法）<ul><li>代理对象执行 b() 方法前，判断出来了当前线程中已经存在一个数据库连接a 了，表示当前线程其实已经拥有一个 Spring事务了，则进行<strong>挂起</strong></li><li>挂起就是把 ThreadLocal 中的数据库连接 a 从 ThreadLocal中移除，并放入一个<strong>挂起资源对象</strong>中</li><li>挂起完成后，再次利用事务管理器新建一个数据库连接 b</li><li>将数据库连接 b 的 autocommit 改为 false</li><li>把数据库连接 b 设置到 ThreadLocal 中</li><li>执行 b() 方法中的 sql</li><li>b() 方法正常执行完，则从 ThreadLocal 中拿到数据库连接 b进行提交</li><li>提交之后会恢复所挂起的数据库连接a，这里的恢复，其实只是把在<strong>挂起资源对象</strong>中所保存的数据库连接a 再次设置到 ThreadLocal 中</li></ul></li><li>a() 方法正常执行完，则从 ThreadLocal 中拿到数据库连接 a进行提交</li></ol><p>这个过程中最为核心的是：<strong>在执行某个方法时，判断当前是否已经存在一个事务，就是判断当前线程的ThreadLocal中是否存在一个数据库连接对象，如果存在则表示已经存在一个事务了。</strong></p><p>其中，以非事务方式运行，表示以非 Spring事务运行，就是在执行这个方法时，Spring事务管理器不会去建立数据库连接，执行 sql 时，由 Mybatis 或 JdbcTemplate自己来建立数据库连接来执行 sql。</p><h4 id="情况1">情况1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserService userService;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// test方法中的sql</span><br>userService.a();<br>&#125;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// a方法中的sql</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认情况下传播机制为<strong>REQUIRED，表示当前如果没有事务则新建一个事务，如果有事务则在当前事务中执行。</strong></p><p>所以上面这种情况的执行流程如下：</p><ol type="1"><li>新建一个数据库连接 conn</li><li>设置 conn 的 autocommit 为 false</li><li>执行 test 方法中的 sql</li><li>执行 a 方法中的 sql</li><li>执行 conn 的 commit() 方法进行提交</li></ol><h4 id="情况2">情况2</h4><p>假如是这种情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserService userService;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// test方法中的sql</span><br>userService.a();<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">100</span>/<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// a方法中的sql</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以上面这种情况的执行流程如下：</p><ol type="1"><li>新建一个数据库连接 conn</li><li>设置 conn 的 autocommit 为 false</li><li>执行 test 方法中的 sql</li><li>执行 a 方法中的 sql</li><li>抛出异常</li><li>执行 conn 的 rollback() 方法进行回滚，所以两个方法中的 sql都会回滚掉</li></ol><h4 id="情况3">情况3</h4><p>假如是这种情况： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserService userService;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// test方法中的sql</span><br>userService.a();<br>&#125;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// a方法中的sql</span><br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">100</span>/<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure> 所以上面这种情况的执行流程如下：</p><ol type="1"><li>新建一个数据库连接 conn</li><li>设置 conn 的 autocommit 为 false</li><li>执行 test 方法中的 sql</li><li>执行 a 方法中的 sql</li><li>抛出异常</li><li>执行 conn 的 rollback() 方法进行回滚，所以两个方法中的 sql都会回滚掉</li></ol><h4 id="情况4">情况4</h4><p>如果是这种情况： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserService userService;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// test方法中的sql</span><br>userService.a();<br>&#125;<br><br><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// a方法中的sql</span><br><span class="hljs-keyword">int</span> result = <span class="hljs-number">100</span>/<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure> 所以上面这种情况的执行流程如下：</p><ol type="1"><li>新建一个数据库连接 conn</li><li>设置 conn 的 autocommit 为 false</li><li>执行 test 方法中的 sql</li><li>又新建一个数据库连接 conn2</li><li>执行 a 方法中的 sql</li><li>抛出异常</li><li>执行 conn2 的 rollback() 方法进行回滚</li><li><strong>继续抛异常，对于 test()方法而言，它会接收到一个异常，然后抛出</strong></li><li>执行 conn 的 rollback() 方法进行回滚，最终还是两个方法中的 sql都回滚了</li></ol><h3 id="spring事务强制回滚">5. Spring事务强制回滚</h3><p>正常情况下，a() 调用 b() 方法时，如果 b() 方法抛了异常，但是在 a()方法捕获了，那么 a()的事务还是会正常提交的，但是有的时候，我们捕获异常可能仅仅只是不把异常信息返回给客户端，而返回一些更友好的错误信息，此时我们还是希望事务能回滚的，那就得告诉Spring 把当前事务回滚掉，做法就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-comment">// 执行sql</span><br><span class="hljs-keyword">try</span> &#123;<br>b();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-comment">// 构造友好的错误信息返回</span><br>TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();<br>&#125;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="transactionsynchronization">6. TransactionSynchronization</h3><p>Spring 事务有可能会提交、回滚、挂起、恢复，所以 Spring事务提供了一种机制，可以让程序员来监听当前 Spring 事务所处于的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserService userService;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>TransactionSynchronizationManager.registerSynchronization(<span class="hljs-keyword">new</span> TransactionSynchronization() &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">suspend</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test被挂起了&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test被恢复了&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeCommit</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> readOnly)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test准备要提交了&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeCompletion</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test准备要提交或回滚了&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCommit</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test提交成功了&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> status)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test提交或回滚成功了&quot;</span>);<br>&#125;<br>&#125;);<br><br>jdbcTemplate.execute(<span class="hljs-string">&quot;insert into t1 values(1,1,1,1,&#x27;1&#x27;)&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;test&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="setglobalrollbackonparticipationfailure">7.setGlobalRollbackOnParticipationFailure</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title">platformTransactionManager</span><span class="hljs-params">()</span></span>&#123;<br>    DataSourceTransactionManager transactionManager = <span class="hljs-keyword">new</span> DataSourceTransactionManager(dataSource());<br>    <span class="hljs-comment">// 部分失败是否全局回滚，默认 true</span><br>    transactionManager.setGlobalRollbackOnParticipationFailure(<span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">return</span> transactionManager;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    UserService userService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    JdbcTemplate jdbcTemplate;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span>  </span>&#123;<br>        jdbcTemplate.update(<span class="hljs-string">&quot;insert into t_user( name, age) VALUES (?,?)&quot;</span>, <span class="hljs-string">&quot;lisi1&quot;</span>, <span class="hljs-number">18</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            userService.add();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>        jdbcTemplate.update(<span class="hljs-string">&quot;insert into t_user( name, age) VALUES (?,?)&quot;</span>, <span class="hljs-string">&quot;lisi2&quot;</span>, <span class="hljs-number">18</span>);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    &#125;<br>&#125;<br>````<br><br>为 <span class="hljs-keyword">false</span> 时，执行 test 方法，两条都插入<br>为 <span class="hljs-keyword">true</span> 时，全部回滚<br><br>```java<br><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>    jdbcTemplate.update(<span class="hljs-string">&quot;insert into t_user( name, age) VALUES (?,?)&quot;</span>, <span class="hljs-string">&quot;lisi2&quot;</span>, <span class="hljs-number">18</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>&#125;<br></code></pre></td></tr></table></figure><p>此时为 true 时，test 方法不回滚，add 方法回滚</p><p><strong>一个事务中要么全都回滚，要么全都不回滚</strong></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——事务</title>
    <link href="/2022/08/27/Spring%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/08/27/Spring%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="spring-jdbctemplate">1. Spring JdbcTemplate</h3><h4 id="配置数据源">1.1 配置数据源</h4><p><strong>pom:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.21.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-orm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.21.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.29<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220827194209.png" /></p><p><strong>dbconfig.properties:</strong> <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">jdbc.name</span>=root<br><span class="hljs-attr">jdbc.password</span>=mysql<br><span class="hljs-attr">jdbc.url</span>=jdbc:mysql://localhost:<span class="hljs-number">3306</span>/debuggingworld?useSSL=<span class="hljs-literal">false</span><br><span class="hljs-attr">jdbc.driverClassName</span>=com.mysql.jdbc.Driver<br></code></pre></td></tr></table></figure></p><h4 id="添加-datasource-和-jdbctemplate">1.2 添加 dataSource 和JdbcTemplate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(&quot;com.zth&quot;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:dbConfig.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.name&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String pwd;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driverClassName&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String driverClassName;<br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DruidDataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;<br><br>        DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();<br>        dataSource.setUsername(userName);<br>        dataSource.setPassword(pwd);<br>        dataSource.setUrl(url);<br>        dataSource.setDriverClassName(driverClassName);<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title">jdbcTemplate</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcTemplate(dataSource());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="查询">1.3 查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoTest</span> </span>&#123;<br><br>    JdbcTemplate jdbcTemplate;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br>        jdbcTemplate = context.getBean(JdbcTemplate.class);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> 查询单个对象_对象属性和数据库字段一致() &#123;<br>        User user = jdbcTemplate.queryForObject(<span class="hljs-string">&quot;select * from t_user where id = ?&quot;</span>,<br>                <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;&gt;(User.class), <span class="hljs-number">1</span>);<br>        System.out.println(user);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> 查询单个对象_对象属性和数据库字段不一致() &#123;<br>        User user = jdbcTemplate.queryForObject(<span class="hljs-string">&quot;select * from t_user where id = ?&quot;</span>, <span class="hljs-keyword">new</span> RowMapper&lt;User&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">mapRow</span><span class="hljs-params">(ResultSet resultSet, <span class="hljs-keyword">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>                User user = <span class="hljs-keyword">new</span> User();<br>                user.setId(resultSet.getInt(<span class="hljs-string">&quot;id&quot;</span>));<br>                user.setName(resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>                user.setAge(resultSet.getInt(<span class="hljs-string">&quot;age&quot;</span>));<br>                <span class="hljs-keyword">return</span> user;<br>            &#125;<br>        &#125;, <span class="hljs-number">1</span>);<br>        System.out.println(user);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> 查询多个对象_对象属性和数据库字段不一致() &#123;<br>        List&lt;User&gt; users = jdbcTemplate.query(<span class="hljs-string">&quot;select * from t_user where id &gt; ?&quot;</span>, <span class="hljs-keyword">new</span> RowMapper&lt;User&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">mapRow</span><span class="hljs-params">(ResultSet resultSet, <span class="hljs-keyword">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>                User user = <span class="hljs-keyword">new</span> User();<br>                user.setId(resultSet.getInt(<span class="hljs-string">&quot;id&quot;</span>));<br>                user.setName(resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>                user.setAge(resultSet.getInt(<span class="hljs-string">&quot;age&quot;</span>));<br>                <span class="hljs-keyword">return</span> user;<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>);<br>        System.out.println(users);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="增删改">1.4 增删改</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsert</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> result = jdbcTemplate.update(<span class="hljs-string">&quot;insert into t_user( name, age) VALUES (?,?)&quot;</span>, <span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">18</span>);<br>    System.out.println(result);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testBatchInsert</span><span class="hljs-params">()</span> </span>&#123;<br>    ArrayList&lt;Object[]&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    users.add(<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">20</span>&#125;);<br>    users.add(<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">20</span>&#125;);<br>    users.add(<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-number">20</span>&#125;);<br><br>    <span class="hljs-keyword">int</span>[] result = jdbcTemplate.batchUpdate(<span class="hljs-string">&quot;insert into t_user( name, age) VALUES (?,?)&quot;</span>, users);<br>    System.out.println(result);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpdate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> result = jdbcTemplate.update(<span class="hljs-string">&quot;update t_user set age = ? where id = ? &quot;</span>, <span class="hljs-number">20</span>,<span class="hljs-number">2</span>);<br>    System.out.println(result);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> result = jdbcTemplate.update(<span class="hljs-string">&quot;delete from t_user where id = ?&quot;</span>, <span class="hljs-number">2</span>);<br>    System.out.println(result);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="具名参数">1.5 具名参数</h4><p><strong>NamedParameterJdbcTemplate:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> NamedParameterJdbcTemplate <span class="hljs-title">namedParameterJdbcTemplate</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NamedParameterJdbcTemplate(dataSource());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testNamedParameterJdbcTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>    Map&lt;String,Object&gt; user = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    user.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;aa&quot;</span>);<br>    user.put(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">20</span>);<br><br>    <span class="hljs-keyword">int</span> result = namedParameterJdbcTemplate.update(<span class="hljs-string">&quot;insert into t_user(name, age) values(:name,:age)&quot;</span>, user);<br>    System.out.println(result);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="spring-jdbctemplate-整合-dao">1.6 Spring JdbcTemplate 整合dao</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUserDao</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDataSource</span><span class="hljs-params">(DataSource dataSource)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.jdbcTemplate = <span class="hljs-keyword">new</span> JdbcTemplate(dataSource);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> jdbcTemplate.queryForObject(<span class="hljs-string">&quot;select * from t_user where id = ?&quot;</span>,<br>                <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;&gt;(User.class), <span class="hljs-number">1</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="声明式事务">2. 声明式事务</h3><h4 id="基于注解">2.1 基于注解</h4><h5 id="添加事务管理器">添加事务管理器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> DruidDataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;<br><br>    DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();<br>    dataSource.setUsername(userName);<br>    dataSource.setPassword(pwd);<br>    dataSource.setUrl(url);<br>    dataSource.setDriverClassName(driverClassName);<br>    <span class="hljs-keyword">return</span> dataSource;<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> DataSourceTransactionManager <span class="hljs-title">dataSourceTransactionManager</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceTransactionManager(dataSource());<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="开启事务注解驱动">开启事务注解驱动</h5><p><strong><span class="citation"data-cites="EnableTransactionManagement">@EnableTransactionManagement</span></strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(&quot;com.zth&quot;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableTransactionManagement</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:dbConfig.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    UserService userService;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>       <span class="hljs-comment">//……</span><br>        userService.add();<br>    &#125;<br><br>    <span class="hljs-meta">@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-comment">//……</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="基于xml">2.2 基于xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.zth&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:dbConfig.properties&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.name&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 基于xml配置的事务：依赖tx名称空间和aop名称空间</span><br><span class="hljs-comment"> 1、spring中提供事务管理器（切面），配置这个事务管理器</span><br><span class="hljs-comment"> 2、配置出事务方法</span><br><span class="hljs-comment"> 3、告诉spring哪些方法是事务方法（事务切面按照切点表达式去切入事务方法） --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txPoint&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.zth.debugSpring.service..*(..))&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;txPoint&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--事务属性--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;get*&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">rollback-for</span>=<span class="hljs-string">&quot;IOException&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="transactional">3 <span class="citation"data-cites="Transactional">@Transactional</span></h3><p><span class="citation"data-cites="Transactional">@Transactional</span>可以标记在类上面，当前类所有的方法都运用事务 <span class="citation"data-cites="Transactional">@Transactional</span>标记在方法则只是当前方法运用事务 如果类和方法都存在 <spanclass="citation" data-cites="Transactional">@Transactional</span>会以方法的为准。 建议：<span class="citation"data-cites="Transactional">@Transactional</span>写在方法上面，控制粒度更细，而且建议 <span class="citation"data-cites="Transactional">@Transactional</span> 写在业务逻辑层上</p><p>事务配置的属性 + isolation：设置事务的隔离级别 +propagation：事务的传播行为 + noRollbackFor：那些异常事务可以不回滚 +noRollbackForClassName：填写的参数是全类名 +rollbackFor：哪些异常事务需要回滚 +rollbackForClassName：填写的参数是全类名 +readOnly：设置事务是否为只读事务 +timeout：事务超出指定执行时长后自动终止并回滚,单位是秒</p><h4 id="隔离级别isolation">3.1 隔离级别（isolation）</h4><p><strong>使用方式：</strong> <span class="citation"data-cites="Transactional">@Transactional</span>(isolation =Isolation.REPEATABLE_READ)</p><ul><li>Isolation.DEFAULT：默认值，表示使用底层数据库的默认隔离级别。</li><li>Isolation.READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。</li><li>Isolation.READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。</li><li>Isolation.REPEATABLE_READ：该隔离级别表示一个事务中多次某个查询得到的记录相同。</li><li>Isolation.SERIALIZABLE：所有的事务依次串行执行。</li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/事务隔离级别abzd.png" /></p><p>并发安全：SERIALIZABLE&gt;REPEATABLE_READ&gt;READ_COMMITTED运行效率：READ_COMMITTED&gt;REPEATABLE_READ&gt;SERIALIZABLE</p><h4 id="事务的传播特性">3.2 事务的传播特性</h4><p>当一个具有事务控制的方法被另一个有事务控制的方法调用后，需要如何管理事务(新建事务?在事务中执行?把事务挂起?报异常?)</p><p><strong>使用方式：</strong> <span class="citation"data-cites="Transactional">@Transactional</span>(propagation =Propagation.REQUIRED)</p><table><thead><tr><th>事务传播行为类型</th><th>外部不存在事务</th><th>外部存在事务</th><th>使用方式</th></tr></thead><tbody><tr><td>REQUIRED（默认）</td><td>开启新的事务</td><td>融合到外部事务中</td><td>适用增删改查</td></tr><tr><td>SUPPORTS</td><td>不开启新的事务</td><td>融合到外部事务中</td><td>适用查询</td></tr><tr><td>REQUIRES_NEW</td><td>开启新的事务</td><td>挂起外部事务，创建新的事务</td><td>适用内部事务和外部事务不存在业务关联情况，如日志</td></tr><tr><td>NOT_SUPPORTED</td><td>不开启新的事务</td><td>挂起外部事务</td><td>不常用</td></tr><tr><td>NEVER</td><td>不开启新的事务</td><td>抛出异常</td><td>不常用</td></tr><tr><td>NESTED</td><td>开启新的事务</td><td>嵌套事务内执行</td><td>不常用</td></tr><tr><td>MANDATORY</td><td>抛出异常</td><td>融合到外部事务中</td><td>不常用</td></tr></tbody></table><p>https://zhuanlan.zhihu.com/p/148504094</p><p><strong>外部事务需要挂起的，外部事务和内部事务必须不在同一个类中</strong></p><h4 id="超时属性timeout">3.3 超时属性(timeout)</h4><p>指定事务等待的最长时间（秒）当前事务访问数据时，有可能访问的数据被别的数据进行加锁的处理，那么此时事务就必须等待，如果等待时间过长给用户造成的体验感差。超时直接回滚返回。</p><p><strong>使用方式：</strong> <span class="citation"data-cites="Transactional">@Transactional</span>(timeout = 2)</p><p>Spring事务超时 = 事务开始时到最后一个Statement创建时时间 +最后一个Statement的执行时超时时间（即其queryTimeout）。</p><h4 id="设置事务只读readonly">3.4 设置事务只读(readOnly)</h4><p><strong>使用方式：</strong> <span class="citation"data-cites="Transactional">@Transactional</span>(readOnly = true)</p><p>readonly：只会设置在查询的业务方法中 connection.setReadOnly(true)通知数据库当前操作是只读，数据库就会对当前只读做相应优化</p><p>如果一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持 SQL执行期间的读一致性；如果一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询SQL 必须保证整体的读一致性，否则在前一条 SQL 查询之后，后一条 SQL查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时应该启用事务支持（如：设置不可重复度、幻影读级别）。 对于只读事务，可以指定事务类型为readonly，即只读事务。由于只读事务不存在数据的修改，因此数据库将会为只读事务提供一些优化手段。</p><p>https://blog.csdn.net/jinwufeiyang/article/details/119300491</p><h4 id="异常属性">3.5 异常属性</h4><p><strong>使用方式：</strong> <span class="citation"data-cites="Transactional">@Transactional</span>(rollbackFor =IOException.class)</p><p>设置当前事务出现哪些异常就进行回滚或者提交。</p><p>默认对于 RuntimeException 、Error 及其子类采用的是回滚的策略。默认对于 检查异常及其子类采用的是提交的策略。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220828225955.png" /></p><h4 id="使用推荐">3.6 使用推荐</h4><p>如果当前业务方法是一组 增、改、删 ： <span class="citation"data-cites="Transactional">@Transactional</span>如果当前业务方法是一组查询：<span class="citation"data-cites="Transactionl">@Transactionl</span>(readOnly=true)如果当前业务方法是单个查询：<span class="citation"data-cites="Transactionl">@Transactionl</span>(propagation=propagation.SUPPORTS,readOnly=true)</p><h3 id="事务失效">4. 事务失效</h3><p>https://baijiahao.baidu.com/s?id=1714667126401049636&amp;wfr=spider&amp;for=pc</p><p>https://zhuanlan.zhihu.com/p/514257018</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——AOP源码解析</title>
    <link href="/2022/08/14/Spring%E2%80%94%E2%80%94AOP%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/08/14/Spring%E2%80%94%E2%80%94AOP%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>https://www.processon.com/view/link/6308fe21f346fb0714c2314d</p><h3 id="动态代理">1. 动态代理</h3><p>代理模式：为<strong>对象</strong>提供一种<strong>代理</strong>以控制对这个对象的访问，增强一个类中的某个方法，对程序进行扩展。</p><p>如果我们现在想在<strong>不修改 UserService 类源码</strong>前提下，给test() 增加额外逻辑，那么就可以使用动态代理机制来创建 UserService对象了。</p><h4 id="cglib-动态代理">1.1 cglib 动态代理</h4><p>比如，现在存在一个UserService类： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;test...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;debug...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 被代理对象</span><br>UserService target = <span class="hljs-keyword">new</span> UserService();<br><br>Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>enhancer.setSuperclass(UserService.class);<br><br><span class="hljs-comment">// 定义代理逻辑</span><br>enhancer.setCallbacks(<span class="hljs-keyword">new</span> Callback[]&#123;<span class="hljs-keyword">new</span> MethodInterceptor() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * o 代理对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;before......&quot;</span>);<br>        <span class="hljs-comment">// 执行被代理对象方法</span><br>        <span class="hljs-comment">// Object result = methodProxy.invoke(target, objects);</span><br>        <span class="hljs-comment">// Object result = method.invoke(target, objects);</span><br>        Object result = methodProxy.invokeSuper(o, objects);  <span class="hljs-comment">// 执行代理对象的父类的方法（等同于执行被代理对象的方法）</span><br>        <span class="hljs-comment">// method.invoke(o,objects); 会无限递归（错误用法）</span><br>        System.out.println(<span class="hljs-string">&quot;after........&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;&#125;);<br>UserService userService = (UserService) enhancer.create();<br>userService.test();<br>userService.debug();<br></code></pre></td></tr></table></figure><p>userService 中的所有方法都会执行相同的代理逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">UserService target = <span class="hljs-keyword">new</span> UserService();<br><br>Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>enhancer.setSuperclass(UserService.class);<br><br>enhancer.setCallbacks(<span class="hljs-keyword">new</span> Callback[]&#123;<span class="hljs-keyword">new</span> MethodInterceptor() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;before......&quot;</span>);<br>        Object result = methodProxy.invoke(target, objects);<br>        System.out.println(<span class="hljs-string">&quot;after........&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;, NoOp.INSTANCE&#125;);<br><span class="hljs-comment">// NoOp.INSTANCE 为空实现</span><br><span class="hljs-comment">// debug 方法执行下标为0的拦截器，其他的执行下标为1的拦截器</span><br>enhancer.setCallbackFilter(<span class="hljs-keyword">new</span> CallbackFilter() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(Method method)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">&quot;debug&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;);<br>UserService userService = (UserService) enhancer.create();<br>userService.test();<br>userService.debug();<br></code></pre></td></tr></table></figure><p>实现不同的方法执行不同的代理逻辑。</p><p>上面是通过 cglib来实现的代理对象的创建，是基于<strong>父子类</strong>的，被代理类（UserService）是父类，代理类是子类，代理对象就是代理类的实例对象，代理类是由cglib 创建的。</p><h4 id="jdk-动态代理">1.2 jdk 动态代理</h4><p>除了 cglib技术，jdk本身也提供了一种创建代理对象的动态代理机制，但是它只能代理接口，也就是UserService 得先有一个接口才能利用 jdk动态代理机制来生成一个代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserInterface</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserInterface</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test...&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>利用 JDK 动态代理来生成一个代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">UserService target = <span class="hljs-keyword">new</span> UserService();<br>Object proxy = Proxy.newProxyInstance(UserService.class.getClassLoader(), <span class="hljs-keyword">new</span> Class[]&#123;IUserService.class&#125;, <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;before...&quot;</span>);<br>        Object result = method.invoke(target, args);<br>        System.out.println(<span class="hljs-string">&quot;after...&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;);<br>IUserService userService = (IUserService) proxy;<br>userService.test();<br></code></pre></td></tr></table></figure><p>如果你把 new Class[]{UserInterface.class}，替换成 newClass[]{UserService.class}，允许代码会直接报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.IllegalArgumentException: com.zth.debugSpring.service.UserService is not an <span class="hljs-class"><span class="hljs-keyword">interface</span></span><br></code></pre></td></tr></table></figure><p>表示一定要是个接口。</p><p>由于这个限制，所以产生的代理对象的类型是 UserInterface，而不是UserService。</p><p>https://segmentfault.com/a/1190000041619989</p><p>https://blog.csdn.net/m0_38033199/article/details/125852733</p><p>https://zhuanlan.zhihu.com/p/426867875</p><h3 id="proxyfactory">2. ProxyFactory</h3><p>在 Spring 中对以上两种动态代理技术进行了封装，封装后的类叫做ProxyFactory，表示是创建代理对象的一个工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>UserService target = <span class="hljs-keyword">new</span> UserService();<br><br>ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory();<br>proxyFactory.setTarget(target);<br>proxyFactory.addAdvice(<span class="hljs-keyword">new</span> MethodInterceptor() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;before...&quot;</span>);<br>Object result = invocation.proceed();<br>System.out.println(<span class="hljs-string">&quot;after...&quot;</span>);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;);<br><br>UserInterface userService = (UserInterface) proxyFactory.getProxy();<br>userService.test();<br></code></pre></td></tr></table></figure><p>通过 ProxyFactory，可以不再关心到底是用 cglib 还是 jdk动态代理了，ProxyFactory 会去判断，如果 UserService 实现了接口，那么ProxyFactory 底层就会用 jdk 动态代理，如果没有实现接口，就会用 cglib技术。</p><h3 id="advice">3. Advice</h3><h4 id="前置通知-methodbeforeadvice">3.1 前置通知MethodBeforeAdvice</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugBeforeAdvice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodBeforeAdvice</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * target：被代理对象</span><br><span class="hljs-comment">     * method：当前执行的方法</span><br><span class="hljs-comment">     * args：执行方法传入的参数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Method method, Object[] args, Object target)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-comment">// 只需写代理逻辑，不需要调用被代理方法</span><br>        System.out.println(<span class="hljs-string">&quot;before.....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="后置返回通知-afterreturningadvice">3.2 后置返回通知AfterReturningAdvice</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugAfterReturningAdvice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AfterReturningAdvice</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * returnValue：方法返回值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturning</span><span class="hljs-params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;after return&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="异常通知-throwsadvice">3.3 异常通知 ThrowsAdvice</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugThrowsAdvice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThrowsAdvice</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">(Method method,Object[] args,Object target,NullPointerException e)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;after throw nullPointerException&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ThrowsAdvice 接口不包含任何方法。它只是标识给定对象实现一个或多个类型化异常通知方法的标识接口,这些应该是以下形式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">(Exception ex)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">(RemoteException)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">(Method method, Object[] args, Object target, Exception ex)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">(Method method, Object[] args, Object target, ServletException ex)</span></span><br></code></pre></td></tr></table></figure><h4 id="环绕通知-methodinterceptor">3.4 环绕通知 MethodInterceptor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MethodInterceptor 是 aop 包中的，不是 cglib 包中的</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugAroundAdvice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;around before...&quot;</span>);<br>        <span class="hljs-comment">// 执行被代理的方法，执行之前会执行其他的 前置通知</span><br>        Object result = invocation.proceed();<br>        System.out.println(<span class="hljs-string">&quot;around after...&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Spring 会把五个注解解析为对应的 Advice 类：</p><ol type="1"><li><span class="citation"data-cites="Before">@Before</span>：AspectJMethodBeforeAdvice，实际上就是一个MethodBeforeAdvice，继承了接口 BeforeAdvice</li><li><span class="citation"data-cites="AfterReturning">@AfterReturning</span>：AspectJAfterReturningAdvice，实际上就是一个AfterReturningAdvice</li><li><span class="citation"data-cites="AfterThrowing">@AfterThrowing</span>：AspectJAfterThrowingAdvice，实际上就是一个MethodInterceptor</li><li><span class="citation"data-cites="After">@After</span>：AspectJAfterAdvice，实际上就是一个MethodInterceptor</li><li><span class="citation"data-cites="Around">@Around</span>：AspectJAroundAdvice，实际上就是一个MethodInterceptor</li></ol><h3 id="advisor">4. Advisor</h3><p>一个 Advisor 是由一个 Pointcut 和一个 Advice 组成的，通过 Pointcut可以指定要需要被代理的逻辑，比如上面的 UserService，所有方法都会被代理，被增强，可以通过Advisor，来控制到具体代理哪一个方法。</p><p>比如只有 debug 方法执行代理逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">UserService target = <span class="hljs-keyword">new</span> UserService();<br><br>ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory();<br>proxyFactory.setTarget(target);<br><br>proxyFactory.addAdvisor(<span class="hljs-keyword">new</span> PointcutAdvisor() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pointcut <span class="hljs-title">getPointcut</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StaticMethodMatcherPointcut() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> method.getName().equals(<span class="hljs-string">&quot;debug&quot;</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Advice <span class="hljs-title">getAdvice</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DebugBeforeAdvice();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPerInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;);<br><br>UserService proxy = (UserService) proxyFactory.getProxy();<br>proxy.test();<br>proxy.debug();<br></code></pre></td></tr></table></figure><h3 id="创建代理对象的方式">5. 创建代理对象的方式</h3><p>上面介绍了 Spring 中所提供的 ProxyFactory、Advisor、Advice、PointCut等技术来实现代理对象的创建，但是在使用 Spring 时，并不会直接去使用ProxyFactory，比如说，希望 ProxyFactory 所产生的代理对象能直接就是Bean，能直接从 Spring 容器中得到 UserSerivce 的代理对象，而这些，Spring都是支持的，只不过肯定需要指定哪些类需要被代理，代理逻辑是什么。</p><h4 id="proxyfactorybean">5.1 ProxyFactoryBean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ProxyFactoryBean <span class="hljs-title">proxyFactoryBean</span><span class="hljs-params">()</span></span>&#123;<br><br>    ProxyFactoryBean proxyFactoryBean = <span class="hljs-keyword">new</span> ProxyFactoryBean();<br>    proxyFactoryBean.addAdvice(<span class="hljs-keyword">new</span> DebugBeforeAdvice());<br>    proxyFactoryBean.setTarget(<span class="hljs-keyword">new</span> UserService());<br><br>    <span class="hljs-keyword">return</span> proxyFactoryBean;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这种方法来定义一个UserService的Bean，并且是经过了AOP的。但是这种方式<strong>只能针对某一个Bean</strong>。它是一个 FactoryBean，所以利用的就是 FactoryBean技术，间接的将 UserService 的代理对象作为了 Bean。</p><p>ProxyFactoryBean 还有额外的功能，比如可以把某个 Advise 或 Advisor定义成为 Bean，然后在 ProxyFactoryBean 中进行设置 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> DebugBeforeAdvice <span class="hljs-title">debugBeforeAdvice</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DebugBeforeAdvice();<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ProxyFactoryBean <span class="hljs-title">userService</span><span class="hljs-params">()</span></span>&#123;<br>    ProxyFactoryBean proxyFactoryBean = <span class="hljs-keyword">new</span> ProxyFactoryBean();<br>    proxyFactoryBean.setTarget( <span class="hljs-keyword">new</span> UserService());<br>    proxyFactoryBean.setInterceptorNames(<span class="hljs-string">&quot;debugBeforeAdvice&quot;</span>);<br>    <span class="hljs-keyword">return</span> proxyFactoryBean;<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="beannameautoproxycreator">5.2 BeanNameAutoProxyCreator</h4><p>ProxyFactoryBean 得指定被代理的对象，而 BeanNameAutoProxyCreator通过指定某个 bean 的名字，来对该 bean 进行代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> BeanNameAutoProxyCreator <span class="hljs-title">beanNameAutoProxyCreator</span><span class="hljs-params">()</span> </span>&#123;<br>    BeanNameAutoProxyCreator beanNameAutoProxyCreator = <span class="hljs-keyword">new</span> BeanNameAutoProxyCreator();<br>    <span class="hljs-comment">// 匹配 beanName</span><br>    beanNameAutoProxyCreator.setBeanNames(<span class="hljs-string">&quot;userSer*&quot;</span>);<br>    <span class="hljs-comment">// 前提是将通知作为 Bean</span><br>    beanNameAutoProxyCreator.setInterceptorNames(<span class="hljs-string">&quot;debugBeforeAdvice&quot;</span>);<br>    <span class="hljs-keyword">return</span> beanNameAutoProxyCreator;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 BeanNameAutoProxyCreator 可以对批量的 Bean 进行AOP，并且指定了代理逻辑，指定了一个 InterceptorName，也就是一个Advice，前提条件是这个 Advice 也得是一个 Bean，这样 Spring才能找到的，但是 BeanNameAutoProxyCreator 的缺点很明显，它只能根据beanName 来指定想要代理的 Bean。</p><h4 id="defaultadvisorautoproxycreator">5.3DefaultAdvisorAutoProxyCreator</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultPointcutAdvisor <span class="hljs-title">defaultPointcutAdvisor</span><span class="hljs-params">()</span> </span>&#123;<br><br>       NameMatchMethodPointcut pointcut = <span class="hljs-keyword">new</span> NameMatchMethodPointcut();<br>       pointcut.addMethodName(<span class="hljs-string">&quot;debug&quot;</span>);<br><br>       DefaultPointcutAdvisor advisor = <span class="hljs-keyword">new</span> DefaultPointcutAdvisor();<br>       advisor.setPointcut(pointcut);<br>       advisor.setAdvice(<span class="hljs-keyword">new</span> DebugBeforeAdvice());<br>       <span class="hljs-keyword">return</span> advisor;<br>   &#125;<br>   <br><br><span class="hljs-comment">// 等价于 @Import(DefaultAdvisorAutoProxyCreator.class)</span><br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultAdvisorAutoProxyCreator  <span class="hljs-title">defaultAdvisorAutoProxyCreator</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultAdvisorAutoProxyCreator();<br>   &#125;<br></code></pre></td></tr></table></figure><p>DefaultAdvisorAutoProxyCreator 是一个 BeanPostProcessor，会使 Bean在初始化后找到所有的 Advisor，匹配其中的 pointcut，如果匹配则生成代理对象。</p><p>但是，通过这种方式得依靠某一个类来实现定义 Advisor，或者 Advise，或者Pointcut，那么这个步骤能不能更加简化一点呢？</p><p>对的，通过<strong>注解</strong>！</p><h4 id="通过注解">5.4 通过注解</h4><p>定义一个类，在类中的方法上通过某些注解，来定义 PointCut 以及Advice。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugAspect</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Before(&quot;execution(public void com.zth.debugSpring.service.UserService.test())&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugBefore</span><span class="hljs-params">(JoinPoint joinPoint)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Before.....&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>对于 Spring 来说，要做的就是来解析这些注解，解析之后得到对应的Pointcut 对象、Advice 对象，生成 Advisor 对象，放进 ProxyFactory中，进而产生对应的代理对象（由 <span class="citation"data-cites="EnableAspectJAutoProxy">@EnableAspectJAutoProxy</span>注解完成）。</p><h3 id="对-spring-aop-的理解">6. 对 Spring AOP 的理解</h3><p>OOP表示面向对象编程，是一种编程思想，AOP表示面向切面编程，也是一种编程思想，而上面所描述的就是Spring 为了更加方便的做到面向切面编程所提供的技术支持，换句话说，就是Spring 提供了一套机制，可以更加容易的来进行 AOP，这套机制可以称之为Spring AOP。</p><p>上面所提供的注解的方式来定义 Pointcut 和 Advice，Spring并不是首创，首创是 AspectJ，而且也不仅仅只有 Spring 提供了一套机制来支持AOP，还有比如 JBoss 4.0、aspectwerkz 等技术都提供了对于 AOP的支持。而刚刚说的注解的方式，Spring 是依赖了 AspectJ 的，或者说，Spring是直接把 AspectJ中所定义的那些注解直接拿过来用，自己没有再重复定义了，不过也仅仅只是把注解的定义复制过来了，每个注解具体底层是怎么解析的，还是Spring 自己做的，所以在用 Spring 时，如果你想用 <span class="citation"data-cites="Before">@Before</span>、<span class="citation"data-cites="Around">@Around</span> 等注解，需要引入 aspecj 相关 jar包的。</p><p>值得注意的是：AspectJ 是在编译时对字节码进行了修改，是直接在UserService 类对应的字节码中进行增强的，也就是说在编译时就会去解析 <spanclass="citation" data-cites="Before">@Before</span>这些注解，然后得到代理逻辑，加入到被代理的类中的字节码中去的，所以如果想用AspectJ 技术来生成代理对象 ，是需要用单独的 AspectJ 编译器的。而 Spring只是用了 <span class="citation" data-cites="Before">@Before</span>这些注解，在启动 Spring 的过程中，Spring会去解析这些注解，然后利用动态代理机制生成代理对象。</p><p>IDEA中使用Aspectj：<ahref="https://blog.csdn.net/gavin_john/article/details/80156963">https://blog.csdn.net/gavin_john/article/details/80156963</a></p><h3 id="targetsource-的使用">7. TargetSource 的使用</h3><p>AOP 中被代理对象就是 Bean 对象，是由 BeanFactory给我们创建出来的，Spring AOP 中提供了 TargetSource机制，可以用来自定义逻辑来创建<strong>被代理对象</strong>。</p><p>当 <span class="citation"data-cites="Lazy注解加在属性上时">@Lazy注解加在属性上时</span>，会产生一个代理对象赋值给这个属性，生成代理对象的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">buildLazyResolutionProxy</span><span class="hljs-params">(<span class="hljs-keyword">final</span> DependencyDescriptor descriptor, <span class="hljs-keyword">final</span> <span class="hljs-meta">@Nullable</span> String beanName)</span> </span>&#123;<br>BeanFactory beanFactory = getBeanFactory();<br>Assert.state(beanFactory <span class="hljs-keyword">instanceof</span> DefaultListableBeanFactory,<br><span class="hljs-string">&quot;BeanFactory needs to be a DefaultListableBeanFactory&quot;</span>);<br><span class="hljs-keyword">final</span> DefaultListableBeanFactory dlbf = (DefaultListableBeanFactory) beanFactory;<br><br>TargetSource ts = <span class="hljs-keyword">new</span> TargetSource() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Class&lt;?&gt; getTargetClass() &#123;<br><span class="hljs-keyword">return</span> descriptor.getDependencyType();<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStatic</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getTarget</span><span class="hljs-params">()</span> </span>&#123;<br>Set&lt;String&gt; autowiredBeanNames = (beanName != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">1</span>) : <span class="hljs-keyword">null</span>);<br>Object target = dlbf.doResolveDependency(descriptor, beanName, autowiredBeanNames, <span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">if</span> (target == <span class="hljs-keyword">null</span>) &#123;<br>Class&lt;?&gt; type = getTargetClass();<br><span class="hljs-keyword">if</span> (Map.class == type) &#123;<br><span class="hljs-keyword">return</span> Collections.emptyMap();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (List.class == type) &#123;<br><span class="hljs-keyword">return</span> Collections.emptyList();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Set.class == type || Collection.class == type) &#123;<br><span class="hljs-keyword">return</span> Collections.emptySet();<br>&#125;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchBeanDefinitionException(descriptor.getResolvableType(),<br><span class="hljs-string">&quot;Optional dependency not present for lazy injection point&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (autowiredBeanNames != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;<br><span class="hljs-keyword">if</span> (dlbf.containsBean(autowiredBeanName)) &#123;<br>dlbf.registerDependentBean(autowiredBeanName, beanName);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> target;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseTarget</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>&#125;<br>&#125;;<br><br>ProxyFactory pf = <span class="hljs-keyword">new</span> ProxyFactory();<br>pf.setTargetSource(ts);<br>Class&lt;?&gt; dependencyType = descriptor.getDependencyType();<br><span class="hljs-keyword">if</span> (dependencyType.isInterface()) &#123;<br>pf.addInterface(dependencyType);<br>&#125;<br><span class="hljs-keyword">return</span> pf.getProxy(dlbf.getBeanClassLoader());<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码就利用了ProxyFactory来生成代理对象，以及使用了TargetSource，以达到代理对象在执行某个方法时，调用TargetSource的getTarget()方法实时得到一个<strong>被代理对象</strong>。</p><h3 id="proxyfactory-选择-cglib-或-jdk-动态代理原理">8. ProxyFactory选择 cglib 或 jdk 动态代理原理</h3><p>ProxyFactory 在生成代理对象之前需要决定到底是使用 JDK 动态代理还是CGLIB 技术：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// config就是ProxyFactory对象</span><br><span class="hljs-comment">// optimize为true,或proxyTargetClass为true,或用户没有给ProxyFactory对象添加interface</span><br><span class="hljs-keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;<br>Class&lt;?&gt; targetClass = config.getTargetClass();<br><span class="hljs-keyword">if</span> (targetClass == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopConfigException(<span class="hljs-string">&quot;TargetSource cannot determine target class: &quot;</span> +<br><span class="hljs-string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);<br>&#125;<br>    <span class="hljs-comment">// targetClass是接口，直接使用Jdk动态代理</span><br><span class="hljs-keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);<br>&#125;<br>    <span class="hljs-comment">// 使用Cglib</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObjenesisCglibAopProxy(config);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 使用Jdk动态代理</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="代理对象的创建">9. 代理对象的创建</h3><h4 id="jdkdynamicaopproxy">9. 1 JdkDynamicAopProxy</h4><ol type="1"><li>在构造 JdkDynamicAopProxy对象时，会先拿到被代理对象自己所实现的接口，并且额外的增加SpringProxy、Advised、DecoratingProxy 三个接口，组合成一个Class[]，并赋值给 proxiedInterfaces 属性</li><li>并且检查这些接口中是否定义了 equals()、hashcode() 方法</li><li>执行<code>Proxy.newProxyInstance(classLoader, this.proxiedInterfaces, this)</code>，得到代理对象，<strong>JdkDynamicAopProxy</strong>作为InvocationHandler，代理对象在执行某个方法时，会进入到JdkDynamicAopProxy的 <strong>invoke()</strong> 方法中</li></ol><h4 id="objenesiscglibaopproxy">9.2 ObjenesisCglibAopProxy</h4><ol type="1"><li>创建 Enhancer 对象</li><li>设置 Enhancer 的 superClass 为通过 ProxyFactory.setTarget()所设置的对象的类</li><li>设置 Enhancer 的 interfaces 为通过 ProxyFactory.addInterface()所添加的接口，以及 SpringProxy、Advised、DecoratingProxy 接口</li><li>设置 Enhancer 的 Callbacks 为 DynamicAdvisedInterceptor</li><li>最后创建一个代理对象，代理对象在执行某个方法时，会进入到DynamicAdvisedInterceptor 的 intercept() 方法中</li></ol><h3 id="代理对象执行过程">10. 代理对象执行过程</h3><ol type="1"><li>在使用 ProxyFactory 创建代理对象之前，需要往 ProxyFactory 先添加Advisor</li><li>代理对象在执行某个方法时，会把 ProxyFactory 中的 Advisor拿出来和当前正在执行的方法进行匹配筛选</li><li>把和方法所匹配的 Advisor 适配成 MethodInterceptor</li><li>把和当前方法匹配的 MethodInterceptor链，以及被代理对象、代理对象、代理类、当前 Method 对象、方法参数封装为MethodInvocation 对象</li><li>调用 MethodInvocation 的 proceed() 方法，开始执行各个MethodInterceptor 以及被代理对象的对应方法</li><li>按顺序调用每个MethodInterceptor 的 invoke() 方法，并且会把MethodInvocation 对象传入 invoke() 方法</li><li>直到执行完最后一个 MethodInterceptor 了，就会调用 invokeJoinpoint()方法，从而执行被代理对象的当前方法</li></ol><h3 id="各注解对应的-methodinterceptor">11. 各注解对应的MethodInterceptor</h3><ul><li><strong><span class="citation"data-cites="Before">@Before</span></strong> 对应AspectJMethodBeforeAdvice，在进行动态代理时会转成<strong>MethodBeforeAdviceInterceptor</strong><ul><li>先执行 advice 对应的方法</li><li>再执行 MethodInvocation 的 proceed()，会执行下一个Interceptor，如果没有下一个 Interceptor 了，会执行 target对应的方法</li></ul></li><li><strong><span class="citation"data-cites="After">@After</span></strong> 对应AspectJAfterAdvice，直接实现了 <strong>MethodInterceptor</strong><ul><li>先执行 MethodInvocation 的 proceed()，会执行下一个Interceptor，如果没有下一个 Interceptor了，会执行 target 对应的方法</li><li>再执行 advice 对应的方法</li></ul></li><li><strong><span class="citation"data-cites="Around">@Around</span></strong> 对应AspectJAroundAdvice，直接实现了 <strong>MethodInterceptor</strong><ul><li>直接执行 advice 对应的方法，由 <span class="citation"data-cites="Around">@Around</span> 自己决定要不要继续往后面调用</li></ul></li><li><strong><span class="citation"data-cites="AfterThrowing">@AfterThrowing</span></strong> 对应AspectJAfterThrowingAdvice，直接实现了<strong>MethodInterceptor</strong><ul><li>先执行 MethodInvocation 的 proceed()，会执行下一个Interceptor，如果没有下一个 Interceptor 了，会执行 target对应的方法</li><li>如果上面抛了 Throwable，那么则会执行 advice 对应的方法</li></ul></li><li><strong><span class="citation"data-cites="AfterReturning">@AfterReturning</span></strong> 对应AspectJAfterReturningAdvice，在进行动态代理时转成<strong>AfterReturningAdviceInterceptor</strong><ul><li>先执行 MethodInvocation 的 proceed()，会执行下一个Interceptor，如果没有下一个 Interceptor 了，会执行 target对应的方法</li><li>执行上面的方法后得到最终的方法的返回值</li><li>再执行 Advice 对应的方法</li></ul></li></ul><h3 id="abstractadvisorautoproxycreator">12.AbstractAdvisorAutoProxyCreator</h3><p>DefaultAdvisorAutoProxyCreator 的父类是AbstractAdvisorAutoProxyCreator。</p><p>只要 Spring 容器中存在<strong>AbstractAdvisorAutoProxyCreator</strong> 类型的Bean，就相当于开启了 AOP，AbstractAdvisorAutoProxyCreator 实际上就是一个BeanPostProcessor，所以在创建某个 Bean时，就会进入到它对应的生命周期方法中，比如：在某个 Bean<strong>初始化之后</strong>，会调用 wrapIfNecessary() 方法进行AOP，底层逻辑是，AbstractAdvisorAutoProxyCreator 会找到所有的Advisor，然后判断当前这个 Bean 是否存在某个 Advisor 与之匹配（根据Pointcut），如果匹配就表示当前这个 Bean 有对应的切面逻辑，需要进行AOP，需要产生一个代理对象。</p><h3 id="enableaspectjautoproxy">13 <span class="citation"data-cites="EnableAspectJAutoProxy">@EnableAspectJAutoProxy</span></h3><p>这个注解主要就是往 Spring 容器中添加了一个AnnotationAwareAspectJAutoProxyCreator 类型的 Bean。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220824223600.png" /></p><p><strong>AspectJAwareAdvisorAutoProxyCreator</strong> 继承了<strong>AbstractAdvisorAutoProxyCreator</strong>，重写了findCandidateAdvisors()方法，<strong>AbstractAdvisorAutoProxyCreator</strong> 只能找到所有Advisor 类型的 Bean 对象，但是<strong>AspectJAwareAdvisorAutoProxyCreator</strong> 除开可以找到所有Advisor 类型的 Bean 对象，还能把 <span class="citation"data-cites="Aspect">@Aspect</span> 注解所标注的 Bean 中的 <spanclass="citation" data-cites="Before">@Before</span>等注解及方法进行解析，并生成对应的 Advisor 对象。</p><p>所以，我们可以理解 <span class="citation"data-cites="EnableAspectJAutoProxy">@EnableAspectJAutoProxy</span>，其实就是向Spring 容器中添加了一个 AbstractAdvisorAutoProxyCreator 类型的Bean，从而开启了 AOP，并且还会解析 <span class="citation"data-cites="Before">@Before</span> 等注解生成 Advisor。</p><h3 id="spring-中-aop-原理流程图">14. Spring 中 AOP 原理流程图</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220821204534.png" />https://www.processon.com/view/link/5faa4ccce0b34d7a1aa2a9a5</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——AOP的使用</title>
    <link href="/2022/08/06/Spring%E2%80%94%E2%80%94AOP%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/08/06/Spring%E2%80%94%E2%80%94AOP%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="aop-概念">1. AOP 概念</h3><p>面向切面编程（Aspect-oriented Programming 简称AOP），是相对面向对象编程（Object-oriented Programming简称OOP）的框架，作为 OOP 的一种功能补充.。OOP主要的模块单元是类（class）。而 AOP则是切面（aspect）。切面会将诸如事务管理这样跨越多个类型和对象的关注点模块化（在AOP的语义中，这类关注点被称为横切关注点（crosscutting））。</p><h4 id="切面aspect">1.1 切面（Aspect）</h4><p>指关注点模块化，这个关注点可能会横切多个对象。 在 Spring AOP中，切面可以用普通类基于 schema 的方式或者以 <span class="citation"data-cites="Aspect">@Aspect</span> 注解来实现。</p><p>它是通知（Advice）和切点（Pointcut）合起来的抽象，它定义了一个切点（Pointcut）用来匹配连接点（Joinpoint），也就是需要对需要拦截的那些方法进行定义；它定义了一系列的通知（Advice）用来对拦截到的方法进行增强。</p><h4 id="连接点join-point">1.2 连接点（Join point）</h4><p>在程序执行过程中某个特定的点，例如某个方法调用的时间点或者处理异常的时间点。在SpringAOP中，一个连接点总是代表一个方法的执行。</p><p>org.aspectj.lang.JoinPoint接口表示目标类连接点对象，它定义这些主要方法。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220809212859.png" /></p><p>org.aspectj.lang.ProceedingJoinPoint 继承了 JoinPoint接口，该对象只用在 <span class="citation"data-cites="Around">@Around</span> 的切面方法中,添加了以下两个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行目标方法</span><br><span class="hljs-function">Object <span class="hljs-title">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span><br><span class="hljs-function"> <span class="hljs-comment">// 传入的新的参数去执行目标方法 </span></span><br><span class="hljs-function">Object <span class="hljs-title">proceed</span><span class="hljs-params">(Object[] var1)</span> <span class="hljs-keyword">throws</span> Throwable</span><br></code></pre></td></tr></table></figure><h4 id="通知advice">1.3 通知（Advice）</h4><p>在切面的某个特定的连接点上执行的动作。许多 AOP 框架，包括 Spring在内，都是以拦截器做通知模型的，并维护着一个以连接点为中心的拦截器链。</p><p>Spring AOP 包含以下类型的通知： + 前置通知（Before advice）:在连接点之前运行但无法阻止执行流程进入连接点的通知（除非它引发异常）。 +后置返回通知（After returningadvice）:在连接点正常完成后执行的通知（例如，当方法没有抛出任何异常并正常返回时）。+ 后置异常通知（After throwing advice）:在方法抛出异常退出时执行的通知。 + 后置通知（总会执行）（After (finally)advice）: 当连接点退出的时候执行的通知（无论是正常返回还是异常退出）。 +环绕通知（AroundAdvice）:环绕连接点的通知，例如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它可以选择是否继续执行连接点或直接返回自定义的返回值又或抛出异常将执行结束。</p><p>通知方法的执行顺序： 1、正常执行：<span class="citation"data-cites="Before">@Before</span>---&gt;<span class="citation"data-cites="After">@After</span>---&gt;<span class="citation"data-cites="AfterReturning">@AfterReturning</span> 2、异常执行：<spanclass="citation" data-cites="Before">@Before</span>---&gt;<spanclass="citation" data-cites="After">@After</span>---&gt;<spanclass="citation" data-cites="AfterThrowing">@AfterThrowing</span></p><p><strong><font color="red">Spring 在 5.2.7 之后就改变的advice 的执行顺序。</font></strong> 1、正常执行：<span class="citation"data-cites="Before">@Before</span>---&gt;<span class="citation"data-cites="AfterReturning">@AfterReturning</span>---&gt;<spanclass="citation" data-cites="After">@After</span> 2、异常执行：<spanclass="citation" data-cites="Before">@Before</span>---&gt;<spanclass="citation"data-cites="AfterThrowing">@AfterThrowing</span>---&gt;<spanclass="citation" data-cites="After">@After</span></p><h4 id="切点pointcut">1.4 切点（Pointcut）</h4><p>匹配连接点的断言。通知和切点表达式相关联，并在满足这个切点的连接点上运行（例如当执行某个特定名称的方法时）。切点表达式如何和连接点匹配是AOP 的核心，Spring 默认使用 AspectJ 切点语义。</p><p>Spring AOP 支持使用以下 AspectJ 切点标识符(PCD)，用于切点表达式： +execution：用于匹配<strong>方法</strong>执行连接点。 +within: 限制匹配<strong>类</strong>中的连接点。 +this:  匹配代理对象实现了某个接口的连接点。 +target: 匹配目标对象实现了某个接口的连接点。 +args: 限制与连接点的匹配，其中变量是给定类型的实例。 + <spanclass="citation"data-cites="target">@target</span>: 限制与连接点的匹配，其中执行对象的类具有给定类型的注解。+ <span class="citation"data-cites="args">@args</span>: 限制匹配连接点，其中传递的实际参数的运行时类型具有给定类型的注解。+ <span class="citation"data-cites="within">@within</span>: 限制与具有给定注解的类型中的连接点匹配。+ <span class="citation"data-cites="annotation:限制匹配连接点">@annotation:限制匹配连接点</span>（在Spring AOP中执行的方法具有给定的注解）。</p><p>表达式语法：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220809224055.png" /></p><p>除返回类型模式（ret-type-pattern）以外的所有部件、名称模式和参数模式都是可选的。通常，可以使用 *作为返回类型模式，它匹配任何返回类型。只有当方法返回给定类型时，完全限定的类型名称才会匹配。名称模式与方法名称匹配，可以将* 通配符用作名称模式的全部或部分。 如果指定声明类型模式，则需要有后缀<strong>.</strong> 将其加入到名称模式组件中。参数模式稍微复杂一点。()匹配没有参数的方法。(..) 匹配任意个数的参数（0个或多个）。 (*)匹配任何类型的单个参数。(*,String)匹配有两个参数而且第一个参数是任意类型，第二个必须是 String 的方法。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220809224141.png" /></p><ol type="1"><li>within 表达式 通过类名进行匹配，粗粒度的切入点表达式。 在 within表达式中可以使用 * 号通配符，例如匹配指定包下所有的类：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;within(cn.tulingxueyuan.service.*)&quot;</span></span><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>execution 表达式细粒度的切入点表达式，可以以方法为单位定义切入点规则</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* cn.tulingxueyuan.service.*.query())&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc1&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>合并切点表达式 可以使用 &amp;&amp;, || 和 !等符号进行合并操作。也可以通过名字来指向切点表达式。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;execution(public * *(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">anyPublicOperation</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><span class="hljs-meta">@Pointcut(&quot;within(com.xyz.someapp.trading..*)&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inTrading</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><span class="hljs-meta">@Pointcut(&quot;anyPublicOperation() &amp;&amp; inTrading()&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tradingOperation</span><span class="hljs-params">()</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="引入introduction">1.5 引入（Introduction）</h4><p>声明额外的方法或者某个类型的字段。Spring允许引入新的接口（以及一个对应的实现）到任何被通知的对象上。例如，可以使用引入来使bean 实现 IsModified 接口， 以便简化缓存机制（在 AspectJ社区，引入也被称为内部类型声明（inter））。</p><p><span class="citation"data-cites="DeclareParents">@DeclareParents</span>https://blog.csdn.net/swh1234567/article/details/116454743</p><h4 id="目标对象target-object">1.6 目标对象（Target object）</h4><p>被一个或者多个切面所通知的对象。也被称作被通知（advised）对象。既然Spring AOP是通过运行时代理实现的，那么这个对象永远是一个被代理（proxied）的对象。</p><h4 id="aop代理aop-proxy">1.7 AOP代理（AOP proxy）</h4><p>AOP 框架创建的对象，用来实现切面契约（aspectcontract）（包括通知方法执行等功能）。在 Spring 中，AOP 代理可以是 JDK动态代理或 CGLIB 代理。</p><h4 id="织入weaving">1.8 织入（Weaving）</h4><p>把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象的过程。这个过程可以在编译时（例如使用AspectJ 编译器）、类加载时或运行时中完成。 Spring 和其他纯 Java AOP框架一样，是在运行时完成织入的。</p><p>一个连接点可以同时匹配多个切点，而切点所对应的增强在连接点上织入顺序的规则是这样的：①如果在同一个切面类中声明的增强，则按照增强在切面类中定义的顺序进行织入；②如果增强位于不同的切面类中，并且这些切面类都实现了org.springframework.core.Ordered接口，则由 Ordered 方法的顺序号决定(顺序号小的先织入)；③如果增强位于不同的切面类中，但这些切面类没有实现org.springframework.core.Ordered接口，织入的顺序是不确定的。</p><p>两个切面类 A 与 B，都实现了 Ordered 接口，A 的顺序号为 1，B的顺序号为 2。切面类 A 与 B 都定义了 3 个增强，那么同时匹配这 6个增强的织入顺序如下图所示：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220809220528.png" /></p><h3 id="基于aspectj的aop支持">2. 基于@AspectJ的AOP支持</h3><p>添加依赖 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></p><h4 id="启用aspectj支持">2.1 启用@AspectJ支持</h4><ol type="1"><li>使用 Java <span class="citation"data-cites="Configuration">@Configuration</span> 启用 <spanclass="citation" data-cites="AspectJ">@AspectJ</span> 支持</li></ol><p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br><br>&#125;<br><br></code></pre></td></tr></table></figure>   2. 使用 XML 配置启用 <span class="citation"data-cites="AspectJ">@AspectJ</span> 支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="声明切面">2.2 声明切面</h4><p>启用了 <span class="citation" data-cites="AspectJ">@AspectJ</span>支持后，在应用程序上下文中定义的 有 <span class="citation"data-cites="Aspect">@Aspect</span> 注解的 bean 都将被 Spring自动检测用于配置 Spring AOP。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugAspect</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="声明切点">2.3 声明切点</h4><p>切点决定了匹配的连接点，从而能够控制通知何时执行。Spring AOP只支持使用 Spring bean 的方法执行连接点，所以可以将切点看做是匹配 Springbean 上方法的执行。切点的声明包含两个部分：包含名称和任意参数的签名，以及明确需要匹配的方式执行的切点表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* com.zth.debugSpring.service..*(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>表达式的抽取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;execution(* com.zth.debugSpring.service..*(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">allService</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br><span class="hljs-meta">@Before(&quot;allService()&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="声明通知">2.4 声明通知</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugAspect</span> </span>&#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.zth.debugSpring.service.UserService.getUser(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">allService</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 前置通知</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Before(&quot;allService()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;before 执行&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 后置返回通知</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@AfterReturning(pointcut = &quot;allService()&quot;, returning = &quot;revalue&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturning</span><span class="hljs-params">(Object revalue)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;AfterReturning,返回值：&quot;</span> + revalue);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 后置异常通知</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@AfterThrowing(pointcut = &quot;allService()&quot;, throwing = &quot;ex&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">(Exception ex)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;afterThrowing,返回异常：&quot;</span> + ex);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 后置通知(总会执行)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@After(&quot;allService()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">After</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;After 执行&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用 <span class="hljs-doctag">@Around</span>注解来定义环绕通知，第一个参数必须是 ProceedingJoinPoint类型的。</span><br><span class="hljs-comment">     * 在通知中调用 ProceedingJoinPoint中的 proceed()方法来引用执行的方法。</span><br><span class="hljs-comment">     * proceed 方法也可以被调用传递数组对象- 数组的值将会被当作参数在方法执行时被使用。</span><br><span class="hljs-comment">     * proceed 方法也可以传入 Object[]。 数组中的值在进行时用作方法执行的参数。</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Around(&quot;allService()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Around before&quot;</span>);<br>        pjp.proceed();<br>        System.out.println(<span class="hljs-string">&quot;Around after&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="通知的参数">通知的参数</h5><p>任何通知方法都可以声明一个类型为 org.aspectj.lang.JoinPoint的参数作为其第一个参数（注意，需要使用 ProceedingJoinPoint 来声明 aroundadvice 的第一个参数，它是JoinPoint的一个子类）。JoinPoint接口提供很多有用的方法：:</p><ul><li>getArgs(): 返回方法参数.</li><li>getThis(): 返回代理对象.</li><li>getTarget(): 返回目标对象.</li><li>getSignature():返回正在通知的方法的描述.</li><li>toString(): 打印方法被通知的有用描述.</li></ul><h5 id="传递参数给通知">传递参数给通知</h5><p>上面已经看到了如何绑定返回的值或异常值（在返回之后和抛出通知之后使用）。为了在通知代码段中使用参数值，可以使用绑定args 的形式。如果在参数表达式中使用参数名代替类型名称，则在调用通知时，要将相关的参数值当作参数传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* com.zth.debugSpring.service.UserService.getUser(..)) &amp;&amp; args(userId)&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testArgs</span><span class="hljs-params">(Integer userId)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Before 执行,args:&quot;</span>+userId);<br>&#125;<br><br><span class="hljs-meta">@Pointcut(&quot;execution(* com.zth.debugSpring.service.UserService.getUser(..)) &amp;&amp; args(userId)&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">argsPointcut</span><span class="hljs-params">(Integer userId)</span></span>&#123;<br><br>&#125;<br><span class="hljs-meta">@Before(value = &quot;argsPointcut(userId)&quot;, argNames = &quot;userId&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testArgs2</span><span class="hljs-params">(Integer userId)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Before 执行,args:&quot;</span>+userId);<br>&#125;<br></code></pre></td></tr></table></figure><p>代理对象( this)，目标对象 ( target)和注解 ( <span class="citation"data-cites="within">@within</span>, <span class="citation"data-cites="target">@target</span>, <span class="citation"data-cites="annotation">@annotation</span>, and <span class="citation"data-cites="args">@args</span>)都可以以类似的方式绑定。</p><h5 id="声明参数的名字">声明参数的名字</h5><p>参数在通知中的绑定依赖于名字匹配，重点在切点表达式中定义的参数名的方法签名上（通知和切点）。</p><ul><li>如果用户已明确指定参数名称，则使用指定的参数名称。通知和切点注解都有一个可选的argNames属性，您可以使用该属性指定带注解的方法的参数名称。这些参数名称在运行时可用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(value=&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)&quot;,</span><br><span class="hljs-meta">        argNames=&quot;bean,auditable&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">audit</span><span class="hljs-params">(Object bean, Auditable auditable)</span> </span>&#123;<br>    AuditCode code = auditable.value();<br>    <span class="hljs-comment">// ... use code and bean</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用'argNames'属性有点笨拙，所以如果没有指定'argNames'属性，SpringAOP会查看该类的调试信息，并尝试从局部变量表中确定参数名称。</li><li>如果代码是在没有必要的调试信息的情况下编译的，那么SpringAOP将尝试推断绑定变量与参数的配对（例如，如果在切点表达式中只绑定了一个变量，并且该通知方法只需要一个参数，此时两者匹配是明显的）。如果给定了可用信息，变量的绑定是不明确的话，则会引发AmbiguousBindingException 异常。</li><li>如果上述所有策略都失败，则抛出 IllegalArgumentException 异常。</li></ul><h4 id="引入">2.5 引入</h4><p>引入（作为 AspectJ中内部类型的声明）允许切面定义通知的对象实现给定的接口，并代表这些对象提供该接口的实现.。</p><p>引入使用 <span class="citation"data-cites="DeclareParents">@DeclareParents</span>注解来定义，这个注解用于声明匹配拥有新的父类的类型。例如， 给定名为UsageTracked 的接口和名为 DefaultUsageTracked的接口的实现，以下切面声明服务接口的所有实现者也实现 UsageTracked接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsageTracking</span> </span>&#123;<br><br>    <span class="hljs-meta">@DeclareParents(value=&quot;com.xzy.myapp.service.*+&quot;, defaultImpl=DefaultUsageTracked.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UsageTracked mixin;<br><br>    <span class="hljs-meta">@Before(&quot;com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recordUsage</span><span class="hljs-params">(UsageTracked usageTracked)</span> </span>&#123;<br>        usageTracked.incrementUseCount();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>要实现的接口由注解属性的类型来确定。 <span class="citation"data-cites="DeclareParents注解的value值是AspectJ类型模式引过来的">@DeclareParents注解的value值是AspectJ类型模式引过来的</span>。服务bean 可以直接作为 UsageTracked 接口的实现，等同于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">UsageTracked usageTracked = (UsageTracked) context.getBean(<span class="hljs-string">&quot;myService&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="基于schema的aop支持">3. 基于Schema的AOP支持</h3><p>在 Spring 配置中，所有 aspect 和 advisor 元素必须放在&lt;aop:config&gt; 元素中（在应用程序上下文配置中可以有多个&lt;aop:config&gt;元素）。 &lt;aop:config&gt;元素可以包含切点，通知者和切面元素。</p><h4 id="声明切面-1">3.1 声明切面</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;debugAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.DebugAspect&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;debugAspect&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="声明切点-1">3.2 声明切点</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userPointCut&quot;</span></span><br><span class="hljs-tag">                          <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.zth.debugSpring.service.UserService.getUser(..))&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="声明通知-1">3.3 声明通知</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;debugAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.DebugAspect&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userPointCut&quot;</span></span><br><span class="hljs-tag">                  <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.zth.debugSpring.service.UserService.getUser(..))&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;debugAspect&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--前置通知--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;userPointCut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;debugBefore&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--后置返回通知--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-returning</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;userPointCut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;debugAfterReturning&quot;</span> <span class="hljs-attr">returning</span>=<span class="hljs-string">&quot;revalue&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--后置异常通知--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-throwing</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;userPointCut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;debugAfterThrowing&quot;</span> <span class="hljs-attr">throwing</span>=<span class="hljs-string">&quot;ex&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--后置通知(总会执行的)--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;userPointCut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;debugAfter&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--环绕通知--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:around</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;userPointCut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;debugAround&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugAspect</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugBefore</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;before 执行&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugAfterReturning</span><span class="hljs-params">(Object revalue)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;AfterReturning,返回值：&quot;</span> + revalue);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugAfterThrowing</span><span class="hljs-params">(Exception ex)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;afterThrowing,返回异常：&quot;</span> + ex);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugAfter</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;After 执行&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugAround</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Around before&quot;</span>);<br>        pjp.proceed();<br>        System.out.println(<span class="hljs-string">&quot;Around after&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通知参数</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;debugAspect&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userPointCut&quot;</span></span><br><span class="hljs-tag">                      <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.zth.debugSpring.service.UserService.getUser(Integer)) and args(userId)&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;userPointCut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;debugArgs&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugArgs</span><span class="hljs-params">(Integer userId)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;debugArgs userId:&quot;</span>+userId);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="引入-1">3.4 引入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;aop:aspect id=<span class="hljs-string">&quot;usageTrackerAspect&quot;</span> ref=<span class="hljs-string">&quot;usageTracking&quot;</span>&gt;<br><br>    &lt;aop:declare-parents<br>        types-matching=<span class="hljs-string">&quot;com.xzy.myapp.service.*+&quot;</span><br>        implement-<span class="hljs-class"><span class="hljs-keyword">interface</span></span>=<span class="hljs-string">&quot;com.xyz.myapp.service.tracking.UsageTracked&quot;</span><br>        <span class="hljs-keyword">default</span>-impl=<span class="hljs-string">&quot;com.xyz.myapp.service.tracking.DefaultUsageTracked&quot;</span>/&gt;<br><br>    &lt;aop:before<br>        pointcut=<span class="hljs-string">&quot;com.xyz.myapp.SystemArchitecture.businessService()</span><br><span class="hljs-string">            and this(usageTracked)&quot;</span><br>            method=<span class="hljs-string">&quot;recordUsage&quot;</span>/&gt;<br><br>&lt;/aop:aspect&gt;<br></code></pre></td></tr></table></figure><p>然后，支持usageTrackingbean的类将包含以下方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recordUsage</span><span class="hljs-params">(UsageTracked usageTracked)</span> </span>&#123;<br>    usageTracked.incrementUseCount();<br>&#125;<br><br><br>UsageTracked usageTracked = (UsageTracked) context.getBean(<span class="hljs-string">&quot;myService&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——整合Mybatis源码解析</title>
    <link href="/2022/07/30/Spring%E2%80%94%E2%80%94%E6%95%B4%E5%90%88Mybatis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/07/30/Spring%E2%80%94%E2%80%94%E6%95%B4%E5%90%88Mybatis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>https://www.processon.com/view/link/62e7f4367d9c08072e703b21</p><h3 id="整合核心思路">1. 整合核心思路</h3><p>第三方框架和 Spring进行整合的核心思想就是把第三方框架所产生的对象放到 Spring容器中，让其成为 Bean。</p><p>比如 Mybatis，Mybatis 框架可以单独使用，而单独使用 Mybatis框架就需要用到 Mybatis所提供的一些类构造出对应的对象，然后使用该对象，就能使用到 Mybatis框架给我们提供的功能。Spring 整合 Mybatis 就是为了将这些对象放入Spring容器中成为 Bean，只要成为了 Bean，在 Spring中就能很方便的使用这些对象了，也就能很方便的使用 Mybatis框架所提供的功能了。</p><h3 id="mybatis-spring-1.3.2-版本底层源码执行流程">2. Mybatis-Spring1.3.2 版本底层源码执行流程</h3><ol type="1"><li><p>通过 <span class="citation"data-cites="MapperScan">@MapperScan</span> 导入了 MapperScannerRegistrar类</p></li><li><p>MapperScannerRegistrar 类实现了 ImportBeanDefinitionRegistrar接口，所以 Spring 在启动时会调用 MapperScannerRegistrar 类中的registerBeanDefinitions 方法</p></li><li><p>在registerBeanDefinitions 方法中定义了一个 ClassPathMapperScanner对象，用来扫描 mapper</p></li><li><p>设置 ClassPathMapperScanner 对象可以扫描到接口，因为在 Spring中是不会扫描接口的</p></li><li><p>同时因为 ClassPathMapperScanner 中重写了 isCandidateComponent方法，导致 isCandidateComponent 只会认为接口是备选者 Component</p></li><li><p>通过利用 Spring 的扫描后，会把接口扫描出来并且得到对应的BeanDefinition</p></li><li><p>接下来把扫描得到的 BeanDefinition 进行修改，把 BeanClass 修改为MapperFactoryBean，把 AutowireMode 修改为 byType</p></li><li><p>扫描完成后，Spring 就会基于 BeanDefinition 去创建 Bean了，相当于每个 Mapper 对应一个 FactoryBean</p></li><li><p>在 MapperFactoryBean 中的 getObject 方法中，调用了getSqlSession() 去得到一个 sqlSession 对象，然后根据对应的 Mapper接口生成一个 Mapper 接口代理对象，这个代理对象就成为 Spring 容器中的Bean <imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220731211441.png" /></p></li><li><p>sqlSession 对象是 Mybatis 中的，一个 sqlSession 对象需要SqlSessionFactory 来产生</p></li><li><p>MapperFactoryBean 的 AutowireMode 为 byType，所以 Spring会自动调用 set 方法，有两个 set 方法，一个 setSqlSessionFactory，一个setSqlSessionTemplate，而这两个方法执行的前提是根据方法参数类型能找到对应的bean，所以 Spring 容器中要存在 SqlSessionFactory 类型的 bean 或者SqlSessionTemplate 类型的 bean。</p></li><li><p>如果你定义的是一个 SqlSessionFactory 类型的bean，那么最终也会被包装为一个 SqlSessionTemplate 对象，并且赋值给sqlSession 属性（SqlSessionTemplate 中包含 SqlSession 的代理对象）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SqlSessionTemplate</span><span class="hljs-params">(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span></span><br><span class="hljs-params"><span class="hljs-function">    PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;<br><br>  notNull(sqlSessionFactory, <span class="hljs-string">&quot;Property &#x27;sqlSessionFactory&#x27; is required&quot;</span>);<br>  notNull(executorType, <span class="hljs-string">&quot;Property &#x27;executorType&#x27; is required&quot;</span>);<br><br>  <span class="hljs-keyword">this</span>.sqlSessionFactory = sqlSessionFactory;<br>  <span class="hljs-keyword">this</span>.executorType = executorType;<br>  <span class="hljs-keyword">this</span>.exceptionTranslator = exceptionTranslator;<br>  <span class="hljs-keyword">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(<br>      SqlSessionFactory.class.getClassLoader(),<br>      <span class="hljs-keyword">new</span> Class[] &#123; SqlSession.class &#125;,<br>      <span class="hljs-keyword">new</span> SqlSessionInterceptor());<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>而在 SqlSessionTemplate 类中就存在一个 getMapper方法，这个方法中就产生一个 Mapper 接口代理对象</p></li><li><p>当执行该代理对象的某个方法时，就会进入到 Mybatis框架的底层执行流程。</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// org.mybatis.spring.SqlSessionTemplate#getMapper</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> getConfiguration().getMapper(type, <span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Configuration <span class="hljs-title">getConfiguration</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sqlSessionFactory.getConfiguration();<br>&#125;<br><br><span class="hljs-comment">// org.apache.ibatis.session.Configuration#getMapper</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.mapperRegistry.getMapper(type, sqlSession);<br>&#125;<br><br><span class="hljs-comment">// org.apache.ibatis.binding.MapperRegistry#getMapper</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;<br>    MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory) <span class="hljs-keyword">this</span>.knownMappers.get(type);<br>    <span class="hljs-keyword">if</span> (mapperProxyFactory == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">&quot;Type &quot;</span> + type + <span class="hljs-string">&quot; is not known to the MapperRegistry.&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> mapperProxyFactory.newInstance(sqlSession);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception var5) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">&quot;Error getting mapper instance. Cause: &quot;</span> + var5, var5);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// org.apache.ibatis.binding.MapperProxyFactory#newInstance(org.apache.ibatis.binding.MapperProxy&lt;T&gt;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">newInstance</span><span class="hljs-params">(SqlSession sqlSession)</span> </span>&#123;<br>    MapperProxy&lt;T&gt; mapperProxy = <span class="hljs-keyword">new</span> MapperProxy(sqlSession, <span class="hljs-keyword">this</span>.mapperInterface, <span class="hljs-keyword">this</span>.methodCache);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.newInstance(mapperProxy);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> T <span class="hljs-title">newInstance</span><span class="hljs-params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<span class="hljs-keyword">this</span>.mapperInterface.getClassLoader(), <span class="hljs-keyword">new</span> Class[]&#123;<span class="hljs-keyword">this</span>.mapperInterface&#125;, mapperProxy);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sqlsessiontemplate">SqlSessionTemplate</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220731221526.png" /></p><p>SqlSessionTemplate 含有一个 SqlSessionFactory工厂类，一个执行器类型（SqlSession 底层使用的 ExecutorType 类型），一个SqlSessionProxy JDK 生成的代理对象， 还有一个异常转换器。</p><p>SqlSessionTemplate 实现了 SqlSession 的所有方法，但内部全部委托了JDK代理的 SqlSessionProxy 来实现。</p><p>SqlSessionTemplate 有一个拦截器内部类，该类就是创建 JDK动态代理时的那个拦截类， 我们看看该类的 invoke 方法实现：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlSessionInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    <span class="hljs-comment">// 拿到 DefaultSqlSession</span><br>        SqlSession sqlSession = getSqlSession(<br>                SqlSessionTemplate.<span class="hljs-keyword">this</span>.sqlSessionFactory,<br>                SqlSessionTemplate.<span class="hljs-keyword">this</span>.executorType,<br>                SqlSessionTemplate.<span class="hljs-keyword">this</span>.exceptionTranslator);<br>        <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 真正执行 sql</span><br>            Object result = method.invoke(sqlSession, args);<br>            <span class="hljs-keyword">if</span> (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.<span class="hljs-keyword">this</span>.sqlSessionFactory)) &#123;<br>                <span class="hljs-comment">// force commit even on non-dirty sessions because some databases require</span><br>                <span class="hljs-comment">// a commit/rollback before calling close()</span><br>                sqlSession.commit(<span class="hljs-keyword">true</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            Throwable unwrapped = unwrapThrowable(t);<br>            <span class="hljs-keyword">if</span> (SqlSessionTemplate.<span class="hljs-keyword">this</span>.exceptionTranslator != <span class="hljs-keyword">null</span> &amp;&amp; unwrapped <span class="hljs-keyword">instanceof</span> PersistenceException) &#123;<br>                <span class="hljs-comment">// release the connection to avoid a deadlock if the translator is no loaded. See issue #22</span><br>                closeSqlSession(sqlSession, SqlSessionTemplate.<span class="hljs-keyword">this</span>.sqlSessionFactory);<br>                sqlSession = <span class="hljs-keyword">null</span>;<br>                Throwable translated = SqlSessionTemplate.<span class="hljs-keyword">this</span>.exceptionTranslator.translateExceptionIfPossible((PersistenceException) unwrapped);<br>                <span class="hljs-keyword">if</span> (translated != <span class="hljs-keyword">null</span>) &#123;<br>                    unwrapped = translated;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">throw</span> unwrapped;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (sqlSession != <span class="hljs-keyword">null</span>) &#123;<br>                closeSqlSession(sqlSession, SqlSessionTemplate.<span class="hljs-keyword">this</span>.sqlSessionFactory);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>首先调用 SqlSessionUtils 的静态方法 getSqlSession 获取 SqlSession对象， 然后调用 SqlSession 的响应方法， 检测事务是否由 Spring管理，并根据此结果决定是否提交事务。 最后，返回结果，并在 finally块中清除 Session（将 Connection 赋值为 null）。</p><p>也就是说，在执行 SqlSession 的 SelectOne之类的方法的时候，都会经过该类。每条 SQL的事务也都是在这里进行处理（如果 Spring 没有管理的话）。</p><p>SqlSessionTemplate.selectOne() ---&gt;SqlSession.selectOne()--&gt;DefaultSqlSession.selectOne()</p><p>SqlSessionTemplate 是线程安全的，而 DefaultSqlSession 不是。</p><p>SqlSessionTemplate 判断当前线程在 ThreadLocal 中有没有DefaultSqlSession,如果有直接使用，如果没有则创建，从而保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getSqlSession</span><span class="hljs-params">(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;<br>    <br>    <span class="hljs-comment">// 先从缓存（ThreadLocal）中获取 sqlSession,</span><br>    SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);<br>    SqlSession session = sessionHolder(executorType, holder);<br>    <span class="hljs-keyword">if</span> (session != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> session;<br>    &#125;<br>    <span class="hljs-comment">// 缓存中没有则重新生成</span><br>    session = sessionFactory.openSession(executorType);<br>    <span class="hljs-comment">// 加入缓存</span><br>    registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);<br>    <span class="hljs-keyword">return</span> session;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerSessionHolder</span><span class="hljs-params">(SqlSessionFactory sessionFactory, ExecutorType executorType,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          PersistenceExceptionTranslator exceptionTranslator, SqlSession session)</span> </span>&#123;<br>    SqlSessionHolder holder;<br>    <span class="hljs-comment">// 如果开启了事务加入缓存</span><br>    <span class="hljs-comment">// 如果没有开启事务则不加入，导致每次拿到的是新的 sqlSession,导致了 spring 整合 mybatis 以及缓存失效</span><br>    <span class="hljs-keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;<br>        Environment environment = sessionFactory.getConfiguration().getEnvironment();<br><br>        <span class="hljs-keyword">if</span> (environment.getTransactionFactory() <span class="hljs-keyword">instanceof</span> SpringManagedTransactionFactory) &#123;<br>            holder = <span class="hljs-keyword">new</span> SqlSessionHolder(session, executorType, exceptionTranslator);<br>            TransactionSynchronizationManager.bindResource(sessionFactory, holder);<br>            TransactionSynchronizationManager.registerSynchronization(<span class="hljs-keyword">new</span> SqlSessionUtils.SqlSessionSynchronization(holder, sessionFactory));<br>            holder.setSynchronizedWithTransaction(<span class="hljs-keyword">true</span>);<br>            holder.requested();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (TransactionSynchronizationManager.getResource(environment.getDataSource()) == <span class="hljs-keyword">null</span>) &#123;<br>              <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TransientDataAccessResourceException(<br>                        <span class="hljs-string">&quot;SqlSessionFactory must be using a SpringManagedTransactionFactory in order to use Spring transaction synchronization&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (LOGGER.isDebugEnabled()) &#123;<br>            LOGGER.debug(<span class="hljs-string">&quot;SqlSession [&quot;</span> + session + <span class="hljs-string">&quot;] was not registered for synchronization because synchronization is not active&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="mybatis-spring-2.0.6-版本底层源码执行流程">3. Mybatis-Spring2.0.6 版本底层源码执行流程</h3><ol type="1"><li>通过 <span class="citation"data-cites="MapperScan">@MapperScan</span> 导入了 MapperScannerRegistrar类</li><li>MapperScannerRegistrar 类实现了 ImportBeanDefinitionRegistrar接口，所以 Spring 在启动时会调用 MapperScannerRegistrar 类中的registerBeanDefinitions 方法</li><li><strong>在 registerBeanDefinitions 方法中注册一个MapperScannerConfigurer 类型的 BeanDefinition</strong></li><li>而 MapperScannerConfigurer 实现了BeanDefinitionRegistryPostProcessor 接口，所以 Spring在启动过程中时会调用它的 postProcessBeanDefinitionRegistry() 方法</li><li>在 postProcessBeanDefinitionRegistry 方法中会生成一个ClassPathMapperScanner 对象，然后进行扫描</li><li>后续逻辑和 1.3.2 版本一样。</li></ol><p>带来的好处是，可以不使用 <span class="citation"data-cites="MapperScan">@MapperScan</span>注解，而可以直接定义一个Bean，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> MapperScannerConfigurer <span class="hljs-title">mapperScannerConfigurer</span><span class="hljs-params">()</span></span>&#123;<br>    MapperScannerConfigurer configurer = <span class="hljs-keyword">new</span> MapperScannerConfigurer();<br>    configurer.setBasePackage(<span class="hljs-string">&quot;com.zth.debuggingSpring&quot;</span>);<br>    <span class="hljs-keyword">return</span> configurer;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="spring-整合-mybatis-后一级缓存失效问题">4. Spring 整合 Mybatis后一级缓存失效问题</h3><p>Mybatis 中的一级缓存是基于 SqlSession 来实现的，所以在执行同一个 sql时，如果使用的是同一个 SqlSession 对象，那么就能利用到一级缓存，提高 sql的执行效率。</p><p>但是在 Spring 整合 Mybatis 后，在执行某个方法时，该方法上没有加 <spanclass="citation" data-cites="Transactional">@Transactional</span>注解，也就是没有开启 Spring 事务，那么后面在执行具体 sql 时，每执行一个sql 时都会新生成一个 SqlSession 对象来执行该sql，这就是我们说的一级缓存失效（也就是没有使用同一个 SqlSession对象），而如果开启了 Spring 事务，那么该 Spring 事务中的多个sql，在执行时会使用同一个 SqlSession 对象，从而一级缓存生效。</p><p>个人理解：实际上 Spring 整合 Mybatis后一级缓存失效并<strong>不是问题</strong>，是正常的实现，因为，一个方法如果没有开启Spring 事务，那么在执行 sql 时候，那就是每个 sql单独一个事务来执行，也就是单独一个 SqlSession 对象来执行该sql，如果开启了 Spring 事务，那就是多个 sql属于同一个事务，那自然就应该用一个 SqlSession 来执行这多个sql。所以，在没有开启 Spring 事务的时候，SqlSession的一级缓存并不是<strong>失效</strong>了，而是存在的生命周期太短了（执行完一个sql 后就被销毁了，下一个 sql 执行时又是一个新的 SqlSession 了）。</p><h3 id="spring-整合-mybatis-之后-sql-执行流程">5. Spring 整合 Mybatis之后 SQL 执行流程：</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220731204002.png" /></p><p><ahref="https://www.processon.com/view/link/6152cc385653bb6791db436c">https://www.processon.com/view/link/6152cc385653bb6791db436c</a></p><h3 id="事务相关">6. 事务相关</h3><p>开启事务，由事务管理器建立数据库连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// protected Transaction transaction;</span><br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(Log statementLog)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>  Connection connection = transaction.getConnection();<br>  <span class="hljs-keyword">if</span> (statementLog.isDebugEnabled()) &#123;<br>    <span class="hljs-keyword">return</span> ConnectionLogger.newInstance(connection, statementLog, queryStack);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> connection;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringManagedTransaction</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Transaction</span> </span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.connection == <span class="hljs-keyword">null</span>) &#123;<br>      openConnection();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.connection;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>    <span class="hljs-keyword">this</span>.connection = DataSourceUtils.getConnection(<span class="hljs-keyword">this</span>.dataSource);<br>    <span class="hljs-keyword">this</span>.autoCommit = <span class="hljs-keyword">this</span>.connection.getAutoCommit();<br>    <span class="hljs-keyword">this</span>.isConnectionTransactional = DataSourceUtils.isConnectionTransactional(<span class="hljs-keyword">this</span>.connection, <span class="hljs-keyword">this</span>.dataSource);<br><br>    LOGGER.debug(() -&gt; <span class="hljs-string">&quot;JDBC Connection [&quot;</span> + <span class="hljs-keyword">this</span>.connection + <span class="hljs-string">&quot;] will&quot;</span><br>        + (<span class="hljs-keyword">this</span>.isConnectionTransactional ? <span class="hljs-string">&quot; &quot;</span> : <span class="hljs-string">&quot; not &quot;</span>) + <span class="hljs-string">&quot;be managed by Spring&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【补充】https://www.jianshu.com/p/c2b2d6f90ba5</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——配置类解析源码解析</title>
    <link href="/2022/07/25/Spring%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E7%B1%BB%E8%A7%A3%E6%9E%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/07/25/Spring%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E7%B1%BB%E8%A7%A3%E6%9E%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>https://www.processon.com/view/link/62e0189b63768979df38f399</p><h3 id="解析配置类">1.解析配置类</h3><p>【注】上图以 Spring 5.2 为例</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220725195647.png" /></p><p>https://www.processon.com/view/link/5f9512d5e401fd06fda0b2dd</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220725201039.png" />https://www.processon.com/view/link/614c83cae0b34d7b342f6d14#map</p><ol type="1"><li>在启动 Spring 时，需要传入一个 AppConfig.class 给ApplicationContext，ApplicationContext 会根据 AppConfig类封装为一个BeanDefinition，这种BeanDefinition 称为配置类BeanDefinition。</li><li>ConfigurationClassPostProcessor 中会把配置类 BeanDefinition取出来</li><li>构造一个 ConfigurationClassParser 用来解析配置类BeanDefinition，并且会生成一个配置类对象 ConfigurationClass</li><li>如果配置类上存在 <span class="citation"data-cites="Component">@Component</span>注解，那么<strong>解析配置类中的内部类（递归，如果内部类也是配置类的话）</strong></li><li>如果配置类上存在 <span class="citation"data-cites="PropertySource">@PropertySource</span>注解，那么则解析该注解，并得到 PropertySource 对象，并添加到 environment中去 https://blog.csdn.net/qq_37312838/article/details/108237678</li><li>如果配置类上存在 <span class="citation"data-cites="ComponentScan">@ComponentScan</span>注解，那么则解析该注解，进行扫描，扫描得到一系列的 BeanDefinition对象，然后判断这些 BeanDefinition 是不是也是配置类BeanDefinition（只要存在 <span class="citation"data-cites="Component">@Component</span>注解就是配置类，所以基本上扫描出来的都是配置类），如果是则继续解析该配置类，<strong>（也有递归）</strong>，并且会生成对应的ConfigurationClass</li><li>如果配置类上存在 <span class="citation"data-cites="Import">@Import</span> 注解，那么则判断 Import 的类的类型：<ol type="1"><li>如果是 ImportSelector，那么调用执行 selectImports方法得到类名，然后在把这个类当做配置类进行解析<strong>（也是递归）</strong></li><li>如果是 ImportBeanDefinitionRegistrar，那么则生成一个ImportBeanDefinitionRegistrar实例对象，并添加到配置类对象中（ConfigurationClass）的<strong>importBeanDefinitionRegistrars</strong> 属性中。</li></ol></li><li>如果配置类上存在 <span class="citation"data-cites="ImportResource">@ImportResource</span>注解，那么则把导入进来的资源路径存在配置类对象中的<strong>importedResources</strong> 属性中。</li><li>如果配置类中存在 <span class="citation"data-cites="Bean">@Bean</span> 的方法，那么则把这些方法封装为 BeanMethod对象，并添加到配置类对象中的 <strong>beanMethods</strong> 属性中。</li><li>如果配置类实现了某些接口，则看这些接口内是否定义了 <spanclass="citation" data-cites="Bean">@Bean</span> 的默认方法</li><li>如果配置类有父类，则把父类当做配置类进行解析</li><li>AppConfig 这个配置类会对应一个ConfigurationClass，同时在解析的过程中也会生成另外的一些ConfigurationClass，接下来就利用 reader 来进一步解析 ConfigurationClass<ol type="1"><li>如果 ConfigurationClass 是通过 <span class="citation"data-cites="Import">@Import</span> 注解导入进来的，则把这个类生成一个BeanDefinition，同时解析这个类上 <span class="citation"data-cites="Scope">@Scope</span>,<span class="citation"data-cites="Lazy">@Lazy</span> 等注解信息，并注册 BeanDefinition</li><li>如果 ConfigurationClass 中存在一些 BeanMethod，也就是定义了一些<span class="citation" data-cites="Bean">@Bean</span>，那么则解析这些<span class="citation" data-cites="Bean">@Bean</span>，并生成对应的BeanDefinition，并注册</li><li>如果 ConfigurationClass 中导入了一些资源文件，比如xx.xml，那么则解析这些 xx.xml 文件，得到并注册 BeanDefinition</li><li>如果 ConfigurationClass 中导入了一些ImportBeanDefinitionRegistrar，那么则执行对应的 registerBeanDefinitions进行 BeanDefinition 的注册</li></ol></li></ol><p><strong>总结：</strong></p><ol type="1"><li>解析 AppConfig 类，生成对应的 ConfigurationClass</li><li>再扫描，扫描到的类都会生成对应的 BeanDefinition，并且同时这些类也是ConfigurationClass</li><li>再解析 ConfigurationClass 的其他信息，比如 <span class="citation"data-cites="ImportResource">@ImportResource</span> 注解的处理，<spanclass="citation" data-cites="Import">@Import</span> 注解的处理，<spanclass="citation" data-cites="Bean">@Bean</span> 注解的处理</li></ol><h3 id="beandefinition-覆盖">2. BeanDefinition 覆盖</h3><p>两个 <span class="citation" data-cites="Compont">@Compont</span>注解导入 BeanName 相同，则报错 两个 <span class="citation"data-cites="Bean">@Bean</span> 注解导入 BeanName相同，不会报错，但是只会生成一个BeanDefinition（依赖注入时会选择参数多的） <span class="citation"data-cites="Compont">@Compont</span> 和 <span class="citation"data-cites="Bean">@Bean</span> 两个 BeanName 相同时，<spanclass="citation" data-cites="Bean">@Bean</span> 覆盖 <spanclass="citation" data-cites="Compont">@Compont</span></p><h3 id="configuration-的-full-和-lite-模式">3. <span class="citation"data-cites="Configuration">@Configuration</span> 的 Full 和 Lite模式</h3><p>Full 模式会生成代理对象而 Lite 模式不会</p><p>https://blog.csdn.net/demon7552003/article/details/107988310</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——启动过程源码解析</title>
    <link href="/2022/07/13/Spring%E2%80%94%E2%80%94%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/07/13/Spring%E2%80%94%E2%80%94%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>https://www.processon.com/view/link/62e0189b63768979df38f399 ###1.概述</p><p>通常，我们说的 Spring 启动，就是构造 ApplicationContext 对象以及调用refresh() 方法的过程。</p><p>首先，Spring 启动过程主要做了这么几件事情：</p><ol type="1"><li>构造一个 BeanFactory 对象</li><li>解析配置类，得到 BeanDefinition，并注册到 BeanFactory 中<ul><li>解析 <span class="citation"data-cites="ComponentScan">@ComponentScan</span>，此时就会完成扫描</li><li>解析 <span class="citation" data-cites="Import">@Import</span></li><li>解析 <span class="citation" data-cites="Bean">@Bean</span></li><li>...</li></ul></li><li>因为 ApplicationContext 还支持国际化，所以还需要初始化 MessageSource对象</li><li>因为 ApplicationContext 还支持事件机制，所以还需要初始化ApplicationEventMulticaster 对象</li><li>把用户定义的 ApplicationListener 对象添加到 ApplicationContext中，等 Spring 启动完了就要发布事件了</li><li>创建<strong>非懒加载的单例</strong> Bean 对象，并存在 BeanFactory的单例池中。</li><li>调用 Lifecycle Bean 的 start() 方法</li><li>发布 <strong>ContextRefreshedEvent</strong> 事件</li></ol><p>由于 Spring 启动过程中要创建非懒加载的单例 Bean 对象，那么就需要用到BeanPostProcessor，所以 Spring 在启动过程中就需要做两件事：</p><ol type="1"><li>生成默认的 BeanPostProcessor 对象，并添加到 BeanFactory 中<ul><li>AutowiredAnnotationBeanPostProcessor：处理 <span class="citation"data-cites="Autowired">@Autowired</span>、<span class="citation"data-cites="Value">@Value</span></li><li>CommonAnnotationBeanPostProcessor：处理 <span class="citation"data-cites="Resource">@Resource</span>、<span class="citation"data-cites="PostConstruct">@PostConstruct</span>、<span class="citation"data-cites="PreDestroy">@PreDestroy</span></li><li>ApplicationContextAwareProcessor：处理 ApplicationContextAware等回调</li></ul></li><li>找到外部用户所定义的 BeanPostProcessor 对象（类型为BeanPostProcessor 的 Bean 对象），并添加到 BeanFactory 中</li></ol><h3 id="beanfactorypostprocessor">2. BeanFactoryPostProcessor</h3><p>BeanPostProcessor 表示 Bean 的后置处理器，是用来对 Bean进行加工的，类似的，BeanFactoryPostProcessor 理解为 BeanFactory的后置处理器，用来对 BeanFactory 进行加工的。</p><p>Spring 支持用户定义 BeanFactoryPostProcessor 的实现类 Bean，来对BeanFactory 进行加工，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>BeanDefinition beanDefinition = beanFactory.getBeanDefinition(<span class="hljs-string">&quot;userService&quot;</span>);<br>beanDefinition.setAutowireCandidate(<span class="hljs-keyword">false</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码，就利用了 BeanFactoryPostProcessor 来拿到BeanFactory，然后获取 BeanFactory 内的某个 BeanDefinition对象并进行修改，注意这一步是发生在 Spring 启动时，创建单例 Bean之前的，所以此时对 BeanDefinition 进行修改是会生效的。</p><p>注意：在 ApplicationContext 内部有一个核心的DefaultListableBeanFactory，它实现了 ConfigurableListableBeanFactory和BeanDefinitionRegistry 接口，所以 ApplicationContext 和DefaultListableBeanFactory 是可以注册 BeanDefinition 的，但是ConfigurableListableBeanFactory 是不能注册 BeanDefinition 的，只能获取BeanDefinition，然后做修改。</p><p>所以 Spring 还提供了一个 BeanFactoryPostProcessor的子接口：<strong>BeanDefinitionRegistryPostProcessor</strong></p><h3 id="beandefinitionregistrypostprocessor">3.BeanDefinitionRegistryPostProcessor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>BeanDefinitionRegistryPostProcessor 继承了 BeanFactoryPostProcessor接口，并新增了一个方法，注意方法的参数为BeanDefinitionRegistry，所以如果一个类实现了BeanDefinitionRegistryPostProcessor，那么在postProcessBeanDefinitionRegistry() 方法中就可以注册 BeanDefinition了。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugBeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();<br>beanDefinition.setBeanClass(User.class);<br>registry.registerBeanDefinition(<span class="hljs-string">&quot;user&quot;</span>, beanDefinition);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>BeanDefinition beanDefinition = beanFactory.getBeanDefinition(<span class="hljs-string">&quot;userService&quot;</span>);<br>beanDefinition.setAutowireCandidate(<span class="hljs-keyword">false</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="refresh-作用">4. refresh() 作用</h3><p>org.springframework.context.ConfigurableApplicationContext#refresh</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Load or refresh the persistent representation of the configuration,</span><br><span class="hljs-comment"> * which might an XML file, properties file, or relational database schema.</span><br><span class="hljs-comment"> * &lt;p&gt;As this is a startup method, it should destroy already created singletons</span><br><span class="hljs-comment"> * if it fails, to avoid dangling resources. In other words, after invocation</span><br><span class="hljs-comment"> * of that method, either all or no singletons at all should be instantiated.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> BeansException if the bean factory could not be initialized</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalStateException if already initialized and multiple refresh</span><br><span class="hljs-comment"> * attempts are not supported</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException</span>;<br></code></pre></td></tr></table></figure><p>翻译：加载或刷新持久化的配置，可能是XML文件、属性文件或关系数据库中存储的。由于这是一个启动方法，如果失败，它应该销毁已经创建的单例，以避免暂用资源。换句话说，在调用该方法之后，应该实例化所有的单例，或者根本不实例化单例 。</p><p><strong>ApplicationContext 关闭之后不代表 JVM也关闭了，ApplicationContext 是属于 JVM 的，说白了 ApplicationContext也是 JVM 中的一个对象。</strong></p><p>在 Spring 的设计中，也提供可以重复刷新的 ApplicationContext和不可以重复刷新的 ApplicationContext。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">AbstractRefreshableApplicationContext extends AbstractApplicationContext</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-keyword">if</span> (hasBeanFactory()) &#123;<br>destroyBeans();<br>closeBeanFactory();<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>DefaultListableBeanFactory beanFactory = createBeanFactory();<br>beanFactory.setSerializationId(getId());<br>customizeBeanFactory(beanFactory);<br>loadBeanDefinitions(beanFactory);<br><span class="hljs-keyword">this</span>.beanFactory = beanFactory;<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationContextException(<span class="hljs-string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就是可以重复刷新的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">GenericApplicationContext extends AbstractApplicationContext</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalStateException </span>&#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.refreshed.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<br><span class="hljs-string">&quot;GenericApplicationContext does not support multiple refresh attempts: just call &#x27;refresh&#x27; once&quot;</span>);<br>&#125;<br><span class="hljs-keyword">this</span>.beanFactory.setSerializationId(getId());<br>&#125;<br></code></pre></td></tr></table></figure><p>就是不可以重复刷新的。</p><p>AnnotationConfigApplicationContext 继承的是GenericApplicationContext，所以它是不能刷新的。AnnotationConfigWebApplicationContext 继承的是AbstractRefreshableWebApplicationContext，所以它是可以刷的。</p><p><strong>不能重复刷新是指只能调用一次 refresh方法，第二次时会报错。</strong></p><h3 id="refresh-底层原理流程">5. refresh() 底层原理流程</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220713220403.png" /></p><p>底层原理流程图：<ahref="https://www.processon.com/view/link/5f60a7d71e08531edf26a919">https://www.processon.com/view/link/5f60a7d71e08531edf26a919</a></p><p>下面以 AnnotationConfigApplicationContext 为例子，来介绍 refresh的底层原理。</p><ol type="1"><li>在调用 AnnotationConfigApplicationContext 的构造方法之前，会调用父类GenericApplicationContext 的无参构造方法，会构造一个BeanFactory，为<strong>DefaultListableBeanFactory</strong>。</li><li>构造 AnnotatedBeanDefinitionReader（<strong>主要作用添加一些基础的PostProcessor，同时可以通过 reader 进行BeanDefinition的注册</strong>），同时对 BeanFactory 进行设置和添加<strong>PostProcessor</strong>（后置处理器）<ol type="1"><li>设置 dependencyComparator：AnnotationAwareOrderComparator，它是一个Comparator，是用来进行排序的，会获取某个对象上的 <strong>Order注解</strong>或者通过实现 <strong>Ordered 接口</strong>所定义的值进行排序，在日常开发中可以利用这个类来进行排序。</li><li>设置autowireCandidateResolver：ContextAnnotationAutowireCandidateResolver，用来解析某个Bean 能不能进行自动注入，比如某个 Bean 的 autowireCandidate 属性是否等于true</li><li>向 BeanFactory 中添加<strong>ConfigurationClassPostProcessor</strong> 对应的BeanDefinition，它是一个 BeanDefinitionRegistryPostProcessor，并且实现了PriorityOrdered 接口</li><li>向 BeanFactory 中添加<strong>AutowiredAnnotationBeanPostProcessor</strong> 对应的BeanDefinition，它是一个InstantiationAwareBeanPostProcessorAdapter，MergedBeanDefinitionPostProcessor</li><li>向 BeanFactory 中添加 CommonAnnotationBeanPostProcessor 对应的BeanDefinition，它是一个InstantiationAwareBeanPostProcessor，InitDestroyAnnotationBeanPostProcessor</li><li>向 BeanFactory 中添加 EventListenerMethodProcessor 对应的BeanDefinition，它是一个BeanFactoryPostProcessor，SmartInitializingSingleton</li><li>向 BeanFactory 中添加 DefaultEventListenerFactory 对应的BeanDefinition，它是一个 EventListenerFactory</li></ol></li><li>构造ClassPathBeanDefinitionScanner（<strong>主要作用可以用来扫描得到并注册BeanDefinition</strong>），同时进行设置：<ol type="1"><li>设置 <strong>this.includeFilters =AnnotationTypeFilter(Component.class)</strong></li><li>设置 environment</li><li>设置 resourceLoader</li></ol></li><li>利用 reader 注册 AppConfig 为 BeanDefinition，类型为AnnotatedGenericBeanDefinition</li><li><strong>接下来就是调用 refresh 方法</strong></li><li>prepareRefresh()：<ol type="1"><li>记录启动时间</li><li>可以允许子容器设置一些内容到 Environment 中</li><li>验证 Environment 中是否包括了必须要有的属性</li></ol></li><li>obtainFreshBeanFactory()：进行 BeanFactory 的refresh，在这里会去调用子类的 refreshBeanFactory方法，具体子类是怎么刷新的得看子类，然后再调用子类的 getBeanFactory方法，重新得到一个 BeanFactory</li><li>prepareBeanFactory(beanFactory)：<ol type="1"><li>设置 beanFactory 的类加载器</li><li>设置表达式解析器：StandardBeanExpressionResolver，用来解析 Spring中的表达式</li><li>添加PropertyEditorRegistrar：ResourceEditorRegistrar，PropertyEditorRegistrar类型转化器注册器，用来注册一些默认的 PropertyEditor</li><li>添加一个 Bean 的后置处理器：ApplicationContextAwareProcessor，是一个BeanPostProcessor，用来执行EnvironmentAware、ApplicationEventPublisherAware 等回调方法</li><li>添加<strong>ignoredDependencyInterface</strong>：可以向这个属性中添加一些接口，如果某个类实现了这个接口，并且这个类中的某些set 方法在接口中也存在，那么这个 set方法在自动注入的时候是不会执行的，比如 EnvironmentAware这个接口，如果某个类实现了这个接口，那么就必须实现它的 setEnvironment方法，而这是一个 set 方法，和 Spring 中的 autowire 是冲突的，那么 Spring在自动注入时是不会调用 setEnvironment 方法的，而是等到回调 Aware接口时再来调用（注意，这个功能仅限于 spring 自带的 autowire，<spanclass="citation" data-cites="Autowired">@Autowired</span>注解是忽略这个属性的）<ol type="1"><li>EnvironmentAware</li><li>EmbeddedValueResolverAware</li><li>ResourceLoaderAware</li><li>ApplicationEventPublisherAware</li><li>MessageSourceAware</li><li>ApplicationContextAware</li><li>另外其实在构造 BeanFactory 的时候就已经提前添加了另外三个：</li><li>BeanNameAware</li><li>BeanClassLoaderAware</li><li>BeanFactoryAware</li></ol></li><li>添加 <strong>resolvableDependencies</strong>：在 byType进行依赖注入时，会先从这个属性中根据类型找 bean<ol type="1"><li>BeanFactory.class：当前 BeanFactory 对象</li><li>ResourceLoader.class：当前 ApplicationContext 对象</li><li>ApplicationEventPublisher.class：当前 ApplicationContext 对象</li><li>ApplicationContext.class：当前 ApplicationContext 对象</li></ol></li><li>添加一个 Bean 的后置处理器：ApplicationListenerDetector，是一个BeanPostProcessor，用来判断某个 Bean 是不是ApplicationListener，如果是则把这个 Bean 添加到 ApplicationContext中去，注意一个 ApplicationListener 只能是单例的</li><li>添加一个 Bean 的后置处理器：LoadTimeWeaverAwareProcessor，是一个BeanPostProcessor，用来判断某个 Bean 是不是实现了 LoadTimeWeaverAware接口，如果实现了则把 ApplicationContext 中的 loadTimeWeaver 回调setLoadTimeWeaver 方法设置给该 Bean。</li><li>添加一些单例 bean 到单例池：<ol type="1"><li>"environment"：Environment 对象</li><li>"systemProperties"：System.getProperties() 返回的 Map 对象</li><li>"systemEnvironment"：System.getenv() 返回的 Map 对象</li></ol></li></ol></li><li>postProcessBeanFactory(beanFactory) ： 提供给AbstractApplicationContext 的子类进行扩展，具体的子类，可以继续向BeanFactory 中再添加一些东西</li><li>invokeBeanFactoryPostProcessors(beanFactory)：<strong>执行BeanFactoryPostProcessor</strong><ol type="1"><li>此时在 BeanFactory 中会存在一个BeanFactoryPostProcessor：<strong>ConfigurationClassPostProcessor</strong>，它也是一个<strong>BeanDefinitionRegistryPostProcessor</strong></li><li><strong>第一阶段</strong></li><li>从 BeanFactory 中找到类型为 BeanDefinitionRegistryPostProcessor 的beanName，也就是 <strong>ConfigurationClassPostProcessor</strong>，然后调用 BeanFactory 的 getBean 方法得到实例对象</li><li>执行 <strong>ConfigurationClassPostProcessor 的postProcessBeanDefinitionRegistry()</strong> 方法:<ol type="1"><li>解析 AppConfig 类</li><li>扫描得到 BeanDefinition 并注册</li><li>解析 <span class="citation"data-cites="Import">@Import</span>，<span class="citation"data-cites="Bean">@Bean</span> 等注解得到 BeanDefinition 并注册</li><li>这些 BeanDefinition 中可能存在 BeanFactoryPostProcessor 和BeanDefinitionRegistryPostProcessor，所以执行完ConfigurationClassPostProcessor的 postProcessBeanDefinitionRegistry() 方法后，还需要继续执行其他BeanDefinitionRegistryPostProcessor 的postProcessBeanDefinitionRegistry() 方法</li></ol></li><li>执行其他 BeanDefinitionRegistryPostProcessor 的<strong>postProcessBeanDefinitionRegistry()</strong> 方法</li><li>执行所有 BeanDefinitionRegistryPostProcessor 的<strong>postProcessBeanFactory()</strong> 方法</li><li><strong>第二阶段</strong></li><li>从 BeanFactory 中找到类型为 BeanFactoryPostProcessor 的beanName，而这些 BeanFactoryPostProcessor 包括了上面的BeanDefinitionRegistryPostProcessor</li><li>执行还没有执行过的 BeanFactoryPostProcessor 的<strong>postProcessBeanFactory()</strong> 方法</li></ol></li><li>到此，所有的 BeanFactoryPostProcessor的逻辑都执行完了，主要做的事情就是得到 BeanDefinition 并注册到BeanFactory 中</li><li>registerBeanPostProcessors(beanFactory)：因为上面的步骤完成了扫描，这个过程中程序员可能自己定义了一些BeanPostProcessor，在这一步就会把 BeanFactory 中所有的 BeanPostProcessor找出来并实例化得到一个对象，并添加到 BeanFactory 中去（属性<strong>beanPostProcessors</strong>），最后再重新添加一个ApplicationListenerDetector 对象（之前其实就添加了过，这里是为了把ApplicationListenerDetector 移动到最后）</li><li>initMessageSource()： 设置 ApplicationContext 的MessageSource,要么是用户设置的，要么是 DelegatingMessageSource，让ApplicationContext 拥有<strong>国际化</strong>的功能</li><li>initApplicationEventMulticaster()：设置 ApplicationContext 的applicationEventMulticaster，要么是用户设置的，要么是SimpleApplicationEventMulticaster，让 ApplicationContext拥有<strong>事件发布</strong>的功能</li><li>onRefresh()：提供给 AbstractApplicationContex t的子类进行扩展</li><li>registerListeners()：从 BeanFactory 中获取 ApplicationListener类型的 beanName，然后添加到 ApplicationContext 中的事件广播器<strong>applicationEventMulticaster</strong> 中去，到这一步因为FactoryBean 还没有调用 getObject() 方法生成 Bean对象，所以这里要再根据类型找一下 ApplicationListener，记录一下对应的beanName</li><li>finishBeanFactoryInitialization(beanFactory)：完成 BeanFactory的初始化，主要就是<strong>实例化非懒加载的单例 Bean</strong></li><li>finishRefresh()：BeanFactory 的初始化完后，就到了 Spring启动的最后一步了</li><li>设置 ApplicationContext 的 lifecycleProcessor，默认情况下设置的是DefaultLifecycleProcessor</li><li>调用 lifecycleProcessor 的 onRefresh() 方法，如果是DefaultLifecycleProcessor，那么会获取所有类型为 Lifecycle 的 Bean对象，然后调用它的 start() 方法，这就是 ApplicationContext的生命周期扩展机制</li><li>发布 <strong>ContextRefreshedEvent</strong> 事件</li></ol><h3 id="执行beanfactorypostprocessor">6.执行BeanFactoryPostProcessor</h3><ol type="1"><li>执行通过 ApplicationContext 添加进来的BeanDefinitionRegistryPostProcessor 的<font color="red">postProcessBeanDefinitionRegistry()</font> 方法</li><li>执行 BeanFactory 中实现了 PriorityOrdered 接口的BeanDefinitionRegistryPostProcessor 的<font color="red">postProcessBeanDefinitionRegistry()</font> 方法</li><li>执行 BeanFactory 中实现了 Ordered 接口的BeanDefinitionRegistryPostProcessor 的<font color="red">postProcessBeanDefinitionRegistry()</font> 方法</li><li>执行 BeanFactory 中其他的 BeanDefinitionRegistryPostProcessor 的<font color="red">postProcessBeanDefinitionRegistry()</font> 方法</li><li>执行上面所有的 BeanDefinitionRegistryPostProcessor 的<font color="green">postProcessBeanFactory()</font> 方法</li><li>执行通过 ApplicationContext 添加进来的 BeanFactoryPostProcessor 的<font color="green">postProcessBeanFactory()</font> 方法</li><li>执行 BeanFactory 中实现了 PriorityOrdered 接口的BeanFactoryPostProcessor 的<font color="green">postProcessBeanFactory()</font> 方法</li><li>执行 BeanFactory 中实现了 Ordered 接口的 BeanFactoryPostProcessor 的<font color="green">postProcessBeanFactory()</font> 方法</li><li>执行 BeanFactory 中其他的 BeanFactoryPostProcessor 的<font color="green">postProcessBeanFactory()</font> 方法</li></ol><h3 id="lifecycle的使用">7. Lifecycle的使用</h3><p>Lifecycle 表示的是 ApplicationContext 的生命周期，可以定义一个SmartLifecycle 来监听 ApplicationContext 的启动和关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugLifecycle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmartLifecycle</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isRunning = <span class="hljs-keyword">false</span>;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;启动&quot;</span>);<br>isRunning = <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 要触发stop()，要调用context.close()，或者注册关闭钩子（context.registerShutdownHook();）</span><br>System.out.println(<span class="hljs-string">&quot;停止&quot;</span>);<br>isRunning = <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRunning</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> isRunning;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="事件相关类">8. 事件相关类</h3><h4 id="事件监听器">事件监听器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugApplicationListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ApplicationEvent event)</span> </span>&#123;<br>        <span class="hljs-comment">// 事件发布 context.publishEvent(&quot;deBugWord&quot;);</span><br>        PayloadApplicationEvent applicationEvent = (PayloadApplicationEvent) event;<br>        System.out.println(applicationEvent.getPayload());<br>    &#125;<br>&#125;<br>````<br><br>普通 Bean 中：<br>```java<br>    <span class="hljs-meta">@EventListener</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">aa</span><span class="hljs-params">(ApplicationEvent applicationEvent)</span></span>&#123;<br>        System.out.println(applicationEvent);<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="applicationlistenerdetector">ApplicationListenerDetector</h4><p>ApplicationListenerDetector 是一个 BeanPostProcessor，用于检查一个Bean 是不是 ApplicationListener。</p><h4 id="eventlistenermethodprocessor">EventListenerMethodProcessor</h4><p>EventListenerMethodProcessor 是一个 SmartInitializingSingleton，利用EventListenerFactory 将加了 <span class="citation"data-cites="EventListener">@EventListener</span> 注解的方法封装成ApplicationListener 对象</p><h4id="simpleapplicationeventmulticaster">SimpleApplicationEventMulticaster</h4><p>SimpleApplicationEventMulticaster 默认事件发布器</p><p>AbstractApplicationContext#publishEvent(java.lang.Object,org.springframework.core.ResolvableType) <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishEvent</span><span class="hljs-params">(Object event, <span class="hljs-meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;<br>Assert.notNull(event, <span class="hljs-string">&quot;Event must not be null&quot;</span>);<br><br><span class="hljs-comment">// Decorate event as an ApplicationEvent if necessary</span><br>ApplicationEvent applicationEvent;<br><span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ApplicationEvent) &#123;<br>applicationEvent = (ApplicationEvent) event;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>applicationEvent = <span class="hljs-keyword">new</span> PayloadApplicationEvent&lt;&gt;(<span class="hljs-keyword">this</span>, event);<br><span class="hljs-keyword">if</span> (eventType == <span class="hljs-keyword">null</span>) &#123;<br>eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.earlyApplicationEvents != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.earlyApplicationEvents.add(applicationEvent);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);<br>&#125;<br><br><span class="hljs-comment">// Publish event via parent context as well...</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parent != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parent <span class="hljs-keyword">instanceof</span> AbstractApplicationContext) &#123;<br>((AbstractApplicationContext) <span class="hljs-keyword">this</span>.parent).publishEvent(event, eventType);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">this</span>.parent.publishEvent(event);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent,org.springframework.core.ResolvableType) <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">multicastEvent</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ApplicationEvent event, <span class="hljs-meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;<br>ResolvableType type = (eventType != <span class="hljs-keyword">null</span> ? eventType : resolveDefaultEventType(event));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;<br>Executor executor = getTaskExecutor();<br><span class="hljs-keyword">if</span> (executor != <span class="hljs-keyword">null</span>) &#123;<br>executor.execute(() -&gt; invokeListener(listener, event));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>invokeListener(listener, event);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——推断构造方法源码解析</title>
    <link href="/2022/07/08/Spring%E2%80%94%E2%80%94%E6%8E%A8%E6%96%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/07/08/Spring%E2%80%94%E2%80%94%E6%8E%A8%E6%96%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>https://www.processon.com/view/link/629e0d260791293c9388933b</p><h3 id="推断构造的场景">1. 推断构造的场景</h3><ol type="1"><li>默认情况下，使用无参构造方法或者唯一的构造方法</li><li>如果通过 getBean() 或者beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(1,newUserService()) 指定了构造方法的入参值，则使用锁匹配的构造方法</li><li>设置 autowire="constructor" 让 Spring自动选择构造方法以及入参值</li><li>通过 <span class="citation" data-cites="Autowired">@Autowired</span>指定构造方法，Spring 自动匹配值</li></ol><p>Spring 中的一个bean，需要实例化得到一个对象，而实例化就需要用到构造方法。</p><p>一般情况下，一个类只有一个构造方法：</p><ol type="1"><li>要么是无参的构造方法</li><li>要么是有参的构造方法</li></ol><p>如果只有<strong>一个无参</strong>的构造方法，那么实例化就只能使用这个构造方法了。如果只有<strong>一个有参</strong>的构造方法，那么实例化时能使用这个构造方法吗？要分情况讨论：</p><ol type="1"><li>使用AnnotationConfigApplicationContext，会使用这个构造方法进行实例化，那么Spring 会根据构造方法的参数信息去寻找 bean，然后传给构造方法</li><li>使用 ClassPathXmlApplicationContext，表示使用 XML 的方式来使用bean，要么在 XML 中指定构造方法的参数值(手动指定)，要么配置<strong>autowire=constructor</strong> 让 Spring <strong>自动</strong>去寻找 bean 做为构造方法参数值。</li></ol><p>上面是只有一个构造方法的情况，那么如果有多个构造方法呢？</p><p>又分为两种情况，多个构造方法中存不存在无参的构造方法。</p><p>分析：一个类存在多个构造方法，那么 Spring进行实例化之前，该如何去确定到底用哪个构造方法呢？</p><ol type="1"><li>如果开发者指定了想要使用的构造方法，那么就用这个构造方法</li><li>如果开发者没有指定想要使用的构造方法，则看开发者有没有让 Spring自动去选择构造方法</li><li>如果开发者也没有让 Spring 自动去选择构造方法，则 Spring利用无参构造方法，如果没有无参构造方法，则报错</li></ol><ul><li>指定构造方法<ul><li>xml 中的 &lt;constructor-arg&gt;标签，这个标签表示构造方法参数，所以可以根据这个确定想要使用的构造方法的参数个数，从而确定想要使用的构造方法</li><li>通过 <span class="citation" data-cites="Autowired">@Autowired</span>注解，<span class="citation" data-cites="Autowired">@Autowired</span>注解可以写在构造方法上，表示开发者想使用哪个构造方法，当然，它和第一个方式的不同点是，通过xml 的方式，我们直接指定了构造方法的参数值，而通过 <spanclass="citation" data-cites="Autowired">@Autowired</span>注解的方式，需要 Spring 通过 byType+byName 的方式去找到符合条件的 bean作为构造方法的参数值</li><li>多个构造方法上写了 <span class="citation"data-cites="Autowired">@Autowired</span> 注解，那么此时 Spring会报错。但是因为 <span class="citation"data-cites="Autowired">@Autowired</span> 还有一个属性 required，默认为ture，所以一个类中，只有能一个构造方法标注了 <span class="citation"data-cites="Autowired">@Autowired</span> 或 <span class="citation"data-cites="Autowired">@Autowired</span>（required=true），有多个会报错。但是可以有多个<span class="citation"data-cites="Autowired">@Autowired</span>（required=false），这种情况下，需要Spring 从这些构造方法中去自动选择一个构造方法。</li></ul></li><li>Spring 自动去选择构造方法<ul><li>对于这一点，只能用在 ClassPathXmlApplicationContext，因为通过AnnotationConfigApplicationContext 没有办法去指定某个 bean可以自动去选择构造方法，而通过 ClassPathXmlApplicationContext 可以在 xml中指定某个 bean 的 autowire 为constructor，虽然这个属性表示通过构造方法自动注入，所以需要自动的去选择一个构造方法进行自动注入，因为是构造方法，所以顺便是进行实例化。</li></ul></li></ul><h3 id="源码思路">2. 源码思路</h3><h4 id="推断构造方法">2.1 推断构造方法</h4><ol type="1"><li>AbstractAutowireCapableBeanFactory 类中的 createBeanInstance()方法会去创建一个 Bean 实例</li><li>根据 BeanDefinition 加载类得到 Class 对象</li><li>如果 BeanDefinition 绑定了一个 Supplier，那就调用 Supplier 的 get方法得到一个对象并直接返回</li><li>如果 BeanDefinition 中存在<strong>factoryMethodName</strong>，那么就<strong>调用该工厂方法</strong>得到一个bean 对象并返回</li><li>如果 BeanDefinition 已经自动构造过了，那就调用 autowireConstructor()自动构造一个对象</li><li>调用 SmartInstantiationAwareBeanPostProcessor 的determineCandidateConstructors() 方法得到哪些构造方法是可以用的</li><li>如果存在可用的构造方法，或者当前 BeanDefinition 的 autowired 是AUTOWIRE_CONSTRUCTOR，或者 BeanDefinition中指定了构造方法参数值，或者创建 Bean的时候指定了构造方法参数值，那么就调用<strong>autowireConstructor()</strong> 方法自动构造一个对象</li><li>最后，如果不是上述情况，就根据无参的构造方法实例化一个对象</li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220710181239.png" /></p><h4 id="autowireconstructor">2.2 autowireConstructor()</h4><ul><li>先检查是否指定了具体的构造方法和构造方法参数值，或者在BeanDefinition中缓存了具体的构造方法或构造方法参数值，如果存在那么则直接使用该构造方法进行实例化</li><li>如果没有确定的构造方法或构造方法参数值，那么<ol type="1"><li>如果没有确定的构造方法，那么则找出类中所有的构造方法</li><li>如果只有一个无参的构造方法，那么直接使用无参的构造方法进行实例化</li><li>如果有多个可用的构造方法或者当前Bean需要自动通过构造方法注入</li><li>根据所指定的构造方法参数值，确定所需要的最少的构造方法参数值的个数</li><li>对所有的构造方法进行排序，参数个数多的在前面</li><li>遍历每个构造方法</li><li>如果不是调用getBean方法时所指定的构造方法参数值，那么则根据构造方法参数类型找值</li><li>如果时调用getBean方法时所指定的构造方法参数值，就直接利用这些值</li><li>如果根据当前构造方法找到了对应的构造方法参数值，那么这个构造方法就是可用的，但是不一定这个构造方法就是最佳的，所以这里会涉及到是否有多个构造方法匹配了同样的值，这个时候就会用值和构造方法类型进行匹配程度的打分，找到一个最匹配的</li></ol></li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220710192029.png" /></p><h4 id="匹配值分数">2.3 匹配值分数</h4><p>主要是计算找到的 bean和构造方法参数类型匹配程度有多高。分数越小优先级越高</p><p>假设 bean 的类型为 A，A 的父类是 B，B 的父类是 C，同时 A 实现了接口 D+ 如果构造方法的参数类型为 A，那么完全匹配，得分为 0 +如果构造方法的参数类型为 B，那么得分为 2 + 如果构造方法的参数类型为C，那么得分为 4 + 如果构造方法的参数类型为 D，那么得分为1</p><p>可以直接使用如下代码进行测试： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] objects = <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-keyword">new</span> A()&#125;;<br><br><span class="hljs-comment">// 0</span><br>System.out.println(MethodInvoker.getTypeDifferenceWeight(<span class="hljs-keyword">new</span> Class[]&#123;A.class&#125;, objects));<br><br><span class="hljs-comment">// 2</span><br>System.out.println(MethodInvoker.getTypeDifferenceWeight(<span class="hljs-keyword">new</span> Class[]&#123;B.class&#125;, objects));<br><br><span class="hljs-comment">// 4</span><br>System.out.println(MethodInvoker.getTypeDifferenceWeight(<span class="hljs-keyword">new</span> Class[]&#123;C.class&#125;, objects));<br><br><span class="hljs-comment">// 1</span><br>System.out.println(MethodInvoker.getTypeDifferenceWeight(<span class="hljs-keyword">new</span> Class[]&#123;D.class&#125;, objects));<br></code></pre></td></tr></table></figure>所以，我们可以发现，越匹配分数越低。</p><h4 id="bean的情况">2.4 <span class="citation"data-cites="Bean的情况">@Bean的情况</span></h4><p>首先，Spring 会把 <span class="citation"data-cites="Bean">@Bean</span> 修饰的方法解析成 BeanDefinition：</p><ul><li>如果方法是非 static 的，那么解析出来的 BeanDefinition 中：<ol type="1"><li>factoryBeanName 为 AppConfig 所对应的 beanName，比如"appConfig"</li><li>factoryMethodName 为对应的方法名，比如 "aService"</li><li>factoryClass 为 AppConfig.class</li></ol></li></ul><ol start="2" type="1"><li>如果方法是 static 的，那么解析出来的 BeanDefinition 中：<ol type="1"><li>factoryBeanName 为 null</li><li>factoryMethodName 为对应的方法名，比如 "aService"</li><li>factoryClass 也为 AppConfig.class</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--非静态方法--&gt;<br>&lt;bean id=<span class="hljs-string">&quot;userService&quot;</span> factory-bean=<span class="hljs-string">&quot;userServiceFactory&quot;</span> factory-method=<span class="hljs-string">&quot;create&quot;</span>/&gt;<br>&lt;!--静态方法--&gt;<br>&lt;bean id=<span class="hljs-string">&quot;userService&quot;</span>  <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.UserServiceFactory&quot;</span> factory-method=<span class="hljs-string">&quot;xxx&quot;</span>/&gt;<br><br></code></pre></td></tr></table></figure><p>在由 <span class="citation" data-cites="Bean">@Bean</span> 生成的BeanDefinition 中，有一个重要的属性 isFactoryMethodUnique，表示factoryMethod 是不是唯一的，在普通情况下 <span class="citation"data-cites="Bean">@Bean</span> 生成的 BeanDefinition 的isFactoryMethodUnique 为true，但是如果出现了方法重载，那么就是特殊的情况，比如： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AService <span class="hljs-title">aService</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AService();<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> AService <span class="hljs-title">aService</span><span class="hljs-params">(BService bService)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AService();<br>&#125;<br></code></pre></td></tr></table></figure>虽然有两个 <span class="citation"data-cites="Bean">@Bean</span>，但是肯定只会生成一个 aService 的Bean，那么 Spring 在处理 <span class="citation"data-cites="Bean">@Bean</span> 时，也只会生成一个 aService 的BeanDefinition，比如 Spring 先解析到第一个 <span class="citation"data-cites="Bean">@Bean</span>，会生成一个 BeanDefinition，此时isFactoryMethodUnique 为 true，但是解析到第二个 <span class="citation"data-cites="Bean">@Bean</span> 时，会判断出来 beanDefinitionMap中已经存在一个 aService 的 BeanDefinition 了，那么会把之前的这个BeanDefinition 的 isFactoryMethodUnique 修改为 false，并且不会生成新的BeanDefinition 了。</p><p>并且后续在根据 BeanDefinition 创建 Bean 时，会根据isFactoryMethodUnique 来操作，如果为 true，那就表示当前 BeanDefinition只对应了一个方法，那也就是只能用这个方法来创建 Bean 了，但是如果isFactoryMethodUnique 为 false，那就表示当前 BeanDefition对应了多个方法，需要和推断构造方法的逻辑一样，去选择用哪个方法来创建Bean。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——循环依赖源码解析</title>
    <link href="/2022/07/02/Spring%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/07/02/Spring%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>https://www.processon.com/view/link/629e0d260791293c9388933b ## 1.什么是循环依赖？</p><p>就是A对象依赖了B对象，B对象依赖了A对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// A依赖了B</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br><span class="hljs-keyword">public</span> B b;<br>&#125;<br><br><span class="hljs-comment">// B依赖了A</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;<br><span class="hljs-keyword">public</span> A a;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么循环依赖是个问题吗？</p><p>如果不考虑Spring，循环依赖并不是问题，因为对象之间相互依赖是很正常的事情。</p><p>比如 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> A();<br>B b = <span class="hljs-keyword">new</span> B();<br><br>a.b = b;<br>b.a = a;<br></code></pre></td></tr></table></figure> 这样，A,B就依赖上了。</p><p>但是，在 Spring 中循环依赖就是一个问题了，为什么？ 因为，在 Spring中，一个对象并不是简单 new 出来了，而是会经过一系列的 Bean的生命周期，就是因为 Bean 的生命周期所以才会出现循环依赖问题。当然，在Spring 中，出现循环依赖的场景很多，有的场景 Spring自动帮我们解决了，而有的场景则需要程序员来解决。</p><h2 id="bean-的生命周期">2. Bean 的生命周期</h2><p>Bean 的生命周期指的就是：在 Spring 中，Bean 是如何生成的？</p><p>被 Spring 管理的对象叫做 Bean。Bean 的生成步骤如下：</p><ol type="1"><li>Spring 扫描 class 得到 BeanDefinition</li><li>根据得到的 BeanDefinition 去生成 bean</li><li>首先根据 class 推断构造方法</li><li>根据推断出来的构造方法，反射，得到一个对象（暂时叫做原始对象）</li><li>填充原始对象中的属性（依赖注入）</li><li>如果原始对象中的某个方法被 AOP了，那么则需要根据原始对象生成一个代理对象</li><li>把最终生成的代理对象放入单例池（singletonObjects）中，下次 getBean时就直接从单例池拿即可</li></ol><p>可以看到，对于 Spring 中的 Bean的生成过程，还有很多很多，比如Aware回调、初始化等等。</p><p>可以发现，在 Spring 中，构造一个 Bean，包括了 new这个步骤（第4步构造方法反射）。得到一个原始对象后，Spring需要给对象中的属性进行依赖注入，那么这个注入过程是怎样的？ 　　A类中存在一个 B 类的 b 属性，所以，当 A类生成了一个原始对象之后，就会去给 b 属性去赋值，此时就会根据 b属性的类型和属性名去 BeanFactory 中去获取 B 类所对应的单例bean。如果此时 BeanFactory 中存在 B 对应的 Bean，那么直接拿来赋值给 b属性；如果此时 BeanFactory 中不存在 B 对应的 Bean，则需要生成一个 B对应的 Bean，然后赋值给 b 属性。 　　问题就出现在第二种情况，如果此时 B类在 BeanFactory 中还没有生成对应的 Bean，那么就需要去生成，就会经过 B的 Bean 的生命周期。 　　那么在创建 B 类的 Bean 的过程中，如果 B类中存在一个 A 类的 a 属性，那么在创建 B 的 Bean 的过程中就需要 A类对应的 Bean，但是，触发 B 类 Bean 的创建的条件是 A 类 Bean在创建过程中的依赖注入，所以这里就出现了循环依赖。</p><p>ABean 创建--&gt;依赖了 B 属性--&gt;触发 BBean 创建---&gt;B 依赖了 A属性---&gt;需要 ABean（但 ABean 还在创建过程中）</p><p>从而导致 ABean 创建不出来，BBean 也创建不出来。</p><p>在 Spring中，通过<strong>三级缓存</strong>机制帮开发者解决了部分循环依赖的问题。</p><h2 id="三级缓存">3. 三级缓存</h2><p>三级缓存是通用的叫法。 一级缓存为：<strong>singletonObjects</strong>二级缓存为：<strong>earlySingletonObjects</strong>三级缓存为：<strong>singletonFactories</strong></p><ul><li><strong>singletonObjects</strong>：中缓存的是已经经历了完整生命周期的bean 对象。</li><li><strong>earlySingletonObjects</strong>：缓存的是早期的 bean对象。表示 Bean 的生命周期还没走完就把这个 Bean 放入了earlySingletonObjects。</li><li><strong>singletonFactories</strong>：缓存的是ObjectFactory，对象工厂，用来创建早期 bean 对象的工厂。</li></ul><h2 id="解决循环依赖思路分析">4. 解决循环依赖思路分析</h2><p>A 创建时---&gt;需要 B----&gt;B 去创建---&gt;需要A，从而产生了循环</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220702154710.png" /></p><p>那么如何打破这个循环，加个缓存：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220702154827.png" /></p><p>　　A 的 Bean 创建过程中，在进行依赖注入之前，先把 A 的原始 Bean放入缓存（提早暴露，只要放到缓存了，其他 Bean需要时就可以从缓存中拿了），放入缓存后，再进行依赖注入，此时 A 的 Bean依赖了 B 的 Bean，如果 B 的 Bean 不存在，则需要创建 B 的 Bean，而创建 B的 Bean 的过程和 A 一样，也是先创建一个 B 的原始对象，然后把 B的原始对象提早暴露出来放入缓存中，然后在对 B 的原始对象进行依赖注入A，此时能从缓存中拿到 A 的原始对象（虽然是 A 的原始对象，还不是最终的Bean），B 的原始对象依赖注入完了之后，B 的生命周期结束，那么 A的生命周期也能结束。</p><p>　　因为整个过程中，都只有一个 A 原始对象，所以对于 B而言，就算在属性注入时，注入的是 A 原始对象，也没有关系，因为 A原始对象在后续的生命周期中在堆中没有发生变化。</p><p>　　从上面这个分析过程中可以得出，只需要一个缓存就能解决循环依赖了，那么为什么Spring 中还需要 <strong>singletonFactories</strong> 呢？</p><p>　　这是难点，基于上面的场景想一个问题：如果 A 的原始对象注入给 B的属性之后，A 的原始对象进行了 AOP产生了一个代理对象，此时就会出现，对于 A 而言，它的 Bean 对象其实应该是AOP 之后的代理对象，而 B 的 a 属性对应的并不是 AOP之后的代理对象，这就产生了冲突。<strong>B依赖的A和最终的A不是同一个对象</strong>。</p><p>　　AOP 就是通过 BeanPostProcessor 来实现的，这个 BeanPostProcessor就是 AnnotationAwareAspectJAutoProxyCreator，它的父类是AbstractAutoProxyCreator，而在 Spring 中 AOP 利用的要么是 JDK动态代理，要么 CGLib的动态代理，所以如果给一个类中的某个方法设置了切面，那么这个类最终就需要生成一个代理对象。</p><p>　　一般过程就是：A类---&gt;生成一个普通对象--&gt;属性注入--&gt;基于切面生成一个代理对象--&gt;把代理对象放入singletonObjects 单例池中。</p><p>　　而 AOP 可以说是 Spring 中除开 IOC的另外一大功能，而循环依赖又是属于 IOC范畴的，所以这两大功能想要并存，Spring 需要特殊处理。</p><p>　　如何处理的，就是利用了第三级缓存<strong>singletonFactories</strong>。</p><p>　　首先，singletonFactories 中存的是某个 beanName 对应的ObjectFactory，在 bean 的生命周期中，生成完原始对象之后，就会构造一个ObjectFactory 存入 singletonFactories 中。这个ObjectFactory是一个函数式接口，所以支持 Lambda 表达式：<strong>() -&gt;getEarlyBeanReference(beanName, mbd, bean)</strong></p><p>　　上面的 Lambda 表达式就是一个 ObjectFactory，执行该 Lambda表达式就会去执行 getEarlyBeanReference 方法，而该方法如下：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getEarlyBeanReference</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;<br>Object exposedObject = bean;<br><span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br><span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<br><span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;<br>SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;<br>exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure> 　　该方法会去执行SmartInstantiationAwareBeanPostProcessor 中的 getEarlyBeanReference方法，而这个接口下的实现类中只有两个类实现了这个方法，一个是AbstractAutoProxyCreator，一个是InstantiationAwareBeanPostProcessorAdapter，它的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// InstantiationAwareBeanPostProcessorAdapter</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getEarlyBeanReference</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutoProxyCreator</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getEarlyBeanReference</span><span class="hljs-params">(Object bean, String beanName)</span> </span>&#123;<br>Object cacheKey = getCacheKey(bean.getClass(), beanName);<br><span class="hljs-keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);<br><span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<br>&#125;<br></code></pre></td></tr></table></figure><p>　在整个 Spring 中，默认就只有 AbstractAutoProxyCreator真正意义上实现了 getEarlyBeanReference 方法，而该类就是用来进行 AOP的。上文提到的 AnnotationAwareAspectJAutoProxyCreator 的父类就是AbstractAutoProxyCreator。</p><p>那么　getEarlyBeanReference　方法到底在干什么？</p><ul><li>首先得到一个 cachekey，cachekey 就是beanName。</li><li>把 beanName 和 bean（这是原始对象）存入 earlyProxyReferences中（标记已经 AOP 过了，初始化后不再进行 AOP）</li><li>调用 wrapIfNecessary 进行 AOP，得到一个代理对象。</li></ul><p>那么，什么时候会调用 getEarlyBeanReference方法呢？回到循环依赖的场景中</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220702165327.png" /></p><p>　　第三集缓存中保存的 ObjectFactory 实际上是一个 labmda表达式，中间有 getEarlyBeanReference 方法，注意存入 singletonFactories时并不会执行 lambda 表达式，也就是不会执行 getEarlyBeanReference方法</p><p>　　如果存在循环依赖，从 singletonFactories 根据 beanName 得到一个ObjectFactory，然后执行 ObjectFactory#getObject，也就是执行getEarlyBeanReference 方法，此时会得到一个 A 原始对象经过 AOP之后的代理对象，然后把该代理对象放入 earlySingletonObjects中，注意此时并没有把代理对象放入 singletonObjects中，那什么时候放入到singletonObjects中呢？</p><p>　　我们这个时候得来理解一下 earlySingletonObjects的作用，此时，我们只得到了 A 原始对象的代理对象，这个对象还不完整，因为A 原始对象还没有进行属性填充，所以此时不能直接把 A 的代理对象放入singletonObjects 中，所以只能把代理对象放入earlySingletonObjects，假设现在有其他对象依赖了A，那么则可以从earlySingletonObjects 中得到 A 原始对象的代理对象了，并且是 A的同一个代理对象。</p><p>　　当 B 创建完了之后，A 继续进行生命周期，而 A在完成属性注入后，会按照它本身的逻辑去进行 AOP，而此时我们知道 A原始对象已经经历过了 AOP，所以对于 A 本身而言，不会再去进行 AOP了，那么怎么判断一个对象是否经历过了 AOP 呢？会利用上文提到的earlyProxyReferences，在 AbstractAutoProxyCreator 的postProcessAfterInitialization 方法中，会去判断当前 beanName 是否在earlyProxyReferences，如果在则表示已经提前进行过 AOP 了，无需再次进行AOP。</p><p>　　对于 A 而言，进行了 AOP 的判断后，以及 BeanPostProcessor的执行之后，就需要把 A 对应的对象放入 singletonObjects中了，但是我们知道，应该是要把 A 的代理对象放入 singletonObjects中，所以此时需要从 earlySingletonObjects 中得到代理对象，然后加入singletonObjects 中。<strong>整个循环依赖解决完毕。</strong></p><h2 id="总结">５.总结</h2><ol type="1"><li><strong>singletonObjects</strong>：缓存经过了<strong>完整生命周期</strong>的bean</li><li><strong>earlySingletonObjects</strong>：缓存<strong>未经过完整生命周期的bean</strong>，如果某个 bean出现了循环依赖，就会<strong>提前</strong>把这个暂时未经过完整生命周期的bean 放入 earlySingletonObjects 中，这个 bean 如果要经过AOP，那么就会把代理对象放入 earlySingletonObjects中，否则就是把原始对象放入 earlySingletonObjects。</li><li><strong>singletonFactories</strong>：缓存的是一个ObjectFactory，实际上是一个 Lambda 表达式。在每个 Bean的生成过程中，经过<strong>实例化</strong>得到一个原始对象后，都会提前基于原始对象暴露一个Lambda 表达式，并保存到三级缓存中，这个 Lambda表达式<strong>可能用到，也可能用不到</strong>，如果当前 Bean没有出现循环依赖，那么这个 Lambda 表达式没用，当前 bean按照自己的生命周期正常执行，执行完后直接把当前 bean 放入singletonObjects 中，如果当前 bean在依赖注入时发现出现了循环依赖（当前正在创建的 bean 被其他 bean依赖了），则从三级缓存中拿到 Lambda 表达式，并执行 Lambda表达式得到一个对象，并把得到的对象放入二级缓存（如果当前Bean需要AOP，那么执行lambda表达式，得到就是对应的代理对象，如果无需AOP，则直接得到一个原始对象）。</li><li>其实还要一个缓存，就是<strong>earlyProxyReferences</strong>，它用来记录某个原始对象是否进行过AOP 了。</li></ol><p>Spring 所用的 singletonFactories，为了调和不同的情况，在singletonFactories 中存的是lambda表达式，这样的话，只有在出现了循环依赖的情况，才会执行 lambda表达式，才会进行 AOP，也就说只有在出现了循环依赖的情况下才会打破 Bean生命周期的设计，如果一个 Bean 没有出现循环依赖，那么它还是遵守了 Bean的生命周期的设计的。</p><ul><li>原型 Bean 循环依赖无法解决，如果其中一个为单例则可以解决</li><li>循环依赖中先加载的 Bean（后加载的不会出现） 中使用 <spanclass="citation" data-cites="Async">@Async</span>注解（AsyncAnnotationBeanPostProcessor)，会修改 AOP生成的代理对象，导致循环依赖失败（否则单例池中的对象和循环依赖中引用的对象不是同一个对象）。可通过在使用<span class="citation" data-cites="Async">@Async</span> 注解的 Bean中通过 <span class="citation" data-cites="Lazy">@Lazy</span>修饰需要依赖注入的 Bean 来解决。</li><li>使用 <span class="citation"data-cites="Transactional">@Transactional</span>注解，循环依赖不会失败。因为 <span class="citation"data-cites="Transactional">@Transactional</span> 不会向容器中添加BeanPostProcessor，而是BeanFactoryTransactionAttributeSourceAdvisor。</li><li>通过构造方法注入的循环依赖将注入失败（无法拿到半成品Bean），可以通过在构造方法上使用 <span class="citation"data-cites="Lazy">@Lazy</span> 注解（生成代理对象）来解决。</li><li>自己注入自己也属于循环依赖，Spring 也可以自己解决。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——依赖注入源码解析</title>
    <link href="/2022/06/20/Spring%E2%80%94%E2%80%94%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/06/20/Spring%E2%80%94%E2%80%94%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p>https://www.processon.com/view/link/629e0d260791293c9388933b</p><h2 id="spring-中依赖注入的方式">1. Spring 中依赖注入的方式</h2><p>首先分两种：</p><ol type="1"><li>手动注入</li><li>自动注入</li></ol><h3 id="手动注入">1.1 手动注入</h3><p>在 XML 中定义 Bean 时，就是手动注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean name=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.debug.service.UserService&quot;</span>&gt;<br>&lt;property name=<span class="hljs-string">&quot;orderService&quot;</span> ref=<span class="hljs-string">&quot;orderService&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>上面这种方式底层是通过 <strong>set方法</strong> 进行注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean name=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.debug.service.UserService&quot;</span>&gt;<br>&lt;constructor-arg index=<span class="hljs-string">&quot;0&quot;</span> ref=<span class="hljs-string">&quot;orderService&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>上面这种方式底层是通过 <strong>构造方法</strong> 进行注入。</p><p>所以手动注入的底层也就是分为两种：</p><ol type="1"><li>set 方法注入</li><li>构造方法注入</li></ol><h3 id="自动注入">1.2 自动注入</h3><p>自动注入又分为两种：</p><ol type="1"><li>XML &lt;bean autowire="byType"/&gt; / <span class="citation"data-cites="Bean">@Bean</span>(autowire = Autowire.BY_NAME)</li><li><span class="citation" data-cites="Autowired">@Autowired</span>注解的自动注入</li></ol><h2 id="xml-的-autowire-自动注入">2. XML 的 autowire 自动注入</h2><p>在 XML 中，我们可以在定义一个 Bean 时去指定这个 Bean的自动注入模式：</p><ol type="1"><li>byType</li><li>byName</li><li>constructor</li><li>default</li><li>no</li></ol><p>比如： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.debug.service.UserService&quot;</span> autowire=<span class="hljs-string">&quot;byType&quot;</span>/&gt;<br></code></pre></td></tr></table></figure> 这么写，表示 Spring 会自动的给 userService中所有的属性自动赋值（<strong>不需要</strong>这个属性上有 <spanclass="citation" data-cites="Autowired">@Autowired</span>注解，但需要这个属性有对应的 <strong>set方法</strong>）。</p><p>在创建 Bean 的过程中，在填充属性时，Spring会去解析当前类，把<strong>当前类的所有方法</strong>都解析出来，Spring会去解析每个方法得到对应的 PropertyDescriptor 对象，PropertyDescriptor中有几个属性：</p><ol type="1"><li>name：这个 name 并不是方法的名字，而是拿方法名字进过处理后的名字<ul><li>如果方法名字以 “get” 开头，比如 “getXXX” ,那么 name=XXX</li><li>如果方法名字以 “is” 开头，比如 “isXXX” ,那么 name=XXX</li><li>如果方法名字以 “set” 开头，比如 “setXXX” ,那么 name=XXX</li></ul></li><li>readMethodRef：表示 get 方法的 Method 对象的引用</li><li>readMethodName：表示 get 方法的名字</li><li>writeMethodRef：表示 set 方法的 Method 对象的引用</li><li>writeMethodName：表示 set 方法的名字</li><li>propertyTypeRef：如果有 get 方法那么对应的就是返回值的类型，如果是set 方法那么对应的就是 set 方法中唯一参数的类型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw) &#123;<br><span class="hljs-comment">// bw 包含当前需要注入属性的对象</span><br>Set&lt;String&gt; result = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();<br>PropertyValues pvs = mbd.getPropertyValues();<br><span class="hljs-comment">// 属性描述器 getter 和 setter</span><br>PropertyDescriptor[] pds = bw.getPropertyDescriptors();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">哪些属性能自动注入？</span><br><span class="hljs-comment">1. 有 set 方法</span><br><span class="hljs-comment">2. 没有在 ignoredDependencyTypes 中</span><br><span class="hljs-comment">3. set 方法不是 ignoredDependencyInterfaces 中某个接口定义的</span><br><span class="hljs-comment">4. 属性类型不是简单类型 Int Integer... （@Autowired 可以注入）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (PropertyDescriptor pd : pds) &#123;<br><span class="hljs-keyword">if</span> (pd.getWriteMethod() != <span class="hljs-keyword">null</span> &amp;&amp; !isExcludedFromDependencyCheck(pd) &amp;&amp; !pvs.contains(pd.getName()) &amp;&amp;<br>!BeanUtils.isSimpleProperty(pd.getPropertyType())) &#123;<br>result.add(pd.getName());<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> StringUtils.toStringArray(result);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>get方法的定义是：</strong> 方法参数个数为 0 个，并且（方法名字以 "get" 开头 或者 方法名字以 "is" 开头并且方法的返回类型为boolean）</p><p><strong>set方法的定义是：</strong> 方法参数个数为 1 个，并且（方法名字以 "set" 开头并且方法返回类型为 void）</p><p>所以，Spring 在通过 byName 的自动填充属性时流程是：</p><ol type="1"><li>找到所有 set 方法所对应的 XXX 部分的名字</li><li>根据 XXX 部分的名字去获取 bean</li></ol><p>Spring 在通过 byType 的自动填充属性时流程是：</p><ol type="1"><li>获取到 set 方法中的唯一参数的参数类型，并且根据该类型去容器中获取bean</li><li>如果找到多个，会报错。</li></ol><p>以上，分析了 autowire 的 byType 和 byName 情况，那么接下来分析constructor，constructor 表示通过构造方法注入.。</p><p>如果是 constructor，那么就可以不写 set 方法了，当某个 bean是通过构造方法来注入时，spring 利用构造方法的参数信息从 Spring容器中去找 bean，找到bean 之后作为参数传给构造方法，从而实例化得到一个bean 对象，并完成属性赋值。</p><p>其实构造方法注入相当于 byType+byName，普通的 byType 是根据 set方法中的参数类型去找 bean，找到多个会报错，而 constructor就是通过构造方法中的参数类型去找bean，如果找到多个会根据参数名确定。</p><p>另外两个：</p><ol type="1"><li>no，表示关闭 autowire</li><li>default，表示默认值，我们一直演示的某个bean的autowire，而也可以直接在&lt;beans&gt; 标签中设置 autowire，如果设置了，那么 &lt;bean&gt;标签中设置的 autowire 如果为 default，那么则会用 &lt;beans&gt;标签中设置的 autowire。</li></ol><p>可以发现 XML中的自动注入是挺强大的，那么问题来了，<strong>为什么我们平时都是用的@Autowired注解呢？而没有用上文说的这种自动注入方式呢？</strong></p><p><span class="citation" data-cites="Autowired">@Autowired</span>注解相当于 XML 中的 autowire 属性的<strong>注解方式的替代</strong>。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">Essentially, the @Autowired annotation provides the same capabilities <span class="hljs-keyword">as</span> described <span class="hljs-keyword">in</span> Autowiring Collaborators but <span class="hljs-keyword">with</span> more fine-grained control <span class="hljs-keyword">and</span> wider applicability<br><br>从本质上讲，@Autowired注解提供了与autowire相同的功能，但是拥有更细粒度的控制和更广泛的适用性。<br></code></pre></td></tr></table></figure><p>注意：<strong>更细粒度的控制</strong>。</p><p>XML 中的 autowire 控制的是整个 bean 的所有属性，而 <spanclass="citation" data-cites="Autowired">@Autowired</span>注解是直接写在某个属性、某个 set 方法、某个构造方法上的。</p><p>再举个例子，如果一个类有多个构造方法，那么如果用 XML 的autowire=constructor，你无法控制到底用哪个构造方法，而你可以用 <spanclass="citation" data-cites="Autowired">@Autowired</span>注解来直接指定你想用哪个构造方法。</p><p>同时，用 <span class="citation"data-cites="Autowired">@Autowired</span>注解，还可以控制，哪些属性想被自动注入，哪些属性不想，这也是细粒度的控制。</p><p>但是 <span class="citation" data-cites="Autowired">@Autowired</span>无法区分 byType 和 byName，<span class="citation"data-cites="Autowired">@Autowired</span> 是先 byType，如果找到多个则byName。</p><p>那么 XML 的自动注入底层其实也就是：</p><ol type="1"><li>set方法注入</li><li>构造方法注入</li></ol><h2 id="autowired-注解的自动注入">3. <span class="citation"data-cites="Autowired">@Autowired</span> 注解的自动注入</h2><p>依赖注入流程图：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220621225203.png" /></p><p><ahref="https://www.processon.com/view/link/5f899fa5f346fb06e1d8f570">https://www.processon.com/view/link/5f899fa5f346fb06e1d8f570</a></p><p><span class="citation" data-cites="Autowired">@Autowired</span>注解可以写在：</p><ol type="1"><li>属性上：先根据<strong>属性类型</strong>去找Bean，如果找到多个再根据<strong>属性名</strong>确定一个</li><li>构造方法上：先根据方法<strong>参数类型</strong>去找Bean，如果找到多个再根据<strong>参数名</strong>确定一个</li><li>set方法上：先根据方法<strong>参数类型</strong>去找Bean，如果找到多个再根据<strong>参数名</strong>确定一个</li></ol><h3 id="寻找注入点">3.1 寻找注入点</h3><p>在创建一个 Bean 的过程中，Spring 会利用AutowiredAnnotationBeanPostProcessor 的<strong>postProcessMergedBeanDefinition()</strong>找出注入点并缓存，找注入点的流程为：</p><ol type="1"><li>遍历当前类的所有的属性字段 Field</li><li>查看字段上是否存在 <span class="citation"data-cites="Autowired">@Autowired</span>、<span class="citation"data-cites="Value">@Value</span>、<span class="citation"data-cites="Inject">@Inject</span>中的其中任意一个，存在则认为该字段是一个注入点</li><li>如果字段是 static 的，则不进行注入</li><li>获取 <span class="citation" data-cites="Autowired">@Autowired</span>中的 required 属性的值</li><li>将字段信息构造成一个<strong>AutowiredFieldElement对象</strong>，作为一个<strong>注入点对象</strong>添加到currElements 集合中。</li><li>遍历当前类的所有方法 Method</li><li>判断当前 Method是否是<strong>桥接方法</strong>，如果是找到原方法</li><li>查看方法上是否存在 <span class="citation"data-cites="Autowired">@Autowired</span>、<span class="citation"data-cites="Value">@Value</span>、<span class="citation"data-cites="Inject">@Inject</span>中的其中任意一个，存在则认为该方法是一个注入点</li><li>如果方法是 static 的，则不进行注入</li><li>获取 <span class="citation" data-cites="Autowired">@Autowired</span>中的 required 属性的值</li><li>将方法信息构造成一个 <strong>AutowiredMethodElement对象</strong>，作为一个<strong>注入点对象</strong>添加到 currElements集合中。</li><li>遍历完当前类的字段和方法后，将<strong>遍历父类</strong>的，直到没有父类。</li><li>最后将 currElements 集合封装成一个 InjectionMetadata 对象，作为当前Bean 对于的注入点集合对象，并缓存。</li></ol><h4 id="static-的字段或方法为什么不支持">static的字段或方法为什么不支持</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderService</span> </span>&#123;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span>  </span>&#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> OrderService orderService;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test123&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>UserService 和 OrderService 都是原型 Bean，假设 Spring 支持 static字段进行自动注入，那么现在调用两次</p><ol type="1"><li>UserService userService1 = context.getBean("userService")</li><li>UserService userService2 = context.getBean("userService")</li></ol><p>问此时，userService1 的 orderService值是什么？还是它自己注入的值吗？</p><p>答案是不是，一旦 userService2 创建好了之后，static orderService字段的值就发生了修改了，从而出现 bug。</p><h4 id="桥接方法">桥接方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserInterface</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setOrderService</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserInterface</span>&lt;<span class="hljs-title">OrderService</span>&gt; </span>&#123;<br><br><span class="hljs-keyword">private</span> OrderService orderService;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOrderService</span><span class="hljs-params">(OrderService orderService)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.orderService = orderService;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test123&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>UserService对应的字节码为： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>/<span class="hljs-title">debug</span>/<span class="hljs-title">service</span>/<span class="hljs-title">UserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">com</span>/<span class="hljs-title">debug</span>/<span class="hljs-title">service</span>/<span class="hljs-title">UserInterface</span> </span>&#123;<br><br>  <span class="hljs-comment">// compiled from: UserService.java</span><br><br>  <span class="hljs-meta">@Lorg</span>/springframework/stereotype/Component;()<br><br>  <span class="hljs-comment">// access flags 0x2</span><br>  <span class="hljs-keyword">private</span> Lcom/debug/service/OrderService; orderService<br><br>  <span class="hljs-comment">// access flags 0x1</span><br>  <span class="hljs-keyword">public</span> &lt;init&gt;()V<br>   L0<br>    LINENUMBER <span class="hljs-number">12</span> L0<br>    ALOAD <span class="hljs-number">0</span><br>    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V<br>    RETURN<br>   L1<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lcom/debug/service/UserService; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">1</span><br>    MAXLOCALS = <span class="hljs-number">1</span><br><br>  <span class="hljs-comment">// access flags 0x1</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">setOrderService</span><span class="hljs-params">(Lcom/debug/service/OrderService;)</span>V</span><br><span class="hljs-function">  @Lorg/springframework/beans/factory/annotation/Autowired</span>;()<br>   L0<br>    LINENUMBER <span class="hljs-number">19</span> L0<br>    ALOAD <span class="hljs-number">0</span><br>    ALOAD <span class="hljs-number">1</span><br>    PUTFIELD com/debug/service/UserService.orderService : Lcom/debug/service/OrderService;<br>   L1<br>    LINENUMBER <span class="hljs-number">20</span> L1<br>    RETURN<br>   L2<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lcom/debug/service/UserService; L0 L2 <span class="hljs-number">0</span><br>    LOCALVARIABLE orderService Lcom/debug/service/OrderService; L0 L2 <span class="hljs-number">1</span><br>    MAXSTACK = <span class="hljs-number">2</span><br>    MAXLOCALS = <span class="hljs-number">2</span><br><br>  <span class="hljs-comment">// access flags 0x1</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">test</span><span class="hljs-params">()</span>V</span><br><span class="hljs-function">   L0</span><br><span class="hljs-function">    LINENUMBER 23 L0</span><br><span class="hljs-function">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream</span>;<br>    LDC <span class="hljs-string">&quot;test123&quot;</span><br>    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V<br>   L1<br>    LINENUMBER <span class="hljs-number">24</span> L1<br>    RETURN<br>   L2<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lcom/debug/service/UserService; L0 L2 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">2</span><br>    MAXLOCALS = <span class="hljs-number">1</span><br><br>  <span class="hljs-comment">// access flags 0x1041</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge <span class="hljs-title">setOrderService</span><span class="hljs-params">(Ljava/lang/Object;)</span>V</span><br><span class="hljs-function">  @Lorg/springframework/beans/factory/annotation/Autowired</span>;()<br>   L0<br>    LINENUMBER <span class="hljs-number">11</span> L0<br>    ALOAD <span class="hljs-number">0</span><br>    ALOAD <span class="hljs-number">1</span><br>    CHECKCAST com/debug/service/OrderService<br>    INVOKEVIRTUAL com/debug/service/UserService.setOrderService (Lcom/debug/service/OrderService;)V<br>    RETURN<br>   L1<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lcom/debug/service/UserService; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">2</span><br>    MAXLOCALS = <span class="hljs-number">2</span><br>&#125;<br><br></code></pre></td></tr></table></figure></p><p>可以看到在 UserSerivce 的字节码中有两个 setOrderService 方法：</p><ol type="1"><li>public setOrderService(Lcom/debug/service/OrderService;)V</li><li>public synthetic bridge setOrderService(Ljava/lang/Object;)V</li></ol><p>并且都是存在 <span class="citation"data-cites="Autowired">@Autowired</span> 注解的。</p><p>所以在 Spring中需要处理这种情况，当遍历到桥接方法时，得找到原方法。</p><h3 id="注入点进行注入">3.2 注入点进行注入</h3><p>Spring 在 AutowiredAnnotationBeanPostProcessor 的<strong>postProcessPropertyValues()</strong>方法中，会遍历所找到的注入点依次进行注入。</p><h4 id="字段注入">字段注入</h4><ol type="1"><li>遍历所有的 <strong>AutowiredFieldElement 对象。</strong></li><li>将对应的字段封装为 <strong>DependencyDescriptor 对象</strong>。</li><li>调用 BeanFactory 的 <strong>resolveDependency()</strong> 方法，传入<strong>DependencyDescriptor对象</strong>，进行依赖查找，找到当前字段所匹配的 Bean 对象。</li><li>将 <strong>DependencyDescriptor对象</strong>和所找到的<strong>结果对象 beanName</strong> 封装成一个<strong>ShortcutDependencyDescriptor 对象</strong>作为缓存，比如如果当前Bean 是原型 Bean，那么下次再来创建该 Bean 时，就可以直接拿缓存的结果对象beanName 去 BeanFactory 中去拿 bean 对象了，不用再次进行查找了</li><li>利用反射将结果对象赋值给字段。</li></ol><h4 id="方法注入">方法注入</h4><ol type="1"><li>遍历所有的 <strong>AutowiredMethodElement 对象</strong></li><li>遍历将对应的方法的参数，将每个参数封装成 <strong>MethodParameter对象</strong></li><li>将 <strong>MethodParameter 对象</strong>封装为<strong>DependencyDescriptor 对象</strong></li><li>调用 BeanFactory 的 <strong>resolveDependency()</strong> 方法，传入<strong>DependencyDescriptor对象</strong>，进行依赖查找，找到当前方法参数所匹配的 Bean 对象。</li><li>将 <strong>DependencyDescriptor对象</strong>和所找到的<strong>结果对象 beanName</strong> 封装成一个<strong>ShortcutDependencyDescriptor 对象</strong>作为缓存，比如如果当前Bean 是原型 Bean，那么下次再来创建该 Bean 时，就可以直接拿缓存的结果对象beanName 去 BeanFactory 中去拿 bean 对象了，不用再次进行查找了</li><li>利用反射将找到的所有结果对象传给当前方法，并执行。</li></ol><h4id="defaultlistablebeanfactoryresolvedependency-实现流程">DefaultListableBeanFactory#resolveDependency实现流程</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220629224806.png" /></p><p>https://www.processon.com/view/link/5f8d3c895653bb06ef076688</p><h4 id="findautowirecandidates-实现">findAutowireCandidates() 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-function">Object <span class="hljs-title">resolveDependency</span><span class="hljs-params">(DependencyDescriptor descriptor, <span class="hljs-meta">@Nullable</span> String requestingBeanName,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="hljs-meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br></code></pre></td></tr></table></figure><p>该方法表示，传入一个依赖描述（DependencyDescriptor），该方法会根据该依赖描述从BeanFactory 中找出对应的唯一的一个 Bean 对象。</p><ol type="1"><li>找出 BeanFactory 中类型为 type 的所有的 Bean的名字，注意是名字，而不是 Bean 对象，因为我们可以根据 BeanDefinition就能判断和当前 type 是不是匹配，不用生成 Bean 对象</li><li>把 resolvableDependencies 中 key 为 type 的对象找出来并添加到 result中</li><li>遍历根据 type 找出的 beanName，判断当前 beanName 对应的 Bean是不是能够被自动注入</li><li>先判断 beanName 对应的 BeanDefinition 中的 autowireCandidate属性，如果为false，表示不能用来进行自动注入，如果为 true则继续进行判断</li><li>判断当前 type 是不是泛型，如果是泛型是会把容器中所有的 beanName找出来的，如果是这种情况，那么在这一步中就要获取到泛型的真正类型，然后进行匹配，如果当前beanName 和当前泛型对应的真实类型匹配，那么则继续判断</li><li>如果当前 DependencyDescriptor 上存在 <span class="citation"data-cites="Qualifier">@Qualifier</span> 注解，那么则要判断当前 beanName上是否定义了Qualifier，并且是否和当前 DependencyDescriptor 上的Qualifier 相等，相等则匹配</li><li>经过上述验证之后，当前 beanName 才能成为一个可注入的，添加到 result中</li></ol><h4 id="关于依赖注入中泛型注入的实现">关于依赖注入中泛型注入的实现</h4><p>首先在 Java 反射中，有一个 Type 接口，表示类型，具体分类为：</p><ol type="1"><li>raw types：也就是普通 Class</li><li>parameterized types：对应 ParameterizedType 接口，泛型类型</li><li>array types：对应 GenericArrayType，泛型数组</li><li>type variables：对应 TypeVariable接口，表示类型变量，也就是所定义的泛型，比如T、K</li><li>primitive types：基本类型，int、boolean</li></ol><p>大家可以好好看看下面代码所打印的结果： ​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeTest</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">private</span> Integer it;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] iarray;<br><span class="hljs-keyword">private</span> List list;<br><span class="hljs-keyword">private</span> List&lt;String&gt; slist;<br><span class="hljs-keyword">private</span> List&lt;T&gt; tlist;<br><span class="hljs-keyword">private</span> T t;<br><span class="hljs-keyword">private</span> T[] tarray;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException </span>&#123;<br><br>test(TypeTest.class.getDeclaredField(<span class="hljs-string">&quot;i&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>test(TypeTest.class.getDeclaredField(<span class="hljs-string">&quot;it&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>test(TypeTest.class.getDeclaredField(<span class="hljs-string">&quot;iarray&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>test(TypeTest.class.getDeclaredField(<span class="hljs-string">&quot;list&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>test(TypeTest.class.getDeclaredField(<span class="hljs-string">&quot;slist&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>test(TypeTest.class.getDeclaredField(<span class="hljs-string">&quot;tlist&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>test(TypeTest.class.getDeclaredField(<span class="hljs-string">&quot;t&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>test(TypeTest.class.getDeclaredField(<span class="hljs-string">&quot;tarray&quot;</span>));<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Field field)</span> </span>&#123;<br><br><span class="hljs-keyword">if</span> (field.getType().isPrimitive()) &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;是基本数据类型&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;不是基本数据类型&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (field.getGenericType() <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;是泛型类型&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;不是泛型类型&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (field.getType().isArray()) &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;是普通数组&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;不是普通数组&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (field.getGenericType() <span class="hljs-keyword">instanceof</span> GenericArrayType) &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;是泛型数组&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;不是泛型数组&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (field.getGenericType() <span class="hljs-keyword">instanceof</span> TypeVariable) &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;是泛型变量&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;不是泛型变量&quot;</span>);<br>&#125;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>Spring 中，注入点是一个泛型时，也是会进行处理的，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseService</span> &lt;<span class="hljs-title">OrderService</span>, <span class="hljs-title">StockService</span>&gt; </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(o);<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseService</span> &lt;<span class="hljs-title">O</span>, <span class="hljs-title">S</span>&gt; </span>&#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">protected</span> O o;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">protected</span> S s;<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>Spring 扫描时发现 UserService 是一个 Bean</li><li>那就取出注入点，也就是 BaseService 中的两个属性 o、s</li><li>接下来需要按注入点类型进行注入，但是 o 和 s 都是泛型，所以 Spring需要确定 o 和 s 的具体类型。</li><li>因为当前正在创建的是 UserService 的 Bean，所以可以通过<code>userService.getClass().getGenericSuperclass().getTypeName()</code>获取到具体的泛型信息，比如<code>com.debug.service.BaseService&lt;com.debug.service.OrderService, com.debug.service.StockService&gt;</code></li><li>然后再拿到 UserService 的父类 BaseService的泛型变量：<code>for (TypeVariable&lt;? extends Class&lt;?&gt;&gt; typeParameter : userService.getClass().getSuperclass().getTypeParameters()) &#123; System._out_.println(typeParameter.getName()); &#125;</code></li><li>通过上面两段代码，就能知道 o 对应的具体就是 OrderService，s对应的具体类型就是 StockService</li><li>然后再调用 <code>Field.getGenericType()</code> 就知道当前 field使用的是哪个泛型，就能知道具体类型了</li></ol><h4 id="qualifier-的使用"><span class="citation"data-cites="Qualifier">@Qualifier</span> 的使用</h4><p>定义两个注解： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Qualifier(&quot;random&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Random &#123;<br>&#125;<br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Qualifier(&quot;roundRobin&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RoundRobin &#123;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>定义一个接口和两个实现类，表示负载均衡： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LoadBalance</span> </span>&#123;<br><span class="hljs-function">String <span class="hljs-title">select</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Random</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LoadBalance</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">select</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RoundRobin</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoundRobinStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LoadBalance</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">select</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span>  </span>&#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@RoundRobin</span><br><span class="hljs-keyword">private</span> LoadBalance loadBalance;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(loadBalance);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><h2 id="resource">4. <span class="citation"data-cites="Resource">@Resource</span></h2><h3 id="寻找注入点-1">4.1 寻找注入点</h3><p>CommonAnnotationBeanPostProcessor#postProcessMergedBeanDefinition</p><p>将 <span class="citation" data-cites="Resource">@Resource</span>注解的属性和方法作为注入点</p><h3 id="依赖注入">4.2 依赖注入</h3><p><span class="citation"data-cites="Resource注解底层工作流程图">@Resource注解底层工作流程图</span>：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220701002519.png" /></p><p><ahref="https://www.processon.com/view/link/5f91275f07912906db381f6e">https://www.processon.com/view/link/5f91275f07912906db381f6e</a></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——Bean的生命周期</title>
    <link href="/2022/05/28/Spring%E2%80%94%E2%80%94Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2022/05/28/Spring%E2%80%94%E2%80%94Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<p>https://www.processon.com/view/link/629e0d260791293c9388933b</p><p>Spring 最重要的功能就是 IOC，而启动 Spring 就是为创建 Bean对象做准备。</p><p>Bean的生命周期就是指：<strong>在Spring中，一个Bean是如何创建、如何销毁的</strong></p><p>Bean 生命周期流程图：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220529092534.png" /></p><h2 id="bean-扫描">Bean 扫描</h2><h3 id="生成-beandefinition">1. 生成 BeanDefinition</h3><p>Spring 启动的时候会进行扫描，会先调用<code>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#scanCandidateComponents(String basePackage)</code>扫描某个包路径，并得到BeanDefinition 的 Set 集合。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220529094123.png" /></p><p>Spring扫描底层流程：<ahref="https://www.processon.com/view/link/61370ee60e3e7412ecd95d43">https://www.processon.com/view/link/61370ee60e3e7412ecd95d43</a></p><ol type="1"><li>首先，通过 ResourcePatternResolver获得指定包路径下的所有<code>.class</code>文件</li><li>遍历每个 Resource 对象</li><li>利用 MetadataReaderFactory 解析 Resource 对象得到MetadataReader（在Spring源码中MetadataReaderFactory具体的实现类为CachingMetadataReaderFactory，MetadataReader的具体实现类为SimpleMetadataReader）</li><li>利用MetadataReader进行excludeFilters和includeFilters，以及条件注解@Conditional的筛选（条件注解并不能理解：某个类上是否存在@Conditional注解，如果存在则调用注解中所指定的类的match方法进行匹配，匹配成功则通过筛选，匹配失败则pass掉。）</li><li>筛选通过后，基于metadataReader生成ScannedGenericBeanDefinition</li><li>再基于metadataReader判断是不是对应的类是不是接口或抽象类</li><li>如果筛选通过，那么就表示扫描到了一个Bean，将ScannedGenericBeanDefinition加入结果集</li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220529234900.png" /></p><p>MetadataReader表示类的元数据读取器，主要包含了 AnnotationMetadata 和classMetadata，功能有</p><ol type="1"><li>获取类的名字</li><li>获取父类的名字</li><li>获取所实现的所有接口名</li><li>获取所有内部类的名字</li><li>判断是不是抽象类</li><li>判断是不是接口</li><li>判断是不是一个注解</li><li>获取拥有某个注解的方法集合</li><li>获取类上添加的所有注解信息</li><li>获取类上添加的所有注解类型集合</li></ol><p>值得注意的是，CachingMetadataReaderFactory 解析某个 .class 文件得到MetadataReader 对象是利用的 <strong>ASM</strong>技术，并没有加载这个类到 JVM。并且最终得到的ScannedGenericBeanDefinition 对象，<strong>beanClass属性存储的是当前类的名字，而不是 class对象</strong>。（beanClass属性的类型是Object，它即可以存储类的名字，也可以存储class对象）</p><p>最后，上面是通过扫描得到 BeanDefinition 对象，我们还可以通过直接定义BeanDefinition，或解析 spring.xml文件的 <bean/>，或者 <spanclass="citation" data-cites="Bean注解得到">@Bean注解得到</span>BeanDefinition 对象。</p><p>BeanDefinition：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220529235316.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title">doScan</span><span class="hljs-params">(String... basePackages)</span> </span>&#123;<br>Assert.notEmpty(basePackages, <span class="hljs-string">&quot;At least one base package must be specified&quot;</span>);<br>Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();<br><span class="hljs-keyword">for</span> (String basePackage : basePackages) &#123;<br><span class="hljs-comment">// 扫描包路径，得到 BeanDefinition</span><br>Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);<br><span class="hljs-keyword">for</span> (BeanDefinition candidate : candidates) &#123;<br>ScopeMetadata scopeMetadata = <span class="hljs-keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);<br><span class="hljs-comment">// 设置作用域</span><br>candidate.setScope(scopeMetadata.getScopeName());<br><span class="hljs-comment">// 获取 BeanName  前两个字母为大写 BeanName 则为类名</span><br>String beanName = <span class="hljs-keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="hljs-keyword">this</span>.registry);<br><span class="hljs-comment">// 设置 BeanDefinition 默认值</span><br><span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) &#123;<br>postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);<br>&#125;<br><span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) &#123;<br><span class="hljs-comment">// 解析 @lazy、@Primary、@DependsOn、@Role、@Description</span><br>AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);<br>&#125;<br><span class="hljs-comment">// 检查容器中是否存在该 BeanName，返回 false 不会注册进去，如果冲突直接抛出异常</span><br><span class="hljs-keyword">if</span> (checkCandidate(beanName, candidate)) &#123;<br><br>BeanDefinitionHolder definitionHolder = <span class="hljs-keyword">new</span> BeanDefinitionHolder(candidate, beanName);<br><span class="hljs-comment">// 创建 AOP 对象</span><br>definitionHolder =<br>AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-keyword">this</span>.registry);<br>beanDefinitions.add(definitionHolder);<br><span class="hljs-comment">// 注册到 BeanDefinitionMap</span><br>registerBeanDefinition(definitionHolder, <span class="hljs-keyword">this</span>.registry);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> beanDefinitions;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="componentsindex">2. componentsIndex</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220530225830.png" /></p><p>使用 componentsIndex 将不再进行 Bean 扫描。加了 componentsIndex的类还是需要加 <span class="citation"data-cites="Compoent">@Compoent</span></p><p>https://blog.csdn.net/W_317/article/details/117405805https://blog.csdn.net/zzuhkp/article/details/108257764</p><h2 id="bean-的生成过程">Bean 的生成过程</h2><h3 id="合并-beandefinition">1. 合并 BeanDefinition</h3><p>通过扫描得到所有 BeanDefinition 之后，就可以根据 BeanDefinition 创建Bean 对象了，但是在 Spring 中支持父子 BeanDefinition，和 Java父子类类似。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.beans.User&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span> <span class="hljs-attr">abstract</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.Service.UserService&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;user&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>子 BeanDefinition 会继承父 BeanDefinition 的属性，所以 userService是原型的。</p><p>而在根据 userService 来生成 Bean 对象之前，需要进行 BeanDefinition的合并，得到完整的 userService 的 BeanDefinition。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220605111531.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取合并后的 BeanDefinition ( 从父 BeanDefinition 获取自己未定义的属性）</span><br><span class="hljs-comment"> * 合并 BeanDefinition 将生成一个新的 RootBeanDefinition</span><br><span class="hljs-comment"> * 没有父 BeanDefinition 将属性复制到一个新的 RootBeanDefinition</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> RootBeanDefinition <span class="hljs-title">getMergedBeanDefinition</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">String beanName, BeanDefinition bd, <span class="hljs-meta">@Nullable</span> BeanDefinition containingBd)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;<br><br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.mergedBeanDefinitions) &#123;<br>RootBeanDefinition mbd = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-keyword">if</span> (containingBd == <span class="hljs-keyword">null</span>) &#123;<br>mbd = <span class="hljs-keyword">this</span>.mergedBeanDefinitions.get(beanName);<br>&#125;<br><br><span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">// 如果没有父 BeanDefinition 直接深拷贝</span><br><span class="hljs-keyword">if</span> (bd.getParentName() == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">if</span> (bd <span class="hljs-keyword">instanceof</span> RootBeanDefinition) &#123;<br>mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mbd = <span class="hljs-keyword">new</span> RootBeanDefinition(bd);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>BeanDefinition pbd;<br><span class="hljs-keyword">try</span> &#123;<br>String parentBeanName = transformedBeanName(bd.getParentName());<br><span class="hljs-comment">// 递归合并</span><br><span class="hljs-keyword">if</span> (!beanName.equals(parentBeanName)) &#123;<br>pbd = getMergedBeanDefinition(parentBeanName);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>BeanFactory parent = getParentBeanFactory();<br><span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> ConfigurableBeanFactory) &#123;<br>pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchBeanDefinitionException(parentBeanName,<br><span class="hljs-string">&quot;Parent name &#x27;&quot;</span> + parentBeanName + <span class="hljs-string">&quot;&#x27; is equal to bean name &#x27;&quot;</span> + beanName +<br><span class="hljs-string">&quot;&#x27;: cannot be resolved without a ConfigurableBeanFactory parent&quot;</span>);<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(bd.getResourceDescription(), beanName,<br><span class="hljs-string">&quot;Could not resolve parent bean definition &#x27;&quot;</span> + bd.getParentName() + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);<br>&#125;<br>mbd = <span class="hljs-keyword">new</span> RootBeanDefinition(pbd);<br><span class="hljs-comment">// 子 BeanDefinition 覆盖父 BeanDefinition 属性</span><br>mbd.overrideFrom(bd);<br>&#125;<br><br><span class="hljs-keyword">if</span> (!StringUtils.hasLength(mbd.getScope())) &#123;<br>mbd.setScope(SCOPE_SINGLETON);<br>&#125;<br><span class="hljs-comment">// 包含非单例 Bean 的 Bean 本身不能是单例的</span><br><span class="hljs-keyword">if</span> (containingBd != <span class="hljs-keyword">null</span> &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123;<br>mbd.setScope(containingBd.getScope());<br>&#125;<br><br><span class="hljs-comment">// 缓存 BeanDefinition</span><br><span class="hljs-keyword">if</span> (containingBd == <span class="hljs-keyword">null</span> &amp;&amp; isCacheBeanMetadata()) &#123;<br><span class="hljs-keyword">this</span>.mergedBeanDefinitions.put(beanName, mbd);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> mbd;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="加载类">2. 加载类</h3><p>BeanDefinition 合并之后，就可以去创建 Bean 对象了，而创建 Bean就必须实例化对象，而实例化就必须先加载当前 BeanDefinition 所对应的class，在 AbstractAutowireCapableBeanFactory 类的 createBean()方法中，一开始就会调用： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);<br></code></pre></td></tr></table></figure>这行代码就是去加载类，该方法是这么实现的： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (mbd.hasBeanClass()) &#123;<br><span class="hljs-keyword">return</span> mbd.getBeanClass();<br>&#125;<br><span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> AccessController.doPrivileged((PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;) () -&gt;<br>doResolveBeanClass(mbd, typesToMatch), getAccessControlContext());<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> doResolveBeanClass(mbd, typesToMatch);<br>&#125;<br></code></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasBeanClass</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.beanClass <span class="hljs-keyword">instanceof</span> Class);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 beanClass 属性的类型是Class，那么就直接返回，如果不是，则会根据类名进行加载（doResolveBeanClass方法所做的事情）</p><p>会利用 BeanFactory 所设置的类加载器来加载类，如果没有设置，则默认使用<strong>ClassUtils.getDefaultClassLoader()</strong>所返回的类加载器来加载。</p><h4id="classutils.getdefaultclassloader"><strong>ClassUtils.getDefaultClassLoader()</strong></h4><ol type="1"><li>优先返回当前线程中的 ClassLoader</li><li>线程中类加载器为 null 的情况下，返回 ClassUtils 类的类加载器</li><li>如果 ClassUtils 类的类加载器为空，那么则表示是 Bootstrap类加载器加载的 ClassUtils 类，那么则返回系统类加载器</li></ol><h3 id="实例化前">3. 实例化前</h3><p>当前 BeanDefinition 对应的类成功加载后，就可以实例化对象了，但是在Spring 中，实例化对象之前，Spring提供了一个扩展点，允许用户来控制是否在某个或某些 Bean实例化之前做一些启动动作。这个扩展点叫<strong>InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()</strong>。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220603202638.png" /></p><p>【示例】：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InstantiationAwareBeanPostProcessor</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;user&quot;</span>.equals(beanName))&#123;<br>System.out.println(<span class="hljs-string">&quot;实例化前&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码会导致，在 user 这个 Bean 实例化前，会进行打印。</p><p>值得注意的是，postProcessBeforeInstantiation()是有返回值的，如果这么实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InstantiationAwareBeanPostProcessor</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;user&quot;</span>.equals(beanName))&#123;<br>System.out.println(<span class="hljs-string">&quot;实例化前&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>user 这个 Bean，在实例化前会直接返回一个由我们所定义的 user对象。如果是这样，表示不需要 Spring 来实例化了，并且后续的 Spring依赖注入也不会进行了，会跳过一些步骤，直接执行初始化后这一步。</p><h3 id="实例化">4. 实例化</h3><p>在这个步骤中就会根据 BeanDefinition 去创建一个对象了。</p><h4 id="supplier-创建对象">4.1 Supplier 创建对象</h4><p>首先判断 BeanDefinition 中是否设置了 Supplier，如果设置了则调用Supplier 的 get() 得到对象。</p><p>得直接使用 BeanDefinition 对象来设置 Supplier，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();<br>beanDefinition.setInstanceSupplier(<span class="hljs-keyword">new</span> Supplier&lt;Object&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserService();<br>&#125;<br>&#125;);<br>context.registerBeanDefinition(<span class="hljs-string">&quot;userService&quot;</span>, beanDefinition);<br></code></pre></td></tr></table></figure><h4 id="工厂方法创建对象">4.2 工厂方法创建对象</h4><p>如果没有设置 Supplier，则检查 BeanDefinition 中是否设置了factoryMethod，也就是工厂方法，有两种方式可以设置factoryMethod，比如：</p><p>方式一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.zth.service.UserService&quot;</span> factory-method=<span class="hljs-string">&quot;createUserService&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>对应的 UserService 类为： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserService <span class="hljs-title">createUserService</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;执行createUserService()&quot;</span>);<br>UserService userService = <span class="hljs-keyword">new</span> UserService();<br><span class="hljs-keyword">return</span> userService;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><p>方式二： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;commonService&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.zhouyu.service.CommonService&quot;</span>/&gt;<br>&lt;bean id=<span class="hljs-string">&quot;userService1&quot;</span> factory-bean=<span class="hljs-string">&quot;commonService&quot;</span> factory-method=<span class="hljs-string">&quot;createUserService&quot;</span> /&gt;<br></code></pre></td></tr></table></figure> 对应的 CommonService 的类为：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonService</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> UserService <span class="hljs-title">createUserService</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserService();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>Spring 发现当前 BeanDefinition方法设置了工厂方法后，就会区分这两种方式，然后调用工厂方法得到对象。</p><p>值得注意的是，我们通过 <span class="citation"data-cites="Bean">@Bean</span> 所定义的 BeanDefinition，是存在factoryMethod 和 factoryBean 的，也就是和上面的方式二非常类似，<spanclass="citation" data-cites="Bean">@Bean</span> 所注解的方法就是factoryMethod，AppConfig 对象就是 factoryBean。如果 <spanclass="citation" data-cites="Bean">@Bean</span> 所注解的方法是 static的，那么对应的就是方式一。</p><h3 id="推断构造方法">4.3 推断构造方法</h3><p>推断完构造方法后，就会使用构造方法来进行实例化了。</p><p>额外的，在推断构造方法逻辑中除了会去选择构造方法以及查找入参对象意外，还会判断是否在对应的类中是否存在使用<strong><span class="citation"data-cites="Lookup注解">@Lookup注解</span></strong>了方法。如果存在则把该方法封装为 LookupOverride 对象并添加到BeanDefinition 中。</p><p>在实例化时，如果判断出来当前 BeanDefinition 中没有LookupOverride，那就直接用构造方法反射得到一个实例对象。如果存在LookupOverride 对象，也就是类中存在 <span class="citation"data-cites="Lookup">@Lookup</span>注解了的方法，那就会生成一个代理对象。</p><p><span class="citation" data-cites="Lookup">@Lookup</span>注解就是<strong>方法注入</strong>，使用 demo 如下： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> OrderService orderService;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>OrderService orderService = createOrderService();<br>System.out.println(orderService);<br>&#125;<br><br><span class="hljs-meta">@Lookup(&quot;orderService&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> OrderService <span class="hljs-title">createOrderService</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="beandefinition-的后置处理">5. BeanDefinition 的后置处理</h3><p>Bean对象实例化出来之后，接下来就应该给对象的属性赋值了。在真正给属性赋值之前，Spring又提供了一个扩展点<strong>MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition()</strong>，可以对此时的BeanDefinition 进行加工，比如设置初始化方法或设置属性等等。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220603232841.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugMergedBeanDefinitionPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MergedBeanDefinitionPostProcessor</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessMergedBeanDefinition</span><span class="hljs-params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;userService&quot;</span>.equals(beanName)) &#123;<br>beanDefinition.getPropertyValues().add(<span class="hljs-string">&quot;orderService&quot;</span>, <span class="hljs-keyword">new</span> OrderService());<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Spring 源码中，AutowiredAnnotationBeanPostProcessor 就是一个MergedBeanDefinitionPostProcessor，它的postProcessMergedBeanDefinition() 中会去查找注入点，并缓存在AutowiredAnnotationBeanPostProcessor 对象的一个 Map中（injectionMetadataCache）。</p><h3 id="实例化后">6. 实例化后</h3><p>在处理完 BeanDefinition 后，Spring又设计了一个扩展点：<strong>InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()</strong>，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">DebugInstantiationAwareBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InstantiationAwareBeanPostProcessor</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">postProcessAfterInstantiation</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;userService&quot;</span>.equals(beanName)) &#123;<br>UserService userService = (UserService) bean;<br>userService.test();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码就是对 userService 所实例化出来的对象进行处理。</p><p>返回 false 不在执行其他 postProcessAfterInstantiation。</p><h3 id="依赖注入">7. 依赖注入</h3><p>https://debuggingworld.github.io/2022/04/18/Spring%E2%80%94%E2%80%94IOC%E7%9A%84%E4%BD%BF%E7%94%A8/#%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5</p><p>这里的自动注入指的是 Spring 的自动注入。</p><h3 id="填充属性后">8. 填充属性后</h3><p>这个步骤中，就会处理 <span class="citation"data-cites="Autowired">@Autowired</span>、<span class="citation"data-cites="Resource">@Resource</span>、<span class="citation"data-cites="Value">@Value</span> 等注解，也是通过<strong>InstantiationAwareBeanPostProcessor.postProcessProperties()</strong>扩展点来实现的，比如我们可以实现一个自己的自动注入功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugInstantiationAwareBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InstantiationAwareBeanPostProcessor</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> PropertyValues <span class="hljs-title">postProcessProperties</span><span class="hljs-params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;userService&quot;</span>.equals(beanName)) &#123;<br><span class="hljs-keyword">for</span> (Field field : bean.getClass().getFields()) &#123;<br><span class="hljs-keyword">if</span> (field.isAnnotationPresent(DebugInject.class)) &#123;<br>field.setAccessible(<span class="hljs-keyword">true</span>);<br><span class="hljs-keyword">try</span> &#123;<br>field.set(bean, <span class="hljs-string">&quot;123&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> pvs;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="执行aware">9. 执行Aware</h3><p>完成了属性赋值之后，Spring 会执行一些回调，包括：</p><ol type="1"><li>BeanNameAware：回传beanName给bean对象。</li><li>BeanClassLoaderAware：回传classLoader给bean对象。</li><li>BeanFactoryAware：回传beanFactory给对象。</li></ol><h3 id="初始化前">10. 初始化前</h3><p>初始化前，也是 Spring提供的一个扩展点：<strong>BeanPostProcessor.postProcessBeforeInitialization()</strong>，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;userService&quot;</span>.equals(beanName)) &#123;<br>System.out.println(<span class="hljs-string">&quot;初始化前&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> bean;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用初始化前，可以对进行了依赖注入的Bean进行处理。</p><p>在Spring源码中：</p><ol type="1"><li>InitDestroyAnnotationBeanPostProcessor 会在初始化前这个步骤中执行<span class="citation" data-cites="PostConstruct">@PostConstruct</span>的方法，</li><li>ApplicationContextAwareProcessor 会在初始化前这个步骤中进行其他Aware 的回调：<ol type="1"><li>EnvironmentAware：回传环境变量</li><li>EmbeddedValueResolverAware：回传占位符解析器</li><li>ResourceLoaderAware：回传资源加载器</li><li>ApplicationEventPublisherAware：回传事件发布器</li><li>MessageSourceAware：回传国际化资源</li><li>ApplicationStartupAware：回传应用其他监听对象，可忽略</li><li>ApplicationContextAware：回传Spring容器ApplicationContext</li></ol></li></ol><h3 id="初始化">11. 初始化</h3><ol type="1"><li>查看当前 Bean 对象是否实现了 InitializingBean接口，如果实现了就调用其 afterPropertiesSet() 方法</li><li>执行 BeanDefinition 中指定的初始化方法</li></ol><h3 id="初始化后">12. 初始化后</h3><p>这是 Bean 创建生命周期中的最后一个步骤，也是 Spring提供的一个扩展点：<strong>BeanPostProcessor.postProcessAfterInitialization()</strong>，比如：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;userService&quot;</span>.equals(beanName)) &#123;<br>System.out.println(<span class="hljs-string">&quot;初始化后&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> bean;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure> 可以在这个步骤中，对 Bean 最终进行处理，Spring中的<strong>AOP就是基于初始化后实现</strong>的，<strong>初始化后返回的对象才是最终的Bean 对象</strong>。</p><h3 id="总结-beanpostprocessor">13. 总结 BeanPostProcessor</h3><ol type="1"><li>InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()<ol type="1"><li>实例化</li></ol></li><li>MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition()</li><li>InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()</li><li>自动注入</li><li>InstantiationAwareBeanPostProcessor.postProcessProperties()</li><li>Aware对象</li><li>BeanPostProcessor.postProcessBeforeInitialization()</li><li>初始化</li><li>BeanPostProcessor.postProcessAfterInitialization()</li></ol><h2 id="bean的销毁过程">Bean的销毁过程</h2><p>Bean 销毁是发生在 Spring 容器关闭过程中。</p><p>在 Spring 容器关闭时，比如： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br>UserService userService = (UserService) context.getBean(<span class="hljs-string">&quot;userService&quot;</span>);<br>userService.test();<br><br><span class="hljs-comment">// 容器关闭</span><br>context.close();<br></code></pre></td></tr></table></figure> 或者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br><span class="hljs-comment">// 注册关闭钩子</span><br>context.registerShutdownHook();<br>UserService userService = ((UserService) context.getBean(<span class="hljs-string">&quot;userService&quot;</span>));<br>userService.test();<br></code></pre></td></tr></table></figure><p>在 Bean创建过程中，在最后（初始化之后），有一个步骤会去判断当前创建的 Bean是不是 DisposableBean：</p><ol type="1"><li>当前 Bean 是否实现了 DisposableBean 接口</li><li>当前 Bean 是否实现了 AutoCloseable 接口</li><li>BeanDefinition 中是否指定了 destroyMethod</li><li>调用 DestructionAwareBeanPostProcessor.requiresDestruction(bean)进行判断<ul><li>ApplicationListenerDetector 中直接使得 ApplicationListener 是DisposableBean</li><li>InitDestroyAnnotationBeanPostProcessor 中使得拥有 <spanclass="citation" data-cites="PreDestroy">@PreDestroy</span>注解了的方法就是 DisposableBean</li></ul></li><li>把符合上述任意一个条件的 Bean 适配成 DisposableBeanAdapter对象，并存入 disposableBeans 中（一个LinkedHashMap）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DestructionAwareBeanPostProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeforeDestruction</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">requiresDestruction</span><span class="hljs-params">(Object bean)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Spring 容器关闭过程是：</p><ol type="1"><li>首先发布 ContextClosedEvent 事件</li><li>调用 lifecycleProcessor 的 onCloese() 方法</li><li>销毁单例 Bean<ol type="1"><li>遍历 disposableBeans<ul><li>把每个 disposableBean 从单例池中移除</li><li>如果这个 disposableBean 还被其他 Bean 依赖了，那么也得销毁其他Bean</li><li>调用 disposableBean 的 destroy()</li><li>如果这个 disposableBean 还包含了 inner beans，将这些 Bean从单例池中移除掉 (inner bean参考<ahref="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-inner-beans">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-inner-beans</a>)</li><li>清空 containedBeanMap</li><li>清空 dependentBeanMap</li><li>清空 dependenciesForBeanMap</li></ul></li><li>清空 manualSingletonNames，是一个 Set，存的是用户手动注册的单例 Bean的 beanName</li><li>清空 allBeanNamesByType，是一个 Map，key 是 bean 类型，value是该类型所有的 beanName 数组</li><li>清空 singletonBeanNamesByType，和 allBeanNamesByType类似，只不过只存了单例 Bean</li></ol></li></ol><p>这里涉及到一个设计模式：<strong>适配器模式</strong> 将实现了DisposableBean 接口、或者 AutoCloseable 接口等适配成实现了DisposableBean 接口，所以就用到了 DisposableBeanAdapter。</p><p>在销毁时，Spring 会找出实现了 DisposableBean 接口的 Bean。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——底层架构核心概念</title>
    <link href="/2022/05/02/Spring%E2%80%94%E2%80%94%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/05/02/Spring%E2%80%94%E2%80%94%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="beandefinition">1. BeanDefinition</h3><p>BeanDefinition 表示 Bean 定义，BeanDefinition中存在很多属性用来描述一个 Bean 的特点。比如：</p><ul><li>beanClass：表示 Bean 类型</li><li>scope：表示 Bean 作用域，单例或原型等</li><li>lazyInit：表示 Bean 是否是懒加载</li><li>initMethodName：表示 Bean 初始化时要执行的方法</li><li>destroyMethodName：表示 Bean 销毁时要执行的方法</li><li>……</li></ul><p>在 Spring 中，经常会通过以下几种方式来定义Bean：</p><ol type="1"><li>&lt;bean/&gt;</li><li><span class="citation" data-cites="Bean">@Bean</span></li><li><span class="citation"data-cites="Component">@Component</span>(<span class="citation"data-cites="Service">@Service</span>,<span class="citation"data-cites="Controller">@Controller</span>)</li></ol><p>这些，称之<strong>申明式定义Bean</strong>。</p><p>我们还可以<strong>编程式定义Bean</strong>，那就是直接通过BeanDefinition，比如： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br><br>AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();<br>beanDefinition.setBeanClass(User.class);<br>beanDefinition.setLazyInit(<span class="hljs-keyword">true</span>);<br>beanDefinition.setScope(<span class="hljs-string">&quot;prototype&quot;</span>);<br>context.registerBeanDefinition(<span class="hljs-string">&quot;user&quot;</span>,beanDefinition);<br><br>System.out.println(context.getBean(User.class));<br></code></pre></td></tr></table></figure></p><p>和申明式事务、编程式事务类似，通过 &lt;bean/&gt;，<spanclass="citation" data-cites="Bean">@Bean</span>，<span class="citation"data-cites="Component">@Component</span> 等申明式方式所定义的Bean，最终都会被 Spring 解析为对应的BeanDefinition 对象，并放入Spring容器中。</p><h3 id="beandefinitionreader">2. BeanDefinitionReader</h3><p>BeanDefinition 读取器（BeanDefinitionReader）</p><h4 id="annotatedbeandefinitionreader">2.1AnnotatedBeanDefinitionReader</h4><p>可以直接把某个类转换为 BeanDefinition，并且会解析该类上的注解，比如<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br><br>AnnotatedBeanDefinitionReader annotatedBeanDefinitionReader = <span class="hljs-keyword">new</span> AnnotatedBeanDefinitionReader(context);<br>annotatedBeanDefinitionReader.registerBean(User.class);<br><br>System.out.println(context.getBean(User.class));<br></code></pre></td></tr></table></figure></p><p>注意：它能解析的注解是：<span class="citation"data-cites="Conditional">@Conditional</span>、 <strong>@Scope</strong>、<span class="citation" data-cites="Lazy">@Lazy</span>、<spanclass="citation" data-cites="Primary">@Primary</span>、<spanclass="citation" data-cites="DependsOn">@DependsOn</span>、<spanclass="citation" data-cites="Role">@Role</span>、<span class="citation"data-cites="Description">@Description</span></p><h4 id="xmlbeandefinitionreader">2.2 XmlBeanDefinitionReader</h4><p>可以解析<bean/>标签 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br><br>XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader(context);<br>xmlBeanDefinitionReader.loadBeanDefinitions(<span class="hljs-string">&quot;debug.xml&quot;</span>);<br><br>System.out.println(context.getBean(User.class));<br></code></pre></td></tr></table></figure></p><h3 id="classpathbeandefinitionscanner">3ClassPathBeanDefinitionScanner</h3><p>ClassPathBeanDefinitionScanner 是扫描器，但是它的作用和BeanDefinitionReader类似，它可以进行扫描，扫描某个包路径，对扫描到的类进行解析，比如扫描到的类上如果存在<span class="citation" data-cites="Component">@Component</span>注解，那么就会把这个类解析为一个BeanDefinition。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();<br>context.refresh();<br><br>ClassPathBeanDefinitionScanner classPathBeanDefinitionScanner = <span class="hljs-keyword">new</span> ClassPathBeanDefinitionScanner(context);<br>classPathBeanDefinitionScanner.scan(<span class="hljs-string">&quot;com.zth&quot;</span>);<br><br>System.out.println(context.getBean(User.class));<br></code></pre></td></tr></table></figure><p><ahref="https://www.jianshu.com/p/52f96a333e9b">ClassPathBeanDefinitionScanner</a></p><p>### 4. BeanFactory</p><p>BeanFactory 表示 Bean <strong>工厂</strong>，BeanFactory 负责创建Bean，并且提供获取 Bean 的 API。</p><p>在 Spring 中，BeanFactory接口最重要的实现类是：<strong>DefaultListableBeanFactory</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">DefaultListableBeanFactory beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();<br><br>AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();<br>beanDefinition.setBeanClass(User.class);<br>beanFactory.registerBeanDefinition(<span class="hljs-string">&quot;user&quot;</span>, beanDefinition);<br><br>System.out.println(beanFactory.getBean(User.class));<br></code></pre></td></tr></table></figure><p><strong>DefaultListableBeanFactory是非常强大的，支持很多功能，可以通过查看DefaultListableBeanFactory的类继承实现结构来看</strong></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220517223724.png" /></p><p>它实现了很多接口： 1.AliasRegistry：支持别名功能，一个名字可以对应多个别名 1.BeanDefinitionRegistry：可以注册、保存、移除、获取某个 BeanDefinition 1.BeanFactory：Bean工厂，可以根据 bean 的名字、类型、别名获取 Bean 对象 1.SingletonBeanRegistry：可以直接注册、获取某个<strong>单例</strong> Bean1. SimpleAliasRegistry：它是一个类，实现了 AliasRegistry接口，支持别名功能 1. ListableBeanFactory：在 BeanFactory的基础上，增加了其他功能，可以获取所有 BeanDefinition 的beanNames，可以根据某个类型获取对应的 beanNames，可以根据某个类型获取{类型：对应的 Bean } 的映射关系 1. HierarchicalBeanFactory：在BeanFactory 的基础上，添加了获取父 BeanFactory 的功能 1.DefaultSingletonBeanRegistry：它是一个类，实现了 SingletonBeanRegistry接口，拥有了直接注册、获取某个<strong>单例</strong> Bean 的功能 1.ConfigurableBeanFactory：在 HierarchicalBeanFactory 和SingletonBeanRegistry 的基础上，添加了设置父BeanFactory、类加载器（表示可以指定某个类加载器进行类的加载）、设置Spring EL 表达式解析器（表示该 BeanFactory 可以解析 EL表达式）、设置类型转化服务（表示该 BeanFactory可以进行类型转化）、可以添加 BeanPostProcessor（表示该 BeanFactory 支持Bean 的后置处理器），可以合并 BeanDefinition，可以销毁某个 Bean 等等功能1. FactoryBeanRegistrySupport：支持了 FactoryBean 的功能 1.AutowireCapableBeanFactory：是直接继承了 BeanFactory，在 BeanFactory的基础上，支持在创建 Bean 的过程中能对 Bean 进行自动装配 1.AbstractBeanFactory：实现了 ConfigurableBeanFactory 接口，继承了FactoryBeanRegistrySupport，这个 BeanFactory的功能已经很全面了，但是不能自动装配和获取 beanNames 1.ConfigurableListableBeanFactory：继承了ListableBeanFactory、AutowireCapableBeanFactory、ConfigurableBeanFactory1. AbstractAutowireCapableBeanFactory：继承了AbstractBeanFactory，实现了AutowireCapableBeanFactory，拥有了自动装配的功能 1.DefaultListableBeanFactory：继承了AbstractAutowireCapableBeanFactory，实现了ConfigurableListableBeanFactory 接口和BeanDefinitionRegistry 接口，所以DefaultListableBeanFactory 的功能很强大</p><h3 id="applicationcontext">5. ApplicationContext</h3><p>ApplicationContext 是 BeanFactory 的一种，在 Spring源码中，是这么定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EnvironmentCapable</span>, <span class="hljs-title">ListableBeanFactory</span>, <span class="hljs-title">HierarchicalBeanFactory</span>,</span><br><span class="hljs-class"><span class="hljs-title">MessageSource</span>, <span class="hljs-title">ApplicationEventPublisher</span>, <span class="hljs-title">ResourcePatternResolver</span> </span>&#123;<br><br>            ...<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，在Java中，接口是可以<strong>多继承</strong>的，ApplicationContext继承了 ListableBeanFactory 和HierarchicalBeanFactory，而ListableBeanFactory 和HierarchicalBeanFactory 都继承至 BeanFactory，所以 ApplicationContext继承了 BeanFactory。</p><p>当 new 一个 ApplicationContext 时，其底层会 new 一个 BeanFactory出来，当使用 ApplicationContext 的某些方法时，比如getBean()，底层调用的是 BeanFactory 的 getBean() 方法。</p><p>ApplicationContext 是个接口，实际上也是一个 BeanFactory，不过比BeanFactory 更加强大，比如：</p><ol type="1"><li>HierarchicalBeanFactory：拥有获取父 BeanFactory 的功能</li><li>ListableBeanFactory：拥有获取 beanNames 的功能</li><li>ResourcePatternResolver：资源加载器，可以一次性获取多个资源</li><li>EnvironmentCapable：可以获取运行时环境（没有设置运行时环境功能）</li><li>ApplicationEventPublisher：拥有广播事件的功能（没有添加事件监听器的功能）</li><li>MessageSource：拥有国际化功能</li></ol><h4 id="annotationconfigapplicationcontext">5.1AnnotationConfigApplicationContext</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220518215301.png" /></p><ol type="1"><li>ConfigurableApplicationContext：继承了 ApplicationContext接口，增加了事件监听器、添加BeanFactoryPostProcessor、设置Environment，获取ConfigurableListableBeanFactory等功能</li><li>AbstractApplicationContext：实现了 ConfigurableApplicationContext接口</li><li>GenericApplicationContext：继承了 AbstractApplicationContext，实现了BeanDefinitionRegistry 接口，拥有了所有 ApplicationContext的功能，并且可以注册BeanDefinition，注意这个类中有一个属性<strong>DefaultListableBeanFactory</strong></li><li>AnnotationConfigRegistry：可以单独注册某个为类为BeanDefinition（可以处理该类上的 <strong><span class="citation"data-cites="Configuration">@Configuration</span></strong>注解，已经可以处理<strong><spanclass="citation"data-cites="Bean注解">@Bean注解</span></strong>），同时可以扫描</li><li>AnnotationConfigApplicationContext：继承了GenericApplicationContext，实现了 AnnotationConfigRegistry接口，拥有了以上所有的功能</li></ol><h4 id="classpathxmlapplicationcontext">5.2ClassPathXmlApplicationContext</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220518222613.png" /></p><p>它也是继承了 AbstractApplicationContext，但是相对于AnnotationConfigApplicationContext 而言，功能没有AnnotationConfigApplicationContext 强大，比如不能注册BeanDefinition。</p><h4 id="国际化">5.3 国际化</h4><p>先定义一个 MessageSource： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> MessageSource <span class="hljs-title">messageSource</span><span class="hljs-params">()</span></span>&#123;<br>       ResourceBundleMessageSource messageSource = <span class="hljs-keyword">new</span> ResourceBundleMessageSource();<br>       messageSource.setBasename(<span class="hljs-string">&quot;msg&quot;</span>);<br>       <span class="hljs-keyword">return</span> messageSource;<br>   &#125;<br><br><span class="hljs-meta">@Service</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageService</span> </span>&#123;<br>   <br>       <span class="hljs-meta">@Autowired</span><br>       <span class="hljs-keyword">private</span> MessageSource messageSource;<br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Locale local = <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">&quot;en_US&quot;</span>);<br>   <br>   <br>       <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">(String key)</span> </span>&#123;<br>           <span class="hljs-keyword">return</span> messageSource.getMessage(key, <span class="hljs-keyword">null</span>, key, local);<br>       &#125;<br>   <br>   &#125;<br><br></code></pre></td></tr></table></figure></p><p>同时，因为 ApplicationContext也拥有国际化的功能，所以可以直接这么用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需要注入 MessageSource</span><br>context.getMessage(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">&quot;en_US&quot;</span>));<br></code></pre></td></tr></table></figure><p>https://www.jianshu.com/p/69f5a19468db</p><h4 id="资源加载">5.4 资源加载</h4><p>ApplicationContext 还拥有资源加载的功能，可以直接利用ApplicationContext 获取某个文件的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br><br>    Resource resource = context.getResource(<span class="hljs-string">&quot;G:\\debugSpring\\src\\main\\java\\com\\zth\\debugSpring\\App.java&quot;</span>);<br>    System.out.println(resource.getFilename());<br><br>    Resource resource2 = context.getResource(<span class="hljs-string">&quot;classpath:dbConfig.properties&quot;</span>);<br>    System.out.println(resource2.contentLength());<br>    System.out.println(resource2.getURL());<br><br>    Resource resource1 = context.getResource(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>);<br>    System.out.println(resource1.contentLength());<br>    System.out.println(resource1.getURL());<br><br>    <span class="hljs-comment">// 一次性获取多个</span><br>    Resource[] resources = context.getResources(<span class="hljs-string">&quot;classpath:com/zth/*/*.class&quot;</span>);<br>    <span class="hljs-keyword">for</span> (Resource res : resources) &#123;<br>        System.out.println(res.getFilename());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="获取运行时环境">5.5 获取运行时环境</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br><br>    <span class="hljs-comment">// 操作系统环境变量</span><br>    Map&lt;String, Object&gt; systemEnvironment = context.getEnvironment().getSystemEnvironment();<br>    System.out.println(systemEnvironment);<br><br>    <span class="hljs-comment">// JVM 启动时指定的环境变量</span><br>    Map&lt;String, Object&gt; systemProperties = context.getEnvironment().getSystemProperties();<br>    System.out.println(systemProperties);<br><br>    <span class="hljs-comment">// 变量集</span><br>    MutablePropertySources propertySources = context.getEnvironment().getPropertySources();<br>    System.out.println(propertySources);<br><br>    <span class="hljs-comment">// 获取指定变量</span><br>    System.out.println(context.getEnvironment().getProperty(<span class="hljs-string">&quot;driverClassName&quot;</span>));<br>    System.out.println(context.getEnvironment().getProperty(<span class="hljs-string">&quot;sun.jnu.encoding&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，可以利用 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PropertySource(&quot;classpath:dbConfig.properties&quot;)</span><br></code></pre></td></tr></table></figure> 加载 properties文件中的参数到运行时环境中。</p><h4 id="事件发布">5.6 事件发布</h4><p>先定义一个事件监听器 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ApplicationListener <span class="hljs-title">applicationListener</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApplicationListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ApplicationEvent event)</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;接收到事件&quot;</span>+event.getSource());<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>然后发布一个事件： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">context.publishEvent(<span class="hljs-string">&quot;hello debuggingWorld&quot;</span>);<br></code></pre></td></tr></table></figure>https://www.cnblogs.com/rickiyang/p/12001524.html</p><h3 id="类型转化">6. 类型转化</h3><p>在 Spring源码中，有可能需要把String转成其他类型，所以在Spring源码中提供了一些技术来更方便的做对象的类型转化，关于类型转化的应用场景，后续看源码的过程中会遇到很多。</p><h4 id="propertyeditor">6.1 PropertyEditor</h4><p>这其实是 JDK 中提供的类型转化工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br>    String name;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringToTeacherPropertyEditor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PropertyEditorSupport</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PropertyEditor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAsText</span><span class="hljs-params">(String text)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException </span>&#123;<br>        Teacher teacher = <span class="hljs-keyword">new</span> Teacher();<br>        teacher.setName(text);<br>        <span class="hljs-keyword">this</span>.setValue(teacher);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    StringToTeacherPropertyEditor propertyEditor = <span class="hljs-keyword">new</span> StringToTeacherPropertyEditor();<br>    propertyEditor.setAsText(<span class="hljs-string">&quot;debugging&quot;</span>);<br>    Teacher teacher = (Teacher) propertyEditor.getValue();<br>    System.out.println(teacher);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如何向 Spring 中注册 PropertyEditor：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> CustomEditorConfigurer <span class="hljs-title">customEditorConfigurer</span><span class="hljs-params">()</span> </span>&#123;<br>    CustomEditorConfigurer customEditorConfigurer = <span class="hljs-keyword">new</span> CustomEditorConfigurer();<br>    Map&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt; propertyEditorMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <br>    <span class="hljs-comment">// 表示 StringToTeacherPropertyEditor 可以将 String 转化成 Teacher 类型</span><br>    <span class="hljs-comment">// 在 Spring 源码中，如果发现当前对象是 String，而需要的类型是 User，就会使用该 PropertyEditor 来做类型转化</span><br>    propertyEditorMap.put(Teacher.class, StringToTeacherPropertyEditor.class);<br>    customEditorConfigurer.setCustomEditors(propertyEditorMap);<br>    <span class="hljs-keyword">return</span> customEditorConfigurer;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设现在有如下Bean： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ToString</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br>    Integer age;<br>    <span class="hljs-meta">@Value(&quot;debugging&quot;)</span><br>    Teacher teacher;<br><br>&#125;<br></code></pre></td></tr></table></figure> 那么 <span class="citation"data-cites="Value">@Value</span> 就能正常的完成属性赋值。</p><h4 id="conversionservice">6.2 ConversionService</h4><p>Spring 中提供的类型转化服务，它比 PropertyEditor更强大（可以将任意类型转化为目标类型）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringToTeacherConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ConditionalGenericConverter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;<br>        <span class="hljs-comment">// 源类型是 String 目标类型是 Teacher 时进行转换</span><br>        <span class="hljs-keyword">return</span> sourceType.getType().equals(String.class) &amp;&amp; targetType.getType().equals(Teacher.class);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="hljs-title">getConvertibleTypes</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Collections.singleton(<span class="hljs-keyword">new</span> ConvertiblePair(String.class, Teacher.class));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">convert</span><span class="hljs-params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;<br>        Teacher teacher = <span class="hljs-keyword">new</span> Teacher();<br>        teacher.setName((String) source);<br>        <span class="hljs-keyword">return</span> teacher;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单独使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    DefaultConversionService conversionService = <span class="hljs-keyword">new</span> DefaultConversionService();<br>    conversionService.addConverter(<span class="hljs-keyword">new</span> StringToTeacherConverter());<br>    Teacher value = conversionService.convert(<span class="hljs-string">&quot;debugging&quot;</span>, Teacher.class);<br>    System.out.println(value);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>向Spring中注册 ConversionService：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ConversionServiceFactoryBean <span class="hljs-title">conversionService</span><span class="hljs-params">()</span> </span>&#123;<br>    ConversionServiceFactoryBean conversionServiceFactoryBean = <span class="hljs-keyword">new</span> ConversionServiceFactoryBean();<br>    conversionServiceFactoryBean.setConverters(Collections.singleton(<span class="hljs-keyword">new</span> StringToTeacherConverter()));<br>    <span class="hljs-keyword">return</span> conversionServiceFactoryBean;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="typeconverter">6.3 TypeConverter</h4><p>整合了 PropertyEditor 和 ConversionService 的功能，Spring内部使用此种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SimpleTypeConverter typeConverter = <span class="hljs-keyword">new</span> SimpleTypeConverter();<br>    <span class="hljs-comment">//typeConverter.registerCustomEditor(Teacher.class, new StringToTeacherPropertyEditor());</span><br><br>    DefaultConversionService conversionService = <span class="hljs-keyword">new</span> DefaultConversionService();<br>    conversionService.addConverter(<span class="hljs-keyword">new</span> StringToTeacherConverter());<br>    typeConverter.setConversionService(conversionService);<br><br>    Teacher value = typeConverter.convertIfNecessary(<span class="hljs-string">&quot;debugging&quot;</span>, Teacher.class);<br>    System.out.println(value);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="ordercomparator">7. OrderComparator</h3><p>OrderComparator 是 Spring 所提供的一种比较器，可以用来根据实现Ordered 接口来执行比较，从而可以进行排序。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Ordered</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getClass().getSimpleName();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Ordered</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getClass().getSimpleName();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    A a = <span class="hljs-keyword">new</span> A(); <span class="hljs-comment">// order=3</span><br>    B b = <span class="hljs-keyword">new</span> B(); <span class="hljs-comment">// order=2</span><br><br>    OrderComparator comparator = <span class="hljs-keyword">new</span> OrderComparator();<br>    System.out.println(comparator.compare(a, b));  <span class="hljs-comment">// 1</span><br><br>    List list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(a);<br>    list.add(b);<br>    <span class="hljs-comment">// 按 order 值升序排序</span><br>    list.sort(comparator);<br><br>    System.out.println(list);  <span class="hljs-comment">// B，A</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>另外，Spring 中还提供了一个 OrderComparator的子类：<strong>AnnotationAwareOrderComparator</strong>，它支持用 <spanclass="citation" data-cites="Order">@Order</span> 来指定 order值。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Order(3)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getClass().getSimpleName();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Order(2)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getClass().getSimpleName();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    A a = <span class="hljs-keyword">new</span> A(); <span class="hljs-comment">// order=3</span><br>    B b = <span class="hljs-keyword">new</span> B(); <span class="hljs-comment">// order=2</span><br><br>    OrderComparator comparator = <span class="hljs-keyword">new</span> AnnotationAwareOrderComparator();<br>    System.out.println(comparator.compare(a, b));  <span class="hljs-comment">// 1</span><br><br>    List list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(a);<br>    list.add(b);<br>    <span class="hljs-comment">// 按 order 值升序排序</span><br>    list.sort(comparator);<br><br>    System.out.println(list);  <span class="hljs-comment">// B，A</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="beanpostprocessor">8. BeanPostProcessor</h3><p>BeanPostProcess 表示 Bean的后置处理器，我们可以定义一个或多个BeanPostProcessor。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebuggingBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;userService&quot;</span>.equals(beanName)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;初始化前&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;userService&quot;</span>.equals(beanName)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;初始化后&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个 BeanPostProcessor 可以在<strong>任意一个 Bean</strong> 的<strong>初始化之前</strong>以及<strong>初始化之后</strong>去额外的做一些用户自定义的逻辑，当然我们可以通过判断 beanName来进行针对性处理（针对某个Bean，或某部分Bean）。</p><p>通过定义 BeanPostProcessor 来干涉 Spring 创建 Bean 的过程。</p><h3 id="beanfactorypostprocessor">9. BeanFactoryPostProcessor</h3><p>BeanFactoryPostProcessor 表示 Bean 工厂的后置处理器，其实和BeanPostProcessor 类似，BeanPostProcessor 是干涉 Bean的创建过程，BeanFactoryPostProcessor 是干涉 BeanFactory 的创建过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebuggingBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;加工 beanFactory&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以在postProcessBeanFactory()方法中对BeanFactory进行加工。</p><p>BeanFactoryPostProcessor 是在 spring 容器加载了 bean的定义文件之后。</p><p>作用： 1. 在 bean 实例化之前执行的。可以用来对工厂内部的beanDefinitionMap 中的 Bean 定义的属性进行修改和填充。 2.类中属性使用配置文件的定义来自动填充时，使PropertySourcesPlaceholderConfigurer 会自动读取配置文件，并且填充到BEANDEFINE 的属性中。 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;conf.properties&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;people1&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">alias</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;people1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.tpw.newday.bean.PeopleBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;p1.name&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></p><h3 id="factorybean">10. FactoryBean</h3><p>通过 FactoryBean 可以来控制 Bean 的创造过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebuggingFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserService();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;<br>        <span class="hljs-keyword">return</span> UserService.class;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br><br>    <span class="hljs-comment">// com.zth.debugSpring.service.UserService@303cf2ba</span><br>    System.out.println(context.getBean(<span class="hljs-string">&quot;debuggingFactoryBean&quot;</span>)); <br>    <span class="hljs-comment">// com.zth.debugSpring.config.DebuggingFactoryBean@76494737</span><br>    System.out.println(context.getBean(<span class="hljs-string">&quot;&amp;debuggingFactoryBean&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>在容器启动过程中，加了 <span class="citation"data-cites="Component">@Component</span> 的类不管是不是实现了FactoryBean 接口，都会扫描为 BeanDefinition 并生成单例 Bean放到单例池中（类型为 DebuggingFactoryBean）。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220525211710.png" /></p><p>getBean() 中先从单例池拿到 FactoryBean 对象实例，然后判断是不是FactoryBean，如果是则调用 getObject() 获取 Bean，然后缓存到factoryBeanObjectCache。</p><p>调用 getBean() 之前：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220525214615.png" /></p><p>调用 getBean() 之后：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220525214933.png" /></p><p>通过上面的 DebuggingFactoryBean 我们自己创造了一个 UserService对象，并且它将成为 Bean。但是通过这种方式创造出来的 UserService 的 Bean<strong>只会经过初始化后（postProcessAfterInitialization）</strong>（为了实现AOP），其他 Spring 的生命周期步骤是不会经过的，比如依赖注入。</p><p><span class="citation" data-cites="Bean">@Bean</span> 定义的 Bean是会经过完整的 Bean 生命周期的。</p><h3 id="excludefilter-和-includefilter">11. ExcludeFilter 和IncludeFilter</h3><p>这两个 Filter 是 Spring 扫描过程中用来过滤的。ExcludeFilter表示<strong>排除过滤器</strong>，IncludeFilter表示<strong>包含过滤器</strong>。</p><p><ahref="https://debuggingworld.github.io/2022/04/18/Spring%E2%80%94%E2%80%94IOC%E7%9A%84%E4%BD%BF%E7%94%A8/#3-1-%E7%B1%BB%E8%B7%AF%E5%BE%84%E6%89%AB%E6%8F%8F">（传送门）</a></p><p>比如以下配置，表示扫描 com.debugging 这个包下面的所有类，但是排除UserService 类，就算它上面有 <span class="citation"data-cites="Component">@Component</span> 注解也不会成为 Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(value = &quot;com.debugging&quot;,</span><br><span class="hljs-meta">excludeFilters = &#123;@ComponentScan.Filter(</span><br><span class="hljs-meta">            type = FilterType.ASSIGNABLE_TYPE, </span><br><span class="hljs-meta">            classes = UserService.class)&#125;.)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>再比如以下配置，就算 UserService 类上没有 <span class="citation"data-cites="Component">@Component</span> 注解，它也会被扫描成为一个Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(value = &quot;com.debugging&quot;,</span><br><span class="hljs-meta">includeFilters = &#123;@ComponentScan.Filter(</span><br><span class="hljs-meta">            type = FilterType.ASSIGNABLE_TYPE, </span><br><span class="hljs-meta">            classes = UserService.class)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Spring 的扫描逻辑中，默认会添加一个 AnnotationTypeFilter 给includeFilters，表示默认情况下 Spring 扫描过程中会认为类上有@Component注解的就是 Bean。</p><p>ClassPathScanningCandidateComponentProvider.registerDefaultFilters()：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerDefaultFilters</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 注册 @Component 对应的 AnnotationTypeFilter</span><br><span class="hljs-keyword">this</span>.includeFilters.add(<span class="hljs-keyword">new</span> AnnotationTypeFilter(Component.class));<br><br>ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">this</span>.includeFilters.add(<span class="hljs-keyword">new</span> AnnotationTypeFilter(<br>((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="hljs-string">&quot;javax.annotation.ManagedBean&quot;</span>, cl)), <span class="hljs-keyword">false</span>));<br>logger.debug(<span class="hljs-string">&quot;JSR-250 &#x27;javax.annotation.ManagedBean&#x27; found and supported for component scanning&quot;</span>);<br>&#125;<br><span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br><span class="hljs-comment">// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.</span><br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">this</span>.includeFilters.add(<span class="hljs-keyword">new</span> AnnotationTypeFilter(<br>((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="hljs-string">&quot;javax.inject.Named&quot;</span>, cl)), <span class="hljs-keyword">false</span>));<br>logger.debug(<span class="hljs-string">&quot;JSR-330 &#x27;javax.inject.Named&#x27; annotation found and supported for component scanning&quot;</span>);<br>&#125;<br><span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br><span class="hljs-comment">// JSR-330 API not available - simply skip.</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="metadatareaderclassmetadataannotationmetadata">12.MetadataReader、ClassMetadata、AnnotationMetadata</h3><p>在 Spring中需要去解析类的信息，比如类名、类中的方法、类上的注解，这些都可以称之为类的元数据，所以Spring 中对类的元数据做了抽象，并提供了一些工具类。</p><p>MetadataReader 表示类的元数据读取器，默认实现类为<strong>SimpleMetadataReader</strong>。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    SimpleMetadataReaderFactory simpleMetadataReaderFactory = <span class="hljs-keyword">new</span> SimpleMetadataReaderFactory();<br>    <span class="hljs-comment">// 构造一个MetadataReader</span><br>    MetadataReader metadataReader = simpleMetadataReaderFactory.getMetadataReader(<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span>);<br>    <span class="hljs-comment">// 得到一个ClassMetadata，并获取了类名</span><br>    ClassMetadata classMetadata = metadataReader.getClassMetadata();<br>    System.out.println(classMetadata.getClassName());<br><br>    <span class="hljs-comment">// 获取一个AnnotationMetadata，并获取类上的注解信息</span><br>    AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();<br>    <span class="hljs-keyword">for</span> (String annotationType : annotationMetadata.getAnnotationTypes()) &#123;<br>        System.out.println(annotationType);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，SimpleMetadataReader去解析类时，使用的<strong>ASM技术</strong>。</p><p>为什么要使用 ASM 技术，Spring启动的时候需要去扫描，如果指定的包路径比较宽泛，那么扫描的类是非常多的，那如果在Spring 启动时就把这些类全部加载进 JVM 了，这样不太好，所以使用了 ASM技术。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——IOC的使用</title>
    <link href="/2022/04/18/Spring%E2%80%94%E2%80%94IOC%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/04/18/Spring%E2%80%94%E2%80%94IOC%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="简介">1. 简介</h3><ul><li>spring 是一个轻量级的开源框架。</li><li>spring 为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题</li><li>spring提供给了丰富的功能，这些功能都依赖于它的两个核心特性——IOC、AOP</li></ul><h4 id="spring-的优点">1.1 spring 的优点</h4><ol type="1"><li>Spring 通过 DI、AOP 和消除样板代码来简化企业级开发</li><li>Spring 框架之外还存在一个构建在核心框架之上的庞大生态圈，它将 Spring扩展到不同的领域，如 Web服务、REST、移动开发以及 NoSQL</li><li>低侵入式设计，代码的污染极低</li><li>独立于各种应用服务器，基于 Spring 框架的应用，可以真正实现 WriteOnce,Run Anywhere的承诺</li><li>Spring 的 IoC容器降低了业务对象替换的复杂性，提高了组件之间的解耦</li><li>Spring 的 AOP支持允许将一些通用任务如安全、事务、日志等进行集中式处理，从而提供了更好的复用</li><li>Spring 的 ORM 和 DAO 提供了与第三方持久层框架的的良好整合，并简化了底层的数据库访问</li><li>Spring 的高度开放性，并不强制应用完全依赖于 Spring，开发者可自由选用Spring 框架的部分或全部</li></ol><h4 id="spring-的模块划分">1.2 spring 的模块划分</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/WPS图片打印_wps_doc_0.png" /></p><ul><li>Test：Spring 的单元测试模块</li><li>Core Container：核心容器模块</li><li>AOP+Aspects：面向切面编程模块</li><li>Instrumentation：提供了classinstrumentation支持和类加载器的实现来在特定的应用服务器上使用</li><li>Messaging：包括一系列的用来映射消息到方法的注解</li><li>DataAccess/Integration：数据的获取/整合模块，包括了JDBC,ORM,OXM,JMS和事务模块</li><li>Web：提供面向 web 整合特性</li></ul><h4 id="ioc">1.3 IOC</h4><p>把创建和查找依赖对象的控制权交给 Spring 容器，由 Spring容器进行注入、组合对象之间的关系。这样对象与对象之间是松耦合、功能可复用（减少对象的创建和内存消耗），使得程序的整个体系结构可维护性、灵活性、扩展性变高。所谓IOC ，就简短一句话：对象由 spring 来创建、管理，装配！</p><p>IOC 和 DI 是从不同的角度描述的同一件事，IOC 是从容器的角度描述，而 DI是从应用程序的角度来描述，也可以这样说，IOC 是依赖倒置原则的设计思想，而DI 是具体的实现方式</p><h4 id="容器">1.4 容器</h4><p>ApplicationContext 是 Spring IoC容器实现的代表，它负责实例化、配置和组装 Bean。容器通过读取配置元数据获取有关实例化、配置和组装哪些对象的说明。配置元数据可以使用 XML、Java注解或J ava代码来呈现。它允许你处理应用程序的对象与其他对象之间的互相依赖关系。</p><ul><li>使用 xml 配置 简单、直观</li><li>基于注解的配置 <span class="citation"data-cites="Compont">@Compont</span>(<span class="citation"data-cites="serivce">@serivce</span> <span class="citation"data-cites="controller">@controller</span> <span class="citation"data-cites="repository">@repository</span>) <span class="citation"data-cites="Autowride">@Autowride</span> Spring 2.5支持基于注解的元数据配置</li><li>基于Java的配置: <span class="citation"data-cites="Confiration">@Confiration</span> <span class="citation"data-cites="Bean">@Bean</span> <span class="citation"data-cites="Import">@Import</span> 从 Spring 3.0 开始, 由 SpringJavaConfig 项目提供的功能已经成为Spring核心框架的一部分。因此可以使用Java 配置来代替 XML 配置定义外部 bean. 从 spring4.0 开始支持springboot1.0 之后 springboot 完全采用 javaConfig 的方式进行开发。</li></ul><h3 id="基于-xml-配置">2. 基于 XML 配置</h3><p>maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.21.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220418232434.png" /></p><h4 id="配置-bean">2.1 配置 bean</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    使用 name 可以设置别名</span><br><span class="hljs-comment">    使用空格或者，或者； 设置多个别名</span><br><span class="hljs-comment">    别名和 id 一样唯一确定一个 bean</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user2 user3,user4;user5&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--设置Bean的别名--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;user6&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    使用 import 可以导入其他 spring 的 xml 配置文件</span><br><span class="hljs-comment">    导入配置中的 bean 和当前配置文件中的 bean 重名，则会覆盖当前配置文件中的 bean</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;dao.xml&quot;</span>/&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;entity.xml&quot;</span>,<span class="hljs-string">&quot;services.xml&quot;</span>);<br>        User user = context.getBean(<span class="hljs-string">&quot;user&quot;</span>, User.class);<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="实例化-bean">2.2 实例化 Bean</h4><ul><li>使用构造器实例化 <font color="red">默认</font>如果不指定构造器参数，默认调用无参构造器实例化Bean。(不指定且没有无参构造器编译报错)</li><li>使用静态工厂方法实例化 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createUserFactory&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> User <span class="hljs-title">createUserFactory</span><span class="hljs-params">()</span></span>&#123;<br>    User user = <span class="hljs-keyword">new</span> User();<br>    user.setName(<span class="hljs-string">&quot;debug&quot;</span>);<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用实例工厂方法实例化 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.UserFactory&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userFactory&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;userFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createUserFactory&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  User <span class="hljs-title">createUserFactory</span><span class="hljs-params">()</span></span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        user.setName(<span class="hljs-string">&quot;debug&quot;</span>);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> #### 2.3 依赖##### 依赖注入</li></ul><p><strong>基于setter方法的依赖注入：</strong> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 基于 setter 方法的依赖注入</span><br><span class="hljs-comment">1. 属性必须声明了set 方法</span><br><span class="hljs-comment">2. name 是根据 set 方法的名字来的 比如方法名字是： setName ‐&gt; name=&quot;name&quot;</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debuggingWorld&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><strong>基于构造函数的依赖注入：</strong> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 基于构造函数的依赖注入</span><br><span class="hljs-comment"> 1. 将会调用自定义构造函数来实例化对象，就不会调用默认的无参构造函数</span><br><span class="hljs-comment"> 2. name 是根据构造函数的参数名来的， 比如：User(String idxx) ‐&gt; name=&quot;idxx&quot;</span><br><span class="hljs-comment"> 3. name 属性可以省略 但是要注意参数的位置</span><br><span class="hljs-comment"> 4. 如果非要把位置错开 可以使用 name 或者 index 或者 type</span><br><span class="hljs-comment"> 5. index 是下标 从 0 开始</span><br><span class="hljs-comment"> 6. type 在位置错开情况下只能在类型不一样的时候指定才有明显效果</span><br><span class="hljs-comment">  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debuggingWorld&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></p><h5 id="依赖和配置的细节">依赖和配置的细节</h5><ul><li>直接值（基本类型，String 等）</li><li>对其他 bean 的引用(装配)</li><li>内部 bean</li><li>集合</li><li>null 和空的字符串值</li><li>使用 p 命名空间简化基于 setter 属性注入</li><li>使用 c 命名空间简化基于构造函数的属性注入</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">p:teacher-ref</span>=<span class="hljs-string">&quot;teacher&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debuggingWorld&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 设置 null 值 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 当依赖其他bean: 内部 bean inner bean</span><br><span class="hljs-comment">    &lt;property name=&quot;teacher&quot;&gt;</span><br><span class="hljs-comment">        &lt;bean class=&quot;com.zth.debugSpring.entity.Teacher&quot;&gt;</span><br><span class="hljs-comment">            &lt;property name=&quot;name&quot; value=&quot;tony&quot;/&gt;</span><br><span class="hljs-comment">        &lt;/bean&gt;</span><br><span class="hljs-comment">    &lt;/property&gt;</span><br><span class="hljs-comment">    --&gt;</span><br><br>    <span class="hljs-comment">&lt;!--当依赖其他 bean: 引用外部 bean</span><br><span class="hljs-comment">    &lt;property name=&quot;teacher&quot; ref=&quot;teacher&quot;/&gt;</span><br><span class="hljs-comment">    --&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbies&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>抽烟<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>喝酒<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>烫头<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.Teacher&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teacher&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;tony&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 可以使用 p 命名空间来简化基于 setter 属性注入 它不支持集合 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.Teacher&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teach2&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;法外狂徒&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 可以使用 c 命名空间来简化基于构造函数属性注入 它不支持集合 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;zhangSan&quot;</span> <span class="hljs-attr">c:name</span>=<span class="hljs-string">&quot;zhangSan&quot;</span> <span class="hljs-attr">c:age</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--&lt;constructor-arg name=&quot;name&quot; value=&quot;zhangSan&quot;/&gt;</span><br><span class="hljs-comment">    &lt;constructor-arg name=&quot;age&quot; value=&quot;20&quot;/&gt;--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="depends-on-属性">depends-on 属性</h6><p>使用 depends‐on 可以设置先加载的 Bean，也就是控制 bean的加载顺序。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">depends-on</span>=<span class="hljs-string">&quot;teacher&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debuggingWorld&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.Teacher&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teacher&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h6 id="懒加载-bean">懒加载 bean</h6><p>使用 lazy‐init 设置懒加载 false（默认值）: 在 spring容器创建的时候加载（实例化） true:在使用的时候(getBean)才会去加载（实例化）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">lazy-init</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debuggingWorld&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="自动注入">自动注入</h6><p>当一个对象中需要引用另外一个对象的时候，在之前的配置中我们都是通过property 标签来进行手动配置的，其实在 spring中还提供了一个非常强大的功能就是自动装配，可以按照指定的规则进行配置，配置的方式有以下几种：+ default/no：不自动装配 + byName：会根据属性 setxxx 方法去掉 set的名字来自动匹配，如果找不到则装配 null +byType：按照类型进行装配，以属性的类型作为查找依据去容器中找到这个组件，如果有多个类型相同的bean 对象，那么会报异常，如果找不到则装配 null +constructor：优先根据构造器参数名字来找，如果名字没有匹配到根据类型来匹配， 如果类型匹配到多个则不会自动注入。</p><blockquote><p>当根据类型匹配到多个 bean 时： 1. 通过将 autowire-candidate属性设置为 false（放弃被注入的机会） 2. 通过将 primary 属性设置为true，将单个 bean 定义指定为主要候选项。</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.Teacher&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;张三&quot;</span>  <span class="hljs-attr">autowire-candidate</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.Teacher&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teacher2&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;lisi&quot;</span> <span class="hljs-attr">primary</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><br></code></pre></td></tr></table></figure><p>Spring 自带的自动注入 <span class="citation"data-cites="Bean">@Bean</span> 方式： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(autowire = Autowire.BY_NAME)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> UserService <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserService();<br>&#125;<br></code></pre></td></tr></table></figure></p><p>【注】Spring 自带的自动注入是在 Bean 实例化后注入的（需要 Setter的支持），而 <span class="citation"data-cites="Autowired">@Autowired</span>、<span class="citation"data-cites="Resource">@Resource</span> 是通过 BeanPostProcessor实现的。</p><h4 id="bean-的作用域">2.4 Bean 的作用域</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220420211227.png" /></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.Teacher&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;张三&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>默认情况下，低层的 Bean 工厂中只支持 singleton 及 prototype两种类型的 Bean。当把 scope 设置成 request 及 session时将会出现不能正确识别 Scope 的错误。这是因为普通的 Bean工厂都没有注册新的 Scope。只有在 WebApplicationContext中注册才注册了新类型的 Bean。</p></blockquote><h4 id="生命周期回调">2.5 生命周期回调</h4><p>从 Spring 2.5 开始，有三种选择用于控制 bean 生命周期行为：</p><ul><li>InitializingBean 和 DisposableBean 回调接口</li><li>自定义 init() 和 destroy() 方法</li><li><span class="citation"data-cites="PostConstruct">@PostConstruct</span> 和 <spanclass="citation" data-cites="PreDestroy">@PreDestroy</span> 注解</li></ul><p>如果 bean配置了多个生命周期机制，而且每个机制都配置了不同的方法名字时，每个配置的方法会按照以下描述的顺序来执行。但是，如果配置了相同的名字，例如初始化回调为init()，在不止一个生命周期机制配置为这个方法的情况下，这个方法只会执行一次。</p><p>为同一个 bean配置的多个生命周期机制具有不同的初始化方法，如下所示:</p><ol type="1"><li>包含 <span class="citation"data-cites="PostConstruct">@PostConstruct</span> 注解的方法</li><li>在 InitializingBean 接口中的 afterPropertiesSet() 方法</li><li>自定义的 init() 方法</li><li>包含 <span class="citation"data-cites="PreDestroy">@PreDestroy</span> 注解的方法</li><li>在 DisposableBean 接口中的 destroy() 方法</li><li>自定义的 destroy() 方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span>, <span class="hljs-title">DisposableBean</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;User.destroy&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;User.afterPropertiesSet&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMethod</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;User.initMethod&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroyMethod</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;User.destroyMethod&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postConstruct</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;User.postConstruct&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preDestroy</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;User.preDestroy&quot;</span>);<br>    &#125;<br><span class="hljs-comment">// ....</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;initMethod&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroyMethod&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>测试： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ClassPathXmlApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;entity.xml&quot;</span>);<br>    User user = context.getBean(<span class="hljs-string">&quot;user&quot;</span>, User.class);<br>    context.close();<br>&#125;<br></code></pre></td></tr></table></figure> 执行结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220420223447.png" /></p><h4 id="aware接口">2.6 Aware接口</h4><p>Aware 接口是为了能够感知到自身的一些属性。 比如实现了ApplicationContextAware 接口的类，能够获取到 ApplicationContext，实现了BeanFactoryAware 接口的类，能够获取到 BeanFactory 对象。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220422223033.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanNameAware</span> </span>&#123;<br><br>    String beanName;<br>    String name;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanName</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.beanName = s;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="bean-定义的继承">2.7 Bean 定义的继承</h4><p>bean定义可以包含许多配置信息，包括构造函数参数，属性值和特定于容器的信息，例如初始化方法，静态工厂方法名称等。子bean定义从父定义继承配置数据。子定义可以覆盖某些值或根据需要添加其他值。使用父子bean定义可以节省很多配置输入。 实际上，这是一种模板形式。</p><p>子bean如果没有指定class，它将使用父bean定义的class。但也可以进行重写。在后一种情况中，子bean必须与父bean兼容，也就是说，它必须接受父bean的属性值。</p><p>子bean定义从父类继承作用域、构造器参数、属性值和可重写的方法，除此之外，还可以增加新值。开发者指定任何作用域、初始化方法、销毁方法和/或者静态工厂方法设置都会覆盖相应的父bean设置。</p><p>剩下的设置会取子bean定义：依赖、自动注入模式、依赖检查、单例、延迟加载。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">bean 的继承 一个 bean 继承另一个 bean </span><br><span class="hljs-comment">可以使用 parent 属性指定父类 bean</span><br><span class="hljs-comment">如果想让父类 bean 不能被实例化 abstract=&quot;true&quot;</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;张三&quot;</span> <span class="hljs-attr">p:age</span>=<span class="hljs-string">&quot;18&quot;</span> <span class="hljs-attr">abstract</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user2&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;lisi&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;user&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="容器的扩展点">2.8 容器的扩展点</h4><h5 id="使用-beanpostprocessor-自定义-bean">使用 BeanPostProcessor自定义 Bean</h5><h5 id="使用-beanfactorypostprocessor-自定义元数据配置">使用BeanFactoryPostProcessor 自定义元数据配置</h5><h5 id="使用-factorybean-自定义初始化逻辑">使用 FactoryBean自定义初始化逻辑</h5><h4 id="spring-创建第三方-bean-对象">2.9 spring 创建第三方 bean对象</h4><ol type="1"><li>导入数据库连接池的 pom 依赖 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.45<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>编写配置文件 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/debuggingworld?useSSL=false&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>测试 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>    ClassPathXmlApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;entity.xml&quot;</span>);<br>    DruidDataSource dataSource = context.getBean(<span class="hljs-string">&quot;dataSource&quot;</span>, DruidDataSource.class);<br>    System.out.println(dataSource);<br>    System.out.println(dataSource.getConnection());<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="spring-引用外部配置文件">2.10 spring 引用外部配置文件</h4><ol type="1"><li>在 resource 中添加 dbconfig.properties <figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">name</span>=root<br><span class="hljs-attr">password</span>=mysql<br><span class="hljs-attr">url</span>=jdbc:mysql://localhost:<span class="hljs-number">3306</span>/debuggingworld?useSSL=<span class="hljs-literal">false</span><br><span class="hljs-attr">driverClassName</span>=com.mysql.jdbc.Driver<br></code></pre></td></tr></table></figure></li><li>编写配置文件 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml">   <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">加载外部配置文件</span><br><span class="hljs-comment">在加载外部依赖文件的时候需要 context 命名空间</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:dbConfig.properties&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;name&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driverClassName&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="spel-的使用">2.11 SpEL 的使用</h4><p>SpEL:Spring Expression Language,spring的表达式语言，支持运行时查询操作对象使用 #{...}作为语法规则，所有的大括号中的字符都认为是SpEL.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.Teacher&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;法外狂徒&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.Student&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--可以引用其他bean的某个属性值--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;#&#123;teacher.name&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--支持任何运算符--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;#&#123;9*2&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--‐引用其他bean--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;#&#123;teacher&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--调用静态方法--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbies&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;#&#123;T(java.util.UUID).randomUUID().toString().substring(0,4)&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--调用非静态方法--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;grade&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;#&#123;teacher.getName()&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="基于注解配置">3. 基于注解配置</h3><p>使用注解将一个类注册为 Bean 的步骤： 1. 设置包扫描 2.对应的类名上加对应的注解</p><h4 id="类路径扫描">3.1 类路径扫描</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.zth.debugSpring&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    base-package：需要扫描的包</span><br><span class="hljs-comment">            排除扫描：exclude-filter</span><br><span class="hljs-comment">            包含扫描：include-filter</span><br><span class="hljs-comment">            type：1. annotation  默认 根据注解的完整限定名设置排除、包含</span><br><span class="hljs-comment">                  2. assignable 根据类的完整限定名设置排除、包含</span><br><span class="hljs-comment">                  3. aspectj 根据切面表达式设置排除、包含</span><br><span class="hljs-comment">                  4. regex 根据正则表达式设置排除、包含</span><br><span class="hljs-comment">                  5. custom 根据 org.springframework.core.type.filter.TypeFilter 接口设置排除、包含</span><br><span class="hljs-comment">            use-default-filters：默认 true ，默认包含扫描 @Component, @Repository,@Service, @Controller, 或 @Configuration</span><br><span class="hljs-comment">                                 false：不扫描 @Component, @Repository,@Service, @Controller, 或 @Configuration</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;regex&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;.*entity.*&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Repository&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure><p>等效于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.zth.debugSpring&quot;,</span><br><span class="hljs-meta">        includeFilters = @ComponentScan.Filter(type = FilterType.REGEX,pattern = &quot;.*entity.*&quot;),</span><br><span class="hljs-meta">        excludeFilters = @ComponentScan.Filter(Repository.class))</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>&#123;<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="注册-bean-到-ioc-容器中">3.2 注册 bean 到 IOC 容器中</h4><p>如果想要将自定义的 bean 对象添加到 IOC容器中，需要在类上添加某些注解。Spring 中包含 4 个主要的组件添加注解： +<span class="citation"data-cites="Controller">@Controller</span>：将控制层的类注册为 Bean +<span class="citation"data-cites="Service">@Service</span>：将业务逻辑层的类注册为 Bean +<span class="citation"data-cites="Repository">@Repository</span>：将数据访问层的类注册为 Bean+ <span class="citation"data-cites="Component">@Component</span>：将非三层的普通类注册为Bean</p><p>不是非要每个层对应相应的注解： 1. 增强可读性 2. 利于 Spring 管理</p><blockquote><p>注意：使用注解注册组件和使用配置文件注册组件是一样的，但是要注意： 1.组件的 id 默认就是组件的类名首字符小写，也可在注解中修改 2.组件默认情况下都是单例的，如果需要配置多例模式的话，可以在注解下添加<span class="citation" data-cites="Scope注">@Scope注</span> 解</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;stu&quot;)</span><br><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br>    Integer age;<br>    Teacher teacher;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="required-注解">3.3 <span class="citation"data-cites="Required">@Required</span> 注解</h4><p>在检查 javabean 中的某些属性是否一定有值的时候，可以通过 <spanclass="citation" data-cites="Required">@Required</span> 来实现。</p><p><span class="citation" data-cites="Required">@Required</span>注解只检查属性是否已经设置而不会测试属性是否非空</p><ol type="1"><li>只能在 setter 方法上加 <span class="citation"data-cites="Required">@Required</span></li><li>如果任何带有 <span class="citation"data-cites="Required">@Required</span> 的属性未设置的话 将会抛出BeanInitializationException 异常</li></ol><p>使用 <span class="citation" data-cites="Required">@Required</span>时需要开启 RequiredAnnotationBeanPostProcessor。 开启方式： +配置文件添加 <context:annotation-config /> 标签 + 注册RequiredAnnotationBeanPostProcessor <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></p><blockquote><p><strong><context:annotation-config /> 标签的作用</strong></p><p>当我们需要使用 BeanPostProcessor 时，直接在 Spring 配置文件中定义这些Bean 显得比较笨拙. 例如： + 使用 <span class="citation"data-cites="Autowired">@Autowired</span> 注解，必须事先在 Spring容器中声明 AutowiredAnnotationBeanPostProcessor 的 Bean： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure>+ 使用 <span class="citation" data-cites="Required">@Required</span>注解，就必须声明 RequiredAnnotationBeanPostProcessor 的 Bean：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure> + 使用 <span class="citation"data-cites="Resource">@Resource</span>、<span class="citation"data-cites="PostConstruct">@PostConstruct</span>、<span class="citation"data-cites="PreDestroy">@PreDestroy</span> 等注解就必须声明CommonAnnotationBeanPostProcessor 的 Bean； + 使用 <spanclass="citation"data-cites="PersistenceContext">@PersistenceContext</span>注解，就必须声明 PersistenceAnnotationBeanPostProcessor 的 Bean。</p><p>为了简化配置，Spring为提供了一种极为方便注册这些BeanPostProcessor的方式，即使用&lt;context:annotation-config/&gt;隐式地向 Spring容器注册AutowiredAnnotationBeanPostProcessor、RequiredAnnotationBeanPostProcessor、CommonAnnotationBeanPostProcessor以及PersistenceAnnotationBeanPostProcessor这 4 个 BeanPostProcessor。</p><p><context:component-scan base-package=”xx.xx”/>包含了自动注入上述Bean的功能，如果前者已存在&lt;context:annotation-config/&gt; 可以省略。</p></blockquote><h4 id="自动注入-1">3.4 自动注入</h4><h5 id="autowired"><span class="citation"data-cites="AutoWired">@AutoWired</span></h5><p>可以使用 JSR 330 的 <span class="citation"data-cites="Inject">@Inject</span> 注解代替 <span class="citation"data-cites="Autowired">@Autowired</span> 注解</p><p><strong>使用位置：</strong> 1. 可以用在构造器上 从 Spring 4.3开始，如果目标 bean 仅定义一个构造函数，则不再需要 <spanclass="citation" data-cites="Autowired">@Autowired</span>构造函数。如果有多个构造函数可用，则至少有一个必须注解 <spanclass="citation" data-cites="Autowired">@Autowired</span>使容器知道它使用的是哪个 2. 用在 setter 方法上 3. 用于普通方法 4.用于字段 5. 字段、setter方法、构造函数之间混用 6. 用在数组上注入全部指定类型 bean 7. 用于集合类型 注入全部指定类型 bean</p><p><font color="red">使用 AutoWired自动注入时，默认优先根据类型匹配，如果匹配到多个 bean 则会按照名字（添加AutoWired 属性的名字） 匹配，如果名字没匹配到则会报错。</font></p><p>默认情况下，当没有候选的 bean 可用时，自动注入将会失败；可设置属性required=false ，没有候选 bean 时忽略。也可用 <span class="citation"data-cites="Required注解来代替">@Required注解来代替</span>。</p><p><span class="citation" data-cites="AutoWired">@AutoWired</span>匹配到多个值解决办法： 1. 修改属性的名字来对应 bean 的名字 2. 修改 bean的名字来对应属性的名字 <span class="citation"data-cites="Component">@Component</span>("name") 3. 通过 <spanclass="citation" data-cites="Qualifier">@Qualifier</span>("name")修改注入属性的名字 4. 通过 <span class="citation"data-cites="Primary">@Primary</span> 设置其中一个 bean 优先注入 5.使用泛型作为自动注入限定符</p><h6 id="使用泛型作为自动装配限定符">使用泛型作为自动装配限定符</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfiguration</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringStore <span class="hljs-title">stringStore</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StringStore();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IntegerStore <span class="hljs-title">integerStore</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IntegerStore();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设上面的bean都实现了泛型接口,即Store&lt;String&gt;和Store&lt;Integer&gt;,那么可以用@Autowire来注解Store接口, 并将泛型用作限定符，如下例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> Store&lt;String&gt; s1; <span class="hljs-comment">// &lt;String&gt; qualifier, injects the stringStore bean</span><br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> Store&lt;Integer&gt; s2; <span class="hljs-comment">// &lt;Integer&gt; qualifier, injects the integerStore bean</span><br></code></pre></td></tr></table></figure><p>通用限定符也适用于自动装配列表，Map实例和数组。以下示例自动装配通用List： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Inject all Store beans as long as they have an &lt;Integer&gt; generic</span><br><span class="hljs-comment">// Store&lt;String&gt; beans will not appear in this list</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> List&lt;Store&lt;Integer&gt;&gt; s;<br></code></pre></td></tr></table></figure></p><h5 id="resource"><span class="citation"data-cites="Resource">@Resource</span></h5><p><span class="citation" data-cites="AutoWired">@AutoWired</span> 和<span class="citation" data-cites="Resource">@Resource</span> 的区别</p><ol type="1"><li><span class="citation" data-cites="AutoWired">@AutoWired</span> 是spring 中提供的注解，<span class="citation"data-cites="Resource">@Resource</span> 是 jdk 中定义的解，依靠的是 java的标准</li><li><span class="citation" data-cites="AutoWired">@AutoWired</span>优先按照类型进行装配，<span class="citation"data-cites="Resource">@Resource</span>优先按照名字进行匹配的，同时可以指定 name 属 性</li></ol><p>https://blog.51cto.com/u_12012821/2510609</p><h4 id="value">3.5 <span class="citation"data-cites="Value">@Value</span></h4><p>用于设置依赖注入的属性值</p><ol type="1"><li>硬编码值</li><li>${} 引用外部配置文件值</li><li>#{} spel 表达式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;userName&#125;&quot;)</span><br>String name;<br>Integer age;<br><span class="hljs-meta">@Value(&quot;#&#123;teacher&#125;&quot;)</span><br>Teacher teachers;<br></code></pre></td></tr></table></figure><h4 id="jsr-330-标准注解">3.6 JSR 330 标准注解</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220425231313.png" /></p><p>注解依赖： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.inject<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.inject<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ManagedBean(&quot;lee&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br>……<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><br>    Teacher teachers;<br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTeachers</span><span class="hljs-params">(<span class="hljs-meta">@Named(&quot;lee&quot;)</span> Teacher teacher)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.teachers = teacher;<br>    &#125;<br>……<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="基于-java-配置">4. 基于 java 配置</h3><p>Spring 基于 Java 配置的核心内容是 <span class="citation"data-cites="Configuration">@Configuration</span> 注解的类和 <spanclass="citation" data-cites="Bean">@Bean</span> 注解的方法。</p><p><span class="citation" data-cites="Bean">@Bean</span>注解用于表明方法的实例化、配置和初始化都是由 Spring IoC容器管理的新对象，<span class="citation"data-cites="Bean注解扮演的角色与">@Bean注解扮演的角色与</span> XML配置的 <beans/> 元素相同。可以在任意的Spring <span class="citation"data-cites="Component">@Component</span> 中使用 <span class="citation"data-cites="Bean">@Bean</span> 注解方法 ，但大多数情况下，<spanclass="citation" data-cites="Bean">@Bean</span> 是配合 <spanclass="citation" data-cites="Configuration">@Configuration</span>使用的。</p><p>使用 <span class="citation"data-cites="Configuration">@Configuration</span>注解类时，这个类的目的就是作为 bean 定义的地方。此外，<spanclass="citation" data-cites="Configuration">@Configuration</span>类允许通过调用同一个类中的其他 <span class="citation"data-cites="Bean">@Bean</span> 方法来定义 bean 间依赖关系，而不能使用<span class="citation" data-cites="Component">@Component</span> 类声明bean 间依赖关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">student</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Student(teacher());<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Teacher <span class="hljs-title">teacher</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Teacher();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="使用-annotationconfigapplicationcontext-初始化-spring-容器">4.1使用 AnnotationConfigApplicationContext 初始化 Spring 容器</h5><p>AnnotationConfigApplicationContext 是在 Spring 3.0 中引入的，不仅能解析 <span class="citation"data-cites="Configuration">@Configuration</span> 注解类 ,也能解析 <spanclass="citation" data-cites="Component">@Component</span> 注解的类和使用JSR-330 注解的类。</p><ul><li>当使用 <span class="citation"data-cites="Configuration">@Configuration</span> 类作为输入时 <spanclass="citation" data-cites="Configuration">@Configuration</span>类本身被注册为一个 bean 定义，类中所有声明的 <span class="citation"data-cites="Bean">@Bean</span> 方法也被注册为 bean 定义。</li><li>当提供 <span class="citation"data-cites="Component">@Component</span> 和 JSR-330 类时，它们被注册为bean 定义，并且假定在必要时在这些类中使用 DI 元数据，例如 <spanclass="citation" data-cites="Autowired">@Autowired</span> 或 <spanclass="citation" data-cites="Inject">@Inject</span>。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br>    Teacher bean = context.getBean(Teacher.class);<br>    System.out.println(bean);<br>&#125;<br></code></pre></td></tr></table></figure><h6id="使用registerclass编程构建容器">使用register(Class&lt;?&gt;…)编程构建容器</h6><p>AnnotationConfigApplicationContext可以通过无参构造函数实例化，然后调用register()方法进行配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();<br>    context.register(AppConfig.class);<br>    context.register(AppConfig1.class, AppConfig2.class);<br>    context.refresh();<br>    Teacher bean = context.getBean(Teacher.class);<br>    System.out.println(bean);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="使用-scanstring-扫描组件">使用 scan(String…) 扫描组件</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.zth.debugSpring&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><span class="citation"data-cites="ComponentScan">@ComponentScan</span> 用于启用组件扫描。和XML 配置的 <context:component-scan base-package="com.zth.debugSpring"/>等价。 也可通过 AnnotationConfigApplicationContext 的 scan(String…)方法开启扫描。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();<br>    context.scan(<span class="hljs-string">&quot;com.zth.debugSpring&quot;</span>);<br>    context.refresh();<br>    Teacher bean = context.getBean(Teacher.class);<br>    System.out.println(bean);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="bean-注解">4.2 <span class="citation"data-cites="Bean">@Bean</span> 注解</h5><p><span class="citation" data-cites="Bean">@Bean</span>是一个方法级别的注解，与 XML 中的 <bean/>元素类似。注解支持<bean/>提供的一些属性，例如 init-method destroy-method autowiringname</p><p>可以在 <span class="citation"data-cites="Configuration">@Configuration</span> 类或 <spanclass="citation" data-cites="Component">@Component</span> 类中使用 <spanclass="citation" data-cites="Bean">@Bean</span> 注解。</p><h6 id="声明一个bean">声明一个Bean</h6><p>要声明一个 bean，只需使用 <span class="citation"data-cites="Bean">@Bean</span> 注解方法即可。使用此方法，将会在ApplicationContext 内注册一个 bean，bean的类型是方法的返回值类型。默认情况下， bean 名称将与方法名称相同。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferServiceImpl <span class="hljs-title">transferService</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> ###### Bean之间的依赖</p><ul><li>外部 Bean：直接在方法入参加入即可，不需要写 <span class="citation"data-cites="Autowired">@Autowired</span>（优先按类型查找，然后根据名字查找）</li><li>内部 Bean：直接调用放法即可（基于@Configuration）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferService <span class="hljs-title">transferService</span><span class="hljs-params">(AccountRepository accountRepository)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl(accountRepository);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="生命周期回调-1">生命周期回调</h6><p><span class="citation" data-cites="Bean">@Bean</span>注解支持指定任意初始化和销毁回调方法，就像 bean 元素上的 Spring XML 的init-method 和 destroy-method 属性一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanOne</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanTwo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean(initMethod = &quot;init&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanOne <span class="hljs-title">beanOne</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BeanOne();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(destroyMethod = &quot;cleanup&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanTwo <span class="hljs-title">beanTwo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BeanTwo();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="bean-的作用域-1">Bean 的作用域</h6><p>默认范围是 singleton 的，可以使用 <span class="citation"data-cites="Scope">@Scope</span> 注解来覆盖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfiguration</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Encryptor <span class="hljs-title">encryptor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>有作用域 bean 的依赖</strong></p><p>如果要将一个 bean 装配到比它作用域更广的 bean 时，那么应当选择注入AOP 代理而不是使用带作用域的 bean。也就是说需要注入代理对象，而这个代理对象既可以找到实际的bean，还能够创建全新的 bean。</p><p>https://github.com/DocsHome/spring-docs/blob/master/pages/core/IoC-container.md#%E6%9C%89%E4%BD%9C%E7%94%A8%E5%9F%9Fbean%E7%9A%84%E4%BE%9D%E8%B5%96</p><p>使用 XML 配置时创建此类代理的最简单方法是&lt;aop:scoped-proxy/&gt;元素。 使用 <span class="citation"data-cites="Scope">@Scope</span> 注解在Java中配置 bean 提供了与proxyMode 属性的等效支持。默认值为无代理（ScopedProxyMode.NO），但您可以指定ScopedProxyMode.TARGET_CLASS（具体类） 或ScopedProxyMode.INTERFACES（实现了接口）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Component</span>  <br>    <span class="hljs-meta">@Scope</span>&#123;  <br> Value=WebApplicationContext.SCOPE_SISSION,<br>         proxyMode=ScopeProxyMode.INTERFACES&#125;<br>    <span class="hljs-function">Public ShoppingCart  <span class="hljs-title">cart</span><span class="hljs-params">()</span></span>&#123;<br>      <br>    &#125;  <br><br><span class="hljs-meta">@Component</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StoreService</span></span>&#123;  <br>    <span class="hljs-meta">@Autowired</span> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setShoppingCart</span><span class="hljs-params">(ShoppingCart shoppingCart)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.shoppingCart=shoppingCart;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="自定义-bean-命名">自定义 Bean 命名</h6><p>默认情况下，配置类使用 <span class="citation"data-cites="Bean">@Bean</span> 方法的名称作为结果 bean 的名称。但是，可以使用name属性覆盖此功能。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean(name = &quot;myThing&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Thing <span class="hljs-title">thing</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thing();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h5 id="引入外部属性资源文件">4.3 引入外部属性资源文件</h5><p><span class="citation"data-cites="PropertySource">@PropertySource</span></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:dbConfig.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;name&#125;&quot;)</span><br>    String userName;<br>    <span class="hljs-meta">@Value(&quot;$&#123;password&#125;&quot;)</span><br>    String password;<br>    <span class="hljs-meta">@Value(&quot;$&#123;url&#125;&quot;)</span><br>    String url;<br>    <span class="hljs-meta">@Value(&quot;$&#123;driverClassName&#125;&quot;)</span><br>    String driverClassName;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DruidDataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();<br>        dataSource.setUsername(userName);<br>        dataSource.setPassword(password);<br>        dataSource.setUrl(url);<br>        dataSource.setDriverClassName(driverClassName);<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="import-注解">4.3 <span class="citation"data-cites="Import">@Import</span> 注解</h4><p>###### 导入其他配置类 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigA</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> A <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> A();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(ConfigA.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigB</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> B <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 在实例化上下文时，不需要同时指定ConfigA.class 和 ConfigB.class，只需要显式提供 ConfigB：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(ConfigB.class);<br><br>    A a = ctx.getBean(A.class);<br>    B b = ctx.getBean(B.class);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="导入类注册为-bean">导入类注册为 Bean</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(&#123;Teacher.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">student</span><span class="hljs-params">(Teacher teacher)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Student( teacher);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="导入-importselector-实现类">导入 ImportSelector 实现类</h6><p>可以注册多个 Bean，必须根据类型获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportSelector</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;com.zth.debugSpring.entity.Student&quot;</span>, Teacher.class.getName()&#125;;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(MyImportSelector.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br>        Teacher bean = context.getBean(Teacher.class);<br>        System.out.println(bean);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="导入-importbeandefinitionregistrar-实现类">导入ImportBeanDefinitionRegistrar 实现类</h6><p>可以注册多个 Bean 定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImportBeanDefinitionRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;<br>        GenericBeanDefinition beanDefinition = <span class="hljs-keyword">new</span> GenericBeanDefinition();<br>        beanDefinition.setBeanClass(Teacher.class);<br>        registry.registerBeanDefinition(<span class="hljs-string">&quot;teacher&quot;</span>,beanDefinition);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(MyImportBeanDefinitionRegistrar.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br>        Teacher bean = context.getBean(<span class="hljs-string">&quot;teacher&quot;</span>,Teacher.class);<br>        System.out.println(bean);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——原型模式</title>
    <link href="/2022/04/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/04/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="模式定义">1. 模式定义</h3><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220410223155.png" /></p><p><strong>优点：</strong> 1. 可以不耦合具体类的情况下克隆对象 2.避免重复的初始化代码 3. 更方便的构建复杂对象</p><p><strong>应用场景：</strong> +对象之间相同或相似，即只是个别的几个属性不同的时候。 +创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。+创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。+ 系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。</p><h3 id="示例">2. 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrototypeTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br><br>        BaseInfo baseInfo = <span class="hljs-keyword">new</span> BaseInfo(<span class="hljs-string">&quot;debuggingWorld&quot;</span>);<br>        Product product = <span class="hljs-keyword">new</span> Product(<span class="hljs-string">&quot;part1&quot;</span>, <span class="hljs-string">&quot;part2&quot;</span>, baseInfo);<br><br>        Product clone = product.clone();<br>        System.out.println(<span class="hljs-string">&quot;original: &quot;</span> + product);<br>        System.out.println(<span class="hljs-string">&quot;clone:  &quot;</span> + clone);<br>        product.getBaseInfo().setCompanyName(<span class="hljs-string">&quot;xxxx&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;original: &quot;</span> + product);<br>        System.out.println(<span class="hljs-string">&quot;clone:  &quot;</span> + clone);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseInfo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String companyName;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseInfo</span><span class="hljs-params">(String companyName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.companyName = companyName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCompanyName</span><span class="hljs-params">(String companyName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.companyName = companyName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> BaseInfo <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> ((BaseInfo) <span class="hljs-keyword">super</span>.clone());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> hashCode() + <span class="hljs-string">&quot; ]BaseInfo&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;companyName=&#x27;&quot;</span> + companyName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">6772397503790075095L</span>;<br><br>    <span class="hljs-keyword">private</span> String part1;<br>    <span class="hljs-keyword">private</span> String part2;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自定义数据类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> BaseInfo baseInfo;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Product</span><span class="hljs-params">(String part1, String part2, BaseInfo baseInfo)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.part1 = part1;<br>        <span class="hljs-keyword">this</span>.part2 = part2;<br>        <span class="hljs-keyword">this</span>.baseInfo = baseInfo;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseInfo <span class="hljs-title">getBaseInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> baseInfo;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Product <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-comment">// 利用jvm克隆机制完成的深拷贝</span><br><span class="hljs-comment">//        Product productClone= ((Product) super.clone());</span><br><span class="hljs-comment">//        BaseInfo clone1=this.baseInfo.clone();</span><br><span class="hljs-comment">//        productClone.setBaseInfo( clone1 );</span><br><span class="hljs-comment">//        return productClone ;</span><br><br>        <span class="hljs-comment">// 序列化方式实现的深拷贝</span><br>        ByteArrayOutputStream byteArrayOutputStream = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br><br>        <span class="hljs-keyword">try</span> (ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(byteArrayOutputStream)) &#123;<br>            oos.writeObject(<span class="hljs-keyword">this</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        ByteArrayInputStream byteArrayInputStream = <span class="hljs-keyword">new</span> ByteArrayInputStream(byteArrayOutputStream.toByteArray());<br><br>        <span class="hljs-keyword">try</span> (ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(byteArrayInputStream)) &#123;<br>            <span class="hljs-keyword">return</span> ((Product) ois.readObject());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Product&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;part1=&#x27;&quot;</span> + part1 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, part2=&#x27;&quot;</span> + part2 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, baseInfo=&quot;</span> + baseInfo +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>如果对应的类中的字段为 8 种原生数据类型，或者 8种原生数据类型的包装类型，或 String，BigInteger 则只需要实现 Cloneable这个接口且覆盖 Object.clone 方法，即可利用 jvm的克隆机制，完成对象的拷贝。 这种方式即是浅拷贝，如果对应的类中数据为自定义数据类型，或者其他可变的数据类型（如Date，或者其他对象类型），要借助 jvm的克隆机制完成数据的拷贝，则需要实现所有的对象字段的遍历拷贝，即是深拷贝。</p></blockquote><h3 id="jdk-中的应用">3. jdk 中的应用</h3><p>java.util.ArrayList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="hljs-keyword">super</span>.clone();<br>v.elementData = Arrays.copyOf(elementData, size);<br>v.modCount = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> v;<br>&#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br><span class="hljs-comment">// this shouldn&#x27;t happen, since we are Cloneable</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="spring-中的应用">4. Spring 中的应用</h3><p>https://blog.csdn.net/Woo_home/article/details/104359232</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>创建型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——单例模式</title>
    <link href="/2022/04/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/04/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="模式定义">1. 模式定义</h3><p>保证一个类只有一个实例，并且提供一个全局访问点。</p><p><strong>优点：</strong> + 保证内存里只有一个实例，减少了内存的开销。+ 避免对资源的多重占用。 +设置全局访问点，可以优化和共享资源的访问。</p><p><strong>缺点：</strong> +单例模式一般没有接口，扩展困难。违背开闭原则。 +单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</p><p><strong>场景:</strong>重量级的对象，不需要多个实例，如线程池，数据库连接池</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220409142054.png" /></p><h3 id="实现">2. 实现</h3><h4 id="懒汉模式">2.1 懒汉模式</h4><p>延迟加载， 只有在真正使用的时候，才开始实例化。 1. 线程安全问题 2.double check 加锁优化 3. 编译器(JIT)、CPU有可能对指令进行重排序，导致使用到尚未初始化的实例，可以通过添加volatile 关键字进行修饰，防止指令重排。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazySingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> LazySingleton instance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazySingleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == instance)&#123;<br>            <span class="hljs-keyword">synchronized</span> (LazySingleton.class)&#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == instance)&#123;<br>                    instance = <span class="hljs-keyword">new</span> LazySingleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="饿汉模式">2.2 饿汉模式</h4><p>类加载的初始化阶段就完成了实例的初始化 。 本质上就是借助于 jvm类加载机制，保证实例的唯一性（初始化过程只会执行一次）及线程安 全（JVM以同步的形式来完成类加载的整个过程）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HungrySingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HungrySingleton instance = <span class="hljs-keyword">new</span> HungrySingleton();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">HungrySingleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HungrySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="静态内部类">2.3 静态内部类</h4><ol type="1"><li>本质上是利用类的加载机制来保证线程安全</li><li>只有在实际使用的时候，才会触发类的初始化，所以也是懒加载的一种形式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClassSingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClassHolder</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InnerClassSingleton instance = <span class="hljs-keyword">new</span> InnerClassSingleton();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">InnerClassSingleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InnerClassSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> InnerClassHolder.instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="反射攻击实例">2.4 反射攻击实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Constructor&lt;InnerClassSingleton&gt; declaredConstructors = InnerClassSingleton.class.getDeclaredConstructor();<br>declaredConstructors.setAccessible(<span class="hljs-keyword">true</span>);<br>InnerClassSingleton innerClassSingleton = declaredConstructors.newInstance();<br><span class="hljs-comment">// false</span><br>System.out.println(innerClassSingleton == InnerClassSingleton.getInstance());<br></code></pre></td></tr></table></figure><p><strong>静态内部类防止反射破坏：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClassSingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClassHolder</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InnerClassSingleton instance = <span class="hljs-keyword">new</span> InnerClassSingleton();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">InnerClassSingleton</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != InnerClassHolder.instance)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot; 单例不允许多个实例 &quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InnerClassSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> InnerClassHolder.instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="反序列化攻击">2.5 反序列化攻击</h4><p>可以利用指定方法来替换从反序列化流中的数据：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ANY‐ACCESS‐<span class="hljs-function">MODIFIER Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ObjectStreamException</span>;<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClassSingleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">42L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClassHolder</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InnerClassSingleton instance = <span class="hljs-keyword">new</span> InnerClassSingleton();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">InnerClassSingleton</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != InnerClassHolder.instance)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot; 单例不允许多个实例 &quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InnerClassSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> InnerClassHolder.instance;<br>    &#125;<br><br>    <span class="hljs-function">Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ObjectStreamException </span>&#123;<br>        <span class="hljs-keyword">return</span> InnerClassSingleton.getInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    InnerClassSingleton instance = InnerClassSingleton.getInstance();<br><br>    ObjectOutputStream outputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;testObject&quot;</span>));<br>    outputStream.writeObject(instance);<br>    outputStream.close();<br><br>    ObjectInputStream inputStream = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;testObject&quot;</span>));<br>    InnerClassSingleton serializedObject = ((InnerClassSingleton) inputStream.readObject());<br>    inputStream.close();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加 readResolve() 前 false</span><br><span class="hljs-comment">     * 添加后为 true</span><br><span class="hljs-comment">     */</span><br>    System.out.println(serializedObject == instance);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="枚举类型">2.6 枚举类型</h4><ol type="1"><li>天然不支持反射创建对应的实例，且有自己的反序列化机制</li><li>利用类加载机制保证线程安全</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EnumSingleton</span> </span>&#123;<br>    INSTANCE;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.hashCode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="jdk-中的应用">3. jdk 中的应用</h3><p>java.lang.Runtime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runtime</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Runtime currentRuntime = <span class="hljs-keyword">new</span> Runtime();<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runtime <span class="hljs-title">getRuntime</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> currentRuntime;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Runtime</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="spring-中的应用">4. Spring 中的应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.aop.framework.ProxyFactoryBean<br>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry <br>org.springframework.core.ReactiveAdapterRegistry<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>创建型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——抽象工厂模式</title>
    <link href="/2022/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="模式定义">1.模式定义</h3><p>提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220405163414.png" /></p><ul><li>抽象工厂：声明了创建抽象产品对象的操作接口。</li><li>具体产品工厂：实现了抽象工厂的接口，负责创建产品对象。</li><li>产品抽象类或接口：定义一类产品对象的接口。</li><li>具体产品实现：定义一个将被相应具体工厂创建的产品对象。</li></ul><p><strong>优缺点:</strong>增加分组非常简单，分组中的产品扩展非常困难。</p><p><strong>使用场景：</strong> 1.一个系统要独立于它的产品的创建、组合和表示时； 2.一个系统要由多个产品系列中的一个来配置时； 3.要强调一系列相关的产品对象的设计以便进行联合使用时； 4.当你提供一个产品类库，而只想显示它们的接口而不是实现时；</p><h3 id="示例">2. 示例</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220405165324.png" /></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zth.designPatterns.abstractfactory;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 猫和少年</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2022-04-05 16:45</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Slogan</span> 才疏学浅，少年登科；满腹经纶，白发不第</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactoryTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        IFactory dellFactory = <span class="hljs-keyword">new</span> DellFactory();<br>        IFactory HPFactory = <span class="hljs-keyword">new</span> HPFactory();<br>        Keyboard dellKeyboard = dellFactory.createKeyboard();<br>        Monitor monitor = HPFactory.createMonitor();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Keyboard</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DellKeyboard</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Keyboard</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//...dell...dell;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HPKeyboard</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Keyboard</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//...HP...HP;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Monitor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DellMonitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Monitor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//...dell...dell;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HPMonitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Monitor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//...HP...HP;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MainFrame</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DellMainFrame</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MainFrame</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//...dell...dell;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HPMainFrame</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MainFrame</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//...HP...HP;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 工厂类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IFactory</span> </span>&#123;<br>    <span class="hljs-function">MainFrame <span class="hljs-title">createMainFrame</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Monitor <span class="hljs-title">createMonitor</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Keyboard <span class="hljs-title">createKeyboard</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DellFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IFactory</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MainFrame <span class="hljs-title">createMainFrame</span><span class="hljs-params">()</span> </span>&#123;<br>        MainFrame mainFrame = <span class="hljs-keyword">new</span> DellMainFrame();<br>        <span class="hljs-comment">//...造一个Dell主机;</span><br>        <span class="hljs-keyword">return</span> mainFrame;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Monitor <span class="hljs-title">createMonitor</span><span class="hljs-params">()</span> </span>&#123;<br>        Monitor monitor = <span class="hljs-keyword">new</span> DellMonitor();<br>        <span class="hljs-comment">//...造一个Dell显示器;</span><br>        <span class="hljs-keyword">return</span> monitor;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Keyboard <span class="hljs-title">createKeyboard</span><span class="hljs-params">()</span> </span>&#123;<br>        Keyboard keyboard = <span class="hljs-keyword">new</span> DellKeyboard();<br>        <span class="hljs-comment">//...造一个Dell键盘;</span><br>        <span class="hljs-keyword">return</span> keyboard;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HPFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IFactory</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MainFrame <span class="hljs-title">createMainFrame</span><span class="hljs-params">()</span> </span>&#123;<br>        MainFrame mainFrame = <span class="hljs-keyword">new</span> HPMainFrame();<br>        <span class="hljs-comment">//...造一个HP主机;</span><br>        <span class="hljs-keyword">return</span> mainFrame;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Monitor <span class="hljs-title">createMonitor</span><span class="hljs-params">()</span> </span>&#123;<br>        Monitor monitor = <span class="hljs-keyword">new</span> HPMonitor();<br>        <span class="hljs-comment">//...造一个HP显示器;</span><br>        <span class="hljs-keyword">return</span> monitor;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Keyboard <span class="hljs-title">createKeyboard</span><span class="hljs-params">()</span> </span>&#123;<br>        Keyboard keyboard = <span class="hljs-keyword">new</span> HPKeyboard();<br>        <span class="hljs-comment">//...造一个HP键盘;</span><br>        <span class="hljs-keyword">return</span> keyboard;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="spring-中的应用">3. Spring 中的应用</h3><p>在 Spring 中，BeanFactory 是用于管理 Bean 的一个工厂，所有工厂都是BeanFactory 的子类。这样我们可以通过 IOC 容器来管理访问Bean，根据不同的策略调用 getBean() 方法，从而获得具体对象。</p><p>其中，BeanFactory 接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<br>    String FACTORY_BEAN_PREFIX = <span class="hljs-string">&quot;&amp;&quot;</span>;<br>    <span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, <span class="hljs-meta">@Nullable</span> Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>    <span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBean</span><span class="hljs-params">(String name)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, ResolvableType typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, <span class="hljs-meta">@Nullable</span> Class&lt;?&gt; typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>    <span class="hljs-meta">@Nullable</span><br>    Class&lt;?&gt; getType(String name) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br>    String[] getAliases(String name);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>BeanFactory 的子类主要有ClassPathXmlApplicationContext、XmlWebApplicationContext、StaticWebApplicationContext、StaticApplicationContext。在Spring 中，DefaultListableBeanFactory 实现了所有工厂的公共逻辑。</p></blockquote><h3 id="jdk-中的应用">4. JDK 中的应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">java.sql.Connection<br>java.sql.Driver<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>创建型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——工厂方法模式</title>
    <link href="/2022/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="模式定义">1. 模式定义</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使得一个类的实例化延迟到子类</p><p><strong>主要优点：</strong> 1. 将具体产品和创建者解耦 2.符合单一职责原则 3. 符合开闭原则</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220324231454.png" /></p><h3 id="示例">2. 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AbstractFactory factory = <span class="hljs-keyword">new</span> ConcreteProductA();<br>        Product product = factory.createProduct();<br>        product.method();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Product</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ProductA.method executed. &quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ProductB.method executed. &quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Product <span class="hljs-title">getObject</span><span class="hljs-params">()</span> </span>&#123;<br>        Product product = createProduct();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProductA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function">Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductA();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProductB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function">Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductB();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="jdk-中的应用">3. jdk 中的应用</h3><p>Collections.iterator() 方法</p><h3 id="spring-中的应用">4. Spring 中的应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactoryBean</span>&lt;<span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">BeanClassLoaderAware</span>, <span class="hljs-title">BeanFactoryAware</span>, <span class="hljs-title">InitializingBean</span>, <span class="hljs-title">DisposableBean</span> </span>&#123;<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> T <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-keyword">if</span> (isSingleton()) &#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.initialized ? <span class="hljs-keyword">this</span>.singletonInstance : getEarlySingletonInstance());<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> createInstance();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title">createInstance</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><br>    ....<br><br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220330224551.png" /></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>创建型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——建造者模</title>
    <link href="/2022/03/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1/"/>
    <url>/2022/03/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="模式定义">1. 模式定义</h3><p>指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。</p><p><strong>优点：</strong> 1. 封装性好，构建和表示分离。 2.扩展性好，各个具体的建造者相互独立，有利于系统的解耦。 3.客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。</p><p>【注】建造者模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程</p><p><strong>应用场景：</strong> 1. 需要生成的对象具有复杂的内部结构 2.需要生成的对象内部属性本身相互依赖 3. 与不可变对象配合使用</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220323233438.png" /></p><h3 id="示例">2. 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Director director = <span class="hljs-keyword">new</span> Director(<span class="hljs-keyword">new</span> DefaultConcreteProductBuilder());<br>        Product product = director.makeProduct(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;company&quot;</span>, <span class="hljs-string">&quot;xxx1&quot;</span>, <span class="hljs-string">&quot;xxx2&quot;</span>, <span class="hljs-string">&quot;xxx3&quot;</span>, <span class="hljs-string">&quot;xxx4&quot;</span>);<br><br>        System.out.println(product);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProductBuilder</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildProductName</span><span class="hljs-params">(String productName)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildCompany</span><span class="hljs-params">(String company)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildPart1</span><span class="hljs-params">(String part1)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildPart2</span><span class="hljs-params">(String part2)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildPart3</span><span class="hljs-params">(String part3)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildPart4</span><span class="hljs-params">(String part4)</span></span>;<br><br>    <span class="hljs-function">Product <span class="hljs-title">build</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ProductBuilder builder;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Director</span><span class="hljs-params">(ProductBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.builder = builder;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">makeProduct</span><span class="hljs-params">(String productName, String companyName, String part1, String part2, String part3, String part4)</span> </span>&#123;<br>        builder.buildProductName(productName);<br>        builder.buildCompany(companyName);<br>        builder.buildPart1(part1);<br>        builder.buildPart2(part2);<br>        builder.buildPart3(part3);<br>        builder.buildPart4(part4);<br><br>        <span class="hljs-keyword">return</span> builder.build();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultConcreteProductBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ProductBuilder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String productName;<br>    <span class="hljs-keyword">private</span> String company;<br>    <span class="hljs-keyword">private</span> String part1;<br>    <span class="hljs-keyword">private</span> String part2;<br>    <span class="hljs-keyword">private</span> String part3;<br>    <span class="hljs-keyword">private</span> String part4;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildProductName</span><span class="hljs-params">(String productName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.productName = productName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildCompany</span><span class="hljs-params">(String company)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.company = company;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPart1</span><span class="hljs-params">(String part1)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.part1 = part1;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPart2</span><span class="hljs-params">(String part2)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.part2 = part2;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPart3</span><span class="hljs-params">(String part3)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.part3 = part3;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPart4</span><span class="hljs-params">(String part4)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.part4 = part4;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Product(<span class="hljs-keyword">this</span>.productName, <span class="hljs-keyword">this</span>.company, <span class="hljs-keyword">this</span>.part1, <span class="hljs-keyword">this</span>.part2, <span class="hljs-keyword">this</span>.part3, <span class="hljs-keyword">this</span>.part4);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String productName;<br>    <span class="hljs-keyword">private</span> String company;<br>    <span class="hljs-keyword">private</span> String part1;<br>    <span class="hljs-keyword">private</span> String part2;<br>    <span class="hljs-keyword">private</span> String part3;<br>    <span class="hljs-keyword">private</span> String part4;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Product</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Product</span><span class="hljs-params">(String productName, String company, String part1, String part2, String part3, String part4)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.productName = productName;<br>        <span class="hljs-keyword">this</span>.company = company;<br>        <span class="hljs-keyword">this</span>.part1 = part1;<br>        <span class="hljs-keyword">this</span>.part2 = part2;<br>        <span class="hljs-keyword">this</span>.part3 = part3;<br>        <span class="hljs-keyword">this</span>.part4 = part4;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Product&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;productName=&#x27;&quot;</span> + productName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, company=&#x27;&quot;</span> + company + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, part1=&#x27;&quot;</span> + part1 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, part2=&#x27;&quot;</span> + part2 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, part3=&#x27;&quot;</span> + part3 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, part4=&#x27;&quot;</span> + part4 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>建造者模式与不可变对象配合使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderTest2</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Product product = <span class="hljs-keyword">new</span> Product.Builder().productName(<span class="hljs-string">&quot;name&quot;</span>).company(<span class="hljs-string">&quot;xxx&quot;</span>).part1(<span class="hljs-string">&quot;1yy&quot;</span>).build();<br>        System.out.println(product);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String productName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String company;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String part1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String part2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String part3;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String part4;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Product</span><span class="hljs-params">(String productName, String company, String part1, String part2, String part3, String part4)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.productName = productName;<br>        <span class="hljs-keyword">this</span>.company = company;<br>        <span class="hljs-keyword">this</span>.part1 = part1;<br>        <span class="hljs-keyword">this</span>.part2 = part2;<br>        <span class="hljs-keyword">this</span>.part3 = part3;<br>        <span class="hljs-keyword">this</span>.part4 = part4;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span></span>&#123;<br>        <span class="hljs-keyword">private</span> String productName;<br>        <span class="hljs-keyword">private</span> String company;<br>        <span class="hljs-keyword">private</span> String part1;<br>        <span class="hljs-keyword">private</span> String part2;<br>        <span class="hljs-keyword">private</span> String part3;<br>        <span class="hljs-keyword">private</span> String part4;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">productName</span><span class="hljs-params">(String productName)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.productName = productName;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">company</span><span class="hljs-params">(String company)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.company = company;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">part1</span><span class="hljs-params">(String part1)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.part1 = part1;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">part2</span><span class="hljs-params">(String part2)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.part2 = part2;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">part3</span><span class="hljs-params">(String part3)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.part3 = part3;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">part4</span><span class="hljs-params">(String part4)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.part4 = part4;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">build</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Product(<span class="hljs-keyword">this</span>.productName,<span class="hljs-keyword">this</span>.company,<span class="hljs-keyword">this</span>.part1,<span class="hljs-keyword">this</span>.part2,<span class="hljs-keyword">this</span>.part3,<span class="hljs-keyword">this</span>.part4);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Product&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;productName=&#x27;&quot;</span> + productName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, company=&#x27;&quot;</span> + company + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, part1=&#x27;&quot;</span> + part1 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, part2=&#x27;&quot;</span> + part2 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, part3=&#x27;&quot;</span> + part3 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, part4=&#x27;&quot;</span> + part4 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="spring-中的应用">3. Spring 中的应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.web.servlet.mvc.method.RequestMappingInfo org.springframework.beans.factory.support.BeanDefinitionBuilder<br></code></pre></td></tr></table></figure><p>https://www.cnblogs.com/bjlhx/p/11156766.html</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>创建型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——享元模式</title>
    <link href="/2022/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="模式定义">1. 模式定义</h3><p>运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p><p><strong>优点：</strong>如果系统有大量类似的对象，可以节省大量的内存及CPU资源</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220320224736.png" /></p><h3 id="示例">2. 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyweightTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        TreeNode treeNode1 = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, TreeFactory.getTree(<span class="hljs-string">&quot;xxx&quot;</span>));<br>        TreeNode treeNode2 = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, TreeFactory.getTree(<span class="hljs-string">&quot;xxx&quot;</span>));<br>        TreeNode treeNode3 = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">13</span>, <span class="hljs-number">24</span>, TreeFactory.getTree(<span class="hljs-string">&quot;yyy&quot;</span>));<br>        TreeNode treeNode4 = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">15</span>, <span class="hljs-number">24</span>, TreeFactory.getTree(<span class="hljs-string">&quot;yyy&quot;</span>));<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tree</span> </span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Tree</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;name: &quot;</span>+name +<span class="hljs-string">&quot; tree created. &quot;</span>);<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>    Tree tree;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, Tree tree)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.x = x;<br>        <span class="hljs-keyword">this</span>.y = y;<br>        <span class="hljs-keyword">this</span>.tree = tree;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeFactory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Tree&gt; cache = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Tree <span class="hljs-title">getTree</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cache.containsKey(name)) &#123;<br>            <span class="hljs-keyword">return</span> cache.get(name);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Tree tree = <span class="hljs-keyword">new</span> Tree(name);<br>            cache.put(name, tree);<br>            <span class="hljs-keyword">return</span> tree;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="jdk-中的应用">3. JDK 中的应用</h3><p>享元模式比较经典的应用就是 JDK中部分基本类型的包装类，缓存了一定数值范围的对象，valueOf方法转换为包装对象时，如果值在缓存范围内，即返回缓存对象。</p><ul><li>Byte，缓存了 -128 ～ 127</li><li>Short，缓存了 -128 ～ 127</li><li>Character，缓存了 0 ～ 127</li><li>Integer，缓存了 -128 ~ 127，JVM 启动参数 -XX:AutoBoxCacheMax可以设置范围的最大值</li><li>Long，缓存了 -128 ～ 127</li><li>Boolean，缓存了 true 和 false 对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>    &#125;<br><br><br><span class="hljs-comment">//----------------------------------------</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerCache</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = -<span class="hljs-number">128</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> high;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br><br>        <span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-comment">// high value may be configured by property</span><br>            <span class="hljs-keyword">int</span> h = <span class="hljs-number">127</span>;<br>            String integerCacheHighPropValue =<br>                sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>            <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">int</span> i = parseInt(integerCacheHighPropValue);<br>                    i = Math.max(i, <span class="hljs-number">127</span>);<br>                    <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                    <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>                &#125;<br>            &#125;<br>            high = h;<br><br>            cache = <span class="hljs-keyword">new</span> Integer[(high - low) + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> j = low;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>                cache[k] = <span class="hljs-keyword">new</span> Integer(j++);<br><br>            <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>            <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">IntegerCache</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>结构型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——外观模式</title>
    <link href="/2022/03/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="模式定义">1. 模式定义</h3><p>外观（Facade）模式又叫作门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p><p><strong>应用场景：</strong> +对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。+当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。+当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</p><p><strong>优点:</strong>观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点。 +降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。+对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</p><p><strong>缺点：</strong> + 违背了“开闭原则”。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220317205254.png" /></p><h3 id="示例">2. 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FacadeTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Facade f = <span class="hljs-keyword">new</span> Facade();<br>        f.method();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span></span>&#123;<br>    <span class="hljs-keyword">private</span> SubSystem01 obj1 = <span class="hljs-keyword">new</span> SubSystem01();<br>    <span class="hljs-keyword">private</span> SubSystem02 obj2 = <span class="hljs-keyword">new</span> SubSystem02();<br>    <span class="hljs-keyword">private</span> SubSystem03 obj3 = <span class="hljs-keyword">new</span> SubSystem03();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        obj1.method1();<br>        obj2.method2();<br>        obj3.method3();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystem01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;子系统01的method1()被调用！&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystem02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;子系统02的method2()被调用！&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystem03</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;子系统03的method3()被调用！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>结构型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——装饰器模式</title>
    <link href="/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="模式定义">1. 模式定义</h3><p>在不改变原有对象的基础上，将功能附加到对象上。</p><p><strong>应用场景：</strong>扩展一个类的功能或给一个类添加附加职责</p><p><strong>优点:</strong> 1. 不改变原有对象的情况下给一个对象扩展功能 2.使用不同的组合可以实现不同的效果 3. 符合开闭原则</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220314225121.png" /></p><h3 id="示例">2. 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecoratorTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        FilterCamera filterCamera = <span class="hljs-keyword">new</span> FilterCamera(<span class="hljs-keyword">new</span> BeautyCamera(<span class="hljs-keyword">new</span> CameraImpl()));<br>        filterCamera.photo();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Camera</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">photo</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CameraImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Camera</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">photo</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;拍照&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CameraDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Camera</span></span>&#123;<br>    Camera camera;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CameraDecorator</span><span class="hljs-params">(Camera camera)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.camera = camera;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeautyCamera</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CameraDecorator</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BeautyCamera</span><span class="hljs-params">(Camera camera)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(camera);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">photo</span><span class="hljs-params">()</span> </span>&#123;<br>        camera.photo();<br>        System.out.println(<span class="hljs-string">&quot;美颜&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterCamera</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CameraDecorator</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FilterCamera</span><span class="hljs-params">(Camera camera)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(camera);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">photo</span><span class="hljs-params">()</span> </span>&#123;<br>        camera.photo();<br>        System.out.println(<span class="hljs-string">&quot;滤镜&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="jdk-中的应用">3. JDK 中的应用</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220314233706.png" /></p><h4 id="spring-中的应用">4. Spring 中的应用</h4><p>http://c.biancheng.net/view/8464.html</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>结构型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——适配器模式</title>
    <link href="/2022/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="模式定义">1. 模式定义</h3><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p><p>适配器模式分为类结构型模式（继承）和对象结构型模式（聚合）两种。前者类之间的耦合度比后者高，且对外暴露了不需要的方法（违反了迪米特法则）。</p><p><strong>优点：</strong> 1. 符合单一职责原则 2. 符合开闭原则</p><p><strong>应用场景：</strong> +以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。+ 使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</p><p>对象适配器：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220313175600.png" /></p><p>类适配器：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220313175504.png" /></p><h3 id="示例">2. 示例</h3><p>对象适配器： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectAdapterTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Target target = <span class="hljs-keyword">new</span> Adapter(<span class="hljs-keyword">new</span> Adaptee());<br>        target.output5V();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adaptee</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">output220V</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">220</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Target</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">output5V</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Target</span></span>&#123;<br>    Adaptee adaptee;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Adapter</span><span class="hljs-params">(Adaptee adaptee)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.adaptee = adaptee;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">output5V</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> v = adaptee.output220V();<br>        System.out.printf(<span class="hljs-string">&quot;原始电压： %d v ‐ &gt; 输出电压： %d v &quot;</span>,v,<span class="hljs-number">5</span> );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 类适配器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassAdapterTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Target target = <span class="hljs-keyword">new</span> Adapter2();<br>        target.output5V();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Target</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">output5V</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> v = output220V();<br>        System.out.printf(<span class="hljs-string">&quot;原始电压： %d v ‐ &gt; 输出电压： %d v &quot;</span>,v,<span class="hljs-number">5</span> );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="jdk-中的应用">3. JDK 中的应用</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220313231941.png" /></p><h3 id="spring-中的应用">4. Spring 中的应用</h3><p>https://blog.csdn.net/yuan882696yan/article/details/105602359</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>结构型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——观察者模式</title>
    <link href="/2022/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="模式定义">1. 模式定义</h3><p>定义了对象之间的一对多依赖，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，它的所有依赖者都会收到通知并更新。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220312174159.png" /></p><p>使用场景： + 事件多级触发场景 +跨系统的消息交换场景，如消息队列、事件总线的处理机制</p><p>优点： + 解除耦合，让耦合的双方都依赖于抽象（符合开闭原则） +可以在运行时建立对象之间的关系</p><p>缺点： + 耗时：注册较多的观察者的时候，通知比较耗时 +如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。+异步投递时，需满足自洽性：多线程异步通知时，系统必须保证通知是以自洽的方式进行的。</p><h3 id="示例">2. 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObserverDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Subject subject = <span class="hljs-keyword">new</span> Subject();<br>        Task1 task1 = <span class="hljs-keyword">new</span> Task1();<br>        Task2 task2 = <span class="hljs-keyword">new</span> Task2();<br>        subject.add(task1);<br>        subject.add(task2);<br>        subject.notifyObserver(<span class="hljs-string">&quot;hello&quot;</span>);<br>        subject.remove(task1);<br>        subject.notifyObserver(<span class="hljs-string">&quot;world&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Observer&gt; container = <span class="hljs-keyword">new</span> ArrayList&lt;Observer&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Observer observer)</span> </span>&#123;<br>        container.add(observer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Observer observer)</span> </span>&#123;<br>        container.remove(observer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span><span class="hljs-params">(Object object)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Observer observer : container) &#123;<br>            observer.update(object);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Object object)</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Object object)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;task1 received: &quot;</span> + object);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Object object)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;task2 received: &quot;</span> + object);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="jdk-中的应用">3. jdk 中的应用</h3><p>java.util.Observable</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220312190855.png" /></p><h3 id="spring-中的应用">4. Spring 中的应用</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220312190254.png" /></p><p>https://www.cnblogs.com/jmcui/p/11054756.html</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>行为型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes——k8s架构与核心组件</title>
    <link href="/2022/03/11/Kubernetes%E2%80%94%E2%80%94k8s%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    <url>/2022/03/11/Kubernetes%E2%80%94%E2%80%94k8s%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="什么是-kubernetes">1. 什么是 Kubernetes</h3><p>Kubernetes(K8S)是由 Google 开源的生产级容器编排系统，是 Google多年大规模容器管理技术 Borg 的开源版本</p><p>Kurbernets的本质是一组服务器集群，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。它的目的就是实现资源管理的自动化，主要提供了如下的主要功能：</p><ul><li>自我修复：一旦某一个容器崩溃，能够在1秒钟左右迅速启动新的容器</li><li>弹性伸缩：可以根据需要，自动对集群中正在运行的容器数量进行调整</li><li>服务发现：服务可以通过自动发现的形式找到它所依赖的服务</li><li>负载均衡:如果一个服务启动了多个容器，能够自动实现请求的负载均衡</li><li>版本回退：如果发现新发布的程序版本有问题，可以立即回退到原来的版本</li><li>容器编排：可以根据容器自身的需求自动创建存储卷</li><li>跨机器和跨地区的集群调度</li><li>无状态服务和有状态服务</li><li>广泛的Volume支持</li><li>插件机制保证扩展性</li></ul><h4 id="产生背景">1.1 产生背景</h4><p>微服务和容器的流行。微服务是把原来一体化的应用转换为一个个相互独立(高内聚低耦合)的小应用，这些小应用就叫微服务。一个应用如果有成千上万的微服务，那么微服务的部署会很麻烦。一台机器可能部署多个微服务。对微服务进行隔离和资源控制(微服务的支持调度计划)就需要用到容器。</p><h4 id="容器">1.2 容器</h4><ul><li>容器是一系列隔离运行的进程，提供了一种轻量操作系统层面的虚拟化技术。</li><li>每个容器都有自己的PID(进程号)，User，UTS，Network栈命名空间等</li><li>与传统虚拟机比具有启动快，性能损耗小，更轻量化的特点</li></ul><p>K8S默认使用Docker引擎，也可使用 Rkt(coreos) 或其他遵循 CRI(containerruntime interface)标准的容器引擎，如Containerd等</p><p>Docker最创新的地方:引入了镜像分层的机制，可以让镜像比较小，使隔离技术在操作系统层面也可以用，docker提供命令行的方式对容器进行增删改查，提供了镜像机制把环境打包到镜像中，使得使用容器技术变得非常简单</p><p>容器化系统面临的挑战：容器虽然解决了应用打包、部署、运行的问题(一次构建、随处运行Build,Shipand Run AnyApp,Anywhere),但是也面临了跨机器的部署、资源调度、负载均衡、自动伸缩、容错处理、服务发现的挑战。</p><h4 id="容器编排">1.3 容器编排</h4><p>容器编排： + 以容器为基本对象进行管理 + 协同容器共同实现应用功能</p><p>容器编排的主要功能：</p><ol type="1"><li>容器调度（Placement, health checking..)</li><li>资源管理(CPU、GPU、Memory...)</li><li>服务管理(Service Discovery服务发现、Load Balance...)</li></ol>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jenkins——构建持续集成环境</title>
    <link href="/2022/03/08/jenkins%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83/"/>
    <url>/2022/03/08/jenkins%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>更新机制是指项目如何进行更新，主要有两种方式：一种是自动推送，另外一种是手动拉取。前者用于开发环境、后者可以用于所有环境。</p><h3 id="手动拉取">1. 手动拉取</h3><p>拉取更新流程：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220308233636.png" /></p><p>上述流程由 deploy.sh 脚本实现：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash -e</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;`dirname <span class="hljs-variable">$0</span>`&quot;</span><br>. ./pom.sh<br><br><span class="hljs-comment">#1. download war, ready env</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deploy time: <span class="hljs-variable">$work_time</span>&quot;</span><br>mkdir -p war/<br>war=war/<span class="hljs-variable">$pom_a</span>-<span class="hljs-variable">$pom_v</span>.war<br>download_path=<span class="hljs-string">&quot;<span class="hljs-variable">$nexus_redirect</span>?r=<span class="hljs-variable">$pom_r</span>&amp;g=<span class="hljs-variable">$pom_g</span>&amp;a=<span class="hljs-variable">$pom_a</span>&amp;v=<span class="hljs-variable">$pom_v</span>&amp;e=war&quot;</span><br>wget  <span class="hljs-variable">$download_path</span> -O <span class="hljs-variable">$war</span><br><br>deploy_war<br></code></pre></td></tr></table></figure><p>pom.sh 脚本内容： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash -e</span><br>. ../bin/env-set.sh<br><br>pom_g=com.zth<br>pom_a=hello-debuggingWorld<br>pom_v=1.0-SNAPSHOT<br>pom_r=snapshots<br><br><br><span class="hljs-function"><span class="hljs-title">deploy_war</span></span>() &#123;<br>        target_d=war/<span class="hljs-variable">$&#123;pom_a&#125;</span>-<span class="hljs-variable">$&#123;pom_v&#125;</span>-<span class="hljs-variable">$work_time</span><br>        target_dir=`<span class="hljs-built_in">pwd</span>`/<span class="hljs-variable">$target_d</span><br>        <span class="hljs-keyword">if</span> [ ! -f <span class="hljs-string">&quot;<span class="hljs-variable">$war</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>                <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;war not exist: <span class="hljs-variable">$war</span>&quot;</span><br>                <span class="hljs-built_in">exit</span> 1<br>        <span class="hljs-keyword">fi</span><br>        unzip -q <span class="hljs-variable">$war</span> -d <span class="hljs-variable">$target_dir</span><br>        cp -r app-conf/* <span class="hljs-variable">$target_dir</span>/WEB-INF/classes/<br>        rm -rf appwar<br>        ln -sf <span class="hljs-variable">$target_d</span>/  appwar<br><br>        ./tomcat.sh stop<br><br>        target_ln=`<span class="hljs-built_in">pwd</span>`/appwar<br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-string">&lt;Context docBase=&quot;&#x27;</span><span class="hljs-variable">$target_ln</span><span class="hljs-string">&#x27;&quot; allowLinking=&quot;true&quot;&gt;</span><br><span class="hljs-string">&lt;/Context&gt;&#x27;</span> &gt; conf/Catalina/localhost/ROOT.xml<br>        ./tomcat.sh start<br>&#125;<br></code></pre></td></tr></table></figure></p><p>tomcat.sh 内容： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;`whoami`&quot;</span> != <span class="hljs-string">&quot;root&quot;</span> ];<span class="hljs-keyword">then</span><br>                <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Error: You must be apps to run this command.&quot;</span><br>                <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;`dirname <span class="hljs-variable">$0</span>`&quot;</span><br>. ../bin/env-set.sh<br>. ./pom.sh<br><br><span class="hljs-built_in">export</span> CATALINA_BASE=<span class="hljs-string">&quot;`pwd`&quot;</span><br>tomcat <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;pom_a&#125;</span>-<span class="hljs-variable">$&#123;pom_v&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure></p><p>文件结构： <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"> ├── apache-tomcat -&gt; /usr/local/apache-maven-<span class="hljs-number">3.8</span>.<span class="hljs-number">4</span>/<br>├── jdk -&gt; /usr/local/jdk1.<span class="hljs-number">8.0</span>_211/<br>└── services<br>    ├── bin<br>    │   └── env-set.sh<br>    └── hello-debuggingworld<br>        ├── app-conf<br>        │   └── app.properties<br>        ├── appwar -&gt; war/hello-debuggingWorld-<span class="hljs-number">1.0</span>-SNAPSHOT-<span class="hljs-number">2022</span>-<span class="hljs-number">03</span>-<span class="hljs-number">08</span>_23-<span class="hljs-number">57</span>-<span class="hljs-number">57</span>/<br>        ├── conf<br>        │   ├── Catalina<br>        │   │   └── localhost<br>        │   │       └── ROOT.<span class="hljs-keyword">xml</span><br>        <span class="hljs-title">│   ├── catalina</span>.policy<br>        │   ├── catalina.properties<br>        │   ├── context.<span class="hljs-keyword">xml</span><br>        <span class="hljs-title">│   ├── jaspic-providers</span>.<span class="hljs-keyword">xml</span><br>        <span class="hljs-title">│   ├── jaspic-providers</span>.xsd<br>        │   ├── logging.properties<br>        │   ├── server.<span class="hljs-keyword">xml</span><br>        <span class="hljs-title">│   ├── tomcat-users</span>.<span class="hljs-keyword">xml</span><br>        <span class="hljs-title">│   ├── tomcat-users</span>.xsd<br>        │   └── web.<span class="hljs-keyword">xml</span><br>        <span class="hljs-title">├── deploy</span>.sh<br>        ├── jenkins.sh<br>        ├── logs<br>        ├── pom.sh<br>        ├── tomcat.sh<br>        ├── war<br>        │   ├── hello-debuggingWorld-<span class="hljs-number">1.0</span>-SNAPSHOT-<span class="hljs-number">2022</span>-<span class="hljs-number">03</span>-<span class="hljs-number">08</span>_23-<span class="hljs-number">57</span>-<span class="hljs-number">57</span><br>        │   │   ├── <span class="hljs-keyword">META</span><span class="hljs-literal">-INF</span><br>        │   │   └── WEB<span class="hljs-literal">-INF</span><br>        │   └── hello-debuggingWorld-<span class="hljs-number">1.0</span>-SNAPSHOT.war<br>        ├── webapps<br>        └── work<br>            └── Catalina<br>                └── localhost<br>                    └── ROOT<br></code></pre></td></tr></table></figure></p><p>执行 deploy.sh 脚本完成更新</p><p><ahref="https://github.com/debuggingworld/jenkinsScript.git">代码地址</a></p><h3 id="自动推送">2. 自动推送</h3><p>自动推送方式采用在 jenkins 构建完成之后，执行远程 sh脚本用于下载本次构建 WAR 包，在自动部署重启。基 jenkins 配置如下：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220309012019.png" /></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">BUILD_ID=dontKillMe<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$BUILD_ID</span><br>ssh root@192.168.60.10 BUILD_URL=<span class="hljs-variable">$BUILD_URL</span> /root/svr/services/hello-debuggingworld/jenkins.sh<br></code></pre></td></tr></table></figure><p>【注】需要设置免密登录（添加公钥到服务器）</p><h3 id="配置文件更新">3. 配置文件更新</h3><p>在跌代的过程中要经过四个环境，每个环境的配置信息是不一样的，如何在更新项目的时候把对应的配置文件也更新了呢?有一种做法是采用 Disconf 之类的配置系统来管理各个环境的配置，也可以采用一个简单些的方案: 把当前环境 的配置文件放到 app-conf目录下，等更新脚本的时候会一同覆盖原来的配置文件。 </p><h3 id="版本回滚">4. 版本回滚</h3><p>之前在部署的时候是通过软链接的形式指向指定程序目录，而且原历史版本不会删除，回滚的时候只要把原软链接指定历史程序目录即可。而且配置文件也会一同回滚。</p><h3 id="更新脚本说明">5. 更新脚本说明</h3><p>deploy.sh 部署脚本中还用到了 pom.sh 与 tomcat.sh等脚本，这些脚本的作用是什么呢？整体逻辑如下依赖关系如下:</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220309001255.png" /></p><ul><li>env-set.sh : 设置 jvm 、Tomcat 等环境参数</li><li>pom.sh: 设置当前项目的 groupid 、artifact、version 信息</li><li>tomcat.sh：启动关闭 Tomcat</li><li>deploy.sh : 下载并部署项目</li><li>jenkins.sh: 用于被 jenkins 远程触发下载指定更新版本</li></ul>]]></content>
    
    
    <categories>
      
      <category>jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven——nexus私服搭建</title>
    <link href="/2022/02/28/maven%E2%80%94%E2%80%94nexus%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/02/28/maven%E2%80%94%E2%80%94nexus%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="私服使用场景">1. 私服使用场景</h3><ol type="1"><li>公司不能连接公网，可以用一个私服务来统一连接</li><li>公司内部 jar 组件的共享</li></ol><h3 id="nexus-下载安装">2. nexus 下载安装</h3><p>nexus 下载地址：https://sonatype-download.global.ssl.fastly.net/nexus/oss/nexus-2.14.5-02-bundle.tar.gz</p><p><strong>解压并设置环境变量</strong></p><p>解压： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -zxvf nexus-2.14.5-02-bundle.tar.gz<br></code></pre></td></tr></table></figure> 在环境变量当中设置启动用户： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /etc/profile<br><span class="hljs-comment">#添加 profile 文件。安全起见不建议使用root用户，如果使用其它用户需要加相应权限</span><br><span class="hljs-built_in">export</span> RUN_AS_USER=root<br><br><span class="hljs-comment"># 配置生效</span><br><span class="hljs-built_in">source</span> /etc/profile <br></code></pre></td></tr></table></figure></p><p>配置启动参数： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">vi <span class="hljs-variable">$&#123;nexusBase&#125;</span>/conf/nexus.properties<br><span class="hljs-comment">#端口号</span><br>application-port=8081<br></code></pre></td></tr></table></figure> 启动与停止nexus： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#启动</span><br><span class="hljs-variable">$&#123;nexusBase&#125;</span>/bin/nexus start<br><span class="hljs-comment">#停止</span><br><span class="hljs-variable">$&#123;nexusBase&#125;</span>/bin/nexus stop<br></code></pre></td></tr></table></figure> 登录nexus 界面 http://192.168.60.10:8081/nexus/ 用户名:admin密码：admin123</p><h3 id="nexus-仓库介绍">3. nexus 仓库介绍</h3><p>3rd party：第三方仓库 Apache Snapshots：apache 快照仓库 Central:maven 中央仓库 Releases：私有发布版本仓库 Snapshots：私有快照版本仓库</p><p>配置阿里云远程仓库：http://maven.aliyun.com/nexus/content/groups/public/</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220301232931.png" /></p><h3 id="本地远程仓库配置">4. 本地远程仓库配置</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220301232522.png" /></p><p>在pom 中配置远程仓库： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-public<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>my nexus repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>192.168.60.10:8081/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p>或者在settings.xml 文件中配置远程仓库镜像 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://192.168.60.10:8081/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>        <br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure> 添加依赖：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure> 执行 mvn compile：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220301234516.png" /></p><p>远程仓库：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220301235001.png" /></p><h3 id="发布项目至-nexus-远程仓库">5. 发布项目至 nexus 远程仓库</h3><p>pom.xml 配置仓库地址：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-release<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>nexus release<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://192.168.60.10:8081//nexus/content/repositories/releases/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">snapshotRepository</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-snapshot<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>nexus snapshot<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://192.168.60.10:8081//nexus/content/repositories/snapshots/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">snapshotRepository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>setting.xml 中设置 server： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-snapshot<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>deployment<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>deployment123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-release<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>deployment<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>deployment123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220302000735.png" /></p><p>pom.xml: <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.zth<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>myplugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p>执行 mvn deploy：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220302001136.png" /></p><p><ahref="https://zhuanlan.zhihu.com/p/443204695">maven配置多仓库</a></p>]]></content>
    
    
    <categories>
      
      <category>maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>docker——docker compose 实践</title>
    <link href="/2022/02/28/docker%E2%80%94%E2%80%94docker%20compose%20%E5%AE%9E%E8%B7%B5/"/>
    <url>/2022/02/28/docker%E2%80%94%E2%80%94docker%20compose%20%E5%AE%9E%E8%B7%B5/</url>
    
    <content type="html"><![CDATA[<p>docker-compose.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">services:</span><br>  <span class="hljs-attr">minio:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">xxxx-registry.cn-beijing.cr.aliyuncs.com/public/minio/minio:RELEASE.2025-03-12T18-04-18Z</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">server</span> <span class="hljs-string">--console-address</span> <span class="hljs-string">&quot;:9000&quot;</span>  <span class="hljs-string">--address</span> <span class="hljs-string">&quot;:9001&quot;</span> <span class="hljs-string">/data</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">debuggingworld_minio</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">minio</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9000:9000&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9001:9001&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/data/middleware/minio/data:/data</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MINIO_ROOT_USER:</span> <span class="hljs-string">minioAdmin</span><br>      <span class="hljs-attr">MINIO_ROOT_PASSWORD:</span> <span class="hljs-string">minioAdmin</span><br>    <span class="hljs-attr">healthcheck:</span><br>      <span class="hljs-attr">test:</span> [ <span class="hljs-string">&quot;CMD&quot;</span>, <span class="hljs-string">&quot;mc&quot;</span>, <span class="hljs-string">&quot;ready&quot;</span>, <span class="hljs-string">&quot;local&quot;</span> ]<br>      <span class="hljs-attr">interval:</span> <span class="hljs-string">5s</span><br>      <span class="hljs-attr">timeout:</span> <span class="hljs-string">5s</span><br>      <span class="hljs-attr">retries:</span> <span class="hljs-number">5</span><br><br>  <span class="hljs-attr">mysql:</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">xxxx-registry.cn-beijing.cr.aliyuncs.com/public/mysql:8.4.4</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">debuggingworld_mysql</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/data/middleware/mysql/data:/var/lib/mysql</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/data/middleware/mysql/conf.d:/etc/mysql/conf.d</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/data/middleware/mysql/docker-entrypoint-initdb.d:/docker-entrypoint-initdb.d</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">MYSQL_ROOT_PASSWORD:</span> <span class="hljs-string">admin123</span><br>      <span class="hljs-attr">TZ:</span> <span class="hljs-string">Asia/Shanghai</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;3306:3306&quot;</span><br><br>  <span class="hljs-attr">redis:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">xxxx-registry.cn-beijing.cr.aliyuncs.com/public/redis:7.4.2</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">debuggingworld_redis</span><br>    <span class="hljs-attr">restart:</span> <span class="hljs-string">always</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;6379&quot;</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/data/middleware/redis/data:/data</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/data/middleware/redis/redis.conf:/usr/local/etc/redis/redis.conf</span><br>    <span class="hljs-attr">command:</span> <span class="hljs-string">redis-server</span> <span class="hljs-string">/usr/local/etc/redis/redis.conf</span><br><br>  <span class="hljs-attr">roseFinch_backend:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">xxxx-registry.cn-beijing.cr.aliyuncs.com/xxxx/rosefinch-backend:rosefinch-backend_master-202504231953-1ffbe0</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">rosefinch_backend</span><br>    <span class="hljs-attr">environment:</span><br>      <span class="hljs-attr">ROSEFINCH_MYSQL_URL:</span> <span class="hljs-string">&quot;jdbc:mysql://debuggingworld_mysql:3306/user_center?useUnicode=true&amp;characterEncoding=UTF-8&amp;serverTimezone=GMT%2B8&amp;useSSL=false&amp;allowPublicKeyRetrieval=true&quot;</span><br>      <span class="hljs-attr">ROSEFINCH_MYSQL_PASSWORD:</span> <span class="hljs-string">admin123</span><br>      <span class="hljs-attr">ROSEFINCH_MYSQL_USERNAME:</span> <span class="hljs-string">root</span><br>      <span class="hljs-attr">ROSEFINCH_REDIS_HOST:</span> <span class="hljs-string">debuggingworld_redis</span><br>      <span class="hljs-attr">ROSEFINCH_REDIS_PASSWORD:</span> <span class="hljs-string">admin123</span><br>      <span class="hljs-attr">ROSEFINCH_REDIS_PORT:</span> <span class="hljs-number">6379</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;9991&quot;</span><br>    <span class="hljs-attr">command:</span> [ <span class="hljs-string">&quot;java&quot;</span>, <span class="hljs-string">&quot;-Xmx1800M&quot;</span>, <span class="hljs-string">&quot;-Xms1800M&quot;</span>, <span class="hljs-string">&quot;-jar&quot;</span>, <span class="hljs-string">&quot;/mnt/sz-service-admin-0.8.7-SNAPSHOT.jar&quot;</span>, <span class="hljs-string">&quot;--spring.profiles.active=delivered&quot;</span> ]<br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;mysql&quot;</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;redis&quot;</span><br><br>  <span class="hljs-attr">roseFinch_frontend:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">xxxx-registry.cn-beijing.cr.aliyuncs.com/xxxx/rosefinch_frontend:privatization-202504301508-edaf67</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">rosefinch_frontend</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;80&quot;</span><br><br>  <span class="hljs-attr">nginx:</span><br>    <span class="hljs-attr">image:</span> <span class="hljs-string">xxxx-registry.cn-beijing.cr.aliyuncs.com/public/nginx:1.27.4</span><br>    <span class="hljs-attr">container_name:</span> <span class="hljs-string">debuggingworld_nginx</span><br>    <span class="hljs-attr">hostname:</span> <span class="hljs-string">nginx</span><br>    <span class="hljs-attr">volumes:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">/data/middleware/nginx/nginx.conf:/etc/nginx/nginx.conf:ro</span><br>    <span class="hljs-attr">ports:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">&quot;81:81&quot;</span><br>    <span class="hljs-attr">depends_on:</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">roseFinch_backend</span><br>      <span class="hljs-bullet">-</span> <span class="hljs-string">roseFinch_frontend</span><br></code></pre></td></tr></table></figure><p>nginx.conf:</p><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">events</span> &#123;&#125;<br><br><span class="hljs-section">http</span> &#123;<br>    <span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span> <span class="hljs-number">81</span>;<br>        <span class="hljs-attribute">server_name</span> localhost;<br><br>        <span class="hljs-attribute">location</span> / &#123;<br>            <span class="hljs-attribute">proxy_pass</span> http://rosefinch_frontend:80;<br>        &#125;<br><br>        <span class="hljs-attribute">location</span> /api/admin/ &#123;<br>            <span class="hljs-attribute">proxy_pass</span> http://rosefinch_backend:9991;<br>            <span class="hljs-attribute">proxy_set_header</span> Host syno-tag.modelbest.co; <span class="hljs-comment"># 动态域名</span><br>            <span class="hljs-attribute">proxy_set_header</span> X-Real-IP $remote_addr;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-For $proxy_add_x_forwarded_for;<br>            <span class="hljs-attribute">proxy_set_header</span> X-Forwarded-Proto $scheme;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>docker</category>
      
    </categories>
    
    
    <tags>
      
      <tag>docker</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven——生命周期与自定义插件开发</title>
    <link href="/2022/02/28/maven%E2%80%94%E2%80%94%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <url>/2022/02/28/maven%E2%80%94%E2%80%94%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h3 id="生命周期">1. 生命周期</h3><h4 id="生命周期的概念与意义">1.1 生命周期的概念与意义</h4><p>在项目构建时通常会包含清理、编译、测试、打包、验证、部署，文档生成等步骤，maven统一对其进行了整理抽像成三个生命周期(lifecycle)及各自对应的多个阶段(phase)。这么做的意义是： 1.每个阶段都成为了一个扩展点，可以采用不同的方式来实现，提高了扩展性与灵活性。2. 规范统一了 maven 的执行路径。</p><p>可以通过命令 mvn ${phase name} 直接触发指定阶段的执行如：<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#执行清理 phase</span><br>mvn clean<br><span class="hljs-comment">#执行 compile phase</span><br>mvn compile<br><span class="hljs-comment">#也可以同时执行 清理加编译</span><br>mvn clean comile<br></code></pre></td></tr></table></figure></p><h4 id="maven-三大生命周期与其对应的phase">1.2 maven三大生命周期与其对应的phase</h4><p>maven 总共包含三大生生命周期 1. cleanLifecycle：清理生命周期，用于清理项目 2. defaultLifecycle：默认生命周期，用于编译、打包、测试、部署等 3. siteLifecycle：站点文档生成，用于构建站点文档</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220228203832.png" /></p><p>三大生命周期其相互独立执行，也可以合在一起执行。但 lifecycle 中的phase 是有严格执行的顺序的，比如必须是先执行完 compile 才能执行 pakcage动作，此外 phase 还有包含逻辑存在，即当你执行一个phase 时 其前面的 phase会自动执行（同一生命周期中）。</p><p>https://maven.apache.org/ref/3.5.4/maven-core/lifecycles.html</p><h4 id="生命周期与插件的关系">1.3 生命周期与插件的关系</h4><p>生命周期的 phase组成了项目构建的完整过程，这些过程具体是由插件来实现的。</p><p>比如：test 阶段就是由 maven-surefire-plugin 实现。在 pom.xml中可以设置指定插件目标（gogal）与 phase 绑定，当项目构建到达指定 phase时，就会触发这些插件 gogal 的执行。一个插件有时会实现多个 phase比如：maven-compiler-plugin 插件分别实现了compile 和 testCompile。</p><p>总结： 生命周期的阶段可以绑定具体的插件及目标不同配置下同一个阶段可以对应多个插件和目标</p><h4 id="生命周期与插件的默认绑定">1.4 生命周期与插件的默认绑定</h4><p>在我们的项目当中并没有配置 maven-compiler-plugin 插件,但当执行compile 阶段时一样能够执行编译操作，原因是 maven默认为指定阶段绑定了插件实现。列如以下两个操作在一定程度上是等价的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn compile<br><span class="hljs-comment">#直接执行compile插件目标</span><br>mvn org.apache.maven.plugins:maven-compiler-plugin:3.1:compile<br></code></pre></td></tr></table></figure><p>Default Lifecycle JAR 默认绑定:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">phases</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">process-resources</span>&gt;</span><br>    org.apache.maven.plugins:maven-resources-plugin:2.6:resources<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">process-resources</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">compile</span>&gt;</span><br>    org.apache.maven.plugins:maven-compiler-plugin:3.1:compile<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">compile</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">process-test-resources</span>&gt;</span><br>    org.apache.maven.plugins:maven-resources-plugin:2.6:testResources<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">process-test-resources</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test-compile</span>&gt;</span><br>    org.apache.maven.plugins:maven-compiler-plugin:3.1:testCompile<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test-compile</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span>&gt;</span><br>    org.apache.maven.plugins:maven-surefire-plugin:2.12.4:test<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">package</span>&gt;</span><br>    org.apache.maven.plugins:maven-jar-plugin:2.4:jar<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">install</span>&gt;</span><br>    org.apache.maven.plugins:maven-install-plugin:2.4:install<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">install</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">deploy</span>&gt;</span><br>    org.apache.maven.plugins:maven-deploy-plugin:2.7:deploy<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">deploy</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">phases</span>&gt;</span><br></code></pre></td></tr></table></figure><p>https://maven.apache.org/ref/3.5.4/maven-core/default-bindings.html</p><h3 id="maven-自定义插件开发">2. maven 自定义插件开发</h3><h4 id="maven-插件相关概念">2.1 maven 插件相关概念</h4><p><strong>插件坐标定位：</strong> 插件与普通 jar 包一样包含一组件坐标定位属性即：groupId、artifactId、version，当使用该插件时会从本地仓库中搜索，如果没有即从远程仓库下载</p><p><strong>插件执行 execution：</strong> execution配置包含一组指示插件如何执行的属性： id ： 执行器命名phase：在什么阶段执行？ goals：执行一组什么目标或功能？configuration：执行目标所需的配置文件？</p><p>【例】将插件依赖拷贝到指定目录 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>copy-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>copy-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/alternateLocation<span class="hljs-tag">&lt;/<span class="hljs-name">outputDirectory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">overWriteReleases</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">overWriteReleases</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">overWriteSnapshots</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">overWriteSnapshots</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">excludeTransitive</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">excludeTransitive</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure></p><h4 id="常用插件的使用">2.2 常用插件的使用</h4><p>除了通过配置的方式使用插件以外，Maven也提供了通过命令直接调用插件目标其命令格式如下：</p><p>mvn groupId:artifactId:version:goal -D{参数名}</p><p>【例】展示 pom 的依赖关系树 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn org.apache.maven.plugins:maven-dependency-plugin:2.10:tree<br></code></pre></td></tr></table></figure>也可以直接简化版的命令，但前提必须是 maven 官方插件 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn dependency:tree<br></code></pre></td></tr></table></figure></p><p><strong>查看 pom 文件的最终配置</strong></p><p>mvn help:effective-pom</p><p><strong>原型项目生成</strong> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">archetype:generate<br><span class="hljs-comment">#快速创建一个 WEB 程序</span><br>mvn archetype:generate -DgroupId=tuling -DartifactId=simple-webbapp -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=<span class="hljs-literal">false</span><br><span class="hljs-comment">#快速创建一个java 项目</span><br>mvn archetype:generate -DgroupId=tuling -DartifactId=simple-java -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure></p><h4 id="开发一个自定义插件">2.3 开发一个自定义插件</h4><p>实现步骤： + 创建 maven 插件项目 + 设定 packaging 为 maven-plugin +添加插件依赖 + 编写插件实现逻辑 + 打包构建插</p><p>pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.zth<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>myplugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-plugin-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugin-tools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-plugin-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>插件实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 猫和少年</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2022-02-28 21:31</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Slogan</span> 才疏学浅，少年登科；满腹经纶，白发不第</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Mojo(name = &quot;debuggingWorld&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPlugin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMojo</span> </span>&#123;<br>    <span class="hljs-meta">@Parameter</span><br>    String name;<br><br>    <span class="hljs-meta">@Parameter</span><br>    String describe;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MojoExecutionException, MojoFailureException </span>&#123;<br>        getLog().info(String.format(<span class="hljs-string">&quot;name: %s describe=%s&quot;</span>,name,describe));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>打包到本地仓库： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn install<br></code></pre></td></tr></table></figure></p><p>其他项目使用此插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.zth<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>myplugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>print user info<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>debuggingWorld<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>zth<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">describe</span>&gt;</span>才疏学浅，少年登科；满腹经纶，白发不第<span class="hljs-tag">&lt;/<span class="hljs-name">describe</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><p>执行结果： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh">PS G:\tmp\learnMaven&gt; mvn compile<br>[INFO] Scanning <span class="hljs-keyword">for</span> projects...<br>[INFO] ------------------------------------------------------------------------<br>[INFO] Reactor Build Order:<br>[INFO]<br>[INFO] my-maven                                                           [pom]<br>[INFO] module1                                                            [jar]<br>[INFO]<br>[INFO] --------------------&lt; com.debuggingworld:my-maven &gt;---------------------<br>[INFO] Building my-maven 1.0                                              [1/2]<br>[INFO] --------------------------------[ pom ]---------------------------------<br>[INFO]<br>[INFO] --- myplugin:1.0-SNAPSHOT:debuggingWorld (<span class="hljs-built_in">print</span> user info) @ my-maven ---<br>[INFO] name: zth describe=才疏学浅，少年登科；满腹经纶，白发不第<br>[INFO]<br>[INFO] ---------------------&lt; com.debuggingworld:module1 &gt;---------------------<br><br>....<br><br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven——基本概念与核心配置</title>
    <link href="/2022/02/25/maven%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/02/25/maven%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="maven-安装与核心概念">1. maven 安装与核心概念</h3><p>maven 的功能：编译、打包、测试、依赖管理</p><h4 id="安装">1.1 安装</h4><ol type="1"><li>官网下载 Maven （http://maven.apache.org/download.cgi）</li><li>解压指定目录</li><li>配置环境变量</li><li>检查安装是否成功 （mvn -version）</li></ol><p><ahref="https://blog.csdn.net/weixin_43811057/article/details/108235117">安装参考</a></p><h4 id="maven-编译">1.2 maven 编译</h4><ul><li>创建 maven 项目</li><li>创建 src 文件</li><li>编写 pom 文件</li><li>执行编译命令</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debuggingworld<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>my-maven<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>编译</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ mvn compile<br>[INFO] Scanning <span class="hljs-keyword">for</span> projects...<br>[INFO]<br>[INFO] --------------------&lt; com.debuggingworld:my-mavwn &gt;---------------------<br>[INFO] Building my-mavwn 1.0<br>[INFO] --------------------------------[ jar ]---------------------------------<br>[INFO]<br>[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ my-mavwn ---<br>[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!<br>[INFO] skip non existing resourceDirectory G:\tmp\learnMaven\src\main\resources<br>[INFO]<br>[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ my-mavwn ---<br>[INFO] No sources to compile<br>[INFO] ------------------------------------------------------------------------<br>[INFO] BUILD SUCCESS<br>[INFO] ------------------------------------------------------------------------<br>[INFO] Total time:  0.947 s<br>[INFO] Finished at: 2022-02-26T09:58:01+08:00<br>[INFO] ------------------------------------------------------------------------<br></code></pre></td></tr></table></figure><p>maven 采用了约定的方式从指项目结构中获取源码与资源文件进行编译打包。<font color="red"><strong>(约定大于配置)</strong></font></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xl">my-app<br>│ <br>│-pom.xml<br>│<br>└─src<br>    ├─main<br>    │  ├─<span class="hljs-function"><span class="hljs-title">java</span>                        ---&gt;</span> 主源码文件<br>    │  │  └─com<br>    │  │      └─debuggging<br>    │  │          └─app<br>    │  │              └─App.java<br>    │  │<br>    │  └─<span class="hljs-function"><span class="hljs-title">resources</span>                   ---&gt;</span> 主资源文件<br>    └─test<br>        ├─<span class="hljs-function"><span class="hljs-title">java</span>                        ---&gt;</span> 测试源码文件<br>        └─<span class="hljs-function"><span class="hljs-title">resources</span>                   ---&gt;</span> 测试资源文件<br></code></pre></td></tr></table></figure><h4 id="maven-打包">1.3 maven 打包</h4><p>打包命令：mvn package</p><p>【注】执行 package 命令前会自动执行 compile 命令</p><h4 id="maven-单元测试">1.4 maven 单元测试</h4><ul><li>编写测试类</li><li>执行测试命令</li></ul><p>maven 中的测试类做了约定，必须是 Test 开头的类名与 test开头的方法才会执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.debuggingworld;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestHello</span></span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testHello</span><span class="hljs-params">()</span></span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;run test .....&quot;</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行命令： <strong><font color="red"> mvn test</font></strong></p><h4 id="maven-依赖管理">1.5 maven 依赖管理</h4><p>以 junit 为例。</p><ul><li>在 pom 文件中添加 junit 依赖</li><li>编写 junit 测试方法</li><li>执行测试命令</li></ul><p><strong>加入依懒配置</strong> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><strong>编写测试方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.debuggingworld;<br><br><span class="hljs-keyword">import</span> org.junit.Assert;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestHello</span></span>&#123;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>System.out.println(<span class="hljs-string">&quot;run test .....&quot;</span>);<br>Assert.assertEquals(<span class="hljs-string">&quot;hi&quot;</span>,<span class="hljs-string">&quot;hi&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>执行测试命令</strong></p><p><strong><font color="red"> mvn test</font></strong></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220226225016.png" /></p><p>本地仓库位置： 默认在 ~/.m2/respository 下 修改${M2_HOME}/conf/settings.xml  来指定仓库目录 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 指定本地仓库目录--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>G:\.m2\repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br></code></pre></td></tr></table></figure><strong>配置文件以 ~/.m2/settings.xml 为主（优先级大于${M2_HOME}/conf/settings.xml ）</strong></p><p>### 2. maven 核心配置 #### 2.1 项目依懒 项目依赖是指 maven通过依赖传播、依赖优先原则、可选依赖、排除依赖、依赖范围等特性来管理项目ClassPath。</p><p>##### 依赖传播特性项目通常需要依赖第三方组件，而第三方组件又会依赖其它组件，遇到这种情况Maven会将依赖网络中的所有节点都会加入ClassPath当中，这就是Maven的依赖传播特性。</p><p>Spring MVC 的依赖网络： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220227121810.png" /></p><p>项目直接依赖了spring-webmvc叫<strong>直接依赖</strong>，而对commons-logging 依赖是通过 webmvc传递的所以叫<strong>间接依赖</strong>。</p><h5 id="依赖优先原则">依赖优先原则</h5><p>基于依赖传播特性，导致整个依赖网络会很复杂，难免会出现相同组件不同版本的情况。Maven此时会基于依赖优先原则选择其中一个版本。</p><p>第一原则：最短路径优先。 第二原则：相同路径下配置在前的优先（非同一pom 引入）。</p><p>添加 commons-logging 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220227125217.png" /></p><p>spring-webmvc 中引入 1.1.3 版本 commons-logging，而项目中直接依赖了1.2 版本时，基于最短路径原则项目最终引入的是1.2版本。</p><p><strong>注意</strong>：在同一pom文件，配置同一依赖的不同版本，以配置在后面的版本为准。</p><h5 id="可选依赖">可选依赖</h5><p>可选依赖表示这个依赖不是必须的，通过在 &lt;dependency&gt; 添 &lt;optional&gt;true&lt;/optional&gt; 表示。默认是不可选的。</p><p>可选依赖不会被传递。</p><h5 id="排除依赖">排除依赖</h5><p>即排除指定的间接依赖。通过配置 &lt;exclusions&gt;配置排除指定组件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="依赖范围">依赖范围</h5><p>像 junit只有在运行测试用例的时候去要用到，也就是没有必要在打包的时候把 junit.jar包过构建进去。 可以通过 Mave 的依赖范围配置 &lt;scope&gt;来达到这种目的。</p><p>maven 总共支持以下四种依赖范围： + compile(默认):编译范围，编译和打包都会依赖。 +provided：提供范围，编译时依赖，但不会打包进去。如：servlet-api.jar +runtime：运行时范围，打包时依赖，编译不会。如：mysql-connector-java.jar+ test：测试范围，编译运行测试用例依赖，不会打包进去。如：junit.jar +system：表示由系统中 CLASSPATH 指定。编译时依赖，不会打包进去。配合&lt;systemPath&gt; 一起使用。</p><p>例：java.home下的tool.jar <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.sun<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;java.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>system<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">systemPath</span>&gt;</span>$&#123;java.home&#125;/../lib/tools.jar<span class="hljs-tag">&lt;/<span class="hljs-name">systemPath</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure> <imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220227154002.png" /></p><p>system 除了可以用于引入系统 classpath 中包，也可以用于引入系统非maven 收录的第三方Jar，做法是将第三方Jar放置在项目的 lib目录下，然后配置 相对路径，但因 system 不会打包进去所以需要配合maven-dependency-plugin 插件配合使用。当然还是推荐通过将第三方 Jar 手动install 到仓库。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220227163955.png" /></p><p><strong>通过插件将 system 的 jar 打包进去</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-war-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">failOnMissingWebXml</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">failOnMissingWebXml</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 通过插件 将system 的jar 打包进去。 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>copy-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>copy-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/$&#123;project.build.finalName&#125;/WEB-INF/lib<span class="hljs-tag">&lt;/<span class="hljs-name">outputDirectory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includeScope</span>&gt;</span>system<span class="hljs-tag">&lt;/<span class="hljs-name">includeScope</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">excludeGroupIds</span>&gt;</span>com.sun<span class="hljs-tag">&lt;/<span class="hljs-name">excludeGroupIds</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220227163811.png" /></p><p><strong>手动加入本地仓库</strong> <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn install:install-file -Dfile=localJar-1.0.jar -DgroupId=com.zth  -DartifactId=localJar -Dversion=1.0 -Dpackaging=jar<br></code></pre></td></tr></table></figure> 执行结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220227164849.png" /></p><h4 id="项目聚合与继承">2.2 项目聚合与继承</h4><h5 id="聚合">聚合</h5><p>是指将多个模块整合在一起，统一构建。聚合需要在父工程中使用&lt;modules&gt; 进行配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>module1<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>module2<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="继承">继承</h5><p>继承是指子工程直接继承父工程中的属性、依赖、插件等配置，避免重复配置。+ .属性继承 + 依赖继承 + .插件继承</p><p>上面的三个配置子工程都可以进行重写，重写之后以子工程的为准。</p><h5 id="依赖管理">依赖管理</h5><p>通过继承的特性，子工程是可以间接依赖父工程的依赖，但多个子工程依赖有时并不一致，这时就可以在父工程中加入&lt;dependencyManagement&gt;声明该功程需要的JAR包，然后在子工程中引入。</p><p>父工程中声明： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p>子工程中引入 : <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure></p><h5 id="项目属性">项目属性</h5><p><a href="https://www.jianshu.com/p/82233bdc917c">maven 属性</a></p><p>通过 &lt;properties&gt; 配置 属性参数，可以简化配置。 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置proName属性 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">proName</span>&gt;</span>ddd<span class="hljs-tag">&lt;/<span class="hljs-name">proName</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure>引用方式 ${proName}</p><h4 id="项目构建配置">2.3 项目构建配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.MF<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.XML<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>说明： resources，build过程中涉及的资源文件 +targetPath：资源文件的目标路径 + directory：资源文件的路径，默认位于${basedir}/src/main/resources/ 目录下 +includes：一组文件名的匹配模式，被匹配的资源文件将被构建过程处理 +excludes：一组文件名的匹配模式，被匹配的资源文件将被构建过程忽略。同时被includes 和 excludes 匹配的资源文件，将被忽略。 + filtering： 默认false。true 表示通过参数对资源文件中的 ${key}在编译时进行动态变更。替换源可以 -Dkey 和 pom 中的 &lt;properties&gt; 值或  &lt;filters&gt; 中指定的 properties 文件。</p>]]></content>
    
    
    <categories>
      
      <category>maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git——搭建私有Git服务</title>
    <link href="/2022/02/23/Git%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89Git%E6%9C%8D%E5%8A%A1/"/>
    <url>/2022/02/23/Git%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89Git%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="git-支持的四种通信协议">1. git 支持的四种通信协议</h3><ul><li>Local(本地协议)</li><li>ssh</li><li>http(Dumb、Smart)</li><li>git</li></ul><h4 id="local本地协议">1. 1 Local(本地协议)</h4><p>基于本地文件系统或共享（NFS）文件系统进行访问.</p><p>优点：简单，直接使用了现有的文件权限和网络访问权限。缺点：这种协议的缺陷就是共享文件系统本身的局限，只能在局域网，而且速度也慢。适应场景：小团队，小项目临时搭建版本服务。</p><ol type="1"><li>从本地 f/git/atals 目录克隆项目，即使是bare仓库也可以正常下载。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> /f/git/atals/<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>基于 file 协议克隆本地项目 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> file:///f/git/atals/<br></code></pre></td></tr></table></figure> 如果在 URL 开头明确的指定file://，那么 Git 的行为会略有不同。 如果仅是指定路径，Git会尝试使用硬链接（hard link）或直接复制所需要的文件。 如果指定file://，Git会触发平时用于网路传输资料的进程，传输过来的是打包好的文件（gitgc），更节约硬盘空间。</li></ol><h4 id="ssh-协议">1.2 ssh 协议</h4><p>git 支持利用 ssh 协议进行通信，这是绝大部分 linux、uninx系统都支持的，所以利用该协议架 设GIT 版本服务是非常方便的。</p><p>优点：首先SSH 架设相对简单、其次通过 SSH 访问是安全的、另外SSH协议很高效，在传输前也会尽量压缩数据。缺点：权限体系不灵活，必须提供操作系统的帐户密码，哪怕是只需要读取版本。适应场景：小团队、小项目、临时项目</p><h5 id="linux-安装-git-服务">linux 安装 git 服务</h5><ol type="1"><li>安装依赖环境</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>下载并解压源码</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ wget https://github.com/git/git/archive/v2.3.0.zip<br>$ unzip v2.3.0.zip<br>$ <span class="hljs-built_in">cd</span> git-2.3.0<br></code></pre></td></tr></table></figure><p>备用下载链接: https://pan.baidu.com/s/1czwEz8 密码: y3hn</p><ol start="3" type="1"><li>编译安装（如果没有权限就加上sudo） <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">make prefix=/usr/<span class="hljs-built_in">local</span>/git all<br>make prefix=/usr/<span class="hljs-built_in">local</span>/git install<br></code></pre></td></tr></table></figure></li><li>添加环境变量</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /etc/profile<br><span class="hljs-built_in">export</span> PATH=/usr/<span class="hljs-built_in">local</span>/git/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><p>#如果成功显示版本号表示添加成功 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git --version<br>git version 2.3.0<br></code></pre></td></tr></table></figure></p><h5 id="测试-ssh-协议">测试 ssh 协议</h5><p>#创建一个祼项目 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git --bare init debuggingworld.git<br></code></pre></td></tr></table></figure> #本地基于远程克隆仓库 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> root@192.168.60.10:/data/git-repository/debuggingworld.git<br></code></pre></td></tr></table></figure>可能的错误： git-upload-pack: command not found 原因是 ssh协议下只能访问/usr/bin 下的目录，解决办法如下： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ln -s /usr/<span class="hljs-built_in">local</span>/git/bin/git-upload-pack /usr/bin/git-upload-pack<br>ln -s /usr/<span class="hljs-built_in">local</span>/git/bin/git-receive-pack /usr/bin/git-receive-pack<br></code></pre></td></tr></table></figure></p><h4 id="httpdumbsmart">3. http(Dumb、Smart)</h4><p>Git http 协议实现是依懒 WEB容器(apache、nginx)及 cgi组件进行通信交互，并利用 WEB 容器本身权限体系进行授权验证。在 Git 1.6.6前只支持http Dumb（哑）协议，该协议只能下载不能提交，通常会配合 ssh协议一起使用，ssh 分配提交帐号，http dumb 提供只读帐号。1.6.6 之后 git提供了 git-http-backend 的 CGI 用于实现接收远程推送等功能。</p><p>优点：解决了 local 与ssh 权限验证单一的问题、可基于http url提供匿名服务，从而可以放到公网上去。而 local 与 ssh是很难做到这一点，比如实现一个类似github 这样的网站。缺点：架设复杂一些需要部署 WEB服务器，和 https 证书之类的配置场景：大型团队、需要对权限精准控制、需要把服务部署到公网上去</p><h5 id="http-dumb-配置与使用">http Dumb 配置与使用</h5><ol type="1"><li>创建服务端版本仓库 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /data/git-repository<br>git --bare init debuggingworld.git<br><span class="hljs-built_in">cd</span> debuggingworld.git/hooks/<br>// 版本更新钩子，当有版本提交的时候会执行更新<br>mv post-update.sample post-update<br>./post-update<br></code></pre></td></tr></table></figure></li><li>nginx 静态访问配置</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span>  git.tl.com;<br>        <span class="hljs-attribute">location</span> / &#123;<br>            <span class="hljs-attribute">root</span>  /data/git-repository;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本地克隆远程服务 git clone http://git.tl.com/debuggingworld.git</p><p>注：http Smart 协议 是基于 CGI 配合GITgit-http-backend 脚本进行使用，配置较复杂，现在一般不会这么去做，而是采用gitlab、gogs 之类的web管理进行代替。</p><h4 id="git-协议">4. GIT 协议</h4><p>Git 协议是包含在 Git里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH服务，但是访问无需任何授权。</p><p>优点：Git 协议是 Git 使用的网络传输协议里最快的。如果你的项目有很大的访问量，或者你的项目很庞大并且不需要为写进行用户授权，架设Git 守护进程来提供服务是不错的选择。 它使用与 SSH相同的数据传输机制，但是省去了加密和授权的开销。</p><p>缺点：Git 协议缺点是缺乏授权机制。而且9418是一个非标准端口，一般防火墙不会开放。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> debuggingworld.git/<br><span class="hljs-comment"># 创建一个空文件，表示开放该项目</span><br>touch git-daemon-export-ok<br><span class="hljs-comment"># 启动守护进程</span><br><span class="hljs-variable">$nohub</span> git daemon --reuseaddr --base-path=/data/git-repository/ /data/git-repository/ &amp;<br><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#本地克隆远程项目</span><br>git <span class="hljs-built_in">clone</span> git://192.168.0.147:9418/debuggingworld.git<br></code></pre></td></tr></table></figure><h3 id="基于-gogs-搭建私有-git-服务">2. 基于 gogs 搭建私有 GIT 服务</h3><h4 id="gogs-介绍安装">2.1 gogs 介绍安装</h4><p>Gogs 是一款开源的轻量级 Git web服务，其特点是简单易用完档齐全、国际化做的相当不错。其主要功能如下: 1.提供 Http 与 ssh 两种协议访问源码服务 2. 提供可 WEB界面可查看修改源码代码 3.提供较完善的权限管理功能、其中包括组织、团队、个人等仓库权限 4.提供简单的项目 viki 功能 5. 提供工单管理与里程碑管理。</p><p>下载安装 官网：https://gogs.io下载：https://gogs.io/docs/installation 选择 linx amd64 下载安装文档：https://gogs.io/docs/installation/install_from_binary</p><p>解压之后目录：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220223231024.png" /></p><p>运行： <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#前台运行</span><br>./gogs web<br><span class="hljs-comment">#后台运行</span><br><span class="hljs-variable">$nohup</span> ./gogs web &amp;<br></code></pre></td></tr></table></figure> 默认端口：3000</p><p>初次访问http://<host>:3000 会进到初始化页,进行引导配置。</p><p>可选择mysql 或sqlite 等数据。 注：mysql索引长度的问题没有安装成功,需要用mysql5.7 以上版本。</p><h4 id="gogs-定时备份与恢复">2.2 gogs 定时备份与恢复</h4><p>备份与恢复：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#查看备份相关参数</span><br>./gogs backup -h<br><span class="hljs-comment">#默认备份,备份在当前目录</span><br>./gogs backup <br><span class="hljs-comment">#参数化备份  --target 输出目录 --database-only 只备份 db </span><br>./gogs backup --target=./backupes --database-only --exclude-repos<br><span class="hljs-comment">#恢复。执行该命令前要先删除 custom.bak</span><br>./gogs restore --from=gogs-backup-20180411062712.zip<br></code></pre></td></tr></table></figure><p>#自动备份脚本 <figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh -e</span><br>gogs_home=<span class="hljs-string">&quot;/home/apps/svr/gogs/&quot;</span><br>backup_dir=<span class="hljs-string">&quot;<span class="hljs-variable">$gogs_home</span>/backups&quot;</span><br><br><span class="hljs-built_in">cd</span> `dirname <span class="hljs-variable">$0</span>`<br><span class="hljs-comment"># 执行备份命令</span><br>./gogs backup --target=<span class="hljs-variable">$backup_dir</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;backup sucess&#x27;</span><br>day=7<br><span class="hljs-comment">#查找并删除 7天前的备份  </span><br>find <span class="hljs-variable">$backup_dir</span> -name <span class="hljs-string">&#x27;*.zip&#x27;</span> -mtime +7 -<span class="hljs-built_in">type</span> f |xargs rm -f;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;delete expire back data!&#x27;</span><br><br><span class="hljs-comment">#添加定时任务 每天4：00执行备份</span><br><span class="hljs-comment"># 打开任务编辑器</span><br>crontab -e<br><span class="hljs-comment"># 输入如下命令 00 04 * * * 每天凌晨4点执行 do-backup.sh 并输出日志至 #backup.log</span><br>00 04 * * * /home/apps/svr/gogs/do-backup.sh &gt;&gt; /home/apps/svr/gogs/backup.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure></p><h4 id="客户端公钥配置与添加">2.3 客户端公钥配置与添加</h4><p>SSH公钥创建 1、打开git bash 2、执行生成公钥和私钥的命令：ssh-keygen-t rsa 并按回车3下 3、执行查看公钥的命令：cat ~/.ssh/id_rsa.pub<br />4、拷贝id_rsa.pub 内容至至服务~~/.ssh/authorized_keys 中</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git——reset的三种模式</title>
    <link href="/2022/02/22/Git%E2%80%94%E2%80%94reset%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/02/22/Git%E2%80%94%E2%80%94reset%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="reset-的三种模式">1. reset 的三种模式 </h3><ul><li><p>--hard：stage区和工作目录里的内容会被完全重置为和指定 HEAD 位置相同的内容。</p></li><li><p>--soft：保留工作目录和暂存区中未提交的内容，并把重置 HEAD 所带来的新的差异（回滚掉的commit较回滚后最新commit的修改）放进暂存区。</p></li><li><p>--mixed（默认）：工作区、暂存区未提交的内容以及由 reset 所导致的新差异，都会被放进工作区。</p></li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220222220108.png" /></p><h3 id="reset---hard">2. reset --hard</h3><p>重置 stage 区和工作目录（慎用）。</p><p>在 reset 后面加 --hard 参数时，stage区和工作目录里的内容会被完全重置为和指定 HEAD 位置相同的内容。也就是没有commit的修改会被全部擦掉。执行后工作区、暂存区、版本库保持一致（指定HEAD版本）<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git status<br>On branch master<br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)<br>  (use <span class="hljs-string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="hljs-keyword">in</span> working directory)<br>        modified:   aa.txt<br><br>no changes added to commit (use <span class="hljs-string">&quot;git add&quot;</span> and/or <span class="hljs-string">&quot;git commit -a&quot;</span>)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git <span class="hljs-built_in">log</span><br>commit 79ed69f7fdeb3474c36fa111ee82ef067575ad83 (HEAD -&gt; master)<br>Author: Zhangtao153 &lt;13289265979@163.com&gt;<br>Date:   Wed Nov 25 21:19:27 2020 +0800<br><br>    bb<br><br>commit d40163567818b2ac0b28743058ff9c68a7798390<br>Author: Zhangtao153 &lt;13289265979@163.com&gt;<br>Date:   Wed Nov 25 21:19:03 2020 +0800<br><br>    aa<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git reset --hard HEAD^<br>HEAD is now at d401635 aa<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git <span class="hljs-built_in">log</span><br>commit d40163567818b2ac0b28743058ff9c68a7798390 (HEAD -&gt; master)<br>Author: Zhangtao153 &lt;13289265979@163.com&gt;<br>Date:   Wed Nov 25 21:19:03 2020 +0800<br><br>    aa<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure> ### 3. reset --soft保留工作目录和暂存区中未提交的内容，并把重置 HEAD 所带来的新的差异（回滚掉的commit较回滚后最新commit的修改）放进暂存区。</p><p>可以使用 SoftReset 合并「当前节点」与「reset目标节点」之间不具太大意义的 commit 记录，让 commit 演进线图较为清晰点。</p><p>【示例】工作区添加新文件后reset  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git <span class="hljs-built_in">log</span><br>commit 82ad83fcfcfb366ab7a895053f9b8936aaabf6cf (HEAD -&gt; master)<br>Author: Zhangtao153 &lt;13289265979@163.com&gt;<br>Date:   Wed Nov 25 21:39:37 2020 +0800<br><br>    bb<br><br>commit d40163567818b2ac0b28743058ff9c68a7798390<br>Author: Zhangtao153 &lt;13289265979@163.com&gt;<br>Date:   Wed Nov 25 21:19:03 2020 +0800<br><br>    aa<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git status<br>On branch master<br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br>        bb.txt<br><br>nothing added to commit but untracked files present (use <span class="hljs-string">&quot;git add&quot;</span> to track)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git reset --soft HEAD^<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git <span class="hljs-built_in">log</span><br>commit d40163567818b2ac0b28743058ff9c68a7798390 (HEAD -&gt; master)<br>Author: Zhangtao153 &lt;13289265979@163.com&gt;<br>Date:   Wed Nov 25 21:19:03 2020 +0800<br><br>    aa<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git status<br>On branch master<br>Changes to be committed:<br>  (use <span class="hljs-string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)<br>        modified:   aa.txt<br><br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br>        bb.txt<br></code></pre></td></tr></table></figure> ### 4. reset不加参数(mixed)工作区、暂存区未提交的内容以及由 reset 所导致的新差异，都会被放进工作区。简而言之，就是「把所有差异都混合（mixed）放在工作目录中」。</p><p>【例】工作区修改后添加到暂存区，在工作区添加新文件后reset<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git status<br>On branch master<br>Changes to be committed:<br>  (use <span class="hljs-string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)<br>        modified:   aa.txt<br><br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br>        bb.txt<br><br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git reset HEAD^<br>Unstaged changes after reset:<br>M       aa.txt<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git status<br>On branch master<br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)<br>  (use <span class="hljs-string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="hljs-keyword">in</span> working directory)<br>        modified:   aa.txt<br><br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br>        bb.txt<br><br>no changes added to commit (use <span class="hljs-string">&quot;git add&quot;</span> and/or <span class="hljs-string">&quot;git commit -a&quot;</span>)<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git——底层原理</title>
    <link href="/2022/02/20/Git%E2%80%94%E2%80%94%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <url>/2022/02/20/Git%E2%80%94%E2%80%94%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="git-存储对像">1. GIT 存储对像</h3><p>Git是一个内容寻址文件系统，其核心部分是一个简单的键值对数据库（key-valuedata store），可以向数据库中插入任意内容，它会返回一个用于取回该值的hash键。</p><p>git 键值库中插入数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello debuggingWorld&quot;</span> | git hash-object -w --stdin<br>cfd6e024dbae18ef2b3231ddd0374286bd2fe650<br></code></pre></td></tr></table></figure><p>git 基于键获取指定内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cat-file -p cfd6e024dbae18ef2b3231ddd0374286bd2fe650<br>hello debuggingWorld<br></code></pre></td></tr></table></figure><p>Git 基于该功能把每个文件的版本中内容都保存在数据库中，当要进行版本回滚的时候就通过其中一个键将期取回并替换。</p><p>所以平常用的 git add 其实就是把修改之后的内容插入到键值库中。当执行git add README.md 等同于执行了 git hash-object -w README.md把文件写到数据库中。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220220222727.png" /></p><p>【问题】解决了存储的问题，但其只能存储内容同并没有存储文件名，如果要进行回滚怎么知道哪个内容对应哪个文件呢？树对象解决的就是文件名存储的问题。</p><h3 id="树对像">2. 树对像</h3><p>树对像解决了文件名的问题，它的目的将多个文件名组织在一起，其内包含多个文件名称与其对应的Key和其它树对像的用引用。可以理解成操作系统当中的文件夹，一个文件夹包含多个文件和多个其它文件夹。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220220223413.png" /></p><p>每一个分支当中都关联了一个树对像，存储了当前分支下所有的文件名及对应的key。</p><p>#查看分支树 git cat-file -p master^{tree}[或 commitId]</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220220234038.png" /></p><p>### 3. git 提交对象</p><p>一次提交即为当前版本的一个快照，该快照就是通过提交对像保存，其存储的内容为：一个顶级树对象、上一次提交的对像啥希、提交者用户名及邮箱、提交时间戳、提交评论。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220221000048.png" /></p><p>通过上面的知识，可以推测出从修改一个文件到提交的过程总共生成了三个对像：一个内容对象 ==&gt; 存储了文件内容 一个树对像 ==&gt;存储了文件名及内容对像的key 一个提交对像 ==&gt; 存储了树对像的key及提交评论。</p><h4 id="git-引用">4.git 引用</h4><p>git 总共 有三种类型的引用： + 分支引用 + 远程分支引用 + 标签引用</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220221000853.png" /></p><p>当执行 git branch {branchName} 时创建了一个分支，其本质就是 git基于指定提交创建了一个引用文件，保存在 .git 下。</p><p>如 .git/refs/heads/master 文件保存的是 master 分支的引用</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220221000348.png" /></p><p>创建 dev 分支：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220221000508.png" /></p><p>/.git/refs/tags 保存的是标签引用</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220221001122.png" /></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git——rebase命令</title>
    <link href="/2022/02/17/Git%E2%80%94%E2%80%94rebase%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/02/17/Git%E2%80%94%E2%80%94rebase%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="应用场景">1. 应用场景</h3><ul><li>合并多次提交记录</li><li>分支合并</li><li>对一个分支做『变基』操作</li></ul><h3 id="合并多次提交记录">2. 合并多次提交记录</h3><p>合并最近两次 commit:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase -i HEAD~2<br></code></pre></td></tr></table></figure><p>执行命令后会自动进入 vi 编辑模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">pick 6935383 rename冲突<br>pick 23b1a51 debug<br><br><span class="hljs-comment"># Rebase eb7f366..23b1a51 onto eb7f366 (2 commands)</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Commands:</span><br><span class="hljs-comment"># p, pick &lt;commit&gt; = use commit</span><br><span class="hljs-comment"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="hljs-comment"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="hljs-comment"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="hljs-comment"># f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&#x27;s log message</span><br><span class="hljs-comment"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span><br><span class="hljs-comment"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span><br><span class="hljs-comment"># d, drop &lt;commit&gt; = remove commit</span><br><span class="hljs-comment"># l, label &lt;label&gt; = label current HEAD with a name</span><br><span class="hljs-comment"># t, reset &lt;label&gt; = reset HEAD to a label</span><br><span class="hljs-comment"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span><br><span class="hljs-comment"># .       create a merge commit using the original merge commit&#x27;s</span><br><span class="hljs-comment"># .       message (or the oneline, if no original merge commit was</span><br><span class="hljs-comment"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># However, if you remove everything, the rebase will be aborted.</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>【注】</li><li>p, pick = use commit</li><li>r, reword = use commit, but edit the commit message</li><li>e, edit = use commit, but stop for amending</li><li>s, squash = use commit, but meld into previous commit</li><li>f, fixup = like “squash”, but discard this commit’s log message</li><li>x, exec = run command (the rest of the line) using shell</li><li>d, drop = remove commit</li></ul></blockquote><p>修改提交纪录并保存退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pick 6935383 rename冲突<br>s 23b1a51 debug<br></code></pre></td></tr></table></figure><p>保存后到注释修改界面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># This is a combination of 2 commits.</span><br><span class="hljs-comment"># This is the 1st commit message:</span><br><br>rename冲突<br><br><span class="hljs-comment"># This is the commit message #2:</span><br><br>debug<br><br><span class="hljs-comment"># Please enter the commit message for your changes. Lines starting</span><br><span class="hljs-comment"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Date:      Tue Nov 24 22:56:02 2020 +0800</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># interactive rebase in progress; onto eb7f366</span><br><span class="hljs-comment"># Last commands done (2 commands done):</span><br><span class="hljs-comment">#    pick 6935383 rename冲突</span><br><span class="hljs-comment">#    squash 23b1a51 debug</span><br><span class="hljs-comment"># No commands remaining.</span><br><span class="hljs-comment"># You are currently rebasing branch &#x27;maseter&#x27; on &#x27;eb7f366&#x27;.</span><br></code></pre></td></tr></table></figure><p>（非编辑状态输入dd删除一行）</p><p>保存后即合并完成。</p><blockquote><p>异常情况：</p><p>1、不要合并已提交远程分支的纪录</p><p>如果这样做，可能出现push rejected。解决方式当然是先拉下远程的代码，进行冲突处理，再进行提交。</p><p>2、git rebase -i 异常操作导致退出了vim编辑页面，会提示：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"> $ git rebase -i head~2<br> error: could not apply 040bd4b... commit on issue-005<br> Resolve all conflicts manually, mark them as resolved with<br><span class="hljs-string">&quot;git add/rm &lt;conflicted_files&gt;&quot;</span>, <span class="hljs-keyword">then</span> run <span class="hljs-string">&quot;git rebase --continue&quot;</span>.<br>You can instead skip this commit: run <span class="hljs-string">&quot;git rebase --skip&quot;</span>.<br>To abort and get back to the state before <span class="hljs-string">&quot;git rebase&quot;</span>, run <span class="hljs-string">&quot;git rebase --abort&quot;</span>.<br>Could not apply 040bd4b... commit on issue-005<br>Auto-merging README.md<br>CONFLICT (content): Merge conflict <span class="hljs-keyword">in</span> README.md<br></code></pre></td></tr></table></figure> 使用 git rebase --edit-todo会再次进入刚才编辑错误退出前的vim状态，这时候可以修改你的编辑。</p><p>使用git rebase --abort  表明退出当前的合并请求(又回到原来的2个commit的状态)</p></blockquote><h3 id="变基">3. 变基</h3><p><font color="red">使用场景：本地与远端同一分支提交历史不一致</font></p><p>多个人在同一个分支上协作时，比如由我和A一同开发。我在修复了一个bug以后准备提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git add .<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git commit -m <span class="hljs-string">&quot;debug the world&quot;</span><br>[master a40d43c] debug the world<br> 1 file changed, 0 insertions(+), 0 deletions(-)<br> create mode 100644 aa.txt<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git push origin master<br>To github.com:Zhangtao153/learngit.git<br> ! [rejected]        master -&gt; master (non-fast-forward)<br>error: failed to push some refs to <span class="hljs-string">&#x27;github.com:Zhangtao153/learngit.git&#x27;</span><br>hint: Updates were rejected because the tip of your current branch is behind<br>hint: its remote counterpart. Integrate the remote changes (e.g.<br>hint: <span class="hljs-string">&#x27;git pull ...&#x27;</span>) before pushing again.<br>hint: See the <span class="hljs-string">&#x27;Note about fast-forwards&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;git push --help&#x27;</span> <span class="hljs-keyword">for</span> details.<br></code></pre></td></tr></table></figure><p>push失败了，说明A在我之前已经提交了，我本地master分支的提交历史已经落后远端了，需要先pull一下，与远端同步后才能push<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git pull<br>Merge made by the <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> README.md | 3 ++-<br> 1 file changed, 2 insertions(+), 1 deletion(-)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> --oneline --graph<br>*   912bb85 (HEAD -&gt; master) Merge branch <span class="hljs-string">&#x27;master&#x27;</span> of github.com:Zhangtao153/learngit into master<br>|\<br>| * 7ad4fd6 (origin/master) add a new <span class="hljs-keyword">function</span><br>* | a40d43c debug the world<br>|/<br>* a8d2e0d 手动删除<br>* 1d243ca add <span class="hljs-built_in">test</span> file<br>* 8438389 wrote a readme file<br></code></pre></td></tr></table></figure>竟然分叉了！由于我本地master的提交历史和远端的master分支的提交历史不一致，所以git为我进行了自动合并，然后生成了一个新的提交历史。</p><p>这个时候就可以用 git rebase 解决分叉的问题。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git rebase<br>Successfully rebased and updated refs/heads/master.<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> --oneline --graph<br>* 4178b6e (HEAD -&gt; master) debug the world<br>* 7ad4fd6 (origin/master) add a new <span class="hljs-keyword">function</span><br>* a8d2e0d 手动删除<br>* 1d243ca add <span class="hljs-built_in">test</span> file<br>* 8438389 wrote a readme file<br></code></pre></td></tr></table></figure>然后再push，将本地修改同步到远端。</p><p><font color="red">git pull --rebase </font> 和上面的效果一致。</p><h3 id="合并分支">4. 合并分支</h3><p>先创建一个分支用于解决bug <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b issues-001<br>Switched to a new branch <span class="hljs-string">&#x27;issues-001&#x27;</span><br></code></pre></td></tr></table></figure> 接下解决bug，然后保存提交<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issues-001)<br>$ git add .<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issues-001)<br>$ git commit -m <span class="hljs-string">&quot;issues-001&quot;</span><br>[issues-001 7a55a26] issues-001<br> 1 file changed, 1 insertion(+)<br></code></pre></td></tr></table></figure> 先尝试通过 <font color="red">merge</font> 合并：<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issues-001)<br>$ git switch master<br>Switched to branch <span class="hljs-string">&#x27;master&#x27;</span><br>Your branch is ahead of <span class="hljs-string">&#x27;origin/master&#x27;</span> by 1 commit.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> to publish your <span class="hljs-built_in">local</span> commits)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git merge issues-001<br>Merge made by the <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> aa.txt | 1 +<br> 1 file changed, 1 insertion(+)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> --oneline --graph<br>*   ae02ea0 (HEAD -&gt; master) Merge branch <span class="hljs-string">&#x27;issues-001&#x27;</span> into master<br>|\<br>| * 7a55a26 (issues-001) issues-001<br>* | d36d166 commit on master<br>|/<br>* 4178b6e (origin/master) debug the world<br>* 7ad4fd6 add a new <span class="hljs-keyword">function</span><br>* a8d2e0d 手动删除<br>* 1d243ca add <span class="hljs-built_in">test</span> file<br>* 8438389 wrote a readme file<br></code></pre></td></tr></table></figure>虽然合并成功，但是Master已经保存了合并历史，出现开叉了！</p><p>通过 <font color="red">rebase</font> 合并分支</p><p>先将代码回退到merge之前 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git reset --hard HEAD^<br>HEAD is now at d36d166 commit on master<br></code></pre></td></tr></table></figure>先切换回issues-001分支，在issues-001分支上执行: git rebase master<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git switch issues-001<br>Switched to branch <span class="hljs-string">&#x27;issues-001&#x27;</span><br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issues-001)<br>$ git rebase master<br>Successfully rebased and updated refs/heads/issues-001.<br></code></pre></td></tr></table></figure>【注】如果rebase出现冲突，先解决冲突，然后通过add添加，之前的rebase其实只是完成了一半，由于出现冲突而终止，冲突解决之后，可以通过<font color="red">git rebase —continue</font> 继续完成之前的 rebase操作。</p><p>切换到主分支master，将issues-001分支上的提交合并过来。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issues-001)<br>$ git switch master<br>Switched to branch <span class="hljs-string">&#x27;master&#x27;</span><br>Your branch is ahead of <span class="hljs-string">&#x27;origin/master&#x27;</span> by 1 commit.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> to publish your <span class="hljs-built_in">local</span> commits)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git merge issues-001<br>Updating d36d166..43823d4<br>Fast-forward<br> aa.txt | 1 +<br> 1 file changed, 1 insertion(+)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> --oneline --graph<br>* 43823d4 (HEAD -&gt; master, issues-001) issues-001<br>* d36d166 commit on master<br>* 4178b6e (origin/master) debug the world<br>* 7ad4fd6 add a new <span class="hljs-keyword">function</span><br>* a8d2e0d 手动删除<br>* 1d243ca add <span class="hljs-built_in">test</span> file<br>* 8438389 wrote a readme file<br></code></pre></td></tr></table></figure>master是一条直线了。最后删除掉issues-001分支。 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git branch -d issues-001<br>Deleted branch issues-001 (was 43823d4).<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git——核心概念与基本操作</title>
    <link href="/2022/02/13/Git%E2%80%94%E2%80%94%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/02/13/Git%E2%80%94%E2%80%94%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="基本概念">1. 基本概念 </h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/07c78b7d376f4c8793b53a43f0a2a7fa.png" /></p><ul><li><strong>工作区</strong>：能看到的目录</li><li><strong>暂存区</strong>：stage 或 index。一般存放在 .git/index中，所以把暂存区有时也叫作索引（index）。</li><li><strong>版本库</strong>：工作区有一个隐藏目录 .git 就是 Git的版本库。</li></ul><p>文件入库流程：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220213233336.png" /></p><blockquote><p> 图中左侧为工作区，右侧为版本库。"index" 为是暂存区（stage/index），"master" 是 master 分支所代表的目录树。</p><ul><li><p>图中的 objects 标识的区域为 Git 的对象库，实际位于 ".git/objects"目录下，里面包含了创建的各种对象及内容。</p></li><li><p>当对工作区修改（或新增）的文件执行 gitadd 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</p></li><li><p>当执行提交操作（gitcommit）时，暂存区的目录树写到版本库（对象库）中，master分支会做相应的更新。即 master指向的目录树就是提交时暂存区的目录树。</p></li><li><p>当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master分支指向的目录树所替换，但是工作区不受影响。</p></li><li><p>当执行 git rm --cached&lt;file&gt; 命令时，会直接从暂存区删除文件，工作区则不做出改变。</p></li><li><p>当执行 git checkout . 或者 git checkout --&lt;file&gt; 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</p></li><li><p>当执行 git checkout HEAD . 或者 git checkout HEAD&lt;file&gt; 命令时，会用 HEAD 指向的 master分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</p></li></ul></blockquote><h3 id="创建版本库">2. 创建版本库</h3><h4 id="git-init-初始化仓库">2.1  git init 初始化仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git init<br>Initialized empty Git repository <span class="hljs-keyword">in</span> G:/learngit/.git/<br></code></pre></td></tr></table></figure><h4 id="git-add-跟踪文件">2.2 git add 跟踪文件</h4><p>git add &lt;directory&gt; 添加指定目录至暂存区 git add -A           添加所有 git  add  &lt;file&gt;   跟踪指定文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add README.md<br></code></pre></td></tr></table></figure><h4 id="git-commit-提交到仓库">2.3 git commit 提交到仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -m <span class="hljs-string">&quot;wrote a readme file&quot;</span><br>[master (root-commit) 8438389] wrote a readme file<br> 1 file changed, 2 insertions(+)<br> create mode 100644 README.md<br></code></pre></td></tr></table></figure><h4 id="git-status-查看-git-状态">2.4 git status 查看 git 状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status<br>On branch master<br>nothing to commit, working directory clean<br></code></pre></td></tr></table></figure><h4 id="移出暂存区">2.5 移出暂存区</h4><p>git rm --cached target -r 将指定目录及子目录移除出暂存区</p><h3 id="版本管理">3. 版本管理</h3><h4 id="git-diff-查看修改内容">3.1 git diff 查看修改内容</h4><ul><li>git diff：比较的是工作区和暂存区之间的差异</li><li>git diff HEAD：比较的是工作区和版本库之间的差异</li><li>git diff --cached：比较的是工作区和版本库之间的差异<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git diff README.md<br>diff --git a/README.md b/README.md<br>index d8036c1..013b5bc 100644<br>--- a/README.md<br>+++ b/README.md<br>@@ -1,2 +1,2 @@<br>-Git is a version control system.<br>+Git is a distributed version control system.<br> Git is free software.<br>\ No newline at end of file<br></code></pre></td></tr></table></figure></li></ul><h4 id="git-reset-回退到上一版本">3.2 git reset 回退到上一版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reset --hard HEAD^<br>HEAD is now at 8438389 wrote a readme file<br></code></pre></td></tr></table></figure><p>在 Git中，用 HEAD 表示当前版本，上一个版本就是HEAD<sup>，上上一个版本就是HEAD，当然往上100个版本写100个</sup>比较容易数不过来，所以写成HEAD~100。</p><h4 id="回到回退之前版本">3.3 回到回退之前版本</h4><p>Git 提供了一个命令 git reflog 用来记录你的每一次命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reflog<br>8438389 HEAD@&#123;0&#125;: reset: moving to HEAD^<br>43597ec HEAD@&#123;1&#125;: commit: add distributed<br>8438389 HEAD@&#123;2&#125;: commit (initial): wrote a readme file<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git reset --hard 43597ec<br>HEAD is now at 43597ec add distributed<br></code></pre></td></tr></table></figure><h4 id="撤销工作区修改">3.4 撤销工作区修改</h4><p>命令：<strong><font color="red">git checkout  -- file</font></strong></p><p>作用：撤销工作区的全部修改，这里有两种情况：</p><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p><h4 id="撤销暂存区修改">3.5 撤销暂存区修改</h4><p>命令： git  reset  HEAD  &lt;file&gt;</p><p>作用：把暂存区的修改回退到工作区。HEAD 表示最新的版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reset HEAD README.md<br>Unstaged changes after reset:<br>M       README.md<br></code></pre></td></tr></table></figure><h4 id="删除文件">3.6 删除文件</h4><p>先手动删除文件，然后使用 git add &lt;file&gt; 的效果和 git rm&lt;file&gt; 是一样的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git rm test.txt<br>rm <span class="hljs-string">&#x27;test.txt&#x27;</span><br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git status<br>On branch master<br>Changes to be committed:<br>  (use <span class="hljs-string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)<br><br>        deleted:    test.txt<br></code></pre></td></tr></table></figure><h3 id="远程仓库">4. 远程仓库</h3><h4 id="添加远程仓库">4.1 添加远程仓库</h4><p>命令：git  remote  add  origin &lt;URL&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$  git remote add origin git@github.com:Zhangtao153/learngit.git<br></code></pre></td></tr></table></figure> #### 4.2推送本地库内容到远程库 命令：git push origin &lt;branch-name&gt;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push -u origin master<br>Warning: Permanently added the RSA host key <span class="hljs-keyword">for</span> IP address <span class="hljs-string">&#x27;192.30.255.112&#x27;</span> to the list of known hosts.<br>Counting objects: 10, <span class="hljs-keyword">done</span>.<br>Delta compression using up to 4 threads.<br>Compressing objects: 100% (7/7), <span class="hljs-keyword">done</span>.<br>Writing objects: 100% (10/10), 855 bytes | 0 bytes/s, <span class="hljs-keyword">done</span>.<br>Total 10 (delta 1), reused 0 (delta 0)<br>remote: Resolving deltas: 100% (1/1), <span class="hljs-keyword">done</span>.<br>To git@github.com:Zhangtao153/learngit.git<br> * [new branch]      master -&gt; master<br>Branch master <span class="hljs-built_in">set</span> up to track remote branch master from origin.<br></code></pre></td></tr></table></figure><p>当前分支 master推送到远程</p><h4 id="查看远程仓库">4.3 查看远程仓库</h4><p>git  remote  -v</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote<br>origin<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (dev)<br>$ git remote -v<br>origin  git@github.com:Zhangtao153/learngit.git (fetch)<br>origin  git@github.com:Zhangtao153/learngit.git (push)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote show<br>origin<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git remote show origin<br>* remote origin<br>  Fetch URL: git@github.com:Zhangtao153/learngit.git<br>  Push  URL: git@github.com:Zhangtao153/learngit.git<br>  HEAD branch: master<br>  Remote branch:<br>    master tracked<br>  Local branch configured <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;git pull&#x27;</span>:<br>    master merges with remote master<br>  Local ref configured <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;git push&#x27;</span>:<br>    master pushes to master (up to date)<br></code></pre></td></tr></table></figure><h4 id="从远程库克隆">4.4 从远程库克隆</h4><p>git clone &lt;url&gt;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git@github.com:Zhangtao153/learngit.git<br>Cloning into <span class="hljs-string">&#x27;learngit&#x27;</span>...<br>remote: Enumerating objects: 10, <span class="hljs-keyword">done</span>.<br>remote: Counting objects: 100% (10/10), <span class="hljs-keyword">done</span>.<br>remote: Compressing objects: 100% (6/6), <span class="hljs-keyword">done</span>.<br>remote: Total 10 (delta 1), reused 10 (delta 1), pack-reused 0<br>Receiving objects: 100% (10/10), <span class="hljs-keyword">done</span>.<br>Resolving deltas: 100% (1/1), <span class="hljs-keyword">done</span>.<br>Checking connectivity... <span class="hljs-keyword">done</span>.<br></code></pre></td></tr></table></figure><h4id="本地创建和远程分支对应的分支">4.5 本地创建和远程分支对应的分支</h4><p>从远程 clone 的代码库默认只有 master 分支。</p><p>命令：<strong><font color="red">git  checkout  -b  dev origin/dev</font></strong> </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b dev origin/dev<br>Switched to a new branch <span class="hljs-string">&#x27;dev&#x27;</span><br>Branch <span class="hljs-string">&#x27;dev&#x27;</span> <span class="hljs-built_in">set</span> up to track remote branch <span class="hljs-string">&#x27;dev&#x27;</span> from <span class="hljs-string">&#x27;origin&#x27;</span>.<br></code></pre></td></tr></table></figure><h4 id="修改远程仓库">4.6 修改远程仓库</h4><p>方法一： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote set-url origin &lt;url&gt;<br></code></pre></td></tr></table></figure> 方法二： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote rm origin<br>git remote add origin [url]<br></code></pre></td></tr></table></figure></p><h4 id="将本地分支与远程建立关联">4.7 将本地分支与远程建立关联</h4><p>git branch --track --set-upstream-to=origin/test test</p><h3 id="分支管理">5. 分支管理</h3><ul><li>git branch 查看本地分支</li><li>git branch -a 查看所有分支</li><li>git branch -av 查看所有分支详细信息</li><li>git branch -avv 查看本地分支和远程分支的关联信息</li></ul><h4 id="创建切换分支">5.1 创建切换分支</h4><ul><li>git branch &lt;branch name&gt; 基于当前分支新建分支</li><li>git branch &lt;branch name&gt; &lt;commit id&gt;基于提交新建分支</li></ul><p>命令：<font color="red">git checkout  -b  dev 或  git switch -c dev</font></p><p>作用：创建并切换分支</p><blockquote><p>git checkout 命令加上 -b 参数表示创建并切换，相当于以下两条命令：</p><p>$ git  branch  dev $ git  checkout  dev</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b dev<br>Switched to a new branch <span class="hljs-string">&#x27;dev&#x27;</span><br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (dev)<br>$ git branch<br>* dev<br>  master<br></code></pre></td></tr></table></figure><h4 id="合并分支">5.2 合并分支</h4><p>命令：git  merge &lt;branch&gt;</p><p>作用：合并指定分支到当前分支 <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git merge dev<br>Updating 35bc9a6..83ef1fc<br>Fast-forward<br> README.md | 3 ++-<br> 1 file changed, 2 insertions(+), 1 deletion(-)<br></code></pre></td></tr></table></figure> &gt;Fast-forward “快进模式”，就是直接把 master 指向 dev 的当前提交，所以合并速度非常快。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220214232219.png" /></p><blockquote><p>通常合并分支时，如果可能，Git会用Fastforward模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用Fastforward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p></blockquote><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220214232236.png" /></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git merge --no-ff -m <span class="hljs-string">&quot;merge with no-ff&quot;</span> zth<br>Merge made by the <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> README.md | 2 +-<br> 1 file changed, 1 insertion(+), 1 deletion(-)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> --graph --pretty=oneline --abbrev-commit<br>*   c5df1ca (HEAD -&gt; master) merge with no-ff<br>|\<br>| * 5db3e3d (zth) delete merge<br>|/<br>* 6707c86 add merge<br>* 7e760b4 add on zth branch<br>*   650cdbc clear on master<br></code></pre></td></tr></table></figure><h4 id="删除分支">5.3 删除分支</h4><p>命令：git   branch  -d   &lt;branch&gt; <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -d dev<br>Deleted branch dev (was 83ef1fc).<br></code></pre></td></tr></table></figure></p><h4 id="查看分支合并情况">5.4 查看分支合并情况</h4><p>命令：<font color="red"> git log --graph --pretty=oneline--abbrev-commit  或：git log --graph --oneline </font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --graph --pretty=oneline --abbrev-commit<br>*   8e7b6c4 conflict fixed<br>|\<br>| * e920442 update on dev<br>* | e15ba0e update on master<br>|/<br>* 83ef1fc add on dev<br>* 35bc9a6 delete test.txt<br>* fd68a6a add file test.txt<br>* a8d2e0d 手动删除<br>* 1d243ca add <span class="hljs-built_in">test</span> file<br>* 8438389 wrote a readme file<br></code></pre></td></tr></table></figure><h4 id="保存现场">5.5 保存现场</h4><p>在创建一个新的分支用来修改 bug时，当前分支的工作还没提交，可以通过 stash 功能把当前工作现场“储藏”起来，等以后恢复现场后继续工作。</p><p>原因：<font color="red">所有分支共享工作区和暂存区</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git stash<br>Saved working directory and index state WIP on issue-004: c5df1ca merge with no-ff<br></code></pre></td></tr></table></figure><p>git  stash  list <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git stash list<br>stash@&#123;0&#125;: WIP on issue-004: c5df1ca merge with no-ff<br>stash@&#123;1&#125;: WIP on dev: c5df1ca merge with no-ff<br></code></pre></td></tr></table></figure> 恢复现场方法：</p><p>一： git stash apply 恢复，但是恢复后，stash内容并不删除，需要用gitstash drop来删除；</p><p>二： git stash pop，恢复的同时把stash内容也删了： <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git stash pop<br>On branch issue-004<br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)<br>  (use <span class="hljs-string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="hljs-keyword">in</span> working directory)<br>        modified:   README.md<br><br>no changes added to commit (use <span class="hljs-string">&quot;git add&quot;</span> and/or <span class="hljs-string">&quot;git commit -a&quot;</span>)<br>Dropped refs/stash@&#123;0&#125; (020a507cf2c1cd55460d17081db6671b7e075ed6)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issue-004)<br>$ git stash list<br>stash@&#123;0&#125;: WIP on dev: c5df1ca merge with no-ff<br></code></pre></td></tr></table></figure></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git stash apply stash@&#123;0&#125;<br></code></pre></td></tr></table></figure><h4 id="git-cherry-pick">5.6 git cherry-pick</h4><p>作用：合并不同分支的若干个 commit 到当前分支</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220215233958.png" /></p><p>语法： </p><p>git cherry-pick &lt;C commit-id&gt; &lt;D commit-id&gt; &lt;Ecommit-id&gt;</p><h3 id="多人协作工作模式">6. 多人协作工作模式</h3><p>首先，可以试图用 git push origin&lt;branch-name&gt; 推送自己的修改；</p><p>如果推送失败，则因为远程分支比你的本地更新，需要先用gitpull试图合并；</p><p>如果合并有冲突，则解决冲突，并在本地提交；</p><p>没有冲突或者解决掉冲突后，再用 git push origin&lt;branch-name&gt; 推送就能成功！</p><p>如果 git pull 提示 no trackinginformation，则说明本地分支和远程分支的链接关系没有创建，用命令 gitbranch --set-upstream-to &lt;branch-name&gt;origin/&lt;branch-name&gt;。</p><h3 id="标签管理">7. 标签管理</h3><h4 id="创建标签">7.1 创建标签</h4><p>命令：git  tag  &lt;name&gt;  [commit]</p><p>-a 指定标签名，-m 指定说明文字</p><p>首先选择分支，默认在最新提交的 commit 上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag v1.0<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (dev)<br>$ git tag v0.9 add2dbd<br></code></pre></td></tr></table></figure><h4 id="查看所有标签">7.2 查看所有标签</h4><p>git  tag <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag<br>v0.9<br>v1.0<br></code></pre></td></tr></table></figure> #### 7.3 查看标签信息 git  show &lt;tagname&gt;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag -a v0.8 -m <span class="hljs-string">&quot;version 0.8 release&quot;</span> 94b83a0<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (dev)<br>$ git show v0.8<br>tag v0.8<br>Tagger: Zhangtao153 &lt;13289265979@163.com&gt;<br>Date:   Wed Oct 21 23:51:54 2020 +0800<br><br>version 0.8 release<br><br>commit 94b83a06c04b8b3a5ca5af4443dda614bc3b1441 (tag: v0.8)<br>Author: Zhangtao153 &lt;13289265979@163.com&gt;<br>Date:   Wed Oct 21 21:32:49 2020 +0800<br><br>    commit on issue-005<br><br>diff --git a/README.md b/README.md<br>index 25ed040..af0e009 100644<br>--- a/README.md<br>+++ b/README.md<br>@@ -1,2 +1,2 @@<br> Git is a version control system.<br>-Git is free software.哈哈zth  delete and update<br>+Git is free software.哈哈zth  delete and update on issue-005<br></code></pre></td></tr></table></figure><h4 id="删除标签">7.4 删除标签</h4><p>删除本地标签： </p><p>git   tag   -d  &lt;tagname&gt;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag -d v0.9<br>Deleted tag <span class="hljs-string">&#x27;v0.9&#x27;</span> (was add2dbd)<br></code></pre></td></tr></table></figure><p>删除远程标签（先删除本地，再删除远程）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag -d v0.8<br>Deleted tag <span class="hljs-string">&#x27;v0.8&#x27;</span> (was 120a8d2)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (dev)<br>$ git push origin  :refs/tags/v0.8<br>To github.com:Zhangtao153/learngit.git<br> - [deleted]         v0.8<br></code></pre></td></tr></table></figure><h4 id="推送标签到远程">7.5 推送标签到远程</h4><p> 推送指定标签：</p><p>git push origin &lt;tagname&gt;</p><p>推送全部尚未推送到远程的本地标签：</p><p>git push origin --tags</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin v1.0<br>Enumerating objects: 28, <span class="hljs-keyword">done</span>.<br>Counting objects: 100% (28/28), <span class="hljs-keyword">done</span>.<br>Delta compression using up to 4 threads<br>Compressing objects: 100% (18/18), <span class="hljs-keyword">done</span>.<br>Writing objects: 100% (26/26), 1.95 KiB | 667.00 KiB/s, <span class="hljs-keyword">done</span>.<br>Total 26 (delta 12), reused 0 (delta 0), pack-reused 0<br>remote: Resolving deltas: 100% (12/12), <span class="hljs-keyword">done</span>.<br>To github.com:Zhangtao153/learngit.git<br> * [new tag]         v1.0 -&gt; v1.0<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (dev)<br>$ git push origin --tags<br>Enumerating objects: 1, <span class="hljs-keyword">done</span>.<br>Counting objects: 100% (1/1), <span class="hljs-keyword">done</span>.<br>Writing objects: 100% (1/1), 167 bytes | 167.00 KiB/s, <span class="hljs-keyword">done</span>.<br>Total 1 (delta 0), reused 0 (delta 0), pack-reused 0<br>To github.com:Zhangtao153/learngit.git<br> * [new tag]         v0.8 -&gt; v0.8<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea——使用技巧</title>
    <link href="/2022/02/04/idea%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/02/04/idea%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="代码模板">1. 代码模板</h3><h4 id="fori-forr-int.foriforr">1.1 fori / forr / (int.fori/forr)</h4><p>快速生成 for 循环</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220201100448.png" /></p><h4 id="sout-soutv-sout-souf-soutm-serr">1.2 sout / soutv / sout / souf/ soutm / serr</h4><p>sout：快速生成 System.out.println(); soutv：输出当前上下文变量 soutm: 打印当前方法签名 soutp：打印当前方法参数 souf：格式化输出字符串serr：prints a string to System.err</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220201101142.png" /></p><h4 id="ifn-inn">1.3 ifn / inn</h4><p>ifn：判断上下文变量是否为空</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220201230733.png" /></p><p>inn：判断上下文变量是否不为空</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220201230938.png" /></p><h4 id="surround-with">1.4 surround with</h4><p>快捷键 Ctrl + alt + T</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220201231455.png" /></p><p>选择 Surround with Callable：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220201232104.png" /></p><h3 id="代码重构">2. 代码重构</h3><ul><li>extract</li><li>change signature</li><li>rename</li></ul><h4 id="extract提取">2.1 extract（提取）</h4><p>// method(M)、constant(C)、fields(F)、variables(V)、parameters(P)</p><ul><li>提取方法（Ctrl + Alt + M）</li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202223339.png" /></p><ul><li>提取常量（Ctrl + Alt + C）</li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202224012.png" /></p><ul><li>提取字段（Ctrl + Alt + F）</li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202230344.png" /></p><ul><li>提取变量（Ctrl + Alt + V）</li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202231120.png" /></p><ul><li>提取参数（Ctrl + Alt + P）</li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202232910.png" /></p><h4 id="change-signature">2.2 change signature</h4><p>快捷键：Ctrl+F6</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202234547.png" /></p><h4 id="rename">2.3 rename</h4><p>快捷键：shift+F6</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202235153.png" /></p><p>也可以在按完快捷键之后再按 shift+F6，设置重命名范围。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202235400.png" /></p><h3 id="常用快捷键">3. 常用快捷键</h3><p>显示快捷键插件：Presentation Assistant</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204001624.png" /></p><p><font color="red"></font></p><ul><li><p><font color="red"><strong>Ctrl + F12</strong></font>查找当前类中的方法</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221109234601.png" /></p></li><li><p><font color="red"><strong>alt+enter</strong></font>结合上下文显示 error 的 fix 信息</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203222308.png" /></p><p>代码补全</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203222726.png" /></p><p>lambda 表达式生成</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203224401.png" /></p></li><li><p><font color="red"><strong>F2</strong></font></p><p>快速定位到报错行，并且多次按 F2 可在不同报错位置切换。</p></li><li><p><font color="red"><strong>alt + 1</strong></font></p><p>快速定位到项目窗口，定位到 project窗口之后可以直接输入进行搜索，定位到文件后直接回车打开。也可以按 esc光标回到编辑区。</p></li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203230028.png" /></p><ul><li><p><font color="red"><strong>esc</strong></font>关闭任何上层窗口，回到编辑区域。</p></li><li><p><font color="red"><strong>Ctrl + e</strong></font>显示最近修改的文件</p></li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203230514.png" /></p><ul><li><p><font color="red"><strong>Ctrl+b / Ctrl+alt+b</strong></font>Ctrl+b：进入到类的实现 Ctrl+alt+b：进入到接口的实现类</p></li><li><p><font color="red"><strong>alt + F7</strong></font>定位类、方法使用到的位置</p></li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203231404.png" /></p><ul><li><font color="red"><strong>Ctrl + Ctrl</strong></font> 运行指令</li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203231931.png" /></p><ul><li><p><font color="red"><strong>Ctrl+W / Ctrl+shift+W</strong></font>选取代码块</p></li><li><p><font color="red"><strong>Ctrl+/ 、Ctrl+shift+/</strong></font>Ctrl+/：单行注释 Ctrl+shift+/：多行注释</p></li><li><p><font color="red"><strong>Ctrl + shift + enter</strong></font>补全声明</p></li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203233914.png" /></p><ul><li><p><font color="red"><strong>Ctrl + alt + L</strong></font>格式化代码</p></li><li><p><font color="red"><strong>Ctrl + shift + alt + T</strong></font>重构代码 呼出面板后按选项前面的数字选择</p></li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203235028.png" /></p><ul><li><font color="red"><strong>Ctrl + shift + A</strong></font>查找操作</li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203235832.png" /></p><ul><li><p><font color="red"><strong>shift + shift</strong></font> Searcheverywhere 可通过 tab 进行切换查找内容</p></li><li><p><font color="red"><strong>Ctrl + D</strong></font>重复当前行或选择块</p></li><li><p><font color="red">Ctrl+← / Ctrl + →</font>光标按单词左右移动</p></li><li><p><font color="red">alt+ ← / alt +→</font> 左右切换编辑区 table页</p></li><li><p><font color="red"><strong>alt+↑ / alt + ↓</strong></font>光标定位到上一个/下一个方法</p></li><li><p><font color="red"><strong>shift + alt + 鼠标左键</strong></font>多行编辑</p></li></ul><h3 id="常用插件">4. 常用插件</h3><ul><li>Alibaba Java Coding Guidelines 代码规范校验</li><li>Grep console 设置控制台打印颜色、过滤等</li><li>Presentation Aassistant 显示操作名称以及快捷键</li><li>SequenceDiagram 生成时序图</li><li>Tasks 待办事项记录卡</li></ul><h3 id="后缀补全postfix-completion">5. 后缀补全（postfixcompletion）</h3><h4 id="for-循环.for-.fori-.forr">5.1 for 循环（.for / .fori /.forr）</h4><p>for each 循环（.for / .iter）：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204143629.png" /></p><p>for 普通循环（.fori）：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204144217.png" /></p><p>for 反向迭代（.forr)： （r：reverse）</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204144456.png" /></p><p>#### 5.2 判空（.null / .notnull / .nn)</p><p>判空（.null）</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204170246.png" /></p><p>判非空（ .notnull / .nn）</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204170739.png" /></p><p>#### 5.3 boolean 判断（.if / .not.if）</p><p>if 判断（.if） <imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204171407.png" /></p><p>取反再判断（.not.if）</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204171943.png" /></p><p>#### 5.4 定义变量（.new / .var / .val / .field）</p><p>创建对象并定义局部变量：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204173326.png" /></p><p>创建 val 类型局部变量：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204173730.png" /></p><p>创建全局变量（.field）：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204174100.png" /></p><p>#### 5.5 格式化字符串（.format）</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204174546.png" /></p><p>#### 5.6 同步锁（.synchronized）</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204174922.png" /></p><p>#### 5.7 异常捕获（.try）</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204175516.png" /></p><p>#### 5.8 强制转换（.cast / .castvar）</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/cast.gif" /></p><p>#### 5.9 抛出异常 / 返回 （.throw / .return）</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204183148.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204183331.png" /></p><h3 id="api-接口测试">6. API 接口测试</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220209232819.png" /></p><p>配置环境变量：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220210225000.png" /></p><p>发送请求体：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220210224857.png" /></p><p>请求模板：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220210225823.png" /></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea——debug 技巧</title>
    <link href="/2022/01/23/idea%E2%80%94%E2%80%94debug%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/01/23/idea%E2%80%94%E2%80%94debug%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="debug">1. debug</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220123122508.png" /></p><p>　1. 以 Debug 模式启动服务。 　2.断点：在左边行号栏单击左键，或者快捷键Ctrl+F8 打上/取消断点。 　3.Debug窗口：访问请求到达第一个断点后，会自动激活Debug窗口。如果没有自动激活，可以去设置里设置。　4. 调试按钮：在菜单栏 Run 里可以找到同样的对应的功能。 　5.服务按钮：可以在这里关闭/启动服务，设置断点等。 　6.方法调用栈：这里显示了该线程调试所经过的所有方法，勾选右上角的 [Show AllFrames] 按钮，就不会显示其它类库的方法了。 　7.Variables：在变量区可以查看当前断点之前的当前方法内的变量。 　8.Watches：查看变量，可以将Variables区中的变量拖到Watches中查看</p><h4 id="基本用法快捷键">1.1 基本用法&amp;快捷键</h4><p>Debug 调试的功能主要对应上图中 4 和 5 两组按钮：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220123203210.png" /></p><ol type="1"><li>Show Execution Point (Alt +F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行。</li><li>Step Over(F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。</li><li>Step Into(F7)：步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内。</li><li>Force Step Into (Alt + Shift +F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。</li><li>Step Out (Shift +F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。</li><li>Drop Frame(默认无)：回退断点，回到上一层该方法调用处或指定方法的调用处（断点回退只能重新走一下流程，之前的某些参数/数据的状态已经改变了的是无法回退到之前的状态的，如对象、集合、更新了数据库数据等等）</li><li>Run to Cursor (Alt + F9)：运行到光标处。</li><li>Evaluate Expression (Alt + F8)：计算表达式。</li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220123205203.png" /></p><ol type="1"><li>Rerun 'xxxx'：重新运行程序，会关闭服务后重新启动程序。</li><li>Update 'tech' application (Ctrl +F5)：更新程序，一般在代码有改动后可执行这个功能。</li><li>Resume Program (F9)：执行到下一个断。</li><li>Pause Program：暂停程序，启用Debug。</li><li>Stop 'xxx' (Ctrl + F2)：连续按两下，关闭程序。</li><li>View Breakpoints (Ctrl + Shift + F8)：查看所有断点。</li><li>MuteBreakpoints：哑的断点，选择这个后，所有断点变为灰色，断点失效，按F9则可以直接运行完程序。再次点击，断点变为红色，有效。如果只想使某一个断点失效，可以在断点上右键取消Enabled。</li></ol><h4 id="智能步入">1.2智能步入</h4><p>一行代码里有好几个方法，怎么只选择某一个方法进入。使用 Step Into (Alt+ F7) 或者 Force Step Into (Alt + Shift + F7)进入到方法内部，但这两个操作会根据方法调用顺序依次进入。那么智能步入就很方便了，这个功能在Run 里可以看到，Smart Step Into (Shift + F7)。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/无标题.png" /></p><h4 id="中断debug">1.3 中断Debug</h4><p>想要在 Debug 的时候，中断请求，不要再走剩余的流程了？</p><p>有些时候，我们看到传入的参数有误后，不想走后面的流程了，怎么中断这次请求呢(后面的流程要删除数据库数据呢....)，难道要关闭服务重新启动程序？</p><p>可以通过 Force Return，即强制返回来避免后续的流程。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220123224600.png" /></p><p>点击 Force Return，弹出Return Value的窗口。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220123225011.png" /></p><h3 id="断点调试">2. 断点调试</h3><h4 id="行断点">2.1 行断点</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220125222604.png" /></p><p>在方法体的左侧鼠标单击即可添加行断点，debug模式执行时，会在停在断点所在的行。</p><h4 id="详细断点">2.2 详细断点</h4><p>通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。</p><p>通常，当我们在遍历一个比较大的集合或数组时，在循环内设置了一个断点，难道我们要一个一个去看变量的值？那肯定很累，说不定你还错过这个值得重新来一次。</p><ol type="1"><li>在断点上右键直接设置当前断点的条件（shift + 鼠标左键 )</li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220123214359.png" />当 exis t为 true 时断点才生效。</p><ol start="2" type="1"><li>点击 View Breakpoints (Ctrl + Shift + F8)，查看所有断点。</li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220123214720.png" /></p><ul><li>. Java Line Breakpoints显示了所有的断点，在右边勾选Condition，设置断点的条件。</li><li>. 勾选 Log message to console，则会将当前断点行输出到控制台。</li><li>. 勾选 Evaluate andlog，可以在执行这行代码时计算表达式的值，并将结果输出到控制台。</li><li>. Instance filters：实例过滤，输入实例ID。</li><li>. Class filters：类过滤，根据类名过滤。</li><li>. Passcount：用于循环中，如果断点在循环中，可以设置该值，循环多少次后停在断点处，之后的循环都会停在断点处。</li></ul><h4 id="方法断点">2.3 方法断点</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220125224402.png" /></p><p>方法断点打在方法签名的左侧，图标为菱形。会在方法的第一行和最后一行停顿。（方便查看方法的返回值以及变量、表达式的变化等等）</p><p><font color="red">如果方法断点打在接口抽象方法上，则会停顿在实现类对应方法的第一行</font></p><h4 id="异常断点">2.4 异常断点</h4><p>通过设置异常断点，在程序中出现需要拦截的异常时，会自动定位到异常行。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220123222025.png" /></p><p>点击 + 号添加 Java ExceptionBreakpoints，添加异常断点。然后输入需要断点的异常类（如NullPointerException）。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220123221924.png" /></p><p>程序将暂停在抛出 NullPointerException 的行。</p><h4 id="字段断点读写监控">2.5 字段断点（读写监控）</h4><p>监控值的变化。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220125231555.png" /></p><p>执行如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">field</span><span class="hljs-params">()</span> </span>&#123;<br>    Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">20</span>);<br>    person.setAge(<span class="hljs-number">18</span>);<br>    System.out.println(person);<br>&#125;<br></code></pre></td></tr></table></figure><p>将会在如下地方暂停：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220125231721.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220125231812.png" /></p><p>#### 2.6 stream 调试</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220128232648.png" /></p><p>有三种断点模式。</p><p>点击 Trance Current Stream Chain 按钮，查看流的转换过程。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220130231133.png" /></p><h3 id="多线程-debug">3. 多线程 debug</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202183512.png" /></p><p>suspend 分两类，一类是All，一类是Thread。</p><p>All：只有其中一个线程会在断点处挂起，此线程挂起后阻塞所有线程，并且不能在call stack 处切换线程上下文。Thread：每个线程执行到断点出会挂起，每个线程之间不会影响，并且在 callstack 出可以切换线程上下文。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202183313.png" /></p><h3 id="远程-debug">4. 远程 debug</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220205230647.png" /></p><p>远程服务启动：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220205230914.png" /></p><p>访问服务：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220205231329.png" /></p><p>debug 结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220205231356.png" /></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jenkins——核心功能</title>
    <link href="/2022/01/20/jenkins%E2%80%94%E2%80%94%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/"/>
    <url>/2022/01/20/jenkins%E2%80%94%E2%80%94%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="概述与环境配置">1. 概述与环境配置</h3><h4 id="持续化集成">1.1 持续化集成</h4><p>持续集成即 Continuous integration（CI）是一种软件开发实践，即团队开发成员经常集成他们的工作，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽快地发现集成错误，让团队能够更高效的开发软件。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/CI.png" /></p><p>持续集成要点： + 统一的代码库(git) + 统一的依赖包管理(nexus) +测试自动化 + 构建全自动化(maven) + 部署自动化 + 可追踪的集成记录</p><h4 id="jenkins-概述">1.2 jenkins 概述</h4><p>jenkins 就是为了满足持续集成的要点而设计的一款工具，其主体框架采用JAVA开发，实质内部功能都是由各种插件实现，极大提高了系统的扩展性。其不仅可以满足JAVA 系统的集成，也可以实现 PHP 等语言的集成发布。通过其 pipeline插件，用户可以随自己需要定制集成流程。</p><h4 id="安装-jenkins">1.3 安装 jenkins</h4><ol type="1"><li><p>下载：jenkins 支持Docker、yum、msi 等安装，推荐通过 WAR包进行安装。https://jenkins.io/download/</p></li><li><p>启动：下载完成之后直接可通过 jar -jar 命令启动</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar jenkins.war --httpPort=8080<br></code></pre></td></tr></table></figure><p>也可以将其放至到 servlet容器（tomcat）中直接启动，无需过多的配置。</p><ol start="3" type="1"><li>配置：下载完成之后进入启动页 (http://127.0.0.1:8080/) 会有一个验证过程，验证码存储在${user_home}.jenkins中，接着就是进入安装插件页，选择默认即可。</li></ol><h4 id="基础环境配置与常用插件下载">1.4 基础环境配置与常用插件下载</h4><p>在集成的时候，jenkins 用到了 Maven、Git。所以服务器中必须提前安装好这些环境。</p><p>Manage Jenkins --&gt; Manage Plugins --&gt; Advanced --&gt;升级站点：</p><p>https://updates.jenkins.io/update-center.json 改为http://mirror.esuni.jp/jenkins/updates/update-center.json</p><p>镜像源查询：http://mirrors.jenkins-ci.org/status.html</p><p>基本插件列表：</p><table><thead><tr><th>插件名称</th><th>插件描述</th></tr></thead><tbody><tr><td>Maven Integration</td><td>maven 管理插件</td></tr><tr><td>Deploy to container</td><td>容器部署插件</td></tr><tr><td>Pipeline</td><td>管道集成插件</td></tr><tr><td>Email Extension  </td><td>邮件通知插件</td></tr><tr><td>SSH</td><td>用于ssh 通信</td></tr></tbody></table><h3 id="基于-jenkins-实现可持续化集成">2. 基于 jenkins实现可持续化集成</h3><h4 id="持续化集成完成的目标">2.1 持续化集成完成的目标</h4><ol type="1"><li>自动基于分支构建项目</li><li>构建好的项目自动部署至 Tomcat 容器</li><li>构建好的项目自动上传至 Nexus 私服存档</li><li>保存构建历史记录，并可以下载历史记录</li></ol><h4 id="持续化集成配置">2.2 持续化集成配置</h4><ol type="1"><li>新建 maven job</li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220305154059.png" /></p><ol start="2" type="1"><li>配置checkout 源码</li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220305155309.png" /></p><ol start="3" type="1"><li>编写 maven 构建命令</li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220305162615.png" /></p><p>构建结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220305170148.png" /></p><ol start="4" type="1"><li>自动部署至 Tomcat 配置</li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220305193106.png" /></p><p>构建后访问：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220305193334.png" /></p><p>自动部署的前提条件： 1.需要下载 Deploy to container 插件 2.设置Tomcatmanager 用户和密码，以下配置加入至 Tomcat conf/tomcat-users.xml 中3.tomcat webapp 中必须保留 manager 项目 <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">&quot;admin-gui&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">&quot;manager-gui&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">&quot;manager-script&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">username</span>=<span class="hljs-string">&quot;manager&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;manager&quot;</span> <span class="hljs-attr">roles</span>=<span class="hljs-string">&quot;manager-gui,manager-script&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">username</span>=<span class="hljs-string">&quot;admin&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;admin&quot;</span> <span class="hljs-attr">roles</span>=<span class="hljs-string">&quot;admin-gui,manager-gui&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure> <ahref="https://blog.csdn.net/weixin_33965305/article/details/93610207">远程无法管理tomcat 问题</a></p><ol start="5" type="1"><li>存档配置 构建后发布到 nexus 私服</li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220305233105.png" /></p><p>配置 setting.xml 获取上传至 nexus 的权限： <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-snapshot<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>deployment<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>deployment123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-release<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>deployment<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>deployment123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br></code></pre></td></tr></table></figure>构建结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220305233742.png" /></p><h4 id="集成实现原理">2.3 集成实现原理</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220306000108.png" /></p><p>工作空间目录：~/.jenkins/workspace/</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220306000043.png" /></p><h3 id="jenkins-pipeline-核心应用">3. jenkins pipeline 核心应用</h3><h4 id="pipeline-概要">3.1 pipeline 概要</h4><p>使用 maven 来进行自动化构建，其流程分别是：构建环境准备 ——&gt;源码下载——&gt;构建——&gt;存档——&gt;部署，这是一种固化的构建流程，如果需要多个项目进行依赖构建，这种复杂的构建场景时该怎么办？jenkins pipeline 可以做到这一点。 Jenkins从根本上讲是一种支持多种自动化模式的自动化引擎。Pipeline 在 Jenkins上添加了一套强大的自动化工具，支持从简单的连续集成到全面的连续输送Pipeline 的用例。用户可以基于他实现更为复杂的建模场景。</p><h4 id="pipeline-基础语法">3.2 pipeline 基础语法</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json">pipeline &#123;<br>    agent any <br>    stages &#123;<br>        stage(&#x27;Build&#x27;) &#123; <br>            steps &#123; <br>                sh &#x27;make&#x27; <br>            &#125;<br>        &#125;<br>        stage(&#x27;Test&#x27;)&#123;<br>            steps &#123;<br>                sh &#x27;make check&#x27;<br>                junit &#x27;reports<span class="hljs-comment">/**/</span>*.xml&#x27; <br>            &#125;<br>        &#125;<br>        stage(&#x27;Deploy&#x27;) &#123;<br>            steps &#123;<br>                sh &#x27;make publish&#x27;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>agent  表示 Jenkins 应该为 Pipeline的这一部分分配一个执行者和工作区。</li><li>stage  描述了这条 Pipeline 的一个阶段。</li><li>steps  描述了要在其中运行的步骤</li><li>sh  执行给定的 shell 命令</li><li>junit 是由 JUnit 插件提供的，用于聚合测试报告的 Pipeline 步骤。</li></ul><h4 id="pipeline-示例">3.3 pipeline 示例</h4><p>前提条件： 1. Jenkins 2.x 或更高版本 2. Pipeline插件</p><p>可以通过以下任一方式创建基本 Pipeline： 1. 直接在 Jenkins网页界面中输入脚本。 2. 通过创建一个 Jenkinsfile可以检入项目的源代码管理库。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220306004515.png" /></p><h5 id="pipeline-script-方式">Pipeline script 方式</h5><p>点击”流水线语法“查看语法帮助： <imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220306005949.png" /></p><p>pipeline script： <figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json">pipeline &#123;<br>    agent any <br>    stages &#123;<br>        stage(&#x27;checkout&#x27;) &#123; <br>            steps &#123; <br>                echo &#x27;checkout&#x27; <br>                checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;*/master&#x27;]], extensions: [], userRemoteConfigs: [[credentialsId: &#x27;<span class="hljs-number">3</span>c819818-d272<span class="hljs-number">-4155</span><span class="hljs-number">-91</span>d5<span class="hljs-number">-3</span>d59158e2823&#x27;, url: &#x27;http:<span class="hljs-comment">//192.168.60.10:3000/root/hello-debuggingWorld.git&#x27;]]])</span><br>            &#125;<br>        &#125;<br>        stage(&#x27;build&#x27;)&#123;<br>            steps &#123;<br>                 echo &#x27;build&#x27;<br>                 sh &#x27;mvn clean install&#x27;<br>            &#125;<br>        &#125;<br>        stage(&#x27;save&#x27;) &#123;<br>            steps &#123;<br>               echo &#x27;save&#x27;<br>               archiveArtifacts artifacts: &#x27;target<span class="hljs-comment">/*.war&#x27;, followSymlinks: false</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure> 构建结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220306011723.png" /></p><h5 id="jenkinsfile-方式">Jenkinsfile 方式</h5><p>项目中添加 Jenkinsfile（内容同上）：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220306013006.png" /></p><p>配置流水线：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220306012633.png" /></p>]]></content>
    
    
    <categories>
      
      <category>jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——socket 编程</title>
    <link href="/2022/01/17/Go%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/01/17/Go%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="go-语言实现-tcp-通信">1. Go 语言实现 TCP 通信</h3><p>TCP/IP(Transmission Control Protocol/Internet Protocol)即传输控制协议/网间协议，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transportlayer）通信协议。</p><h4 id="服务端">1.1 服务端</h4><p>TCP 服务端程序的处理流程： 1. 监听端口 2. 接收客户端请求建立链接 3.创建 goroutine 处理链接。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listen, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:28001&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;server error:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listen.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;accept fail:&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> process(conn)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br><span class="hljs-keyword">defer</span> conn.Close()<br><span class="hljs-keyword">var</span> buf [<span class="hljs-number">128</span>]<span class="hljs-keyword">byte</span><br><br><span class="hljs-keyword">for</span> &#123;<br>reader := bufio.NewReader(conn)<br><br>n, err := reader.Read(buf[:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;read from client failed, err:&quot;</span>, err)<br><span class="hljs-keyword">break</span><br>&#125;<br><br>res := <span class="hljs-keyword">string</span>(buf[:n])<br>fmt.Println(<span class="hljs-string">&quot;server 接收消息：&quot;</span>, res)<br>conn.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;收到&quot;</span>))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="客户端">1.2 客户端</h4><p>一个 TCP 客户端进行 TCP 通信的流程如下：</p><ol type="1"><li>建立与服务端的链接</li><li>进行数据收发</li><li>关闭链接</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:28001&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;client connection error:&quot;</span>,err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-keyword">var</span> buf [<span class="hljs-number">128</span>]<span class="hljs-keyword">byte</span><br><br>inputReader := bufio.NewReader(os.Stdin)<br><span class="hljs-keyword">for</span> &#123;<br>readString, _ := inputReader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>readString = strings.Trim(readString,<span class="hljs-string">&quot;\r\nhello&quot;</span>)<br><span class="hljs-keyword">if</span> strings.EqualFold(readString, <span class="hljs-string">&quot;exit&quot;</span>) &#123;<span class="hljs-comment">// 退出</span><br><span class="hljs-keyword">return</span><br>&#125;<br>_, err = conn.Write([]<span class="hljs-keyword">byte</span>(readString)) <span class="hljs-comment">// 发送数据</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;client send error:&quot;</span>,err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>n, err := conn.Read(buf[:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;client receive error:&quot;</span>,err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-keyword">string</span>(buf[:n]))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="tcp黏包">2. TCP黏包</h3><p><strong>服务端代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listen, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:28001&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;server error:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listen.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;accept fail:&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> process(conn)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br><span class="hljs-keyword">defer</span> conn.Close()<br><span class="hljs-keyword">var</span> buf [<span class="hljs-number">128</span>]<span class="hljs-keyword">byte</span><br>reader := bufio.NewReader(conn)<br><br><span class="hljs-keyword">for</span> &#123;<br>n, err := reader.Read(buf[:])<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;read from client failed, err:&quot;</span>, err)<br><span class="hljs-keyword">break</span><br>&#125;<br>res := <span class="hljs-keyword">string</span>(buf[:n])<br>fmt.Println(<span class="hljs-string">&quot;server 接收消息：&quot;</span>, res)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:28001&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;client connection error:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++ &#123;<br>conn.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hello debuggingWorld!&quot;</span>))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220118204607.png" /></p><h4 id="粘包的原因">2.1 粘包的原因</h4><p>主要原因就是 tcp数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。</p><p>“粘包”可发生在发送端也可发生在接收端：</p><ol type="1"><li>由 Nagle 算法造成的发送端的粘包：Nagle算法是一种改善网络传输效率的算法。简单来说就是当提交一段数据给 TCP发送时，TCP并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。</li><li>接收端接收不及时造成的接收端粘包：TCP会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把TCP 的数据取出来，就会造成 TCP 缓冲区中存放了几段数据。</li></ol><h4 id="解决办法">2.2 解决办法</h4><p>出现”粘包”的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。</p><p>封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了(过滤非法包时封包会加入”包尾”内容)。包头部分的长度是固定的，并且它存储了包体的长度，根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> proto<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;encoding/binary&quot;</span><br>)<br><br><span class="hljs-comment">// Encode 消息编码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Encode</span><span class="hljs-params">(message <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;<br><span class="hljs-comment">// 消息头前四个字节为消息体长度</span><br>length := <span class="hljs-keyword">int32</span>(<span class="hljs-built_in">len</span>(message))<br><br>buffer := <span class="hljs-built_in">new</span>(bytes.Buffer)<br>err := binary.Write(buffer, binary.LittleEndian, length)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-comment">// 写入消息体</span><br>err = binary.Write(buffer, binary.LittleEndian, []<span class="hljs-keyword">byte</span>(message))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> buffer.Bytes(), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Decode 消息解码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Decode</span><span class="hljs-params">(reader *bufio.Reader)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span> &#123;<br><span class="hljs-comment">// 读取消息体长度</span><br>lenByte, _ := reader.Peek(<span class="hljs-number">4</span>)<br>buffer := bytes.NewBuffer(lenByte)<br><br><span class="hljs-keyword">var</span> length <span class="hljs-keyword">int32</span><br>err := binary.Read(buffer, binary.LittleEndian, &amp;length)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br><span class="hljs-comment">// Buffered返回缓冲中现有的可读取的字节数。</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">int32</span>(reader.Buffered()) &lt; length+<span class="hljs-number">4</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br><br><span class="hljs-comment">// 读取真正的消息数据</span><br>msg := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, length+<span class="hljs-number">4</span>)<br><br>_, err = reader.Read(msg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(msg[<span class="hljs-number">4</span>:]), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>服务端代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listen, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:28001&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;server error:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listen.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;accept fail:&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> process(conn)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br><span class="hljs-keyword">defer</span> conn.Close()<br>reader := bufio.NewReader(conn)<br><br><span class="hljs-keyword">for</span> &#123;<br>res, err := proto.Decode(reader)<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;decode msg failed, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;server 接收消息：&quot;</span>, res)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端代码：</strong> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:28001&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;client connection error:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++ &#123;<br>bytes, err := proto.Encode(<span class="hljs-string">&quot;hello debuggingWorld!&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;encode msg failed, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>conn.Write(bytes)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure> <imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220118213857.png" /></p><h3 id="go语言实现udp通信">3. Go语言实现UDP通信</h3><p>UDP 协议（User Datagram Protocol）中文名称是用户数据报协议，是OSI（Open SystemInterconnection，开放式系统互联）参考模型中一种无连接的传输层协议，不需要建立连接就能直接进行数据发送和接收，属于不可靠的、没有时序的通信，但是UDP协议的实时性比较好，通常用于视频直播相关领域。</p><p><strong>服务端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := net.ListenUDP(<span class="hljs-string">&quot;udp&quot;</span>,&amp;net.UDPAddr&#123;<br>IP: net.IPv4(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),<br>Port: <span class="hljs-number">8888</span>,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;udp server listen fail:&quot;</span>,err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-keyword">var</span> buf [<span class="hljs-number">1024</span>]<span class="hljs-keyword">byte</span><br><br><span class="hljs-keyword">for</span> &#123;<br>n, addr, err := conn.ReadFromUDP(buf[:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;read udp failed, err:&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;data:%v addr:%v count:%v\n&quot;</span>, <span class="hljs-keyword">string</span>(buf[:n]), addr, n)<br><br>_, err = conn.WriteToUDP([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;已接收&quot;</span>), addr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;write to udp failed, err:&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>socket, err := net.DialUDP(<span class="hljs-string">&quot;udp&quot;</span>, <span class="hljs-literal">nil</span>, &amp;net.UDPAddr&#123;<br>IP:   net.IPv4(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>Port: <span class="hljs-number">8888</span>,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;连接服务端失败，err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> socket.Close()<br>sendData := []<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;Hello server&quot;</span>)<br>_, err = socket.Write(sendData) <span class="hljs-comment">// 发送数据</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;发送数据失败，err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>data := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">4096</span>)<br>n, remoteAddr, err := socket.ReadFromUDP(data) <span class="hljs-comment">// 接收数据</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;接收数据失败，err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;recv:%v addr:%v count:%v\n&quot;</span>, <span class="hljs-keyword">string</span>(data[:n]), remoteAddr, n)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——文件操作</title>
    <link href="/2022/01/16/Go%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/01/16/Go%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="目录操作">1. 目录操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建目录</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createDir</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建单个目录</span><br><span class="hljs-comment">// err := os.Mkdir(&quot;test&quot;, os.ModePerm)</span><br>err := os.MkdirAll(<span class="hljs-string">&quot;test/a/b&quot;</span>, os.ModePerm)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;err: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 删除目录</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeDir</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// err := os.Remove(&quot;test.txt&quot;)</span><br><br>err := os.RemoveAll(<span class="hljs-string">&quot;test&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;err: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 获得工作目录</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getWd</span><span class="hljs-params">()</span></span> &#123;<br>dir, err := os.Getwd()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;err: %v\n&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;dir: %v\n&quot;</span>, dir)<br>&#125;<br><br><span class="hljs-comment">// 获得临时目录</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getTemp</span><span class="hljs-params">()</span></span> &#123;<br>s := os.TempDir()<br>fmt.Printf(<span class="hljs-string">&quot;s: %v\n&quot;</span>, s)<br>&#125;<br><br><span class="hljs-comment">// 重命名文件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">renameFile</span><span class="hljs-params">()</span></span> &#123;<br>err := os.Rename(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;test2.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;err: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>createDir()<br>removeDir()<br>getWd()<br>getTemp()<br>renameFile()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="文件操作">2. 文件操作</h3><h4 id="打开和关闭文件">2.1 打开和关闭文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 关闭文件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f \*File)</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span><br><span class="hljs-comment">// 以只读的方式打开文件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Open</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(\*File, error)</span></span><br><span class="hljs-comment">// 以指定模式打开文件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">OpenFile</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, flag <span class="hljs-keyword">int</span>, perm FileMode)</span> <span class="hljs-params">(\*File, error)</span></span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>name：要打开的文件名</li><li>perm：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。</li><li>flag：打开文件的模式。 模式有以下几种：</li></ul><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220116182739.png" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 只读方式打开</span><br><span class="hljs-comment">//file, err := os.Open(&quot;./test&quot;)</span><br><br>file, err := os.OpenFile(<span class="hljs-string">&quot;./test.txt&quot;</span>, os.O_RDWR | os.O_CREATE, <span class="hljs-number">0777</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;open file failed!, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 关闭文件</span><br>file.Close()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="文件读取">2.2 文件读取</h4><h5 id="file.read">file.Read()</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>file, err := os.Open(<span class="hljs-string">&quot;./test.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;open file failed!, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br><br><span class="hljs-comment">// 循环读取文件</span><br><span class="hljs-keyword">var</span> tmp = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">128</span>)<br><span class="hljs-keyword">for</span> &#123;<br>n, err := file.Read(tmp)<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<span class="hljs-comment">// 文件读取结束</span><br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;read file failed, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Print(<span class="hljs-keyword">string</span>(tmp[:n]))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="bufio">bufio</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>file, err := os.Open(<span class="hljs-string">&quot;./test.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;open file failed!, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br><br>reader := bufio.NewReader(file)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// line, err := reader.ReadBytes(&#x27;\n&#x27;)</span><br>line, err := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>) <span class="hljs-comment">//注意是字符</span><br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(line) != <span class="hljs-number">0</span> &#123;<br>fmt.Println(line)<br>&#125;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;read file failed, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Print(line)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="ioutil">ioutil</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>content, err := ioutil.ReadFile(<span class="hljs-string">&quot;./test.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;read file failed, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-keyword">string</span>(content))<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="文件写入">2.3 文件写入</h4><h5 id="write和writestring">Write和WriteString</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>file, err := os.OpenFile(<span class="hljs-string">&quot;xx.txt&quot;</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="hljs-number">0666</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;open file failed, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br>str := <span class="hljs-string">&quot;满腹经纶，白发不第；&quot;</span><br>file.Write([]<span class="hljs-keyword">byte</span>(str))       <span class="hljs-comment">//写入字节切片数据</span><br>file.WriteString(<span class="hljs-string">&quot;才疏学浅，少年登科&quot;</span>) <span class="hljs-comment">//直接写入字符串数据</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="bufio-1">bufio</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>file, err := os.OpenFile(<span class="hljs-string">&quot;xx.txt&quot;</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="hljs-number">0666</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;open file failed, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br>writer := bufio.NewWriter(file)<br><br>writer.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hello &quot;</span>))<br>writer.WriteString(<span class="hljs-string">&quot;debuggingWorld&quot;</span>)<br><br>writer.Flush() <span class="hljs-comment">//将缓存中的内容写入文件</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="ioutil.writefile">ioutil.WriteFile</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;hello debuggingWorld&quot;</span><br>err := ioutil.WriteFile(<span class="hljs-string">&quot;./xx.txt&quot;</span>, []<span class="hljs-keyword">byte</span>(str), <span class="hljs-number">0666</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;write file failed, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——并发</title>
    <link href="/2022/01/13/Go%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91/"/>
    <url>/2022/01/13/Go%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h3 id="goroutine">1. Goroutine</h3><p>Go 语言中的 goroutine 是由 Go 的运行时（runtime）调度和管理的。Go程序会将 goroutine 中的任务合理地分配给每个CPU。</p><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个goroutine 的栈在其生命周期开始时只有很小的栈（典型情况下2KB），goroutine 的栈不是固定的，他可以按需增大和缩小，goroutine的栈大小限制可以达到1GB。</p><h4 id="使用-goroutine">1.1 使用 goroutine</h4><p>Go 语言中使用g oroutine 非常简单，只需要在调用函数的时候在前面加上 go关键字，就可以为一个函数创建一个 goroutine。</p><p>一个 goroutine 必定对应一个函数，可以创建多个 goroutine去执行相同的函数。</p><p>使用 go 关键字创建 goroutine 时，被调用函数的返回值会被忽略。</p><p>在程序启动时，Go 程序就会为 main() 函数创建一个默认的 goroutine。所有goroutine 在 main() 函数结束时会一同结束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go 关键字放在方法调用前新建一个 goroutine 并执行方法体</span><br><span class="hljs-keyword">go</span> GetThingDone(param1, param2);<br><br><span class="hljs-comment">//新建一个匿名方法并执行</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(param1, param2)</span></span> &#123;<br>&#125;(val1, val2)<br><br><span class="hljs-keyword">go</span> 语句<br></code></pre></td></tr></table></figure><p>示例： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;this is a goroutine&quot;</span>)<br>&#125;()<br><br>fmt.Println(<span class="hljs-string">&quot;this is main goroutine !&quot;</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="gomaxprocs">1.2 GOMAXPROCS</h4><p>Go 运行时的调度器使用 <code>GOMAXPROCS</code>参数来确定需要使用多少个 OS 线程来同时执行 Go代码。默认值是机器上的CPU核心数。</p><p>Go语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。</p><p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;A:&quot;</span>, i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;B:&quot;</span>, i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>runtime.GOMAXPROCS(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">go</span> a()<br><span class="hljs-keyword">go</span> b()<br>time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="channel">2. channel</h3><p>Go 语言的并发模型是 CSP（Communicating Sequential Processes），提倡<code>通过通信共享内存</code>而不是<code>通过共享内存而实现通信</code>。</p><p>如果说 goroutine 是 Go 程序并发的执行体，channel就是它们之间的连接。channel 是可以让一个 goroutine 发送特定值到另一个goroutine 的通信机制。</p><p>Go语言中的通道（channel）是一种特殊的类型。在任何时候，同时只能有一个goroutine 访问通道进行发送和获取数据。goroutine间通过通道就可以通信。</p><p>通道像一个队列，总是遵循先入先出（First In FirstOut）的规则，保证收发数据的顺序。</p><h4 id="channel-类型">2.1 channel 类型</h4><p>channel 是一种类型，一种引用类型。声明通道类型的格式如下：</p><blockquote><p>var　变量　chan　元素类型</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch1 <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>   <span class="hljs-comment">// 声明一个传递整型的通道</span><br><span class="hljs-keyword">var</span> ch2 <span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>  <span class="hljs-comment">// 声明一个传递布尔型的通道</span><br><span class="hljs-keyword">var</span> ch3 <span class="hljs-keyword">chan</span> []<span class="hljs-keyword">int</span> <span class="hljs-comment">// 声明一个传递int切片的通道</span><br></code></pre></td></tr></table></figure><h4 id="创建-channel">2.2 创建 channel</h4><p>通道是引用类型，通道类型的空值是nil。</p><p>声明的通道后需要使用 make 函数初始化之后才能使用。</p><p>创建channel的格式如下：</p><blockquote><p>make(chan 元素类型, [缓冲大小])</p></blockquote><p>channel 的缓冲大小是可选的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ch4 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>ch5 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)<br>ch6 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-keyword">int</span>)<br></code></pre></td></tr></table></figure><h4 id="channel-操作">2.3 channel 操作</h4><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p><p>发送和接收都使用 &lt;- 符号。</p><p>关闭后的通道有以下特点： &gt;+ 对一个关闭的通道再发送值就会导致panic。 &gt;+ 对一个关闭的通道进行接收会一直获取值直到通道为空。 &gt;+对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。 &gt;+关闭一个已经关闭的通道会导致 panic。</p><h4 id="for-range-从通道循环接收">2.4 for range 从通道循环接收</h4><p>使用 for range 遍历通道，当通道被关闭的时候就会退出 for range。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go">ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><span class="hljs-comment">// 开启 goroutine 将 0~100 的数发送到 ch1 中</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>ch1 &lt;- i<br>&#125;<br><span class="hljs-built_in">close</span>(ch1)<br>&#125;()<br><span class="hljs-comment">// 开启 goroutine 从 ch1 中接收值，并将该值的平方发送到 ch2 中</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>i, ok := &lt;-ch1 <span class="hljs-comment">// 通道关闭后再取值 ok =false</span><br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>ch2 &lt;- i * i<br>&#125;<br><span class="hljs-built_in">close</span>(ch2)<br>&#125;()<br><br><span class="hljs-comment">// 在主 goroutine 中从 ch2 中接收值打印</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> ch2 &#123; <span class="hljs-comment">// 通道关闭后会退出 for range 循环</span><br>fmt.Println(i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="无缓冲的通道">2.5 无缓冲的通道</h4><p>无缓冲的通道又称为阻塞的通道。</p><p>无缓冲通道上的发送操作会阻塞，直到另一个 goroutine在该通道上执行接收操作，这时值才能发送成功，两个 goroutine将继续执行。相反，如果接收操作先执行，接收方的 goroutine将阻塞，直到另一个 goroutine 在该通道上发送一个值。</p><p>使用无缓冲通道进行通信将导致发送和接收的 goroutine同步化。因此，无缓冲通道也被称为同步通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">receive</span><span class="hljs-params">(c <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br>ret := &lt;-c<br>fmt.Println(<span class="hljs-string">&quot;接收成功&quot;</span>, ret)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><span class="hljs-keyword">go</span> receive(ch) <span class="hljs-comment">// 启用 goroutine 从通道接收值</span><br>ch &lt;- <span class="hljs-number">10</span><br>fmt.Println(<span class="hljs-string">&quot;发送成功&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="有缓冲的通道">2.6 有缓冲的通道</h4><p>有缓冲的通道（bufferedchannel）是一种在被接收前能存储一个或者多个值的通道。这种类型的通道并不强制要求goroutine之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建一个3个元素缓冲大小的整型通道</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(ch)) <span class="hljs-comment">// 0</span><br>ch &lt;- <span class="hljs-number">1</span><br>ch &lt;- <span class="hljs-number">2</span><br>ch &lt;- <span class="hljs-number">3</span><br>fmt.Println(<span class="hljs-built_in">len</span>(ch)) <span class="hljs-comment">// 3</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="单向通道">2.7 单向通道</h4><p>声明格式： &gt;var 通道实例 chan&lt;- 元素类型 // 只能写入数据的通道&gt;var 通道实例 &lt;-chan 元素类型 // 只能读取数据的通道</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>out &lt;- i<br>&#125;<br><span class="hljs-built_in">close</span>(out)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">squarer</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>, in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> in &#123;<br>out &lt;- i * i<br>&#125;<br><span class="hljs-built_in">close</span>(out)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printer</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> in &#123;<br>fmt.Println(i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><span class="hljs-keyword">go</span> counter(ch1)<br><span class="hljs-keyword">go</span> squarer(ch2, ch1)<br>printer(ch2)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="worker-pool">2.8 worker pool</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>, jobs &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, results <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> jobs &#123;<br>fmt.Printf(<span class="hljs-string">&quot;worker:%d start job:%d\n&quot;</span>, id, j)<br>time.Sleep(time.Second)<br>fmt.Printf(<span class="hljs-string">&quot;worker:%d end job:%d\n&quot;</span>, id, j)<br>results &lt;- j * <span class="hljs-number">2</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>jobs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">100</span>)<br>results := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">100</span>)<br><span class="hljs-comment">// 开启 3 个 goroutine</span><br><span class="hljs-keyword">for</span> w := <span class="hljs-number">1</span>; w &lt;= <span class="hljs-number">3</span>; w++ &#123;<br><span class="hljs-keyword">go</span> worker(w, jobs, results)<br>&#125;<br><span class="hljs-comment">// 5个任务</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">5</span>; j++ &#123;<br>jobs &lt;- j<br>&#125;<br><span class="hljs-built_in">close</span>(jobs)<br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-keyword">for</span> a := <span class="hljs-number">1</span>; a &lt;= <span class="hljs-number">5</span>; a++ &#123;<br>fmt.Println(&lt;-results)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="通道异常总结">2.9 通道异常总结</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220114215946.png" /></p><p>关闭已经关闭的 channel 也会引发 panic。</p><h3 id="select-语句">3. select 语句</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> communication clause  :<br>       statement(s);      <br>    <span class="hljs-keyword">case</span> communication clause  :<br>       statement(s);<br>    ...<br>    <span class="hljs-keyword">default</span> : <span class="hljs-comment">/* 可选 */</span><br>       statement(s);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>每个 case 都必须是一个通信（接收或发送）</li><li>所有 channel 表达式都会被求值</li><li>如果任意某个通信可以进行，它就执行，其他被忽略。</li><li>对于没有 case 的 select{} 会一直等待。</li><li>如果有多个 case 都可以运行，Select会随机公平地选出一个执行。其他不会执行。 否则：<ol type="1"><li>如果有 default 子句，则执行该语句。</li><li>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go不会重新对 channel 或值进行求值。</li></ol></li></ul><p>例1：打印偶数 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> x := &lt;-ch:<br>fmt.Println(x)<br><span class="hljs-keyword">case</span> ch &lt;- i:<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure> 例2：火箭点火火箭点火倒计时10秒，如果键盘输入任意字符就打断点火，如果没有就10s后起飞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>abort := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>os.Stdin.Read(<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">1</span>))<br>abort &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;()<br>fmt.Println(<span class="hljs-string">&quot;start countdown&quot;</span>)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">10</span> * time.Second):<br><span class="hljs-keyword">case</span> &lt;-abort:<br>fmt.Println(<span class="hljs-string">&quot;Launch aborted!&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;launch&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="并发安全和锁">4. 并发安全和锁</h3><p>多个 goroutine同时操作一个资源（临界区），会发生竞态问题（数据竞态）。</p><h4 id="互斥锁">4.1 互斥锁</h4><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个goroutine 可以访问共享资源。Go 语言中使用 sync 包的 Mutex类型来实现互斥锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-keyword">int64</span><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-keyword">var</span> lock sync.Mutex<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ &#123;<br>lock.Lock() <span class="hljs-comment">// 加锁</span><br>x = x + <span class="hljs-number">1</span><br>lock.Unlock() <span class="hljs-comment">// 解锁</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg.Add(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">go</span> add()<br><span class="hljs-keyword">go</span> add()<br>wg.Wait()<br>fmt.Println(x)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用互斥锁能够保证同一时间有且只有一个 goroutine 进入临界区，其他的goroutine 则在等待锁；当互斥锁释放后，等待的 goroutine才可以获取锁进入临界区，多个 goroutine同时等待一个锁时，唤醒的策略是随机的。</p><h4 id="读写互斥锁">4.2 读写互斥锁</h4><p>读写锁分为两种：读锁和写锁。当一个 goroutine获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个goroutine 获取写锁之后，其他的 goroutine无论是获取读锁还是写锁都会等待。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>x      <span class="hljs-keyword">int64</span><br>wg     sync.WaitGroup<br>rwLock sync.RWMutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>rwLock.Lock() <span class="hljs-comment">// 加写锁</span><br>x = x + <span class="hljs-number">1</span><br>time.Sleep(<span class="hljs-number">10</span> * time.Millisecond) <span class="hljs-comment">// 假设读操作耗时10毫秒</span><br>rwLock.Unlock()                   <span class="hljs-comment">// 解写锁</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>rwLock.RLock()               <span class="hljs-comment">// 加读锁</span><br>time.Sleep(time.Millisecond) <span class="hljs-comment">// 假设读操作耗时1毫秒</span><br>rwLock.RUnlock()             <span class="hljs-comment">// 解读锁</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> write()<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> read()<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sync.waitgroup">4.3 sync.WaitGroup</h4><p>sync.WaitGroup 方法：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220115180328.png" /></p><p>需要注意sync.WaitGroup是一个结构体，传递的时候要传递指针。</p><h4 id="sync.once">4.4 sync.Once</h4><p>Once is an object that will perform exactly one action.</p><p>可以用来实现加载配置文件等只需要加载一次的操作。</p><p>sync.Once 实现的并发安全的单例模式： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> singleton <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-keyword">var</span> instance *singleton<br><span class="hljs-keyword">var</span> once sync.Once<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> *<span class="hljs-title">singleton</span></span> &#123;<br>once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>instance = &amp;singleton&#123;&#125;<br>&#125;)<br><span class="hljs-keyword">return</span> instance<br>&#125;<br></code></pre></td></tr></table></figure></p><h4 id="sync.map">4.5 sync.Map</h4><p>Go 语言中内置的 map 不是并发安全的 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span></span> &#123;<br>key := strconv.Itoa(n)<br>m[key] = n<br>fmt.Printf(<span class="hljs-string">&quot;k=:%v,v:=%v\n&quot;</span>, key, m[key])<br>wg.Done()<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure> 报错：fatal error:concurrent map writes</p><p>Go 语言的 sync 包中提供了一个开箱即用的并发安全版map——sync.Map。开箱即用表示不用像内置的 map 一样使用 make函数初始化就能直接使用。同时 sync.Map 内置了诸如Store、Load、LoadOrStore、Delete、Range 等操作方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m = sync.Map&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg := sync.WaitGroup&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span></span> &#123;<br>key := strconv.Itoa(n)<br>m.Store(key, n)<br>value, _ := m.Load(key)<br>fmt.Printf(<span class="hljs-string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)<br>wg.Done()<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sync.pool">4.6 sync.Pool</h4><p>sync.Pool是一个并发池，负责安全地保存一组对象。它有两个导出方法：</p><ul><li>Get() interface{} 用来从并发池中随机取出元素。</li><li>Put(interface{}) 将一个对象加入并发池。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>pool := &amp;sync.Pool&#123;&#125;<br><br>pool.Put(NewConnection(<span class="hljs-number">1</span>))<br>pool.Put(NewConnection(<span class="hljs-number">2</span>))<br>pool.Put(NewConnection(<span class="hljs-number">3</span>))<br><br>connection := pool.Get().(*Connection)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, connection.id)<br>connection = pool.Get().(*Connection)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, connection.id)<br>connection = pool.Get().(*Connection)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, connection.id)<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以为 sync.Pool 指定一个创建者方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>pool := &amp;sync.Pool&#123;<br>New: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br><span class="hljs-keyword">return</span> NewConnection()<br>&#125;,<br>&#125;<br><br>connection := pool.Get().(*Connection)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="sync.cond">4.7 sync.Cond</h4><p>类似与Java的wait和notify 或者说 Condition，更像后者，但是没有超时的机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>mutex := sync.Mutex&#123;&#125;<br>start := sync.NewCond(&amp;mutex)<br><br><span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">10</span>; x++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>start.L.Lock()<br><span class="hljs-keyword">defer</span> start.L.Unlock()<br>start.Wait()<br>fmt.Println(<span class="hljs-string">&quot;do work&quot;</span>)<br>&#125;()<br>&#125;<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(time.Second * <span class="hljs-number">3</span>)<br>start.Broadcast()<br>&#125;()<br><br>time.Sleep(time.Second * <span class="hljs-number">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="原子操作">5. 原子操作</h3><p>Go语言中原子操作由内置的标准库sync/atomic提供。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220115185737.png" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> counter <span class="hljs-keyword">int64</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>atomic.AddInt64(&amp;counter, <span class="hljs-number">1</span>)<br>wg.Done()<br>&#125;()<br>&#125;<br>wg.Wait()<br>fmt.Println(atomic.LoadInt64(&amp;counter))<span class="hljs-comment">// 10000</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——反射</title>
    <link href="/2022/01/11/Go%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/01/11/Go%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<p>反射是指在程序运行期对程序本身进行访问和修改的能力。</p><p>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p><p>Go 程序在运行期使用 reflect 包访问程序的反射信息。</p><h3 id="reflect-包">1. reflect 包</h3><p>在 Go 语言的反射机制中，任何接口值都由是一个<strong>具体类型</strong> 和 <strong>具体类型的值</strong> 两部分组成。在 Go 语言中反射的相关功能由内置的 reflect包提供，任意接口值在反射中都可以理解为由 reflect.Type 和 reflect.Value两部分组成，并且 reflect 包提供了 reflect.TypeOf 和 reflect.ValueOf两个函数来获取任意对象的 Value 和 Type。</p><h4 id="reflect.type">1.1 reflect.Type</h4><p>使用 reflect.TypeOf()函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span><br>typeOfA := reflect.TypeOf(a)<br>fmt.Println(typeOfA.Name(), typeOfA.Kind())<span class="hljs-comment">// int int</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="反射的类型type与种类kind">反射的类型（Type）与种类（Kind）</h5><p>Go语言程序中的类型（Type）指的是系统原生数据类型，如int、string、bool、float32 等类型，以及使用 type关键字定义的类型，这些类型的名称就是其类型本身的名称。例如使用 type Astruct{} 定义结构体时，A 就是 struct{} 的类型。</p><p>种类（Kind）指的是对象归属的品种，在 reflect 包中定义的 Kind类型如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Kind <span class="hljs-keyword">uint</span><br><span class="hljs-keyword">const</span> (<br>    Invalid Kind = <span class="hljs-literal">iota</span>  <span class="hljs-comment">// 非法类型</span><br>    Bool                 <span class="hljs-comment">// 布尔型</span><br>    Int                  <span class="hljs-comment">// 有符号整型</span><br>    Int8                 <span class="hljs-comment">// 有符号8位整型</span><br>    Int16                <span class="hljs-comment">// 有符号16位整型</span><br>    Int32                <span class="hljs-comment">// 有符号32位整型</span><br>    Int64                <span class="hljs-comment">// 有符号64位整型</span><br>    Uint                 <span class="hljs-comment">// 无符号整型</span><br>    Uint8                <span class="hljs-comment">// 无符号8位整型</span><br>    Uint16               <span class="hljs-comment">// 无符号16位整型</span><br>    Uint32               <span class="hljs-comment">// 无符号32位整型</span><br>    Uint64               <span class="hljs-comment">// 无符号64位整型</span><br>    Uintptr              <span class="hljs-comment">// 指针</span><br>    Float32              <span class="hljs-comment">// 单精度浮点数</span><br>    Float64              <span class="hljs-comment">// 双精度浮点数</span><br>    Complex64            <span class="hljs-comment">// 64位复数类型</span><br>    Complex128           <span class="hljs-comment">// 128位复数类型</span><br>    Array                <span class="hljs-comment">// 数组</span><br>    Chan                 <span class="hljs-comment">// 通道</span><br>    Func                 <span class="hljs-comment">// 函数</span><br>    Interface            <span class="hljs-comment">// 接口</span><br>    Map                  <span class="hljs-comment">// 映射</span><br>    Ptr                  <span class="hljs-comment">// 指针</span><br>    Slice                <span class="hljs-comment">// 切片</span><br>    String               <span class="hljs-comment">// 字符串</span><br>    Struct               <span class="hljs-comment">// 结构体</span><br>    UnsafePointer        <span class="hljs-comment">// 底层指针</span><br>)<br></code></pre></td></tr></table></figure><h5id="从类型对象中获取类型名称和种类">从类型对象中获取类型名称和种类</h5><p>Go语言中的类型名称对应的反射获取方法是 reflect.Type 中的 Name()方法，返回表示类型名称的字符串；类型归属的种类（Kind）使用的是reflect.Type 中的 Kind() 方法，返回 reflect.Kind 类型的常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myInt <span class="hljs-keyword">int64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectType</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>t := reflect.TypeOf(x)<br>fmt.Printf(<span class="hljs-string">&quot;type:%v   kind:%v\n&quot;</span>, t.Name(), t.Kind())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a *<span class="hljs-keyword">float32</span> <span class="hljs-comment">// 指针</span><br><span class="hljs-keyword">var</span> b myInt    <span class="hljs-comment">// 自定义类型</span><br><span class="hljs-keyword">var</span> c <span class="hljs-keyword">rune</span>     <span class="hljs-comment">// 类型别名</span><br>reflectType(a) <span class="hljs-comment">// type:   kind:ptr</span><br>reflectType(b) <span class="hljs-comment">// type:myInt   kind:int64</span><br>reflectType(c) <span class="hljs-comment">// type:int32   kind:int32</span><br><br><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br><br>&#125;<br><span class="hljs-keyword">var</span> d = person&#123;<br>name: <span class="hljs-string">&quot;张三&quot;</span>,<br>&#125;<br>reflectType(d) <span class="hljs-comment">// type:person kind:struct</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Go 语言的反射中像数组、切片、Map、指针等类型的变量，它们的 Name()都是返回空。</p><h4 id="reflect.value">1.2 reflect.Value</h4><p>reflect.ValueOf()返回的是reflect.Value类型，其中包含了原始值的值信息。reflect.Value与原始值之间可以互相转换。</p><p>reflect.Value类型提供的获取原始值的方法如下：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220111203052.png" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectValue</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>v := reflect.ValueOf(x)<br>k := v.Kind()<br><span class="hljs-keyword">switch</span> k &#123;<br><span class="hljs-keyword">case</span> reflect.Int64:<br>fmt.Println(<span class="hljs-keyword">int64</span>(v.Int()))<br><span class="hljs-keyword">case</span> reflect.Float32:<br>fmt.Println(<span class="hljs-keyword">float32</span>(v.Float()))<br><span class="hljs-keyword">case</span> reflect.Float64:<br>fmt.Println(v.Float())<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">float32</span> = <span class="hljs-number">3.14</span><br><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int64</span> = <span class="hljs-number">100</span><br>reflectValue(a) <span class="hljs-comment">// 3.14</span><br>reflectValue(b) <span class="hljs-comment">// 100</span><br><span class="hljs-comment">// 将int类型的原始值转换为reflect.Value类型</span><br>c := reflect.ValueOf(<span class="hljs-number">10</span>)<br>fmt.Printf(<span class="hljs-string">&quot;type c :%T\n&quot;</span>, c) <span class="hljs-comment">// type c :reflect.Value</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="指针与指针指向的元素">1.3 指针与指针指向的元素</h4><p>Go语言程序中对指针获取反射对象时，可以通过 reflect.Elem()方法获取这个指针指向的元素类型，这个获取过程被称为取元素，等效于对指针类型变量做了一个* 操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">type</span> cat <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><span class="hljs-comment">// 创建cat的实例</span><br>ins := &amp;cat&#123;&#125;<br><span class="hljs-comment">// 获取结构体实例的反射类型对象</span><br>typeOfCat := reflect.TypeOf(ins)<br><span class="hljs-comment">// 显示反射类型对象的名称和种类</span><br>fmt.Printf(<span class="hljs-string">&quot;name:&#x27;%v&#x27; kind:&#x27;%v&#x27;\n&quot;</span>, typeOfCat.Name(), typeOfCat.Kind())<span class="hljs-comment">// name:&#x27;&#x27; kind:&#x27;ptr&#x27;</span><br><span class="hljs-comment">// 取类型的元素</span><br>typeOfCat = typeOfCat.Elem()<br><span class="hljs-comment">// 显示反射类型对象的名称和种类</span><br>fmt.Printf(<span class="hljs-string">&quot;element name: &#x27;%v&#x27;, element kind: &#x27;%v&#x27;\n&quot;</span>, typeOfCat.Name(), typeOfCat.Kind())<br><span class="hljs-comment">// element name: &#x27;cat&#x27;, element kind: &#x27;struct&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="isnil-和-isvalid">2. IsNil() 和 IsValid()</h3><p>IsNil() bool：返回值是否为nil。如果值类型不是通道（channel）、函数、接口、map、指针或 切片时发生panic，类似于语言层的v== nil操作 IsValid() bool：判断值是否有效。当值本身非法时，返回 false，例如 reflect Value不包含任何值，值为 nil等，此时除了 IsValid、String、Kind 之外的方法都会导致 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// *int类型空指针</span><br><span class="hljs-keyword">var</span> a *<span class="hljs-keyword">int</span><br>fmt.Println(<span class="hljs-string">&quot;var a *int IsNil:&quot;</span>, reflect.ValueOf(a).IsNil()) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// nil值</span><br>fmt.Println(<span class="hljs-string">&quot;nil IsValid:&quot;</span>, reflect.ValueOf(<span class="hljs-literal">nil</span>).IsValid()) <span class="hljs-comment">// false</span><br><span class="hljs-comment">// 实例化一个匿名结构体</span><br>b := <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-comment">// 尝试从结构体中查找&quot;abc&quot;字段</span><br>fmt.Println(<span class="hljs-string">&quot;不存在的结构体成员:&quot;</span>, reflect.ValueOf(b).FieldByName(<span class="hljs-string">&quot;abc&quot;</span>).IsValid()) <span class="hljs-comment">// false</span><br><span class="hljs-comment">// 尝试从结构体中查找&quot;abc&quot;方法</span><br>fmt.Println(<span class="hljs-string">&quot;不存在的结构体方法:&quot;</span>, reflect.ValueOf(b).MethodByName(<span class="hljs-string">&quot;abc&quot;</span>).IsValid()) <span class="hljs-comment">// false</span><br><span class="hljs-comment">// map</span><br>c := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>&#123;&#125;<br><span class="hljs-comment">// 尝试从map中查找一个不存在的键</span><br>fmt.Println(<span class="hljs-string">&quot;map中不存在的键：&quot;</span>, reflect.ValueOf(c).MapIndex(reflect.ValueOf(<span class="hljs-string">&quot;娜扎&quot;</span>)).IsValid()) <span class="hljs-comment">// false</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>### 3. 通过反射修改变量的值</p><p>有一些 reflect.Values 是可取地址的；其它一些则不可以。</p><p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"> x := <span class="hljs-number">2</span> <span class="hljs-comment">// value type variable?</span><br>a := reflect.ValueOf(<span class="hljs-number">2</span>) <span class="hljs-comment">// 2 int no</span><br>b := reflect.ValueOf(x) <span class="hljs-comment">// 2 int no</span><br>c := reflect.ValueOf(&amp;x)<span class="hljs-comment">// &amp;x *int no</span><br>d := c.Elem() <span class="hljs-comment">// 2 int yes (x)</span><br></code></pre></td></tr></table></figure> 其中 a 对应的变量则不可取地址。因为 a 中的值仅仅是整数2 的拷贝副本。b 中的值也同样不可取地址。c中的值还是不可取地址，它只是一个指针 &amp;x 的拷贝。实际上，所有通过reflect.ValueOf(x) 返回的 reflect.Value 都是不可取地址的。但是对于d，它是 c的解引用方式生成的，指向另一个变量，因此是可取地址的。我们可以通过调用reflect.ValueOf(&amp;x).Elem()，来获取任意变量x对应的可取地址的Value。</p><p>判定及获取元素的相关方法：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220112102159.png" /></p><p>值修改相关方法：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220112103035.png" /></p><p>#### 值可修改条件之一：可被寻址</p><p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 声明整型变量a并赋初值</span><br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">1024</span><br><span class="hljs-comment">// 获取变量a的反射值对象</span><br>valueOfA := reflect.ValueOf(a)<br><span class="hljs-comment">// 尝试将a修改为1(此处会发生崩溃)</span><br>valueOfA.SetInt(<span class="hljs-number">1</span>) <span class="hljs-comment">// panic: reflect: reflect.Value.SetInt using unaddressable value</span><br>&#125;<br></code></pre></td></tr></table></figure> 从 reflect.ValueOf 传入的是 a 的值，而不是 a的地址，这个 reflect.Value 当然是不能被寻址的。 <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"> func <span class="hljs-selector-tag">main</span>() &#123;<br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> int = <span class="hljs-number">1024</span><br><span class="hljs-comment">// 获取变量a的反射值对象(a的地址)</span><br>valueOfA := reflect<span class="hljs-selector-class">.ValueOf</span>(&amp;a)<br><span class="hljs-comment">// 取出a地址的元素(a的值)</span><br>valueOfA = valueOfA<span class="hljs-selector-class">.Elem</span>()<br><span class="hljs-comment">// 修改a的值为1</span><br>valueOfA<span class="hljs-selector-class">.SetInt</span>(<span class="hljs-number">1</span>)<br>fmt<span class="hljs-selector-class">.Println</span>(valueOfA<span class="hljs-selector-class">.Int</span>()) <span class="hljs-comment">// 1</span><br>&#125;<br></code></pre></td></tr></table></figure> 当reflect.Value 不可寻址时，使用 Addr()方法也是无法取到值的地址的，同时会发生宕机。虽然说 reflect.Value 的Addr() 方法类似于语言层的&amp;操作；Elem()方法类似于语言层的*操作，但并不代表这些方法与语言层操作等效。</p><p>#### 值可修改条件之一：被导出</p><p>结构体成员中，如果字段没有被导出，即便不使用反射也可以被访问，但不能通过反射修改。</p><p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs GO"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">type</span> dog <span class="hljs-keyword">struct</span> &#123;<br>legCount <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-comment">// 获取 dog 实例地址的反射值对象</span><br>valueOfDog := reflect.ValueOf(&amp;dog&#123;&#125;)<br><span class="hljs-comment">// 取出 dog 实例地址的元素</span><br>valueOfDog = valueOfDog.Elem()<br><span class="hljs-comment">// 获取 legCount 字段的值</span><br>vLegCount := valueOfDog.FieldByName(<span class="hljs-string">&quot;legCount&quot;</span>)<br><br>vLegCount.SetInt(<span class="hljs-number">4</span>)<span class="hljs-comment">// panic: reflect: reflect.Value.SetInt using value obtained using unexported field</span><br><br>fmt.Println(vLegCount.Int())<br>&#125;<br></code></pre></td></tr></table></figure> SetInt() 使用的值来自于一个未导出的字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">type</span> dog <span class="hljs-keyword">struct</span> &#123;<br>LegCount <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-comment">// 获取 dog 实例地址的反射值对象</span><br>valueOfDog := reflect.ValueOf(&amp;dog&#123;&#125;)<br><span class="hljs-comment">// 取出 dog 实例地址的元素</span><br>valueOfDog = valueOfDog.Elem()<br><span class="hljs-comment">// 获取 legCount 字段的值</span><br>vLegCount := valueOfDog.FieldByName(<span class="hljs-string">&quot;LegCount&quot;</span>)<br><br>vLegCount.SetInt(<span class="hljs-number">4</span>)<br><br>fmt.Println(vLegCount.Int())<span class="hljs-comment">// 4</span><br>&#125;<br></code></pre></td></tr></table></figure><p>导出后可正确设置。</p><p>### 4. 结构体反射</p><p>结构体相关的方法：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220112105630.png" /></p><p>StructField 类型用来描述结构体中的一个字段的信息。</p><p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-keyword">type</span> StructField <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&quot;&quot;。</span><br>    <span class="hljs-comment">// 参见http://golang.org/ref/spec#Uniqueness_of_identifiers</span><br>    Name    <span class="hljs-keyword">string</span><br>    PkgPath <span class="hljs-keyword">string</span><br>    Type      Type      <span class="hljs-comment">// 字段的类型</span><br>    Tag       StructTag <span class="hljs-comment">// 字段的标签</span><br>    Offset    <span class="hljs-keyword">uintptr</span>   <span class="hljs-comment">// 字段在结构体中的字节偏移量</span><br>    Index     []<span class="hljs-keyword">int</span>     <span class="hljs-comment">// 用于Type.FieldByIndex时的索引切片</span><br>    Anonymous <span class="hljs-keyword">bool</span>      <span class="hljs-comment">// 是否匿名字段</span><br>&#125;<br></code></pre></td></tr></table></figure></p><p>StructTag 拥有一些方法，可以进行 Tag 信息的解析和提取，如下所示： +func (tag StructTag) Get(key string) string 根据 Tag中的键获取对应的值，例如 <code>key1:"value1"key2:"value2"</code> 的 Tag中，可以传入“key1”获得“value1”。 + func(tag StructTag) Lookup(keystring)(value string,ok bool) 根据 Tag 中的键，查询值是否存在。</p><h4 id="反射操作结构体字段">反射操作结构体字段</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>stu1 := student&#123;<br>Name:  <span class="hljs-string">&quot;张三&quot;</span>,<br>Score: <span class="hljs-number">18</span>,<br>&#125;<br><br>t := reflect.TypeOf(stu1)<br>fmt.Println(t.Name(), t.Kind()) <span class="hljs-comment">// student struct</span><br><br><span class="hljs-comment">// 通过for循环遍历结构体的所有字段信息</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; t.NumField(); i++ &#123;<br>field := t.Field(i)<br>fmt.Printf(<span class="hljs-string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, field.Name, field.Index, field.Type, field.Tag.Get(<span class="hljs-string">&quot;json&quot;</span>))<br>&#125;<br><span class="hljs-comment">// name:Name index:[0] type:string json tag:name</span><br><span class="hljs-comment">// name:Score index:[1] type:int json tag:score</span><br><br><span class="hljs-comment">// 通过字段名获取指定结构体字段信息</span><br><span class="hljs-keyword">if</span> scoreField, ok := t.FieldByName(<span class="hljs-string">&quot;Score&quot;</span>); ok &#123;<br>fmt.Printf(<span class="hljs-string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(<span class="hljs-string">&quot;json&quot;</span>))<br>&#125;<br><span class="hljs-comment">// name:Score index:[1] type:int json tag:score</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="反射操作结构体方法">反射操作结构体方法</h4><p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-keyword">type</span> student <span class="hljs-keyword">struct</span> &#123;<br>Name  <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Score <span class="hljs-keyword">int</span>    <span class="hljs-string">`json:&quot;score&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s student)</span> <span class="hljs-title">Study</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br>msg := <span class="hljs-string">&quot;好好学习，天天向上。&quot;</span><br>fmt.Println(msg)<br><span class="hljs-keyword">return</span> msg<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s student)</span> <span class="hljs-title">Sleep</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br>msg := <span class="hljs-string">&quot;zzzzzz&quot;</span><br>fmt.Println(msg)<br><span class="hljs-keyword">return</span> msg<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printMethod</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>t := reflect.TypeOf(x)<br>v := reflect.ValueOf(x)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.NumMethod(); i++ &#123;<br>methodType := v.Method(i).Type()<br>fmt.Printf(<span class="hljs-string">&quot;method name:%s\n&quot;</span>, t.Method(i).Name)<br>fmt.Printf(<span class="hljs-string">&quot;method type:%s\n&quot;</span>, methodType)<br><span class="hljs-comment">// 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span><br><span class="hljs-keyword">var</span> args []reflect.Value<br>v.Method(i).Call(args)<br>&#125;<br><span class="hljs-comment">// 执行结果：</span><br><span class="hljs-comment">// method name:Sleep</span><br><span class="hljs-comment">// method type:func() string</span><br><span class="hljs-comment">// zzzzzz</span><br><span class="hljs-comment">// method name:Study</span><br><span class="hljs-comment">// method type:func() string</span><br><span class="hljs-comment">// 好好学习，天天向上。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>printMethod(student&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="反射调用方法">5. 反射调用方法</h3><p>将函数保存到反射值对象（reflect.Value）中，然后将两个整型值构造为反射值对象的切片（[]reflect.Value），使用Call() 方法进行调用。 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 普通函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 将函数包装为反射值对象</span><br>funcValue := reflect.ValueOf(add)<br><br>fmt.Println(funcValue.Type().Kind(),<span class="hljs-string">&quot;---&quot;</span>,funcValue.Type().Name())<br><span class="hljs-comment">// func ---</span><br><span class="hljs-comment">// 构造函数参数, 传入两个整型值</span><br>paramList := []reflect.Value&#123;reflect.ValueOf(<span class="hljs-number">10</span>), reflect.ValueOf(<span class="hljs-number">20</span>)&#125;<br><span class="hljs-comment">// 反射调用函数</span><br>retList := funcValue.Call(paramList)<br><span class="hljs-comment">// 获取第一个返回值, 取整数值</span><br>fmt.Println(retList[<span class="hljs-number">0</span>].Int())<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——排序</title>
    <link href="/2022/01/09/Go%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/01/09/Go%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="使用-sort.interface-接口进行排序">1. 使用 sort.Interface接口进行排序</h3><p>sort.Interface 接口的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Len 集合中元素的数量</span><br>Len() <span class="hljs-keyword">int</span><br><br><span class="hljs-comment">// Less 索引为 i 的元素是否必须排在索引为 j 的元素之前</span><br>Less(i, j <span class="hljs-keyword">int</span>) <span class="hljs-keyword">bool</span><br><br><span class="hljs-comment">// Swap 交换索引为 i 和 j 的元素</span><br>Swap(i, j <span class="hljs-keyword">int</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStringList []<span class="hljs-keyword">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MyStringList)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(m)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MyStringList)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> m[i] &lt; m[j]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MyStringList)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span> &#123;<br>m[i], m[j] = m[j], m[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// 准备一个内容被打乱顺序的字符串切片</span><br>names := MyStringList&#123;<br><span class="hljs-string">&quot;zhangsan&quot;</span>,<br><span class="hljs-string">&quot;lisi&quot;</span>,<br><span class="hljs-string">&quot;wamgwu&quot;</span>,<br><span class="hljs-string">&quot;zhaoliu&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">// 使用sort包进行排序</span><br>sort.Sort(names)<br><br><span class="hljs-comment">// 遍历打印结果</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> names &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, v)<br>&#125;<br><span class="hljs-comment">/* 执行结果：</span><br><span class="hljs-comment">lisi</span><br><span class="hljs-comment">wamgwu</span><br><span class="hljs-comment">zhangsan</span><br><span class="hljs-comment">zhaoliu</span><br><span class="hljs-comment">*/</span><br><br>sort.Sort(sort.Reverse(names))<br><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> names &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, v)<br>&#125;<br><span class="hljs-comment">/* 执行结果：</span><br><span class="hljs-comment">zhaoliu</span><br><span class="hljs-comment">zhangsan</span><br><span class="hljs-comment">wamgwu</span><br><span class="hljs-comment">lisi</span><br><span class="hljs-comment">*/</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常见类型的便捷排序">2. 常见类型的便捷排序</h3><p>sort 包内建的类型排序接口一览：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220109172924.png" /></p><p>int32、int64、float32、bool 类型并没有由 sort 包实现</p><p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// 准备一个内容被打乱顺序的字符串切片</span><br>names := sort.StringSlice&#123;<br><span class="hljs-string">&quot;zhangsan&quot;</span>,<br><span class="hljs-string">&quot;lisi&quot;</span>,<br><span class="hljs-string">&quot;wamgwu&quot;</span>,<br><span class="hljs-string">&quot;zhaoliu&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">// 使用sort包进行排序</span><br>sort.Sort(names)<br><br><br>names2 := []<span class="hljs-keyword">string</span>&#123;<br><span class="hljs-string">&quot;zhangsan&quot;</span>,<br><span class="hljs-string">&quot;lisi&quot;</span>,<br><span class="hljs-string">&quot;wamgwu&quot;</span>,<br><span class="hljs-string">&quot;zhaoliu&quot;</span>,<br>&#125;<br><br>sort.Strings(names2)<br><br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="对结构体数据进行排序">3. 对结构体数据进行排序</h3><h4 id="实现-sort.interface-进行结构体排序">3.1 实现 sort.Interface进行结构体排序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// HeroKind 声明英雄的分类</span><br><span class="hljs-keyword">type</span> HeroKind <span class="hljs-keyword">int</span><br><br><span class="hljs-comment">// 定义HeroKind常量, 类似于枚举</span><br><span class="hljs-keyword">const</span> (<br>None HeroKind = <span class="hljs-literal">iota</span><br>Tank<br>Assassin<br>Mage<br>)<br><br><span class="hljs-keyword">type</span> Hero <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-keyword">string</span>  <span class="hljs-comment">// 英雄的名字</span><br>Kind HeroKind  <span class="hljs-comment">// 英雄的种类</span><br>&#125;<br><br><br><span class="hljs-keyword">type</span> Heroes []*Hero<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Heroes)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Heroes)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><br><span class="hljs-comment">// 如果英雄的分类不一致时, 优先对分类进行排序</span><br><span class="hljs-keyword">if</span> s[i].Kind != s[j].Kind &#123;<br><span class="hljs-keyword">return</span> s[i].Kind &lt; s[j].Kind<br>&#125;<br><br><span class="hljs-comment">// 默认按英雄名字字符升序排列</span><br><span class="hljs-keyword">return</span> s[i].Name &lt; s[j].Name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Heroes)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span> &#123;<br>s[i], s[j] = s[j], s[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// 准备英雄列表</span><br>heroes := Heroes&#123;<br>&amp;Hero&#123;<span class="hljs-string">&quot;吕布&quot;</span>, Tank&#125;,<br>&amp;Hero&#123;<span class="hljs-string">&quot;李白&quot;</span>, Assassin&#125;,<br>&amp;Hero&#123;<span class="hljs-string">&quot;妲己&quot;</span>, Mage&#125;,<br>&amp;Hero&#123;<span class="hljs-string">&quot;貂蝉&quot;</span>, Assassin&#125;,<br>&amp;Hero&#123;<span class="hljs-string">&quot;关羽&quot;</span>, Tank&#125;,<br>&amp;Hero&#123;<span class="hljs-string">&quot;诸葛亮&quot;</span>, Mage&#125;,<br>&#125;<br><br><span class="hljs-comment">// 使用sort包进行排序</span><br>sort.Sort(heroes)<br><br><span class="hljs-comment">// 遍历英雄列表打印排序结果</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> heroes &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220109174536.png" /></p><h4 id="使用-sort.slice-进行切片元素排序">3.2 使用 sort.Slice进行切片元素排序</h4><p>从 Go 1.8 开始，Go语言在 sort 包中提供了 sort.Slice()函数进行更为简便的排序方法。sort.Slice()函数只要求传入需要排序的数据，以及一个排序时对元素的回调函数，类型为func(i,j int)bool，sort.Slice() 函数的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Slice</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;, less <span class="hljs-keyword">func</span>(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span>)</span> &#123;<br>rv := reflectValueOf(x)<br>swap := reflectSwapper(x)<br>length := rv.Len()<br>quickSort_func(lessSwap&#123;less, swap&#125;, <span class="hljs-number">0</span>, length, maxDepth(length))<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> HeroKind <span class="hljs-keyword">int</span><br><br><span class="hljs-keyword">const</span> (<br>None = <span class="hljs-literal">iota</span><br>Tank<br>Assassin<br>Mage<br>)<br><br><span class="hljs-keyword">type</span> Hero <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-keyword">string</span><br>Kind HeroKind<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>heroes := []*Hero&#123;<br>&#123;<span class="hljs-string">&quot;吕布&quot;</span>, Tank&#125;,<br>&#123;<span class="hljs-string">&quot;李白&quot;</span>, Assassin&#125;,<br>&#123;<span class="hljs-string">&quot;妲己&quot;</span>, Mage&#125;,<br>&#123;<span class="hljs-string">&quot;貂蝉&quot;</span>, Assassin&#125;,<br>&#123;<span class="hljs-string">&quot;关羽&quot;</span>, Tank&#125;,<br>&#123;<span class="hljs-string">&quot;诸葛亮&quot;</span>, Mage&#125;,<br>&#125;<br><br>sort.Slice(heroes, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> heroes[i].Kind != heroes[j].Kind &#123;<br><span class="hljs-keyword">return</span> heroes[i].Kind &lt; heroes[j].Kind<br>&#125;<br><br><span class="hljs-keyword">return</span> heroes[i].Name &lt; heroes[j].Name<br>&#125;)<br><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> heroes &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——接口</title>
    <link href="/2022/01/06/Go%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/01/06/Go%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p><p><font color="red"><strong>接口（interface）是一种类型</strong></font></p><h3 id="接口定义">1. 接口定义</h3><p>Go语言中每个接口由数个方法（零个或多个）组成，接口的定义格式如下：</p><blockquote><p>type　接口类型名　interface{ 　方法名1( 参数列表1 )　返回值列表1　方法名2( 参数列表2 )　返回值列表2 　 … }</p></blockquote><p>其中：</p><ul><li>接口名：使用 type 将接口定义为自定义的类型名。Go语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer。</li><li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li><li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;<br>    String() <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实现该接，调用 String() 方法时可以获得对象对应的字符串，功能类似于Java 语言里的 toString 的操作。</p><h3 id="接口实现">2. 接口实现</h3><p>如果一个任意类型 T 的方法集为一个接口类型的方法集的超集，则我们说类型T 实现了此接口类型。T 可以是一个非接口类型，也可以是一个接口类型。</p><p>实现关系在Go语言中是隐式的。两个类型之间的实现关系不需要在代码中显式地表示出来。Go语言中没有类似于implements 的关键字。Go编译器将自动在需要的时候检查两个类型之间的实现关系。</p><p>接口定义后，需要实现接口，调用方才能正确编译通过并使用接口。接口的实现需要遵循两条规则才能让接口可用。</p><p>一个对象只要全部实现了接口中的方法，那么就实现了这个接口。</p><ol type="1"><li>接口的方法与实现接口的类型方法格式一致</li></ol><p>在类型中添加与接口签名一致的方法就可以实现该方法。签名包括方法中的名称、参数列表、返回参数列表。也就是说，只要实现接口类型中的方法的名称、参数列表、返回参数列表中的任意一项与接口要实现的方法不一致，那么接口的这个方法就不会被实现。</p><ol start="2" type="1"><li>接口中所有方法均被实现</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Eater 定义接口</span><br><span class="hljs-keyword">type</span> Eater <span class="hljs-keyword">interface</span> &#123;<br>eat()<br>&#125;<br><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// 实现接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;骨头&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> eater Eater = <span class="hljs-built_in">new</span>(Dog)<br>eater.eat()<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="值接收者实现接口">2.1 值接收者实现接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 实现接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;骨头&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> eater Eater<br>eater = Dog&#123;&#125;<span class="hljs-comment">// Dog 类型</span><br>eater = <span class="hljs-built_in">new</span>(Dog)<span class="hljs-comment">// 指针类型</span><br>eater.eat()<br>&#125;<br></code></pre></td></tr></table></figure><p>使用值接收者实现接口，不管是 dog 结构体还是结构体指针 *dog类型的变量都可以赋值给该接口变量。因为 Go语言中有对指针类型变量求值的语法糖，dog 指针内部会自动求值。</p><h4 id="指针接收者实现接口">2.2 指针接收者实现接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cat)</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;小黄鱼&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> eater Eater<br>eater = <span class="hljs-built_in">new</span>(Cat) <span class="hljs-comment">// 指针类型</span><br><span class="hljs-comment">// eater = Cat&#123;&#125;// Cat 类型，编译错误</span><br>eater.eat()<br>&#125;<br></code></pre></td></tr></table></figure><p>时实现接口的是 *Cat 类型，所以不把 Cat 类型传给接口类型变量。</p><h3 id="接口变量">3. 接口变量</h3><p>接口类型变量可以存储所有实现了该接口的实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> w io.Writer<br>fmt.Printf(<span class="hljs-string">&quot;%T \n&quot;</span>,w)<span class="hljs-comment">// &lt;nil&gt;</span><br>w = os.Stdout<br>fmt.Printf(<span class="hljs-string">&quot;%T \n&quot;</span>,w)<span class="hljs-comment">// *os.File</span><br>w = <span class="hljs-built_in">new</span>(bytes.Buffer)<br>fmt.Printf(<span class="hljs-string">&quot;%T \n&quot;</span>,w)<span class="hljs-comment">// *bytes.Buffer</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。这两部分分别称为接口的动态类型和动态值。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220108225046.png" /></p><h3 id="类型与接口的关系">4. 类型与接口的关系</h3><ol type="1"><li>一个类型实现多个接口</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Sayer <span class="hljs-keyword">interface</span> &#123;<br>say()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;汪汪汪~~~&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>dog := Dog&#123;&#125;<br>dog.say()<br>dog.eat()<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>多个类型实现同一接口</li></ol><p>并且一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Washer 洗衣</span><br><span class="hljs-keyword">type</span> Washer <span class="hljs-keyword">interface</span> &#123;<br>wash()<br>dry()<br>&#125;<br><br><span class="hljs-comment">// 甩干器</span><br><span class="hljs-keyword">type</span> dryer <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// 实现 Washer 接口的 dry() 方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d dryer)</span> <span class="hljs-title">dry</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;甩一甩&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 海尔洗衣机</span><br><span class="hljs-keyword">type</span> haier <span class="hljs-keyword">struct</span> &#123;<br>dryer <span class="hljs-comment">//嵌入甩干器</span><br>&#125;<br><br><span class="hljs-comment">// 实现 WashingMachine 接口的 wash() 方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h haier)</span> <span class="hljs-title">wash</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;洗刷刷&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口嵌套">5. 接口嵌套</h3><p>接口与接口间可以通过嵌套创造出新的接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">/ 接口嵌套<br><span class="hljs-keyword">type</span> animal <span class="hljs-keyword">interface</span> &#123;<br>Sayer<br>Eater<br>&#125;<br><br><span class="hljs-comment">// Eater 定义接口</span><br><span class="hljs-keyword">type</span> Eater <span class="hljs-keyword">interface</span> &#123;<br>eat()<br>&#125;<br><br><span class="hljs-keyword">type</span> Sayer <span class="hljs-keyword">interface</span> &#123;<br>say()<br>&#125;<br></code></pre></td></tr></table></figure><p>实现嵌套接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;骨头&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;汪汪汪~~~&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a animal =  Dog&#123;&#125;<br>a.say()<br>a.eat()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="空接口">6. 空接口</h3><p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。</p><p>空接口类型的变量可以存储任意类型的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 定义一个空接口</span><br><span class="hljs-keyword">var</span> object <span class="hljs-keyword">interface</span>&#123;&#125;<br><br>object = <span class="hljs-string">&quot;Hello world&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;type:%T   value:%v\n&quot;</span>, object, object)<br><span class="hljs-comment">//type:string   value:Hello world</span><br><br>object = <span class="hljs-number">100</span><br>fmt.Printf(<span class="hljs-string">&quot;type:%T   value:%v\n&quot;</span>, object, object)<br><span class="hljs-comment">// type:int   value:100</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>空接口的应用</strong></p><ol type="1"><li>空接口作为函数的参数</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 空接口作为函数参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sout</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;type:%T value:%v\n&quot;</span>, a, a)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>空接口作为map的值</li></ol><p>使用空接口实现可以保存任意值的字典。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> studentInfo = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br>studentInfo[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;张三&quot;</span><br>studentInfo[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">18</span><br>studentInfo[<span class="hljs-string">&quot;married&quot;</span>] = <span class="hljs-literal">false</span><br>fmt.Println(studentInfo)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="从空接口获取值">6.1 从空接口获取值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 声明a变量, 类型int, 初始值为1</span><br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span><br><span class="hljs-comment">// 声明i变量, 类型为interface&#123;&#125;, 初始值为a, 此时i的值变为1</span><br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = a<br><span class="hljs-comment">// 声明b变量, 尝试赋值i</span><br><span class="hljs-comment">// var b int = i// cannot use i (type interface &#123;&#125;) as type int in assignment: need type assertion</span><br><br><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int</span> = i.(<span class="hljs-keyword">int</span>)<br>fmt.Println(b)<span class="hljs-comment">// 1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>保存到空接口的值，如果直接取出指定类型的值时，会发生编译错误。</p><h4 id="空接口的值比较">6.2 空接口的值比较</h4><p>空接口在保存不同的值后，可以和其他变量值一样使用==进行比较操作。空接口的比较有以下几种特性。</p><ol type="1"><li>类型不同的空接口间的比较结果不相同保存有类型不同的值的空接口进行比较时，Go语言会优先比较值的类型。因此类型不同，比较结果也是不相同的。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// a保存整型</span><br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-number">100</span><br><span class="hljs-comment">// b保存字符串</span><br><span class="hljs-keyword">var</span> b <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-string">&quot;hi&quot;</span><br><span class="hljs-comment">// 两个空接口不相等</span><br>fmt.Println(a == b) <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>不能比较空接口中的动态值当接口中保存有动态类型的值时，运行时将触发错误。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// c保存包含10的整型切片</span><br><span class="hljs-keyword">var</span> c <span class="hljs-keyword">interface</span>&#123;&#125; = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">10</span>&#125;<br><span class="hljs-comment">// d保存包含20的整型切片</span><br><span class="hljs-keyword">var</span> d <span class="hljs-keyword">interface</span>&#123;&#125; = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">20</span>&#125;<br><span class="hljs-comment">// 这里会发生崩溃</span><br>fmt.Println(c == d)<span class="hljs-comment">// panic: runtime error: comparing uncomparable type []int</span><br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220109122840.png" /></p><h3 id="类型断言">7. 类型断言</h3><p>类型断言（TypeAssertion）是一个使用在接口值上的操作，用于检查接口类型变量所持有的值是否实现了期望的接口或者具体的类型。</p><p>类型断言的语法格式如下： &gt; value, ok := x.(T)</p><p>其中，x 表示一个接口类型的变量，T表示一个具体的类型（也可为接口类型）。</p><p>该断言表达式会返回 x 的值（也就是 value）和一个布尔值（也就是ok），可根据该布尔值判断 x 是否为 T 类型： + 如果 T是具体某个类型，类型断言会检查 x 的动态类型是否等于具体类型T。如果检查成功，类型断言返回的结果是 x 的动态值，其类型是 T。 + 如果 T是接口类型，类型断言会检查 x 的动态类型是否满足 T。如果检查成功，x的动态值不会被提取，返回值是一个类型为 T 的接口值。 + 无论 T是什么类型，如果 x 是 nil 接口值，类型断言都会失败。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span>&#123;<br>name <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span>&#123;&#125;<br><br>x = <span class="hljs-number">10</span><br>value, ok := x.(<span class="hljs-keyword">int</span>)<br>fmt.Print(value, <span class="hljs-string">&quot;,&quot;</span>, ok,<span class="hljs-string">&quot;\n&quot;</span>)<br><span class="hljs-comment">// 10,true</span><br><br>x = Dog&#123;<span class="hljs-string">&quot;旺财&quot;</span>&#125;<br>v, b := x.(animal)<br>fmt.Print(v, <span class="hljs-string">&quot;,&quot;</span>, b)<br><span class="hljs-comment">// &#123;花花&#125;,true</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果不接收第二个参数，断言失败时会直接造成一个 panic。如果 x 为 nil同样也会 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span>&#123;&#125;<br><br>x = <span class="hljs-number">10</span><br>value := x.(<span class="hljs-keyword">int</span>)<br>fmt.Print(value, <span class="hljs-string">&quot;\n&quot;</span>) <span class="hljs-comment">// 10</span><br><br>x = <span class="hljs-number">10</span><br>v := x.(<span class="hljs-keyword">string</span>) <span class="hljs-comment">// panic: interface conversion: interface &#123;&#125; is int, not string</span><br>fmt.Print(v, <span class="hljs-string">&quot;\n&quot;</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>类型断言还可以配合 switch 使用：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span><br>a = <span class="hljs-number">10</span><br>getType(a)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getType</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">switch</span> a.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span>:<br>fmt.Println(<span class="hljs-string">&quot;the type of a is int&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">string</span>:<br>fmt.Println(<span class="hljs-string">&quot;the type of a is string&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">float64</span>:<br>fmt.Println(<span class="hljs-string">&quot;the type of a is float&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;unknown type&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="接口和类型之间的转换">8. 接口和类型之间的转换</h3><h4 id="将接口转换为其他接口">8.1 将接口转换为其他接口</h4><p>实现某个接口的类型同时实现了另外一个接口，此时可以在两个接口间转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Sayer <span class="hljs-keyword">interface</span> &#123;<br>say()<br>&#125;<br><br><span class="hljs-keyword">type</span> Eater <span class="hljs-keyword">interface</span> &#123;<br>eat()<br>&#125;<br><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;骨头&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;汪汪汪~~~&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> eat Eater = Dog&#123;<span class="hljs-string">&quot;小黄&quot;</span>&#125;<br>say := eat.(Sayer)<br><br>fmt.Println(say)<br><span class="hljs-comment">// &#123;小黄&#125;</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="将接口转换为其他类型">8.2 将接口转换为其他类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> dog *Dog = <span class="hljs-built_in">new</span>(Dog)<br><span class="hljs-keyword">var</span> eat Eater = dog<br><br><span class="hljs-comment">// d := eat.(Dog)</span><br><span class="hljs-comment">// panic: interface conversion: main.Eater is *main.Dog, not main.Dog</span><br>d := eat.(*Dog)<br>fmt.Println(d)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果接口内保存的实例对应的类型指针，必须是要转换的对应的类型指针。</p><h3 id="error-接口">9. error 接口</h3><p>Go语言中返回的 error 类型接口类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> error <span class="hljs-keyword">interface</span> &#123;<br>Error() <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>自定义错误类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyError <span class="hljs-keyword">struct</span> &#123;<br>code     <span class="hljs-keyword">int</span><br>msg <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(err MyError)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;error code：%v，error message :%v&quot;</span>, err.code,err.msg)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getUser</span><span class="hljs-params">(id <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span> &#123;<br><span class="hljs-keyword">if</span> id == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, MyError&#123;<span class="hljs-number">400</span>, <span class="hljs-string">&quot;user id is illegal&quot;</span>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;....&#125;&quot;</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>result, err := getUser(<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-comment">// error code：400，error message :user id is illegal</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(result)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——结构体</title>
    <link href="/2022/01/02/Go%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2022/01/02/Go%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<p>Golang 面向对象编程非常简洁，去掉了传统 OOP语言的方法重载、构造函数和析构函数、隐藏的this指针等等</p><h3 id="结构体">1. 结构体</h3><h4 id="结构体的定义">1.1 结构体的定义</h4><p>使用type和struct关键字来定义结构体，具体代码格式如下：</p><blockquote><p>type　类型名　struct { 　字段名　字段类型 　字段名　字段类型 　…}</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-keyword">string</span><br>Name <span class="hljs-keyword">string</span><br>Age  <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">// 同样类型的字段也可以写在一行</span><br><span class="hljs-keyword">type</span> Student1 <span class="hljs-keyword">struct</span> &#123;<br>ID, Name <span class="hljs-keyword">string</span><br>Age      <span class="hljs-keyword">int</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="实例化与初始化">1.2 实例化与初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// 方法一</span><br><span class="hljs-keyword">var</span> stu Student<br>fmt.Println(stu)<br><span class="hljs-comment">// &#123;  0&#125;</span><br>stu.ID = <span class="hljs-string">&quot;0001&quot;</span><br>stu.Name = <span class="hljs-string">&quot;张三&quot;</span><br>stu.Age = <span class="hljs-number">18</span><br>fmt.Println(stu)<br><span class="hljs-comment">// &#123;0001 张涛 18&#125;</span><br><br><span class="hljs-comment">// 方法二</span><br><span class="hljs-comment">//var stu1 Student = Student&#123;&#125;</span><br><span class="hljs-keyword">var</span> stu1 Student = Student&#123;<span class="hljs-string">&quot;0002&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>&#125;<br>fmt.Println(stu1)<br><span class="hljs-comment">// &#123;0002 李四 19&#125;</span><br><br><span class="hljs-comment">// 方法三</span><br><span class="hljs-keyword">var</span> stu2 *Student = <span class="hljs-built_in">new</span>(Student)<br>(*stu2).ID = <span class="hljs-string">&quot;0003&quot;</span><br>(*stu2).Name = <span class="hljs-string">&quot;李四&quot;</span><br><span class="hljs-comment">// 编译器进行自动转换</span><br>stu2.Age = <span class="hljs-number">20</span><br>fmt.Println(*stu2)<br><span class="hljs-comment">// &#123;0003 李四 20&#125;</span><br><br><span class="hljs-comment">// 方法四</span><br><span class="hljs-comment">//var stu3 *Student = &amp;Student&#123;&#125;</span><br>stu3 := &amp;Student&#123;<span class="hljs-string">&quot;0004&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">19</span>&#125;<br>fmt.Println(*stu3)<br><br><span class="hljs-comment">// 初始化方式</span><br>stu4 := &amp;Student&#123;Name: <span class="hljs-string">&quot;王五&quot;</span>, ID: <span class="hljs-string">&quot;00005&quot;</span>, Age: <span class="hljs-number">19</span>&#125;<br>fmt.Println(*stu4)<br><br>stu5 := &amp;Student&#123;Name: <span class="hljs-string">&quot;王五&quot;</span>&#125;<br>fmt.Println(*stu5)<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="匿名结构体">1.3 匿名结构体</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> user <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-keyword">string</span><br>age  <span class="hljs-keyword">int</span><br>&#125;<br>user.Name = <span class="hljs-string">&quot;张三&quot;</span><br>user.age = <span class="hljs-number">19</span><br>fmt.Println(user)<br></code></pre></td></tr></table></figure><h4 id="结构体的匿名字段">1.4 结构体的匿名字段</h4><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-keyword">string</span><br><span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p1 := Person&#123;<br><span class="hljs-string">&quot;张三&quot;</span>,<br><span class="hljs-number">18</span>,<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, p1)<span class="hljs-comment">// &#123;string:张三 int:18&#125;</span><br>fmt.Println(p1.<span class="hljs-keyword">string</span>, p1.<span class="hljs-keyword">int</span>) <span class="hljs-comment">//张三 18</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><h4 id="嵌套结构体">1.5 嵌套结构体</h4><p>一个结构体中可以嵌套包含另一个结构体或结构体指针。当访问结构体成员时会先在结构体中查找该字段，找不到再去嵌套的匿名字段中查找。嵌套结构体内部可能存在相同的字段名。在这种情况下为了避免歧义需要通过指定具体的内嵌结构体字段名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Address 地址结构体</span><br><span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> &#123;<br>Province <span class="hljs-keyword">string</span><br>City     <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">// User 嵌套结构体</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Name    <span class="hljs-keyword">string</span><br>Gender  <span class="hljs-keyword">string</span><br>Address Address<br>&#125;<br><br><span class="hljs-comment">// User1 嵌套匿名字段</span><br><span class="hljs-keyword">type</span> User1 <span class="hljs-keyword">struct</span> &#123;<br>Name   <span class="hljs-keyword">string</span><br>Gender <span class="hljs-keyword">string</span><br>Address<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>u1 := User&#123;<br>Name:   <span class="hljs-string">&quot;张三&quot;</span>,<br>Gender: <span class="hljs-string">&quot;男&quot;</span>,<br>Address: Address&#123;<br>Province: <span class="hljs-string">&quot;陕西&quot;</span>,<br>City:     <span class="hljs-string">&quot;西安&quot;</span>,<br>&#125;,<br>&#125;<br><br><span class="hljs-keyword">var</span> u2 User1<br>u2.Name = <span class="hljs-string">&quot;李四&quot;</span><br>u2.Gender = <span class="hljs-string">&quot;男&quot;</span><br>u2.Address.Province = <span class="hljs-string">&quot;甘肃&quot;</span> <span class="hljs-comment">// 匿名字段默认使用类型名作为字段名</span><br>u2.City = <span class="hljs-string">&quot;天水&quot;</span>             <span class="hljs-comment">// 匿名字段可以省略</span><br><br>fmt.Printf(<span class="hljs-string">&quot;user1=%+v\n&quot;</span>, u1)<br>fmt.Printf(<span class="hljs-string">&quot;user1=%+v\n&quot;</span>, u2)<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结构体之间的转换">1.6 结构体之间的转换</h4><ol type="1"><li>结构体是用户单独定义的类型，和其它类型进行转换时需要有完全相同的字段(名字、个数和类型)</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Age <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Age <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> p Person = Person&#123;<span class="hljs-number">10</span>&#125;<br><span class="hljs-keyword">var</span> s Student<br>s = Student(p)<br>fmt.Println(s)<br><span class="hljs-comment">// &#123;10&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>结构体进行 typ e重新定义(相当于取别名)，Golang认为是新的数据类型，但是相互间可以强转</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Age <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-keyword">type</span> Stu Student<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> s1 Student = Student&#123;<span class="hljs-number">19</span>&#125;<br><span class="hljs-keyword">var</span> s2 Stu<br>s2 = Stu(s1)<br>fmt.Println(s2)<br><span class="hljs-comment">// &#123;19&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构体的继承">2. 结构体的“继承”</h3><h4 id="方法和接收者">2.1 方法和接收者</h4><p>Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的this 或者 self。</p><p>定义格式如下：</p><blockquote><p>func　(接收者变量 接收者类型)　方法名(参数列表)　(返回参数) {　　函数体 }</p></blockquote><ul><li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Person 结构体</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>age  <span class="hljs-keyword">int8</span><br>&#125;<br><br><span class="hljs-comment">//NewPerson 构造函数（Go语言的结构体没有构造函数）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPerson</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, age <span class="hljs-keyword">int8</span>)</span> *<span class="hljs-title">Person</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;Person&#123;<br>name: name,<br>age:  age,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//Eat Person做梦的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span> <span class="hljs-title">Eat</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;干啥啥不行，吃饭第一名&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// SetAge 实现 setter</span><br><span class="hljs-comment">// 使用指针接收者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span> <span class="hljs-title">SetAge</span><span class="hljs-params">(newAge <span class="hljs-keyword">int8</span>)</span></span> &#123;<br>p.age = newAge<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p1 := NewPerson(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">25</span>)<br>p1.SetAge(<span class="hljs-number">18</span>)<br>fmt.Println(*p1)<span class="hljs-comment">// &#123;张三 18&#125;</span><br>p1.Eat()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="结构体的-继承">2.2 结构体的 “继承”</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Animal 动物</span><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Animal)</span> <span class="hljs-title">move</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s会动！\n&quot;</span>, a.name)<br>&#125;<br><br><span class="hljs-comment">//Dog 狗</span><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>Feet    <span class="hljs-keyword">int8</span><br>*Animal <span class="hljs-comment">//通过嵌套匿名结构体实现继承</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dog)</span> <span class="hljs-title">wang</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>d1 := &amp;Dog&#123;<br>Feet: <span class="hljs-number">4</span>,<br>Animal: &amp;Animal&#123;<br>name: <span class="hljs-string">&quot;小黄&quot;</span>,<br>&#125;,<br>&#125;<br>d1.wang() <span class="hljs-comment">// 小黄会汪汪汪~</span><br>d1.move() <span class="hljs-comment">// 小黄会动！</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="结构体与json序列化">3. 结构体与JSON序列化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Student 学生</span><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>ID     <span class="hljs-keyword">int</span><br>Gender <span class="hljs-keyword">string</span><br>Name   <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">//Class 班级</span><br><span class="hljs-keyword">type</span> Class <span class="hljs-keyword">struct</span> &#123;<br>Title    <span class="hljs-keyword">string</span><br>Students []*Student<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := &amp;Class&#123;<br>Title:    <span class="hljs-string">&quot;101&quot;</span>,<br>Students: <span class="hljs-built_in">make</span>([]*Student, <span class="hljs-number">2</span>),<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;<br>stu := &amp;Student&#123;<br>Name:   fmt.Sprintf(<span class="hljs-string">&quot;stu%02d&quot;</span>, i),<br>Gender: <span class="hljs-string">&quot;男&quot;</span>,<br>ID:     i,<br>&#125;<br>c.Students = <span class="hljs-built_in">append</span>(c.Students, stu)<br>&#125;<br><br><span class="hljs-comment">//JSON序列化：结构体--&gt;JSON格式的字符串</span><br>data, err := json.Marshal(c)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;json marshal failed&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;json:%s\n&quot;</span>, data)<br><br><span class="hljs-comment">//JSON反序列化：JSON格式的字符串--&gt;结构体</span><br>str := <span class="hljs-string">`&#123;&quot;Title&quot;:&quot;101&quot;,&quot;Students&quot;:[&#123;&quot;ID&quot;:0,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu00&quot;&#125;,&#123;&quot;ID&quot;:1,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu01&quot;&#125;,&#123;&quot;ID&quot;:2,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu02&quot;&#125;]&#125;`</span><br>c1 := &amp;Class&#123;&#125;<br>err = json.Unmarshal([]<span class="hljs-keyword">byte</span>(str), c1)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;json unmarshal failed!&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, *c1)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="结构体标签">4. 结构体标签</h3><p>Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 Tag在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：</p><blockquote><p>`key1:"value1　"key2:"value2" `</p></blockquote><p>结构体 tag由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>ID     <span class="hljs-keyword">int</span>    <span class="hljs-string">`json:&quot;id&quot;`</span> <span class="hljs-comment">// 通过指定 tag 实现 json 序列化该字段时的 key</span><br>Gender <span class="hljs-keyword">string</span> <span class="hljs-comment">// json 序列化是默认使用字段名作为 key</span><br>name   <span class="hljs-keyword">string</span> <span class="hljs-comment">// 私有不能被 json 包访问</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := Student&#123;<br>ID:     <span class="hljs-number">1</span>,<br>Gender: <span class="hljs-string">&quot;男&quot;</span>,<br>name:   <span class="hljs-string">&quot;张三&quot;</span>,<br>&#125;<br>data, err := json.Marshal(s1)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;json marshal failed!&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, data) <span class="hljs-comment">// &#123;&quot;id&quot;:1,&quot;Gender&quot;:&quot;男&quot;&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——Map</title>
    <link href="/2022/01/02/Go%E2%80%94%E2%80%94Map/"/>
    <url>/2022/01/02/Go%E2%80%94%E2%80%94Map/</url>
    
    <content type="html"><![CDATA[<h3 id="定义-map">1. 定义 Map</h3><blockquote><p>var　map_variable　map[key_data_type]　value_data_type</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> student <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span><br></code></pre></td></tr></table></figure><ul><li>key、value的类型：bool、数字、string、指针、channel、还可以是只包含前面几个类型的接口、结构体、数组</li><li>key 通常为 int 、string 类型，value通常为数字（整数、浮点数）、string、map、结构体</li><li>key：slice、map、function 不可以</li><li>map 只申明不会进行内存分配</li><li>map 的 key-value 是无序的</li><li>key 是不可以重复的</li><li>value 可以重复</li></ul><h3 id="初始化">2. 初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> student <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span><br><span class="hljs-comment">// 第一种</span><br>student = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>, <span class="hljs-number">10</span>)<br>student[<span class="hljs-number">00001</span>] = <span class="hljs-string">&quot;张三&quot;</span><br><br><span class="hljs-comment">// 第二种</span><br>stu := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>)<br>stu[<span class="hljs-number">00002</span>] = <span class="hljs-string">&quot;李四&quot;</span><br><br><span class="hljs-comment">// 第三种</span><br>stud := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>&#123;<br><span class="hljs-number">00003</span>: <span class="hljs-string">&quot;王五&quot;</span>,<br><span class="hljs-number">00004</span>: <span class="hljs-string">&quot;赵六&quot;</span>,<br>&#125;<br><br>fmt.Println(stud)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="操作">3. 操作</h3><ol type="1"><li><p>增加、更新操作 map["key"] = value 如果 key 不存在，进行新增，如果key 存则覆盖。</p></li><li><p>删除操作 delete(map，"key") 如果 key 存在，就删除该key-value，如果 key 不存在，不操作也不会报错。</p></li><li><p>清空操作 （1）可以遍历key，逐个删除 （2）或者map =make(...)，make一个新的，让原来的成为垃圾，被gc回收</p></li><li><p>查找操作 value ,bool = map[key] value 为返回的 value，bool为是否返回</p></li><li><p>获取长度：len函数</p></li><li><p>遍历：for-range</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>student := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>)<br><br>student[<span class="hljs-number">00001</span>] = <span class="hljs-string">&quot;张三&quot;</span><br>student[<span class="hljs-number">00001</span>] = <span class="hljs-string">&quot;李四&quot;</span><br>student[<span class="hljs-number">00002</span>] = <span class="hljs-string">&quot;王五&quot;</span><br>fmt.Println(student)<br><span class="hljs-comment">// map[1:李四 2:王五]</span><br><br><span class="hljs-comment">// 查找</span><br>s := student[<span class="hljs-number">0001</span>]<br>fmt.Println(s) <span class="hljs-comment">// 李四</span><br>s2, b := student[<span class="hljs-number">0004</span>]<br>fmt.Println(s2, b) <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">for</span> i, s3 := <span class="hljs-keyword">range</span> student &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v --- %v \n&quot;</span>, i, s3)<br>&#125;<br><br><span class="hljs-comment">// 删除</span><br><span class="hljs-built_in">delete</span>(student, <span class="hljs-number">001</span>)<br><span class="hljs-built_in">delete</span>(student, <span class="hljs-number">003</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(student)) <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 清空</span><br>student = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(student)) <span class="hljs-comment">// 0</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="比较">4. 比较</h3><p>map 之间也不能进行相等比较；唯一的例外是和nil进行比较。要判断两个 map是否包含相同的 key 和 value，我们必须通过一个循环实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">equal</span><span class="hljs-params">(x, y <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(x) != <span class="hljs-built_in">len</span>(y) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">for</span> k, xv := <span class="hljs-keyword">range</span> x &#123;<br><span class="hljs-keyword">if</span> yv, ok := y[k]; !ok || yv != xv &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——切片</title>
    <link href="/2022/01/02/Go%E2%80%94%E2%80%94%E5%88%87%E7%89%87/"/>
    <url>/2022/01/02/Go%E2%80%94%E2%80%94%E5%88%87%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>切片（slice）是对数组的一个连续片段的引用，所以切片是一个引用类型，这个片段可以是整个数组，也可以是由起始和终止索引标识的一些项的子集，需要注意的是，终止索引标识的项不包括在切片内。</p><p>一个 slice 由三个部分构成：指针、长度和容量。指针指向第一个 slice元素对应的底层数组元素的地址，要注意的是 slice的第一个元素并不一定就是数组的第一个元素。</p><h3 id="切片的定义">1. 切片的定义</h3><ol type="1"><li><p>从数组或切片生成新的切片</p><p>语法：slice [开始位置 : 结束位置] &gt;从数组或切片生成新的切片拥有如下特性： &gt; + 取出的元素数量为：结束位置- 开始位置； &gt; +取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)]获取； &gt; + 当缺省开始位置时，表示从连续区域开头到结束位置； &gt; +当缺省结束位置时，表示从开始位置到整个连续区域末尾； &gt; +两者同时缺省时，与切片本身等效； &gt; + 两者同时为 0时，等效于空切片，一般用于切片复位。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">/* 数组长度为 5 */</span><br><span class="hljs-keyword">var</span>  array = [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span> &#123;<span class="hljs-number">1000</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">17</span>, <span class="hljs-number">50</span>&#125;<br><br>slice := array[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]<br><span class="hljs-comment">// [1000 2 3 17]</span><br>slice2 := slice[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]<br><span class="hljs-comment">// [1000 2 3]</span><br><br>fmt.Printf(<span class="hljs-string">&quot;%T&quot;</span>,slice)<br><span class="hljs-comment">// []int</span><br>fmt.Printf(<span class="hljs-string">&quot;%v,%v&quot;</span>,<span class="hljs-built_in">len</span>(slice2),<span class="hljs-built_in">cap</span>(slice2))<br><span class="hljs-comment">// 3,5</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用 make() 函数构造切片</p></li></ol><blockquote><p>语法：make( []Type, size, cap )</p></blockquote><p>make 底层创建一个数组，对外不可见</p><p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br>fmt.Println(slice)<br><span class="hljs-comment">//[0 0 0 0 0]</span><br><br>fmt.Printf(<span class="hljs-string">&quot;长度：%v，容量：%v&quot;</span>, <span class="hljs-built_in">len</span>(slice), <span class="hljs-built_in">cap</span>(slice))<br><span class="hljs-comment">// 长度：5，容量：10</span><br>&#125;<br></code></pre></td></tr></table></figure></p><ol start="3" type="1"><li>直接声明新的切片</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>slice := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">23</span>, <span class="hljs-number">45</span>, <span class="hljs-number">67</span>&#125;<br>fmt.Println(slice)<br><span class="hljs-comment">//[23 45 67]</span><br><br>fmt.Printf(<span class="hljs-string">&quot;长度：%v，容量：%v&quot;</span>, <span class="hljs-built_in">len</span>(slice), <span class="hljs-built_in">cap</span>(slice))<br><span class="hljs-comment">// 长度：3，容量：3</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="切片的遍历">2. 切片的遍历</h3><p>方式1：for循环常规方式遍历 方式2：for-range 结构遍历切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>slice := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">23</span>, <span class="hljs-number">45</span>, <span class="hljs-number">67</span>&#125;<br><br><span class="hljs-comment">//方式1：普通for循环</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(slice); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;slice[%v] = %v \t&quot;</span>, i, slice[i])<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;\n------------------------------&quot;</span>)<br><span class="hljs-comment">//方式2：for-range循环：</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> slice &#123;<br>fmt.Printf(<span class="hljs-string">&quot;下标：%v ，元素：%v\n&quot;</span>, i, v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="切片的操作">3. 切片的操作</h3><h4 id="添加元素">3.1 添加元素</h4><p>用 append()函数为切片动态添加元素时，如果空间不足，切片就会进行“扩容”。切片在扩容时，容量的扩展规律是按容量的2 倍数进行扩充。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a []<span class="hljs-keyword">int</span><br>a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">1</span>)                 <span class="hljs-comment">// 追加1个元素</span><br>a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)           <span class="hljs-comment">// 追加多个元素, 手写解包方式</span><br>a = <span class="hljs-built_in">append</span>(a, []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;...) <span class="hljs-comment">// 追加一个切片, 切片需要解包</span><br><br>fmt.Println(a)<br><span class="hljs-comment">// [1 1 2 3 1 2 3]</span><br><br><span class="hljs-keyword">var</span> b = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>b = <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>&#125;, b...)          <span class="hljs-comment">// 在开头添加1个元素</span><br>b = <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">-3</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>&#125;, b...) <span class="hljs-comment">// 在开头添加1个切片</span><br>fmt.Println(b)<br><span class="hljs-comment">// [-3 -2 -1 0 1 2 3]</span><br><br><span class="hljs-keyword">var</span> c []<span class="hljs-keyword">int</span> = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>c = <span class="hljs-built_in">append</span>(c[:<span class="hljs-number">1</span>], <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">100</span>&#125;, c[<span class="hljs-number">1</span>:]...)...)     <span class="hljs-comment">// 在第i个位置插入x</span><br>c = <span class="hljs-built_in">append</span>(c[:<span class="hljs-number">2</span>], <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, c[<span class="hljs-number">2</span>:]...)...) <span class="hljs-comment">// 在第i个位置插入切片</span><br>fmt.Println(c)<br><span class="hljs-comment">// [1 100 0 0 0 2 3]</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>在切片开头添加元素一般都会导致内存的重新分配，而且会导致已有元素全部被复制1次，因此，从切片的开头添加元素的性能要比从尾部追加元素的性能差很多。</p><h4 id="切片复制">3.2 切片复制</h4><blockquote><p>语法：copy( destSlice, srcSlice []T) int 将 srcSlice 复制到destSlice</p></blockquote><p>copy()可以将一个数组切片复制到另一个数组切片中，如果加入的两个数组切片不一样大，就会按照其中较小的那个数组切片的元素个数进行复制。</p><p>来源和目标的类型必须一致，copy()函数的返回值表示实际发生复制的元素个数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice1 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>slice2 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-built_in">copy</span>(slice2, slice1) <span class="hljs-comment">// 只会复制slice1的前3个元素到slice2中</span><br>fmt.Println(slice2)<br><span class="hljs-comment">// [1 2 3]</span><br><br><span class="hljs-built_in">copy</span>(slice1, slice2) <span class="hljs-comment">// 只会复制slice2的3个元素到slice1的前3个位置</span><br>fmt.Println(slice1)<br><span class="hljs-comment">// [1 2 3 4 5]</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="删除元素">3.3 删除元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br>a = a[<span class="hljs-number">2</span>:] <span class="hljs-comment">// 删除开头N个元素</span><br>a = <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">0</span>], a[<span class="hljs-number">3</span>:]...) <span class="hljs-comment">// 删除开头N个元素</span><br><br>fmt.Println(a)<br><span class="hljs-comment">// [6 7 8 9]</span><br><br>a = <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">1</span>], a[<span class="hljs-number">1</span>+<span class="hljs-number">1</span>:]...) <span class="hljs-comment">// 删除中间N个元素</span><br><br>a = a[:<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-2</span>] <span class="hljs-comment">// 删除尾部N个元素</span><br><br>fmt.Println(a)<br><span class="hljs-comment">// [6]</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——数组</title>
    <link href="/2022/01/01/Go%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/01/Go%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="数组的申明">1. 数组的申明</h3><blockquote><p>var　variable_name　[SIZE]variable_type</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> scores [<span class="hljs-number">5</span>]<span class="hljs-keyword">int16</span><br><br>fmt.Println(scores)         <span class="hljs-comment">// [0 0 0 0 0]</span><br>fmt.Println(<span class="hljs-built_in">len</span>(scores))    <span class="hljs-comment">// 5</span><br>fmt.Printf(<span class="hljs-string">&quot;%T \n&quot;</span>, scores) <span class="hljs-comment">// [5]int16</span><br><br>fmt.Printf(<span class="hljs-string">&quot;数组的地址：%p \n&quot;</span>, &amp;scores) <span class="hljs-comment">// 0xc0000ac070</span><br><span class="hljs-comment">//第一个空间的地址：</span><br>fmt.Printf(<span class="hljs-string">&quot;第一个元素地址：%p \n&quot;</span>, &amp;scores[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 0xc0000ac070</span><br><span class="hljs-comment">//第二个空间的地址：</span><br>fmt.Printf(<span class="hljs-string">&quot;第二个元素地址：%p \n&quot;</span>, &amp;scores[<span class="hljs-number">1</span>]) <span class="hljs-comment">// 0xc0000ac072</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>【注】 1.数组的地址即第一个元素的地址，数组每个元素占用的字节数取决于数组类型。2. 长度属于类型的一部分 3. Go中数组属值类型，在默认情况下是值传递，因此会进行值拷贝。</p><h3 id="数组的初始化">2. 数组的初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//第一种：</span><br><span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span> = [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>&#125;<br>fmt.Println(arr1)<br><span class="hljs-comment">//第二种：</span><br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>&#125;<br>fmt.Println(arr2)<br><span class="hljs-comment">//第三种：</span><br><span class="hljs-keyword">var</span> arr3 = [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;<br>fmt.Println(arr3)<br><span class="hljs-comment">//第四种：</span><br><span class="hljs-keyword">var</span> arr4 = [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">2</span>: <span class="hljs-number">66</span>, <span class="hljs-number">0</span>: <span class="hljs-number">33</span>, <span class="hljs-number">1</span>: <span class="hljs-number">99</span>, <span class="hljs-number">3</span>: <span class="hljs-number">88</span>&#125;<br>fmt.Println(arr4)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="数组的遍历">3. 数组的遍历</h3><ol type="1"><li>for 循环</li><li>for range</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> scores [<span class="hljs-number">5</span>]<span class="hljs-keyword">int16</span> = [<span class="hljs-number">5</span>]<span class="hljs-keyword">int16</span>&#123;<span class="hljs-number">56</span>, <span class="hljs-number">34</span>, <span class="hljs-number">78</span>, <span class="hljs-number">94</span>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(scores); i++ &#123;<br>fmt.Println(scores[i])<br>&#125;<br><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> scores &#123;<br>fmt.Println(v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="二维数组">4. 二维数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> array1 [<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]<span class="hljs-keyword">int16</span> = [<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]<span class="hljs-keyword">int16</span>&#123;&#123;<span class="hljs-number">32</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">32</span>&#125;&#125;<br>fmt.Println(array1)<br><br><span class="hljs-keyword">var</span> array [<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]<span class="hljs-keyword">int16</span><br><span class="hljs-comment">// 赋值</span><br>array[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">32</span><br>array[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">32</span><br>fmt.Println(array)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(array); i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(array[i]); j++ &#123;<br>fmt.Print(array[i][j], <span class="hljs-string">&quot;\t&quot;</span>)<br>&#125;<br>fmt.Println()<br>&#125;<br><br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> array &#123;<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> value &#123;<br>fmt.Printf(<span class="hljs-string">&quot;arr[%v][%v]=%v\t&quot;</span>, key, k, v)<br>&#125;<br>fmt.Println()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="向函数传递数组">5. 向函数传递数组</h3><p>void myFunction(param [10]int){} void myFunction(param []int)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">/* 数组长度为 5 */</span><br><span class="hljs-keyword">var</span>  balance = []<span class="hljs-keyword">int</span> &#123;<span class="hljs-number">1000</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">17</span>, <span class="hljs-number">50</span>&#125;<br><span class="hljs-keyword">var</span> avg <span class="hljs-keyword">float32</span><br><br>avg = getAverage( balance, <span class="hljs-number">5</span> )<br>fmt.Printf( <span class="hljs-string">&quot;平均值为: %f &quot;</span>, avg )<br><br><span class="hljs-keyword">var</span>  balance2 = [<span class="hljs-number">6</span>]<span class="hljs-keyword">int</span> &#123;<span class="hljs-number">1000</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">17</span>, <span class="hljs-number">50</span>&#125;<br>avg = getAverage2( balance2)<br>fmt.Printf( <span class="hljs-string">&quot;平均值为: %f &quot;</span>, avg )<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getAverage</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, size <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">float32</span></span> &#123;<br><span class="hljs-keyword">var</span> i,sum <span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> avg <span class="hljs-keyword">float32</span><br><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; i &lt; size;i++ &#123;<br>sum += arr[i]<br>&#125;<br>avg = <span class="hljs-keyword">float32</span>(sum) / <span class="hljs-keyword">float32</span>(size)<br><span class="hljs-keyword">return</span> avg<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getAverage2</span><span class="hljs-params">(arr [6]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">float32</span></span> &#123;<br><span class="hljs-keyword">var</span> i,sum <span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> avg <span class="hljs-keyword">float32</span><br><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr);i++ &#123;<br>sum += arr[i]<br>&#125;<br>avg = <span class="hljs-keyword">float32</span>(sum) / <span class="hljs-keyword">float32</span>(<span class="hljs-built_in">len</span>(arr))<br><span class="hljs-keyword">return</span> avg<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——异常处理</title>
    <link href="/2021/12/30/Go%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2021/12/30/Go%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="deferrecover-机制处理错误">1. defer+recover 机制处理错误</h3><blockquote><p>func recover() interface{}</p></blockquote><p>内建函数 recover 允许程序管理恐慌过程中的 Go 程。在 defer的函数中，执行 recover 调用会取回传至 panic调用的错误值，恢复正常执行，停止恐慌过程。若 recover 在 defer的函数之外被调用，它将不会停止恐慌过程序列。在此情况下，或当该 Go程不在恐慌过程中时，或提供给 panic 的实参为 nil 时，recover就会返回nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>result := division(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)<br>fmt.Println(result)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">division</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>err := <span class="hljs-built_in">recover</span>()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;捕获到异常:&quot;</span>, err)<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">return</span> num1 / num2<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211230233446.png" /></p><h3 id="自定义错误">2. 自定义错误</h3><p>调用 errors 包下的 New 函数，函数返回 error 类型。</p><blockquote><p>func New(text string) error</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>result, err := division(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><br>fmt.Println(result)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">division</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;<br><br><span class="hljs-keyword">if</span> num2 == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;integer divide by zero&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> num1 / num2, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211230234230.png" /></p><p>### 3. 出现异常后中断程序</p><blockquote><p>func panic(v interface{})</p></blockquote><p>内建函数 panic 停止当前 Go 程的正常执行。当函数 F 调用 panic 时，F的正常执行就会立刻停止。F 中 defer 的所有函数先入后出执行后，F返回给其调用者 G。G 如同 F 一样行动，层层返回，直到该 Go程中所有函数都按相反的顺序停止执行。之后，程序被终止，而错误情况会被报告，包括引发该恐慌的实参值，此终止序列称为恐慌过程。</p><p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>result, err := division(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(result)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">division</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;<br><br><span class="hljs-keyword">if</span> num2 == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;integer divide by zero&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> num1 / num2, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure> <imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211230234827.png" /></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——函数</title>
    <link href="/2021/12/29/Go%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/"/>
    <url>/2021/12/29/Go%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="函数">1. 函数</h3><p><strong>基本语法：</strong> func 函数名（形参列表) [ 返回值类型列表 ]{ 　　执行语句.. 　　return　返回值列表 }</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span> &#123; <span class="hljs-comment">// 如果返回值类型只有一个，那么()是可以省略不写</span><br><span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br></code></pre></td></tr></table></figure><ol type="1"><li>函数名</li></ol><ul><li>驼峰命名<br /></li><li>首字母不能是数字</li><li>首字母大写该函数可以被本包文件和其它包文件使用</li><li>首学母小写只能被本包文件使用</li></ul><ol start="2" type="1"><li><p>形参列表：形参可以是一个参数，可以是n个参数，可以是0个参数</p></li><li><p>返回值类型列表 如果有多个返回值，用 ()括起来；如果返回值类型只有一个，可以省略()；如果没有返回值，什么都不用写。在函数调用时，如果有返回值不想接收，可以用_ 忽略。</p></li><li><p>值传递和引用传递基本数据类型和数组默认都是值传递的，即进行值拷贝</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> num <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><br>aa(num)<br>fmt.Println(num)<span class="hljs-comment">// 10</span><br>bb(&amp;num)<br>fmt.Println(num)<span class="hljs-comment">// 200</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">aa</span><span class="hljs-params">(int2 <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>int2 = <span class="hljs-number">100</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bb</span><span class="hljs-params">(int2 *<span class="hljs-keyword">int</span>)</span></span>  &#123;<br>*int2 = <span class="hljs-number">200</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="5" type="1"><li><p>Golang 中函数不支持重载</p></li><li><p>支持可变参数 函数内将可变参数当做切片来处理</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>test(<span class="hljs-number">37</span>, <span class="hljs-number">58</span>, <span class="hljs-number">39</span>, <span class="hljs-number">59</span>, <span class="hljs-number">47</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(args ...<span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(args); i++ &#123;<br>fmt.Println(args[i])<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7" type="1"><li>在 Go中函数也是一种数据类型，可以赋值给一个变量，通过该变量可以对函数调用。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(num <span class="hljs-keyword">int</span>)</span></span> &#123;<br>fmt.Println(num)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>a := test<br>fmt.Printf(<span class="hljs-string">&quot;a的类型：%T，test函数的类型：%T \n&quot;</span>, a, test)<br><span class="hljs-comment">// a的类型：func(int)，test函数的类型：func(int)</span><br>a(<span class="hljs-number">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="8" type="1"><li>函数既然是一种数据类型，因此在 Go 中，函数可以作为形参。</li></ol><p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(str <span class="hljs-keyword">string</span>)</span></span> &#123;<br>fmt.Println(str)<br>&#125;<br><br><span class="hljs-comment">//定义一个函数，把另一个函数作为形参</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test02</span><span class="hljs-params">(testFunc <span class="hljs-keyword">func</span>(string2 <span class="hljs-keyword">string</span>)</span>)</span> &#123;<br>testFunc(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>a := test<br>test02(a)<br>&#125;<br></code></pre></td></tr></table></figure> 9. 为了简化数据类型定义，Go 支持自定义数据类型</p><pre><code class="hljs">基本语法：type　自定义数据类型名　数据类型</code></pre><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">type</span> myInt <span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> num myInt = <span class="hljs-number">100</span><br><br><span class="hljs-comment">// 虽然是别名，但是还是两种不同的类型</span><br><span class="hljs-comment">//var num2 int = num</span><br><br><span class="hljs-keyword">var</span> num2 <span class="hljs-keyword">int</span> = <span class="hljs-keyword">int</span>(num)<br>fmt.Println(num2)<br><br><span class="hljs-keyword">type</span> myFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="10" type="1"><li>支持对函数返回值命名</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;<br>sum := num1 + num2<br>sub := num1 - num2<br><span class="hljs-keyword">return</span> sum, sub<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test2</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(sum <span class="hljs-keyword">int</span>, sub <span class="hljs-keyword">int</span>)</span></span> &#123;<br>sum = num1 + num2<br>sub = num1 - num2<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="包">2. 包</h3><ol type="1"><li><p>package 进行包的声明 建议：包的声明和所在的文件夹同名</p></li><li><p>main 包是程序的入口包 main 函数一定要放在 main包下，否则不能编译执行</p></li><li><p>包的引入 语法：import "包的路径"<br />包名是从 $GOPATH/src/ 后开始的，使用 / 进行路径分隔。 【注：未开启 gomodules 的情况下】</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211230161703.png" /></p></li><li><p>包名和文件夹的名字，可以不一样，建议一致</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211230162839.png" /></p></li><li><p>一个目录下只能声明一个package，所以一个目录下不能有重复的函数</p></li><li><p>可以给包取别名，取别名后，原来的包名就不能使用了</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211230163246.png" /></p></li></ol><p>### 3. init函数</p><p>初始化函数，可以用来进行一些初始化的操作</p><p>每一个源文件都可以包含一个 init 函数，该函数会在 main 函数执行前，被Go 运行框架调用。</p><p>全局变量定义，init 函数，main 函数的执行流程：</p><p>全局变量 --&gt; init 函数 --&gt; main 函数 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> global <span class="hljs-keyword">int</span> = get()<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;get....&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">100</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;init....&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;main......&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure>执行结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211230174442.png" /></p><p>多个源文件都有init函数的时候，如何执行：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211230174547.png" /></p><h4 id="匿名函数">4. 匿名函数</h4><p>匿名函数使用方式：</p><ol type="1"><li>在定义匿名函数时就直接调用，这种方式匿名函数只能调用一次</li></ol><p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>result := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> num1 + num2<br>&#125;(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br><br>fmt.Println(result)<br>&#125;<br></code></pre></td></tr></table></figure> 2.将匿名函数赋给一个变量，再通过该变量来调用匿名函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>add := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br>fmt.Println(add(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="闭包">5. 闭包</h4><p>闭包就是一个函数和与其相关的引用环境组合的一个整体</p><p>闭包的本质：闭包本质依旧是一个匿名函数，只是这个函数引入外界的变量/参数匿名函数 + 引用的变量/参数 = 闭包</p><p>（当一个函数的返回值是另外一个函数，而返回的这个函数如果调用了其父函数内部的变量，且返回的这个函数在外部被执行，就产生了闭包。闭包是一个环境，具体指的就是外部函数--高阶函数。）</p><p>特点： 1.返回的是一个匿名函数，但是这个匿名函数引用到函数外的变量/参数,因此这个匿名函数就和变量/参数形成一个整体，构成闭包。 2.闭包中使用的变量/参数会一直保存在内存中</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getSum</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">var</span> sum <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>sum = sum + num<br><span class="hljs-keyword">return</span> sum<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f := getSum()<br>fmt.Println(f(<span class="hljs-number">1</span>)) <span class="hljs-comment">// 1</span><br>fmt.Println(f(<span class="hljs-number">2</span>)) <span class="hljs-comment">// 3</span><br>fmt.Println(f(<span class="hljs-number">3</span>)) <span class="hljs-comment">// 6</span><br>&#125;<br></code></pre></td></tr></table></figure><p>用处：</p><ol type="1"><li>读取函数内部的变量</li><li>这些变量的值始终保持在内存中，不会在外层函数调用后被自动清除</li></ol><p>优点： 1. 变量长期驻扎在内存中 2. 避免全局变量的污染</p><p>缺点： 1. 常驻内存 会增大内存的使用量</p><h3 id="defer关键字">5. defer关键字</h3><p>defer提供延迟机制，会将要延迟执行的方法“压栈”，当 defer被触发时，将所有“压栈”的方法“出栈”并执行。</p><p>defer 的执行时机： 1. 包裹 defer 的函数返回时 2. 包裹 defer的函数执行到末尾时 3. 所在的 goroutine 发生 panic 时</p><p>【注】调用 os.Exit() 方法退出程序时，不会执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getSum</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;num1：&quot;</span>, num1)<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;num2：&quot;</span>, num2)<br><br>sum := num1 + num2<br>fmt.Println(<span class="hljs-string">&quot;sum：&quot;</span>, sum)<br><br><span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>getSum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="系统函数">6. 系统函数</h3><h4 id="内置函数">6.1 内置函数</h4><p>new 函数： 分配内存，主要用来分配值类型（int系列, float系列, bool,string、数组和结构体 struct）</p><p>func new(Type) *Type其第一个实参为类型，而非值。其返回值为指向该类型的新分配的零值的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>num := <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>)<br>fmt.Printf(<span class="hljs-string">&quot;num 的类型：%T，num 的值：%v，num 的地址：%v， num 指针指向的值: %v&quot;</span>, num, num, &amp;num, *num)<br><span class="hljs-comment">//num 的类型：*int，num 的值：0xc0000a6058，num 的地址：0xc0000d2018， num 指针指向的值: 0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>make函数: func make(Type, size IntegerType) Type</p><p>make分配并初始化一个类型为切片、映射、或通道的对象。其第一个实参为类型，而非值。make的返回类型与其参数相同，而非指向它的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>demo := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>)<br>fmt.Println( demo)<br><span class="hljs-comment">// [0 0 0 0 0 0 0 0 0 0]</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="字符串相关函数">6.1 字符串相关函数</h4><ol type="1"><li><p>字符串转整数 n, err := strconv.Atoi("66")</p></li><li><p>整数转字符串 str := strconv.Itoa(6887)</p></li><li><p>不区分大小写比较字符串是否相同 func EqualFold(s, t string)bool</p></li><li><p>判断 s 是否有前缀字符串 prefix func HasPrefix(s, prefix string)bool</p></li><li><p>判断 s 是否有后缀字符串 suffix func HasSuffix(s, suffix string)bool</p></li><li><p>判断字符串 s 是否包含子串 substr func Contains(s, substr string)bool</p></li><li><p>返回字符串 s 中有几个不重复的 sep 子串 func Count(s, sep string)int</p></li><li><p>子串 sep 在字符串s中第一次出现的位置，不存在则返回-1 funcIndex(s, sep string) int</p></li><li><p>子串 sep 在字符串 s 中最后一次出现的位置，不存在则返回-1 funcLastIndex(s, sep string) int</p></li><li><p>将所有字母都转为对应的小写 func ToLower(s string) string</p></li><li><p>将所有字母都转为对应的大写 func ToUpper(s string) string</p></li><li><p>返回 count 个 s 串联的字符串。 func Repeat(s string, count int)string</p></li><li><p>将 s 中前 n 个不重叠 old 子串都替换为 new 的新字符串 funcReplace(s, old, new string, n int) string</p></li><li><p>将 s 前后端所有 cutset 去掉 func Trim(s string, cutset string)string</p></li><li><p>将 s 前后端所有空白都去掉 func TrimSpace(s string)string</p></li><li><p>用去掉 s 中出现的 sep的方式进行分割，返回生成的所有片段组成的切片 func Split(s, sep string)[]string 每一个 sep 都会进行一次切割，即使两个 sep相邻，也会进行两次切割。</p></li></ol><h4 id="时间相关函数">6.2 时间相关函数</h4><p>时间和日期的函数在 time 包，time.Now() 返回当前时间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>now := time.Now()<br>fmt.Printf(<span class="hljs-string">&quot;%v ~~~ 对应的类型为：%T\n&quot;</span>, now, now)<br><span class="hljs-comment">// 2021-12-30 19:36:01.1827252 +0800 CST m=+0.003000101 ~~~ 对应的类型为：time.Time</span><br><br><span class="hljs-comment">// 当前时间戳</span><br>fmt.Println(now.Unix())<br><span class="hljs-comment">// 纳秒级时间戳</span><br>fmt.Println(now.UnixNano())<br><span class="hljs-comment">// 时间戳小数部分 单位：纳秒</span><br>fmt.Println(now.Nanosecond())<br><br><span class="hljs-comment">//调用结构体中的方法：</span><br>fmt.Printf(<span class="hljs-string">&quot;年：%v \n&quot;</span>, now.Year())<br>fmt.Printf(<span class="hljs-string">&quot;月：%v \n&quot;</span>, now.Month())      <span class="hljs-comment">//月：February</span><br>fmt.Printf(<span class="hljs-string">&quot;月：%v \n&quot;</span>, <span class="hljs-keyword">int</span>(now.Month())) <span class="hljs-comment">//月：2</span><br>fmt.Printf(<span class="hljs-string">&quot;日：%v \n&quot;</span>, now.Day())<br>fmt.Printf(<span class="hljs-string">&quot;时：%v \n&quot;</span>, now.Hour())<br>fmt.Printf(<span class="hljs-string">&quot;分：%v \n&quot;</span>, now.Minute())<br>fmt.Printf(<span class="hljs-string">&quot;秒：%v \n&quot;</span>, now.Second())<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>根据指定时间返回 time.Time</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>now := time.Now()<br>layout := <span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span><br><br><span class="hljs-comment">//根据指定时间返回 time.Time 类型</span><br><span class="hljs-comment">//分别指定年，月，日，时，分，秒，纳秒，时区</span><br>t := time.Date(<span class="hljs-number">2011</span>, time.Month(<span class="hljs-number">3</span>), <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, now.Location())<br>fmt.Println(t.Format(layout))<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>日期字符串解析成 time.Time</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t, _ := time.ParseInLocation(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>, time.Now().Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>), time.Local)<br>fmt.Println(t)<br><span class="hljs-comment">// 2021-12-30 19:54:31 +0800 CST</span><br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211230195731.png" /></p><p><strong>日期的格式化</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>now := time.Now()<br><br>fmt.Println( now.Format(<span class="hljs-string">&quot;2006/01/02 15/04/05&quot;</span>))<br><span class="hljs-comment">// 2021/12/30 19/46/44</span><br><br>fmt.Println(now.Format(<span class="hljs-string">&quot;2006 15:04&quot;</span>))<br><span class="hljs-comment">//2021 19:46</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>计算、比较日期</strong></p><p>0-24小时之内的时间计算:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br><br><span class="hljs-comment">// 1小时1分1s之后</span><br>t1, _ := time.ParseDuration(<span class="hljs-string">&quot;1h1m1s&quot;</span>)<br>m1 := now.Add(t1)<br>fmt.Println(m1)<br><br><span class="hljs-comment">// 1小时1分1s之前</span><br>t2, _ := time.ParseDuration(<span class="hljs-string">&quot;-1h1m1s&quot;</span>)<br>m2 := now.Add(t2)<br>fmt.Println(m2)<br><br><span class="hljs-comment">// 3小时之前</span><br>t3, _ := time.ParseDuration(<span class="hljs-string">&quot;-1h&quot;</span>)<br>m3 := now.Add(t3 * <span class="hljs-number">3</span>)<br>fmt.Println(m3)<br><br><span class="hljs-comment">// 10 分钟之后</span><br>t4, _ := time.ParseDuration(<span class="hljs-string">&quot;10m&quot;</span>)<br>m4 := now.Add(t4)<br>fmt.Println(m4)<br><br><span class="hljs-comment">// Sub 计算两个时间差</span><br>sub1 := now.Sub(m3)<br>fmt.Println(sub1.Hours())   <span class="hljs-comment">// 相差小时数</span><br>fmt.Println(sub1.Minutes()) <span class="hljs-comment">// 相差分钟数</span><br><br><br><br><span class="hljs-comment">// 返回当前时间与 t 的时间差，返回值是 Duration</span><br><span class="hljs-comment">// time.Since(t Time) Duration</span><br><br><span class="hljs-comment">// 返回 t 与当前时间的时间差，返回值是 Duration</span><br><span class="hljs-comment">// time.Until(t Time) Duration</span><br><br><br>t5, _ := time.ParseDuration(<span class="hljs-string">&quot;-1h&quot;</span>)<br>m5 := now.Add(t5)<br><br>fmt.Println(time.Since(m5))<br>fmt.Println(time.Until(m5))<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>1-24小时之外的时间计算</p><p>func (t Time) AddDate(years int, months int, days int) Time</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br>fmt.Println(now)<br><span class="hljs-comment">// 一年一个月零一天 </span><br>m1 := now.AddDate(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>fmt.Println(m1)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>日期比较</strong> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br><br><span class="hljs-comment">// 1小时之后</span><br>t1, _ := time.ParseDuration(<span class="hljs-string">&quot;1h&quot;</span>)<br>m1 := now.Add(t1)<br><br>fmt.Println(m1.After(now))  <span class="hljs-comment">// true</span><br>fmt.Println(now.Before(m1))<span class="hljs-comment">// true</span><br>fmt.Println(now.Equal(m1))<span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——流程控制</title>
    <link href="/2021/12/29/Go%E2%80%94%E2%80%94%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2021/12/29/Go%E2%80%94%E2%80%94%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="分支结构">1. 分支结构</h3><h4 id="if-分支">1.1 if 分支</h4><p><strong>基本语法：</strong></p><p>if 条件表达式1 { 　逻辑代码1 } else if　条件表达式2 { 　逻辑代码2 }....... else { 　逻辑代码n }</p><blockquote><ul><li>条件表达式左右的 () 可以不写，也建议不写。</li><li>if 和表达式中间，一定要有空格。</li><li>{} 是必须有的，即使逻辑代码只有一行。</li><li>else 和上一个代码块结束的 { 必须在同一行，不能换行</li></ul></blockquote><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211229113906.png" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> score = <span class="hljs-number">80</span><br><br><span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">90</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;A&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">80</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;B&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">70</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;C&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">60</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;D&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;E&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="switch-分支">1.2 switch 分支</h4><p><strong>基本语法：</strong></p><p>switch 表达式 { 　case 值1,值2,.….<strong>:</strong> 　　　语句块1　case 值3,值4,...<strong>:</strong> 　　　语句块2 　 .... 　default<strong>:</strong> 　　　 语句块 } <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> score <span class="hljs-keyword">int</span> = <span class="hljs-number">89</span><br><br><span class="hljs-keyword">switch</span> score / <span class="hljs-number">10</span> &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">10</span>, <span class="hljs-number">9</span>:<br>fmt.Println(<span class="hljs-string">&quot;A&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>fmt.Println(<span class="hljs-string">&quot;B&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>fmt.Println(<span class="hljs-string">&quot;C&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>fmt.Println(<span class="hljs-string">&quot;D&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;E&quot;</span>)<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></p><ol type="1"><li>switch 后是一个表达式（即:常量值、变量、一个有返回值的函数等）</li><li>case 后面的值如果是常量值(字面量)，则要求不能重复</li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211229123557.png" /></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211229123520.png" /></p><ol start="3" type="1"><li><p>case 后的各个值的数据类型，必须和 switch的表达式数据类型一致</p></li><li><p>case 后面可以带多个值，使用逗号间隔</p></li><li><p>case 后面不需要带 break ，默认不穿透</p></li><li><p>default 语句不是必须的，位置也是随意的 (所有 case不匹配才执行)</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211229124313.png" /></p></li><li><p>switch 后也可以不带表达式，当做 if 分支来使用<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> score <span class="hljs-keyword">int</span> = <span class="hljs-number">69</span><br><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">60</span>:<br>fmt.Println(<span class="hljs-string">&quot;及格&quot;</span>)<br><span class="hljs-keyword">case</span> score &lt; <span class="hljs-number">60</span>:<br>fmt.Println(<span class="hljs-string">&quot;不及格&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></p></li><li><p>利用 fallthrough 关键字进行 switch穿透，继续执行下一个case</p></li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211229125520.png" /></p><p><font color="red"><strong>java 中的 switch：</strong></font></p><blockquote><p>case 标签必须为字符串常量或字面量。 支持的类型： &gt;Java5以前，只支持 byte，short，char，int 类型 &gt;Java5 引入了枚举类型和byte，short，char，int 的包装类 &gt;从Java7开始，支持 String 类型</p></blockquote><p>（byte、short、char类型可以在不损失精度的情况下向上转型成int类型。枚举类型的支持是因为枚举类有一个ordinal 方法,该方法返回一个 int 类型的值。支持 String 是利用 String 的hash 值，本质上也是 switch-int 结构，并且通过 equals 方法来防止 hash冲突，用 switch-byte 结构精确匹配。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (<span class="hljs-string">&quot;A&quot;</span>) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;A&quot;</span> :<br>                System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;B&quot;</span> :<br>                System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译结果： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] var0)</span> </span>&#123;<br>        String var1 = <span class="hljs-string">&quot;A&quot;</span>;<br>        <span class="hljs-keyword">byte</span> var2 = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">switch</span>(var1.hashCode()) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">65</span>:<br>            <span class="hljs-keyword">if</span> (var1.equals(<span class="hljs-string">&quot;A&quot;</span>)) &#123;<br>                var2 = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">66</span>:<br>            <span class="hljs-keyword">if</span> (var1.equals(<span class="hljs-string">&quot;B&quot;</span>)) &#123;<br>                var2 = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">switch</span>(var2) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="循环结构">2. 循环结构</h3><p>Go 语言中只有 for 循环。</p><h4 id="基本格式">2.1 基本格式</h4><p>for init; condition; post { } for condition { } for { }</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> sum <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++ &#123;<br>sum += i<br>&#125;<br><br>index := <span class="hljs-number">5</span><br><span class="hljs-keyword">for</span> index &gt; <span class="hljs-number">0</span> &#123;<br>fmt.Println(index)<br>index--<br>&#125;<br><br>index = <span class="hljs-number">5</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Println(index)<br>index--<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="循环控制关键字">2.2 循环控制关键字</h4><table><thead><tr><th style="text-align: center;">控制语句</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr><td style="text-align: center;">break</td><td style="text-align: center;">经常用于中断当前 for 循环或跳出 switch语句</td></tr><tr><td style="text-align: center;">continue</td><tdstyle="text-align: center;">跳过当前循环的剩余语句，然后继续进行下一轮循环</td></tr><tr><td style="text-align: center;">goto</td><td style="text-align: center;">将控制转移到被标记的语句</td></tr></tbody></table><p>以上关键字均支持标签。 （语法和 java 相同）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>label:<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++ &#123;<br><span class="hljs-keyword">if</span> j == <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">continue</span> label<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%d --- %d \n&quot;</span>, i, j)<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="for-range">2.4 for range</h4><p>for range 可以遍历数组、切片、字符串、map 及通道，for range语法上类似于其它 java 中的 foreach 语句，一般形式为：</p><p>for key, val := range coll { 　　... }</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>strings := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;<br><span class="hljs-keyword">for</span> i, s := <span class="hljs-keyword">range</span> strings &#123;<br>fmt.Println(i, s)<br>&#125;<br><br><span class="hljs-keyword">var</span> str <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;hello 张三&quot;</span><br><span class="hljs-keyword">for</span> i, value := <span class="hljs-keyword">range</span> str &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d &lt;====&gt; %c \n&quot;</span>, i, value)<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211229181327.png" /></p><p>字符串遍历的另一种方式： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>str := <span class="hljs-string">&quot;hello 张三&quot;</span><br>r := []<span class="hljs-keyword">rune</span>(str)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(r); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%c &quot;</span>, r[i])<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——运算符</title>
    <link href="/2021/12/28/Go%E2%80%94%E2%80%94%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2021/12/28/Go%E2%80%94%E2%80%94%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211228223837.png" /></p><h3 id="算术运算符">1. 算术运算符</h3><p>算术运算符包括： + ，-，*，/，%，++，--</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">//+加号：</span><br><span class="hljs-comment">//1.正数 2.相加操作  3.字符串拼接</span><br><span class="hljs-keyword">var</span> n1 <span class="hljs-keyword">int</span> = +<span class="hljs-number">10</span><br>fmt.Println(n1)<br><span class="hljs-keyword">var</span> n2 <span class="hljs-keyword">int</span> = <span class="hljs-number">4</span> + <span class="hljs-number">7</span><br>fmt.Println(n2)<br><span class="hljs-keyword">var</span> s1 <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span><br>fmt.Println(s1)<br><br><span class="hljs-comment">// /除号：</span><br>fmt.Println(<span class="hljs-number">10</span> / <span class="hljs-number">3</span>)   <span class="hljs-comment">//两个int类型数据运算，结果一定为整数类型</span><br>fmt.Println(<span class="hljs-number">10.0</span> / <span class="hljs-number">3</span>) <span class="hljs-comment">//浮点类型参与运算，结果为浮点类型</span><br><br><span class="hljs-comment">// % 取模</span><br>fmt.Println(<span class="hljs-number">10</span> % <span class="hljs-number">-3</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-comment">//++自增操作：</span><br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><br>a++<br>a--<br><span class="hljs-comment">//++ 自增 加1操作，--自减，减1操作</span><br><span class="hljs-comment">// 只能单独使用，不能参与到运算中去</span><br><span class="hljs-comment">// ++，--只能在变量的后面</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="赋值运算符">2. 赋值运算符</h3><p>赋值运算符包括=,+=，-=，*=，/=,%=</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> num1 <span class="hljs-keyword">int</span> = (<span class="hljs-number">10</span> + <span class="hljs-number">20</span>) % <span class="hljs-number">3</span><br>num1 += <span class="hljs-number">20</span><br>fmt.Println(num1) <span class="hljs-comment">// 20</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="关系运算符">3. 关系运算符</h3><p>关系运算符包括：==、!=、&gt;、&lt;、&gt; =、&lt;=</p><h3 id="逻辑运算符">4. 逻辑运算符</h3><p>逻辑运算符：&amp;&amp;(逻辑与/短路与)，||（逻辑或/短路或），!（逻辑非）</p><p>【注】&amp; 不能作为逻辑运算</p><h3 id="位运算符">5. 位运算符</h3><table><thead><tr><th style="text-align: center;">运算符</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr><td style="text-align: center;">&amp;</td><td style="text-align: center;">按位与</td></tr><tr><td style="text-align: center;">|</td><td style="text-align: center;">按位或</td></tr><tr><td style="text-align: center;">^</td><td style="text-align: center;">按位异或</td></tr><tr><td style="text-align: center;">&lt;&lt;</td><td style="text-align: center;">左移运算符（高位丢弃，低位补0）</td></tr><tr><td style="text-align: center;">&gt;&gt;</td><td style="text-align: center;">右移运算符</td></tr></tbody></table><p>【注】没有无符号右移 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> c <span class="hljs-keyword">int8</span> = <span class="hljs-number">127</span><br>fmt.Println(c &lt;&lt; <span class="hljs-number">1</span>) <span class="hljs-comment">// -2</span><br><br><span class="hljs-comment">// 01111111// 127</span><br><span class="hljs-comment">// 11111110// 补码</span><br><span class="hljs-comment">// 10000001// 反码</span><br><span class="hljs-comment">// 10000010// 原码</span><br><br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="其他运算符">6. 其他运算符</h3><p>&amp; ：返回变量的存储地址 * ：返回针变量对应的值</p><h3 id="运算符优先级">7. 运算符优先级</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211228232536.png" /></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——testify</title>
    <link href="/2021/12/22/Go%E2%80%94%E2%80%94testify/"/>
    <url>/2021/12/22/Go%E2%80%94%E2%80%94testify/</url>
    
    <content type="html"><![CDATA[<p>testify 扩展了 testing 标准库，断言库 assert，测试替身 mock和测试套件 suite 等，让我们编写测试代码更容易！</p><h3 id="引入">1. 引入</h3><p>安装 testify 库： <figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/stretchr/testify<br></code></pre></td></tr></table></figure></p><p>如果 go get 失败： <figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">$ go env -w GO111MODULE=on<br>$ go env -w GOPROXY=https:<span class="hljs-comment">//goproxy.cn,direct</span><br></code></pre></td></tr></table></figure> estify 模块： + assert + http + mock+ require + suite</p><h3 id="assert">2. assert</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Equal</span><span class="hljs-params">(t TestingT, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotEqual</span><span class="hljs-params">(t TestingT, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Nil</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotNil</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-comment">/* 断言object是空，根据object中存储的实际类型，空的含义不同：</span><br><span class="hljs-comment">   指针：nil；</span><br><span class="hljs-comment">   整数：0；</span><br><span class="hljs-comment">   浮点数：0.0；</span><br><span class="hljs-comment">   字符串：空串&quot;&quot;；</span><br><span class="hljs-comment">   布尔：false；</span><br><span class="hljs-comment">   切片或 channel：长度为 0。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Empty</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotEmpty</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NoError</span><span class="hljs-params">(t TestingT, err error, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 断言err不为nil</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Error</span><span class="hljs-params">(t TestingT, err error, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 断言err表示的 error 链中至少有一个和target匹配</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ErrorAs</span><span class="hljs-params">(t TestingT, err error, target <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 断言err的 error 链中有target</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ErrorIs</span><span class="hljs-params">(t TestingT, err, target error, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Zero</span><span class="hljs-params">(t TestingT, i <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotZero</span><span class="hljs-params">(t TestingT, i <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">True</span><span class="hljs-params">(t TestingT, value <span class="hljs-keyword">bool</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">False</span><span class="hljs-params">(t TestingT, value <span class="hljs-keyword">bool</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Len</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, length <span class="hljs-keyword">int</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-comment">// 断言 s 包含 contains。其中 s 可以是字符串，数组/切片，map。相应地，contains为子串，数组/切片元素，map 的键。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Contains</span><span class="hljs-params">(t TestingT, s, contains <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotContains</span><span class="hljs-params">(t TestingT, s, contains <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Subset</span><span class="hljs-params">(t TestingT, list, subset <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(ok <span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotSubset</span><span class="hljs-params">(t TestingT, list, subset <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(ok <span class="hljs-keyword">bool</span>)</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FileExists</span><span class="hljs-params">(t TestingT, path <span class="hljs-keyword">string</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 断言路径 path 是一个目录，如果 path 不存在或者是一个文件，断言失败。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DirExists</span><span class="hljs-params">(t TestingT, path <span class="hljs-keyword">string</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><br><span class="hljs-comment">// 断言 listA 和 listB 包含相同的元素，忽略元素出现的顺序。listA/listB 必须是数组或切片。如果有重复元素，重复元素出现的次数也必须相等。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ElementsMatch</span><span class="hljs-params">(t TestingT, listA, listB <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-comment">// 断言theError.Error()的返回值与errString相等。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">EqualError</span><span class="hljs-params">(t TestingT, theError error, errString <span class="hljs-keyword">string</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-comment">// 断言expected与actual相等，或者可以转换为相同的类型，并且相等</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">EqualValues</span><span class="hljs-params">(t TestingT, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br></code></pre></td></tr></table></figure><p><strong>示例:</strong> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSomething</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><br><span class="hljs-comment">//断言相等</span><br>assert.Equal(t, <span class="hljs-number">123</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&quot;they should be equal&quot;</span>)<br><span class="hljs-comment">//断言不相等</span><br>assert.NotEqual(t, <span class="hljs-number">123</span>, <span class="hljs-number">456</span>, <span class="hljs-string">&quot;they should not be equal&quot;</span>)<br><br><span class="hljs-comment">//对于nil的断言</span><br>assert.Nil(t, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">var</span> object = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-comment">//对于非nil的断言</span><br><span class="hljs-keyword">if</span> assert.NotNil(t, object) &#123;<br>assert.Equal(t, <span class="hljs-string">&quot;hello&quot;</span>, object)<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><strong>Assertions 对象</strong></p><p>上面的断言都是以 TestingT为第一个参数，需要大量使用时比较麻烦。testify 提供了一种方便的方式。先以* testing.T创建一个* Assertions 对象，Assertions定义了前面所有的断言方法，只是不需要再传入TestingT参数了。 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestEqual</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>  assertions := assert.New(t)<br>  assertion.Equal(a, b, <span class="hljs-string">&quot;&quot;</span>)<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure>### 3. requirerequire提供了和assert同样的接口，但是遇到错误时，require直接终止测试，而assert返回false。</p><h3 id="mock">4. mock</h3><p>testify 提供了对 Mock 的简单支持。Mock简单来说就是构造一个仿对象，仿对象提供和原对象一样的接口，在测试中用仿对象来替换原对象。</p><p>待测试代码： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">type User struct &#123;<br>Name string<br>Age  <span class="hljs-keyword">int</span><br>&#125;<br><br>type ICrawler <span class="hljs-class"><span class="hljs-keyword">interface</span> </span>&#123;<br>GetUserList() ([]*User, error)<br>&#125;<br><br>type MyCrawler struct &#123;<br>url string<br>&#125;<br><br>func (c *MyCrawler) GetUserList() ([]*User, error) &#123;<br>resp, err := http.Get(c.url)<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-keyword">return</span> nil, err<br>&#125;<br><br>defer resp.Body.Close()<br>data, err := ioutil.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-keyword">return</span> nil, err<br>&#125;<br><br><span class="hljs-keyword">var</span> userList []*User<br>err = json.Unmarshal(data, &amp;userList)<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-keyword">return</span> nil, err<br>&#125;<br><br><span class="hljs-keyword">return</span> userList, nil<br>&#125;<br><br><span class="hljs-function">func <span class="hljs-title">GetAndPrintUsers</span><span class="hljs-params">(crawler ICrawler)</span> </span>&#123;<br>users, err := crawler.GetUserList()<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">for</span> _, u := range users &#123;<br>fmt.Println(u)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure> 测试代码： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MockCrawler <span class="hljs-keyword">struct</span> &#123;<br>mock.Mock<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MockCrawler)</span> <span class="hljs-title">GetUserList</span><span class="hljs-params">()</span> <span class="hljs-params">([]*User, error)</span></span> &#123;<br>args := m.Called()<br><span class="hljs-keyword">return</span> args.Get(<span class="hljs-number">0</span>).([]*User), args.Error(<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>MockUsers []*User<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>MockUsers = <span class="hljs-built_in">append</span>(MockUsers, &amp;User&#123;<span class="hljs-string">&quot;dj&quot;</span>, <span class="hljs-number">18</span>&#125;)<br>MockUsers = <span class="hljs-built_in">append</span>(MockUsers, &amp;User&#123;<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">20</span>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGetUserList</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>crawler := <span class="hljs-built_in">new</span>(MockCrawler)<br>crawler.On(<span class="hljs-string">&quot;GetUserList&quot;</span>).Return(MockUsers, <span class="hljs-literal">nil</span>)<br><br>GetAndPrintUsers(crawler)<br><br>crawler.AssertExpectations(t)<br>&#125;<br></code></pre></td></tr></table></figure> 实现GetUserList() 方法时，需要调用 Mock.Called() 方法，传入参数。Called()会返回一个 mock.Arguments对象，该对象中保存着返回的值。它提供了对基本类型和 error 的获取方法Int()/String()/Bool()/Error()，和通用的获取方法 Get()，通用方法返回interface{}，需要类型断言为具体类型，它们都接受一个表示索引的参数。</p><p>crawler.On("GetUserList").Return(MockUsers, nil) 是 Mock发挥魔法的地方，这里指示调用 GetUserList() 方法的返回值分别 为MockUsers和 nil，返回值在上面的 GetUserList() 方法中被 Arguments.Get(0) 和Arguments.Error(1) 获取。</p><p>最后 crawler.AssertExpectations(t)对 Mock 对象做断言。</p><p>执行结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211225233426.png" /></p><hr /><p>使用 Mock，可以精确断言某方法以特定参数的调用次数，Times(nint)，它有两个便捷函数Once()/Twice()。下面我们要求函数Hello(nint)要以参数 1 调用 1次，参数 2 调用两次，参数 3 调用 3 次：</p><p>待测试方法:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> IExample <span class="hljs-keyword">interface</span> &#123;<br>Hello(n <span class="hljs-keyword">int</span>) <span class="hljs-keyword">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">Hello</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Hello with %d\n&quot;</span>, n)<br><span class="hljs-keyword">return</span> n<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleFunc</span><span class="hljs-params">(e IExample)</span></span> &#123;<br><span class="hljs-keyword">for</span> n := <span class="hljs-number">1</span>; n &lt;= <span class="hljs-number">3</span>; n++ &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= n; i++ &#123;<br>e.Hello(n)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试方法： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MockExample <span class="hljs-keyword">struct</span> &#123;<br>mock.Mock<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *MockExample)</span> <span class="hljs-title">Hello</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>args := e.Mock.Called(n)<br><span class="hljs-keyword">return</span> args.Int(<span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestExample</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>e := <span class="hljs-built_in">new</span>(MockExample)<br><br>e.On(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">1</span>).Return(<span class="hljs-number">1</span>).Times(<span class="hljs-number">1</span>)<br>e.On(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">2</span>).Return(<span class="hljs-number">2</span>).Times(<span class="hljs-number">2</span>)<br>e.On(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">3</span>).Return(<span class="hljs-number">3</span>).Times(<span class="hljs-number">3</span>)<br><br>ExampleFunc(e)<br><br>e.AssertExpectations(t)<br>&#125;<br></code></pre></td></tr></table></figure> 执行结果</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211225235248.png" /></p><p>修改 ExampleFunc 将 for i := 0; i &lt;= n; i++ 改为 for i := 0; i&lt; n; i++</p><p>执行结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211225235641.png" /></p><h3 id="suite">5. suite</h3><p>testify提供了测试套件的功能（TestSuite），testify测试套件只是一个结构体，内嵌一个匿名的suite.Suite结构。测试套件中可以包含多个测试，它们可以共享状态，还可以定义钩子方法执行初始化和清理操作。钩子都是通过接口来定义的，实现了这些接口的测试套件结构在运行到指定节点时会调用对应的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SetupAllSuite <span class="hljs-keyword">interface</span> &#123;<br>  SetupSuite()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果定义了SetupSuite()方法（即实现了SetupAllSuite接口），在套件中所有测试开始运行前调用这个方法。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TearDownAllSuite <span class="hljs-keyword">interface</span> &#123;<br>  TearDownSuite()<br>&#125;<br></code></pre></td></tr></table></figure>如果定义了TearDonwSuite()方法（即实现了TearDownSuite接口），在套件中所有测试运行完成后调用这个方法。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SetupTestSuite <span class="hljs-keyword">interface</span> &#123;<br>  SetupTest()<br>&#125;<br></code></pre></td></tr></table></figure>如果定义了SetupTest()方法（即实现了SetupTestSuite接口），在套件中每个测试执行前都会调用这个方法。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TearDownTestSuite <span class="hljs-keyword">interface</span> &#123;<br>  TearDownTest()<br>&#125;<br></code></pre></td></tr></table></figure>如果定义了TearDownTest()方法（即实现了TearDownTest接口），在套件中每个测试执行后都会调用这个方法。</p><p>还有一对接口BeforeTest/AfterTest，它们分别在每个测试运行前/后调用，接受套件名和测试名作为参数。</p><p><strong>示例</strong> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyTestSuit <span class="hljs-keyword">struct</span> &#123;<br>suite.Suite<br>testCount <span class="hljs-keyword">uint32</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">SetupSuite</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;SetupSuite&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">TearDownSuite</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;TearDownSuite&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">SetupTest</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;SetupTest test count:%d\n&quot;</span>, s.testCount)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">TearDownTest</span><span class="hljs-params">()</span></span> &#123;<br>s.testCount++<br>fmt.Printf(<span class="hljs-string">&quot;TearDownTest test count:%d\n&quot;</span>, s.testCount)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">BeforeTest</span><span class="hljs-params">(suiteName, testName <span class="hljs-keyword">string</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;BeforeTest suite:%s test:%s\n&quot;</span>, suiteName, testName)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">AfterTest</span><span class="hljs-params">(suiteName, testName <span class="hljs-keyword">string</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;AfterTest suite:%s test:%s\n&quot;</span>, suiteName, testName)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">TestExample</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;TestExample1111&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">TestExample2</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;TestExample2222&quot;</span>)<br>&#125;<br><br><br><span class="hljs-comment">// 为了用 go test 运行测试</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestExample</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>suite.Run(t, <span class="hljs-built_in">new</span>(MyTestSuit))<br>&#125;<br></code></pre></td></tr></table></figure> 执行结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211226005128.png" /></p><h3 id="http-测试">6. HTTP 测试</h3><p>httptest提供了一个ResponseRecorder类型，它实现了http.ResponseWriter接口，但是它只是记录写入的状态码和响应内容，不会发送响应给客户端</p><p>一个简单的 http 服务器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">index</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>  fmt.Fprintln(w, <span class="hljs-string">&quot;Hello World&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greeting</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>  fmt.Fprintf(w, <span class="hljs-string">&quot;welcome, %s&quot;</span>, r.URL.Query().Get(<span class="hljs-string">&quot;name&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  mux := http.NewServeMux()<br>  mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, index)<br>  mux.HandleFunc(<span class="hljs-string">&quot;/greeting&quot;</span>, greeting)<br><br>  server := &amp;http.Server&#123;<br>    Addr:    <span class="hljs-string">&quot;:8080&quot;</span>,<br>    Handler: mux,<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> err := server.ListenAndServe(); err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试1</strong> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestIndex</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>recorder := httptest.NewRecorder()<br>request, _ := http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-literal">nil</span>)<br>mux := http.NewServeMux()<br>mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, index)<br>mux.HandleFunc(<span class="hljs-string">&quot;/greeting&quot;</span>, greeting)<br><br>mux.ServeHTTP(recorder, request)<br><br>assert.Equal(t, recorder.Code, <span class="hljs-number">200</span>, <span class="hljs-string">&quot;get index error&quot;</span>)<br>assert.Contains(t, recorder.Body.String(), <span class="hljs-string">&quot;Hello World&quot;</span>, <span class="hljs-string">&quot;body error&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGreeting</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>recorder := httptest.NewRecorder()<br>request, _ := http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/greeting&quot;</span>, <span class="hljs-literal">nil</span>)<br>request.URL.RawQuery = <span class="hljs-string">&quot;name=dj&quot;</span><br>mux := http.NewServeMux()<br>mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, index)<br>mux.HandleFunc(<span class="hljs-string">&quot;/greeting&quot;</span>, greeting)<br><br>mux.ServeHTTP(recorder, request)<br><br>assert.Equal(t, recorder.Code, <span class="hljs-number">200</span>, <span class="hljs-string">&quot;greeting error&quot;</span>)<br>assert.Contains(t, recorder.Body.String(), <span class="hljs-string">&quot;welcome, dj&quot;</span>, <span class="hljs-string">&quot;body error&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure> 可以使用 suite，消除recorder/mux 等对象的创建，处理器函数的注册。</p><p><strong>测试2</strong> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MySuite <span class="hljs-keyword">struct</span> &#123;<br>suite.Suite<br>recorder *httptest.ResponseRecorder<br>mux      *http.ServeMux<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MySuite)</span> <span class="hljs-title">SetupSuite</span><span class="hljs-params">()</span></span> &#123;<br>s.recorder = httptest.NewRecorder()<br>s.mux = http.NewServeMux()<br>s.mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, index)<br>s.mux.HandleFunc(<span class="hljs-string">&quot;/greeting&quot;</span>, greeting)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MySuite)</span> <span class="hljs-title">TestIndex</span><span class="hljs-params">()</span></span> &#123;<br>request, _ := http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-literal">nil</span>)<br>s.mux.ServeHTTP(s.recorder, request)<br><br>s.Assert().Equal(s.recorder.Code, <span class="hljs-number">200</span>, <span class="hljs-string">&quot;get index error&quot;</span>)<br>s.Assert().Contains(s.recorder.Body.String(), <span class="hljs-string">&quot;Hello World&quot;</span>, <span class="hljs-string">&quot;body error&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MySuite)</span> <span class="hljs-title">TestGreeting</span><span class="hljs-params">()</span></span> &#123;<br>request, _ := http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/greeting&quot;</span>, <span class="hljs-literal">nil</span>)<br>request.URL.RawQuery = <span class="hljs-string">&quot;name=dj&quot;</span><br><br>s.mux.ServeHTTP(s.recorder, request)<br><br>s.Assert().Equal(s.recorder.Code, <span class="hljs-number">200</span>, <span class="hljs-string">&quot;greeting error&quot;</span>)<br>s.Assert().Contains(s.recorder.Body.String(), <span class="hljs-string">&quot;welcome, dj&quot;</span>, <span class="hljs-string">&quot;body error&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 测试驱动</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestHTTP</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>suite.Run(t, <span class="hljs-built_in">new</span>(MySuite))<br>&#125;<br></code></pre></td></tr></table></figure></p><p><a href="https://zhuanlan.zhihu.com/p/267341653">拓展</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——测试</title>
    <link href="/2021/12/20/Go%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95/"/>
    <url>/2021/12/20/Go%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="基本测试框架">1. 基本测试框架</h3><p>在 Go 语言中，所有的测试都需要以 _test.go 结尾，这样 go build不会去编译 _test.go 结尾的文件，而 go test 会去编译 _test.go结尾的文件。</p><p>在编写测试的时候，会用到 testing这个包，在这个包中，常用的类型有下面这些:</p><ul><li>testing.T（单元测试）</li><li>testing.B（基准测试）</li><li>testing.M（TestMain 测试）</li><li>testing.TB（testing.T、testing.B 公用接口）</li><li>testing.PB（Next() 接口 。 判断是否继续循环）</li></ul><p>有一类测试例外，那就是 Example测试，主要用来在文档中输出一些测试案例，Example 测试必须以 Example开头，方法不需要任何参数，同时要指明这个实例的输出，像下面这样：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleTest</span><span class="hljs-params">()</span></span> &#123;<br> fmt.Println(<span class="hljs-string">&quot;run example test&quot;</span>)<br> <span class="hljs-comment">// Output:</span><br> <span class="hljs-comment">// run example test</span><br>&#125;<br></code></pre></td></tr></table></figure> 所有的测试都可以通过 go test来发起，例如，在当前包下发起测试 go test -v ./ ，-v参数表示打印测试的过程，会把测试过程中的标准输出都打印出来。</p><h3 id="单元测试">2. 单元测试</h3><h4 id="语法格式">2.1 语法格式：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestXxx</span><span class="hljs-params">(*testing.T)</span></span><br></code></pre></td></tr></table></figure><p><font color="red">注意：Xxx可以是任何字母数字字符串，但是第一个字母不能是小写字母。</font> 其中参数t 用于报告测试失败和附加的日志信息。 testing.T的拥有的方法如下：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Error</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Fail</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">FailNow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Failed</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Fatal</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Fatalf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Log</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Logf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span> <span class="hljs-title">Parallel</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span> <span class="hljs-title">Run</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, f <span class="hljs-keyword">func</span>(t *T)</span>) <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Skip</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">SkipNow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Skipf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Skipped</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span><br><br></code></pre></td></tr></table></figure> + 判定失败接口： 　　Fail 失败继续 　　FailNow 失败终止 +打印信息接口： 　　Log 数据流 （cout　类似） 　　Logf format (printf类似） + SkipNow 跳过当前测试 + Skiped 检测是否跳过 + 综合接口产生：　　Error / Errorf 报告出错继续 [ Log / Logf + Fail ] 　　Fatel / Fatelf报告出错终止 [ Log / Logf + FailNow ] 　　Skip / Skipf 报告并跳过 [ Log/ Logf + SkipNow ] <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getAge</span><span class="hljs-params">(IDNumber <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int16</span></span> &#123;<br><br> strYear := IDNumber[<span class="hljs-number">6</span>:<span class="hljs-number">10</span>]<br> intYear, _ := strconv.Atoi(strYear)<br><br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">int16</span>(<span class="hljs-number">2022</span> - intYear)<br>&#125;<br></code></pre></td></tr></table></figure> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_GetAge</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br> <span class="hljs-keyword">var</span> (<br>  in       = <span class="hljs-string">&quot;610113200505189012&quot;</span><br>  expected = <span class="hljs-number">16</span><br> )<br> actual := getAge(in)<br> <span class="hljs-keyword">if</span> actual != <span class="hljs-keyword">int16</span>(expected) &#123;<br>  t.Errorf(<span class="hljs-string">&quot;Fib(%s) = %d; expected %d&quot;</span>, in, actual, expected)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>所有的测试都可以通过 go test 来发起，例如，在当前包下发起测试 go test-v ./ ，-v ：查看测试函数名称和运行时间</p><p>还可以在go test命令后添加 -run参数，它对应一个正则表达式，只有函数名匹配上的测试函数才会被 go test命令执行</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211220232747.png" /></p><p>【注】： <figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">PS D:\workspace\zth\gotest\src\gocode\main&gt; <span class="hljs-built_in">go</span> test .    <br><span class="hljs-built_in">go</span>: <span class="hljs-built_in">go</span>.<span class="hljs-built_in">mod</span> file <span class="hljs-keyword">not</span> found <span class="hljs-keyword">in</span> current <span class="hljs-built_in">directory</span> <span class="hljs-keyword">or</span> any parent <span class="hljs-built_in">directory</span>; see &#x27;<span class="hljs-built_in">go</span> help modules&#x27; <br></code></pre></td></tr></table></figure> <strong>问题原因：</strong> go module 是 go从1.13 版本开始正式推荐使用依赖管理库 go module可以将某个项目(文件夹)下的所有依赖整理成一个 go.mod文件,里面写入了依赖的版本等 使用gomodule之后我们可不用将代码放置在src下了 使用 go module管理依赖后会在项目根目录下生成两个文件 go.mod 和 go.sum。</p><blockquote><p>go env -w GO111MODULE=auto go mod init XXX 　//初始化Gomoudle，xxx为文件夹名</p></blockquote><blockquote><p>用环境变量 GO111MODULE开启或关闭模块支持，它有三个可选值：off、on、auto，默认值是 auto。 +GO111MODULE=off 　无模块支持，go 会从 GOPATH 和 vendor 文件夹寻找包。 +GO111MODULE=on 　模块支持，go 会忽略 GOPATH 和 vendor 文件夹，只根据go.mod 下载依赖。 + GO111MODULE=auto 　在 $GOPATH/src 外面且根目录有go.mod 文件时，开启模块支持。 在使用模块的时候，GOPATH是无意义的，不过它还是会把下载的依赖储存在 <spanclass="math inline">\(GOPATH/src/mod 中，也会把 go install的结果放在\)</span>GOPATH/bin 中。</p></blockquote><h4 id="table-driven-test">2.2 Table-Driven Test</h4><p>采用 Table-Driven 的方式盖更多 case。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_GetAge2</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> ageTest = [] <span class="hljs-keyword">struct</span>&#123;<br>in       <span class="hljs-keyword">string</span><br>expected <span class="hljs-keyword">int</span><br>&#125;&#123;<br>&#123;<span class="hljs-string">&quot;610113200505189012&quot;</span>,<span class="hljs-number">16</span>&#125;,<br>&#123;<span class="hljs-string">&quot;610113202105189012&quot;</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-string">&quot;610113202005189012&quot;</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-string">&quot;610113202105189012&quot;</span>,<span class="hljs-number">2</span>&#125;,<br><br><br>&#125;<br><br><span class="hljs-keyword">for</span> _,item := <span class="hljs-keyword">range</span> ageTest&#123;<br>actual := getAge(item.in)<br><span class="hljs-keyword">if</span> actual != item.expected &#123;<br>t.Errorf(<span class="hljs-string">&quot;Fib(%s) = %d; expected %d&quot;</span>, item.in, actual, item.expected)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>t.Errorf，即使其中某个 case 失败，也不会终止测试执行。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211220234619.png" /></p><h4 id="parallel-测试">2.3 Parallel 测试</h4><p>被测试方法： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>data   = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)<br>locker sync.RWMutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteToMap</span><span class="hljs-params">(k, v <span class="hljs-keyword">string</span>)</span></span> &#123;<br>locker.Lock()<br><span class="hljs-keyword">defer</span> locker.Unlock()<br>data[k] = v<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadFromMap</span><span class="hljs-params">(k <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>locker.RLock()<br><span class="hljs-keyword">defer</span> locker.RUnlock()<br><span class="hljs-keyword">return</span> data[k]<br>&#125;<br></code></pre></td></tr></table></figure> 单元测试方法： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> pairs = []<span class="hljs-keyword">struct</span> &#123;<br>k <span class="hljs-keyword">string</span><br>v <span class="hljs-keyword">string</span><br>&#125;&#123;<br>&#123;<span class="hljs-string">&quot;baidu&quot;</span>, <span class="hljs-string">&quot;百度&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;google&quot;</span>, <span class="hljs-string">&quot;谷歌&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;jd&quot;</span>, <span class="hljs-string">&quot;京东&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;taobao&quot;</span>, <span class="hljs-string">&quot;淘宝&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;tianmao&quot;</span>, <span class="hljs-string">&quot;天猫&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;meituan&quot;</span>, <span class="hljs-string">&quot;美团&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-comment">// 注意 TestWriteToMap 需要在 TestReadFromMap 之前</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestWriteToMap</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>t.Parallel()<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> pairs &#123;<br>time.Sleep(time.Duration(<span class="hljs-number">1</span>)*time.Second)<br>WriteToMap(tt.k, tt.v)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestReadFromMap</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>t.Parallel()<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> pairs &#123;<br>time.Sleep(time.Duration(<span class="hljs-number">1</span>)*time.Second)<br>actual := ReadFromMap(tt.k)<br><span class="hljs-keyword">if</span> actual != tt.v &#123;<br>t.Errorf(<span class="hljs-string">&quot;the value of key(%s) is %s, expected: %s&quot;</span>, tt.k, actual, tt.v)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>执行结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211221234812.png" /></p><p>如果注释掉 WriteToMap 和 ReadFromMap 中 locker保护的代码，执行测试，测试失败。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211222000146.png" /></p><h4 id="testing-的变量">2.4 testing 的变量</h4><ul><li>test.short : 一个快速测试的标记，在测试用例中可以使用testing.Short() 来绕开一些测试</li><li>test.outputdir : 输出目录</li><li>test.coverprofile : 测试覆盖率参数，指定输出文件</li><li>test.run : 指定正则来运行某个 / 某些测试用例</li><li>test.memprofile : 内存分析参数，指定输出文件</li><li>test.memprofilerate : 内存分析参数，内存分析的抽样率</li><li>test.cpuprofile : cpu 分析输出参数，为空则不做 cpu 分析</li><li>test.blockprofile : 阻塞事件的分析参数，指定输出文件</li><li>test.blockprofilerate : 阻塞事件的分析参数，指定抽样频率</li><li>test.timeout : 超时时间</li><li>test.cpu : 指定 cpu 数量</li><li>test.parallel : 指定运行测试用例的并行数</li></ul><p>测试覆盖率：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211221235659.png" /></p><p>将覆盖率相关的信息输出到文件：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211222000959.png" /></p><h3 id="基准测试">3. 基准测试</h3><h4 id="基本格式">3.1 基本格式</h4><p>在 _test.go 结尾的测试文件中，基准测试函数形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkXxx</span><span class="hljs-params">(*testing.B)</span></span><br></code></pre></td></tr></table></figure><p>通过 go test 命令，加上 -bench（匹配需要执行的函数）标志来执行。多个基准测试按照顺序运行。</p><p>待测试函数： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fib</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> n<br>&#125;<br><span class="hljs-keyword">return</span> Fib(n<span class="hljs-number">-1</span>) + Fib(n<span class="hljs-number">-2</span>)<br>&#125;<br></code></pre></td></tr></table></figure> 基准测试函数： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkFib10</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> n := <span class="hljs-number">0</span>; n &lt; b.N; n++ &#123;<br>Fib(<span class="hljs-number">10</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/1微信截图_20211222154956.png" /></p><h4 id="计时方法">3.2 计时方法</h4><ol type="1"><li>StartTimer：开始对测试进行计时。该方法会在基准测试开始时自动被调用，也可以在调用StopTimer 之后恢复计时；</li><li>StopTimer：停止对测试进行计时。当需要执行一些复杂的初始化操作，并且不想对这些操作进行测量时，就可以使用这个方法来暂时地停止计时；</li><li>ResetTimer：对已经逝去的基准测试时间以及内存分配计数器进行清零。对于正在运行中的计时器，不会产生任何效果。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkFibReset</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-comment">// 长耗时配置等</span><br>time.Sleep(time.Duration(<span class="hljs-number">2</span>)*time.Second)<br>b.ResetTimer()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>Fib(<span class="hljs-number">10</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/2微信截图_20211222161446.png" /></p><p>#### 3.3 内存统计</p><p>ReportAllocs 方法用于打开当前基准测试的内存统计功能， 与 go test 使用-benchmem 标志类似，但 ReportAllocs 只影响那些调用了该函数的基准测试。<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkFib10Para</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>b.ReportAllocs()<br>templ := template.Must(template.New(<span class="hljs-string">&quot;test&quot;</span>).Parse(<span class="hljs-string">&quot;Hello, &#123;&#123;.&#125;&#125;!&quot;</span>))<br>b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pb *testing.PB)</span></span> &#123;<br><span class="hljs-comment">// Each goroutine has its own bytes.Buffer.</span><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br><span class="hljs-keyword">for</span> pb.Next() &#123;<br><span class="hljs-comment">// The loop body is executed b.N times total across all goroutines.</span><br>buf.Reset()<br>templ.Execute(&amp;buf, <span class="hljs-string">&quot;World&quot;</span>)<br>&#125;<br>&#125;)<br><br>&#125;<br></code></pre></td></tr></table></figure> <imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211222222227.png" /></p><h3 id="子测试与子基准测试">4. 子测试与子基准测试</h3><p>T 和 B 的 Run方法允许定义子单元测试和子基准测试，而不必为它们单独定义函数。这便于创建基于Table-Driven 的基准测试和层级测试。它还提供了一种共享通用 setup 和tear-down 代码的方法： <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFoo</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-comment">// &lt;setup code&gt;</span><br>    t.Run(<span class="hljs-string">&quot;A=1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123; ... &#125;)<br>    t.Run(<span class="hljs-string">&quot;A=2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123; ... &#125;)<br>    t.Run(<span class="hljs-string">&quot;B=1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123; ... &#125;)<br>    <span class="hljs-comment">// &lt;tear-down code&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure>每个子测试和子基准测试都有一个唯一的名称：由顶层测试的名称与传递给 Run的名称组成，以斜杠分隔，并具有可选的尾随序列号，用于消除歧义。</p><p>命令行标志 -run 和 -bench的参数是非固定的正则表达式，用于匹配测试名称。对于由斜杠分隔的测试名称，例如子测试的名称，它名称本身即可作为参数，依次匹配由斜杠分隔的每部分名称。<figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">go test -run <span class="hljs-string">&#x27;&#x27;</span>      # 执行所有测试。<br>go test -run Foo     # 执行匹配 <span class="hljs-string">&quot;Foo&quot;</span> 的顶层测试，例如 <span class="hljs-string">&quot;TestFooBar&quot;</span>。<br>go test -run Foo/A=  # 对于匹配 <span class="hljs-string">&quot;Foo&quot;</span> 的顶层测试，执行其匹配 <span class="hljs-string">&quot;A=&quot;</span> 的子测试。<br>go test -run /A=<span class="hljs-number">1</span>    # 执行所有匹配 <span class="hljs-string">&quot;A=1&quot;</span> 的子测试。<br></code></pre></td></tr></table></figure>子测试也可用于程序并行控制。只有子测试全部执行完毕后，父测试才会完成。在下述例子中，所有子测试之间并行运行，此处的“并行” 只限于这些子测试之间，并不影响定义在其他顶层测试中的子测试：<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGroupedParallel</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> _, tc := <span class="hljs-keyword">range</span> tests &#123;<br>        tc := tc <span class="hljs-comment">// capture range variable</span><br>        t.Run(tc.Name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>            t.Parallel()<br>            ...<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——变量、常量与数据类型</title>
    <link href="/2021/12/18/Go%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/12/18/Go%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="变量">1. 变量</h3><h4 id="变量的声明">1.1 变量的声明</h4><ol type="1"><li>指定变量类型，如果没有初始化，则变量默认为零值。</li><li>根据值自行判定变量类型</li><li>简短形式，使用 := 赋值操作符（只能声明局部变量）</li></ol><p>【注】局部变量声明后未使用，编译报错。 &gt;申明变量没有初始化就为零值&gt; + 数值类型为 0 &gt; + 布尔类型为 false &gt; + 字符串为""（空字符串） &gt; + 复杂类型为 nil（指针、切片、map 等）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> name <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;张三&quot;</span><br>fmt.Println(name)<br><br><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span><br>fmt.Println(flag)<br><br>age := <span class="hljs-number">18</span><br>fmt.Println(age)<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="多变量声明">1.2 多变量声明</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x, y <span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> (<br><span class="hljs-comment">// 这种写法一般用于声明全局变量</span><br>a , z <span class="hljs-keyword">int</span><br>b <span class="hljs-keyword">bool</span><br>)<br><br><span class="hljs-keyword">var</span> c, d <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">var</span> e, f = <span class="hljs-number">123</span>, <span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>g, h := <span class="hljs-number">123</span>, <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-built_in">println</span>(x, y, a, b, c, d, e, f, g, h)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="常量">2. 常量</h3><p>常量的声明和变量声明非常类似，只是把 var 换成了const，常量在定义的时候必须赋值。</p><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.1415</span><br><span class="hljs-keyword">const</span> e = <span class="hljs-number">2.7182</span><br><br><span class="hljs-keyword">const</span> (<br>a = <span class="hljs-number">1</span><br>b = <span class="hljs-number">2</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>n1 = <span class="hljs-number">100</span><br>n2<br>n3<br>)<br><br>fmt.Println(n3) <span class="hljs-comment">// 100</span><br></code></pre></td></tr></table></figure><h4 id="iota">2.1 iota</h4><p>iota 是 go 语言的常量计数器，只能在常量的表达式中使用。</p><p>iota 在 const 关键字出现时将被重置为 0。const中每新增一行常量声明将使 iota 计数一次( iota 可理解为 const语句块中的行索引)。 使用 iota 能简化定义，在定义枚举时很有用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>n1 = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 0</span><br>n2        <span class="hljs-comment">// 1</span><br>n3        <span class="hljs-comment">// 2</span><br>n4        <span class="hljs-comment">// 3</span><br>)<br><br><span class="hljs-comment">// 使用_跳过某些值</span><br><span class="hljs-keyword">const</span> (<br>n5 = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 0</span><br>n6        <span class="hljs-comment">// 1</span><br>_<br>n7 <span class="hljs-comment">// 3</span><br>)<br><br><span class="hljs-comment">// iota声明中间插队</span><br><span class="hljs-keyword">const</span> (<br>n8  = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 0</span><br>n9  = <span class="hljs-number">100</span>  <span class="hljs-comment">// 100</span><br>n10 = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 2</span><br>n11        <span class="hljs-comment">// 3</span><br>)<br><br><span class="hljs-comment">// 多个 iota 定义在一行</span><br><span class="hljs-keyword">const</span> (<br>a, b = <span class="hljs-literal">iota</span> + <span class="hljs-number">1</span>, <span class="hljs-literal">iota</span> + <span class="hljs-number">2</span> <span class="hljs-comment">// 1,2</span><br>c, d                      <span class="hljs-comment">// 2,3</span><br>e, f                      <span class="hljs-comment">// 3,4</span><br>)<br></code></pre></td></tr></table></figure><h3 id="数据类型">3. 数据类型</h3><h4 id="基本数据类型">3.1 基本数据类型</h4><h5 id="整型">整型</h5><table><thead><tr><th style="text-align: center;">类型</th><th style="text-align: center;">有无符号</th><th style="text-align: center;">占用存储空间</th><th style="text-align: center;">表示范围</th></tr></thead><tbody><tr><td style="text-align: center;">uint8</td><td style="text-align: center;">无符号</td><td style="text-align: center;">1字节</td><td style="text-align: center;">0 - 255(2<sup>8</sup> -1)</td></tr><tr><td style="text-align: center;">uint16</td><td style="text-align: center;">无符号</td><td style="text-align: center;">21字节</td><td style="text-align: center;">0 - 65535(2<sup>16</sup> -1)</td></tr><tr><td style="text-align: center;">uint32</td><td style="text-align: center;">无符号</td><td style="text-align: center;">4字节</td><td style="text-align: center;">0 到 4294967295(2<sup>32</sup> -1)</td></tr><tr><td style="text-align: center;">uint64</td><td style="text-align: center;">无符号</td><td style="text-align: center;">8字节</td><td style="text-align: center;">0 到 18446744073709551615(2<sup>64</sup>-1)</td></tr><tr><td style="text-align: center;">int8</td><td style="text-align: center;">有符号</td><td style="text-align: center;">1字节</td><td style="text-align: center;">-128 到 127(-2<sup>7</sup> ~2<sup>7</sup>-1)</td></tr><tr><td style="text-align: center;">int16</td><td style="text-align: center;">有符号</td><td style="text-align: center;">2字节</td><td style="text-align: center;">-32768 到 32767(-2<sup>15</sup> ~2<sup>15</sup>-1)</td></tr><tr><td style="text-align: center;">int32</td><td style="text-align: center;">有符号</td><td style="text-align: center;">4字节</td><td style="text-align: center;">-2147483648 到2147483647(-2<sup>31</sup> ~ 2<sup>31</sup>-1)</td></tr><tr><td style="text-align: center;">int64</td><td style="text-align: center;">有符号</td><td style="text-align: center;">8字节</td><td style="text-align: center;">-2<sup>63</sup> ~ 2<sup>63</sup>-1</td></tr></tbody></table><p>其他整数类型：</p><table><thead><tr><th style="text-align: center;">类型</th><th style="text-align: center;">有无符号</th><th style="text-align: center;">占用存储空间</th><th style="text-align: center;">表示范围</th></tr></thead><tbody><tr><td style="text-align: center;">int</td><td style="text-align: center;">有符号</td><td style="text-align: center;">32位机占4字节，64位机占8字节</td><td style="text-align: center;">(-2<sup>31</sup> ~ 2<sup>31</sup>-1)  (-2<sup>63</sup> ~ 2<sup>63</sup>-1)</td></tr><tr><td style="text-align: center;">uint</td><td style="text-align: center;">无符号</td><td style="text-align: center;">32位机占4字节，64位机占8字节</td><td style="text-align: center;">(0~2<sup>32</sup> -1)  ( 0 ~2<sup>64</sup>-1)</td></tr><tr><td style="text-align: center;">rune</td><td style="text-align: center;">有符号</td><td style="text-align: center;">等价 int32</td><td style="text-align: center;">-2<sup>31</sup> ~ 2<sup>31</sup>-1</td></tr><tr><td style="text-align: center;">byte</td><td style="text-align: center;">无符号</td><td style="text-align: center;">等价 uint8</td><td style="text-align: center;">0 - 255</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// 整型默认类型</span><br><span class="hljs-keyword">var</span> num1 = <span class="hljs-number">1</span><br><span class="hljs-comment">// 打印数据类型、内存占用大小  （64 位机)</span><br>fmt.Printf(<span class="hljs-string">&quot;num1 数据类型：%T，内存占用空间：%d&quot;</span>, num1, unsafe.Sizeof(num1))<br><span class="hljs-comment">// num1 数据类型：int，内存占用空间：8</span><br><br><span class="hljs-keyword">var</span> num2 <span class="hljs-keyword">int8</span> = <span class="hljs-number">128</span><br><span class="hljs-comment">// 编译报错：constant 128 overflows int8</span><br>fmt.Println(num2)<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="浮点型">浮点型</h5><table><thead><tr><th style="text-align: center;">类型</th><th style="text-align: center;">占用存储空间</th><th style="text-align: center;">表示范围</th></tr></thead><tbody><tr><td style="text-align: center;">float32</td><td style="text-align: center;">4字节</td><td style="text-align: center;">-3.403E38 ~ 3.403E38</td></tr><tr><td style="text-align: center;">float64</td><td style="text-align: center;">8字节</td><td style="text-align: center;">-1.798E308 ~ 1.798E308</td></tr><tr><td style="text-align: center;">complex64</td><td style="text-align: center;">8字节</td><td style="text-align: center;">32 位实数和虚数</td></tr><tr><td style="text-align: center;">complex128</td><td style="text-align: center;">16字节</td><td style="text-align: center;">64 位实数和虚数</td></tr></tbody></table><p>浮点类型存储：符号位+指数位+尾数位，所以可能会出现精度损失</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">//定义浮点类型的数据：</span><br><span class="hljs-keyword">var</span> num1 <span class="hljs-keyword">float32</span> = <span class="hljs-number">3.14</span><br>fmt.Println(num1)<br><span class="hljs-comment">//浮点数可以用十进制表示形式，也可以用科学计数法表示形式  E 大写小写都可以的</span><br><span class="hljs-keyword">var</span> num2 <span class="hljs-keyword">float32</span> = <span class="hljs-number">-314E-2</span><br>fmt.Println(num2)<br><br><span class="hljs-comment">//浮点数可能会有精度的损失，所以通常情况下，建议你使用：float64</span><br><span class="hljs-keyword">var</span> num3 <span class="hljs-keyword">float32</span> = <span class="hljs-number">256.000000916</span><br>fmt.Println(num3)  <span class="hljs-comment">// 256</span><br><span class="hljs-keyword">var</span> num4 <span class="hljs-keyword">float64</span> = <span class="hljs-number">256.000000916</span><br>fmt.Println(num4)  <span class="hljs-comment">// 256.000000916</span><br><br><span class="hljs-comment">// 默认的浮点类型为：float64</span><br><span class="hljs-keyword">var</span> num5 = <span class="hljs-number">3.17</span><br>fmt.Printf(<span class="hljs-string">&quot;num9对应的默认的类型为：%T&quot;</span>,num5)<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// complex定义复数类型使用的关键字。</span><br><span class="hljs-keyword">var</span> score <span class="hljs-keyword">complex64</span> = <span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">var</span> number <span class="hljs-keyword">complex128</span> = <span class="hljs-built_in">complex</span>(<span class="hljs-number">23.23</span>, <span class="hljs-number">11.11</span>)<br>fmt.Print(<span class="hljs-string">&quot;Score = &quot;</span>, score, <span class="hljs-string">&quot; Number = &quot;</span>, number, <span class="hljs-string">&quot;\n&quot;</span>)<br><span class="hljs-comment">// Score = (1+2i) Number = (23.23+11.11i)</span><br><br><span class="hljs-comment">// 使用 real 获取复数的实部，使用 imag 获取复数的虚部。</span><br>fmt.Print(<span class="hljs-string">&quot;Real Score = &quot;</span>, <span class="hljs-built_in">real</span>(score), <span class="hljs-string">&quot; Image Score = &quot;</span>, <span class="hljs-built_in">imag</span>(score), <span class="hljs-string">&quot;\n&quot;</span>)<br><span class="hljs-comment">// Real Score = 1 Image Score = 2</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="字符类型">字符类型</h5><p>Golang中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte来保存（Unicode 码）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//定义字符类型的数据：</span><br><span class="hljs-keyword">var</span> c1 <span class="hljs-keyword">byte</span> = <span class="hljs-string">&#x27;a&#x27;</span><br>fmt.Printf(<span class="hljs-string">&quot;c1 的值：%d ,对应的具体的字符为：%c&quot;</span>, c1, c1)<br><span class="hljs-comment">// c1 的值：97 ,对应的具体的字符为：a</span><br><br><span class="hljs-comment">//定义字符类型的数据：</span><br><span class="hljs-keyword">var</span> c2 <span class="hljs-keyword">int16</span> = <span class="hljs-string">&#x27;中&#x27;</span><br>fmt.Printf(<span class="hljs-string">&quot;c1 的值：%d ,对应的具体的字符为：%c&quot;</span>, c2, c2)<br><span class="hljs-comment">// c1 的值：20013 ,对应的具体的字符为：中</span><br><br><span class="hljs-keyword">var</span> int1 <span class="hljs-keyword">int</span> = <span class="hljs-string">&#x27;中&#x27;</span><br>fmt.Println(int1)<br><span class="hljs-comment">// 20013</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>java 中的字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> code = <span class="hljs-string">&#x27;中&#x27;</span>;<br>    System.out.println(code);<br>    <span class="hljs-comment">// 20013</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>转义字符</strong></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211228130016.png" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//\b 退格</span><br>fmt.Println(<span class="hljs-string">&quot;aaa\bbbb&quot;</span>)<br><span class="hljs-comment">//\r 光标回到本行的开头，后续输入就会替换原有的字符</span><br>fmt.Println(<span class="hljs-string">&quot;aaaaa\rbbb&quot;</span>)<br><span class="hljs-comment">//\t 制表符</span><br>fmt.Println(<span class="hljs-string">&quot;aaaaaaaabbbbbbbbcccccccc&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;aaaaa\tbbbbb&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;aaaaaaaa\tbbbbb&quot;</span>)<br><span class="hljs-comment">//\&quot;</span><br>fmt.Println(<span class="hljs-string">&quot;\&quot;Golang\&quot;&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211228130737.png" /></p><h5 id="布尔类型">布尔类型</h5><p>布尔型的值只可以是常量 true 或者 false。 布尔类型占1个字节</p><h5 id="字符串类型">字符串类型</h5><p>【注意】go 中 字符串是基本数据类型 <figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">func <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> &#123;<br><br><span class="hljs-comment">//1.定义一个字符串：</span><br><span class="hljs-keyword">var</span> s1 <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;hello world&quot;</span><br>fmt.Println(s1)<br><br><span class="hljs-comment">//2.字符串的表示形式：</span><br><span class="hljs-comment">//（1）如果字符串中没有特殊字符，字符串的表示形式用双引号</span><br><span class="hljs-comment">//（2）如果字符串中有特殊字符，字符串的表示形式用反引号 ``</span><br><span class="hljs-keyword">var</span> s4 <span class="hljs-built_in">string</span> = `<br>        package main<br>        import <span class="hljs-string">&quot;fmt&quot;</span> <br>        <span class="hljs-function">func <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>        &#125;<br>        `<br>fmt.Println(s4)<br><br><span class="hljs-comment">//3.字符串的拼接：</span><br><span class="hljs-keyword">var</span> s5 <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span><br>s5 += <span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-comment">//当一个字符串过长的时候：注意：+保留在上一行的最后</span><br><span class="hljs-keyword">var</span> s6 <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span> + <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span> + <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span> + <span class="hljs-string">&quot;abc&quot;</span> +<br><span class="hljs-string">&quot;def&quot;</span> + <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span> + <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span><br>fmt.Println(s6)<br><br>&#125;<br></code></pre></td></tr></table></figure> #####数据类型转换</p><h6 id="数值类型之间转换">数值类型之间转换</h6><p>Go在不同类型的变量之间赋值时需要显式转换，并且只有显式转换(强制转换)。</p><p>语法：T(v) T : 数据类型 v : 需要转换的变量 将值 v 转换为类型 T</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//进行类型转换：</span><br><span class="hljs-keyword">var</span> n1 <span class="hljs-keyword">int</span> = <span class="hljs-number">100</span><br><span class="hljs-comment">//var n2 float32 = n1  // 无法直接转换</span><br><br><span class="hljs-keyword">var</span> n2 <span class="hljs-keyword">float32</span> = <span class="hljs-keyword">float32</span>(n1)<br>fmt.Println(n2)<br><br><span class="hljs-comment">//将int64转为int8的时候，编译不会出错的，但是会数据的溢出</span><br><span class="hljs-keyword">var</span> n3 <span class="hljs-keyword">int64</span> = <span class="hljs-number">888888</span><br><span class="hljs-keyword">var</span> n4 <span class="hljs-keyword">int8</span> = <span class="hljs-keyword">int8</span>(n3)<br>fmt.Println(n4) <span class="hljs-comment">//56</span><br><br><span class="hljs-keyword">var</span> n5 <span class="hljs-keyword">int32</span> = <span class="hljs-number">12</span><br><span class="hljs-keyword">var</span> n6 <span class="hljs-keyword">int64</span> = <span class="hljs-keyword">int64</span>(n5) + <span class="hljs-number">30</span> <span class="hljs-comment">//一定要匹配=左右的数据类型</span><br>fmt.Println(n6)<br><br><span class="hljs-keyword">var</span> n7 <span class="hljs-keyword">int64</span> = <span class="hljs-number">12</span><br><span class="hljs-keyword">var</span> n8 <span class="hljs-keyword">int8</span> = <span class="hljs-keyword">int8</span>(n7) + <span class="hljs-number">127</span> <span class="hljs-comment">//编译通过，但是结果可能会溢出</span><br><span class="hljs-comment">//var n9 int8 = int8(n7) + 128 //编译不会通过</span><br>fmt.Println(n8) <span class="hljs-comment">// -117</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="数值类型转换为-string">数值类型转换为 string</h6><p>方式1：fmt.Sprintf("%参数",表达式) 方式2：使用 strconv 包的函数<br />参数参考：https://studygolang.com/pkgdoc</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211228134900.png" /></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> n1 <span class="hljs-keyword">int</span> = <span class="hljs-number">19</span><br><span class="hljs-keyword">var</span> n2 <span class="hljs-keyword">float64</span> = <span class="hljs-number">4.78</span><br><span class="hljs-keyword">var</span> s1 <span class="hljs-keyword">string</span> = fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, n1)<br>fmt.Printf(<span class="hljs-string">&quot;s1对应的类型是：%T ，s1 = %#v \n&quot;</span>, s1, s1)<br><span class="hljs-keyword">var</span> s2 <span class="hljs-keyword">string</span> = fmt.Sprintf(<span class="hljs-string">&quot;%f&quot;</span>, n2)<br>fmt.Printf(<span class="hljs-string">&quot;s2对应的类型是：%T ，s2 = %q \n&quot;</span>, s2, s2)<br><br><span class="hljs-keyword">var</span> n3 <span class="hljs-keyword">bool</span> = <span class="hljs-literal">true</span><br><span class="hljs-keyword">var</span> s3 <span class="hljs-keyword">string</span> = strconv.FormatBool(n3)<br>fmt.Printf(<span class="hljs-string">&quot;s3对应的类型是：%T ，s3 = %q \n&quot;</span>, s3, s3)<br><span class="hljs-keyword">var</span> s4 <span class="hljs-keyword">string</span> = strconv.FormatInt(<span class="hljs-keyword">int64</span>(n1), <span class="hljs-number">10</span>) <span class="hljs-comment">//参数：第二个参数指定字面值的进制形式为十进制</span><br>fmt.Printf(<span class="hljs-string">&quot;s1对应的类型是：%T ，s1 = %q \n&quot;</span>, s4, s4)<br><span class="hljs-keyword">var</span> s5 <span class="hljs-keyword">string</span> = strconv.FormatFloat(n2, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">9</span>, <span class="hljs-number">64</span>)<br><span class="hljs-comment">//第二个参数：&#x27;f&#x27;（-ddd.dddd）  第三个参数：9 保留小数点后面9位  第四个参数：表示这个小数是float64类型</span><br>fmt.Printf(<span class="hljs-string">&quot;s2对应的类型是：%T ，s2 = %q \n&quot;</span>, s5, s5)<br><span class="hljs-comment">// 4.780000000</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="string-类型转数值类型">string 类型转数值类型</h6><p>方式：使用 strconv 包的函数</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211228140047.png" /></p><p>注意：string向基本数据类型转换的时候，一定要确保 string类型能够转成有效的数据类型，否则最后得到的结果就是按照对应类型的默认值输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//string--&gt;bool</span><br><span class="hljs-keyword">var</span> s1 <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;true&quot;</span><br><span class="hljs-comment">//ParseBool这个函数的返回值有两个：(value bool, err error)</span><br>b, _ := strconv.ParseBool(s1)<br>fmt.Printf(<span class="hljs-string">&quot;b的类型是：%T,b=%v \n&quot;</span>, b, b)<br><br><span class="hljs-comment">//string---》int</span><br><span class="hljs-keyword">var</span> s2 <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;-19&quot;</span><br>num1, _ := strconv.ParseInt(s2, <span class="hljs-number">10</span>, <span class="hljs-number">64</span>)<br>fmt.Printf(<span class="hljs-string">&quot;num1的类型是：%T,num1=%v \n&quot;</span>, num1, num1)<br><br><span class="hljs-comment">//string--&gt;float32/float64</span><br><span class="hljs-keyword">var</span> s3 <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;3.14&quot;</span><br>f1, _ := strconv.ParseFloat(s3, <span class="hljs-number">64</span>)<br>fmt.Printf(<span class="hljs-string">&quot;f1的类型是：%T,f1=%v \n&quot;</span>, f1, f1)<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="复杂数据类型">3.2 复杂数据类型</h4><h5 id="指针">指针</h5><p>基本数据类型都有对应的指针类型，形式为 *数据类型</p><p>基本数据类型和指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> age <span class="hljs-keyword">int</span> = <span class="hljs-number">18</span><br><span class="hljs-comment">//&amp;符号+变量 就可以获取这个变量内存的地址</span><br>fmt.Println(&amp;age) <span class="hljs-comment">//0xc0000a2058</span><br>&#125;<br></code></pre></td></tr></table></figure><p>指针变量： 1. &amp; 取内存地址 2. * 根据地址取值</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> age <span class="hljs-keyword">int</span> = <span class="hljs-number">18</span><br><br><span class="hljs-comment">//定义一个指针变量：</span><br><span class="hljs-comment">//ptr 指针变量的名字</span><br><span class="hljs-comment">//ptr对应的类型是：*int 是一个指针类型 （可以理解为 指向int类型的指针）</span><br><span class="hljs-comment">//&amp;age 就是一个地址，是 ptr 变量的具体的值</span><br><span class="hljs-keyword">var</span> ptr *<span class="hljs-keyword">int</span> = &amp;age<br>fmt.Println(ptr)<span class="hljs-comment">// 0xc0000a2058</span><br>fmt.Println(<span class="hljs-string">&quot;ptr 存储空间的地址为：&quot;</span>, &amp;ptr) <br><span class="hljs-comment">// 获取指针指向的变量的值</span><br>fmt.Printf(<span class="hljs-string">&quot;ptr指向的数值为：%v&quot;</span>, *ptr) <span class="hljs-comment">//ptr指向的数值为：18</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211228142655.png" /></p><p>通过指针改变指向值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> num <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><br>aa(num)<br>fmt.Println(num)<span class="hljs-comment">// 10</span><br>bb(&amp;num)<br>fmt.Println(num)<span class="hljs-comment">// 200</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">aa</span><span class="hljs-params">(int2 <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>int2 = <span class="hljs-number">100</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bb</span><span class="hljs-params">(int2 *<span class="hljs-keyword">int</span>)</span></span>  &#123;<br>*int2 = <span class="hljs-number">200</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——模板模式</title>
    <link href="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="模式定义">1. 模式定义</h3><p>定义一个操作的算法骨架，而将一些步骤延迟到子类中。Template Method使得子类可以不改变一个算法的结构即可重定义该算法的某些 特定步骤。</p><p><strong>优点：</strong> 1. 封装不变部分，扩展可变部分。 2.提取公共代码，便于维护。 3. 行为由父类控制，子类实现。</p><p><strong>缺点：</strong> +每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211217214833.png" /></p><h3 id="示例">2. 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 猫和少年</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-12-17 21:35</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Slogan</span> 才疏学浅，少年登科；满腹经纶，白发不第</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AbstractClass abstractClass = <span class="hljs-keyword">new</span> SubClass();<br>        abstractClass.option();<br><br>        abstractClass = <span class="hljs-keyword">new</span> SubClass2();<br>        abstractClass.option();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClass</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">option</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 准备工作</span><br>        System.out.println(<span class="hljs-string">&quot;pre .......&quot;</span>);<br>        templateMethod();<br>        <span class="hljs-comment">// 结尾工作</span><br>        System.out.println(<span class="hljs-string">&quot;teardown.....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">templateMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClass</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">templateMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;subclass  executed...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">SubClass2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClass</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">templateMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;subclass2  executed...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="jdk-中的应用">3. JDK 中的应用</h3><p><strong>HttpServlet</strong></p><p>通过继承 HttpServlet ，并实现 doGet 等方法来支持相应的请求。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/GenericServlet.png" /></p><p><strong>HttpServlet 响应流程</strong> 1. Web 客户向 Servlet容器发出Http请求 2. Servlet 容器解析 Web 客户的 Http 请求 3. Servlet容器创建一个 HttpRequest 对象，封装 Http 请求信息 4. Servlet容器创建一个 HttpResponse 对象 5. Servlet 容器调用 HttpServlet 的service 方法，把 HttpRequest 和 HttpResponse 对象作为 service方法的参数传给 HttpServlet 对象 6. HttpServle t调用 HttpRequest的有关方法，获取HTTP请求信息 7. HttpServlet 调用 HttpResponse的有关方法，生成响应数据 8. Servlet 容器把 HttpServle t的响应结果传给Web 客户</p><p>其中HttpServlet首先必须读取Http请求的内容，Servlet容器负责创建HttpServlet对象，并把Http请求直接封装到HttpServlet对象中。</p><p><strong>创建 HttpServlet 步骤</strong> 1. 继承 HttpServlet 抽象类 2.重写 HttpServlet 的部分方法，如 doGet() 或 doPost() 方法 3. 获取 HTTP请求信息。通过 HttpServletRequest 对象来检索 HTML 表单所提交的数据或 URL上的查询字符串 4. 生成 HTTP 响应结果。通过 HttpServletResponse对象生成响应结果</p><h3 id="spring-中的应用">4. Spring 中的应用</h3><p><strong>AbstractController</strong> 通过继承 AbstractController并重写 handleRequestInternal 方法，实现 Controller。AbstractController包装的功能：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211217234313.png" /></p><p>AbstractController 继承关系：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/AbstractController.png" /></p><p><ahref="https://www.cnblogs.com/yif0118/p/12494239.html">SpringMVC实现Controller方式</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>行为型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——责任链模式</title>
    <link href="/2021/12/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/12/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="模式定义">1. 模式定义</h3><p>为请求创建了一个接收者对象的链。为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p><strong>优点：</strong> 1. 降低耦合。它将请求的发送者和接收者解耦。2. 可以控制执行顺序。可以动态增删责任以及调动他们的顺序。 5.符合开闭原则和单一职责原则</p><p><strong>缺点：</strong> 1. 不能保证请求一定被接收。 2.系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。3. 可能不容易观察运行时的特征，有碍于除错。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/WPS图片编辑.png" /></p><p>使用场景：1、有多个对象处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。3、可动态指定一组对象处理请求。</p><h3 id="示例">2. 示例</h3><p>在请求业务前，需要对请求进行请求频率控制、登录认证、访问权限验证、敏感词过滤等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChainOfResponsibility</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Request request = <span class="hljs-keyword">new</span> Request.RequestBuilder().frequentOK(<span class="hljs-keyword">true</span>).loggedOn(<span class="hljs-keyword">false</span>).build();<br><br>        RequestFrequentHandler requestFrequentHandler = <span class="hljs-keyword">new</span> RequestFrequentHandler(<span class="hljs-keyword">new</span> LoggingHandler(<span class="hljs-keyword">null</span>));<br><br>        <span class="hljs-keyword">if</span> (requestFrequentHandler.process(request)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;业务正常处理&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;访问异常&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>责任定义: <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    Handler next;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(Handler next)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Handler <span class="hljs-title">getNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Handler next)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Request request)</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestFrequentHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RequestFrequentHandler</span><span class="hljs-params">(Handler next)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(next);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Request request)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;访问频率验证&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (request.isFrequentOK()) &#123;<br>            Handler next = getNext();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == next) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> next.process(request);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoggingHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoggingHandler</span><span class="hljs-params">(Handler next)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(next);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Request request)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;登录验证&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (request.isLoggedOn()) &#123;<br>            Handler next = getNext();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == next) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> next.process(request);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> 请求定义： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> loggedOn;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> frequentOK;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isPermits;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> containsSensitiveWords;<br>    <span class="hljs-keyword">private</span> String requestBody;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Request</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> loggedOn, <span class="hljs-keyword">boolean</span> frequentOK, <span class="hljs-keyword">boolean</span> isPermits, <span class="hljs-keyword">boolean</span> containsSensitiveWords)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loggedOn = loggedOn;<br>        <span class="hljs-keyword">this</span>.frequentOK = frequentOK;<br>        <span class="hljs-keyword">this</span>.isPermits = isPermits;<br>        <span class="hljs-keyword">this</span>.containsSensitiveWords = containsSensitiveWords;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestBuilder</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> loggedOn;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> frequentOK;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isPermits;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> containsSensitiveWords;<br><br>        <span class="hljs-function">RequestBuilder <span class="hljs-title">loggedOn</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> loggedOn)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.loggedOn = loggedOn;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function">RequestBuilder <span class="hljs-title">frequentOK</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> frequentOK)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.frequentOK = frequentOK;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function">RequestBuilder <span class="hljs-title">isPermits</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isPermits)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.isPermits = isPermits;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function">RequestBuilder <span class="hljs-title">containsSensitiveWords</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> containsSensitiveWords)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.containsSensitiveWords = containsSensitiveWords;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Request <span class="hljs-title">build</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Request(loggedOn,frequentOK,isPermits,containsSensitiveWords);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/* getter  setter */</span><br><br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="jdk-中应用">3. JDK 中应用</h3><p>javax.servlet.FilterChain javax.servlet.Filter</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211215232225.png" /></p><p>通过数组实现责任链表</p><h3 id="spring-中的应用">4. Spring 中的应用</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211218232612.png" /></p><p>https://blog.csdn.net/u014082714/article/details/103463378</p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>行为型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GO——入门</title>
    <link href="/2021/12/13/GO%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"/>
    <url>/2021/12/13/GO%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="认识-go-语言">1. 认识 Go 语言</h3><h4 id="go-语言的-logo">1.1 GO 语言的 logo</h4><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211214223325.png" />#### 1.2 Go 语言的吉祥物 <imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211214223153.png" /></p><p>gopher 是一种生活在加拿大的小动物，中文名叫做囊地鼠。 ### 2. Go语言特性 &gt; + 自动垃圾回收 &gt; + 更丰富的内置类型 &gt; + 函数多返回值&gt; + 错误处理 &gt; + 匿名函数和闭包 &gt; + 类型和接口 &gt; + 并发编程&gt; + 反射 &gt; + 语言交互性</p><h3 id="语言结构">3. 语言结构</h3><p>基础组成有以下几个部分：</p><ul><li>包声明</li><li>引入包</li><li>函数</li><li>变量</li><li>语句 &amp; 表达式</li><li>注释</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 必须在源文件中非注释的第一行指明这个文件属于哪个包，每个 Go 应用程序都包含一个名为 main 的包。</span><br><span class="hljs-keyword">package</span> main<br><span class="hljs-comment">// 引入包</span><br><span class="hljs-keyword">import</span>  <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-comment">// 每一个可执行程序必须包含 main 函数是</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br> fmt.Println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>注释：多行注释（/*...*/）和单行注释（//）</li><li>分隔符：在 Go程序中，一行代表一个语句结束。如果一行只有一个语句，结尾不需要显式加分号（;），但是多个语句写在同一行，则必须使用; 区分。</li><li>标识符：标识符由一个或是多个字母、数字、下划线组成的序列，并且第一个字符必须是字母或下划线而不能是数字。</li><li>当标识符（包括常量、变量、类型、函数名、结构字段等等）以大写字母开头，它就可以被外部包的代码所使用（类似java 中的public）；标识符如果以小写字母开头，则对包外是不可见的（类似java 的 protected ）。</li></ul></blockquote><p><font color = "red"><strong>注意：</strong></font> {不能单独放在一行，否则编译错误 <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br>&#123;<br> fmt.Println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="执行-go-程序">4. 执行 GO 程序</h3><ol type="1"><li>先编译再执行</li><li>编译运行一起执行</li></ol><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211214231117.png" /></p><h3 id="关键字">关键字</h3><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211213234710.png" /></p><p>Golang中文网在线标准库文档: https://studygolang.com/pkgdoc</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——策略模式</title>
    <link href="/2021/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="模式定义">1. 模式定义</h3><p>定义了算法族，分别封装起来，让他们之间可以相互替换，此模式的变化独立于算法的使用者。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211211121318.png" /></p><p>解决场景：一般是具有同类可替代的行为逻辑算法场景。比如；不同类型的交易方式（信用卡、支付宝、微信）、生成唯一ID 策略（UUID、DB自增、DB+Redis、雪花算法、Leaf算法）等，都可以使用策略模式进行行为包装，供给外部使用。</p><h3 id="示例">2. 示例</h3><p>场景：模拟在购买商品时使用各种类型优惠券(满减、直减、折扣、n元购)，</p><h4 id="一般实现">2.1 一般实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CouponDiscountService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">disCountAmount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">double</span> typeContent, <span class="hljs-keyword">double</span> skuPrice, <span class="hljs-keyword">double</span> typeExt)</span> </span>&#123;<br>        <span class="hljs-comment">// 直减</span><br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> skuPrice - typeContent;<br>        &#125;<br>        <span class="hljs-comment">// 满减</span><br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> skuPrice &lt; typeContent ? skuPrice : skuPrice - typeContent;<br>        &#125;<br>        <span class="hljs-comment">// 折扣</span><br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> skuPrice * typeContent;<br>        &#125;<br>        <span class="hljs-comment">// n 元购</span><br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">return</span> typeContent;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="策略模式重构代码">2.2 策略模式重构代码</h4><p><strong>优惠券接口</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 优惠券金额计算</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> couponInfo 优惠券信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> skuPrice skuji金额</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>   折扣金额</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(T couponInfo,BigDecimal skuPrice)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><strong>优惠券接口实现</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MJCouponDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">Map</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">String</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 满减计算</span><br><span class="hljs-comment">     * 1. 判断满⾜x元后-n元，否则不减</span><br><span class="hljs-comment">     * 2. 最低⽀付⾦额1元</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(Map&lt;String, String&gt; couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br>        String condition = couponInfo.get(<span class="hljs-string">&quot;condition&quot;</span>);<br>        String amount = couponInfo.get(<span class="hljs-string">&quot;amount&quot;</span>);<br>        <span class="hljs-comment">// ⼩于商品⾦额条件的，直接返回商品原价</span><br>        <span class="hljs-keyword">if</span> (skuPrice.compareTo(<span class="hljs-keyword">new</span> BigDecimal(condition)) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> skuPrice;<br>        <span class="hljs-comment">// 减去优惠⾦额判断</span><br>        BigDecimal discountAmount = skuPrice.subtract(<span class="hljs-keyword">new</span> BigDecimal(amount));<br>        <span class="hljs-keyword">if</span> (discountAmount.compareTo(BigDecimal.ZERO) &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span><br>                BigDecimal.ONE;<br>        <span class="hljs-keyword">return</span> discountAmount;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZJCouponDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">Double</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 直减计算</span><br><span class="hljs-comment">     * 1. 使用商品价格减去优惠价格</span><br><span class="hljs-comment">     * 2. 最低⽀付⾦额1元</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(Double couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br>        BigDecimal discountAmount = skuPrice.subtract(<span class="hljs-keyword">new</span> BigDecimal(couponInfo));<br><br>        <span class="hljs-keyword">if</span> (discountAmount.compareTo(BigDecimal.ONE) &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> BigDecimal.ONE;<br>        &#125;<br>        <span class="hljs-keyword">return</span> discountAmount;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZKCouponDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">Double</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 折扣计算</span><br><span class="hljs-comment">     * 1. 使⽤商品价格乘以折扣⽐例，为最后⽀付⾦额</span><br><span class="hljs-comment">     * 2. 保留两位⼩数</span><br><span class="hljs-comment">     * 3. 最低⽀付⾦额1元</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(Double couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br><br>        BigDecimal discountAmount = skuPrice.multiply(<span class="hljs-keyword">new</span> BigDecimal(couponInfo)).<br>                setScale(<span class="hljs-number">2</span>, BigDecimal.ROUND_HALF_UP);<br>        <span class="hljs-keyword">if</span> (discountAmount.compareTo(BigDecimal.ONE) &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> BigDecimal.ONE;<br>        &#125;<br>        <span class="hljs-keyword">return</span> discountAmount;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NYGCouponDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">Double</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * n 元购购买</span><br><span class="hljs-comment">     * 1. ⽆论原价多少钱都固定⾦额购买</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(Double couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BigDecimal(couponInfo);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure></p><p><strong>策略控制类</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> CouponDiscount&lt;T&gt; couponDiscount;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span><span class="hljs-params">(CouponDiscount&lt;T&gt; couponDiscount)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.couponDiscount = couponDiscount;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(T couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> couponDiscount.discountAmount(couponInfo, skuPrice);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> <strong>测试验证</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContextTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">discountAmount</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">// 直减；100-10，商品100元</span><br>        Context&lt;Double&gt; context = <span class="hljs-keyword">new</span> Context&lt;Double&gt;(<span class="hljs-keyword">new</span> ZJCouponDiscount());<br>        BigDecimal discountAmount = context.discountAmount(<span class="hljs-number">10D</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>));<br>        Assert.assertTrue(discountAmount.equals(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">90</span>)));<br><br>        <span class="hljs-comment">// 满100减10，商品100元</span><br>        Context&lt;Map&lt;String, String&gt;&gt; context1 = <span class="hljs-keyword">new</span> Context&lt;Map&lt;String, String&gt;&gt;(<span class="hljs-keyword">new</span> MJCouponDiscount());<br>        Map&lt;String, String&gt; mapReq = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();<br>        mapReq.put(<span class="hljs-string">&quot;condition&quot;</span>, <span class="hljs-string">&quot;100&quot;</span>);<br>        mapReq.put(<span class="hljs-string">&quot;amount&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>);<br>        BigDecimal discountAmount1 = context1.discountAmount(mapReq, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">90</span>));<br>        Assert.assertTrue(discountAmount1.equals(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">90</span>)));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>通过策略设计模式的使用可以把方法中的 if 语句优化掉，大量的 if语句使用会让代码难以扩展，也不好维护，同时在后期遇到各种问题也很难维护。在使用这样的设计模式后可以很好的满足隔离性与和扩展性，对于不断新增的需求也非常方便承接。</p><h3 id="jdk中的应用">3. JDK中的应用</h3><p>排序时通过实现排序接口生成不同的排序类，以达到按不同的属性排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComparatorTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Person[] people = <span class="hljs-keyword">new</span> Person[]&#123;<span class="hljs-keyword">new</span> Person(<span class="hljs-number">10</span>,<span class="hljs-number">111</span>),<span class="hljs-keyword">new</span> Person(<span class="hljs-number">18</span>,<span class="hljs-number">99</span>),<span class="hljs-keyword">new</span> Person(<span class="hljs-number">15</span>,<span class="hljs-number">122</span>)&#125;;<br><br>        System.out.println(Arrays.toString(people));<br>        Arrays.sort(people,<span class="hljs-keyword">new</span> SortByAge());<br>        System.out.println(Arrays.toString(people));<br>        Arrays.sort(people,<span class="hljs-keyword">new</span> SortByHeight());<br>        System.out.println(Arrays.toString(people));<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  [Person&#123;age=10, height=111&#125;, Person&#123;age=18, height=99&#125;, Person&#123;age=15, height=122&#125;]</span><br><span class="hljs-comment">            [Person&#123;age=10, height=111&#125;, Person&#123;age=15, height=122&#125;, Person&#123;age=18, height=99&#125;]</span><br><span class="hljs-comment">            [Person&#123;age=15, height=122&#125;, Person&#123;age=10, height=111&#125;, Person&#123;age=18, height=99&#125;]</span><br><span class="hljs-comment">         */</span><br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortByHeight</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Person</span>&gt;</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person o1, Person o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span>  o1.getHeight()-o2.getHeight();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortByAge</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Person</span>&gt;</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person o1, Person o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> o1.getAge()-o2.getAge();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">int</span> height;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> height)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.height = height;<br>    &#125;<br>    <br>    <span class="hljs-comment">/* getter setter  toString */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="spring-中的应用">4. Spring 中的应用</h3><h4 id="instantiationstrategy">4.1 InstantiationStrategy</h4><p>接口 InstantiationStrategy是实例化策略接口类，它定义了三种实例化方式，SimpleInstantiationStrategy实现了该策略，CglibSubclassingInstantiationStrategy 又继承了SimpleInstantiationStrategy 新增了根据 cglib 生成代理类实例化方法。</p><p><a href="https://my.oschina.net/chengxiaoyuan/blog/823655">实例化策略InstantiationStrategy</a></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211211125722.png" /></p><p>如果工厂方法实例化直接用反射创建对象，如果是构造方法实例化的则判断是否有MethodOverrides，如果没有MethodOverrides 也是直接用反射，如果有MethodOverrides 就需要用 cglib 实例化对象，SimpleInstantiationStrategy把通过 cglib 实例化的任务交给了它的子类CglibSubclassingInstantiationStrategy。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211211224848.png" /></p><h4 id="aop代理策略">4.2 Aop代理策略</h4><p>首先 AopProxyFactory 接口类提供了 createAopProxy接口，这个是策略模式的接口方法。DefaultAopProxyFactory实现了该接口作为策略的实现者。ProxyCreatorSupport 里面引用了AopProxyFactory，并且提供了 get、set 方法用来运行时改变策略。这里 Spring只实现了 DefaultAopProxyFactory 这一个策略，如果需要自己也可以实现。</p><p>DefaultAopProxyFactory 里面的 createAopProxy的逻辑如下，可以在运行时根据参数决定用 Cglib 策略还是 JDK动态代理策略生成代理类： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> AopProxy <span class="hljs-title">createAopProxy</span><span class="hljs-params">(AdvisedSupport config)</span> <span class="hljs-keyword">throws</span> AopConfigException </span>&#123;<br><br><br>        <span class="hljs-comment">//如果XML打开了优化开关，或者设置为了代理目标类，或者目前类没有接口</span><br>        <span class="hljs-keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;<br>            Class&lt;?&gt; targetClass = config.getTargetClass();<br>            <span class="hljs-keyword">if</span> (targetClass == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopConfigException(<span class="hljs-string">&quot;TargetSource cannot determine target class: &quot;</span> +<br>                        <span class="hljs-string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-comment">//如果有接口，或者通过Proxy.newProxyInstance生成的，则使用jdk动态代理</span><br>            <span class="hljs-keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);<br>            &#125;<br><br>            <span class="hljs-comment">//使用cglib</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObjenesisCglibAopProxy(config);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//使用jdk动态代理</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure> 另外 AopProxy也是一个策略接口类，具体实现的策略为JdkDynamicAopProxy、CglibAopProxy、ObjenesisCglibAopProxy。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211211231617.png" /></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>行为型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——泛型</title>
    <link href="/2021/12/09/java%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B/"/>
    <url>/2021/12/09/java%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="理解泛型">1.理解泛型</h3><p>什么是泛型？为什么要使用泛型？</p><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性,泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</p><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化（称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><p>泛型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><blockquote><p>注意：<br />泛型的类型参数只能是类类型，不能是简单类型。 不能对确切的泛型类型使用instanceof 操作。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; strings = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><span class="hljs-comment">// 编译报错：Illegal generic type for instanceo</span><br><span class="hljs-keyword">if</span> (strings <span class="hljs-keyword">instanceof</span> List&lt;String&gt;) &#123;&#125;<br></code></pre></td></tr></table></figure></p></blockquote><h3 id="泛型类">2. 泛型类</h3><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。泛型类的类型参数声明部分可以包含一个或多个类型参数，参数间用逗号隔开。</p><p>一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</p><p>通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p><p><strong>语法：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名称 &lt;泛型标识：可以是任意标识号&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> 泛型标识 <span class="hljs-comment">/*（成员变量类型）*/</span> <span class="hljs-keyword">var</span>;<br>    .....<br>&#125;<br></code></pre></td></tr></table></figure> <strong>示例：</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//key这个成员变量的类型为T,T的类型由外部指定</span><br>    <span class="hljs-keyword">private</span> T key;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Generic</span><span class="hljs-params">(T key)</span> </span>&#123; <span class="hljs-comment">// 构造方法形参类型也为T，由外部指定</span><br>        <span class="hljs-keyword">this</span>.key = key;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//传入的实参类型需与泛型的类型参数类型相同，即为 Integer.</span><br>Generic&lt;Integer&gt; genericInteger = <span class="hljs-keyword">new</span> Generic&lt;Integer&gt;(<span class="hljs-number">123456</span>);<br></code></pre></td></tr></table></figure></p><h3 id="泛型接口">3. 泛型接口</h3><p>泛型类型用于接口的定义中，被称为泛型接口。</p><p><strong>示例</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义泛型接口</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">// 实现接口一</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CarGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;car&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 实现接口二</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitGenerator</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> T next;<br><br><span class="hljs-comment">// 非泛型方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FruitGenerator</span><span class="hljs-params">(T next)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        FruitGenerator&lt;String&gt; fruit = <span class="hljs-keyword">new</span> FruitGenerator&lt;String&gt;(<span class="hljs-string">&quot;Fruit&quot;</span>);<br>        System.out.println(fruit.next);<br>        <span class="hljs-comment">// Fruit</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="泛型方法">4. 泛型方法</h3><p>泛型方法：是在调用方法的时候指明泛型的具体类型。&gt;泛型类：是在实例化类的时候指明泛型的具体类型。</p><h4 id="泛型方法的基本用法">4.1 泛型方法的基本用法</h4><p>泛型方法的定义规则： +所有泛型方法声明在方法返回类型之前都有类型参数声明部分（由尖括号分隔） +每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。 +类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</p><blockquote><p>java 中泛型标记符： + E - Element(在集合中使用，因为集合中存放的是元素) + T - Type（Java 类） + K -Key（键） + V - Value（值） + N - Number（数值类型） + ？ - 表示不确定的java 类型 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 泛型方法 printArray</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(E[] inputArray)</span></span>&#123;<br>    <span class="hljs-comment">// 输出数组元素</span><br>    Arrays.stream(inputArray).forEach(System.out::println);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>    <span class="hljs-comment">// 创建不同的数组</span><br>    Integer[] intArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br>    Double[] doubleArray = &#123; <span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">3.3</span>, <span class="hljs-number">4.4</span> &#125;;<br>    Character[] charArray = &#123; <span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span> &#125;;<br><br>    System.out.println(<span class="hljs-string">&quot;整型数组元素为：&quot;</span>);<br>    printArray(intArray);<br><br>    System.out.println(<span class="hljs-string">&quot;双精度型数组元素为：&quot;</span>);<br>    printArray(doubleArray);<br><br>    System.out.println(<span class="hljs-string">&quot;字符型数组元素为：&quot;</span>);<br>    printArray(charArray);<br>&#125;<br></code></pre></td></tr></table></figure> #### 4.2 泛型方法与可变参数</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMsg</span><span class="hljs-params">(T... args)</span></span>&#123;<br>       Arrays.stream(args).forEach(System.out::println);<br>   &#125;<br><br>printMsg(<span class="hljs-string">&quot;111&quot;</span>,<span class="hljs-number">111</span>,<span class="hljs-number">123.23</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">123L</span>);<br></code></pre></td></tr></table></figure><h4 id="静态方法与泛型">4.3 静态方法与泛型</h4><p>静态方法无法访问类上定义的泛型，如果静态方法操作的引用数据类型不确定时，必须将泛型定义在方法上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticGenerator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 编译错误：cannot be referenced from a static context</span><br>    <span class="hljs-comment">// public static void Show(T t) &#123;&#125;</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">(T t)</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="泛型通配符">5. 泛型通配符</h3><h4 id="用-代替具体的类型参数">5.1 用 ? 代替具体的类型参数</h4><p>此处’？’是类型实参，而不是类型形参。也就是说此处的？和Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    List&lt;String&gt; name = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    List&lt;Integer&gt; age = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    List&lt;Number&gt; number = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br><br>    name.add(<span class="hljs-string">&quot;zth&quot;</span>);<br>    age.add(<span class="hljs-number">18</span>);<br>    number.add(<span class="hljs-number">13</span>);<br>    getData(name);<br>    getData(age);<br>    getData(number);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getData</span><span class="hljs-params">(List&lt;?&gt; data)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;data: &quot;</span>+data.get(<span class="hljs-number">0</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="泛型的上边界">5.2 泛型的上边界</h4><p>通过形如 List &lt; ? extends Number&gt;来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; age = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Number&gt; number = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Double&gt; doubles = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    printNumber(age);<br>    printNumber(number);<br>    printNumber(doubles);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printNumber</span><span class="hljs-params">(List&lt;? extends Number&gt; data)</span> </span>&#123;<br>    data.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure></p><blockquote><p>Ingeter 是 Number 的一个子类，但是 Generic<Integer> 不能被看作为Generic<Number>的子类。由此可以看出：同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。</p></blockquote><h4 id="泛型的下边界">5.3 泛型的下边界</h4><p>通过形如 List&lt; ? super Number&gt; 来定义，表示类型只能接受 Number及其三层父类类型，如Objec类型的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Number&gt; number = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Object&gt; objects = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    printNumber(number);<br>    printNumber(objects);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printNumber</span><span class="hljs-params">(List&lt; ? <span class="hljs-keyword">super</span> Number&gt; data)</span> </span>&#123;<br>    data.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：不能在上限泛型集合中添加元素，可以在下限泛型集合中添加元素<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">      List&lt; ? <span class="hljs-keyword">super</span> Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      <span class="hljs-comment">// 可以在下限泛型集合中添加元素</span><br>      list.add(<span class="hljs-number">111</span>);<br>      <span class="hljs-comment">//报错： add (capture&lt; ? super java.lang.Integer&gt;) in List cannot be applied  to (java.lang.Object)</span><br>      list.add(<span class="hljs-keyword">new</span> Object());<br><br><span class="hljs-comment">// 不能在上限泛型集合中添加元素</span><br>      List&lt; ? extends Number&gt; data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      <span class="hljs-comment">// 报错：add  (capture&lt; ? extends java.lang.Number&gt;) in List cannot be applied to (java.lang.Integer)</span><br>      data.add(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">111</span>));<br></code></pre></td></tr></table></figure> 在日常中，只要记住 “ PECS(Producer Extends ConsumerSuper)原则” 即可。意思为： （1）频繁往外读取内容的，适合用上界Extends。（2）经常往里插入的，适合用下界Super。</p></blockquote><p>参考：https://www.zhihu.com/question/20400700</p><h3 id="泛型的生命周期">6. 泛型的生命周期</h3><p>Java的泛型信息只存在于编译期间，编译之后所有的泛型信息都会被擦除。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integerList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>List&lt;String&gt; stringList = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>System.out.println(integerList.getClass() == stringList.getClass());<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure> 不管是 ArrayList&lt; Integer &gt; 还是 ArrayList&lt; Long&gt;，在编译时都会被编译器擦除成了 ArrayList。</p><p>Java引入泛型是为了加强参数类型的安全性，在编译期间根据泛型声明及早发现类型转化问题，减少了类型的转换。因为在JDK1.5之前是没有泛型的，需要考虑向下兼容，所以对于泛型只存在于编译期间。编译成字节码后，ArrayList&lt;Integer &gt; 或 ArrayList&lt; Long &gt; 都会被擦除成ArrayList，这样就能保持和 JDK1.5 之前版本兼容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>list.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>Class listClass = list.getClass();<br>Method methodList = listClass.getMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);<br>methodList.invoke(list, <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>));<br><span class="hljs-keyword">for</span> (Object obj : list) &#123;<br>    System.out.println(<span class="hljs-string">&quot;obj = &quot;</span> + obj +<span class="hljs-string">&quot;, class = &quot;</span> + obj.getClass().getName());<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * obj = hello, class = java.lang.String</span><br><span class="hljs-comment"> * obj = 10, class = java.lang.Integer</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><strong>在运行期间获取泛型信息</strong></p><p>虽然泛型类在编译的时候会进行泛型擦除，不过泛型信息还是会保存在泛型类的字节码对象中。</p><blockquote><p>获取到泛型类型的要求： + 必须具有真实类型的存在。 +泛型的类型是明确的（如List<User>是明确的，List<T>是不明确的）。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 为了方便其他类获取，将其作为公有属性</span><br>    Class&lt;?&gt; clazz;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Generic</span><span class="hljs-params">()</span> </span>&#123;<br>        ParameterizedType pt = (ParameterizedType)<br>                <span class="hljs-keyword">this</span>.getClass().getGenericSuperclass();<br>        <span class="hljs-comment">// 获取泛型参数列表，如Map&lt;K,V&gt;，那么返回K，V的数组</span><br>        Type[] types = pt.getActualTypeArguments();<br>        <span class="hljs-comment">//因为这里只有一个泛型T，所以获取第一个元素</span><br>        clazz = (Class&lt;?&gt;) types[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGeneric</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>&#125;<br>System.out.println(<span class="hljs-keyword">new</span> Generic1().clazz);<br><span class="hljs-comment">// class java.lang.String</span><br></code></pre></td></tr></table></figure></p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——java9新特性</title>
    <link href="/2021/12/06/Java%E2%80%94%E2%80%94java9%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2021/12/06/Java%E2%80%94%E2%80%94java9%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p><strong>java9 新特性：</strong></p><ul><li>目录结构</li><li>模块化系统</li><li>jshell</li><li>接口的私有方法</li><li>改进 try-with-resourcs</li><li>改进钻石操作符</li><li>限制使用单独下划线标识符</li><li>String 存储结构变更</li><li>快速创建只读集合</li><li>增强 Stream API</li><li>改进 Optional 类</li><li>多分辨率图像 API</li><li>全新 HTTP 客户端 API</li><li>智能 JAVA 编译工具</li><li>统一 JVM 日志系统</li><li>javadoc 的 HTML5 支持</li><li>java 动态编译</li></ul><h4 id="目录结构">1.目录结构</h4><p>JDK9具体目录结构： + bin： 该目录包含所有的命令。 + conf：包含用户可以编辑的配置文件，例如以前位于 jre目录中的 .properties 和.policy 文件。 + include： 包含一些编译本地代码时使用的 C/C++头文件。 +jmods： 包含JMOD 格式的平台模块，创建自定义运行映射时需要它。 + legal：包含法律声明。 + lib： 包含非 Windows平台上动态链接的本地库，其子目录和文件不应由开发人员直接编辑或使用。</p><blockquote><p>JDK8 目录结构： + bin： 该目录存放了 JDK 的各种工具命令，即 jdk工具的可执行二进制文件，包括编译器，调试器等，例如：java，javac + db：该目录是安装 Java DB 的路径。Java 自带数据库 Derby。 + include：包含一些编译本地代码时使用的 C/C++头文件。 + jre： 该目录包含的是 jre环境(Java runtime environment 即 Java 运行时环境)。 +lib：该目录存放的是 java 工具命令实际执行的程序包。</p></blockquote><p><strong>注：JDK9 目录中不再有 jre 子目录。</strong></p><h4 id="模块化系统">2. 模块化系统</h4><p>JDK9 将 JDK分成一组模块，可以在编译时，运行时或构建时进行组合。模块化可以减少内存开销；只需必要的模块，并非全部模块，可以简化各种类库和大型应用的开发和维护，八个仓库：root、corba、hotspot、jaxp、jaxws、jdk、langtools 和 nashorn</p><blockquote><p>module-info.java：该文件必须位于项目的根目录中。该文件用于定义模块需要什么依赖，以及哪些包被外部使用。exports：控制哪些包可以被其他模块访问，所有不被 exports的包默认都被封装在模块里面不 被外界所使用。requires：指明对其他模块的依赖。</p></blockquote><p><strong>示例:</strong></p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211212225847.png" /></p><p>有两个模块 jdk9 和 jdk9module1，在 jdk9 中引用 jdk9module1的内容。</p><p>jdk9 module-info 内容： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> jdk9 &#123;<br>    <span class="hljs-keyword">requires</span> jdk9module1;<br>    <span class="hljs-keyword">requires</span> jdk.incubator.httpclient;<br>&#125;<br></code></pre></td></tr></table></figure> jdk9module1 module-info 内容：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> jdk9module1 &#123;<br>    <span class="hljs-keyword">exports</span> com.zth.bean;<br>    <span class="hljs-comment">//exports com.zth.common;</span><br>&#125;<br></code></pre></td></tr></table></figure> <imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211212230559.png" />可以看到如果没有引用 common 包，将如法使用 Util 类。</p><h4 id="jshell">3. JShell</h4><p>JDK9 新增了 REPL（Read-Eval-Print Loop）工具 jshell，jshell工具提供了一个交互式命令界面，可以评估声明、语句和表达式，无需编译即可返回执行结果。</p><blockquote><ol type="1"><li>/list 　　　　 //列出所有的代码</li><li>/methods 　　 //查看所有的方法</li><li>/var 　　 //所有的变量</li><li>/edit 　　 //打开编辑器</li><li>/open path 　　//执行路径上的代码 如 /open C:.java</li></ol></blockquote><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211212231645.png" /></p><h4 id="接口私有化方法">4. 接口私有化方法</h4><p>jdk1.8 之前接口定义中只有抽象方法（public abstract）和常量（publicstatic final），从 jdk8 开始，接口可以加入静态方法和默认方法，JDK9可以在接口中使用私有方法。</p><p>作用：在一个接口中，有可能在多个默认方法上存在重复的通用代码，但通用代码又不想被子类发现，所以引入了私有方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInterface</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        log(<span class="hljs-string">&quot;getName&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;猫和少年&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> String <span class="hljs-title">getSlogan</span><span class="hljs-params">()</span> </span>&#123;<br>        log(<span class="hljs-string">&quot;getSlogan&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;才疏学浅，少年登科；满腹经纶，白发不第&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 接口的私有化方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(String method)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;TestInterface.&quot;</span>+method+<span class="hljs-string">&quot;()被调用&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="改进-try-with-resource">5. 改进 try-with-resource</h3><p>JDK 8中新增了 try-with-resources语句，可以自动关闭需要关闭的资源文件。但是必须在 try语句后的括号中初始化需要关闭的资源。在JDK9中改进了 try-with-resources语句，可以在 try 外初始化资源，然后在 try后的括号中添加需要自动关的资源即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jdk7</span><span class="hljs-params">()</span></span>&#123;<br>    FileInputStream fileInputStream = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span>&#123;<br>        fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;/home/a.txt&quot;</span>);<br>        <span class="hljs-keyword">byte</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        fileInputStream.read(temp);<br>        System.out.println(<span class="hljs-keyword">new</span> String(temp));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != fileInputStream)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                fileInputStream.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jdk8</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span>(FileInputStream fileInputStream =  <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;/home/a.txt&quot;</span>))&#123;<br><br>        <span class="hljs-keyword">byte</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> read = fileInputStream.read(temp);<br>        System.out.println(<span class="hljs-keyword">new</span> String(temp));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jdk9</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>    FileInputStream fileInputStream =  <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;/home/a.txt&quot;</span>);<br>    <span class="hljs-keyword">try</span>(fileInputStream)&#123;<br>        <span class="hljs-keyword">byte</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> read = fileInputStream.read(temp);<br>        System.out.println(<span class="hljs-keyword">new</span> String(temp));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="改进钻石操作符">6. 改进钻石操作符</h3><p>JDK9 中钻石操作符可以使用匿名实现类，可以在匿名实现类中重写方法等操作。</p><p>JDK8 中： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;Integer&gt; integerComparator = <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;;<br><br>Set&lt;String&gt; hashSet = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;() &#123;<br>&#125;;<br><br></code></pre></td></tr></table></figure></p><p>JDK9： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;Integer&gt; integerComparator = <span class="hljs-keyword">new</span> Comparator&lt;&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><br>Set&lt;String&gt; hashSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;() &#123;<br>&#125;;<br></code></pre></td></tr></table></figure></p><h3 id="限制使用单独下划线标识符">7. 限制使用单独下划线标识符</h3><p>在 JDK8 之前可以使用单独的下划线（ _ ）作为标识符，但在 JDK9中限制使用单独的下划线作为标识符。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211226115041.png" /></p><h3 id="string-存储结构变更">8. String 存储结构变更</h3><p>String 类在 JDK8 以及之前将字符存储在 char数组中，每个字符使用两个字节（十六位）。从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数String 对象仅包含 Latin-1 字符。此类字符仅需要一个字节的存储空间，也就是 String对象的内部字符数组中有一半空间未使用。 JDK 8 String 结构： <imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211226122939.png" /></p><p>JDK9 将 String 的内部表示从 UTF-16字符数组更改为字节数组加上编码标志字段。 将根据字符串的内容存储编码为ISO-8859-1/Latin-1（每个字符一个字节）或UTF-16（每个字符两个字节）的字符。 编码标志将指示使用哪种编码。 JDK 9String 结构：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211226123032.png" /></p><blockquote><p>内码 :某种语言运行时，其 char 和 string 在内存中的编码方式。 外码:除了内码，皆是外码。要注意的是，源代码编译产生的目标代码文件（可执行文件或class文件）中的编码方式属于外码。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    printString(<span class="hljs-string">&quot;abc&quot;</span>);<br>    printString(<span class="hljs-string">&quot;中文&quot;</span>);<br>    printString(<span class="hljs-string">&quot;abc中文&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(String str)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;======&gt;&quot;</span> + str);<br>    <span class="hljs-comment">// return the UTF-16 char[] size</span><br>    System.out.println(<span class="hljs-string">&quot;length: &quot;</span> + str.length());<br>    <span class="hljs-comment">// Use default Encoding (UTF-8)</span><br>    System.out.println(<span class="hljs-string">&quot;getBytes: &quot;</span> + str.getBytes().length);<br>    <span class="hljs-comment">// Convert UTF-16 char[] to char</span><br>    System.out.println(<span class="hljs-string">&quot;codePointCount: &quot;</span> + str.codePointCount(<span class="hljs-number">0</span>, str.length()));<br>    <span class="hljs-comment">// Get the UTF-16 char[]</span><br>    System.out.println(<span class="hljs-string">&quot;toCharArray: &quot;</span> + str.toCharArray().length);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211226210914.png" /></p><p><ahref="https://blog.csdn.net/loveshunyi/article/details/90680487">java编码详解与原理</a></p><h3 id="快速创建只读集合">9. 快速创建只读集合</h3><p>JDK9 在 List、Set 和 Map 集合中新增 of 静态方法，快速创建只读集合。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    Map&lt;String, String&gt; map = Map.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;bbb&quot;</span>);<br><br>    List&lt;String&gt; names = List.of(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>);<br>    names.forEach(System.out::println);<br>    names.remove(<span class="hljs-string">&quot;张三&quot;</span>); <span class="hljs-comment">// 抛出 UnsupportedOperationException</span><br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="增强-stream-api">10. 增强 Stream API</h3><p>JDK9 在 Stream接口中新增4个方法：dropWhile、takeWhile、ofNullable、iterate方法新增重载方法</p><ol type="1"><li>default Stream<T> takeWhile(Predicate&lt; ? super T&gt;predicate)</li></ol><blockquote><p>有序的集合：从 Stream 中获取一部分数据, 返回从头开始的尽可能多的元素,直到遇到第一个 false 结果，如果第一个值不满足断言条件，将返回一个空的Stream。</p><p>无序的集合：如果这个流是无序的，那么这个操作的结果是<strong>不确定</strong>的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Stream&lt;String&gt; nameStream = Stream.of(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王麻子&quot;</span>, <span class="hljs-string">&quot;赵六&quot;</span>);<br>    nameStream.takeWhile(item -&gt; item.length() == <span class="hljs-number">2</span>).forEach(System.out::println);<br>    <span class="hljs-comment">// 张三  李四</span><br><br>    System.out.println(<span class="hljs-string">&quot;=========&quot;</span>);<br><br>    Set&lt;String&gt; names = Set.of(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王麻子&quot;</span>, <span class="hljs-string">&quot;赵六&quot;</span>);<br>    names.stream().takeWhile(item -&gt; item.length() == <span class="hljs-number">2</span>).forEach(System.out::println);<br>    <span class="hljs-comment">// 第一次执行结果： 李四</span><br>    <span class="hljs-comment">// 第二次执行结果： 张三</span><br>    <span class="hljs-comment">// 第三次执行结果： 赵六  李四</span><br>    <span class="hljs-comment">// ......</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2" type="1"><li>default Stream<T> dropWhile(Predicate&lt; ? super T&gt; predicate)&gt;与 takeWhile 相反，返回剩余的元素，和 takeWhile 方法形成互补&gt;有序的集合：从头开始删除元素，直到第一个值不满足断言条件，返回剩余元素。&gt;无序的集合：如果这个流是无序的，那么这个操作的结果是<strong>不确定</strong>的。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Stream&lt;String&gt; nameStream = Stream.of(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王麻子&quot;</span>, <span class="hljs-string">&quot;赵六&quot;</span>);<br>    nameStream.dropWhile(item -&gt; item.length() == <span class="hljs-number">2</span>).forEach(System.out::println);<br>    <span class="hljs-comment">// 王麻子  赵六</span><br><br>    System.out.println(<span class="hljs-string">&quot;=========&quot;</span>);<br><br>    Set&lt;String&gt; names = Set.of(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王麻子&quot;</span>, <span class="hljs-string">&quot;赵六&quot;</span>);<br>    names.stream().dropWhile(item -&gt; item.length() == <span class="hljs-number">2</span>).forEach(System.out::println);<br>    <span class="hljs-comment">// 第一次执行结果： 王麻子  赵六</span><br>    <span class="hljs-comment">// 第二次执行结果： 王麻子  赵六  李四</span><br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3" type="1"><li>public static<T> Stream<T> ofNullable(T t)&gt;如果非空，则返回一个包含单个元素的连续流，否则返回空流。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Object&gt; nulStream = Stream.ofNullable(<span class="hljs-keyword">null</span>);<br>System.out.println(nulStream.count());<br><span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="改进-optional-类">11. 改进 Optional 类</h3><p>Optional 类是在 JDK8 中新增的类，主要是为了解决空指针异常。在 JDK9中对这个类进行了改进，主要是新增了三个方法：stream、ifPresentOrElse 和or</p><blockquote><p>ifPresentOrElse：如果有值，则使用该值执行给定的操作，否则执行给定的基于空的操作。or：如果有值，则返回描述该值的 Optional，否则返回由提供函数生成的Optional。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王麻子&quot;</span>, <span class="hljs-string">&quot;赵六&quot;</span>);<br>    Optional&lt;List&lt;String&gt;&gt; optional = Optional.ofNullable(list);<br>    optional.stream().forEach(System.out::println);<br>    <span class="hljs-comment">// [张三, 李四, 王麻子, 赵六]</span><br><br>    Optional&lt;String&gt; name = Optional.ofNullable(<span class="hljs-keyword">null</span>);<br>    name.ifPresentOrElse(item -&gt; System.out.println(<span class="hljs-string">&quot;name: &quot;</span> + item), () -&gt; System.out.println(<span class="hljs-string">&quot;Not Present.&quot;</span>));<br>    <span class="hljs-comment">// Not Present.</span><br><br>    name = name.or(() -&gt; Optional.of(<span class="hljs-string">&quot;Not Present&quot;</span>));<br>    System.out.println(name.get());<br>    <span class="hljs-comment">// Not Present</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Optional类是在JDK8中新增的类，主要是为了解决空指针异常。在JDK9中对这个类进行了改进，主要是新增了三个方法：stream，ifPresentOrElse 和 or 1 List<String>list = new ArrayList&lt;&gt;(); 2 list.add("人参"); 3 list.add("当归");4 list.add("鹿茸"); 5 list.add("黄柏"); 6 Optional&lt;List<String>&gt;optional = Optional.ofNullable(list); 7optional.stream().forEach(System.out::println); 8910 Optional<String>optional1 = Optional.of("Mahesh"); 11 optional1.ifPresentOrElse( x ‐&gt;System.out.println("Value: " + x),() ‐&gt; 12 System.out.println("NotPresent.")); 13 Supplier&lt;Optional<String>&gt; supplierString = ()‐&gt; Optional.of("Not Prese nt"); 14 optional1 = optional1.or(supplierString);</p><h3 id="多分辨率图像api">12. 多分辨率图像API</h3><p>在 java.awt.image包下新增了支持多分辨率图片的API，用于支持多分辨率的图片。 1.将不同分辨率的图像封装到一张（多分辨率的）图像中，作为它的变体。 2.获取这个图像的所有变体。 3.获取特定分辨率的图像变体，表示一张已知分辨率单位为 DPI的特定尺寸大小的逻辑图像，并且这张图像是最佳的变体。 4.java.awt.image.MultiResolutionImage 接口的基础实现java.awt.image.BaseMultiResolutionImage 获取所需要的变体。 5. 通过接口的getResolutionVariant（double destImageWidth, doubledestImageHeight）方法，根据分辨率获取图像。</p><h3 id="全新的-http-客户端-api">13. 全新的 HTTP 客户端 API</h3><p>HTTP，用于传输网页的协议，早在 1997 年就被采用在目前的 1.1版本中。直到 2015 年， HTTP2 才成为标准。</p><p><imgsrc="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211227000024.png" /></p><p>Http2和Http1.X的区别</p><ol type="1"><li>HTTP2 使用的是二进制传输，HTTP1.X 是文本（字符串）传输。</li><li>HTTP2 支持多路复用</li><li>HTTP2 头部压缩</li><li>HTTP2 支持服务器推送</li></ol><p>HTTP/1.1 和 HTTP/2的主要区别是如何在客户端和服务器之间构建和传输数据。HTTP/1.1依赖于请求/响应周期。 HTTP/2允许服务器“push”数据：它可以发送比客户端请求更多的数据。这使得它可以优先处理并发送对于首先加载网页至关重要的数据</p><p><a href="https://www.jianshu.com/p/63fe1bf5d445">http2 和http1.1区别详细分析</a></p><p>JDK9 中有新的方式来处理 HTTP 调用。它提供了一个新的HTTP客户端(HttpClient)，它将替代仅适用于 blocking 模式的HttpURLConnection（HttpURLConnection 是在HTTP 1.0 时代创建的，并使用了协议无关的方法)，并提供对 WebSocket 和 HTTP/2 的支持。此外，HTTP客户端还提供 API 来处理 HTTP/2的特性，比如流和服务器推送等功能。</p><p>全新的 HTTP 客户端 API 可以从 jdk.incubator.httpclient模块中获取。因为在默认情况下，这个模块是不能根据 classpath获取的，需要使用 add modules 命令选项配置这个模块，将这个模块添加到classpath 中。（requires jdk.incubator.httpclient;）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException, URISyntaxException </span>&#123;<br>    <span class="hljs-comment">//创建 builder</span><br>    HttpClient.Builder builder = HttpClient.newBuilder();<br>    <span class="hljs-comment">//链式调用</span><br>    HttpClient client = builder<br>            <span class="hljs-comment">//http 协议版本 1.1 或者 2</span><br>            .version(HttpClient.Version.HTTP_2) <span class="hljs-comment">//.version(HttpClient.Version.HTTP_1_1)</span><br>            <span class="hljs-comment">//连接完成之后的转发策略</span><br>            .followRedirects(HttpClient.Redirect.NEVER). <span class="hljs-comment">//followRedirects(HttpClient.Redirect.ALWAYS)</span><br>            <span class="hljs-comment">// 指定线程池</span><br>                    executor(Executors.newFixedThreadPool(<span class="hljs-number">5</span>))<br><br>            <span class="hljs-comment">//认证，默认情况下 Authenticator.getDefault() 是 null 值，会报错</span><br>            <span class="hljs-comment">//.authenticator(Authenticator.getDefault())</span><br><br>            <span class="hljs-comment">//代理地址</span><br>            <span class="hljs-comment">//.proxy(ProxySelector.of(new InetSocketAddress(&quot;http://www.baidu.com&quot;, 8080)))</span><br><br>            .cookieManager(<span class="hljs-keyword">new</span> CookieManager())<br>            <span class="hljs-comment">//创建完成</span><br>            .build();<br><br>    <span class="hljs-comment">//组装 request</span><br><br>    URI baiduUri = <span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>);<br>    HttpRequest request = HttpRequest.newBuilder(baiduUri)<br>            .version(HttpClient.Version.HTTP_2)<br>            .build();<br>    <span class="hljs-comment">//发起调用</span><br>    HttpResponse&lt;String&gt; r = client.send(request, HttpResponse.BodyHandler.asString());<br>    System.out.println(r.body());<br><br>&#125;<br></code></pre></td></tr></table></figure><p><ahref="https://blog.csdn.net/u014042066/article/details/78153653">Java9之HttpClientAPI实战详解</a></p><h3 id="智能-java-编译工具">14. 智能 JAVA 编译工具</h3><p>智能 java 编译工具（sjavac）的第一个阶段始于 JEP139这个项目，用于在多核处理器情况下提升 JDK的编译速度。如今，这个项目已经进入第二阶段，即 JEP199，其目的是改进 Java编译工 具，并取代目前 JDK 编译工具 javac，继而成为 Java环境默认的通用的智能编译工具。 JDK 9 还更新了 javac 编译器以便能够将java 9 代码编译运行在低版本 Java 中。</p><h3 id="统一的jvm日志系统">15. 统一的JVM日志系统</h3><p>日志是解决问题的唯一有效途径：曾经很难知道导致 JVM 性能问题和导致 JVM崩溃的根本原因。不同的 JVM 日志的碎片化和日志选项（例如：JVM组件对于日志使用的是不同的机制和规则），这使得 JVM 难以进行调试。解决该问题最佳方法：对所有的 JVM 组件引入一个单一的系统，这些 JVM组件支持细粒度的和易配置的 JVM 日志。</p><h3 id="javadoc-的-html5-支持">16. javadoc 的 HTML5 支持</h3><p>JDK8 生成的 java 帮助文档是在 HTML4 中。而 HTML4 已经是很久的标准了。JDK9 的 javadoc，现支持HTML5 标准，具有搜索功能。</p><h3 id="java-动态编译器">18. java 动态编译器</h3><p>JIT（Just-in-time）编译器可以在运行时将热点编译成本地代码，速度很快。但是Java 项目现在变得很大很复杂，因此 JIT编译器需要花费较长时间才能热身完，而且有些 Java方法还没法编译，性能方面也会下降。AoT编译就是为了解决这些问题而生的。</p><p>在 JDK 9 中， AOT（JEP 295: Ahead-of-TimeCompilation）作为实验特性被引入进来，开发者可以利用新的 jaotc工具将重点代码转换成类似类库一样的文件。虽然仍处于试验阶段，但这个功能使得Java 应用在被虚拟机启动之前能够先将 Java类编译为原生代码。此功能旨在改进小型和大型应用程序的启动时间，同时对峰值性能的影响很小。但是 Java 技术供应商 Excelsior 的营销总监 Dmitry Leskov 担心 AoT编译技术不够成熟，希望 Oracle 能够等到 Java10时有个更稳定版本才发布。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java9新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——java8新特性之Optional</title>
    <link href="/2021/12/03/Java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BOptional/"/>
    <url>/2021/12/03/Java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BOptional/</url>
    
    <content type="html"><![CDATA[<h3 id="optional-介绍">1. Optional 介绍</h3><p>Optional<T> 是在 java.util 包下的一个用于代替 null 的一个工具类</p><p><strong>仅仅是解决 NPE(NullPointerException) 问题吗？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">List&lt;Order&gt;  <span class="hljs-title">getOrders</span><span class="hljs-params">(User user)</span></span>&#123;<br>    Optional&lt;User&gt; u = Optional.ofNullable(user);<br>    <span class="hljs-keyword">if</span> (u.isPresent())&#123;<br>        <span class="hljs-keyword">return</span> u.get().getOrders();<br>    &#125;<br>    <span class="hljs-keyword">return</span> Collections.emptyList();<br>&#125;<br><br><span class="hljs-function">List&lt;Order&gt;  <span class="hljs-title">getOrders2</span><span class="hljs-params">(User user)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != user)&#123;<br>        <span class="hljs-keyword">return</span> user.getOrders();<br>    &#125;<br>    <span class="hljs-keyword">return</span> Collections.emptyList();<br>&#125;<br></code></pre></td></tr></table></figure><p>第一种方法虽然使用了 Optional ，但是本质上没有区别，如何优雅的使用Optional？</p><p><strong>Optional 错误使用姿势</strong> 1. 调用 isPresent() 方法 2.调用 get() 方法 3. Optional 类型作为类/实例属性 4. Optional类型作为方法参数</p><blockquote><p>解释： + 使用 isPresent() 和使用 obj != null 无任何分别 + 直接调用get() 方法虽然不抛出 NPE 了，但如果没有值是会抛出NoSuchElementException。</p></blockquote><p>Optional 中可以依赖的是除了 isPresent() 和 get() 的其他方法：</p><table><thead><tr><th style="text-align: center;">方法</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr><td style="text-align: center;">public<U> Optional<U> map(Function&lt;?super T, ? extends U&gt; mapper)</td><td style="text-align: center;">如果值存在，就对该值执行提供的 mapping函数的调用</td></tr><tr><td style="text-align: center;">public T orElse(T other)</td><td style="text-align: center;">如果有值则将其返回，否则返回默认值</td></tr><tr><td style="text-align: center;">public T orElseGet(Supplier&lt;? extendsT&gt; other)</td><td style="text-align: center;">如果有值则将其返回，否则返回一个Supplier 接口生成的值</td></tr><tr><td style="text-align: center;">public void ifPresent(Consumer&lt;?super T&gt; consumer)</td><td style="text-align: center;">如果值存在，就通过 consumer消费次值，否则什么也不做</td></tr><tr><td style="text-align: center;">public Optional<T> filter(Predicate&lt;?super T&gt; predicate)</td><tdstyle="text-align: center;">如果值存在并且满足提供的谓词，就返回包含该值的Optional 对象</td></tr><tr><td style="text-align: center;">public<U> Optional<U>flatMap(Function&lt;? super T, Optional<U>&gt; mapper)</td><td style="text-align: center;">如果值存在，就对该值执行提供的 mapping函数调用</td></tr><tr><td style="text-align: center;">public <X extends Throwable> TorElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</td><td style="text-align: center;">如果有值则将其返回，否则抛出一个由指定的Supplier 接口生成的异常</td></tr></tbody></table><h3 id="optional-构造方式">2. Optional 构造方式</h3><ul><li>Optional.of(obj)：要求传入的 obj 不能为 null，否则还抛出NullPointerException 异常</li><li>Optional.empty()：value 为 null 的 Optional</li><li>Optional.ofNullable(obj)：如果 obj 为 null 返回Optional.empty()，否则返回 Optional.of(obj)</li></ul><blockquote><p>Optional.of(obj) 的作用 1. 当非常明确将要传给 Optional.of(obj) 的 obj参数不可能为 null 时, 比如刚 new 出来的对象(Optional.of(new User(…))),或者是一个非 null 常量时; 2. 当想为 obj 断言不为 null 时, 即想在万一 obj为 null 立即报告 NullPointException 异常, 立即修改,而不是隐藏空指针异常</p></blockquote><h3 id="optional-使用">3. Optional 使用</h3><h4 id="获取值">3.1 获取值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 存在即返回，否则提供默认值</span><br><span class="hljs-keyword">return</span> user.orElse(UNKNOWUSER);<br><span class="hljs-comment">// 而不是 return user.isPresent() ? user.get() : null ;</span><br><br><br><span class="hljs-comment">// 存在即返回，否则函数生成</span><br><span class="hljs-keyword">return</span> user.orElseGet(<span class="hljs-keyword">this</span>::getDefaultUser);<br><br><span class="hljs-comment">// 存在即返回，否则抛出异常</span><br><span class="hljs-keyword">return</span> user.orElseThrow(NullPointerException::<span class="hljs-keyword">new</span>);<br><br><br><span class="hljs-comment">// 存在才执行操作</span><br>user.ifPresent(System.out::print);<br><span class="hljs-comment">// 而不是</span><br><span class="hljs-keyword">if</span> (user.isPresent())&#123;<br>    System.out.println(user.get());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="map-函数">3.2 map 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 当 user.isPresent() 为真, 获得 用户名，否则返回 null</span><br>String name = user.map(User::getName).orElse(<span class="hljs-string">&quot;UNKNOW&quot;</span>);<br><br><span class="hljs-comment">// java8 之前</span><br>String name2 = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">if</span> (user.isPresent())&#123;<br>    name2 = user.get().getName();<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    name2 = <span class="hljs-string">&quot;UNKNOW&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="filter-函数">3.3 filter 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; name = Optional.of(<span class="hljs-string">&quot;debugging&quot;</span>);<br>Optional&lt;String&gt; longName = name.filter(i -&gt; i.length() &gt; <span class="hljs-number">6</span>);<br>System.out.println(longName.orElse(<span class="hljs-string">&quot;The name is less than 6 characters&quot;</span>));<br><span class="hljs-comment">// debugging</span><br><br>Optional&lt;String&gt; name2 = Optional.of(<span class="hljs-string">&quot;admin&quot;</span>);<br>Optional&lt;String&gt; longName2 = name2.filter(i -&gt; i.length() &gt; <span class="hljs-number">6</span>);<br>System.out.println(longName2.orElse(<span class="hljs-string">&quot;The name is less than 6 characters&quot;</span>));<br><span class="hljs-comment">// The name is less than 6 characters</span><br><br><br>Optional&lt;String&gt; name3 = Optional.empty();<br>Optional&lt;String&gt; longName3 = name3.filter(i -&gt; i.length() &gt; <span class="hljs-number">6</span>);<br>System.out.println(longName3.orElse(<span class="hljs-string">&quot;The name is less than 6 characters&quot;</span>));<br><span class="hljs-comment">// The name is less than 6 characters</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——java8新特性之Stream</title>
    <link href="/2021/12/01/java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/"/>
    <url>/2021/12/01/java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/</url>
    
    <content type="html"><![CDATA[<h3 id="定义">1. 定义</h3><p><strong>A sequence of elements supporting sequential and parallelaggregate operations .</strong> 1. Stream 是元素的集合，这点让 Stream看起来用些类似 Iterator； 2.可以支持顺序和并行的对原Stream进行汇聚的操作；</p><blockquote><p>Java 8 中的 Stream是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregateoperation），或者大批量数据操作 (bulkdata operation)。</p></blockquote><p>Stream API 借助于 Lambda表达式，极大的提高编程效率和程序可读性。同时提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势（使用fork/join框架，fork 递归式地分解问题，然后每段并行执行，最终由 join合并结果，返回最后的值）。</p><p>[例] 统计列表中不为 null 的元素个数。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; nums = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">6</span>);<br><br><span class="hljs-comment">//原始版本</span><br><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (Integer item : nums) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != item) &#123;<br>        count++;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Stream 版本</span><br><span class="hljs-keyword">long</span> count1 = nums.stream().filter(Objects::nonNull).count();<br></code></pre></td></tr></table></figure></p><h3 id="语法">2. 语法</h3><figure><imgsrc="https://user-images.githubusercontent.com/45761474/144250337-a744591a-f7ef-4877-8876-c01a7ede3661.jpg"alt="Stream表达式" /><figcaption aria-hidden="true">Stream表达式</figcaption></figure><p>一条语句分为三部分： 1. 红色框中的语句是一个 Stream的生命开始的地方，负责创建一个Stream实例； 2. 绿色框中的语句是赋予Stream 灵魂的地方，把一个 Stream 转换成另外一个 Stream； 3.蓝色框中的语句是汇聚的地方，把 Stream里面包含的内容按照某种算法来汇聚成一个值。</p><blockquote><p>使用Stream的基本步骤： 1. 创建Stream； 2.转换Stream，每次转换原有Stream对象不改变，返回一个新的Stream对象（可以有多次转换）；3. 对Stream进行聚合（Reduce）操作，获取想要的结果</p></blockquote><h3 id="创建-stream">3. 创建 Stream</h3><p>常见创建 Stream 的方式有三种：</p><ul><li>通过 Stream 接口的静态工厂方法</li><li>通过 Collection 接口的默认方法 stream() 把一个 Collection 对象转换为Stream</li><li>通过数组，Arrays.stream(T array)</li></ul><ol type="1"><li><p>of 方法：有两个 overload 方法，一个接受变长参数，一个接口单一值；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>Stream&lt;String&gt; stringStream = Stream.of(<span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></td></tr></table></figure></p></li><li><p>generator 方法 生成一个无限长度的 Stream ，其元素生成时通过给定的Supplier 接口提供</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.generate(<span class="hljs-keyword">new</span> Supplier&lt;Double&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Math.random();<br>    &#125;<br>&#125;);<br>Stream.generate(()-&gt;Math.random());<br><br>Stream.generate(Math::random);<br></code></pre></td></tr></table></figure><p>生成一个无限长度的Stream，其中值是随机的。这个无限长度Stream是懒加载。</p><ol start="3" type="1"><li>iterate 方法：</li></ol><p>也是生成无限长度的 Stream，和 generator不同的是，其元素的生成是重复对给定的种子值(seed)调用用户指定函数来生成的。其中包含的元素可以认为是：seed，f(seed),f(f(seed))无限循环。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先获取一个无限长度的正整数集合的Stream，然后取出前10个打印。</span><br>      Stream.iterate(<span class="hljs-number">1</span>, item -&gt; item * <span class="hljs-number">2</span>).limit(<span class="hljs-number">10</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure></p><ol start="4" type="1"><li>通过 Collection 子类获取 StreamCollection接口有一个stream方法，所以其所有子类都都可以获取对应的Stream对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integerList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">3</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>integerList.stream();<br>Set&lt;Integer&gt; integerSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>integerSet.stream();<br>Map&lt;String, String&gt; stringMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>stringMap.entrySet().stream();<br>stringMap.keySet().stream();<br>stringMap.values().stream();<br></code></pre></td></tr></table></figure></li><li>Arrays.stream(T array)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.stream(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);<br></code></pre></td></tr></table></figure><h3 id="转换stream">4. 转换Stream</h3><p>转换Stream就是把一个 Stream 通过某些行为转换成一个新的 Stream。</p><p>Stream 接口中几个常用的转换方法: + disinct + filter + map + flatmap +peek + limit + skip</p><h4 id="distinct">4.1 distinct</h4><p>对于 Stream 中包含的元素进行去重操作(依赖于元素的 equals方法)，新生成的Stream 中没有重复的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>    list.stream().distinct().forEach(item -&gt; System.out.print(item+ <span class="hljs-string">&quot;  &quot;</span>));<br>    <span class="hljs-comment">// 1  null  2  3  4  5  6  7  8  9 </span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="filter">4.2 filter</h4><p>对于 Stream 中包含的元素使用给定的过滤函数进行过滤，新生成的 Stream只包含符合条件的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>list.stream().distinct().filter(Objects::nonNull).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br><span class="hljs-comment">// 1  2  3  4  5  6  7  8  9  </span><br></code></pre></td></tr></table></figure><h4 id="map">4.3 map</h4><p>对于 Stream 中包含的元素使用给定的转换函数进行转换操作，新生成的Stream只包含转换生成的元素。这个方法有三个对于原始类型的变种方法，分别是：mapToInt，mapToLong和 mapToDouble。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>list.stream().distinct().filter(Objects::nonNull).map(i -&gt; i * <span class="hljs-number">2</span>).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br><span class="hljs-comment">// 2  4  6  8  10  12  14  16  18 </span><br><br>DoubleStream stream = DoubleStream.of(<span class="hljs-number">23.0</span>, <span class="hljs-number">25.4</span>, <span class="hljs-number">32.5</span>, <span class="hljs-number">45.9</span>);<br>stream.mapToInt(item -&gt; (<span class="hljs-keyword">int</span>) item).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br><span class="hljs-comment">// 23  25  32  45          </span><br></code></pre></td></tr></table></figure></p><h4 id="flatmap">4.4 flatMap</h4><p>和map类似，不同的是其每个元素转换得到的是Stream对象，会把子Stream中的元素压缩到父集合中<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; teamIndia = Arrays.asList(<span class="hljs-string">&quot;Virat&quot;</span>, <span class="hljs-string">&quot;Dhoni&quot;</span>, <span class="hljs-string">&quot;Jadeja&quot;</span>);<br>List&lt;String&gt; teamAustralia = Arrays.asList(<span class="hljs-string">&quot;Warner&quot;</span>, <span class="hljs-string">&quot;Watson&quot;</span>, <span class="hljs-string">&quot;Smith&quot;</span>);<br>List&lt;List&lt;String&gt;&gt; players = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>players.add(teamIndia);<br>players.add(teamAustralia);<br>players.stream().flatMap(Collection::stream).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br></code></pre></td></tr></table></figure></p><h4 id="peek">4.5. peek</h4><p>生成一个包含原 Stream 的所有元素的新Stream，同时会提供一个消费函数（Consumer实例），新 Stream每个元素被消费的时候都会执行给定的消费函数； <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>System.out.println(<span class="hljs-string">&quot;\n&quot;</span>+integers.stream().peek(System.out::print).count());<br><span class="hljs-comment">//16789</span><br><span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure></p><h4 id="limit">4.6 limit</h4><p>对一个 Stream 进行截断操作，获取其前N个元素，如果原 Stream中包含的元素个数小于N，则获取其所有的元素 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>integers.stream().limit(<span class="hljs-number">3</span>).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;   &quot;</span>));<br><span class="hljs-comment">// 1   6   7</span><br></code></pre></td></tr></table></figure></p><h4 id="skip">4.7 skip</h4><p>返回一个丢弃原 Stream 的前 N 个元素后剩下元素组成的新Stream，如果原Stream中包含的元素个数小于N，那么返回空 Stream<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>integers.stream().skip(<span class="hljs-number">2</span>).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;   &quot;</span>));<br><span class="hljs-comment">// 7   8   9  </span><br></code></pre></td></tr></table></figure></p><p><strong>转换操作都是 lazy的，多个转换操作只会在汇聚操作的时候融合起来，一次循环完成。可以这样简单的理解，Stream里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在汇聚操作的时候循环Stream 对应的集合，然后对每个元素执行所有的函数。</strong></p><h3 id="汇聚reducestream">5. 汇聚（reduce）Stream</h3><p>Reduce操作接受一个元素序列为输入，反复使用某个合并操作，把序列中的元素合并成一个汇总的结果。</p><p>比如查找一个数字列表的总和或者最大值，或者把这些数字累积成一个List对象。</p><p>Stream接口通用的汇聚操作 + reduce() + collect() + count() + sum() +allMatch：判断是否是全部的元素都满足给定匹配条件 +noneMatch：判断是否是全部的元素都不满足给定匹配条件 +anyMatch：判断是否至少有一个元素满足给定匹配条件 +findFirst：返回第一个元素 + max()：使用比较器（Operator），返回 Stream中最大的元素</p><p>注意：sum 方法不是所有的 Stream 对象都有的，只有IntStream、LongStream 和 DoubleStream是实例才有。</p><h4 id="collect">5.1 collect</h4><p>把输入的元素累积到一个可变的容器中，比如 Collection 或者StringBuilder。可变汇聚对应的方法只有一个：collect，它的作用就是把Stream中的所有元素收集到一个结果容器中。</p><p><strong>方法定义1：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R&gt; <span class="hljs-function">R <span class="hljs-title">collect</span><span class="hljs-params">(Supplier&lt;R&gt; supplier,</span></span><br><span class="hljs-params"><span class="hljs-function">              BiConsumer&lt;R, ? <span class="hljs-keyword">super</span> T&gt; accumulator,</span></span><br><span class="hljs-params"><span class="hljs-function">              BiConsumer&lt;R, R&gt; combiner)</span></span><br></code></pre></td></tr></table></figure> 方法参数： + Supplier<R>supplier：工厂函数，用来生成一个新的容器。 + BiConsumer&lt;R, ? superT&gt; accumulator：用来把 Stream 中的元素添加到结果容器 +BiConsumer&lt;R, R&gt;combiner：用来把中间状态的多个结果容器合并成一个（并发时）</p><p>示例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>ArrayList&lt;Integer&gt; collect = integers.stream().filter(Objects::nonNull)<br>        .collect(ArrayList::<span class="hljs-keyword">new</span>, ArrayList::add, ArrayList::addAll);<br>System.out.println(collect.toString());<br><span class="hljs-comment">// [1, 6, 7, 8, 9]</span><br></code></pre></td></tr></table></figure> <strong>方法定义2：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R, A&gt; <span class="hljs-function">R <span class="hljs-title">collect</span><span class="hljs-params">(Collector&lt;? <span class="hljs-keyword">super</span> T, A, R&gt; collector)</span></span>;<br></code></pre></td></tr></table></figure>Collectors 已经定义了一些静态工厂方法： + Collectors.toCollection()收集到 Collection 中 + Collectors.toList() 收集到 List 中 +Collectors.toSet() 收集到 Set 中</p><p>示例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>List&lt;Integer&gt; collect = integers.stream().filter(Objects::nonNull)<br>        .collect(Collectors.toList());<br>System.out.println(collect.toString());<br><span class="hljs-comment">// [1, 6, 7, 8, 9]</span><br></code></pre></td></tr></table></figure> #### 5.2 reduce <strong>方法定义1</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">reduce</span><span class="hljs-params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;<br></code></pre></td></tr></table></figure> 接受一个 BinaryOperator 类型的参数，BinaryOperator函数有两个参数 + 第一个参数是上次函数执行的返回值（中间结果） +第二个参数是 Stream 中的元素</p><p>示例： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>Integer integer = integers.stream().filter(Objects::nonNull).<br>        reduce((sum, item) -&gt; sum + item).get();<br>System.out.println(integer);<br><span class="hljs-comment">// 31</span><br></code></pre></td></tr></table></figure></p><p><strong>方法定义2</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">T <span class="hljs-title">reduce</span><span class="hljs-params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;<br></code></pre></td></tr></table></figure>和上面的类似，不同的是允许提供一个初始值，如果 Stream为空，则直接返回初始值。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>Integer integer = integers.stream().filter(Objects::nonNull).<br>        reduce(<span class="hljs-number">100</span>,(sum, item) -&gt; sum + item);<br>System.out.println(integer);<br><span class="hljs-comment">// 131</span><br></code></pre></td></tr></table></figure> <strong>方法定义3</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;U&gt; <span class="hljs-function">U <span class="hljs-title">reduce</span><span class="hljs-params">(U identity,</span></span><br><span class="hljs-params"><span class="hljs-function">             BiFunction&lt;U, ? <span class="hljs-keyword">super</span> T, U&gt; accumulator,</span></span><br><span class="hljs-params"><span class="hljs-function">             BinaryOperator&lt;U&gt; combiner)</span></span>;<br></code></pre></td></tr></table></figure> 功能和上面的类似，不同的是允许用户提供一个 combiner函数用来处理并发场景下的数据汇总。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>Integer integer = integers.parallelStream().filter(Objects::nonNull).<br>        reduce(<span class="hljs-number">0</span>, (sum, item) -&gt; sum + item, (result, fragment) -&gt; result + fragment);<br>System.out.println(integer);<br><span class="hljs-comment">// 31</span><br></code></pre></td></tr></table></figure> #### 5.3 count 方法统计 Stream 中的元素的个数 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><span class="hljs-keyword">long</span> count = integers.parallelStream().filter(Objects::nonNull).count();<br>System.out.println(count);<br><span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure> ### 6. CollectorsCollector接口： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collector</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">A</span>, <span class="hljs-title">R</span>&gt; </span>&#123;<br> <span class="hljs-comment">// 用于生成和返回一个结果容器</span><br>    <span class="hljs-function">Supplier&lt;A&gt; <span class="hljs-title">supplier</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-comment">// 将元素 T 归纳到容器A</span><br>    <span class="hljs-function">BiConsumer&lt;A, T&gt; <span class="hljs-title">accumulator</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-comment">// 将两个结果合并并返回</span><br>    <span class="hljs-function">BinaryOperator&lt;A&gt; <span class="hljs-title">combiner</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-comment">// 将中间结果R 转换为A</span><br>    <span class="hljs-function">Function&lt;A, R&gt; <span class="hljs-title">finisher</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-comment">// characteristics 表示当前 collector的特征值，返回 Collector 特征值的 Set</span><br>    <span class="hljs-function">Set&lt;Characteristics&gt; <span class="hljs-title">characteristics</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure> Collectors 是一个工具类，是 JDK 预实现Collector 的工具类，它内部提供了多种 Collector。</p><p>Collectors除了提供了上文介绍过的收集方法外还提供了一组非常有用方法。</p><p>#### 6.1 joining 连接收集的结果 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>String value = integers.stream().map(String::valueOf).collect(Collectors.joining());<br><span class="hljs-comment">// 16789</span><br><br><span class="hljs-comment">// 指定间隔符</span><br>String value1 = integers.stream().map(String::valueOf).collect(Collectors.joining(<span class="hljs-string">&quot;-&quot;</span>));<br><span class="hljs-comment">// 1-6-7-8-9</span><br><br><br><span class="hljs-comment">// 指定间隔符、前缀、后缀</span><br>String value2 = integers.stream().map(String::valueOf).collect(Collectors.joining(<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;$&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>));<br><span class="hljs-comment">// $1-6-7-8-9#</span><br></code></pre></td></tr></table></figure></p><h4 id="collectingandthen">6.2 collectingAndThen</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T,A,R,RR&gt; Collector&lt;T,A,RR&gt; <span class="hljs-title">collectingAndThen</span><span class="hljs-params">(Collector&lt;T,A,R&gt; downstream,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                            Function&lt;R,RR&gt; finisher)</span></span><br></code></pre></td></tr></table></figure><p>通过第二个参数 Function 函数对汇聚后的结果进行再操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 收集后逆序排序</span><br>      List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>      List&lt;String&gt; collect = integers.stream().map(String::valueOf).<br>              collect(Collectors.collectingAndThen(Collectors.toList(), Lists::reverse));<br>      <span class="hljs-comment">// [9, 8, 7, 6, 1]</span><br></code></pre></td></tr></table></figure><h4 id="groupingby">6.3 groupingBy</h4><p>用于生成一个拥有分组功能的 Collector，它也有三个重载方法<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 只需一个分组参数 classifier，内部自动将结果保存到一个 map 中</span><br><span class="hljs-comment">// 每个 map 的键为 ？ 类型（即 classifier 的结果类型），值为 list（保存这个组中的元素）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;<br>    groupingBy(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; classifier)<br><br><span class="hljs-comment">// 在上面方法的基础上增加了对流元素的处理方式的Collector，比如上面的默认处理方法是 Collectors.toList()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K, A, D&gt;<br>    Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; classifier,<br>                                          Collector&lt;? <span class="hljs-keyword">super</span> T, A, D&gt; downstream)<br><br><span class="hljs-comment">// 在第二个方法的基础上增加了结果 Map 的生成方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt;<br>    Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; classifier,<br>                                  Supplier&lt;M&gt; mapFactory,<br>                                  Collector&lt;? <span class="hljs-keyword">super</span> T, A, D&gt; downstream)<br><br></code></pre></td></tr></table></figure></p><p><strong>示例：</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>Map&lt;Integer, List&lt;Integer&gt;&gt; collect = integers.stream().collect(Collectors.groupingBy(item -&gt; item % <span class="hljs-number">3</span>));<br><span class="hljs-comment">// &#123;0=[3, 6, 9], 1=[1, 4, 7], 2=[2, 5, 8]&#125;</span><br><br>Map&lt;Integer, Set&lt;Integer&gt;&gt; collect1 = integers.stream().collect(Collectors.groupingBy(item -&gt; item % <span class="hljs-number">3</span>, Collectors.toSet()));<br><span class="hljs-comment">// &#123;0=[3, 6, 9], 1=[1, 4, 7], 2=[2, 5, 8]&#125;</span><br><br><br>Map&lt;Integer, Set&lt;Integer&gt;&gt; collect2 = integers.stream()<br>        .collect(Collectors.groupingBy(item -&gt; item % <span class="hljs-number">3</span>,HashMap::<span class="hljs-keyword">new</span>, Collectors.toSet()));<br><span class="hljs-comment">// &#123;0=[3, 6, 9], 1=[1, 4, 7], 2=[2, 5, 8]&#125;</span><br></code></pre></td></tr></table></figure></p><h4 id="partitioningby">6.4 partitioningBy</h4><p>将流中的元素按照给定的校验规则分为两部分，放到一个 map 中返回，map的键是 boolean 类型，值为元素的列表 list。 <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 只需要一个校验参数 predicate</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt;<br>   Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)<br><span class="hljs-comment">// 在上面的基础上增加了对流中元素的处理方式的 Collector，默认 Collector.toList()</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, D, A&gt;<br>   Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate,<br>                                                   Collector&lt;? <span class="hljs-keyword">super</span> T, A, D&gt; downstream)<br><br></code></pre></td></tr></table></figure></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><br><span class="hljs-comment">// 对序列进行奇偶分区</span><br>Map&lt;Boolean, List&lt;Integer&gt;&gt; collect = integers.stream().collect(Collectors.partitioningBy(item -&gt; item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>));<br><span class="hljs-comment">// &#123;false=[1, 1, 3, 5, 7, 9], true=[2, 4, 6, 8]&#125;</span><br><br>Map&lt;Boolean, Set&lt;Integer&gt;&gt; collect1 = integers.stream().<br>        collect(Collectors.partitioningBy(item -&gt; item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, Collectors.toSet()));<br><span class="hljs-comment">// &#123;false=[1, 3, 5, 7, 9], true=[2, 4, 6, 8]&#125;</span><br></code></pre></td></tr></table></figure><h4 id="reducing">6.4 reducing</h4><p><strong>方法定义</strong> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无初始值，返回一个可以生成 Optional 结果的  Collector</span><br>&lt;T&gt; Collector&lt;T, ?, T&gt;   reducing(T identity, BinaryOperator&lt;T&gt; op)<br><br><span class="hljs-comment">// 有初始值，返回一个可以直接生成结果的  Collector</span><br>&lt;T&gt; Collector&lt;T, ?, T&gt;  reducing(T identity, BinaryOperator&lt;T&gt; op)<br><br><span class="hljs-comment">// 有初始值，元素在执行操作之前先执行 mapper 进行元素转换</span><br> &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity,<br>                                Function&lt;? <span class="hljs-keyword">super</span> T, ? extends U&gt; mapper,<br>                                BinaryOperator&lt;U&gt; op)<br></code></pre></td></tr></table></figure> <strong>示例</strong><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><br>Optional&lt;Integer&gt; integerOptional = integers.stream().collect(Collectors.reducing(Integer::sum));<br><span class="hljs-comment">// 等价于 integers.stream().reduce(Integer::sum);</span><br>System.out.println(integerOptional.get());<br><span class="hljs-comment">// 46</span><br><br>Integer collect = integers.stream().collect(Collectors.reducing(<span class="hljs-number">10</span>, Integer::sum));<br><span class="hljs-comment">// 等价于 integers.stream().reduce(10, Integer::sum);</span><br><span class="hljs-comment">// 56</span><br><br>String s = integers.stream().collect(Collectors.reducing(<span class="hljs-string">&quot;@&quot;</span>, String::valueOf, String::concat));<br><span class="hljs-comment">// 等价于 integers.stream().map(String::valueOf).reduce(&quot;@&quot;, String::concat);</span><br><span class="hljs-comment">// @1123456789</span><br></code></pre></td></tr></table></figure></p><h4 id="综合应用">6.5 综合应用</h4><p>将列表按奇偶分组，然后每组里面找最大值（两种实现） <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><br>Map&lt;Boolean, Optional&lt;Integer&gt;&gt; collect = integers.stream().collect(<br>        Collectors.partitioningBy(item -&gt; item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>,<br>                Collectors.maxBy(Comparator.comparing(Integer::valueOf))));<br><br>Map&lt;Boolean, Optional&lt;Integer&gt;&gt; collect1 = integers.stream().collect(<br>        Collectors.partitioningBy(item -&gt; item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>,<br>                Collectors.reducing(BinaryOperator.maxBy(Comparator.comparing(Integer::valueOf)))));<br><br><span class="hljs-comment">// &#123;false=Optional[9], true=Optional[8]&#125;</span><br></code></pre></td></tr></table></figure></p><h3 id="stream-的关闭">7 Stream 的关闭</h3><p>Steam 继承了 AutoCloseable接口，在大多数场景下都是无需手动关闭的，仅在流的资源是 IO通道（例如：Files.lines(Path ,Charset )）时需要调用 Stream.close()方法关闭流，以保证 IO 资源的释放。也可以使用 try-with-resources 语法关闭Stream。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——函数式编程</title>
    <link href="/2021/11/30/java%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/11/30/java%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="重新认识接口">1. 重新认识接口</h3><h4 id="java8之前">1.1 java8之前</h4><p>接口的作用：定义该类型实例具有的功能，不关心如何进行这些工作。所以，接口定义中只有抽象方法（publicabstract）和常量（public staticfinal），并且接口中不允许定义实例变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInterface</span> </span>&#123;<br>    Integer age = <span class="hljs-number">18</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="java8之后">1.2 java8之后</h4><p>从JDK8开始，接口可以加入静态方法和默认方法默认方法允许接口方法定义默认实现，而所有子类都继承该方法及实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInterface</span> </span>&#123;<br>    Integer age = <span class="hljs-number">18</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printHello</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getString</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure> <strong>默认方法的优势</strong> 1.默认方法的主要优势是提供一种拓展接口的方法，而不破坏现有代码。增加新的方法，并且能保证对使用这个接口的老版本代码的兼容性。在JDK8以前，如果为一个现有接口增加一个新方法，则我们必须在所有实现类中添加该方法的实现，否则编译会出现异常。如果实现类比较多或者我们没有权限修改实现类源代码，这样可能就比较麻烦。默认方法则解决了这个问题，它提供了一个实现，当没有显式提供其他实现时就采用这个实现，这样新添加的方法将不会破坏现有代码。2. 另一个优势是该方法是可选，子类可以根据不同的需求Override默认实现。例如，我们定义一个集合接口，其中有增、删、改等操作。如果实现类90%都是以数组保存数据，那么可以定义针对这些方法给出默认实现，而对于其他非数组集合或者有其他类似业务，可以选择性复写接口中默认方法。</p><h3 id="函数式接口">2.函数式接口</h3><p><strong>定义：</strong>&gt;如果一个接口定义唯一一个抽象方法，那么这个接口就成为函数式接口。</p><p>java.lang.Runnable 就是一个函数式接口，因为它只有一个抽象方法。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></p><p>默认方法不是abstract的，所以一个函数式接口里可以定义任意多的默认方法。为了标明函数式接口Java8引入了一个新的注解： <span class="citation"data-cites="FunctionalInterface">@FunctionalInterface</span></p><p><strong>函数接口特性</strong> + <span class="citation"data-cites="FunctionInterface">@FunctionInterface</span>注解只能标记在有且仅有一个抽象方法的接口上； +Java8接口中的静态方法和默认方法，都不算是抽象方法； + 接口默认继承java.lang.Object,所以如果接口声明覆盖了Object中的方法，那么也不算抽象方法； +注解不是必须的，如果接口符合函数式接口的定义，那么不加注解也没有影响。加上则编译器可以进行检查。如果不是函数接口而加上了注解，则编译器会报错。</p><h3 id="函数式编程">3. 函数式编程</h3><p>函数编程特性：</p><p><strong>a. 闭包与高阶函数</strong>函数编程支持函数作为第一类对象，有时称为 闭包或者仿函数（functor）对象。实质上，闭包是起函数的作用并可以像对象一样操作的对象。高阶函数可以用另一个函数作为其输入参数，也可以返回一个函数作为其输出参数。</p><p><strong>b. 惰性计算</strong>在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算。延迟的计算可以编写可能潜在地生成无穷输出的函数。因为不会计算多于程序的其余部分所需要的值，所以不需要担心由无穷计算所导致的out-of-memory 错误。</p><p><strong>c. 没有“副作用”</strong> 所谓"副作用"（sideeffect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。函数式编程强调没有"副作用"，意味着函数要保持独立，所有功能返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p><blockquote><p>综上所述，函数式编程可以简言之是： 使用不可变值和函数，通过函数对一个值进行处理，映射成另一个值。这个值在面向对象语言中可以理解为对象，另外这个值还可以作为函数的输入。</p></blockquote><p>Java8 中的函数式编程 + 内建的函数式接口 + Optional API + Lambda表达式+ Stream API</p><h4 id="内建的函数式接口">3.1 内建的函数式接口</h4><p>Java8API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。</p><table><thead><tr><th style="text-align: center;">name</th><th style="text-align: center;">type</th><th style="text-align: center;">description</th></tr></thead><tbody><tr><td style="text-align: center;">Consumer(消费者)</td><td style="text-align: center;">Consumer<T></td><td style="text-align: center;">接收 T 对象，不返回值</td></tr><tr><td style="text-align: center;">Predicate(谓词)</td><td style="text-align: center;">Predicate<T></td><td style="text-align: center;">接收 T 对象并返回boolean</td></tr><tr><td style="text-align: center;">Function(函数)</td><td style="text-align: center;">Function&lt;T,R&gt;</td><td style="text-align: center;">接收 T 对象，返回 R 对象</td></tr><tr><td style="text-align: center;">Supplier(提供者)</td><td style="text-align: center;">Supplier<T></td><td style="text-align: center;">提供T对象，不接收值</td></tr><tr><td style="text-align: center;">UnaryOperator(一元运算符)</td><td style="text-align: center;">UnaryOperator<T></td><td style="text-align: center;">接收T对象，返回T对象</td></tr><tr><td style="text-align: center;">BinaryOperator(二元操作)</td><td style="text-align: center;">BinaryOperator<T></td><td style="text-align: center;">接收两个T对象，返回T对象</td></tr></tbody></table><blockquote><p>以上四种为基本的函数接口，在此之上JDK又提供了若干扩展： 1.以上前三种添加了Bi的前缀：BiConsumer,BiPredicate,BiFunction,入参变为两个；2. 对Function的扩展产生了UnaryOperator(一元运算符)，接收T返回T； 3.对BiFunction的扩展产生了BinaryOperator(二元操作)，收两个T对象，返回T对象4. 增加了若干具体基本类型的接口，可参见function包下具体接口说明。</p></blockquote><h4 id="optional-api">3.2 Optional API</h4><p>Java8中引入的 Optional是一种优雅解决NPE(NullPointExcepiton)问题的方法，是通过函数式接口实现的。</p><p>Optional 提供的方法：</p><table><thead><tr><th style="text-align: center;">方法</th><th style="text-align: center;">描述</th></tr></thead><tbody><tr><td style="text-align: center;">public<U> Optional<U> map(Function&lt;?super T, ? extends U&gt; mapper)</td><td style="text-align: center;">如果当前 Optional 为Optional.empty，则依旧返回 Optional.empty；否则返回一个新的 Optional，该Optional 包含的是：函数 mapper 在以 value 作为输入时的输出值。</td></tr><tr><td style="text-align: center;">public T orElse(T other)</td><tdstyle="text-align: center;">如果有值则将其返回，否则返回一个默认值</td></tr><tr><td style="text-align: center;">public T orElseGet(Supplier&lt;? extendsT&gt; other)</td><tdstyle="text-align: center;">如果有值则将其返回，否则返回一个由指定的Supplier接口生成的值</td></tr></tbody></table><p>如果当前 Optional 为 Optional.empty，则依旧返回Optional.empty；否则返回一个新的 Optional，该 Optional 包含的是：函数mapper 在以 value 作为输入时的输出值。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——java8新特性之Lambda 表达式</title>
    <link href="/2021/11/28/java%E2%80%94%E2%80%94jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/11/28/java%E2%80%94%E2%80%94jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="lambda表达式">Lambda表达式</h3><p>lambda 表达式本质上是一段匿名内部类，也可以是一段可以传递的代码</p><h4 id="语法">1. 语法</h4><p>完整的 Lambda 表达式由三部分组成：参数列表、箭头、声明语句；<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> (Type1 param1, Type2 param2, ..., TypeN paramN) ‐&gt; &#123; statment1;<br>statment2; <span class="hljs-comment">//............. return statmentM;&#125;</span><br></code></pre></td></tr></table></figure> 1.绝大多数情况，编译器都可以从上下文环境中推断出lambda表达式的参数类型，所以参数可以省略：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(param1,param2, ..., paramN) ‐&gt; &#123; statment1; statment2; <span class="hljs-comment">//............. r</span><br>eturn statmentM;&#125;<br></code></pre></td></tr></table></figure> 2. 当lambda表达式的参数个数只有一个，可以省略小括号：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">param1 ‐&gt; &#123; statment1; statment2; <span class="hljs-comment">//............. return statmentM;&#125;</span><br></code></pre></td></tr></table></figure> 3.当lambda表达式只包含一条语句时，可以省略大括号、return和语句结尾的分号：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">param1 ‐&gt; statment<br></code></pre></td></tr></table></figure></p><h4 id="函数接口">2. 函数接口</h4><p>函数接口是只有一个抽象方法的接口， 用作 Lambda 表达式的返回类型。包路径为 java.util.function接口类上面都有@FunctionalInterface这个注解。</p><h4 id="类型检查类型推断">3. 类型检查、类型推断</h4><p>Java编译器根据 Lambda 表达式上下文信息就能推断出参数的正确类型。程序依然要经过类型检查来保证运行的安全性， 但不用再显式声明类型罢了。这就是所谓的类型推断。</p><h4 id="局部变量限制">4. 局部变量限制</h4><p>Lambda表达式也允许使用自由变量（不是参数，而是在外层作用域中定义的变量），就像匿名类一样。它们被称作捕获Lambda。Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为final，或事实上是final。</p><p>Lambda 表达式访问外部变量： <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String[] strings = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;;<br>    <span class="hljs-keyword">for</span> (Integer i : Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)) &#123;<br>        Stream.of(strings).map(string -&gt; string + i).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></p><blockquote><p>为什么局部变量有这些限制？实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。因此，Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] strings = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>    Stream.of(strings).map(string -&gt; string + i).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>上面的代码会报编译错误，lambda表达式引用的变量需要时final或等效final的变量。</strong></p><h4 id="lambda表达式的方法和构造器引用">5.Lambda表达式的方法和构造器引用</h4><p>方法引用的语法格式有以下三种：</p><ol type="1"><li>objectName::instanceMethod</li><li>ClassName::staticMethod</li><li>ClassName::instanceMethod</li></ol><blockquote><p>前两种等同于把lambda表达式的参数当成 instanceMethod | staticMethod的参数来调用。 例如： Math::max等同于(x, y)-&gt;Math.max(x,y)</p><p>后一种等于把lambda表达式的第一个参数当成instanceMethod的目标对象，其他参数当成该方法的参数。 例如： String::toLowerCase()等同于 x-&gt;x.toLowerCase()</p></blockquote><p><em>构造器引用语法如下</em></p><p>ClassName::new</p><blockquote><p>把 lambda 表达式的参数当成 ClassName 构造器的参数。例如：BigDecimal::new 等同于 x-&gt;new BigDecimal(x)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis——入门</title>
    <link href="/2021/11/28/Redis%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"/>
    <url>/2021/11/28/Redis%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="nosql介绍">1. NoSQL介绍</h2><p>NoSQL （Not OnlySQL）指的是非关系型的数据库，是对不同于传统的关系型数据库的数据库管理系统的统称。NoSQL用于超大规模数据的存储。Redis就属于非关系型数据库,传统的Mysql,oracle ,sql server 等 都是关系型数据库。</p><h2 id="为什么需要nosql">2. 为什么需要NoSQL</h2><p>主要应对以下问题时，传统关系型数据库力不从心</p><p>高并发读写 海量数据的高效率存储和访问 高可扩展性和高可用性 ## 3.Redis 简介 Redis 是一个高性能的 key-value数据库。它通常被称为数据结构服务器，因为值（value）可以是字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sortedsets)等类型。</p><p>Redis 与其他 key - value 缓存产品相比有以下三个特点：Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。Redis支持数据的备份，即master-slave模式的数据备份。 Redis的应用场景 缓存任务队列 网站访问统计 数据过期处理 应用排行榜分布式集群架构中的session分离 Redis 支持的五种数据类型：字符串（String） 字符串列表（list） 哈希（hash） 字符串集合（set）有序字符串集合（zset）</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
