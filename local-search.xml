<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go——接口</title>
    <link href="/2022/01/06/Go%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/01/06/Go%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p><p><font color="red"> <strong>接口（interface）是一种类型</strong></font></p><h3 id="1-接口定义"><a href="#1-接口定义" class="headerlink" title="1. 接口定义"></a>1. 接口定义</h3><p>Go 语言中每个接口由数个方法（零个或多个）组成，接口的定义格式如下：</p><blockquote><p>type　接口类型名　interface{<br>　方法名1( 参数列表1 )　返回值列表1<br>　方法名2( 参数列表2 )　返回值列表2<br>　 …<br>}</p></blockquote><p>其中：</p><ul><li>接口名：使用 type 将接口定义为自定义的类型名。Go 语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer。</li><li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li><li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li></ul><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;<br>    String() <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>实现该接，调用 String() 方法时可以获得对象对应的字符串，功能类似于 Java 语言里的 toString 的操作。</p><h3 id="2-接口实现"><a href="#2-接口实现" class="headerlink" title="2. 接口实现"></a>2. 接口实现</h3><p>如果一个任意类型 T 的方法集为一个接口类型的方法集的超集，则我们说类型 T 实现了此接口类型。T 可以是一个非接口类型，也可以是一个接口类型。</p><p>实现关系在Go语言中是隐式的。两个类型之间的实现关系不需要在代码中显式地表示出来。Go语言中没有类似于 implements 的关键字。 Go编译器将自动在需要的时候检查两个类型之间的实现关系。</p><p>接口定义后，需要实现接口，调用方才能正确编译通过并使用接口。接口的实现需要遵循两条规则才能让接口可用。</p><p>一个对象只要全部实现了接口中的方法，那么就实现了这个接口。</p><ol><li>接口的方法与实现接口的类型方法格式一致</li></ol><p>在类型中添加与接口签名一致的方法就可以实现该方法。签名包括方法中的名称、参数列表、返回参数列表。也就是说，只要实现接口类型中的方法的名称、参数列表、返回参数列表中的任意一项与接口要实现的方法不一致，那么接口的这个方法就不会被实现。</p><ol start="2"><li>接口中所有方法均被实现</li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Eater 定义接口</span><br><span class="hljs-keyword">type</span> Eater <span class="hljs-keyword">interface</span> &#123;<br>eat()<br>&#125;<br><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// 实现接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;骨头&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> eater Eater = <span class="hljs-built_in">new</span>(Dog)<br>eater.eat()<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-1-值接收者实现接口"><a href="#2-1-值接收者实现接口" class="headerlink" title="2.1 值接收者实现接口"></a>2.1 值接收者实现接口</h4><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 实现接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;骨头&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> eater Eater<br>eater = Dog&#123;&#125;<span class="hljs-comment">// Dog 类型</span><br>eater = <span class="hljs-built_in">new</span>(Dog)<span class="hljs-comment">// 指针类型</span><br>eater.eat()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>使用值接收者实现接口，不管是 dog 结构体还是结构体指针 *dog 类型的变量都可以赋值给该接口变量。因为 Go 语言中有对指针类型变量求值的语法糖，dog 指针内部会自动求值。</p><h4 id="2-2-指针接收者实现接口"><a href="#2-2-指针接收者实现接口" class="headerlink" title="2.2 指针接收者实现接口"></a>2.2 指针接收者实现接口</h4><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cat)</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;小黄鱼&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> eater Eater<br>eater = <span class="hljs-built_in">new</span>(Cat) <span class="hljs-comment">// 指针类型</span><br><span class="hljs-comment">// eater = Cat&#123;&#125;// Cat 类型，编译错误</span><br>eater.eat()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>时实现接口的是 *Cat 类型，所以不把 Cat 类型传给接口类型变量。</p><h3 id="3-接口变量"><a href="#3-接口变量" class="headerlink" title="3. 接口变量"></a>3. 接口变量</h3><p>接口类型变量可以存储所有实现了该接口的实例</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> w io.Writer<br>fmt.Printf(<span class="hljs-string">&quot;%T \n&quot;</span>,w)<span class="hljs-comment">// &lt;nil&gt;</span><br>w = os.Stdout<br>fmt.Printf(<span class="hljs-string">&quot;%T \n&quot;</span>,w)<span class="hljs-comment">// *os.File</span><br>w = <span class="hljs-built_in">new</span>(bytes.Buffer)<br>fmt.Printf(<span class="hljs-string">&quot;%T \n&quot;</span>,w)<span class="hljs-comment">// *bytes.Buffer</span><br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。这两部分分别称为接口的动态类型和动态值。</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20220108225046.png"></p><h3 id="4-类型与接口的关系"><a href="#4-类型与接口的关系" class="headerlink" title="4. 类型与接口的关系"></a>4. 类型与接口的关系</h3><ol><li>一个类型实现多个接口</li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Sayer <span class="hljs-keyword">interface</span> &#123;<br>say()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;汪汪汪~~~&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>dog := Dog&#123;&#125;<br>dog.say()<br>dog.eat()<br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="2"><li>多个类型实现同一接口</li></ol><p>并且一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// Washer 洗衣</span><br><span class="hljs-keyword">type</span> Washer <span class="hljs-keyword">interface</span> &#123;<br>wash()<br>dry()<br>&#125;<br><br><span class="hljs-comment">// 甩干器</span><br><span class="hljs-keyword">type</span> dryer <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// 实现 Washer 接口的 dry() 方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d dryer)</span> <span class="hljs-title">dry</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;甩一甩&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 海尔洗衣机</span><br><span class="hljs-keyword">type</span> haier <span class="hljs-keyword">struct</span> &#123;<br>dryer <span class="hljs-comment">//嵌入甩干器</span><br>&#125;<br><br><span class="hljs-comment">// 实现 WashingMachine 接口的 wash() 方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h haier)</span> <span class="hljs-title">wash</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;洗刷刷&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="5-接口嵌套"><a href="#5-接口嵌套" class="headerlink" title="5. 接口嵌套"></a>5. 接口嵌套</h3><p>接口与接口间可以通过嵌套创造出新的接口。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">/ 接口嵌套<br><span class="hljs-keyword">type</span> animal <span class="hljs-keyword">interface</span> &#123;<br>Sayer<br>Eater<br>&#125;<br><br><span class="hljs-comment">// Eater 定义接口</span><br><span class="hljs-keyword">type</span> Eater <span class="hljs-keyword">interface</span> &#123;<br>eat()<br>&#125;<br><br><span class="hljs-keyword">type</span> Sayer <span class="hljs-keyword">interface</span> &#123;<br>say()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实现嵌套接口：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;骨头&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;汪汪汪~~~&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a animal =  Dog&#123;&#125;<br>a.say()<br>a.eat()<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="6-空接口"><a href="#6-空接口" class="headerlink" title="6. 空接口"></a>6. 空接口</h3><p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。</p><p>空接口类型的变量可以存储任意类型的变量。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 定义一个空接口</span><br><span class="hljs-keyword">var</span> object <span class="hljs-keyword">interface</span>&#123;&#125;<br><br>object = <span class="hljs-string">&quot;Hello world&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;type:%T   value:%v\n&quot;</span>, object, object)<br><span class="hljs-comment">//type:string   value:Hello world</span><br><br>object = <span class="hljs-number">100</span><br>fmt.Printf(<span class="hljs-string">&quot;type:%T   value:%v\n&quot;</span>, object, object)<br><span class="hljs-comment">// type:int   value:100</span><br><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>空接口的应用</strong></p><ol><li>空接口作为函数的参数</li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 空接口作为函数参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sout</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;type:%T value:%v\n&quot;</span>, a, a)<br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="2"><li>空接口作为map的值</li></ol><p>使用空接口实现可以保存任意值的字典。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> studentInfo = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br>studentInfo[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;张三&quot;</span><br>studentInfo[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">18</span><br>studentInfo[<span class="hljs-string">&quot;married&quot;</span>] = <span class="hljs-literal">false</span><br>fmt.Println(studentInfo)<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——结构体</title>
    <link href="/2022/01/02/Go%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2022/01/02/Go%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<p>Golang 面向对象编程非常简洁，去掉了传统 OOP 语言的方法重载、构造函数和析构函数、隐藏的this指针等等</p><h3 id="1-结构体"><a href="#1-结构体" class="headerlink" title="1. 结构体"></a>1. 结构体</h3><h4 id="1-1-结构体的定义"><a href="#1-1-结构体的定义" class="headerlink" title="1.1 结构体的定义"></a>1.1 结构体的定义</h4><p>使用type和struct关键字来定义结构体，具体代码格式如下：</p><blockquote><p>type　类型名　struct {<br>　字段名　字段类型<br>　字段名　字段类型<br>　…<br>}</p></blockquote><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-keyword">string</span><br>Name <span class="hljs-keyword">string</span><br>Age  <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">// 同样类型的字段也可以写在一行</span><br><span class="hljs-keyword">type</span> Student1 <span class="hljs-keyword">struct</span> &#123;<br>ID, Name <span class="hljs-keyword">string</span><br>Age      <span class="hljs-keyword">int</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><h4 id="1-2-实例化与初始化"><a href="#1-2-实例化与初始化" class="headerlink" title="1.2 实例化与初始化"></a>1.2 实例化与初始化</h4><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// 方法一</span><br><span class="hljs-keyword">var</span> stu Student<br>fmt.Println(stu)<br><span class="hljs-comment">// &#123;  0&#125;</span><br>stu.ID = <span class="hljs-string">&quot;0001&quot;</span><br>stu.Name = <span class="hljs-string">&quot;张三&quot;</span><br>stu.Age = <span class="hljs-number">18</span><br>fmt.Println(stu)<br><span class="hljs-comment">// &#123;0001 张涛 18&#125;</span><br><br><span class="hljs-comment">// 方法二</span><br><span class="hljs-comment">//var stu1 Student = Student&#123;&#125;</span><br><span class="hljs-keyword">var</span> stu1 Student = Student&#123;<span class="hljs-string">&quot;0002&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>&#125;<br>fmt.Println(stu1)<br><span class="hljs-comment">// &#123;0002 李四 19&#125;</span><br><br><span class="hljs-comment">// 方法三</span><br><span class="hljs-keyword">var</span> stu2 *Student = <span class="hljs-built_in">new</span>(Student)<br>(*stu2).ID = <span class="hljs-string">&quot;0003&quot;</span><br>(*stu2).Name = <span class="hljs-string">&quot;李四&quot;</span><br><span class="hljs-comment">// 编译器进行自动转换</span><br>stu2.Age = <span class="hljs-number">20</span><br>fmt.Println(*stu2)<br><span class="hljs-comment">// &#123;0003 李四 20&#125;</span><br><br><span class="hljs-comment">// 方法四</span><br><span class="hljs-comment">//var stu3 *Student = &amp;Student&#123;&#125;</span><br>stu3 := &amp;Student&#123;<span class="hljs-string">&quot;0004&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">19</span>&#125;<br>fmt.Println(*stu3)<br><br><span class="hljs-comment">// 初始化方式</span><br>stu4 := &amp;Student&#123;Name: <span class="hljs-string">&quot;王五&quot;</span>, ID: <span class="hljs-string">&quot;00005&quot;</span>, Age: <span class="hljs-number">19</span>&#125;<br>fmt.Println(*stu4)<br><br>stu5 := &amp;Student&#123;Name: <span class="hljs-string">&quot;王五&quot;</span>&#125;<br>fmt.Println(*stu5)<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="1-3-匿名结构体"><a href="#1-3-匿名结构体" class="headerlink" title="1.3 匿名结构体"></a>1.3 匿名结构体</h4><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> user <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-keyword">string</span><br>age  <span class="hljs-keyword">int</span><br>&#125;<br>user.Name = <span class="hljs-string">&quot;张三&quot;</span><br>user.age = <span class="hljs-number">19</span><br>fmt.Println(user)<br></code></pre></div></td></tr></table></figure><h4 id="1-4-结构体的匿名字段"><a href="#1-4-结构体的匿名字段" class="headerlink" title="1.4 结构体的匿名字段"></a>1.4 结构体的匿名字段</h4><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-keyword">string</span><br><span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p1 := Person&#123;<br><span class="hljs-string">&quot;张三&quot;</span>,<br><span class="hljs-number">18</span>,<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, p1)<span class="hljs-comment">// &#123;string:张三 int:18&#125;</span><br>fmt.Println(p1.<span class="hljs-keyword">string</span>, p1.<span class="hljs-keyword">int</span>) <span class="hljs-comment">//张三 18</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>注意：这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><h4 id="1-5-嵌套结构体"><a href="#1-5-嵌套结构体" class="headerlink" title="1.5 嵌套结构体"></a>1.5 嵌套结构体</h4><p>一个结构体中可以嵌套包含另一个结构体或结构体指针。<br>当访问结构体成员时会先在结构体中查找该字段，找不到再去嵌套的匿名字段中查找。<br>嵌套结构体内部可能存在相同的字段名。在这种情况下为了避免歧义需要通过指定具体的内嵌结构体字段名。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//Address 地址结构体</span><br><span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> &#123;<br>Province <span class="hljs-keyword">string</span><br>City     <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">// User 嵌套结构体</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Name    <span class="hljs-keyword">string</span><br>Gender  <span class="hljs-keyword">string</span><br>Address Address<br>&#125;<br><br><span class="hljs-comment">// User1 嵌套匿名字段</span><br><span class="hljs-keyword">type</span> User1 <span class="hljs-keyword">struct</span> &#123;<br>Name   <span class="hljs-keyword">string</span><br>Gender <span class="hljs-keyword">string</span><br>Address<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>u1 := User&#123;<br>Name:   <span class="hljs-string">&quot;张三&quot;</span>,<br>Gender: <span class="hljs-string">&quot;男&quot;</span>,<br>Address: Address&#123;<br>Province: <span class="hljs-string">&quot;陕西&quot;</span>,<br>City:     <span class="hljs-string">&quot;西安&quot;</span>,<br>&#125;,<br>&#125;<br><br><span class="hljs-keyword">var</span> u2 User1<br>u2.Name = <span class="hljs-string">&quot;李四&quot;</span><br>u2.Gender = <span class="hljs-string">&quot;男&quot;</span><br>u2.Address.Province = <span class="hljs-string">&quot;甘肃&quot;</span> <span class="hljs-comment">// 匿名字段默认使用类型名作为字段名</span><br>u2.City = <span class="hljs-string">&quot;天水&quot;</span>             <span class="hljs-comment">// 匿名字段可以省略</span><br><br>fmt.Printf(<span class="hljs-string">&quot;user1=%+v\n&quot;</span>, u1)<br>fmt.Printf(<span class="hljs-string">&quot;user1=%+v\n&quot;</span>, u2)<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="1-6-结构体之间的转换"><a href="#1-6-结构体之间的转换" class="headerlink" title="1.6 结构体之间的转换"></a>1.6 结构体之间的转换</h4><ol><li>结构体是用户单独定义的类型，和其它类型进行转换时需要有完全相同的字段(名字、个数和类型)</li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Age <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Age <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> p Person = Person&#123;<span class="hljs-number">10</span>&#125;<br><span class="hljs-keyword">var</span> s Student<br>s = Student(p)<br>fmt.Println(s)<br><span class="hljs-comment">// &#123;10&#125;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="2"><li>结构体进行 typ e重新定义(相当于取别名)，Golang 认为是新的数据类型，但是相互间可以强转</li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Age <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-keyword">type</span> Stu Student<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> s1 Student = Student&#123;<span class="hljs-number">19</span>&#125;<br><span class="hljs-keyword">var</span> s2 Stu<br>s2 = Stu(s1)<br>fmt.Println(s2)<br><span class="hljs-comment">// &#123;19&#125;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-结构体的“继承”"><a href="#2-结构体的“继承”" class="headerlink" title="2. 结构体的“继承”"></a>2. 结构体的“继承”</h3><h4 id="2-1-方法和接收者"><a href="#2-1-方法和接收者" class="headerlink" title="2.1 方法和接收者"></a>2.1 方法和接收者</h4><p>Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的 this 或者 self。</p><p>定义格式如下：</p><blockquote><p>func　(接收者变量 接收者类型)　方法名(参数列表)　(返回参数) {<br>　　函数体<br>}</p></blockquote><ul><li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li></ul><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//Person 结构体</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>age  <span class="hljs-keyword">int8</span><br>&#125;<br><br><span class="hljs-comment">//NewPerson 构造函数（Go语言的结构体没有构造函数）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPerson</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, age <span class="hljs-keyword">int8</span>)</span> *<span class="hljs-title">Person</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;Person&#123;<br>name: name,<br>age:  age,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//Eat Person做梦的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span> <span class="hljs-title">Eat</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;干啥啥不行，吃饭第一名&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// SetAge 实现 setter</span><br><span class="hljs-comment">// 使用指针接收者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span> <span class="hljs-title">SetAge</span><span class="hljs-params">(newAge <span class="hljs-keyword">int8</span>)</span></span> &#123;<br>p.age = newAge<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p1 := NewPerson(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">25</span>)<br>p1.SetAge(<span class="hljs-number">18</span>)<br>fmt.Println(*p1)<span class="hljs-comment">// &#123;张三 18&#125;</span><br>p1.Eat()<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-2-结构体的-“继承”"><a href="#2-2-结构体的-“继承”" class="headerlink" title="2.2 结构体的 “继承”"></a>2.2 结构体的 “继承”</h4><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//Animal 动物</span><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Animal)</span> <span class="hljs-title">move</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s会动！\n&quot;</span>, a.name)<br>&#125;<br><br><span class="hljs-comment">//Dog 狗</span><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>Feet    <span class="hljs-keyword">int8</span><br>*Animal <span class="hljs-comment">//通过嵌套匿名结构体实现继承</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dog)</span> <span class="hljs-title">wang</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>d1 := &amp;Dog&#123;<br>Feet: <span class="hljs-number">4</span>,<br>Animal: &amp;Animal&#123;<br>name: <span class="hljs-string">&quot;小黄&quot;</span>,<br>&#125;,<br>&#125;<br>d1.wang() <span class="hljs-comment">// 小黄会汪汪汪~</span><br>d1.move() <span class="hljs-comment">// 小黄会动！</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-结构体与JSON序列化"><a href="#3-结构体与JSON序列化" class="headerlink" title="3. 结构体与JSON序列化"></a>3. 结构体与JSON序列化</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">//Student 学生</span><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>ID     <span class="hljs-keyword">int</span><br>Gender <span class="hljs-keyword">string</span><br>Name   <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">//Class 班级</span><br><span class="hljs-keyword">type</span> Class <span class="hljs-keyword">struct</span> &#123;<br>Title    <span class="hljs-keyword">string</span><br>Students []*Student<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := &amp;Class&#123;<br>Title:    <span class="hljs-string">&quot;101&quot;</span>,<br>Students: <span class="hljs-built_in">make</span>([]*Student, <span class="hljs-number">2</span>),<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;<br>stu := &amp;Student&#123;<br>Name:   fmt.Sprintf(<span class="hljs-string">&quot;stu%02d&quot;</span>, i),<br>Gender: <span class="hljs-string">&quot;男&quot;</span>,<br>ID:     i,<br>&#125;<br>c.Students = <span class="hljs-built_in">append</span>(c.Students, stu)<br>&#125;<br><br><span class="hljs-comment">//JSON序列化：结构体--&gt;JSON格式的字符串</span><br>data, err := json.Marshal(c)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;json marshal failed&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;json:%s\n&quot;</span>, data)<br><br><span class="hljs-comment">//JSON反序列化：JSON格式的字符串--&gt;结构体</span><br>str := <span class="hljs-string">`&#123;&quot;Title&quot;:&quot;101&quot;,&quot;Students&quot;:[&#123;&quot;ID&quot;:0,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu00&quot;&#125;,&#123;&quot;ID&quot;:1,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu01&quot;&#125;,&#123;&quot;ID&quot;:2,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu02&quot;&#125;]&#125;`</span><br>c1 := &amp;Class&#123;&#125;<br>err = json.Unmarshal([]<span class="hljs-keyword">byte</span>(str), c1)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;json unmarshal failed!&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, *c1)<br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="4-结构体标签"><a href="#4-结构体标签" class="headerlink" title="4. 结构体标签"></a>4. 结构体标签</h3><p>Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 Tag 在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：</p><blockquote><p>`key1:”value1　“key2:”value2” `</p></blockquote><p>结构体 tag 由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>ID     <span class="hljs-keyword">int</span>    <span class="hljs-string">`json:&quot;id&quot;`</span> <span class="hljs-comment">// 通过指定 tag 实现 json 序列化该字段时的 key</span><br>Gender <span class="hljs-keyword">string</span> <span class="hljs-comment">// json 序列化是默认使用字段名作为 key</span><br>name   <span class="hljs-keyword">string</span> <span class="hljs-comment">// 私有不能被 json 包访问</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := Student&#123;<br>ID:     <span class="hljs-number">1</span>,<br>Gender: <span class="hljs-string">&quot;男&quot;</span>,<br>name:   <span class="hljs-string">&quot;张三&quot;</span>,<br>&#125;<br>data, err := json.Marshal(s1)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;json marshal failed!&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, data) <span class="hljs-comment">// &#123;&quot;id&quot;:1,&quot;Gender&quot;:&quot;男&quot;&#125;</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——Map</title>
    <link href="/2022/01/02/Go%E2%80%94%E2%80%94Map/"/>
    <url>/2022/01/02/Go%E2%80%94%E2%80%94Map/</url>
    
    <content type="html"><![CDATA[<h3 id="1-定义-Map"><a href="#1-定义-Map" class="headerlink" title="1. 定义 Map"></a>1. 定义 Map</h3><blockquote><p>var　map_variable　map[key_data_type]　value_data_type</p></blockquote><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> student <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span><br></code></pre></div></td></tr></table></figure><ul><li>key、value的类型：bool、数字、string、指针、channel 、还可以是只包含前面几个类型的接口、结构体、数组</li><li>key 通常为 int 、string 类型，value 通常为数字（整数、浮点数）、string、map、结构体</li><li>key：slice、map、function 不可以</li><li>map 只申明不会进行内存分配</li><li>map 的 key-value 是无序的</li><li>key 是不可以重复的</li><li>value 可以重复</li></ul><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> student <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span><br><span class="hljs-comment">// 第一种</span><br>student = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>, <span class="hljs-number">10</span>)<br>student[<span class="hljs-number">00001</span>] = <span class="hljs-string">&quot;张三&quot;</span><br><br><span class="hljs-comment">// 第二种</span><br>stu := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>)<br>stu[<span class="hljs-number">00002</span>] = <span class="hljs-string">&quot;李四&quot;</span><br><br><span class="hljs-comment">// 第三种</span><br>stud := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>&#123;<br><span class="hljs-number">00003</span>: <span class="hljs-string">&quot;王五&quot;</span>,<br><span class="hljs-number">00004</span>: <span class="hljs-string">&quot;赵六&quot;</span>,<br>&#125;<br><br>fmt.Println(stud)<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-操作"><a href="#3-操作" class="headerlink" title="3. 操作"></a>3. 操作</h3><ol><li><p>增加、更新操作<br> map[“key”] = value<br> 如果 key 不存在，进行新增，如果 key 存则覆盖。</p></li><li><p>删除操作<br>delete(map，”key”)<br>如果 key 存在，就删除该 key-value，如果 key 不存在，不操作也不会报错。</p></li><li><p>清空操作<br>（1）可以遍历key，逐个删除<br>（2）或者map = make(…)，make一个新的，让原来的成为垃圾，被gc回收</p></li><li><p>查找操作<br>value ,bool = map[key]<br>value 为返回的 value，bool 为是否返回</p></li><li><p>获取长度：len函数</p></li><li><p>遍历：for-range</p></li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>student := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>)<br><br>student[<span class="hljs-number">00001</span>] = <span class="hljs-string">&quot;张三&quot;</span><br>student[<span class="hljs-number">00001</span>] = <span class="hljs-string">&quot;李四&quot;</span><br>student[<span class="hljs-number">00002</span>] = <span class="hljs-string">&quot;王五&quot;</span><br>fmt.Println(student)<br><span class="hljs-comment">// map[1:李四 2:王五]</span><br><br><span class="hljs-comment">// 查找</span><br>s := student[<span class="hljs-number">0001</span>]<br>fmt.Println(s) <span class="hljs-comment">// 李四</span><br>s2, b := student[<span class="hljs-number">0004</span>]<br>fmt.Println(s2, b) <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">for</span> i, s3 := <span class="hljs-keyword">range</span> student &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v --- %v \n&quot;</span>, i, s3)<br>&#125;<br><br><span class="hljs-comment">// 删除</span><br><span class="hljs-built_in">delete</span>(student, <span class="hljs-number">001</span>)<br><span class="hljs-built_in">delete</span>(student, <span class="hljs-number">003</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(student)) <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 清空</span><br>student = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(student)) <span class="hljs-comment">// 0</span><br><br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="4-比较"><a href="#4-比较" class="headerlink" title="4. 比较"></a>4. 比较</h3><p>map 之间也不能进行相等比较；唯一的例外是和nil进行比较。要判断两个 map 是否包含相同的 key 和 value，我们必须通过一个循环实现：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">equal</span><span class="hljs-params">(x, y <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(x) != <span class="hljs-built_in">len</span>(y) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">for</span> k, xv := <span class="hljs-keyword">range</span> x &#123;<br><span class="hljs-keyword">if</span> yv, ok := y[k]; !ok || yv != xv &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——切片</title>
    <link href="/2022/01/02/Go%E2%80%94%E2%80%94%E5%88%87%E7%89%87/"/>
    <url>/2022/01/02/Go%E2%80%94%E2%80%94%E5%88%87%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>切片（slice）是对数组的一个连续片段的引用，所以切片是一个引用类型，这个片段可以是整个数组，也可以是由起始和终止索引标识的一些项的子集，需要注意的是，终止索引标识的项不包括在切片内。</p><p>一个 slice 由三个部分构成：指针、长度和容量。指针指向第一个 slice 元素对应的底层数组元素的地址，要注意的是 slice 的第一个元素并不一定就是数组的第一个元素。</p><h3 id="1-切片的定义"><a href="#1-切片的定义" class="headerlink" title="1. 切片的定义"></a>1. 切片的定义</h3><ol><li><p>从数组或切片生成新的切片</p><p>语法：slice [开始位置 : 结束位置]</p><blockquote><p>从数组或切片生成新的切片拥有如下特性：</p><ul><li>取出的元素数量为：结束位置 - 开始位置；</li><li>取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取；</li><li>当缺省开始位置时，表示从连续区域开头到结束位置；</li><li>当缺省结束位置时，表示从开始位置到整个连续区域末尾；</li><li>两者同时缺省时，与切片本身等效；</li><li>两者同时为 0 时，等效于空切片，一般用于切片复位。</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">/* 数组长度为 5 */</span><br><span class="hljs-keyword">var</span>  array = [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span> &#123;<span class="hljs-number">1000</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">17</span>, <span class="hljs-number">50</span>&#125;<br><br>slice := array[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]<br><span class="hljs-comment">// [1000 2 3 17]</span><br>slice2 := slice[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]<br><span class="hljs-comment">// [1000 2 3]</span><br><br>fmt.Printf(<span class="hljs-string">&quot;%T&quot;</span>,slice)<br><span class="hljs-comment">// []int</span><br>fmt.Printf(<span class="hljs-string">&quot;%v,%v&quot;</span>,<span class="hljs-built_in">len</span>(slice2),<span class="hljs-built_in">cap</span>(slice2))<br><span class="hljs-comment">// 3,5</span><br>&#125;<br></code></pre></div></td></tr></table></figure></li><li><p>使用 make() 函数构造切片</p></li></ol><blockquote><p>语法：make( []Type, size, cap )    </p></blockquote><p> make 底层创建一个数组，对外不可见</p> <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br>fmt.Println(slice)<br><span class="hljs-comment">//[0 0 0 0 0]</span><br><br>fmt.Printf(<span class="hljs-string">&quot;长度：%v，容量：%v&quot;</span>, <span class="hljs-built_in">len</span>(slice), <span class="hljs-built_in">cap</span>(slice))<br><span class="hljs-comment">// 长度：5，容量：10</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="3"><li>直接声明新的切片</li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>slice := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">23</span>, <span class="hljs-number">45</span>, <span class="hljs-number">67</span>&#125;<br>fmt.Println(slice)<br><span class="hljs-comment">//[23 45 67]</span><br><br>fmt.Printf(<span class="hljs-string">&quot;长度：%v，容量：%v&quot;</span>, <span class="hljs-built_in">len</span>(slice), <span class="hljs-built_in">cap</span>(slice))<br><span class="hljs-comment">// 长度：3，容量：3</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-切片的遍历"><a href="#2-切片的遍历" class="headerlink" title="2. 切片的遍历"></a>2. 切片的遍历</h3><p>方式1：for循环常规方式遍历<br>方式2：for-range 结构遍历切片</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>slice := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">23</span>, <span class="hljs-number">45</span>, <span class="hljs-number">67</span>&#125;<br><br><span class="hljs-comment">//方式1：普通for循环</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(slice); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;slice[%v] = %v \t&quot;</span>, i, slice[i])<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;\n------------------------------&quot;</span>)<br><span class="hljs-comment">//方式2：for-range循环：</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> slice &#123;<br>fmt.Printf(<span class="hljs-string">&quot;下标：%v ，元素：%v\n&quot;</span>, i, v)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-切片的操作"><a href="#3-切片的操作" class="headerlink" title="3. 切片的操作"></a>3. 切片的操作</h3><h4 id="3-1-添加元素"><a href="#3-1-添加元素" class="headerlink" title="3.1 添加元素"></a>3.1 添加元素</h4><p>用 append() 函数为切片动态添加元素时，如果空间不足，切片就会进行“扩容”。切片在扩容时，容量的扩展规律是按容量的 2 倍数进行扩充。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a []<span class="hljs-keyword">int</span><br>a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">1</span>)                 <span class="hljs-comment">// 追加1个元素</span><br>a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)           <span class="hljs-comment">// 追加多个元素, 手写解包方式</span><br>a = <span class="hljs-built_in">append</span>(a, []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;...) <span class="hljs-comment">// 追加一个切片, 切片需要解包</span><br><br>fmt.Println(a)<br><span class="hljs-comment">// [1 1 2 3 1 2 3]</span><br><br><span class="hljs-keyword">var</span> b = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>b = <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>&#125;, b...)          <span class="hljs-comment">// 在开头添加1个元素</span><br>b = <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">-3</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>&#125;, b...) <span class="hljs-comment">// 在开头添加1个切片</span><br>fmt.Println(b)<br><span class="hljs-comment">// [-3 -2 -1 0 1 2 3]</span><br><br><span class="hljs-keyword">var</span> c []<span class="hljs-keyword">int</span> = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>c = <span class="hljs-built_in">append</span>(c[:<span class="hljs-number">1</span>], <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">100</span>&#125;, c[<span class="hljs-number">1</span>:]...)...)     <span class="hljs-comment">// 在第i个位置插入x</span><br>c = <span class="hljs-built_in">append</span>(c[:<span class="hljs-number">2</span>], <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, c[<span class="hljs-number">2</span>:]...)...) <span class="hljs-comment">// 在第i个位置插入切片</span><br>fmt.Println(c)<br><span class="hljs-comment">// [1 100 0 0 0 2 3]</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>在切片开头添加元素一般都会导致内存的重新分配，而且会导致已有元素全部被复制 1 次，因此，从切片的开头添加元素的性能要比从尾部追加元素的性能差很多。</p><h4 id="3-2-切片复制"><a href="#3-2-切片复制" class="headerlink" title="3.2 切片复制"></a>3.2 切片复制</h4><blockquote><p>语法：copy( destSlice, srcSlice []T) int<br>将 srcSlice 复制到 destSlice</p></blockquote><p> copy() 可以将一个数组切片复制到另一个数组切片中，如果加入的两个数组切片不一样大，就会按照其中较小的那个数组切片的元素个数进行复制。</p><p>来源和目标的类型必须一致，copy() 函数的返回值表示实际发生复制的元素个数。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice1 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>slice2 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-built_in">copy</span>(slice2, slice1) <span class="hljs-comment">// 只会复制slice1的前3个元素到slice2中</span><br>fmt.Println(slice2)<br><span class="hljs-comment">// [1 2 3]</span><br><br><span class="hljs-built_in">copy</span>(slice1, slice2) <span class="hljs-comment">// 只会复制slice2的3个元素到slice1的前3个位置</span><br>fmt.Println(slice1)<br><span class="hljs-comment">// [1 2 3 4 5]</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="3-3-删除元素"><a href="#3-3-删除元素" class="headerlink" title="3.3 删除元素"></a>3.3 删除元素</h4><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br>a = a[<span class="hljs-number">2</span>:] <span class="hljs-comment">// 删除开头N个元素</span><br>a = <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">0</span>], a[<span class="hljs-number">3</span>:]...) <span class="hljs-comment">// 删除开头N个元素</span><br><br>fmt.Println(a)<br><span class="hljs-comment">// [6 7 8 9]</span><br><br>a = <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">1</span>], a[<span class="hljs-number">1</span>+<span class="hljs-number">1</span>:]...) <span class="hljs-comment">// 删除中间N个元素</span><br><br>a = a[:<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-2</span>] <span class="hljs-comment">// 删除尾部N个元素</span><br><br>fmt.Println(a)<br><span class="hljs-comment">// [6]</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——数组</title>
    <link href="/2022/01/01/Go%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/01/Go%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="1-数组的申明"><a href="#1-数组的申明" class="headerlink" title="1. 数组的申明"></a>1. 数组的申明</h3><blockquote><p>var　variable_name　[SIZE]variable_type</p></blockquote><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> scores [<span class="hljs-number">5</span>]<span class="hljs-keyword">int16</span><br><br>fmt.Println(scores)         <span class="hljs-comment">// [0 0 0 0 0]</span><br>fmt.Println(<span class="hljs-built_in">len</span>(scores))    <span class="hljs-comment">// 5</span><br>fmt.Printf(<span class="hljs-string">&quot;%T \n&quot;</span>, scores) <span class="hljs-comment">// [5]int16</span><br><br>fmt.Printf(<span class="hljs-string">&quot;数组的地址：%p \n&quot;</span>, &amp;scores) <span class="hljs-comment">// 0xc0000ac070</span><br><span class="hljs-comment">//第一个空间的地址：</span><br>fmt.Printf(<span class="hljs-string">&quot;第一个元素地址：%p \n&quot;</span>, &amp;scores[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 0xc0000ac070</span><br><span class="hljs-comment">//第二个空间的地址：</span><br>fmt.Printf(<span class="hljs-string">&quot;第二个元素地址：%p \n&quot;</span>, &amp;scores[<span class="hljs-number">1</span>]) <span class="hljs-comment">// 0xc0000ac072</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>【注】</p><ol><li>数组的地址即第一个元素的地址，数组每个元素占用的字节数取决于数组类型。</li><li>长度属于类型的一部分 </li><li>Go 中数组属值类型，在默认情况下是值传递，因此会进行值拷贝。</li></ol><h3 id="2-数组的初始化"><a href="#2-数组的初始化" class="headerlink" title="2. 数组的初始化"></a>2. 数组的初始化</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//第一种：</span><br><span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span> = [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>&#125;<br>fmt.Println(arr1)<br><span class="hljs-comment">//第二种：</span><br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>&#125;<br>fmt.Println(arr2)<br><span class="hljs-comment">//第三种：</span><br><span class="hljs-keyword">var</span> arr3 = [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;<br>fmt.Println(arr3)<br><span class="hljs-comment">//第四种：</span><br><span class="hljs-keyword">var</span> arr4 = [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">2</span>: <span class="hljs-number">66</span>, <span class="hljs-number">0</span>: <span class="hljs-number">33</span>, <span class="hljs-number">1</span>: <span class="hljs-number">99</span>, <span class="hljs-number">3</span>: <span class="hljs-number">88</span>&#125;<br>fmt.Println(arr4)<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-数组的遍历"><a href="#3-数组的遍历" class="headerlink" title="3. 数组的遍历"></a>3. 数组的遍历</h3><ol><li>for 循环</li><li> for range</li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> scores [<span class="hljs-number">5</span>]<span class="hljs-keyword">int16</span> = [<span class="hljs-number">5</span>]<span class="hljs-keyword">int16</span>&#123;<span class="hljs-number">56</span>, <span class="hljs-number">34</span>, <span class="hljs-number">78</span>, <span class="hljs-number">94</span>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(scores); i++ &#123;<br>fmt.Println(scores[i])<br>&#125;<br><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> scores &#123;<br>fmt.Println(v)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-二维数组"><a href="#4-二维数组" class="headerlink" title="4. 二维数组"></a>4. 二维数组</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> array1 [<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]<span class="hljs-keyword">int16</span> = [<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]<span class="hljs-keyword">int16</span>&#123;&#123;<span class="hljs-number">32</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">32</span>&#125;&#125;<br>fmt.Println(array1)<br><br><span class="hljs-keyword">var</span> array [<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]<span class="hljs-keyword">int16</span><br><span class="hljs-comment">// 赋值</span><br>array[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">32</span><br>array[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">32</span><br>fmt.Println(array)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(array); i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(array[i]); j++ &#123;<br>fmt.Print(array[i][j], <span class="hljs-string">&quot;\t&quot;</span>)<br>&#125;<br>fmt.Println()<br>&#125;<br><br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> array &#123;<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> value &#123;<br>fmt.Printf(<span class="hljs-string">&quot;arr[%v][%v]=%v\t&quot;</span>, key, k, v)<br>&#125;<br>fmt.Println()<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="5-向函数传递数组"><a href="#5-向函数传递数组" class="headerlink" title="5. 向函数传递数组"></a>5. 向函数传递数组</h3><p>void myFunction(param [10]int){}<br>void myFunction(param []int)</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">/* 数组长度为 5 */</span><br><span class="hljs-keyword">var</span>  balance = []<span class="hljs-keyword">int</span> &#123;<span class="hljs-number">1000</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">17</span>, <span class="hljs-number">50</span>&#125;<br><span class="hljs-keyword">var</span> avg <span class="hljs-keyword">float32</span><br><br>avg = getAverage( balance, <span class="hljs-number">5</span> )<br>fmt.Printf( <span class="hljs-string">&quot;平均值为: %f &quot;</span>, avg )<br><br><span class="hljs-keyword">var</span>  balance2 = [<span class="hljs-number">6</span>]<span class="hljs-keyword">int</span> &#123;<span class="hljs-number">1000</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">17</span>, <span class="hljs-number">50</span>&#125;<br>avg = getAverage2( balance2)<br>fmt.Printf( <span class="hljs-string">&quot;平均值为: %f &quot;</span>, avg )<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getAverage</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, size <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">float32</span></span> &#123;<br><span class="hljs-keyword">var</span> i,sum <span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> avg <span class="hljs-keyword">float32</span><br><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; i &lt; size;i++ &#123;<br>sum += arr[i]<br>&#125;<br>avg = <span class="hljs-keyword">float32</span>(sum) / <span class="hljs-keyword">float32</span>(size)<br><span class="hljs-keyword">return</span> avg<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getAverage2</span><span class="hljs-params">(arr [6]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">float32</span></span> &#123;<br><span class="hljs-keyword">var</span> i,sum <span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> avg <span class="hljs-keyword">float32</span><br><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr);i++ &#123;<br>sum += arr[i]<br>&#125;<br>avg = <span class="hljs-keyword">float32</span>(sum) / <span class="hljs-keyword">float32</span>(<span class="hljs-built_in">len</span>(arr))<br><span class="hljs-keyword">return</span> avg<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——异常处理</title>
    <link href="/2021/12/30/Go%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2021/12/30/Go%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="1-defer-recover-机制处理错误"><a href="#1-defer-recover-机制处理错误" class="headerlink" title="1. defer+recover 机制处理错误"></a>1. defer+recover 机制处理错误</h3><blockquote><p>func recover() interface{}</p></blockquote><p>内建函数 recover 允许程序管理恐慌过程中的 Go 程。在 defer 的函数中，执行 recover 调用会取回传至 panic 调用的错误值，恢复正常执行，停止恐慌过程。若 recover 在 defer 的函数之外被调用，它将不会停止恐慌过程序列。在此情况下，或当该 Go 程不在恐慌过程中时，或提供给 panic 的实参为 nil 时，recover 就会返回nil。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>result := division(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)<br>fmt.Println(result)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">division</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>err := <span class="hljs-built_in">recover</span>()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;捕获到异常:&quot;</span>, err)<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">return</span> num1 / num2<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211230233446.png"></p><h3 id="2-自定义错误"><a href="#2-自定义错误" class="headerlink" title="2. 自定义错误"></a>2. 自定义错误</h3><p>调用 errors 包下的 New 函数，函数返回 error 类型。</p><blockquote><p>func New(text string) error</p></blockquote><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>result, err := division(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><br>fmt.Println(result)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">division</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;<br><br><span class="hljs-keyword">if</span> num2 == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;integer divide by zero&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> num1 / num2, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211230234230.png"></p><h3 id="3-出现异常后中断程序"><a href="#3-出现异常后中断程序" class="headerlink" title="3. 出现异常后中断程序"></a>3. 出现异常后中断程序</h3><blockquote><p>func panic(v interface{})</p></blockquote><p> 内建函数 panic 停止当前 Go 程的正常执行。当函数 F 调用 panic 时，F 的正常执行就会立刻停止。F 中 defer 的所有函数先入后出执行后，F 返回给其调用者 G。G 如同 F 一样行动，层层返回，直到该 Go 程中所有函数都按相反的顺序停止执行。之后，程序被终止，而错误情况会被报告，包括引发该恐慌的实参值，此终止序列称为恐慌过程。</p> <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>result, err := division(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(result)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">division</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;<br><br><span class="hljs-keyword">if</span> num2 == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;integer divide by zero&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> num1 / num2, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211230234827.png"></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——函数</title>
    <link href="/2021/12/29/Go%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/"/>
    <url>/2021/12/29/Go%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1-函数"><a href="#1-函数" class="headerlink" title="1. 函数"></a>1. 函数</h3><p><strong>基本语法：</strong><br>func   函数名（形参列表) [ 返回值类型列表 ] {<br> 　　执行语句..<br>　　return　返回值列表<br>}</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span> &#123; <span class="hljs-comment">// 如果返回值类型只有一个，那么()是可以省略不写</span><br><span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br></code></pre></div></td></tr></table></figure><ol><li>函数名</li></ol><ul><li>驼峰命名  </li><li>首字母不能是数字</li><li>首字母大写该函数可以被本包文件和其它包文件使用</li><li>首学母小写只能被本包文件使用</li></ul><ol start="2"><li><p>形参列表：<br>形参可以是一个参数，可以是n个参数，可以是0个参数</p></li><li><p>返回值类型列表<br>如果有多个返回值，用 () 括起来；如果返回值类型只有一个，可以省略 ()；如果没有返回值，什么都不用写。在函数调用时，如果有返回值不想接收，可以用 _ 忽略。</p></li><li><p>值传递和引用传递<br>基本数据类型和数组默认都是值传递的，即进行值拷贝</p></li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> num <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><br>aa(num)<br>fmt.Println(num)<span class="hljs-comment">// 10</span><br>bb(&amp;num)<br>fmt.Println(num)<span class="hljs-comment">// 200</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">aa</span><span class="hljs-params">(int2 <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>int2 = <span class="hljs-number">100</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bb</span><span class="hljs-params">(int2 *<span class="hljs-keyword">int</span>)</span></span>  &#123;<br>*int2 = <span class="hljs-number">200</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="5"><li><p>Golang 中函数不支持重载</p></li><li><p>支持可变参数<br>函数内将可变参数当做切片来处理</p></li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>test(<span class="hljs-number">37</span>, <span class="hljs-number">58</span>, <span class="hljs-number">39</span>, <span class="hljs-number">59</span>, <span class="hljs-number">47</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(args ...<span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(args); i++ &#123;<br>fmt.Println(args[i])<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="7"><li>在 Go 中函数也是一种数据类型，可以赋值给一个变量，通过该变量可以对函数调用。</li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(num <span class="hljs-keyword">int</span>)</span></span> &#123;<br>fmt.Println(num)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>a := test<br>fmt.Printf(<span class="hljs-string">&quot;a的类型：%T，test函数的类型：%T \n&quot;</span>, a, test)<br><span class="hljs-comment">// a的类型：func(int)，test函数的类型：func(int)</span><br>a(<span class="hljs-number">10</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="8"><li>函数既然是一种数据类型，因此在 Go 中，函数可以作为形参。</li></ol>  <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(str <span class="hljs-keyword">string</span>)</span></span> &#123;<br>fmt.Println(str)<br>&#125;<br><br><span class="hljs-comment">//定义一个函数，把另一个函数作为形参</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test02</span><span class="hljs-params">(testFunc <span class="hljs-keyword">func</span>(string2 <span class="hljs-keyword">string</span>)</span>)</span> &#123;<br>testFunc(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>a := test<br>test02(a)<br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="9"><li>为了简化数据类型定义，Go 支持自定义数据类型 基本语法：type　自定义数据类型名　数据类型</li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">type</span> myInt <span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> num myInt = <span class="hljs-number">100</span><br><br><span class="hljs-comment">// 虽然是别名，但是还是两种不同的类型</span><br><span class="hljs-comment">//var num2 int = num</span><br><br><span class="hljs-keyword">var</span> num2 <span class="hljs-keyword">int</span> = <span class="hljs-keyword">int</span>(num)<br>fmt.Println(num2)<br><br><span class="hljs-keyword">type</span> myFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span><br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="10"><li>支持对函数返回值命名</li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;<br>sum := num1 + num2<br>sub := num1 - num2<br><span class="hljs-keyword">return</span> sum, sub<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test2</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(sum <span class="hljs-keyword">int</span>, sub <span class="hljs-keyword">int</span>)</span></span> &#123;<br>sum = num1 + num2<br>sub = num1 - num2<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-包"><a href="#2-包" class="headerlink" title="2. 包"></a>2. 包</h3><ol><li><p>package 进行包的声明<br>建议：包的声明和所在的文件夹同名</p></li><li><p>main 包是程序的入口包<br>main 函数一定要放在 main 包下，否则不能编译执行</p></li><li><p>包的引入<br>语法：import  “包的路径”<br>包名是从 $GOPATH/src/ 后开始的，使用 / 进行路径分隔。<br>【注：未开启 go modules 的情况下】</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211230161703.png"></p></li><li><p>包名和文件夹的名字，可以不一样，建议一致</p><p> <img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211230162839.png"> </p></li><li><p>一个目录下只能声明一个 package，所以一个目录下不能有重复的函数</p></li><li><p>可以给包取别名，取别名后，原来的包名就不能使用了</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211230163246.png"></p></li></ol><h3 id="3-init函数"><a href="#3-init函数" class="headerlink" title="3. init函数"></a>3. init函数</h3><p> 初始化函数，可以用来进行一些初始化的操作</p><p>每一个源文件都可以包含一个 init 函数，该函数会在 main 函数执行前，被 Go 运行框架调用。</p><p>全局变量定义，init 函数，main 函数的执行流程：</p><p>全局变量 –&gt; init 函数 –&gt; main 函数</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> global <span class="hljs-keyword">int</span> = get()<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;get....&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">100</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;init....&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;main......&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211230174442.png"></p><p>多个源文件都有init函数的时候，如何执行：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211230174547.png"></p><h4 id="4-匿名函数"><a href="#4-匿名函数" class="headerlink" title="4. 匿名函数"></a>4. 匿名函数</h4><p>匿名函数使用方式：</p><ol><li>在定义匿名函数时就直接调用，这种方式匿名函数只能调用一次</li></ol> <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>result := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> num1 + num2<br>&#125;(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br><br>fmt.Println(result)<br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="2"><li>将匿名函数赋给一个变量，再通过该变量来调用匿名函数</li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>add := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br>fmt.Println(add(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5. 闭包"></a>5. 闭包</h4><p>闭包就是一个函数和与其相关的引用环境组合的一个整体</p><p>闭包的本质：闭包本质依旧是一个匿名函数，只是这个函数引入外界的变量/参数<br>匿名函数 + 引用的变量/参数 = 闭包</p><p>（ 当一个函数的返回值是另外一个函数，而返回的这个函数如果调用了其父函数内部的变量，且返回的这个函数在外部被执行，就产生了闭包。闭包是一个环境，具体指的就是外部函数–高阶函数。）</p><p>特点：</p><ol><li>返回的是一个匿名函数，但是这个匿名函数引用到函数外的变量/参数 ,因此这个匿名函数就和变量/参数形成一个整体，构成闭包。</li><li>闭包中使用的变量/参数会一直保存在内存中</li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getSum</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">var</span> sum <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>sum = sum + num<br><span class="hljs-keyword">return</span> sum<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f := getSum()<br>fmt.Println(f(<span class="hljs-number">1</span>)) <span class="hljs-comment">// 1</span><br>fmt.Println(f(<span class="hljs-number">2</span>)) <span class="hljs-comment">// 3</span><br>fmt.Println(f(<span class="hljs-number">3</span>)) <span class="hljs-comment">// 6</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>用处：</p><ol><li>读取函数内部的变量</li><li>这些变量的值始终保持在内存中，不会在外层函数调用后被自动清除</li></ol><p>优点：</p><ol><li>变量长期驻扎在内存中</li><li>避免全局变量的污染</li></ol><p>缺点：</p><ol><li>常驻内存 会增大内存的使用量</li></ol><h3 id="5-defer关键字"><a href="#5-defer关键字" class="headerlink" title="5. defer关键字"></a>5. defer关键字</h3><p>defer提供延迟机制，会将要延迟执行的方法“压栈”，当 defer 被触发时，将所有“压栈”的方法“出栈”并执行。</p><p>defer 的执行时机：</p><ol><li>包裹 defer 的函数返回时</li><li>包裹 defer 的函数执行到末尾时</li><li>所在的 goroutine 发生 panic 时</li></ol><p>【注】调用 os.Exit() 方法退出程序时，不会执行</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getSum</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;num1：&quot;</span>, num1)<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;num2：&quot;</span>, num2)<br><br>sum := num1 + num2<br>fmt.Println(<span class="hljs-string">&quot;sum：&quot;</span>, sum)<br><br><span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>getSum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="6-系统函数"><a href="#6-系统函数" class="headerlink" title="6. 系统函数"></a>6. 系统函数</h3><h4 id="6-1-内置函数"><a href="#6-1-内置函数" class="headerlink" title="6.1 内置函数"></a>6.1 内置函数</h4><p>new 函数：<br>分配内存，主要用来分配值类型（int系列, float系列, bool, string、数组和结构体 struct）</p><p>func new(Type) *Type<br>其第一个实参为类型，而非值。其返回值为指向该类型的新分配的零值的指针。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>num := <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>)<br>fmt.Printf(<span class="hljs-string">&quot;num 的类型：%T，num 的值：%v，num 的地址：%v， num 指针指向的值: %v&quot;</span>, num, num, &amp;num, *num)<br><span class="hljs-comment">//num 的类型：*int，num 的值：0xc0000a6058，num 的地址：0xc0000d2018， num 指针指向的值: 0</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>make函数:<br>func make(Type, size IntegerType) Type</p><p>make分配并初始化一个类型为切片、映射、或通道的对象。其第一个实参为类型，而非值。make的返回类型与其参数相同，而非指向它的指针。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>demo := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>)<br>fmt.Println( demo)<br><span class="hljs-comment">// [0 0 0 0 0 0 0 0 0 0]</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="6-1-字符串相关函数"><a href="#6-1-字符串相关函数" class="headerlink" title="6.1 字符串相关函数"></a>6.1 字符串相关函数</h4><ol><li><p>字符串转整数<br>n, err := strconv.Atoi(“66”)</p></li><li><p>整数转字符串<br>str := strconv.Itoa(6887)</p></li><li><p>不区分大小写比较字符串是否相同<br>func EqualFold(s, t string) bool</p></li><li><p>判断 s 是否有前缀字符串 prefix<br>func HasPrefix(s, prefix string) bool</p></li><li><p>判断 s 是否有后缀字符串 suffix<br>func HasSuffix(s, suffix string) bool</p></li><li><p>判断字符串 s 是否包含子串 substr<br>func Contains(s, substr string) bool</p></li><li><p>返回字符串 s 中有几个不重复的 sep 子串<br>func Count(s, sep string) int</p></li><li><p>子串 sep 在字符串s中第一次出现的位置，不存在则返回-1<br>func Index(s, sep string) int</p></li><li><p>子串 sep 在字符串 s 中最后一次出现的位置，不存在则返回-1<br>func LastIndex(s, sep string) int</p></li><li><p>将所有字母都转为对应的小写<br>func ToLower(s string) string</p></li><li><p>将所有字母都转为对应的大写<br>func ToUpper(s string) string</p></li><li><p>返回 count 个 s 串联的字符串。<br>func Repeat(s string, count int) string</p></li><li><p>将 s 中前 n 个不重叠 old 子串都替换为 new 的新字符串<br>func Replace(s, old, new string, n int) string</p></li><li><p>将 s 前后端所有 cutset  去掉<br>func Trim(s string, cutset string) string</p></li><li><p>将 s 前后端所有空白都去掉<br>func TrimSpace(s string) string</p></li><li><p>用去掉 s 中出现的 sep 的方式进行分割，返回生成的所有片段组成的切片<br>func Split(s, sep string) []string<br>每一个 sep 都会进行一次切割，即使两个 sep 相邻，也会进行两次切割。</p></li></ol><h4 id="6-2-时间相关函数"><a href="#6-2-时间相关函数" class="headerlink" title="6.2 时间相关函数"></a>6.2 时间相关函数</h4><p>时间和日期的函数在 time 包，time.Now() 返回当前时间。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>now := time.Now()<br>fmt.Printf(<span class="hljs-string">&quot;%v ~~~ 对应的类型为：%T\n&quot;</span>, now, now)<br><span class="hljs-comment">// 2021-12-30 19:36:01.1827252 +0800 CST m=+0.003000101 ~~~ 对应的类型为：time.Time</span><br><br><span class="hljs-comment">// 当前时间戳</span><br>fmt.Println(now.Unix())<br><span class="hljs-comment">// 纳秒级时间戳</span><br>fmt.Println(now.UnixNano())<br><span class="hljs-comment">// 时间戳小数部分 单位：纳秒</span><br>fmt.Println(now.Nanosecond())<br><br><span class="hljs-comment">//调用结构体中的方法：</span><br>fmt.Printf(<span class="hljs-string">&quot;年：%v \n&quot;</span>, now.Year())<br>fmt.Printf(<span class="hljs-string">&quot;月：%v \n&quot;</span>, now.Month())      <span class="hljs-comment">//月：February</span><br>fmt.Printf(<span class="hljs-string">&quot;月：%v \n&quot;</span>, <span class="hljs-keyword">int</span>(now.Month())) <span class="hljs-comment">//月：2</span><br>fmt.Printf(<span class="hljs-string">&quot;日：%v \n&quot;</span>, now.Day())<br>fmt.Printf(<span class="hljs-string">&quot;时：%v \n&quot;</span>, now.Hour())<br>fmt.Printf(<span class="hljs-string">&quot;分：%v \n&quot;</span>, now.Minute())<br>fmt.Printf(<span class="hljs-string">&quot;秒：%v \n&quot;</span>, now.Second())<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>根据指定时间返回 time.Time</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>now := time.Now()<br>layout := <span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span><br><br><span class="hljs-comment">//根据指定时间返回 time.Time 类型</span><br><span class="hljs-comment">//分别指定年，月，日，时，分，秒，纳秒，时区</span><br>t := time.Date(<span class="hljs-number">2011</span>, time.Month(<span class="hljs-number">3</span>), <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, now.Location())<br>fmt.Println(t.Format(layout))<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>日期字符串解析成 time.Time</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t, _ := time.ParseInLocation(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>, time.Now().Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>), time.Local)<br>fmt.Println(t)<br><span class="hljs-comment">// 2021-12-30 19:54:31 +0800 CST</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211230195731.png"></p><p><strong>日期的格式化</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>now := time.Now()<br><br>fmt.Println( now.Format(<span class="hljs-string">&quot;2006/01/02 15/04/05&quot;</span>))<br><span class="hljs-comment">// 2021/12/30 19/46/44</span><br><br>fmt.Println(now.Format(<span class="hljs-string">&quot;2006 15:04&quot;</span>))<br><span class="hljs-comment">//2021 19:46</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>计算、比较日期</strong></p><p>0-24小时之内的时间计算:</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br><br><span class="hljs-comment">// 1小时1分1s之后</span><br>t1, _ := time.ParseDuration(<span class="hljs-string">&quot;1h1m1s&quot;</span>)<br>m1 := now.Add(t1)<br>fmt.Println(m1)<br><br><span class="hljs-comment">// 1小时1分1s之前</span><br>t2, _ := time.ParseDuration(<span class="hljs-string">&quot;-1h1m1s&quot;</span>)<br>m2 := now.Add(t2)<br>fmt.Println(m2)<br><br><span class="hljs-comment">// 3小时之前</span><br>t3, _ := time.ParseDuration(<span class="hljs-string">&quot;-1h&quot;</span>)<br>m3 := now.Add(t3 * <span class="hljs-number">3</span>)<br>fmt.Println(m3)<br><br><span class="hljs-comment">// 10 分钟之后</span><br>t4, _ := time.ParseDuration(<span class="hljs-string">&quot;10m&quot;</span>)<br>m4 := now.Add(t4)<br>fmt.Println(m4)<br><br><span class="hljs-comment">// Sub 计算两个时间差</span><br>sub1 := now.Sub(m3)<br>fmt.Println(sub1.Hours())   <span class="hljs-comment">// 相差小时数</span><br>fmt.Println(sub1.Minutes()) <span class="hljs-comment">// 相差分钟数</span><br><br><br><br><span class="hljs-comment">// 返回当前时间与 t 的时间差，返回值是 Duration</span><br><span class="hljs-comment">// time.Since(t Time) Duration</span><br><br><span class="hljs-comment">// 返回 t 与当前时间的时间差，返回值是 Duration</span><br><span class="hljs-comment">// time.Until(t Time) Duration</span><br><br><br>t5, _ := time.ParseDuration(<span class="hljs-string">&quot;-1h&quot;</span>)<br>m5 := now.Add(t5)<br><br>fmt.Println(time.Since(m5))<br>fmt.Println(time.Until(m5))<br>&#125;<br><br><br></code></pre></div></td></tr></table></figure><p>1-24小时之外的时间计算</p><p>func (t Time) AddDate(years int, months int, days int) Time</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br>fmt.Println(now)<br><span class="hljs-comment">// 一年一个月零一天 </span><br>m1 := now.AddDate(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>fmt.Println(m1)<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>日期比较</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br><br><span class="hljs-comment">// 1小时之后</span><br>t1, _ := time.ParseDuration(<span class="hljs-string">&quot;1h&quot;</span>)<br>m1 := now.Add(t1)<br><br>fmt.Println(m1.After(now))  <span class="hljs-comment">// true</span><br>fmt.Println(now.Before(m1))<span class="hljs-comment">// true</span><br>fmt.Println(now.Equal(m1))<span class="hljs-comment">// false</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——流程控制</title>
    <link href="/2021/12/29/Go%E2%80%94%E2%80%94%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2021/12/29/Go%E2%80%94%E2%80%94%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="1-分支结构"><a href="#1-分支结构" class="headerlink" title="1. 分支结构"></a>1. 分支结构</h3><h4 id="1-1-if-分支"><a href="#1-1-if-分支" class="headerlink" title="1.1 if 分支"></a>1.1 if 分支</h4><p><strong>基本语法：</strong></p><p>if  条件表达式1 {<br>    　逻辑代码1<br>} else if　条件表达式2 {<br>   　逻辑代码2<br>}<br>…….<br>else {<br>  　逻辑代码n<br>}</p><blockquote><ul><li>条件表达式左右的 () 可以不写，也建议不写。</li><li>if 和表达式中间，一定要有空格。</li><li>{} 是必须有的，即使逻辑代码只有一行。</li><li>else 和上一个代码块结束的 { 必须在同一行，不能换行</li></ul></blockquote><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211229113906.png"></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> score = <span class="hljs-number">80</span><br><br><span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">90</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;A&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">80</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;B&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">70</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;C&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">60</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;D&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;E&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="1-2-switch-分支"><a href="#1-2-switch-分支" class="headerlink" title="1.2 switch 分支"></a>1.2 switch 分支</h4><p><strong>基本语法：</strong></p><p>switch 表达式 {<br>　case 值1,值2,.….<strong>:</strong><br>　　　语句块1<br>　case 值3,值4,…<strong>:</strong><br>　　　语句块2<br>　 ….<br>　default <strong>:</strong><br>　　　 语句块<br>}</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> score <span class="hljs-keyword">int</span> = <span class="hljs-number">89</span><br><br><span class="hljs-keyword">switch</span> score / <span class="hljs-number">10</span> &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">10</span>, <span class="hljs-number">9</span>:<br>fmt.Println(<span class="hljs-string">&quot;A&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>fmt.Println(<span class="hljs-string">&quot;B&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>fmt.Println(<span class="hljs-string">&quot;C&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>fmt.Println(<span class="hljs-string">&quot;D&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;E&quot;</span>)<br>&#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><ol><li>switch 后是一个表达式（即:常量值、变量、一个有返回值的函数等）</li><li>case 后面的值如果是常量值(字面量)，则要求不能重复</li></ol><p>  <img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211229123557.png"></p><p>  <img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211229123520.png"></p><ol start="3"><li>case 后的各个值的数据类型，必须和 switch 的表达式数据类型一致</li><li>case 后面可以带多个值，使用逗号间隔</li><li>case 后面不需要带 break ，默认不穿透</li><li>default 语句不是必须的，位置也是随意的<br>(所有 case 不匹配才执行)<img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211229124313.png"></li><li>switch 后也可以不带表达式，当做 if 分支来使用<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> score <span class="hljs-keyword">int</span> = <span class="hljs-number">69</span><br><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">60</span>:<br>fmt.Println(<span class="hljs-string">&quot;及格&quot;</span>)<br><span class="hljs-keyword">case</span> score &lt; <span class="hljs-number">60</span>:<br>fmt.Println(<span class="hljs-string">&quot;不及格&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure></li><li>利用 fallthrough 关键字进行 switch 穿透，继续执行下一个case</li></ol><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211229125520.png"></p><p><font color="red"><strong>java 中的 switch：</strong></font></p><blockquote><p> case 标签必须为字符串常量或字面量。<br>支持的类型：</p><blockquote><p>Java5 以前，只支持 byte，short，char，int 类型<br>Java5 引入了枚举类型和 byte，short，char，int 的包装类<br>从Java7开始，支持 String 类型</p></blockquote></blockquote><p>（byte、short、char 类型可以在不损失精度的情况下向上转型成int类型。枚举类型的支持是因为枚举类有一个 ordinal 方法,该方法返回一个 int 类型的值。支持 String 是利用 String 的 hash 值，本质上也是 switch-int 结构，并且通过 equals 方法来防止 hash 冲突，用 switch-byte 结构精确匹配。)</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (<span class="hljs-string">&quot;A&quot;</span>) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;A&quot;</span> :<br>                System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;B&quot;</span> :<br>                System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>反编译结果：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] var0)</span> </span>&#123;<br>        String var1 = <span class="hljs-string">&quot;A&quot;</span>;<br>        <span class="hljs-keyword">byte</span> var2 = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">switch</span>(var1.hashCode()) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">65</span>:<br>            <span class="hljs-keyword">if</span> (var1.equals(<span class="hljs-string">&quot;A&quot;</span>)) &#123;<br>                var2 = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">66</span>:<br>            <span class="hljs-keyword">if</span> (var1.equals(<span class="hljs-string">&quot;B&quot;</span>)) &#123;<br>                var2 = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">switch</span>(var2) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-循环结构"><a href="#2-循环结构" class="headerlink" title="2. 循环结构"></a>2. 循环结构</h3><p>Go 语言中只有 for 循环。</p><h4 id="2-1-基本格式"><a href="#2-1-基本格式" class="headerlink" title="2.1 基本格式"></a>2.1 基本格式</h4><p>for init; condition; post { }<br>for condition { }<br>for { }</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> sum <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++ &#123;<br>sum += i<br>&#125;<br><br>index := <span class="hljs-number">5</span><br><span class="hljs-keyword">for</span> index &gt; <span class="hljs-number">0</span> &#123;<br>fmt.Println(index)<br>index--<br>&#125;<br><br>index = <span class="hljs-number">5</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Println(index)<br>index--<br>&#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-2-循环控制关键字"><a href="#2-2-循环控制关键字" class="headerlink" title="2.2 循环控制关键字"></a>2.2 循环控制关键字</h4><table><thead><tr><th align="center">控制语句</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">break</td><td align="center">经常用于中断当前 for 循环或跳出 switch 语句</td></tr><tr><td align="center">continue</td><td align="center">跳过当前循环的剩余语句，然后继续进行下一轮循环</td></tr><tr><td align="center">goto</td><td align="center">将控制转移到被标记的语句</td></tr></tbody></table><p>以上关键字均支持标签。<br>（语法和 java 相同）</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>label:<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++ &#123;<br><span class="hljs-keyword">if</span> j == <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">continue</span> label<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%d --- %d \n&quot;</span>, i, j)<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-4-for-range"><a href="#2-4-for-range" class="headerlink" title="2.4 for range"></a>2.4 for range</h4><p>for range 可以遍历数组、切片、字符串、map 及通道，for range 语法上类似于其它 java 中的 foreach 语句，一般形式为：</p><p>for key, val := range coll {<br>　　…<br>}</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>strings := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;<br><span class="hljs-keyword">for</span> i, s := <span class="hljs-keyword">range</span> strings &#123;<br>fmt.Println(i, s)<br>&#125;<br><br><span class="hljs-keyword">var</span> str <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;hello 张三&quot;</span><br><span class="hljs-keyword">for</span> i, value := <span class="hljs-keyword">range</span> str &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d &lt;====&gt; %c \n&quot;</span>, i, value)<br>&#125;<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211229181327.png"></p><p>字符串遍历的另一种方式：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>str := <span class="hljs-string">&quot;hello 张三&quot;</span><br>r := []<span class="hljs-keyword">rune</span>(str)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(r); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%c &quot;</span>, r[i])<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——运算符</title>
    <link href="/2021/12/28/Go%E2%80%94%E2%80%94%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2021/12/28/Go%E2%80%94%E2%80%94%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211228223837.png"></p><h3 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h3><p>算术运算符包括： + ，-，*，/，%，++，–</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">//+加号：</span><br><span class="hljs-comment">//1.正数 2.相加操作  3.字符串拼接</span><br><span class="hljs-keyword">var</span> n1 <span class="hljs-keyword">int</span> = +<span class="hljs-number">10</span><br>fmt.Println(n1)<br><span class="hljs-keyword">var</span> n2 <span class="hljs-keyword">int</span> = <span class="hljs-number">4</span> + <span class="hljs-number">7</span><br>fmt.Println(n2)<br><span class="hljs-keyword">var</span> s1 <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span><br>fmt.Println(s1)<br><br><span class="hljs-comment">// /除号：</span><br>fmt.Println(<span class="hljs-number">10</span> / <span class="hljs-number">3</span>)   <span class="hljs-comment">//两个int类型数据运算，结果一定为整数类型</span><br>fmt.Println(<span class="hljs-number">10.0</span> / <span class="hljs-number">3</span>) <span class="hljs-comment">//浮点类型参与运算，结果为浮点类型</span><br><br><span class="hljs-comment">// % 取模</span><br>fmt.Println(<span class="hljs-number">10</span> % <span class="hljs-number">-3</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-comment">//++自增操作：</span><br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><br>a++<br>a--<br><span class="hljs-comment">//++ 自增 加1操作，--自减，减1操作</span><br><span class="hljs-comment">// 只能单独使用，不能参与到运算中去</span><br><span class="hljs-comment">// ++，--只能在变量的后面</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="2. 赋值运算符"></a>2. 赋值运算符</h3><p>赋值运算符包括=,+=，-=，*=，/=,%=</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> num1 <span class="hljs-keyword">int</span> = (<span class="hljs-number">10</span> + <span class="hljs-number">20</span>) % <span class="hljs-number">3</span><br>num1 += <span class="hljs-number">20</span><br>fmt.Println(num1) <span class="hljs-comment">// 20</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-关系运算符"><a href="#3-关系运算符" class="headerlink" title="3. 关系运算符"></a>3. 关系运算符</h3><p>关系运算符包括：==、!=、&gt;、&lt;、&gt; =、&lt;=</p><h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4. 逻辑运算符"></a>4. 逻辑运算符</h3><p>逻辑运算符：&amp;&amp;(逻辑与/短路与)，||（逻辑或/短路或），!（逻辑非）</p><p>【注】&amp; 不能作为逻辑运算</p><h3 id="5-位运算符"><a href="#5-位运算符" class="headerlink" title="5. 位运算符"></a>5. 位运算符</h3><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">按位与</td></tr><tr><td align="center">|</td><td align="center">按位或</td></tr><tr><td align="center">^</td><td align="center">按位异或</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">左移运算符（高位丢弃，低位补0）</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">右移运算符</td></tr></tbody></table><p>【注】没有无符号右移</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> c <span class="hljs-keyword">int8</span> = <span class="hljs-number">127</span><br>fmt.Println(c &lt;&lt; <span class="hljs-number">1</span>) <span class="hljs-comment">// -2</span><br><br><span class="hljs-comment">// 01111111// 127</span><br><span class="hljs-comment">// 11111110// 补码</span><br><span class="hljs-comment">// 10000001// 反码</span><br><span class="hljs-comment">// 10000010// 原码</span><br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="6-其他运算符"><a href="#6-其他运算符" class="headerlink" title="6. 其他运算符"></a>6. 其他运算符</h3><p>&amp; ：返回变量的存储地址<br>* ：返回针变量对应的值</p><h3 id="7-运算符优先级"><a href="#7-运算符优先级" class="headerlink" title="7. 运算符优先级"></a>7. 运算符优先级</h3><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211228232536.png"></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——testify</title>
    <link href="/2021/12/22/Go%E2%80%94%E2%80%94testify/"/>
    <url>/2021/12/22/Go%E2%80%94%E2%80%94testify/</url>
    
    <content type="html"><![CDATA[<p>testify 扩展了 testing 标准库，断言库 assert，测试替身 mock 和测试套件 suite 等，让我们编写测试代码更容易！</p><h3 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h3><p>安装 testify 库：</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">$ <span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/stretchr/testify<br></code></pre></div></td></tr></table></figure><p>如果 go  get 失败：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">$ go env -w GO111MODULE=on<br>$ go env -w GOPROXY=https:<span class="hljs-comment">//goproxy.cn,direct</span><br></code></pre></div></td></tr></table></figure><p>estify 模块：</p><ul><li>assert</li><li>http</li><li>mock</li><li>require</li><li>suite</li></ul><h3 id="2-assert"><a href="#2-assert" class="headerlink" title="2. assert"></a>2. assert</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Equal</span><span class="hljs-params">(t TestingT, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotEqual</span><span class="hljs-params">(t TestingT, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Nil</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotNil</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-comment">/* 断言object是空，根据object中存储的实际类型，空的含义不同：</span><br><span class="hljs-comment">   指针：nil；</span><br><span class="hljs-comment">   整数：0；</span><br><span class="hljs-comment">   浮点数：0.0；</span><br><span class="hljs-comment">   字符串：空串&quot;&quot;；</span><br><span class="hljs-comment">   布尔：false；</span><br><span class="hljs-comment">   切片或 channel：长度为 0。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Empty</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotEmpty</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NoError</span><span class="hljs-params">(t TestingT, err error, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 断言err不为nil</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Error</span><span class="hljs-params">(t TestingT, err error, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 断言err表示的 error 链中至少有一个和target匹配</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ErrorAs</span><span class="hljs-params">(t TestingT, err error, target <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 断言err的 error 链中有target</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ErrorIs</span><span class="hljs-params">(t TestingT, err, target error, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Zero</span><span class="hljs-params">(t TestingT, i <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotZero</span><span class="hljs-params">(t TestingT, i <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">True</span><span class="hljs-params">(t TestingT, value <span class="hljs-keyword">bool</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">False</span><span class="hljs-params">(t TestingT, value <span class="hljs-keyword">bool</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Len</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, length <span class="hljs-keyword">int</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-comment">// 断言 s 包含 contains。其中 s 可以是字符串，数组/切片，map。相应地，contains为子串，数组/切片元素，map 的键。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Contains</span><span class="hljs-params">(t TestingT, s, contains <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotContains</span><span class="hljs-params">(t TestingT, s, contains <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Subset</span><span class="hljs-params">(t TestingT, list, subset <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(ok <span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotSubset</span><span class="hljs-params">(t TestingT, list, subset <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(ok <span class="hljs-keyword">bool</span>)</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FileExists</span><span class="hljs-params">(t TestingT, path <span class="hljs-keyword">string</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 断言路径 path 是一个目录，如果 path 不存在或者是一个文件，断言失败。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DirExists</span><span class="hljs-params">(t TestingT, path <span class="hljs-keyword">string</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><br><span class="hljs-comment">// 断言 listA 和 listB 包含相同的元素，忽略元素出现的顺序。listA/listB 必须是数组或切片。如果有重复元素，重复元素出现的次数也必须相等。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ElementsMatch</span><span class="hljs-params">(t TestingT, listA, listB <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-comment">// 断言theError.Error()的返回值与errString相等。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">EqualError</span><span class="hljs-params">(t TestingT, theError error, errString <span class="hljs-keyword">string</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-comment">// 断言expected与actual相等，或者可以转换为相同的类型，并且相等</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">EqualValues</span><span class="hljs-params">(t TestingT, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br></code></pre></div></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSomething</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><br><span class="hljs-comment">//断言相等</span><br>assert.Equal(t, <span class="hljs-number">123</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&quot;they should be equal&quot;</span>)<br><span class="hljs-comment">//断言不相等</span><br>assert.NotEqual(t, <span class="hljs-number">123</span>, <span class="hljs-number">456</span>, <span class="hljs-string">&quot;they should not be equal&quot;</span>)<br><br><span class="hljs-comment">//对于nil的断言</span><br>assert.Nil(t, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">var</span> object = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-comment">//对于非nil的断言</span><br><span class="hljs-keyword">if</span> assert.NotNil(t, object) &#123;<br>assert.Equal(t, <span class="hljs-string">&quot;hello&quot;</span>, object)<br><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>Assertions 对象</strong></p><p>上面的断言都是以 TestingT 为第一个参数，需要大量使用时比较麻烦。testify 提供了一种方便的方式。先以 * testing.T创建一个* Assertions 对象，Assertions 定义了前面所有的断言方法，只是不需要再传入TestingT参数了。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestEqual</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>  assertions := assert.New(t)<br>  assertion.Equal(a, b, <span class="hljs-string">&quot;&quot;</span>)<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-require"><a href="#3-require" class="headerlink" title="3. require"></a>3. require</h3><p>require提供了和assert同样的接口，但是遇到错误时，require直接终止测试，而assert返回false。</p><h3 id="4-mock"><a href="#4-mock" class="headerlink" title="4. mock"></a>4. mock</h3><p>testify 提供了对 Mock 的简单支持。Mock 简单来说就是构造一个仿对象，仿对象提供和原对象一样的接口，在测试中用仿对象来替换原对象。</p><p>待测试代码：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">type User struct &#123;<br>Name string<br>Age  <span class="hljs-keyword">int</span><br>&#125;<br><br>type ICrawler <span class="hljs-class"><span class="hljs-keyword">interface</span> </span>&#123;<br>GetUserList() ([]*User, error)<br>&#125;<br><br>type MyCrawler struct &#123;<br>url string<br>&#125;<br><br>func (c *MyCrawler) GetUserList() ([]*User, error) &#123;<br>resp, err := http.Get(c.url)<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-keyword">return</span> nil, err<br>&#125;<br><br>defer resp.Body.Close()<br>data, err := ioutil.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-keyword">return</span> nil, err<br>&#125;<br><br><span class="hljs-keyword">var</span> userList []*User<br>err = json.Unmarshal(data, &amp;userList)<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-keyword">return</span> nil, err<br>&#125;<br><br><span class="hljs-keyword">return</span> userList, nil<br>&#125;<br><br><span class="hljs-function">func <span class="hljs-title">GetAndPrintUsers</span><span class="hljs-params">(crawler ICrawler)</span> </span>&#123;<br>users, err := crawler.GetUserList()<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">for</span> _, u := range users &#123;<br>fmt.Println(u)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>测试代码：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MockCrawler <span class="hljs-keyword">struct</span> &#123;<br>mock.Mock<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MockCrawler)</span> <span class="hljs-title">GetUserList</span><span class="hljs-params">()</span> <span class="hljs-params">([]*User, error)</span></span> &#123;<br>args := m.Called()<br><span class="hljs-keyword">return</span> args.Get(<span class="hljs-number">0</span>).([]*User), args.Error(<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>MockUsers []*User<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>MockUsers = <span class="hljs-built_in">append</span>(MockUsers, &amp;User&#123;<span class="hljs-string">&quot;dj&quot;</span>, <span class="hljs-number">18</span>&#125;)<br>MockUsers = <span class="hljs-built_in">append</span>(MockUsers, &amp;User&#123;<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">20</span>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGetUserList</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>crawler := <span class="hljs-built_in">new</span>(MockCrawler)<br>crawler.On(<span class="hljs-string">&quot;GetUserList&quot;</span>).Return(MockUsers, <span class="hljs-literal">nil</span>)<br><br>GetAndPrintUsers(crawler)<br><br>crawler.AssertExpectations(t)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>实现 GetUserList() 方法时，需要调用 Mock.Called() 方法，传入参数。Called() 会返回一个 mock.Arguments 对象，该对象中保存着返回的值。它提供了对基本类型和 error 的获取方法 Int()/String()/Bool()/Error()，和通用的获取方法 Get()，通用方法返回 interface{}，需要类型断言为具体类型，它们都接受一个表示索引的参数。</p><p>crawler.On(“GetUserList”).Return(MockUsers, nil) 是 Mock 发挥魔法的地方，这里指示调用 GetUserList() 方法的返回值分别 为MockUsers 和 nil，返回值在上面的 GetUserList() 方法中被 Arguments.Get(0) 和 Arguments.Error(1) 获取。</p><p>最后 crawler.AssertExpectations(t)对 Mock 对象做断言。</p><p>执行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211225233426.png"></p><hr><p>使用 Mock，可以精确断言某方法以特定参数的调用次数，Times(n int)，它有两个便捷函数Once()/Twice()。下面我们要求函数Hello(n int)要以参数 1 调用 1次，参数 2 调用两次，参数 3 调用 3 次：</p><p>待测试方法:</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> IExample <span class="hljs-keyword">interface</span> &#123;<br>Hello(n <span class="hljs-keyword">int</span>) <span class="hljs-keyword">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">Hello</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Hello with %d\n&quot;</span>, n)<br><span class="hljs-keyword">return</span> n<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleFunc</span><span class="hljs-params">(e IExample)</span></span> &#123;<br><span class="hljs-keyword">for</span> n := <span class="hljs-number">1</span>; n &lt;= <span class="hljs-number">3</span>; n++ &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= n; i++ &#123;<br>e.Hello(n)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>测试方法：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MockExample <span class="hljs-keyword">struct</span> &#123;<br>mock.Mock<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *MockExample)</span> <span class="hljs-title">Hello</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>args := e.Mock.Called(n)<br><span class="hljs-keyword">return</span> args.Int(<span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestExample</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>e := <span class="hljs-built_in">new</span>(MockExample)<br><br>e.On(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">1</span>).Return(<span class="hljs-number">1</span>).Times(<span class="hljs-number">1</span>)<br>e.On(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">2</span>).Return(<span class="hljs-number">2</span>).Times(<span class="hljs-number">2</span>)<br>e.On(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">3</span>).Return(<span class="hljs-number">3</span>).Times(<span class="hljs-number">3</span>)<br><br>ExampleFunc(e)<br><br>e.AssertExpectations(t)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行结果</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211225235248.png"></p><p>修改 ExampleFunc 将 for i := 0; i &lt;= n; i++  改为 for i := 0; i &lt; n; i++ </p><p>执行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211225235641.png"></p><h3 id="5-suite"><a href="#5-suite" class="headerlink" title="5. suite"></a>5. suite</h3><p>testify提供了测试套件的功能（TestSuite），testify测试套件只是一个结构体，内嵌一个匿名的 suite.Suite 结构。测试套件中可以包含多个测试，它们可以共享状态，还可以定义钩子方法执行初始化和清理操作。钩子都是通过接口来定义的，实现了这些接口的测试套件结构在运行到指定节点时会调用对应的方法。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SetupAllSuite <span class="hljs-keyword">interface</span> &#123;<br>  SetupSuite()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果定义了SetupSuite()方法（即实现了SetupAllSuite接口），在套件中所有测试开始运行前调用这个方法。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TearDownAllSuite <span class="hljs-keyword">interface</span> &#123;<br>  TearDownSuite()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果定义了TearDonwSuite()方法（即实现了TearDownSuite接口），在套件中所有测试运行完成后调用这个方法。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SetupTestSuite <span class="hljs-keyword">interface</span> &#123;<br>  SetupTest()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果定义了SetupTest()方法（即实现了SetupTestSuite接口），在套件中每个测试执行前都会调用这个方法。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TearDownTestSuite <span class="hljs-keyword">interface</span> &#123;<br>  TearDownTest()<br>&#125;<br></code></pre></div></td></tr></table></figure><p>如果定义了TearDownTest()方法（即实现了TearDownTest接口），在套件中每个测试执行后都会调用这个方法。</p><p>还有一对接口BeforeTest/AfterTest，它们分别在每个测试运行前/后调用，接受套件名和测试名作为参数。</p><p><strong>示例</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyTestSuit <span class="hljs-keyword">struct</span> &#123;<br>suite.Suite<br>testCount <span class="hljs-keyword">uint32</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">SetupSuite</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;SetupSuite&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">TearDownSuite</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;TearDownSuite&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">SetupTest</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;SetupTest test count:%d\n&quot;</span>, s.testCount)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">TearDownTest</span><span class="hljs-params">()</span></span> &#123;<br>s.testCount++<br>fmt.Printf(<span class="hljs-string">&quot;TearDownTest test count:%d\n&quot;</span>, s.testCount)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">BeforeTest</span><span class="hljs-params">(suiteName, testName <span class="hljs-keyword">string</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;BeforeTest suite:%s test:%s\n&quot;</span>, suiteName, testName)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">AfterTest</span><span class="hljs-params">(suiteName, testName <span class="hljs-keyword">string</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;AfterTest suite:%s test:%s\n&quot;</span>, suiteName, testName)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">TestExample</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;TestExample1111&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">TestExample2</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;TestExample2222&quot;</span>)<br>&#125;<br><br><br><span class="hljs-comment">// 为了用 go test 运行测试</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestExample</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>suite.Run(t, <span class="hljs-built_in">new</span>(MyTestSuit))<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211226005128.png"></p><h3 id="6-HTTP-测试"><a href="#6-HTTP-测试" class="headerlink" title="6. HTTP 测试"></a>6. HTTP 测试</h3><p>httptest提供了一个ResponseRecorder类型，它实现了http.ResponseWriter接口，但是它只是记录写入的状态码和响应内容，不会发送响应给客户端</p><p>一个简单的 http 服务器：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">index</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>  fmt.Fprintln(w, <span class="hljs-string">&quot;Hello World&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greeting</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>  fmt.Fprintf(w, <span class="hljs-string">&quot;welcome, %s&quot;</span>, r.URL.Query().Get(<span class="hljs-string">&quot;name&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  mux := http.NewServeMux()<br>  mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, index)<br>  mux.HandleFunc(<span class="hljs-string">&quot;/greeting&quot;</span>, greeting)<br><br>  server := &amp;http.Server&#123;<br>    Addr:    <span class="hljs-string">&quot;:8080&quot;</span>,<br>    Handler: mux,<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> err := server.ListenAndServe(); err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>  &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>测试1</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestIndex</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>recorder := httptest.NewRecorder()<br>request, _ := http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-literal">nil</span>)<br>mux := http.NewServeMux()<br>mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, index)<br>mux.HandleFunc(<span class="hljs-string">&quot;/greeting&quot;</span>, greeting)<br><br>mux.ServeHTTP(recorder, request)<br><br>assert.Equal(t, recorder.Code, <span class="hljs-number">200</span>, <span class="hljs-string">&quot;get index error&quot;</span>)<br>assert.Contains(t, recorder.Body.String(), <span class="hljs-string">&quot;Hello World&quot;</span>, <span class="hljs-string">&quot;body error&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGreeting</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>recorder := httptest.NewRecorder()<br>request, _ := http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/greeting&quot;</span>, <span class="hljs-literal">nil</span>)<br>request.URL.RawQuery = <span class="hljs-string">&quot;name=dj&quot;</span><br>mux := http.NewServeMux()<br>mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, index)<br>mux.HandleFunc(<span class="hljs-string">&quot;/greeting&quot;</span>, greeting)<br><br>mux.ServeHTTP(recorder, request)<br><br>assert.Equal(t, recorder.Code, <span class="hljs-number">200</span>, <span class="hljs-string">&quot;greeting error&quot;</span>)<br>assert.Contains(t, recorder.Body.String(), <span class="hljs-string">&quot;welcome, dj&quot;</span>, <span class="hljs-string">&quot;body error&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>可以使用 suite，消除 recorder/mux 等对象的创建，处理器函数的注册。</p><p><strong>测试2</strong></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MySuite <span class="hljs-keyword">struct</span> &#123;<br>suite.Suite<br>recorder *httptest.ResponseRecorder<br>mux      *http.ServeMux<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MySuite)</span> <span class="hljs-title">SetupSuite</span><span class="hljs-params">()</span></span> &#123;<br>s.recorder = httptest.NewRecorder()<br>s.mux = http.NewServeMux()<br>s.mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, index)<br>s.mux.HandleFunc(<span class="hljs-string">&quot;/greeting&quot;</span>, greeting)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MySuite)</span> <span class="hljs-title">TestIndex</span><span class="hljs-params">()</span></span> &#123;<br>request, _ := http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-literal">nil</span>)<br>s.mux.ServeHTTP(s.recorder, request)<br><br>s.Assert().Equal(s.recorder.Code, <span class="hljs-number">200</span>, <span class="hljs-string">&quot;get index error&quot;</span>)<br>s.Assert().Contains(s.recorder.Body.String(), <span class="hljs-string">&quot;Hello World&quot;</span>, <span class="hljs-string">&quot;body error&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MySuite)</span> <span class="hljs-title">TestGreeting</span><span class="hljs-params">()</span></span> &#123;<br>request, _ := http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/greeting&quot;</span>, <span class="hljs-literal">nil</span>)<br>request.URL.RawQuery = <span class="hljs-string">&quot;name=dj&quot;</span><br><br>s.mux.ServeHTTP(s.recorder, request)<br><br>s.Assert().Equal(s.recorder.Code, <span class="hljs-number">200</span>, <span class="hljs-string">&quot;greeting error&quot;</span>)<br>s.Assert().Contains(s.recorder.Body.String(), <span class="hljs-string">&quot;welcome, dj&quot;</span>, <span class="hljs-string">&quot;body error&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 测试驱动</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestHTTP</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>suite.Run(t, <span class="hljs-built_in">new</span>(MySuite))<br>&#125;<br></code></pre></div></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/267341653">拓展</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——测试</title>
    <link href="/2021/12/20/Go%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95/"/>
    <url>/2021/12/20/Go%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1-基本测试框架"><a href="#1-基本测试框架" class="headerlink" title="1. 基本测试框架"></a>1. 基本测试框架</h3><p>在 Go 语言中，所有的测试都需要以  _test.go 结尾，这样 go build 不会去编译  _test.go 结尾的文件，而  go test 会去编译  _test.go 结尾的文件。</p><p>在编写测试的时候，会用到 testing 这个包，在这个包中，常用的类型有下面这些:</p><ul><li>testing.T（单元测试）</li><li>testing.B（基准测试）</li><li>testing.M（TestMain 测试）</li><li>testing.TB（testing.T、testing.B 公用接口）</li><li>testing.PB（Next() 接口 。 判断是否继续循环）</li></ul><p>有一类测试例外，那就是 Example 测试，主要用来在文档中输出一些测试案例，Example 测试必须以 Example 开头，方法不需要任何参数，同时要指明这个实例的输出，像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleTest</span><span class="hljs-params">()</span></span> &#123;<br> fmt.Println(<span class="hljs-string">&quot;run example test&quot;</span>)<br> <span class="hljs-comment">// Output:</span><br> <span class="hljs-comment">// run example test</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>所有的测试都可以通过 go test 来发起，例如，在当前包下发起测试 go test -v ./ ，-v 参数表示打印测试的过程，会把测试过程中的标准输出都打印出来。</p><h3 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2. 单元测试"></a>2. 单元测试</h3><h4 id="2-1-语法格式："><a href="#2-1-语法格式：" class="headerlink" title="2.1 语法格式："></a>2.1 语法格式：</h4><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestXxx</span><span class="hljs-params">(*testing.T)</span></span><br></code></pre></div></td></tr></table></figure><p><font color="red">注意：Xxx 可以是任何字母数字字符串，但是第一个字母不能是小写字母。</font><br>其中参数 t 用于报告测试失败和附加的日志信息。<br>testing.T的拥有的方法如下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Error</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Fail</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">FailNow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Failed</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Fatal</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Fatalf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Log</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Logf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span> <span class="hljs-title">Parallel</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span> <span class="hljs-title">Run</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, f <span class="hljs-keyword">func</span>(t *T)</span>) <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Skip</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">SkipNow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Skipf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Skipped</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span><br><br></code></pre></div></td></tr></table></figure><ul><li>判定失败接口：<br>　　Fail 失败继续<br>　　FailNow 失败终止</li><li>打印信息接口：<br>　　Log 数据流 （cout　类似）<br>　　Logf format (printf 类似）</li><li>SkipNow 跳过当前测试</li><li>Skiped 检测是否跳过</li><li>综合接口产生：<br>　　Error / Errorf 报告出错继续 [ Log / Logf + Fail ]<br>　　Fatel / Fatelf 报告出错终止 [ Log / Logf + FailNow ]<br>　　Skip / Skipf 报告并跳过 [ Log / Logf + SkipNow ]<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getAge</span><span class="hljs-params">(IDNumber <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int16</span></span> &#123;<br><br> strYear := IDNumber[<span class="hljs-number">6</span>:<span class="hljs-number">10</span>]<br> intYear, _ := strconv.Atoi(strYear)<br><br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">int16</span>(<span class="hljs-number">2022</span> - intYear)<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_GetAge</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br> <span class="hljs-keyword">var</span> (<br>  in       = <span class="hljs-string">&quot;610113200505189012&quot;</span><br>  expected = <span class="hljs-number">16</span><br> )<br> actual := getAge(in)<br> <span class="hljs-keyword">if</span> actual != <span class="hljs-keyword">int16</span>(expected) &#123;<br>  t.Errorf(<span class="hljs-string">&quot;Fib(%s) = %d; expected %d&quot;</span>, in, actual, expected)<br> &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>所有的测试都可以通过 go test 来发起，例如，在当前包下发起测试 go test -v ./ ，-v ：查看测试函数名称和运行时间</p><p>还可以在go test命令后添加 -run 参数，它对应一个正则表达式，只有函数名匹配上的测试函数才会被 go test 命令执行</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211220232747.png"></p><p>【注】：</p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">PS D:\workspace\zth\gotest\src\gocode\main&gt; <span class="hljs-built_in">go</span> test .    <br><span class="hljs-built_in">go</span>: <span class="hljs-built_in">go</span>.<span class="hljs-built_in">mod</span> file <span class="hljs-keyword">not</span> found <span class="hljs-keyword">in</span> current <span class="hljs-built_in">directory</span> <span class="hljs-keyword">or</span> any parent <span class="hljs-built_in">directory</span>; see &#x27;<span class="hljs-built_in">go</span> help modules&#x27; <br></code></pre></div></td></tr></table></figure><p><strong>问题原因：</strong><br>go module 是 go 从1.13 版本开始正式推荐使用依赖管理库<br>go module 可以将某个项目(文件夹)下的所有依赖整理成一个 go.mod 文件,里面写入了依赖的版本等<br>使用go module之后我们可不用将代码放置在src下了<br>使用 go module 管理依赖后会在项目根目录下生成两个文件 go.mod 和 go.sum。</p><blockquote><p>go env -w GO111MODULE=auto<br>go mod init XXX 　//初始化Go moudle，xxx为文件夹名</p></blockquote><blockquote><p>用环境变量 GO111MODULE 开启或关闭模块支持，它有三个可选值：off、on、auto，默认值是 auto。</p><ul><li>GO111MODULE=off 　无模块支持，go 会从 GOPATH 和 vendor 文件夹寻找包。</li><li>GO111MODULE=on 　模块支持，go 会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。</li><li>GO111MODULE=auto 　在 $GOPATH/src 外面且根目录有 go.mod 文件时，开启模块支持。<br>在使用模块的时候，GOPATH 是无意义的，不过它还是会把下载的依赖储存在 $GOPATH/src/mod 中，也会把 go install 的结果放在$GOPATH/bin 中。</li></ul></blockquote><h4 id="2-2-Table-Driven-Test"><a href="#2-2-Table-Driven-Test" class="headerlink" title="2.2 Table-Driven Test"></a>2.2 Table-Driven Test</h4><p>采用 Table-Driven 的方式盖更多 case。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_GetAge2</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> ageTest = [] <span class="hljs-keyword">struct</span>&#123;<br>in       <span class="hljs-keyword">string</span><br>expected <span class="hljs-keyword">int</span><br>&#125;&#123;<br>&#123;<span class="hljs-string">&quot;610113200505189012&quot;</span>,<span class="hljs-number">16</span>&#125;,<br>&#123;<span class="hljs-string">&quot;610113202105189012&quot;</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-string">&quot;610113202005189012&quot;</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-string">&quot;610113202105189012&quot;</span>,<span class="hljs-number">2</span>&#125;,<br><br><br>&#125;<br><br><span class="hljs-keyword">for</span> _,item := <span class="hljs-keyword">range</span> ageTest&#123;<br>actual := getAge(item.in)<br><span class="hljs-keyword">if</span> actual != item.expected &#123;<br>t.Errorf(<span class="hljs-string">&quot;Fib(%s) = %d; expected %d&quot;</span>, item.in, actual, item.expected)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>t.Errorf，即使其中某个 case 失败，也不会终止测试执行。</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211220234619.png"></p><h4 id="2-3-Parallel-测试"><a href="#2-3-Parallel-测试" class="headerlink" title="2.3 Parallel 测试"></a>2.3 Parallel 测试</h4><p>被测试方法：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>data   = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)<br>locker sync.RWMutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteToMap</span><span class="hljs-params">(k, v <span class="hljs-keyword">string</span>)</span></span> &#123;<br>locker.Lock()<br><span class="hljs-keyword">defer</span> locker.Unlock()<br>data[k] = v<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadFromMap</span><span class="hljs-params">(k <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>locker.RLock()<br><span class="hljs-keyword">defer</span> locker.RUnlock()<br><span class="hljs-keyword">return</span> data[k]<br>&#125;<br></code></pre></div></td></tr></table></figure><p>单元测试方法：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> pairs = []<span class="hljs-keyword">struct</span> &#123;<br>k <span class="hljs-keyword">string</span><br>v <span class="hljs-keyword">string</span><br>&#125;&#123;<br>&#123;<span class="hljs-string">&quot;baidu&quot;</span>, <span class="hljs-string">&quot;百度&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;google&quot;</span>, <span class="hljs-string">&quot;谷歌&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;jd&quot;</span>, <span class="hljs-string">&quot;京东&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;taobao&quot;</span>, <span class="hljs-string">&quot;淘宝&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;tianmao&quot;</span>, <span class="hljs-string">&quot;天猫&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;meituan&quot;</span>, <span class="hljs-string">&quot;美团&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-comment">// 注意 TestWriteToMap 需要在 TestReadFromMap 之前</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestWriteToMap</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>t.Parallel()<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> pairs &#123;<br>time.Sleep(time.Duration(<span class="hljs-number">1</span>)*time.Second)<br>WriteToMap(tt.k, tt.v)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestReadFromMap</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>t.Parallel()<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> pairs &#123;<br>time.Sleep(time.Duration(<span class="hljs-number">1</span>)*time.Second)<br>actual := ReadFromMap(tt.k)<br><span class="hljs-keyword">if</span> actual != tt.v &#123;<br>t.Errorf(<span class="hljs-string">&quot;the value of key(%s) is %s, expected: %s&quot;</span>, tt.k, actual, tt.v)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211221234812.png"></p><p>如果注释掉 WriteToMap 和 ReadFromMap 中 locker 保护的代码，执行测试，测试失败。</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211222000146.png"></p><h4 id="2-4-testing-的变量"><a href="#2-4-testing-的变量" class="headerlink" title="2.4 testing 的变量"></a>2.4 testing 的变量</h4><ul><li>test.short : 一个快速测试的标记，在测试用例中可以使用 testing.Short() 来绕开一些测试</li><li>test.outputdir : 输出目录</li><li>test.coverprofile : 测试覆盖率参数，指定输出文件</li><li>test.run : 指定正则来运行某个 / 某些测试用例</li><li>test.memprofile : 内存分析参数，指定输出文件</li><li>test.memprofilerate : 内存分析参数，内存分析的抽样率</li><li>test.cpuprofile : cpu 分析输出参数，为空则不做 cpu 分析</li><li>test.blockprofile : 阻塞事件的分析参数，指定输出文件</li><li>test.blockprofilerate : 阻塞事件的分析参数，指定抽样频率</li><li>test.timeout : 超时时间</li><li>test.cpu : 指定 cpu 数量</li><li>test.parallel : 指定运行测试用例的并行数</li></ul><p>测试覆盖率：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211221235659.png"></p><p>将覆盖率相关的信息输出到文件：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211222000959.png"></p><h3 id="3-基准测试"><a href="#3-基准测试" class="headerlink" title="3. 基准测试"></a>3. 基准测试</h3><h4 id="3-1-基本格式"><a href="#3-1-基本格式" class="headerlink" title="3.1 基本格式"></a>3.1 基本格式</h4><p>在 _test.go 结尾的测试文件中，基准测试函数形式如下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkXxx</span><span class="hljs-params">(*testing.B)</span></span><br></code></pre></div></td></tr></table></figure><p>通过 go test 命令，加上 -bench （匹配需要执行的函数）标志来执行。多个基准测试按照顺序运行。</p><p>待测试函数：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fib</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> n<br>&#125;<br><span class="hljs-keyword">return</span> Fib(n<span class="hljs-number">-1</span>) + Fib(n<span class="hljs-number">-2</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>基准测试函数：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkFib10</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> n := <span class="hljs-number">0</span>; n &lt; b.N; n++ &#123;<br>Fib(<span class="hljs-number">10</span>)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/1%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211222154956.png"></p><h4 id="3-2-计时方法"><a href="#3-2-计时方法" class="headerlink" title="3.2 计时方法"></a>3.2 计时方法</h4><ol><li>StartTimer：开始对测试进行计时。该方法会在基准测试开始时自动被调用，也可以在调用 StopTimer 之后恢复计时；</li><li>StopTimer：停止对测试进行计时。当需要执行一些复杂的初始化操作，并且不想对这些操作进行测量时，就可以使用这个方法来暂时地停止计时；</li><li>ResetTimer：对已经逝去的基准测试时间以及内存分配计数器进行清零。对于正在运行中的计时器，不会产生任何效果。</li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkFibReset</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-comment">// 长耗时配置等</span><br>time.Sleep(time.Duration(<span class="hljs-number">2</span>)*time.Second)<br>b.ResetTimer()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>Fib(<span class="hljs-number">10</span>)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>  <img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/2%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211222161446.png"></p><h4 id="3-3-内存统计"><a href="#3-3-内存统计" class="headerlink" title="3.3  内存统计"></a>3.3  内存统计</h4><p>  ReportAllocs 方法用于打开当前基准测试的内存统计功能， 与 go test 使用 -benchmem 标志类似，但 ReportAllocs 只影响那些调用了该函数的基准测试。<br>  <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkFib10Para</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>b.ReportAllocs()<br>templ := template.Must(template.New(<span class="hljs-string">&quot;test&quot;</span>).Parse(<span class="hljs-string">&quot;Hello, &#123;&#123;.&#125;&#125;!&quot;</span>))<br>b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pb *testing.PB)</span></span> &#123;<br><span class="hljs-comment">// Each goroutine has its own bytes.Buffer.</span><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br><span class="hljs-keyword">for</span> pb.Next() &#123;<br><span class="hljs-comment">// The loop body is executed b.N times total across all goroutines.</span><br>buf.Reset()<br>templ.Execute(&amp;buf, <span class="hljs-string">&quot;World&quot;</span>)<br>&#125;<br>&#125;)<br><br>&#125;<br></code></pre></div></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211222222227.png"></p><h3 id="4-子测试与子基准测试"><a href="#4-子测试与子基准测试" class="headerlink" title="4.  子测试与子基准测试"></a>4.  子测试与子基准测试</h3><p>T 和 B 的 Run 方法允许定义子单元测试和子基准测试，而不必为它们单独定义函数。这便于创建基于 Table-Driven 的基准测试和层级测试。它还提供了一种共享通用 setup 和 tear-down 代码的方法：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFoo</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-comment">// &lt;setup code&gt;</span><br>    t.Run(<span class="hljs-string">&quot;A=1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123; ... &#125;)<br>    t.Run(<span class="hljs-string">&quot;A=2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123; ... &#125;)<br>    t.Run(<span class="hljs-string">&quot;B=1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123; ... &#125;)<br>    <span class="hljs-comment">// &lt;tear-down code&gt;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>每个子测试和子基准测试都有一个唯一的名称：由顶层测试的名称与传递给 Run 的名称组成，以斜杠分隔，并具有可选的尾随序列号，用于消除歧义。</p><p>命令行标志 -run 和 -bench 的参数是非固定的正则表达式，用于匹配测试名称。对于由斜杠分隔的测试名称，例如子测试的名称，它名称本身即可作为参数，依次匹配由斜杠分隔的每部分名称。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">go test -run <span class="hljs-string">&#x27;&#x27;</span>      # 执行所有测试。<br>go test -run Foo     # 执行匹配 <span class="hljs-string">&quot;Foo&quot;</span> 的顶层测试，例如 <span class="hljs-string">&quot;TestFooBar&quot;</span>。<br>go test -run Foo/A=  # 对于匹配 <span class="hljs-string">&quot;Foo&quot;</span> 的顶层测试，执行其匹配 <span class="hljs-string">&quot;A=&quot;</span> 的子测试。<br>go test -run /A=<span class="hljs-number">1</span>    # 执行所有匹配 <span class="hljs-string">&quot;A=1&quot;</span> 的子测试。<br></code></pre></div></td></tr></table></figure><p>子测试也可用于程序并行控制。只有子测试全部执行完毕后，父测试才会完成。在下述例子中，所有子测试之间并行运行，此处的 “并行” 只限于这些子测试之间，并不影响定义在其他顶层测试中的子测试：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGroupedParallel</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> _, tc := <span class="hljs-keyword">range</span> tests &#123;<br>        tc := tc <span class="hljs-comment">// capture range variable</span><br>        t.Run(tc.Name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>            t.Parallel()<br>            ...<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——变量、常量与数据类型</title>
    <link href="/2021/12/18/Go%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/12/18/Go%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h3><h4 id="1-1-变量的声明"><a href="#1-1-变量的声明" class="headerlink" title="1.1 变量的声明"></a>1.1 变量的声明</h4><ol><li>指定变量类型，如果没有初始化，则变量默认为零值。</li><li>根据值自行判定变量类型</li><li>简短形式，使用 := 赋值操作符（只能声明局部变量）</li></ol><p>【注】局部变量声明后未使用，编译报错。</p><blockquote><p>申明变量没有初始化就为零值</p><ul><li>数值类型为 0</li><li>布尔类型为 false</li><li>字符串为 “”（空字符串）</li><li>复杂类型为 nil（指针、切片、map 等）</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> name <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;张三&quot;</span><br>fmt.Println(name)<br><br><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span><br>fmt.Println(flag)<br><br>age := <span class="hljs-number">18</span><br>fmt.Println(age)<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="1-2-多变量声明"><a href="#1-2-多变量声明" class="headerlink" title="1.2 多变量声明"></a>1.2 多变量声明</h4><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x, y <span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> (<br><span class="hljs-comment">// 这种写法一般用于声明全局变量</span><br>a , z <span class="hljs-keyword">int</span><br>b <span class="hljs-keyword">bool</span><br>)<br><br><span class="hljs-keyword">var</span> c, d <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">var</span> e, f = <span class="hljs-number">123</span>, <span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>g, h := <span class="hljs-number">123</span>, <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-built_in">println</span>(x, y, a, b, c, d, e, f, g, h)<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-常量"><a href="#2-常量" class="headerlink" title="2. 常量"></a>2. 常量</h3><p>常量的声明和变量声明非常类似，只是把 var 换成了 const，常量在定义的时候必须赋值。</p><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.1415</span><br><span class="hljs-keyword">const</span> e = <span class="hljs-number">2.7182</span><br><br><span class="hljs-keyword">const</span> (<br>a = <span class="hljs-number">1</span><br>b = <span class="hljs-number">2</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>n1 = <span class="hljs-number">100</span><br>n2<br>n3<br>)<br><br>fmt.Println(n3) <span class="hljs-comment">// 100</span><br></code></pre></div></td></tr></table></figure><h4 id="2-1-iota"><a href="#2-1-iota" class="headerlink" title="2.1 iota"></a>2.1 iota</h4><p>iota  是 go 语言的常量计数器，只能在常量的表达式中使用。</p><p>iota 在 const 关键字出现时将被重置为 0。const 中每新增一行常量声明将使 iota 计数一次( iota 可理解为 const 语句块中的行索引)。 使用 iota 能简化定义，在定义枚举时很有用。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>n1 = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 0</span><br>n2        <span class="hljs-comment">// 1</span><br>n3        <span class="hljs-comment">// 2</span><br>n4        <span class="hljs-comment">// 3</span><br>)<br><br><span class="hljs-comment">// 使用_跳过某些值</span><br><span class="hljs-keyword">const</span> (<br>n5 = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 0</span><br>n6        <span class="hljs-comment">// 1</span><br>_<br>n7 <span class="hljs-comment">// 3</span><br>)<br><br><span class="hljs-comment">// iota声明中间插队</span><br><span class="hljs-keyword">const</span> (<br>n8  = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 0</span><br>n9  = <span class="hljs-number">100</span>  <span class="hljs-comment">// 100</span><br>n10 = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 2</span><br>n11        <span class="hljs-comment">// 3</span><br>)<br><br><span class="hljs-comment">// 多个 iota 定义在一行</span><br><span class="hljs-keyword">const</span> (<br>a, b = <span class="hljs-literal">iota</span> + <span class="hljs-number">1</span>, <span class="hljs-literal">iota</span> + <span class="hljs-number">2</span> <span class="hljs-comment">// 1,2</span><br>c, d                      <span class="hljs-comment">// 2,3</span><br>e, f                      <span class="hljs-comment">// 3,4</span><br>)<br></code></pre></div></td></tr></table></figure><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3. 数据类型"></a>3. 数据类型</h3><h4 id="3-1-基本数据类型"><a href="#3-1-基本数据类型" class="headerlink" title="3.1 基本数据类型"></a>3.1 基本数据类型</h4><h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><table><thead><tr><th align="center">类型</th><th align="center">有无符号</th><th align="center">占用存储空间</th><th align="center">表示范围</th></tr></thead><tbody><tr><td align="center">uint8</td><td align="center">无符号</td><td align="center">1字节</td><td align="center">0 - 255(2^8^ -1)</td></tr><tr><td align="center">uint16</td><td align="center">无符号</td><td align="center">21字节</td><td align="center">0 - 65535(2^16^ -1)</td></tr><tr><td align="center">uint32</td><td align="center">无符号</td><td align="center">4字节</td><td align="center">0 到 4294967295(2^32^ -1)</td></tr><tr><td align="center">uint64</td><td align="center">无符号</td><td align="center">8字节</td><td align="center">0 到 18446744073709551615(2^64^ -1)</td></tr><tr><td align="center">int8</td><td align="center">有符号</td><td align="center">1字节</td><td align="center">-128 到 127(-2^7^  ~  2^7^-1)</td></tr><tr><td align="center">int16</td><td align="center">有符号</td><td align="center">2字节</td><td align="center">-32768 到 32767(-2^15^  ~  2^15^-1)</td></tr><tr><td align="center">int32</td><td align="center">有符号</td><td align="center">4字节</td><td align="center">-2147483648 到 2147483647(-2^31^  ~  2^31^-1)</td></tr><tr><td align="center">int64</td><td align="center">有符号</td><td align="center">8字节</td><td align="center">-2^63^  ~  2^63^-1</td></tr></tbody></table><p>其他整数类型：</p><table><thead><tr><th align="center">类型</th><th align="center">有无符号</th><th align="center">占用存储空间</th><th align="center">表示范围</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">有符号</td><td align="center">32位机占4字节，64位机占8字节</td><td align="center">(-2^31^  ~  2^31^-1) \ ( -2^63^  ~  2^63^-1)</td></tr><tr><td align="center">uint</td><td align="center">无符号</td><td align="center">32位机占4字节，64位机占8字节</td><td align="center">(0~2^32^ -1) \ ( 0  ~  2^64^-1)</td></tr><tr><td align="center">rune</td><td align="center">有符号</td><td align="center">等价 int32</td><td align="center">-2^31^  ~  2^31^-1</td></tr><tr><td align="center">byte</td><td align="center">无符号</td><td align="center">等价 uint8</td><td align="center">0 - 255</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// 整型默认类型</span><br><span class="hljs-keyword">var</span> num1 = <span class="hljs-number">1</span><br><span class="hljs-comment">// 打印数据类型、内存占用大小  （64 位机)</span><br>fmt.Printf(<span class="hljs-string">&quot;num1 数据类型：%T，内存占用空间：%d&quot;</span>, num1, unsafe.Sizeof(num1))<br><span class="hljs-comment">// num1 数据类型：int，内存占用空间：8</span><br><br><span class="hljs-keyword">var</span> num2 <span class="hljs-keyword">int8</span> = <span class="hljs-number">128</span><br><span class="hljs-comment">// 编译报错：constant 128 overflows int8</span><br>fmt.Println(num2)<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h5><table><thead><tr><th align="center">类型</th><th align="center">占用存储空间</th><th align="center">表示范围</th></tr></thead><tbody><tr><td align="center">float32</td><td align="center">4字节</td><td align="center">-3.403E38 ~ 3.403E38</td></tr><tr><td align="center">float64</td><td align="center">8字节</td><td align="center">-1.798E308 ~ 1.798E308</td></tr><tr><td align="center">complex64</td><td align="center">8字节</td><td align="center">32 位实数和虚数</td></tr><tr><td align="center">complex128</td><td align="center">16字节</td><td align="center">64 位实数和虚数</td></tr></tbody></table><p>浮点类型存储：符号位+指数位+尾数位，所以可能会出现精度损失</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">//定义浮点类型的数据：</span><br><span class="hljs-keyword">var</span> num1 <span class="hljs-keyword">float32</span> = <span class="hljs-number">3.14</span><br>fmt.Println(num1)<br><span class="hljs-comment">//浮点数可以用十进制表示形式，也可以用科学计数法表示形式  E 大写小写都可以的</span><br><span class="hljs-keyword">var</span> num2 <span class="hljs-keyword">float32</span> = <span class="hljs-number">-314E-2</span><br>fmt.Println(num2)<br><br><span class="hljs-comment">//浮点数可能会有精度的损失，所以通常情况下，建议你使用：float64</span><br><span class="hljs-keyword">var</span> num3 <span class="hljs-keyword">float32</span> = <span class="hljs-number">256.000000916</span><br>fmt.Println(num3)  <span class="hljs-comment">// 256</span><br><span class="hljs-keyword">var</span> num4 <span class="hljs-keyword">float64</span> = <span class="hljs-number">256.000000916</span><br>fmt.Println(num4)  <span class="hljs-comment">// 256.000000916</span><br><br><span class="hljs-comment">// 默认的浮点类型为：float64</span><br><span class="hljs-keyword">var</span> num5 = <span class="hljs-number">3.17</span><br>fmt.Printf(<span class="hljs-string">&quot;num9对应的默认的类型为：%T&quot;</span>,num5)<br><br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// complex定义复数类型使用的关键字。</span><br><span class="hljs-keyword">var</span> score <span class="hljs-keyword">complex64</span> = <span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">var</span> number <span class="hljs-keyword">complex128</span> = <span class="hljs-built_in">complex</span>(<span class="hljs-number">23.23</span>, <span class="hljs-number">11.11</span>)<br>fmt.Print(<span class="hljs-string">&quot;Score = &quot;</span>, score, <span class="hljs-string">&quot; Number = &quot;</span>, number, <span class="hljs-string">&quot;\n&quot;</span>)<br><span class="hljs-comment">// Score = (1+2i) Number = (23.23+11.11i)</span><br><br><span class="hljs-comment">// 使用 real 获取复数的实部，使用 imag 获取复数的虚部。</span><br>fmt.Print(<span class="hljs-string">&quot;Real Score = &quot;</span>, <span class="hljs-built_in">real</span>(score), <span class="hljs-string">&quot; Image Score = &quot;</span>, <span class="hljs-built_in">imag</span>(score), <span class="hljs-string">&quot;\n&quot;</span>)<br><span class="hljs-comment">// Real Score = 1 Image Score = 2</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h5><p>Golang中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存（Unicode 码）。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//定义字符类型的数据：</span><br><span class="hljs-keyword">var</span> c1 <span class="hljs-keyword">byte</span> = <span class="hljs-string">&#x27;a&#x27;</span><br>fmt.Printf(<span class="hljs-string">&quot;c1 的值：%d ,对应的具体的字符为：%c&quot;</span>, c1, c1)<br><span class="hljs-comment">// c1 的值：97 ,对应的具体的字符为：a</span><br><br><span class="hljs-comment">//定义字符类型的数据：</span><br><span class="hljs-keyword">var</span> c2 <span class="hljs-keyword">int16</span> = <span class="hljs-string">&#x27;中&#x27;</span><br>fmt.Printf(<span class="hljs-string">&quot;c1 的值：%d ,对应的具体的字符为：%c&quot;</span>, c2, c2)<br><span class="hljs-comment">// c1 的值：20013 ,对应的具体的字符为：中</span><br><br><span class="hljs-keyword">var</span> int1 <span class="hljs-keyword">int</span> = <span class="hljs-string">&#x27;中&#x27;</span><br>fmt.Println(int1)<br><span class="hljs-comment">// 20013</span><br><br>&#125;<br></code></pre></div></td></tr></table></figure><p>java 中的字符：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> code = <span class="hljs-string">&#x27;中&#x27;</span>;<br>    System.out.println(code);<br>    <span class="hljs-comment">// 20013</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>转义字符</strong></p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211228130016.png"></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//\b 退格</span><br>fmt.Println(<span class="hljs-string">&quot;aaa\bbbb&quot;</span>)<br><span class="hljs-comment">//\r 光标回到本行的开头，后续输入就会替换原有的字符</span><br>fmt.Println(<span class="hljs-string">&quot;aaaaa\rbbb&quot;</span>)<br><span class="hljs-comment">//\t 制表符</span><br>fmt.Println(<span class="hljs-string">&quot;aaaaaaaabbbbbbbbcccccccc&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;aaaaa\tbbbbb&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;aaaaaaaa\tbbbbb&quot;</span>)<br><span class="hljs-comment">//\&quot;</span><br>fmt.Println(<span class="hljs-string">&quot;\&quot;Golang\&quot;&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211228130737.png"></p><h5 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h5><p>布尔型的值只可以是常量 true 或者 false。<br>布尔类型占1个字节</p><h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><p>【注意】go 中 字符串是基本数据类型</p><figure class="highlight csharp"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs csharp"><span class="hljs-function">func <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> &#123;<br><br><span class="hljs-comment">//1.定义一个字符串：</span><br><span class="hljs-keyword">var</span> s1 <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;hello world&quot;</span><br>fmt.Println(s1)<br><br><span class="hljs-comment">//2.字符串的表示形式：</span><br><span class="hljs-comment">//（1）如果字符串中没有特殊字符，字符串的表示形式用双引号</span><br><span class="hljs-comment">//（2）如果字符串中有特殊字符，字符串的表示形式用反引号 ``</span><br><span class="hljs-keyword">var</span> s4 <span class="hljs-built_in">string</span> = `<br>        package main<br>        import <span class="hljs-string">&quot;fmt&quot;</span> <br>        <span class="hljs-function">func <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>        &#125;<br>        `<br>fmt.Println(s4)<br><br><span class="hljs-comment">//3.字符串的拼接：</span><br><span class="hljs-keyword">var</span> s5 <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span><br>s5 += <span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-comment">//当一个字符串过长的时候：注意：+保留在上一行的最后</span><br><span class="hljs-keyword">var</span> s6 <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span> + <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span> + <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span> + <span class="hljs-string">&quot;abc&quot;</span> +<br><span class="hljs-string">&quot;def&quot;</span> + <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span> + <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span><br>fmt.Println(s6)<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h5 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h5><h6 id="数值类型之间转换"><a href="#数值类型之间转换" class="headerlink" title="数值类型之间转换"></a>数值类型之间转换</h6><p>Go 在不同类型的变量之间赋值时需要显式转换，并且只有显式转换(强制转换)。</p><p>语法：T(v)<br>T : 数据类型<br>v : 需要转换的变量<br>将值 v 转换为类型 T</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//进行类型转换：</span><br><span class="hljs-keyword">var</span> n1 <span class="hljs-keyword">int</span> = <span class="hljs-number">100</span><br><span class="hljs-comment">//var n2 float32 = n1  // 无法直接转换</span><br><br><span class="hljs-keyword">var</span> n2 <span class="hljs-keyword">float32</span> = <span class="hljs-keyword">float32</span>(n1)<br>fmt.Println(n2)<br><br><span class="hljs-comment">//将int64转为int8的时候，编译不会出错的，但是会数据的溢出</span><br><span class="hljs-keyword">var</span> n3 <span class="hljs-keyword">int64</span> = <span class="hljs-number">888888</span><br><span class="hljs-keyword">var</span> n4 <span class="hljs-keyword">int8</span> = <span class="hljs-keyword">int8</span>(n3)<br>fmt.Println(n4) <span class="hljs-comment">//56</span><br><br><span class="hljs-keyword">var</span> n5 <span class="hljs-keyword">int32</span> = <span class="hljs-number">12</span><br><span class="hljs-keyword">var</span> n6 <span class="hljs-keyword">int64</span> = <span class="hljs-keyword">int64</span>(n5) + <span class="hljs-number">30</span> <span class="hljs-comment">//一定要匹配=左右的数据类型</span><br>fmt.Println(n6)<br><br><span class="hljs-keyword">var</span> n7 <span class="hljs-keyword">int64</span> = <span class="hljs-number">12</span><br><span class="hljs-keyword">var</span> n8 <span class="hljs-keyword">int8</span> = <span class="hljs-keyword">int8</span>(n7) + <span class="hljs-number">127</span> <span class="hljs-comment">//编译通过，但是结果可能会溢出</span><br><span class="hljs-comment">//var n9 int8 = int8(n7) + 128 //编译不会通过</span><br>fmt.Println(n8) <span class="hljs-comment">// -117</span><br><br>&#125;<br></code></pre></div></td></tr></table></figure><h6 id="数值类型转换为-string"><a href="#数值类型转换为-string" class="headerlink" title="数值类型转换为 string"></a>数值类型转换为 string</h6><p>方式1：fmt.Sprintf(“%参数”,表达式)<br>方式2：使用 strconv 包的函数<br>参数参考：<a href="https://studygolang.com/pkgdoc">https://studygolang.com/pkgdoc</a></p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211228134900.png"></p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> n1 <span class="hljs-keyword">int</span> = <span class="hljs-number">19</span><br><span class="hljs-keyword">var</span> n2 <span class="hljs-keyword">float64</span> = <span class="hljs-number">4.78</span><br><span class="hljs-keyword">var</span> s1 <span class="hljs-keyword">string</span> = fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, n1)<br>fmt.Printf(<span class="hljs-string">&quot;s1对应的类型是：%T ，s1 = %#v \n&quot;</span>, s1, s1)<br><span class="hljs-keyword">var</span> s2 <span class="hljs-keyword">string</span> = fmt.Sprintf(<span class="hljs-string">&quot;%f&quot;</span>, n2)<br>fmt.Printf(<span class="hljs-string">&quot;s2对应的类型是：%T ，s2 = %q \n&quot;</span>, s2, s2)<br><br><span class="hljs-keyword">var</span> n3 <span class="hljs-keyword">bool</span> = <span class="hljs-literal">true</span><br><span class="hljs-keyword">var</span> s3 <span class="hljs-keyword">string</span> = strconv.FormatBool(n3)<br>fmt.Printf(<span class="hljs-string">&quot;s3对应的类型是：%T ，s3 = %q \n&quot;</span>, s3, s3)<br><span class="hljs-keyword">var</span> s4 <span class="hljs-keyword">string</span> = strconv.FormatInt(<span class="hljs-keyword">int64</span>(n1), <span class="hljs-number">10</span>) <span class="hljs-comment">//参数：第二个参数指定字面值的进制形式为十进制</span><br>fmt.Printf(<span class="hljs-string">&quot;s1对应的类型是：%T ，s1 = %q \n&quot;</span>, s4, s4)<br><span class="hljs-keyword">var</span> s5 <span class="hljs-keyword">string</span> = strconv.FormatFloat(n2, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">9</span>, <span class="hljs-number">64</span>)<br><span class="hljs-comment">//第二个参数：&#x27;f&#x27;（-ddd.dddd）  第三个参数：9 保留小数点后面9位  第四个参数：表示这个小数是float64类型</span><br>fmt.Printf(<span class="hljs-string">&quot;s2对应的类型是：%T ，s2 = %q \n&quot;</span>, s5, s5)<br><span class="hljs-comment">// 4.780000000</span><br><br>&#125;<br></code></pre></div></td></tr></table></figure><h6 id="string-类型转数值类型"><a href="#string-类型转数值类型" class="headerlink" title="string 类型转数值类型"></a>string 类型转数值类型</h6><p>方式：使用 strconv 包的函数   </p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211228140047.png"></p><p>注意：string向基本数据类型转换的时候，一定要确保 string 类型能够转成有效的数据类型，否则最后得到的结果就是按照对应类型的默认值输出</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//string--&gt;bool</span><br><span class="hljs-keyword">var</span> s1 <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;true&quot;</span><br><span class="hljs-comment">//ParseBool这个函数的返回值有两个：(value bool, err error)</span><br>b, _ := strconv.ParseBool(s1)<br>fmt.Printf(<span class="hljs-string">&quot;b的类型是：%T,b=%v \n&quot;</span>, b, b)<br><br><span class="hljs-comment">//string---》int</span><br><span class="hljs-keyword">var</span> s2 <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;-19&quot;</span><br>num1, _ := strconv.ParseInt(s2, <span class="hljs-number">10</span>, <span class="hljs-number">64</span>)<br>fmt.Printf(<span class="hljs-string">&quot;num1的类型是：%T,num1=%v \n&quot;</span>, num1, num1)<br><br><span class="hljs-comment">//string--&gt;float32/float64</span><br><span class="hljs-keyword">var</span> s3 <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;3.14&quot;</span><br>f1, _ := strconv.ParseFloat(s3, <span class="hljs-number">64</span>)<br>fmt.Printf(<span class="hljs-string">&quot;f1的类型是：%T,f1=%v \n&quot;</span>, f1, f1)<br><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="3-2-复杂数据类型"><a href="#3-2-复杂数据类型" class="headerlink" title="3.2 复杂数据类型"></a>3.2 复杂数据类型</h4><h5 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h5><p>基本数据类型都有对应的指针类型，形式为 *数据类型</p><p>基本数据类型和指针：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> age <span class="hljs-keyword">int</span> = <span class="hljs-number">18</span><br><span class="hljs-comment">//&amp;符号+变量 就可以获取这个变量内存的地址</span><br>fmt.Println(&amp;age) <span class="hljs-comment">//0xc0000a2058</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>指针变量：</p><ol><li>&amp; 取内存地址</li><li> * 根据地址取值</li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> age <span class="hljs-keyword">int</span> = <span class="hljs-number">18</span><br><br><span class="hljs-comment">//定义一个指针变量：</span><br><span class="hljs-comment">//ptr 指针变量的名字</span><br><span class="hljs-comment">//ptr对应的类型是：*int 是一个指针类型 （可以理解为 指向int类型的指针）</span><br><span class="hljs-comment">//&amp;age 就是一个地址，是 ptr 变量的具体的值</span><br><span class="hljs-keyword">var</span> ptr *<span class="hljs-keyword">int</span> = &amp;age<br>fmt.Println(ptr)<span class="hljs-comment">// 0xc0000a2058</span><br>fmt.Println(<span class="hljs-string">&quot;ptr 存储空间的地址为：&quot;</span>, &amp;ptr) <br><span class="hljs-comment">// 获取指针指向的变量的值</span><br>fmt.Printf(<span class="hljs-string">&quot;ptr指向的数值为：%v&quot;</span>, *ptr) <span class="hljs-comment">//ptr指向的数值为：18</span><br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211228142655.png"></p><p>通过指针改变指向值:</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> num <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><br>aa(num)<br>fmt.Println(num)<span class="hljs-comment">// 10</span><br>bb(&amp;num)<br>fmt.Println(num)<span class="hljs-comment">// 200</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">aa</span><span class="hljs-params">(int2 <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>int2 = <span class="hljs-number">100</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bb</span><span class="hljs-params">(int2 *<span class="hljs-keyword">int</span>)</span></span>  &#123;<br>*int2 = <span class="hljs-number">200</span><br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——模板模式</title>
    <link href="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>定义一个操作的算法骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些 特定步骤。</p><p><strong>优点：</strong></p><ol><li>封装不变部分，扩展可变部分。 </li><li>提取公共代码，便于维护。</li><li>行为由父类控制，子类实现。</li></ol><p><strong>缺点：</strong></p><ul><li>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211217214833.png"></p><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 猫和少年</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-12-17 21:35</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Slogan</span> 才疏学浅，少年登科；满腹经纶，白发不第</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AbstractClass abstractClass = <span class="hljs-keyword">new</span> SubClass();<br>        abstractClass.option();<br><br>        abstractClass = <span class="hljs-keyword">new</span> SubClass2();<br>        abstractClass.option();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClass</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">option</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 准备工作</span><br>        System.out.println(<span class="hljs-string">&quot;pre .......&quot;</span>);<br>        templateMethod();<br>        <span class="hljs-comment">// 结尾工作</span><br>        System.out.println(<span class="hljs-string">&quot;teardown.....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">templateMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClass</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">templateMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;subclass  executed...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">SubClass2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClass</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">templateMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;subclass2  executed...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-JDK-中的应用"><a href="#3-JDK-中的应用" class="headerlink" title="3. JDK 中的应用"></a>3. JDK 中的应用</h3><p><strong>HttpServlet</strong></p><p>通过继承 HttpServlet ，并实现 doGet 等方法来支持相应的请求。</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/GenericServlet.png"></p><p><strong>HttpServlet 响应流程</strong></p><ol><li>Web 客户向 Servlet 容器发出Http请求</li><li>Servlet 容器解析 Web 客户的 Http 请求</li><li>Servlet 容器创建一个 HttpRequest 对象，封装 Http 请求信息</li><li>Servlet 容器创建一个 HttpResponse 对象</li><li>Servlet 容器调用 HttpServlet 的 service 方法，把 HttpRequest 和 HttpResponse 对象作为 service 方法的参数传给 HttpServlet 对象</li><li>HttpServle t调用 HttpRequest 的有关方法，获取HTTP请求信息</li><li>HttpServlet 调用 HttpResponse 的有关方法，生成响应数据</li><li>Servlet 容器把 HttpServle t的响应结果传给 Web 客户</li></ol><p>其中HttpServlet首先必须读取Http请求的内容，Servlet容器负责创建HttpServlet对象，并把Http请求直接封装到HttpServlet对象中。</p><p><strong>创建 HttpServlet 步骤</strong></p><ol><li>继承 HttpServlet 抽象类</li><li>重写 HttpServlet 的部分方法，如 doGet() 或 doPost() 方法</li><li>获取 HTTP 请求信息。通过 HttpServletRequest 对象来检索 HTML 表单所提交的数据或 URL 上的查询字符串</li><li>生成 HTTP 响应结果。通过 HttpServletResponse 对象生成响应结果</li></ol><h3 id="4-Spring-中的应用"><a href="#4-Spring-中的应用" class="headerlink" title="4. Spring 中的应用"></a>4. Spring 中的应用</h3><p><strong>AbstractController</strong><br>通过继承 AbstractController 并重写  handleRequestInternal 方法，实现 Controller。AbstractController 包装的功能：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211217234313.png"></p><p>AbstractController 继承关系：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/AbstractController.png"></p><p><a href="https://www.cnblogs.com/yif0118/p/12494239.html">SpringMVC实现Controller方式</a> </p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>行为型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——责任链模式</title>
    <link href="/2021/12/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/12/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>为请求创建了一个接收者对象的链。<br>为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p><strong>优点：</strong> </p><ol><li>降低耦合。它将请求的发送者和接收者解耦。 </li><li>可以控制执行顺序。可以动态增删责任以及调动他们的顺序。</li><li> 符合开闭原则和单一职责原则</li></ol><p><strong>缺点：</strong></p><ol><li>不能保证请求一定被接收。</li><li>系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。</li><li>可能不容易观察运行时的特征，有碍于除错。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/WPS%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91.png"></p><p>使用场景： 1、有多个对象处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。</p><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><p>在请求业务前，需要对请求进行请求频率控制、登录认证、访问权限验证、敏感词过滤等。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChainOfResponsibility</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Request request = <span class="hljs-keyword">new</span> Request.RequestBuilder().frequentOK(<span class="hljs-keyword">true</span>).loggedOn(<span class="hljs-keyword">false</span>).build();<br><br>        RequestFrequentHandler requestFrequentHandler = <span class="hljs-keyword">new</span> RequestFrequentHandler(<span class="hljs-keyword">new</span> LoggingHandler(<span class="hljs-keyword">null</span>));<br><br>        <span class="hljs-keyword">if</span> (requestFrequentHandler.process(request)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;业务正常处理&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;访问异常&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>责任定义:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    Handler next;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(Handler next)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Handler <span class="hljs-title">getNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Handler next)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Request request)</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestFrequentHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RequestFrequentHandler</span><span class="hljs-params">(Handler next)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(next);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Request request)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;访问频率验证&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (request.isFrequentOK()) &#123;<br>            Handler next = getNext();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == next) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> next.process(request);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoggingHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoggingHandler</span><span class="hljs-params">(Handler next)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(next);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Request request)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;登录验证&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (request.isLoggedOn()) &#123;<br>            Handler next = getNext();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == next) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> next.process(request);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>请求定义：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> loggedOn;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> frequentOK;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isPermits;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> containsSensitiveWords;<br>    <span class="hljs-keyword">private</span> String requestBody;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Request</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> loggedOn, <span class="hljs-keyword">boolean</span> frequentOK, <span class="hljs-keyword">boolean</span> isPermits, <span class="hljs-keyword">boolean</span> containsSensitiveWords)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loggedOn = loggedOn;<br>        <span class="hljs-keyword">this</span>.frequentOK = frequentOK;<br>        <span class="hljs-keyword">this</span>.isPermits = isPermits;<br>        <span class="hljs-keyword">this</span>.containsSensitiveWords = containsSensitiveWords;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestBuilder</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> loggedOn;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> frequentOK;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isPermits;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> containsSensitiveWords;<br><br>        <span class="hljs-function">RequestBuilder <span class="hljs-title">loggedOn</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> loggedOn)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.loggedOn = loggedOn;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function">RequestBuilder <span class="hljs-title">frequentOK</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> frequentOK)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.frequentOK = frequentOK;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function">RequestBuilder <span class="hljs-title">isPermits</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isPermits)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.isPermits = isPermits;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function">RequestBuilder <span class="hljs-title">containsSensitiveWords</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> containsSensitiveWords)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.containsSensitiveWords = containsSensitiveWords;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Request <span class="hljs-title">build</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Request(loggedOn,frequentOK,isPermits,containsSensitiveWords);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/* getter  setter */</span><br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-JDK-中应用"><a href="#3-JDK-中应用" class="headerlink" title="3. JDK 中应用"></a>3. JDK 中应用</h3><p>javax.servlet.FilterChain<br>javax.servlet.Filter</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211215232225.png"></p><p>通过数组实现责任链表</p><h3 id="4-Spring-中的应用"><a href="#4-Spring-中的应用" class="headerlink" title="4. Spring 中的应用"></a>4. Spring 中的应用</h3><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211218232612.png"></p><p><a href="https://blog.csdn.net/u014082714/article/details/103463378">https://blog.csdn.net/u014082714/article/details/103463378</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>行为型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GO——入门</title>
    <link href="/2021/12/13/GO%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"/>
    <url>/2021/12/13/GO%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1-认识-Go-语言"><a href="#1-认识-Go-语言" class="headerlink" title="1. 认识 Go 语言"></a>1. 认识 Go 语言</h3><h4 id="1-1-GO-语言的-logo"><a href="#1-1-GO-语言的-logo" class="headerlink" title="1.1 GO 语言的 logo"></a>1.1 GO 语言的 logo</h4><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211214223325.png"></p><h4 id="1-2-Go-语言的吉祥物"><a href="#1-2-Go-语言的吉祥物" class="headerlink" title="1.2 Go 语言的吉祥物"></a>1.2 Go 语言的吉祥物</h4><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211214223153.png"></p><p>gopher 是一种生活在加拿大的小动物，中文名叫做囊地鼠。</p><h3 id="2-Go-语言特性"><a href="#2-Go-语言特性" class="headerlink" title="2. Go 语言特性"></a>2. Go 语言特性</h3><blockquote><ul><li>自动垃圾回收</li><li>更丰富的内置类型</li><li>函数多返回值</li><li>错误处理</li><li>匿名函数和闭包</li><li>类型和接口</li><li>并发编程</li><li>反射</li><li>语言交互性</li></ul></blockquote><h3 id="3-语言结构"><a href="#3-语言结构" class="headerlink" title="3. 语言结构"></a>3. 语言结构</h3><p>基础组成有以下几个部分：</p><ul><li>包声明</li><li>引入包</li><li>函数</li><li>变量</li><li>语句 &amp; 表达式</li><li>注释</li></ul><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 必须在源文件中非注释的第一行指明这个文件属于哪个包，每个 Go 应用程序都包含一个名为 main 的包。</span><br><span class="hljs-keyword">package</span> main<br><span class="hljs-comment">// 引入包</span><br><span class="hljs-keyword">import</span>  <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-comment">// 每一个可执行程序必须包含 main 函数是</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br> fmt.Println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><ul><li>注释：多行注释（/*…*/）和单行注释（//） </li><li>分隔符：在 Go 程序中，一行代表一个语句结束。如果一行只有一个语句，结尾不需要显式加分号（;），但是多个语句写在同一行，则必须使用 ; 区分。</li><li>标识符：标识符由一个或是多个字母、数字、下划线组成的序列，并且第一个字符必须是字母或下划线而不能是数字。</li><li>当标识符（包括常量、变量、类型、函数名、结构字段等等）以大写字母开头，它就可以被外部包的代码所使用（类似 java 中的public）；标识符如果以小写字母开头，则对包外是不可见的（类似 java 的 protected ）。</li></ul></blockquote><p><font color = "red"><strong>注意：</strong></font><br> { 不能单独放在一行，否则编译错误<br> <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br>&#123;<br> fmt.Println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure></p><h3 id="4-执行-GO-程序"><a href="#4-执行-GO-程序" class="headerlink" title="4. 执行 GO 程序"></a>4. 执行 GO 程序</h3><ol><li> 先编译再执行</li><li> 编译运行一起执行</li></ol><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211214231117.png"></p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211213234710.png"></p><p>Golang中文网在线标准库文档: <a href="https://studygolang.com/pkgdoc">https://studygolang.com/pkgdoc</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——策略模式</title>
    <link href="/2021/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>定义了算法族，分别封装起来，让他们之间可以相互替换，此模式的变化独立于算法的使用者。</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211211121318.png"></p><p>解决场景：一般是具有同类可替代的行为逻辑算法场景。比如；不同类型的交易方式（信用卡、支付宝、微信）、生成唯一 ID 策略（UUID、DB自增、DB+Redis、雪花算法、Leaf 算法）等，都可以使用策略模式进行行为包装，供给外部使用。 </p><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><p>场景：模拟在购买商品时使用各种类型优惠券(满减、直减、折扣、n元购)，</p><h4 id="2-1-一般实现"><a href="#2-1-一般实现" class="headerlink" title="2.1 一般实现"></a>2.1 一般实现</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CouponDiscountService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">disCountAmount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">double</span> typeContent, <span class="hljs-keyword">double</span> skuPrice, <span class="hljs-keyword">double</span> typeExt)</span> </span>&#123;<br>        <span class="hljs-comment">// 直减</span><br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> skuPrice - typeContent;<br>        &#125;<br>        <span class="hljs-comment">// 满减</span><br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> skuPrice &lt; typeContent ? skuPrice : skuPrice - typeContent;<br>        &#125;<br>        <span class="hljs-comment">// 折扣</span><br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> skuPrice * typeContent;<br>        &#125;<br>        <span class="hljs-comment">// n 元购</span><br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">return</span> typeContent;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-2-策略模式重构代码"><a href="#2-2-策略模式重构代码" class="headerlink" title="2.2 策略模式重构代码"></a>2.2 策略模式重构代码</h4><p><strong>优惠券接口</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 优惠券金额计算</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> couponInfo 优惠券信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> skuPrice skuji金额</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>   折扣金额</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(T couponInfo,BigDecimal skuPrice)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>优惠券接口实现</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MJCouponDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">Map</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">String</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 满减计算</span><br><span class="hljs-comment">     * 1. 判断满⾜x元后-n元，否则不减</span><br><span class="hljs-comment">     * 2. 最低⽀付⾦额1元</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(Map&lt;String, String&gt; couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br>        String condition = couponInfo.get(<span class="hljs-string">&quot;condition&quot;</span>);<br>        String amount = couponInfo.get(<span class="hljs-string">&quot;amount&quot;</span>);<br>        <span class="hljs-comment">// ⼩于商品⾦额条件的，直接返回商品原价</span><br>        <span class="hljs-keyword">if</span> (skuPrice.compareTo(<span class="hljs-keyword">new</span> BigDecimal(condition)) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> skuPrice;<br>        <span class="hljs-comment">// 减去优惠⾦额判断</span><br>        BigDecimal discountAmount = skuPrice.subtract(<span class="hljs-keyword">new</span> BigDecimal(amount));<br>        <span class="hljs-keyword">if</span> (discountAmount.compareTo(BigDecimal.ZERO) &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span><br>                BigDecimal.ONE;<br>        <span class="hljs-keyword">return</span> discountAmount;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZJCouponDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">Double</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 直减计算</span><br><span class="hljs-comment">     * 1. 使用商品价格减去优惠价格</span><br><span class="hljs-comment">     * 2. 最低⽀付⾦额1元</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(Double couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br>        BigDecimal discountAmount = skuPrice.subtract(<span class="hljs-keyword">new</span> BigDecimal(couponInfo));<br><br>        <span class="hljs-keyword">if</span> (discountAmount.compareTo(BigDecimal.ONE) &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> BigDecimal.ONE;<br>        &#125;<br>        <span class="hljs-keyword">return</span> discountAmount;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZKCouponDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">Double</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 折扣计算</span><br><span class="hljs-comment">     * 1. 使⽤商品价格乘以折扣⽐例，为最后⽀付⾦额</span><br><span class="hljs-comment">     * 2. 保留两位⼩数</span><br><span class="hljs-comment">     * 3. 最低⽀付⾦额1元</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(Double couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br><br>        BigDecimal discountAmount = skuPrice.multiply(<span class="hljs-keyword">new</span> BigDecimal(couponInfo)).<br>                setScale(<span class="hljs-number">2</span>, BigDecimal.ROUND_HALF_UP);<br>        <span class="hljs-keyword">if</span> (discountAmount.compareTo(BigDecimal.ONE) &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> BigDecimal.ONE;<br>        &#125;<br>        <span class="hljs-keyword">return</span> discountAmount;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NYGCouponDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">Double</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * n 元购购买</span><br><span class="hljs-comment">     * 1. ⽆论原价多少钱都固定⾦额购买</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(Double couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BigDecimal(couponInfo);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><strong>策略控制类</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> CouponDiscount&lt;T&gt; couponDiscount;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span><span class="hljs-params">(CouponDiscount&lt;T&gt; couponDiscount)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.couponDiscount = couponDiscount;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(T couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> couponDiscount.discountAmount(couponInfo, skuPrice);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>测试验证</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContextTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">discountAmount</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">// 直减；100-10，商品100元</span><br>        Context&lt;Double&gt; context = <span class="hljs-keyword">new</span> Context&lt;Double&gt;(<span class="hljs-keyword">new</span> ZJCouponDiscount());<br>        BigDecimal discountAmount = context.discountAmount(<span class="hljs-number">10D</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>));<br>        Assert.assertTrue(discountAmount.equals(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">90</span>)));<br><br>        <span class="hljs-comment">// 满100减10，商品100元</span><br>        Context&lt;Map&lt;String, String&gt;&gt; context1 = <span class="hljs-keyword">new</span> Context&lt;Map&lt;String, String&gt;&gt;(<span class="hljs-keyword">new</span> MJCouponDiscount());<br>        Map&lt;String, String&gt; mapReq = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();<br>        mapReq.put(<span class="hljs-string">&quot;condition&quot;</span>, <span class="hljs-string">&quot;100&quot;</span>);<br>        mapReq.put(<span class="hljs-string">&quot;amount&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>);<br>        BigDecimal discountAmount1 = context1.discountAmount(mapReq, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">90</span>));<br>        Assert.assertTrue(discountAmount1.equals(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">90</span>)));<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过策略设计模式的使用可以把方法中的 if 语句优化掉，大量的 if 语句使用会让代码难以扩展，也不好维护，同时在后期遇到各种问题也很难维护。在使用这样的设计模式后可以很好的满足隔离性与和扩展性，对于不断新增的需求也非常方便承接。</p><h3 id="3-JDK中的应用"><a href="#3-JDK中的应用" class="headerlink" title="3. JDK中的应用"></a>3. JDK中的应用</h3><p>排序时通过实现排序接口生成不同的排序类，以达到按不同的属性排序。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComparatorTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Person[] people = <span class="hljs-keyword">new</span> Person[]&#123;<span class="hljs-keyword">new</span> Person(<span class="hljs-number">10</span>,<span class="hljs-number">111</span>),<span class="hljs-keyword">new</span> Person(<span class="hljs-number">18</span>,<span class="hljs-number">99</span>),<span class="hljs-keyword">new</span> Person(<span class="hljs-number">15</span>,<span class="hljs-number">122</span>)&#125;;<br><br>        System.out.println(Arrays.toString(people));<br>        Arrays.sort(people,<span class="hljs-keyword">new</span> SortByAge());<br>        System.out.println(Arrays.toString(people));<br>        Arrays.sort(people,<span class="hljs-keyword">new</span> SortByHeight());<br>        System.out.println(Arrays.toString(people));<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  [Person&#123;age=10, height=111&#125;, Person&#123;age=18, height=99&#125;, Person&#123;age=15, height=122&#125;]</span><br><span class="hljs-comment">            [Person&#123;age=10, height=111&#125;, Person&#123;age=15, height=122&#125;, Person&#123;age=18, height=99&#125;]</span><br><span class="hljs-comment">            [Person&#123;age=15, height=122&#125;, Person&#123;age=10, height=111&#125;, Person&#123;age=18, height=99&#125;]</span><br><span class="hljs-comment">         */</span><br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortByHeight</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Person</span>&gt;</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person o1, Person o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span>  o1.getHeight()-o2.getHeight();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortByAge</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Person</span>&gt;</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person o1, Person o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> o1.getAge()-o2.getAge();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">int</span> height;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> height)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.height = height;<br>    &#125;<br>    <br>    <span class="hljs-comment">/* getter setter  toString */</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="4-Spring-中的应用"><a href="#4-Spring-中的应用" class="headerlink" title="4. Spring 中的应用"></a>4. Spring 中的应用</h3><h4 id="4-1-InstantiationStrategy"><a href="#4-1-InstantiationStrategy" class="headerlink" title="4.1 InstantiationStrategy"></a>4.1 InstantiationStrategy</h4><p>接口 InstantiationStrategy 是实例化策略接口类，它定义了三种实例化方式，SimpleInstantiationStrategy 实现了该策略，CglibSubclassingInstantiationStrategy 又继承了 SimpleInstantiationStrategy  新增了根据 cglib 生成代理类实例化方法。</p><p><a href="https://my.oschina.net/chengxiaoyuan/blog/823655">实例化策略 InstantiationStrategy</a></p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211211125722.png"></p><p>如果工厂方法实例化直接用反射创建对象，如果是构造方法实例化的则判断是否有 MethodOverrides，如果没有MethodOverrides 也是直接用反射，如果有 MethodOverrides 就需要用 cglib 实例化对象，SimpleInstantiationStrategy 把通过 cglib 实例化的任务交给了它的子类 CglibSubclassingInstantiationStrategy。</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211211224848.png"></p><h4 id="4-2-Aop代理策略"><a href="#4-2-Aop代理策略" class="headerlink" title="4.2 Aop代理策略"></a>4.2 Aop代理策略</h4><p>首先 AopProxyFactory 接口类提供了 createAopProxy 接口，这个是策略模式的接口方法。DefaultAopProxyFactory 实现了该接口作为策略的实现者。ProxyCreatorSupport 里面引用了 AopProxyFactory，并且提供了 get、set 方法用来运行时改变策略。这里 Spring 只实现了 DefaultAopProxyFactory 这一个策略，如果需要自己也可以实现。</p><p>DefaultAopProxyFactory 里面的 createAopProxy 的逻辑如下，可以在运行时根据参数决定用 Cglib 策略还是 JDK 动态代理策略生成代理类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> AopProxy <span class="hljs-title">createAopProxy</span><span class="hljs-params">(AdvisedSupport config)</span> <span class="hljs-keyword">throws</span> AopConfigException </span>&#123;<br><br><br>        <span class="hljs-comment">//如果XML打开了优化开关，或者设置为了代理目标类，或者目前类没有接口</span><br>        <span class="hljs-keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;<br>            Class&lt;?&gt; targetClass = config.getTargetClass();<br>            <span class="hljs-keyword">if</span> (targetClass == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopConfigException(<span class="hljs-string">&quot;TargetSource cannot determine target class: &quot;</span> +<br>                        <span class="hljs-string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-comment">//如果有接口，或者通过Proxy.newProxyInstance生成的，则使用jdk动态代理</span><br>            <span class="hljs-keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);<br>            &#125;<br><br>            <span class="hljs-comment">//使用cglib</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObjenesisCglibAopProxy(config);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//使用jdk动态代理</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>另外 AopProxy 也是一个策略接口类，具体实现的策略为 JdkDynamicAopProxy、CglibAopProxy、ObjenesisCglibAopProxy。</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211211231617.png"></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>行为型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——泛型</title>
    <link href="/2021/12/09/java%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B/"/>
    <url>/2021/12/09/java%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1-理解泛型"><a href="#1-理解泛型" class="headerlink" title="1.理解泛型"></a>1.理解泛型</h3><p>什么是泛型？为什么要使用泛型？</p><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</p><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。<br>泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化（称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><p>泛型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><blockquote><p>注意：<br>泛型的类型参数只能是类类型，不能是简单类型。<br>不能对确切的泛型类型使用 instanceof 操作。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;String&gt; strings = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><span class="hljs-comment">// 编译报错：Illegal generic type for instanceo</span><br><span class="hljs-keyword">if</span> (strings <span class="hljs-keyword">instanceof</span> List&lt;String&gt;) &#123;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-泛型类"><a href="#2-泛型类" class="headerlink" title="2. 泛型类"></a>2. 泛型类</h3><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。泛型类的类型参数声明部分可以包含一个或多个类型参数，参数间用逗号隔开。</p><p>一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</p><p>通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p><p><strong>语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名称 &lt;泛型标识：可以是任意标识号&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> 泛型标识 <span class="hljs-comment">/*（成员变量类型）*/</span> <span class="hljs-keyword">var</span>;<br>    .....<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//key这个成员变量的类型为T,T的类型由外部指定</span><br>    <span class="hljs-keyword">private</span> T key;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Generic</span><span class="hljs-params">(T key)</span> </span>&#123; <span class="hljs-comment">// 构造方法形参类型也为T，由外部指定</span><br>        <span class="hljs-keyword">this</span>.key = key;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//传入的实参类型需与泛型的类型参数类型相同，即为 Integer.</span><br>Generic&lt;Integer&gt; genericInteger = <span class="hljs-keyword">new</span> Generic&lt;Integer&gt;(<span class="hljs-number">123456</span>);<br></code></pre></div></td></tr></table></figure><h3 id="3-泛型接口"><a href="#3-泛型接口" class="headerlink" title="3. 泛型接口"></a>3. 泛型接口</h3><p>泛型类型用于接口的定义中，被称为泛型接口。</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 定义泛型接口</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">// 实现接口一</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CarGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;car&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 实现接口二</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitGenerator</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> T next;<br><br><span class="hljs-comment">// 非泛型方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FruitGenerator</span><span class="hljs-params">(T next)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        FruitGenerator&lt;String&gt; fruit = <span class="hljs-keyword">new</span> FruitGenerator&lt;String&gt;(<span class="hljs-string">&quot;Fruit&quot;</span>);<br>        System.out.println(fruit.next);<br>        <span class="hljs-comment">// Fruit</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-泛型方法"><a href="#4-泛型方法" class="headerlink" title="4. 泛型方法"></a>4. 泛型方法</h3><p>泛型方法：是在调用方法的时候指明泛型的具体类型。</p><blockquote><p>泛型类：是在实例化类的时候指明泛型的具体类型。</p></blockquote><h4 id="4-1-泛型方法的基本用法"><a href="#4-1-泛型方法的基本用法" class="headerlink" title="4.1 泛型方法的基本用法"></a>4.1 泛型方法的基本用法</h4><p>泛型方法的定义规则：</p><ul><li>所有泛型方法声明在方法返回类型之前都有类型参数声明部分（由尖括号分隔）</li><li>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。</li><li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li></ul><blockquote><p>java 中泛型标记符：</p><ul><li>E - Element (在集合中使用，因为集合中存放的是元素)</li><li>T - Type（Java 类）</li><li>K - Key（键）</li><li>V - Value（值）</li><li>N - Number（数值类型）</li><li>？ - 表示不确定的 java 类型</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 泛型方法 printArray</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(E[] inputArray)</span></span>&#123;<br>    <span class="hljs-comment">// 输出数组元素</span><br>    Arrays.stream(inputArray).forEach(System.out::println);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>    <span class="hljs-comment">// 创建不同的数组</span><br>    Integer[] intArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br>    Double[] doubleArray = &#123; <span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">3.3</span>, <span class="hljs-number">4.4</span> &#125;;<br>    Character[] charArray = &#123; <span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span> &#125;;<br><br>    System.out.println(<span class="hljs-string">&quot;整型数组元素为：&quot;</span>);<br>    printArray(intArray);<br><br>    System.out.println(<span class="hljs-string">&quot;双精度型数组元素为：&quot;</span>);<br>    printArray(doubleArray);<br><br>    System.out.println(<span class="hljs-string">&quot;字符型数组元素为：&quot;</span>);<br>    printArray(charArray);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="4-2-泛型方法与可变参数"><a href="#4-2-泛型方法与可变参数" class="headerlink" title="4.2 泛型方法与可变参数"></a>4.2 泛型方法与可变参数</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">   <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMsg</span><span class="hljs-params">(T... args)</span></span>&#123;<br>       Arrays.stream(args).forEach(System.out::println);<br>   &#125;<br><br>printMsg(<span class="hljs-string">&quot;111&quot;</span>,<span class="hljs-number">111</span>,<span class="hljs-number">123.23</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">123L</span>);<br></code></pre></div></td></tr></table></figure><h4 id="4-3-静态方法与泛型"><a href="#4-3-静态方法与泛型" class="headerlink" title="4.3 静态方法与泛型"></a>4.3 静态方法与泛型</h4><p>静态方法无法访问类上定义的泛型，如果静态方法操作的引用数据类型不确定时，必须将泛型定义在方法上。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticGenerator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 编译错误：cannot be referenced from a static context</span><br>    <span class="hljs-comment">// public static void Show(T t) &#123;&#125;</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">(T t)</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="5-泛型通配符"><a href="#5-泛型通配符" class="headerlink" title="5.  泛型通配符"></a>5.  泛型通配符</h3><h4 id="5-1-用-代替具体的类型参数"><a href="#5-1-用-代替具体的类型参数" class="headerlink" title="5.1 用 ? 代替具体的类型参数"></a>5.1 用 ? 代替具体的类型参数</h4><p>此处’？’是类型实参，而不是类型形参。也就是说此处的？和 Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    List&lt;String&gt; name = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    List&lt;Integer&gt; age = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    List&lt;Number&gt; number = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br><br>    name.add(<span class="hljs-string">&quot;zth&quot;</span>);<br>    age.add(<span class="hljs-number">18</span>);<br>    number.add(<span class="hljs-number">13</span>);<br>    getData(name);<br>    getData(age);<br>    getData(number);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getData</span><span class="hljs-params">(List&lt;?&gt; data)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;data: &quot;</span>+data.get(<span class="hljs-number">0</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="5-2-泛型的上边界"><a href="#5-2-泛型的上边界" class="headerlink" title="5.2 泛型的上边界"></a>5.2 泛型的上边界</h4><p>通过形如  List &lt; ? extends Number&gt;  来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; age = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Number&gt; number = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Double&gt; doubles = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    printNumber(age);<br>    printNumber(number);<br>    printNumber(doubles);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printNumber</span><span class="hljs-params">(List&lt;? extends Number&gt; data)</span> </span>&#123;<br>    data.forEach(System.out::println);<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>Ingeter 是 Number 的一个子类，但是 Generic<Integer>  不能被看作为 Generic<Number>  的子类。由此可以看出：同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。</p></blockquote><h4 id="5-3-泛型的下边界"><a href="#5-3-泛型的下边界" class="headerlink" title="5.3 泛型的下边界"></a>5.3 泛型的下边界</h4><p>通过形如 List&lt; ? super Number&gt; 来定义，表示类型只能接受 Number 及其三层父类类型，如Objec类型的实例。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Number&gt; number = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Object&gt; objects = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    printNumber(number);<br>    printNumber(objects);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printNumber</span><span class="hljs-params">(List&lt; ? <span class="hljs-keyword">super</span> Number&gt; data)</span> </span>&#123;<br>    data.forEach(System.out::println);<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>注：不能在上限泛型集合中添加元素，可以在下限泛型集合中添加元素</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">      List&lt; ? <span class="hljs-keyword">super</span> Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      <span class="hljs-comment">// 可以在下限泛型集合中添加元素</span><br>      list.add(<span class="hljs-number">111</span>);<br>      <span class="hljs-comment">//报错： add (capture&lt; ? super java.lang.Integer&gt;) in List cannot be applied  to (java.lang.Object)</span><br>      list.add(<span class="hljs-keyword">new</span> Object());<br><br><span class="hljs-comment">// 不能在上限泛型集合中添加元素</span><br>      List&lt; ? extends Number&gt; data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      <span class="hljs-comment">// 报错：add  (capture&lt; ? extends java.lang.Number&gt;) in List cannot be applied to (java.lang.Integer)</span><br>      data.add(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">111</span>));<br></code></pre></div></td></tr></table></figure><p>在日常中，只要记住 “ PECS(Producer Extends Consumer Super)原则” 即可。意思为：<br>（1）频繁往外读取内容的，适合用上界Extends。<br>（2）经常往里插入的，适合用下界Super。</p><p>参考：<a href="https://www.zhihu.com/question/20400700">https://www.zhihu.com/question/20400700</a></p><h3 id="6-泛型的生命周期"><a href="#6-泛型的生命周期" class="headerlink" title="6. 泛型的生命周期"></a>6. 泛型的生命周期</h3><p>Java的泛型信息只存在于编译期间，编译之后所有的泛型信息都会被擦除。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integerList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>List&lt;String&gt; stringList = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>System.out.println(integerList.getClass() == stringList.getClass());<br><span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><p>不管是 ArrayList&lt; Integer &gt; 还是 ArrayList&lt; Long &gt;，在编译时都会被编译器擦除成了 ArrayList。</p><p>Java引入泛型是为了加强参数类型的安全性，在编译期间根据泛型声明及早发现类型转化问题，减少了类型的转换。因为在 JDK1.5 之前是没有泛型的，需要考虑向下兼容，所以对于泛型只存在于编译期间。编译成字节码后，ArrayList&lt; Integer &gt; 或 ArrayList&lt; Long &gt; 都会被擦除成 ArrayList，这样就能保持和 JDK1.5 之前版本兼容。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>list.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>Class listClass = list.getClass();<br>Method methodList = listClass.getMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);<br>methodList.invoke(list, <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>));<br><span class="hljs-keyword">for</span> (Object obj : list) &#123;<br>    System.out.println(<span class="hljs-string">&quot;obj = &quot;</span> + obj +<span class="hljs-string">&quot;, class = &quot;</span> + obj.getClass().getName());<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * obj = hello, class = java.lang.String</span><br><span class="hljs-comment"> * obj = 10, class = java.lang.Integer</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><p><strong>在运行期间获取泛型信息</strong></p><p>虽然泛型类在编译的时候会进行泛型擦除，不过泛型信息还是会保存在泛型类的字节码对象中。</p><blockquote><p>获取到泛型类型的要求：</p><ul><li>必须具有真实类型的存在。</li><li>泛型的类型是明确的（如List<User>是明确的，List<T>是不明确的）。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 为了方便其他类获取，将其作为公有属性</span><br>    Class&lt;?&gt; clazz;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Generic</span><span class="hljs-params">()</span> </span>&#123;<br>        ParameterizedType pt = (ParameterizedType)<br>                <span class="hljs-keyword">this</span>.getClass().getGenericSuperclass();<br>        <span class="hljs-comment">// 获取泛型参数列表，如Map&lt;K,V&gt;，那么返回K，V的数组</span><br>        Type[] types = pt.getActualTypeArguments();<br>        <span class="hljs-comment">//因为这里只有一个泛型T，所以获取第一个元素</span><br>        clazz = (Class&lt;?&gt;) types[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGeneric</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>&#125;<br>System.out.println(<span class="hljs-keyword">new</span> Generic1().clazz);<br><span class="hljs-comment">// class java.lang.String</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——java9新特性</title>
    <link href="/2021/12/06/Java%E2%80%94%E2%80%94java9%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2021/12/06/Java%E2%80%94%E2%80%94java9%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p><strong>java9 新特性：</strong></p><ul><li>目录结构</li><li>模块化系统</li><li>jshell</li><li>接口的私有方法</li><li>改进 try-with-resourcs </li><li>改进钻石操作符 </li><li>限制使用单独下划线标识符</li><li> String 存储结构变更</li><li> 快速创建只读集合</li><li> 增强 Stream API</li><li> 改进 Optional 类</li><li> 多分辨率图像 API</li><li> 全新 HTTP 客户端 API</li><li> 智能 JAVA 编译工具</li><li> 统一 JVM 日志系统</li><li> javadoc 的 HTML5 支持</li><li> java 动态编译</li></ul><h4 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1.目录结构"></a>1.目录结构</h4><p>JDK9具体目录结构：</p><ul><li>bin： 该目录包含所有的命令。</li><li>conf： 包含用户可以编辑的配置文件，例如以前位于 jre\lib 目录中的 .properties 和 .policy 文件。 </li><li>include： 包含一些编译本地代码时使用的 C/C++头文件。</li><li>jmods： 包含JMOD 格式的平台模块，创建自定义运行映射时需要它。 </li><li>legal： 包含法律声明。 </li><li>lib： 包含非 Windows 平台上动态链接的本地库，其子目录和文件不应由开发人员直 接编辑或使用。</li></ul><blockquote><p>JDK8 目录结构：</p><ul><li>bin： 该目录存放了 JDK 的各种工具命令，即 jdk 工具的可执行二进制文件，包括编译器，调试器等，例如：java，javac</li><li>db： 该目录是安装 Java DB 的路径。Java 自带数据库 Derby。</li><li>include： 包含一些编译本地代码时使用的 C/C++头文件。</li><li>jre： 该目录包含的是 jre 环境(Java runtime environment 即 Java 运行时环境)。</li><li>lib：该目录存放的是 java 工具命令实际执行的程序包。</li></ul></blockquote><p> <strong>注：JDK9 目录中不再有 jre 子目录。</strong></p><h4 id="2-模块化系统"><a href="#2-模块化系统" class="headerlink" title="2. 模块化系统"></a>2. 模块化系统</h4><p>JDK9 将 JDK 分成一组模块，可以在编译时，运行时或构建时进行组合。模块化可以减少内存开销；只需必要的模块，并非全部模块，可以简化各种类库和大型应用的开发和维护，八个仓库： root、corba、hotspot、jaxp、jaxws、jdk、langtools 和 nashorn </p><blockquote><p>module-info.java：该文件必须位于项目的根目录中。该文件用于定义模块需要什么依赖，以及哪些包被外部使用。<br>exports：控制哪些包可以被其他模块访问，所有不被 exports 的包默认都被封装在模块里面不 被外界所使用。<br>requires：指明对其他模块的依赖。 </p></blockquote><p><strong>示例:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211212225847.png"></p><p>有两个模块 jdk9 和 jdk9module1，在 jdk9 中引用 jdk9module1 的内容。</p><p>jdk9  module-info 内容：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span> jdk9 &#123;<br>    <span class="hljs-keyword">requires</span> jdk9module1;<br>    <span class="hljs-keyword">requires</span> jdk.incubator.httpclient;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>jdk9module1  module-info 内容：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span> jdk9module1 &#123;<br>    <span class="hljs-keyword">exports</span> com.zth.bean;<br>    <span class="hljs-comment">//exports com.zth.common;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211212230559.png"><br>可以看到如果没有引用 common 包，将如法使用 Util 类。</p><h4 id="3-JShell"><a href="#3-JShell" class="headerlink" title="3. JShell"></a>3. JShell</h4><p>JDK9 新增了 REPL（Read-Eval-Print Loop）工具 jshell，jshell 工具提供了一个交互式命令界面， 可以评估声明、语句和表达式，无需编译即可返回执行结果。</p><blockquote><ol><li> /list   　　　　    //列出所有的代码 </li><li> /methods 　　   //查看所有的方法 </li><li> /var          　　   //所有的变量 </li><li>/edit          　　  //打开编辑器 </li><li>/open path 　　//执行路径上的代码 如 /open C:\Users\wukong\Desktop\App.java </li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211212231645.png"></p><h4 id="4-接口私有化方法"><a href="#4-接口私有化方法" class="headerlink" title="4. 接口私有化方法"></a>4. 接口私有化方法</h4><p>jdk1.8 之前接口定义中只有抽象方法（public abstract）和常量（public static final），从 jdk8 开始，接口可以加入静态方法和默认方法，JDK9 可以在接口中使用私有方法。</p><p>作用：在一个接口中，有可能在多个默认方法上存在重复的通用代码，但通用代码又不想被子类发现，所以引入了私有方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInterface</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        log(<span class="hljs-string">&quot;getName&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;猫和少年&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> String <span class="hljs-title">getSlogan</span><span class="hljs-params">()</span> </span>&#123;<br>        log(<span class="hljs-string">&quot;getSlogan&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;才疏学浅，少年登科；满腹经纶，白发不第&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 接口的私有化方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(String method)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;TestInterface.&quot;</span>+method+<span class="hljs-string">&quot;()被调用&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="5-改进-try-with-resource"><a href="#5-改进-try-with-resource" class="headerlink" title="5. 改进 try-with-resource"></a>5. 改进 try-with-resource</h3><p>JDK 8中新增了 try-with-resources 语句，可以自动关闭需要关闭的资源文件。但是必须在 try 语句后的括号中初始化需要关闭的资源。在JDK9中改进了 try-with-resources 语句，可以在 try 外初始化资源，然后在 try 后的括号中添加需要自动关的资源即可。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jdk7</span><span class="hljs-params">()</span></span>&#123;<br>    FileInputStream fileInputStream = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span>&#123;<br>        fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;/home/a.txt&quot;</span>);<br>        <span class="hljs-keyword">byte</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        fileInputStream.read(temp);<br>        System.out.println(<span class="hljs-keyword">new</span> String(temp));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != fileInputStream)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                fileInputStream.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jdk8</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span>(FileInputStream fileInputStream =  <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;/home/a.txt&quot;</span>))&#123;<br><br>        <span class="hljs-keyword">byte</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> read = fileInputStream.read(temp);<br>        System.out.println(<span class="hljs-keyword">new</span> String(temp));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jdk9</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>    FileInputStream fileInputStream =  <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;/home/a.txt&quot;</span>);<br>    <span class="hljs-keyword">try</span>(fileInputStream)&#123;<br>        <span class="hljs-keyword">byte</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> read = fileInputStream.read(temp);<br>        System.out.println(<span class="hljs-keyword">new</span> String(temp));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="6-改进钻石操作符"><a href="#6-改进钻石操作符" class="headerlink" title="6. 改进钻石操作符"></a>6. 改进钻石操作符</h3><p>JDK9 中钻石操作符可以使用匿名实现类，可以在匿名实现类中重写方法等操作 。</p><p>JDK8 中：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Comparator&lt;Integer&gt; integerComparator = <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;;<br><br>Set&lt;String&gt; hashSet = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;() &#123;<br>&#125;;<br><br></code></pre></div></td></tr></table></figure><p>JDK9：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Comparator&lt;Integer&gt; integerComparator = <span class="hljs-keyword">new</span> Comparator&lt;&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><br>Set&lt;String&gt; hashSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;() &#123;<br>&#125;;<br></code></pre></div></td></tr></table></figure><h3 id="7-限制使用单独下划线标识符"><a href="#7-限制使用单独下划线标识符" class="headerlink" title="7. 限制使用单独下划线标识符"></a>7. 限制使用单独下划线标识符</h3><p>在 JDK8 之前可以使用单独的下划线（ _ ）作为标识符，但在 JDK9 中限制使用单独的下划线作为标识符。</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211226115041.png"></p><h3 id="8-String-存储结构变更"><a href="#8-String-存储结构变更" class="headerlink" title="8. String 存储结构变更"></a>8. String 存储结构变更</h3><p>String 类在 JDK8 以及之前将字符存储在 char 数组中，每个字符使用两个字节（十六位）。 从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数 String 对象仅包含 Latin-1 字符。 此类字符仅需要一个字节的存储空间，也就是 String 对象的内部字符数组中有一半空间未使用。<br>JDK 8 String 结构：<br><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211226122939.png"></p><p>JDK9 将 String 的内部表示从 UTF-16 字符数组更改为字节数组加上编码标志字段。 将根据字符串的内容存储编码为 ISO-8859-1/Latin-1（每个字符一个字节）或 UTF-16（每个字符两个字节）的字符。 编码标志将指示使用哪种编码。<br>JDK 9 String 结构：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211226123032.png"></p><blockquote><p>内码 :某种语言运行时，其 char 和 string 在内存中的编码方式。<br>  外码 :除了内码，皆是外码。<br>要注意的是，源代码编译产生的目标代码文件（可执行文件或class文件）中的编码方式属于外码。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    printString(<span class="hljs-string">&quot;abc&quot;</span>);<br>    printString(<span class="hljs-string">&quot;中文&quot;</span>);<br>    printString(<span class="hljs-string">&quot;abc中文&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(String str)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;======&gt;&quot;</span> + str);<br>    <span class="hljs-comment">// return the UTF-16 char[] size</span><br>    System.out.println(<span class="hljs-string">&quot;length: &quot;</span> + str.length());<br>    <span class="hljs-comment">// Use default Encoding (UTF-8)</span><br>    System.out.println(<span class="hljs-string">&quot;getBytes: &quot;</span> + str.getBytes().length);<br>    <span class="hljs-comment">// Convert UTF-16 char[] to char</span><br>    System.out.println(<span class="hljs-string">&quot;codePointCount: &quot;</span> + str.codePointCount(<span class="hljs-number">0</span>, str.length()));<br>    <span class="hljs-comment">// Get the UTF-16 char[]</span><br>    System.out.println(<span class="hljs-string">&quot;toCharArray: &quot;</span> + str.toCharArray().length);<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211226210914.png"></p><p><a href="https://blog.csdn.net/loveshunyi/article/details/90680487">java 编码详解与原理</a></p><h3 id="9-快速创建只读集合"><a href="#9-快速创建只读集合" class="headerlink" title="9. 快速创建只读集合"></a>9. 快速创建只读集合</h3><p>JDK9 在 List、Set 和 Map 集合中新增 of 静态方法，快速创建只读集合。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    Map&lt;String, String&gt; map = Map.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;bbb&quot;</span>);<br><br>    List&lt;String&gt; names = List.of(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>);<br>    names.forEach(System.out::println);<br>    names.remove(<span class="hljs-string">&quot;张三&quot;</span>); <span class="hljs-comment">// 抛出 UnsupportedOperationException</span><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="10-增强-Stream-API"><a href="#10-增强-Stream-API" class="headerlink" title="10. 增强 Stream API"></a>10. 增强 Stream API</h3><p>JDK9 在 Stream 接口中新增4个方法：dropWhile、takeWhile、ofNullable、iterate方法新增重载方法</p><ol><li> default Stream<T> takeWhile(Predicate&lt; ? super T&gt; predicate)</li></ol><blockquote><p>有序的集合：从 Stream 中获取一部分数据, 返回从头开始的尽可能多的元素, 直到遇到第一个 false 结果，如果第一个值不满足断言条件，将返回一个空的 Stream。</p><p>无序的集合：如果这个流是无序的，那么这个操作的结果是<strong>不确定</strong>的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Stream&lt;String&gt; nameStream = Stream.of(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王麻子&quot;</span>, <span class="hljs-string">&quot;赵六&quot;</span>);<br>    nameStream.takeWhile(item -&gt; item.length() == <span class="hljs-number">2</span>).forEach(System.out::println);<br>    <span class="hljs-comment">// 张三  李四</span><br><br>    System.out.println(<span class="hljs-string">&quot;=========&quot;</span>);<br><br>    Set&lt;String&gt; names = Set.of(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王麻子&quot;</span>, <span class="hljs-string">&quot;赵六&quot;</span>);<br>    names.stream().takeWhile(item -&gt; item.length() == <span class="hljs-number">2</span>).forEach(System.out::println);<br>    <span class="hljs-comment">// 第一次执行结果： 李四</span><br>    <span class="hljs-comment">// 第二次执行结果： 张三</span><br>    <span class="hljs-comment">// 第三次执行结果： 赵六  李四</span><br>    <span class="hljs-comment">// ......</span><br><br>&#125;<br><br></code></pre></div></td></tr></table></figure><ol start="2"><li>default Stream<T> dropWhile(Predicate&lt; ? super T&gt; predicate)<blockquote><p>与 takeWhile 相反，返回剩余的元素，和 takeWhile 方法形成互补<br>有序的集合：从头开始删除元素，直到第一个值不满足断言条件，返回剩余元素。<br>无序的集合：如果这个流是无序的，那么这个操作的结果是<strong>不确定</strong>的。</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Stream&lt;String&gt; nameStream = Stream.of(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王麻子&quot;</span>, <span class="hljs-string">&quot;赵六&quot;</span>);<br>    nameStream.dropWhile(item -&gt; item.length() == <span class="hljs-number">2</span>).forEach(System.out::println);<br>    <span class="hljs-comment">// 王麻子  赵六</span><br><br>    System.out.println(<span class="hljs-string">&quot;=========&quot;</span>);<br><br>    Set&lt;String&gt; names = Set.of(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王麻子&quot;</span>, <span class="hljs-string">&quot;赵六&quot;</span>);<br>    names.stream().dropWhile(item -&gt; item.length() == <span class="hljs-number">2</span>).forEach(System.out::println);<br>    <span class="hljs-comment">// 第一次执行结果： 王麻子  赵六</span><br>    <span class="hljs-comment">// 第二次执行结果： 王麻子  赵六  李四</span><br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></div></td></tr></table></figure><ol start="3"><li>public static<T> Stream<T> ofNullable(T t)<blockquote><p>如果非空，则返回一个包含单个元素的连续流，否则返回空流。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Stream&lt;Object&gt; nulStream = Stream.ofNullable(<span class="hljs-keyword">null</span>);<br>System.out.println(nulStream.count());<br><span class="hljs-comment">// 0</span><br></code></pre></div></td></tr></table></figure></li></ol><h3 id="11-改进-Optional-类"><a href="#11-改进-Optional-类" class="headerlink" title="11. 改进 Optional 类"></a>11. 改进 Optional 类</h3><p>Optional 类是在 JDK8 中新增的类，主要是为了解决空指针异常。在 JDK9 中对这个类进行了改进，主要是新增了三个方法：stream、ifPresentOrElse 和 or</p><blockquote><p>ifPresentOrElse：如果有值，则使用该值执行给定的操作，否则执行给定的基于空的操作。<br>or：如果有值，则返回描述该值的 Optional，否则返回由提供函数生成的 Optional。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王麻子&quot;</span>, <span class="hljs-string">&quot;赵六&quot;</span>);<br>    Optional&lt;List&lt;String&gt;&gt; optional = Optional.ofNullable(list);<br>    optional.stream().forEach(System.out::println);<br>    <span class="hljs-comment">// [张三, 李四, 王麻子, 赵六]</span><br><br>    Optional&lt;String&gt; name = Optional.ofNullable(<span class="hljs-keyword">null</span>);<br>    name.ifPresentOrElse(item -&gt; System.out.println(<span class="hljs-string">&quot;name: &quot;</span> + item), () -&gt; System.out.println(<span class="hljs-string">&quot;Not Present.&quot;</span>));<br>    <span class="hljs-comment">// Not Present.</span><br><br>    name = name.or(() -&gt; Optional.of(<span class="hljs-string">&quot;Not Present&quot;</span>));<br>    System.out.println(name.get());<br>    <span class="hljs-comment">// Not Present</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>Optional 类是在JDK8中新增的类，主要是为了解决空指针异常。在JDK9中对这个类进行了改 进，主要是新增了三个方法：stream，ifPresentOrElse 和 or 1 List<String> list = new ArrayList&lt;&gt;(); 2 list.add(“人参”); 3 list.add(“当归”); 4 list.add(“鹿茸”); 5 list.add(“黄柏”); 6 Optional&lt;List<String>&gt; optional = Optional.ofNullable(list); 7 optional.stream().forEach(System.out::println); 8910 Optional<String> optional1 = Optional.of(“Mahesh”); 11 optional1.ifPresentOrElse( x ‐&gt; System.out.println(“Value: “ + x),() ‐&gt; 12 System.out.println(“Not Present.”)); 13 Supplier&lt;Optional<String>&gt; supplierString = () ‐&gt; Optional.of(“Not Prese nt”); 14 optional1 = optional1.or( supplierString); </p><h3 id="12-多分辨率图像API"><a href="#12-多分辨率图像API" class="headerlink" title="12. 多分辨率图像API"></a>12. 多分辨率图像API</h3><p>在 java.awt.image 包下新增了支持多分辨率图片的API，用于支持多分辨率的图片。 </p><ol><li>将不同分辨率的图像封装到一张（多分辨率的）图像中，作为它的变体。</li><li>获取这个图像的所有变体。</li><li>获取特定分辨率的图像变体，表示一张已知分辨率单位为 DPI 的特定尺寸大小的逻辑图像，并且这张图像是最佳的变体。</li><li>java.awt.image.MultiResolutionImage 接口的基础实现 java.awt.image.BaseMultiResolutionImage 获取所需要的变体。</li><li>通过接口的 getResolutionVariant（double destImageWidth, double destImageHeight）方法，根据分辨率获取图像。</li></ol><h3 id="13-全新的-HTTP-客户端-API"><a href="#13-全新的-HTTP-客户端-API" class="headerlink" title="13. 全新的 HTTP 客户端 API"></a>13. 全新的 HTTP 客户端 API</h3><p>HTTP，用于传输网页的协议，早在 1997 年就被采用在目前的 1.1 版本中。直到 2015 年， HTTP2 才成为标准。</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211227000024.png"></p><p>Http2和Http1.X的区别</p><ol><li>HTTP2 使用的是二进制传输，HTTP1.X 是文本（字符串）传输。</li><li>HTTP2 支持多路复用</li><li>HTTP2 头部压缩</li><li>HTTP2 支持服务器推送</li></ol><p>HTTP/1.1 和 HTTP/2 的主要区别是如何在客户端和服务器之间构建和传输数据。HTTP/1.1 依赖于请求/响应周期。 HTTP/2 允许服务器“push”数据：它可以发送比客户端请求更多的数据。 这使得它可以优先处理并发送对于首先加载网页至关重要的数据</p><p><a href="https://www.jianshu.com/p/63fe1bf5d445">http2 和http1.1 区别详细分析</a></p><p>JDK9 中有新的方式来处理 HTTP 调用。它提供了一个新的 HTTP客户端(HttpClient)，它将替代仅适用于 blocking 模式的 HttpURLConnection（HttpURLConnection 是在HTTP 1.0 时代创建的， 并使用了协议无关的方法)，并提供对 WebSocket 和 HTTP/2 的支持。<br>此外，HTTP客户端还提供 API 来处理 HTTP/2 的特性，比如流和服务器推送等功能。 </p><p>全新的 HTTP 客户端 API 可以从 jdk.incubator.httpclient 模块中获取。因为在默认情况下，这个模块是不能根据 classpath 获取的，需要使用 add modules 命令选项配置这个模块，将这个模块添加到  classpath 中。（requires jdk.incubator.httpclient;）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException, URISyntaxException </span>&#123;<br>    <span class="hljs-comment">//创建 builder</span><br>    HttpClient.Builder builder = HttpClient.newBuilder();<br>    <span class="hljs-comment">//链式调用</span><br>    HttpClient client = builder<br>            <span class="hljs-comment">//http 协议版本 1.1 或者 2</span><br>            .version(HttpClient.Version.HTTP_2) <span class="hljs-comment">//.version(HttpClient.Version.HTTP_1_1)</span><br>            <span class="hljs-comment">//连接完成之后的转发策略</span><br>            .followRedirects(HttpClient.Redirect.NEVER). <span class="hljs-comment">//followRedirects(HttpClient.Redirect.ALWAYS)</span><br>            <span class="hljs-comment">// 指定线程池</span><br>                    executor(Executors.newFixedThreadPool(<span class="hljs-number">5</span>))<br><br>            <span class="hljs-comment">//认证，默认情况下 Authenticator.getDefault() 是 null 值，会报错</span><br>            <span class="hljs-comment">//.authenticator(Authenticator.getDefault())</span><br><br>            <span class="hljs-comment">//代理地址</span><br>            <span class="hljs-comment">//.proxy(ProxySelector.of(new InetSocketAddress(&quot;http://www.baidu.com&quot;, 8080)))</span><br><br>            .cookieManager(<span class="hljs-keyword">new</span> CookieManager())<br>            <span class="hljs-comment">//创建完成</span><br>            .build();<br><br>    <span class="hljs-comment">//组装 request</span><br><br>    URI baiduUri = <span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>);<br>    HttpRequest request = HttpRequest.newBuilder(baiduUri)<br>            .version(HttpClient.Version.HTTP_2)<br>            .build();<br>    <span class="hljs-comment">//发起调用</span><br>    HttpResponse&lt;String&gt; r = client.send(request, HttpResponse.BodyHandler.asString());<br>    System.out.println(r.body());<br><br>&#125;<br></code></pre></div></td></tr></table></figure><p><a href="https://blog.csdn.net/u014042066/article/details/78153653">Java9之HttpClientAPI实战详解</a></p><h3 id="14-智能-JAVA-编译工具"><a href="#14-智能-JAVA-编译工具" class="headerlink" title="14. 智能 JAVA 编译工具"></a>14. 智能 JAVA 编译工具</h3><p>智能 java 编译工具（sjavac）的第一个阶段始于 JEP139 这个项目，用于在多核处理器情况下提升 JDK 的编译速度。如今，这个项目已经进入第二阶段，即 JEP199，其目的是改进 Java 编译工 具，并取代目前 JDK 编译工具 javac，继而成为 Java 环境默认的通用的智能编译工具。<br>JDK 9 还更新了 javac 编译器以便能够将 java 9 代码编译运行在低版本 Java 中。</p><h3 id="15-统一的JVM日志系统"><a href="#15-统一的JVM日志系统" class="headerlink" title="15. 统一的JVM日志系统"></a>15. 统一的JVM日志系统</h3><p>日志是解决问题的唯一有效途径：曾经很难知道导致 JVM 性能问题和导致 JVM 崩溃的根本原因。不同的 JVM 日志的碎片化和日志选项（例如：JVM 组件对于日志使用的是不同的机制和规则），这使得 JVM 难以进行调试。<br>解决该问题最佳方法：对所有的 JVM 组件引入一个单一的系统，这些 JVM 组件支持细粒度的和易配置的 JVM 日志。</p><h3 id="16-javadoc-的-HTML5-支持"><a href="#16-javadoc-的-HTML5-支持" class="headerlink" title="16. javadoc 的 HTML5 支持"></a>16. javadoc 的 HTML5 支持</h3><p>JDK8 生成的 java 帮助文档是在 HTML4 中。而 HTML4 已经是很久的标准了。 JDK9 的 javadoc，现支持HTML5 标准，具有搜索功能。</p><h3 id="18-java-动态编译器"><a href="#18-java-动态编译器" class="headerlink" title="18. java 动态编译器"></a>18. java 动态编译器</h3><p>JIT（Just-in-time）编译器可以在运行时将热点编译成本地代码，速度很快。但是 Java 项目现在变得很大很复杂，因此 JIT 编译器需要花费较长时间才能热身完，而且有些 Java 方法还没法编译，性能方面也会下降。AoT 编译就是为了解决这些问题而生的。</p><p>在 JDK 9 中， AOT（JEP 295: Ahead-of-Time Compilation）作为实验特性被引入进来，开发者可以利用新的 jaotc 工具将重点代码转换成类似类库一样的文件。虽然仍处于试验阶段，但这个功能使得 Java 应用在被虚拟机启动之前能够先将 Java 类编译为原生代码。此功能旨在改进小型和大型应用程序的启动时间，同时对峰值性能的影响很小。<br>但是 Java 技术供应商 Excelsior 的营销总监 Dmitry Leskov 担心 AoT 编译技术不够成熟，希望 Oracle 能够等到 Java10 时有个更稳定版本才发布。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java9新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——java8新特性之Optional</title>
    <link href="/2021/12/03/Java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BOptional/"/>
    <url>/2021/12/03/Java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BOptional/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Optional-介绍"><a href="#1-Optional-介绍" class="headerlink" title="1. Optional 介绍"></a>1. Optional 介绍</h3><p>Optional<T> 是在 java.util 包下的一个用于代替 null 的一个工具类</p><p><strong>仅仅是解决 NPE(NullPointerException) 问题吗？</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;Order&gt;  <span class="hljs-title">getOrders</span><span class="hljs-params">(User user)</span></span>&#123;<br>    Optional&lt;User&gt; u = Optional.ofNullable(user);<br>    <span class="hljs-keyword">if</span> (u.isPresent())&#123;<br>        <span class="hljs-keyword">return</span> u.get().getOrders();<br>    &#125;<br>    <span class="hljs-keyword">return</span> Collections.emptyList();<br>&#125;<br><br><span class="hljs-function">List&lt;Order&gt;  <span class="hljs-title">getOrders2</span><span class="hljs-params">(User user)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != user)&#123;<br>        <span class="hljs-keyword">return</span> user.getOrders();<br>    &#125;<br>    <span class="hljs-keyword">return</span> Collections.emptyList();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>第一种方法虽然使用了 Optional ，但是本质上没有区别，如何优雅的使用 Optional？    </p><p><strong>Optional 错误使用姿势</strong></p><ol><li>调用 isPresent() 方法</li><li>调用 get() 方法</li><li>Optional 类型作为类/实例属性</li><li>Optional 类型作为方法参数 </li></ol><blockquote><p>解释：</p><ul><li>使用 isPresent() 和使用 obj != null 无任何分别</li><li>直接调用 get() 方法虽然不抛出 NPE 了，但如果没有值是会抛出 NoSuchElementException。</li></ul></blockquote><p>Optional 中可以依赖的是除了 isPresent() 和 get() 的其他方法：</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">public<U> Optional<U> map(Function&lt;? super T, ? extends U&gt; mapper)</td><td align="center">如果值存在，就对该值执行提供的 mapping 函数的调用</td></tr><tr><td align="center">public T orElse(T other)</td><td align="center">如果有值则将其返回，否则返回默认值</td></tr><tr><td align="center">public T orElseGet(Supplier&lt;? extends T&gt; other)</td><td align="center">如果有值则将其返回，否则返回一个 Supplier 接口生成的值</td></tr><tr><td align="center">public void ifPresent(Consumer&lt;? super T&gt; consumer)</td><td align="center">如果值存在，就通过 consumer 消费次值，否则什么也不做</td></tr><tr><td align="center">public Optional<T> filter(Predicate&lt;? super T&gt; predicate)</td><td align="center">如果值存在并且满足提供的谓词，就返回包含该值的 Optional 对象</td></tr><tr><td align="center">public<U> Optional<U> flatMap(Function&lt;? super T, Optional<U>&gt; mapper)</td><td align="center">如果值存在，就对该值执行提供的 mapping 函数调用</td></tr><tr><td align="center">public <X extends Throwable> T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</td><td align="center">如果有值则将其返回，否则抛出一个由指定的 Supplier 接口生成的异常</td></tr></tbody></table><h3 id="2-Optional-构造方式"><a href="#2-Optional-构造方式" class="headerlink" title="2. Optional 构造方式"></a>2. Optional 构造方式</h3><ul><li>Optional.of(obj)：要求传入的 obj 不能为 null，否则还抛出 NullPointerException 异常</li><li>Optional.empty()：value 为 null 的 Optional</li><li>Optional.ofNullable(obj)：如果 obj  为 null 返回 Optional.empty()，否则返回 Optional.of(obj)</li></ul><blockquote><p>Optional.of(obj) 的作用</p><ol><li>当非常明确将要传给 Optional.of(obj) 的 obj 参数不可能为 null 时, 比如刚 new 出来的对象(Optional.of(new User(…))), 或者是一个非 null 常量时;</li><li>当想为 obj 断言不为 null 时, 即想在万一 obj 为 null 立即报告 NullPointException 异常, 立即修改, 而不是隐藏空指针异常</li></ol></blockquote><h3 id="3-Optional-使用"><a href="#3-Optional-使用" class="headerlink" title="3. Optional 使用"></a>3. Optional 使用</h3><h4 id="3-1-获取值"><a href="#3-1-获取值" class="headerlink" title="3.1 获取值"></a>3.1 获取值</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 存在即返回，否则提供默认值</span><br><span class="hljs-keyword">return</span> user.orElse(UNKNOWUSER);<br><span class="hljs-comment">// 而不是 return user.isPresent() ? user.get() : null ;</span><br><br><br><span class="hljs-comment">// 存在即返回，否则函数生成</span><br><span class="hljs-keyword">return</span> user.orElseGet(<span class="hljs-keyword">this</span>::getDefaultUser);<br><br><span class="hljs-comment">// 存在即返回，否则抛出异常</span><br><span class="hljs-keyword">return</span> user.orElseThrow(NullPointerException::<span class="hljs-keyword">new</span>);<br><br><br><span class="hljs-comment">// 存在才执行操作</span><br>user.ifPresent(System.out::print);<br><span class="hljs-comment">// 而不是</span><br><span class="hljs-keyword">if</span> (user.isPresent())&#123;<br>    System.out.println(user.get());<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="3-2-map-函数"><a href="#3-2-map-函数" class="headerlink" title="3.2 map 函数"></a>3.2 map 函数</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 当 user.isPresent() 为真, 获得 用户名，否则返回 null</span><br>String name = user.map(User::getName).orElse(<span class="hljs-string">&quot;UNKNOW&quot;</span>);<br><br><span class="hljs-comment">// java8 之前</span><br>String name2 = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">if</span> (user.isPresent())&#123;<br>    name2 = user.get().getName();<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    name2 = <span class="hljs-string">&quot;UNKNOW&quot;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="3-3-filter-函数"><a href="#3-3-filter-函数" class="headerlink" title="3.3 filter 函数"></a>3.3 filter 函数</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Optional&lt;String&gt; name = Optional.of(<span class="hljs-string">&quot;debugging&quot;</span>);<br>Optional&lt;String&gt; longName = name.filter(i -&gt; i.length() &gt; <span class="hljs-number">6</span>);<br>System.out.println(longName.orElse(<span class="hljs-string">&quot;The name is less than 6 characters&quot;</span>));<br><span class="hljs-comment">// debugging</span><br><br>Optional&lt;String&gt; name2 = Optional.of(<span class="hljs-string">&quot;admin&quot;</span>);<br>Optional&lt;String&gt; longName2 = name2.filter(i -&gt; i.length() &gt; <span class="hljs-number">6</span>);<br>System.out.println(longName2.orElse(<span class="hljs-string">&quot;The name is less than 6 characters&quot;</span>));<br><span class="hljs-comment">// The name is less than 6 characters</span><br><br><br>Optional&lt;String&gt; name3 = Optional.empty();<br>Optional&lt;String&gt; longName3 = name3.filter(i -&gt; i.length() &gt; <span class="hljs-number">6</span>);<br>System.out.println(longName3.orElse(<span class="hljs-string">&quot;The name is less than 6 characters&quot;</span>));<br><span class="hljs-comment">// The name is less than 6 characters</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——java8新特性之Stream</title>
    <link href="/2021/12/01/java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/"/>
    <url>/2021/12/01/java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/</url>
    
    <content type="html"><![CDATA[<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p><strong>A sequence of elements supporting sequential and parallel aggregate operations .</strong></p><ol><li>Stream 是元素的集合，这点让 Stream 看起来用些类似 Iterator；</li><li>可以支持顺序和并行的对原Stream进行汇聚的操作；</li></ol><blockquote><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulkdata operation)。</p></blockquote><p>Stream API 借助于 Lambda 表达式，极大的提高编程效率和程序可读性。同时提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势（使用 fork/join框架，fork 递归式地分解问题，然后每段并行执行，最终由 join 合并结果，返回最后的值）。</p><p>[例] 统计列表中不为 null 的元素个数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; nums = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">6</span>);<br><br><span class="hljs-comment">//原始版本</span><br><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (Integer item : nums) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != item) &#123;<br>        count++;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Stream 版本</span><br><span class="hljs-keyword">long</span> count1 = nums.stream().filter(Objects::nonNull).count();<br></code></pre></div></td></tr></table></figure><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h3><p><img src="https://user-images.githubusercontent.com/45761474/144250337-a744591a-f7ef-4877-8876-c01a7ede3661.jpg" alt="Stream表达式"></p><p>一条语句分为三部分：</p><ol><li>红色框中的语句是一个 Stream 的生命开始的地方，负责创建一个Stream实例；</li><li>绿色框中的语句是赋予 Stream 灵魂的地方，把一个 Stream 转换成另外一个 Stream；</li><li>蓝色框中的语句是汇聚的地方，把 Stream 里面包含的内容按照某种算法来汇聚成一个值。</li></ol><blockquote><p>使用Stream的基本步骤：</p><ol><li>创建Stream；</li><li>转换Stream，每次转换原有Stream对象不改变，返回一个新的Stream对象（可以有多次转换）；</li><li>对Stream进行聚合（Reduce）操作，获取想要的结果</li></ol></blockquote><h3 id="3-创建-Stream"><a href="#3-创建-Stream" class="headerlink" title="3. 创建 Stream"></a>3. 创建 Stream</h3><p>常见创建 Stream 的方式有三种：</p><ul><li>通过 Stream 接口的静态工厂方法</li><li>通过 Collection 接口的默认方法 stream() 把一个 Collection 对象转换为 Stream</li><li>通过数组，Arrays.stream(T array)</li></ul><ol><li><p>of 方法：有两个 overload 方法，一个接受变长参数，一个接口单一值；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>Stream&lt;String&gt; stringStream = Stream.of(<span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></div></td></tr></table></figure></li><li><p>generator 方法<br>生成一个无限长度的 Stream ，其元素生成时通过给定的 Supplier 接口提供</p></li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Stream.generate(<span class="hljs-keyword">new</span> Supplier&lt;Double&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Math.random();<br>    &#125;<br>&#125;);<br>Stream.generate(()-&gt;Math.random());<br><br>Stream.generate(Math::random);<br></code></pre></div></td></tr></table></figure><p>生成一个无限长度的Stream，其中值是随机的。这个无限长度Stream是懒加载。</p><ol start="3"><li>iterate 方法：</li></ol><p>也是生成无限长度的 Stream，和 generator 不同的是，其元素的生成是重复对给定的种子值(seed)调用用户指定函数来生成的。其中包含的元素可以认为是：seed，f(seed),f(f(seed))无限循环。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 先获取一个无限长度的正整数集合的Stream，然后取出前10个打印。</span><br>      Stream.iterate(<span class="hljs-number">1</span>, item -&gt; item * <span class="hljs-number">2</span>).limit(<span class="hljs-number">10</span>).forEach(System.out::println);<br></code></pre></div></td></tr></table></figure><ol start="4"><li>通过 Collection 子类获取 Stream<br>Collection接口有一个stream方法，所以其所有子类都都可以获取对应的Stream对象。<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integerList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">3</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>integerList.stream();<br>Set&lt;Integer&gt; integerSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>integerSet.stream();<br>Map&lt;String, String&gt; stringMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>stringMap.entrySet().stream();<br>stringMap.keySet().stream();<br>stringMap.values().stream();<br></code></pre></div></td></tr></table></figure></li><li>Arrays.stream(T array)</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Arrays.stream(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);<br></code></pre></div></td></tr></table></figure><h3 id="4-转换Stream"><a href="#4-转换Stream" class="headerlink" title="4. 转换Stream"></a>4. 转换Stream</h3><p>转换Stream就是把一个 Stream 通过某些行为转换成一个新的 Stream。</p><p>Stream 接口中几个常用的转换方法:</p><ul><li>disinct</li><li>filter</li><li>map</li><li>flatmap</li><li>peek</li><li>limit</li><li>skip</li></ul><h4 id="4-1-distinct"><a href="#4-1-distinct" class="headerlink" title="4.1 distinct"></a>4.1 distinct</h4><p>对于 Stream 中包含的元素进行去重操作(依赖于元素的 equals 方法)，新生成的Stream 中没有重复的元素。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>    list.stream().distinct().forEach(item -&gt; System.out.print(item+ <span class="hljs-string">&quot;  &quot;</span>));<br>    <span class="hljs-comment">// 1  null  2  3  4  5  6  7  8  9 </span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="4-2-filter"><a href="#4-2-filter" class="headerlink" title="4.2 filter"></a>4.2 filter</h4><p>对于 Stream 中包含的元素使用给定的过滤函数进行过滤，新生成的 Stream 只包含符合条件的元素</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>list.stream().distinct().filter(Objects::nonNull).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br><span class="hljs-comment">// 1  2  3  4  5  6  7  8  9  </span><br></code></pre></div></td></tr></table></figure><h4 id="4-3-map"><a href="#4-3-map" class="headerlink" title="4.3 map"></a>4.3 map</h4><p>对于 Stream 中包含的元素使用给定的转换函数进行转换操作，新生成的 Stream 只包含转换生成的元素。这个方法有三个对于原始类型的变种方法，分别是：mapToInt，mapToLong 和 mapToDouble。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>list.stream().distinct().filter(Objects::nonNull).map(i -&gt; i * <span class="hljs-number">2</span>).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br><span class="hljs-comment">// 2  4  6  8  10  12  14  16  18 </span><br><br>DoubleStream stream = DoubleStream.of(<span class="hljs-number">23.0</span>, <span class="hljs-number">25.4</span>, <span class="hljs-number">32.5</span>, <span class="hljs-number">45.9</span>);<br>stream.mapToInt(item -&gt; (<span class="hljs-keyword">int</span>) item).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br><span class="hljs-comment">// 23  25  32  45          </span><br></code></pre></div></td></tr></table></figure><h4 id="4-4-flatMap"><a href="#4-4-flatMap" class="headerlink" title="4.4 flatMap"></a>4.4 flatMap</h4><p>和map类似，不同的是其每个元素转换得到的是Stream对象，会把子Stream中的元素压缩到父集合中</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;String&gt; teamIndia = Arrays.asList(<span class="hljs-string">&quot;Virat&quot;</span>, <span class="hljs-string">&quot;Dhoni&quot;</span>, <span class="hljs-string">&quot;Jadeja&quot;</span>);<br>List&lt;String&gt; teamAustralia = Arrays.asList(<span class="hljs-string">&quot;Warner&quot;</span>, <span class="hljs-string">&quot;Watson&quot;</span>, <span class="hljs-string">&quot;Smith&quot;</span>);<br>List&lt;List&lt;String&gt;&gt; players = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>players.add(teamIndia);<br>players.add(teamAustralia);<br>players.stream().flatMap(Collection::stream).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br></code></pre></div></td></tr></table></figure><h4 id="4-5-peek"><a href="#4-5-peek" class="headerlink" title="4.5. peek"></a>4.5. peek</h4><p>生成一个包含原 Stream 的所有元素的新 Stream，同时会提供一个消费函数（Consumer实例），新 Stream 每个元素被消费的时候都会执行给定的消费函数；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>System.out.println(<span class="hljs-string">&quot;\n&quot;</span>+integers.stream().peek(System.out::print).count());<br><span class="hljs-comment">//16789</span><br><span class="hljs-comment">//5</span><br></code></pre></div></td></tr></table></figure><h4 id="4-6-limit"><a href="#4-6-limit" class="headerlink" title="4.6 limit"></a>4.6 limit</h4><p>对一个 Stream 进行截断操作，获取其前N个元素，如果原 Stream 中包含的元素个数小于N，则获取其所有的元素</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>integers.stream().limit(<span class="hljs-number">3</span>).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;   &quot;</span>));<br><span class="hljs-comment">// 1   6   7</span><br></code></pre></div></td></tr></table></figure><h4 id="4-7-skip"><a href="#4-7-skip" class="headerlink" title="4.7 skip"></a>4.7 skip</h4><p>返回一个丢弃原 Stream 的前 N 个元素后剩下元素组成的新 Stream，如果原Stream中包含的元素个数小于N，那么返回空 Stream</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>integers.stream().skip(<span class="hljs-number">2</span>).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;   &quot;</span>));<br><span class="hljs-comment">// 7   8   9  </span><br></code></pre></div></td></tr></table></figure><p>  <strong>转换操作都是 lazy 的，多个转换操作只会在汇聚操作的时候融合起来，一次循环完成。可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在汇聚操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</strong></p><h3 id="5-汇聚（reduce）Stream"><a href="#5-汇聚（reduce）Stream" class="headerlink" title="5. 汇聚（reduce）Stream"></a>5. 汇聚（reduce）Stream</h3><p>Reduce 操作接受一个元素序列为输入，反复使用某个合并操作，把序列中的元素合并成一个汇总的结果。</p><p>比如查找一个数字列表的总和或者最大值，或者把这些数字累积成一个List对象。</p><p>Stream接口通用的汇聚操作</p><ul><li>reduce()</li><li>collect()</li><li>count() </li><li>sum()</li><li>allMatch：判断是否是全部的元素都满足给定匹配条件</li><li>noneMatch：判断是否是全部的元素都不满足给定匹配条件</li><li>anyMatch：判断是否至少有一个元素满足给定匹配条件</li><li>findFirst：返回第一个元素</li><li>max()：使用比较器（Operator），返回 Stream 中最大的元素</li></ul><p>注意：sum 方法不是所有的 Stream 对象都有的，只有 IntStream、LongStream 和 DoubleStream是实例才有。</p><h4 id="5-1-collect"><a href="#5-1-collect" class="headerlink" title="5.1  collect"></a>5.1  collect</h4><p>把输入的元素累积到一个可变的容器中，比如 Collection 或者 StringBuilder。<br>可变汇聚对应的方法只有一个：collect，它的作用就是把Stream中的所有元素收集到一个结果容器中。</p><p><strong>方法定义1：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">&lt;R&gt; <span class="hljs-function">R <span class="hljs-title">collect</span><span class="hljs-params">(Supplier&lt;R&gt; supplier,</span></span><br><span class="hljs-params"><span class="hljs-function">              BiConsumer&lt;R, ? <span class="hljs-keyword">super</span> T&gt; accumulator,</span></span><br><span class="hljs-params"><span class="hljs-function">              BiConsumer&lt;R, R&gt; combiner)</span></span><br></code></pre></div></td></tr></table></figure><p>方法参数：</p><ul><li>Supplier<R> supplier：工厂函数，用来生成一个新的容器。</li><li>BiConsumer&lt;R, ? super T&gt; accumulator：用来把 Stream 中的元素添加到结果容器</li><li>BiConsumer&lt;R, R&gt; combiner：用来把中间状态的多个结果容器合并成一个（并发时）</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>ArrayList&lt;Integer&gt; collect = integers.stream().filter(Objects::nonNull)<br>        .collect(ArrayList::<span class="hljs-keyword">new</span>, ArrayList::add, ArrayList::addAll);<br>System.out.println(collect.toString());<br><span class="hljs-comment">// [1, 6, 7, 8, 9]</span><br></code></pre></div></td></tr></table></figure><p><strong>方法定义2：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">&lt;R, A&gt; <span class="hljs-function">R <span class="hljs-title">collect</span><span class="hljs-params">(Collector&lt;? <span class="hljs-keyword">super</span> T, A, R&gt; collector)</span></span>;<br></code></pre></div></td></tr></table></figure><p>Collectors 已经定义了一些静态工厂方法：</p><ul><li>Collectors.toCollection() 收集到 Collection 中</li><li>Collectors.toList() 收集到 List 中</li><li>Collectors.toSet() 收集到 Set 中</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>List&lt;Integer&gt; collect = integers.stream().filter(Objects::nonNull)<br>        .collect(Collectors.toList());<br>System.out.println(collect.toString());<br><span class="hljs-comment">// [1, 6, 7, 8, 9]</span><br></code></pre></div></td></tr></table></figure><h4 id="5-2-reduce"><a href="#5-2-reduce" class="headerlink" title="5.2 reduce"></a>5.2 reduce</h4><p><strong>方法定义1</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">reduce</span><span class="hljs-params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;<br></code></pre></div></td></tr></table></figure><p>接受一个 BinaryOperator 类型的参数，BinaryOperator 函数有两个参数</p><ul><li>第一个参数是上次函数执行的返回值（中间结果）</li><li>第二个参数是 Stream 中的元素</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>Integer integer = integers.stream().filter(Objects::nonNull).<br>        reduce((sum, item) -&gt; sum + item).get();<br>System.out.println(integer);<br><span class="hljs-comment">// 31</span><br></code></pre></div></td></tr></table></figure><p><strong>方法定义2</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">T <span class="hljs-title">reduce</span><span class="hljs-params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;<br></code></pre></div></td></tr></table></figure><p>和上面的类似，不同的是允许提供一个初始值，如果 Stream 为空，则直接返回初始值。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>Integer integer = integers.stream().filter(Objects::nonNull).<br>        reduce(<span class="hljs-number">100</span>,(sum, item) -&gt; sum + item);<br>System.out.println(integer);<br><span class="hljs-comment">// 131</span><br></code></pre></div></td></tr></table></figure><p><strong>方法定义3</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">&lt;U&gt; <span class="hljs-function">U <span class="hljs-title">reduce</span><span class="hljs-params">(U identity,</span></span><br><span class="hljs-params"><span class="hljs-function">             BiFunction&lt;U, ? <span class="hljs-keyword">super</span> T, U&gt; accumulator,</span></span><br><span class="hljs-params"><span class="hljs-function">             BinaryOperator&lt;U&gt; combiner)</span></span>;<br></code></pre></div></td></tr></table></figure><p>功能和上面的类似，不同的是允许用户提供一个 combiner 函数用来处理并发场景下的数据汇总。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>Integer integer = integers.parallelStream().filter(Objects::nonNull).<br>        reduce(<span class="hljs-number">0</span>, (sum, item) -&gt; sum + item, (result, fragment) -&gt; result + fragment);<br>System.out.println(integer);<br><span class="hljs-comment">// 31</span><br></code></pre></div></td></tr></table></figure><h4 id="5-3-count-方法"><a href="#5-3-count-方法" class="headerlink" title="5.3 count 方法"></a>5.3 count 方法</h4><p>统计 Stream 中的元素的个数</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><span class="hljs-keyword">long</span> count = integers.parallelStream().filter(Objects::nonNull).count();<br>System.out.println(count);<br><span class="hljs-comment">// 5</span><br></code></pre></div></td></tr></table></figure><h3 id="6-Collectors"><a href="#6-Collectors" class="headerlink" title="6. Collectors"></a>6. Collectors</h3><p>Collector接口：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collector</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">A</span>, <span class="hljs-title">R</span>&gt; </span>&#123;<br> <span class="hljs-comment">// 用于生成和返回一个结果容器</span><br>    <span class="hljs-function">Supplier&lt;A&gt; <span class="hljs-title">supplier</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-comment">// 将元素 T 归纳到容器A</span><br>    <span class="hljs-function">BiConsumer&lt;A, T&gt; <span class="hljs-title">accumulator</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-comment">// 将两个结果合并并返回</span><br>    <span class="hljs-function">BinaryOperator&lt;A&gt; <span class="hljs-title">combiner</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-comment">// 将中间结果R 转换为A</span><br>    <span class="hljs-function">Function&lt;A, R&gt; <span class="hljs-title">finisher</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-comment">// characteristics 表示当前 collector的特征值，返回 Collector 特征值的 Set</span><br>    <span class="hljs-function">Set&lt;Characteristics&gt; <span class="hljs-title">characteristics</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>Collectors 是一个工具类，是 JDK 预实现 Collector 的工具类，它内部提供了多种 Collector。</p><p>Collectors 除了提供了上文介绍过的收集方法外还提供了一组非常有用方法。</p><h4 id="6-1-joining"><a href="#6-1-joining" class="headerlink" title="6.1 joining"></a>6.1 joining</h4><p>连接收集的结果</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>String value = integers.stream().map(String::valueOf).collect(Collectors.joining());<br><span class="hljs-comment">// 16789</span><br><br><span class="hljs-comment">// 指定间隔符</span><br>String value1 = integers.stream().map(String::valueOf).collect(Collectors.joining(<span class="hljs-string">&quot;-&quot;</span>));<br><span class="hljs-comment">// 1-6-7-8-9</span><br><br><br><span class="hljs-comment">// 指定间隔符、前缀、后缀</span><br>String value2 = integers.stream().map(String::valueOf).collect(Collectors.joining(<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;$&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>));<br><span class="hljs-comment">// $1-6-7-8-9#</span><br></code></pre></div></td></tr></table></figure><h4 id="6-2-collectingAndThen"><a href="#6-2-collectingAndThen" class="headerlink" title="6.2 collectingAndThen"></a>6.2 collectingAndThen</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T,A,R,RR&gt; Collector&lt;T,A,RR&gt; <span class="hljs-title">collectingAndThen</span><span class="hljs-params">(Collector&lt;T,A,R&gt; downstream,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                            Function&lt;R,RR&gt; finisher)</span></span><br></code></pre></div></td></tr></table></figure><p>通过第二个参数 Function 函数对汇聚后的结果进行再操作</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 收集后逆序排序</span><br>      List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>      List&lt;String&gt; collect = integers.stream().map(String::valueOf).<br>              collect(Collectors.collectingAndThen(Collectors.toList(), Lists::reverse));<br>      <span class="hljs-comment">// [9, 8, 7, 6, 1]</span><br></code></pre></div></td></tr></table></figure><h4 id="6-3-groupingBy"><a href="#6-3-groupingBy" class="headerlink" title="6.3 groupingBy"></a>6.3 groupingBy</h4><p>用于生成一个拥有分组功能的 Collector，它也有三个重载方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 只需一个分组参数 classifier，内部自动将结果保存到一个 map 中</span><br><span class="hljs-comment">// 每个 map 的键为 ？ 类型（即 classifier 的结果类型），值为 list（保存这个组中的元素）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;<br>    groupingBy(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; classifier)<br><br><span class="hljs-comment">// 在上面方法的基础上增加了对流元素的处理方式的Collector，比如上面的默认处理方法是 Collectors.toList()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K, A, D&gt;<br>    Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; classifier,<br>                                          Collector&lt;? <span class="hljs-keyword">super</span> T, A, D&gt; downstream)<br><br><span class="hljs-comment">// 在第二个方法的基础上增加了结果 Map 的生成方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt;<br>    Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; classifier,<br>                                  Supplier&lt;M&gt; mapFactory,<br>                                  Collector&lt;? <span class="hljs-keyword">super</span> T, A, D&gt; downstream)<br><br></code></pre></div></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>Map&lt;Integer, List&lt;Integer&gt;&gt; collect = integers.stream().collect(Collectors.groupingBy(item -&gt; item % <span class="hljs-number">3</span>));<br><span class="hljs-comment">// &#123;0=[3, 6, 9], 1=[1, 4, 7], 2=[2, 5, 8]&#125;</span><br><br>Map&lt;Integer, Set&lt;Integer&gt;&gt; collect1 = integers.stream().collect(Collectors.groupingBy(item -&gt; item % <span class="hljs-number">3</span>, Collectors.toSet()));<br><span class="hljs-comment">// &#123;0=[3, 6, 9], 1=[1, 4, 7], 2=[2, 5, 8]&#125;</span><br><br><br>Map&lt;Integer, Set&lt;Integer&gt;&gt; collect2 = integers.stream()<br>        .collect(Collectors.groupingBy(item -&gt; item % <span class="hljs-number">3</span>,HashMap::<span class="hljs-keyword">new</span>, Collectors.toSet()));<br><span class="hljs-comment">// &#123;0=[3, 6, 9], 1=[1, 4, 7], 2=[2, 5, 8]&#125;</span><br></code></pre></div></td></tr></table></figure><h4 id="6-4-partitioningBy"><a href="#6-4-partitioningBy" class="headerlink" title="6.4 partitioningBy"></a>6.4 partitioningBy</h4><p>将流中的元素按照给定的校验规则分为两部分，放到一个 map 中返回，map 的键是 boolean 类型，值为元素的列表 list。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 只需要一个校验参数 predicate</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt;<br>   Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)<br><span class="hljs-comment">// 在上面的基础上增加了对流中元素的处理方式的 Collector，默认 Collector.toList()</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, D, A&gt;<br>   Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate,<br>                                                   Collector&lt;? <span class="hljs-keyword">super</span> T, A, D&gt; downstream)<br><br></code></pre></div></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><br><span class="hljs-comment">// 对序列进行奇偶分区</span><br>Map&lt;Boolean, List&lt;Integer&gt;&gt; collect = integers.stream().collect(Collectors.partitioningBy(item -&gt; item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>));<br><span class="hljs-comment">// &#123;false=[1, 1, 3, 5, 7, 9], true=[2, 4, 6, 8]&#125;</span><br><br>Map&lt;Boolean, Set&lt;Integer&gt;&gt; collect1 = integers.stream().<br>        collect(Collectors.partitioningBy(item -&gt; item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, Collectors.toSet()));<br><span class="hljs-comment">// &#123;false=[1, 3, 5, 7, 9], true=[2, 4, 6, 8]&#125;</span><br></code></pre></div></td></tr></table></figure><h4 id="6-4-reducing"><a href="#6-4-reducing" class="headerlink" title="6.4 reducing"></a>6.4 reducing</h4><p><strong>方法定义</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 无初始值，返回一个可以生成 Optional 结果的  Collector</span><br>&lt;T&gt; Collector&lt;T, ?, T&gt;   reducing(T identity, BinaryOperator&lt;T&gt; op)<br><br><span class="hljs-comment">// 有初始值，返回一个可以直接生成结果的  Collector</span><br>&lt;T&gt; Collector&lt;T, ?, T&gt;  reducing(T identity, BinaryOperator&lt;T&gt; op)<br><br><span class="hljs-comment">// 有初始值，元素在执行操作之前先执行 mapper 进行元素转换</span><br> &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity,<br>                                Function&lt;? <span class="hljs-keyword">super</span> T, ? extends U&gt; mapper,<br>                                BinaryOperator&lt;U&gt; op)<br></code></pre></div></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><br>Optional&lt;Integer&gt; integerOptional = integers.stream().collect(Collectors.reducing(Integer::sum));<br><span class="hljs-comment">// 等价于 integers.stream().reduce(Integer::sum);</span><br>System.out.println(integerOptional.get());<br><span class="hljs-comment">// 46</span><br><br>Integer collect = integers.stream().collect(Collectors.reducing(<span class="hljs-number">10</span>, Integer::sum));<br><span class="hljs-comment">// 等价于 integers.stream().reduce(10, Integer::sum);</span><br><span class="hljs-comment">// 56</span><br><br>String s = integers.stream().collect(Collectors.reducing(<span class="hljs-string">&quot;@&quot;</span>, String::valueOf, String::concat));<br><span class="hljs-comment">// 等价于 integers.stream().map(String::valueOf).reduce(&quot;@&quot;, String::concat);</span><br><span class="hljs-comment">// @1123456789</span><br></code></pre></div></td></tr></table></figure><h4 id="6-5-综合应用"><a href="#6-5-综合应用" class="headerlink" title="6.5 综合应用"></a>6.5 综合应用</h4><p>将列表按奇偶分组，然后每组里面找最大值（两种实现）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><br>Map&lt;Boolean, Optional&lt;Integer&gt;&gt; collect = integers.stream().collect(<br>        Collectors.partitioningBy(item -&gt; item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>,<br>                Collectors.maxBy(Comparator.comparing(Integer::valueOf))));<br><br>Map&lt;Boolean, Optional&lt;Integer&gt;&gt; collect1 = integers.stream().collect(<br>        Collectors.partitioningBy(item -&gt; item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>,<br>                Collectors.reducing(BinaryOperator.maxBy(Comparator.comparing(Integer::valueOf)))));<br><br><span class="hljs-comment">// &#123;false=Optional[9], true=Optional[8]&#125;</span><br></code></pre></div></td></tr></table></figure><h3 id="7-Stream-的关闭"><a href="#7-Stream-的关闭" class="headerlink" title="7 Stream 的关闭"></a>7 Stream 的关闭</h3><p>Steam 继承了 AutoCloseable 接口，在大多数场景下都是无需手动关闭的，仅在流的资源是 IO 通道（例如：Files.lines(Path ,Charset )）时需要调用 Stream.close() 方法关闭流，以保证 IO 资源的释放。也可以使用 try-with-resources 语法关闭 Stream。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——函数式编程</title>
    <link href="/2021/11/30/java%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/11/30/java%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1-重新认识接口"><a href="#1-重新认识接口" class="headerlink" title="1. 重新认识接口"></a>1. 重新认识接口</h3><h4 id="1-1-java8之前"><a href="#1-1-java8之前" class="headerlink" title="1.1 java8之前"></a>1.1 java8之前</h4><p>接口的作用：定义该类型实例具有的功能，不关心如何进行这些工作。所以，接口定义中只有抽象方法（public abstract）和常量（public static final），并且接口中不允许定义实例变量。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInterface</span> </span>&#123;<br>    Integer age = <span class="hljs-number">18</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="1-2-java8之后"><a href="#1-2-java8之后" class="headerlink" title="1.2 java8之后"></a>1.2 java8之后</h4><p>从JDK8开始，接口可以加入静态方法和默认方法<br>默认方法允许接口方法定义默认实现，而所有子类都继承该方法及实现</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInterface</span> </span>&#123;<br>    Integer age = <span class="hljs-number">18</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printHello</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getString</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>默认方法的优势</strong></p><ol><li>默认方法的主要优势是提供一种拓展接口的方法，而不破坏现有代码。增加新的方法，并且能保证对使用这个接口的老版本代码的兼容性。<br>在JDK8以前，如果为一个现有接口增加一个新方法，则我们必须在所有实现类中添加该方法的实现，否则编译会出现异常。<br>如果实现类比较多或者我们没有权限修改实现类源代码，这样可能就比较麻烦。<br>默认方法则解决了这个问题，它提供了一个实现，当没有显式提供其他实现时就采用这个实现，这样新添加的方法将不会破坏现有代码。</li><li>另一个优势是该方法是可选，子类可以根据不同的需求Override默认实现。<br>例如，我们定义一个集合接口，其中有增、删、改等操作。如果实现类90%都是以数组保存数据，那么可以定义针对这些方法给出默认实现，而对于其他非数组集合或者有其他类似业务，可以选择性复写接口中默认方法。</li></ol><h3 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2.函数式接口"></a>2.函数式接口</h3><p><strong>定义：</strong></p><blockquote><p>如果一个接口定义唯一一个抽象方法，那么这个接口就成为函数式接口。</p></blockquote><p>java.lang.Runnable 就是一个函数式接口，因为它只有一个抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>默认方法不是abstract的，所以一个函数式接口里可以定义任意多的默认方法。<br>为了标明函数式接口Java8引入了一个新的注解： @FunctionalInterface</p><p><strong>函数接口特性</strong></p><ul><li>@FunctionInterface 注解只能标记在有且仅有一个抽象方法的接口上；</li><li>Java8接口中的静态方法和默认方法，都不算是抽象方法；</li><li>接口默认继承 java.lang.Object ,所以如果接口声明覆盖了Object中的方法，那么也不算抽象方法；</li><li>注解不是必须的，如果接口符合函数式接口的定义，那么不加注解也没有影响。加上则编译器可以进行检查。如果不是函数接口而加上了注解，则编译器会报错。</li></ul><h3 id="3-函数式编程"><a href="#3-函数式编程" class="headerlink" title="3.  函数式编程"></a>3.  函数式编程</h3><p>函数编程特性：</p><p><strong>a. 闭包与高阶函数</strong><br>函数编程支持函数作为第一类对象，有时称为 闭包或者 仿函数（functor）对象。实质上，闭包是起函数的作用并可以像对象一样操作的对象。高阶函数可以用另一个函数作为其输入参数，也可以返回一个函数作为其输出参数。</p><p><strong>b. 惰性计算</strong><br>在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算。延迟的计算可以编写可能潜在地生成无穷输出的函数。因为不会计算多于程序的其余部分所需要的值，所以不需要担心由无穷计算所导致的 out-of-memory 错误。</p><p><strong>c. 没有“副作用”</strong><br>所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p><blockquote><p>综上所述，函数式编程可以简言之是： 使用不可变值和函数， 通过函数对一个值进行处理， 映射成另一个值。这个值在面向对象语言中可以理解为对象，另外这个值还可以作为函数的输入。</p></blockquote><p>Java8 中的函数式编程</p><ul><li>内建的函数式接口</li><li>Optional API</li><li>Lambda表达式</li><li>Stream API</li></ul><h4 id="3-1-内建的函数式接口"><a href="#3-1-内建的函数式接口" class="headerlink" title="3.1 内建的函数式接口"></a>3.1 内建的函数式接口</h4><p>Java8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。</p><table><thead><tr><th align="center">name</th><th align="center">type</th><th align="center">description</th></tr></thead><tbody><tr><td align="center">Consumer(消费者)</td><td align="center">Consumer<T></td><td align="center">接收 T 对象，不返回值</td></tr><tr><td align="center">Predicate(谓词)</td><td align="center">Predicate<T></td><td align="center">接收 T 对象并返回boolean</td></tr><tr><td align="center">Function(函数)</td><td align="center">Function&lt;T,R&gt;</td><td align="center">接收 T 对象，返回 R 对象</td></tr><tr><td align="center">Supplier(提供者)</td><td align="center">Supplier<T></td><td align="center">提供T对象，不接收值</td></tr><tr><td align="center">UnaryOperator(一元运算符)</td><td align="center">UnaryOperator<T></td><td align="center">接收T对象，返回T对象</td></tr><tr><td align="center">BinaryOperator(二元操作)</td><td align="center">BinaryOperator<T></td><td align="center">接收两个T对象，返回T对象</td></tr></tbody></table><blockquote><p>以上四种为基本的函数接口，在此之上JDK又提供了若干扩展：</p><ol><li>以上前三种添加了Bi的前缀：BiConsumer,BiPredicate,BiFunction,入参变为两个；</li><li>对Function的扩展产生了UnaryOperator(一元运算符)，接收T返回T；</li><li>对BiFunction的扩展产生了BinaryOperator(二元操作)，收两个T对象，返回T对象</li><li>增加了若干具体基本类型的接口，可参见function包下具体接口说明。</li></ol></blockquote><h4 id="3-2-Optional-API"><a href="#3-2-Optional-API" class="headerlink" title="3.2 Optional API"></a>3.2 Optional API</h4><p>Java8中引入的 Optional 是一种优雅解决NPE(NullPointExcepiton)问题的方法，是通过函数式接口实现的。</p><p>Optional 提供的方法：</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">public<U> Optional<U> map(Function&lt;? super T, ? extends U&gt; mapper)</td><td align="center">如果当前 Optional 为 Optional.empty，则依旧返回 Optional.empty；否则返回一个新的 Optional，该 Optional 包含的是：函数 mapper 在以 value 作为输入时的输出值。</td></tr><tr><td align="center">public T orElse(T other)</td><td align="center">如果有值则将其返回，否则返回一个默认值</td></tr><tr><td align="center">public T orElseGet(Supplier&lt;? extends T&gt; other)</td><td align="center">如果有值则将其返回，否则返回一个由指定的Supplier接口生成的值</td></tr></tbody></table><p>如果当前 Optional 为 Optional.empty，则依旧返回 Optional.empty；否则返回一个新的 Optional，该 Optional 包含的是：函数 mapper 在以 value 作为输入时的输出值。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git——rebase命令</title>
    <link href="/2021/11/29/Git%E2%80%94%E2%80%94rebase%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/11/29/Git%E2%80%94%E2%80%94rebase%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h3><ul><li>合并多次提交记录</li><li>分支合并</li><li>对一个分支做『变基』操作</li></ul><h3 id="2-合并多次提交记录"><a href="#2-合并多次提交记录" class="headerlink" title="2. 合并多次提交记录"></a>2. 合并多次提交记录</h3><p>合并最近两次commit:</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> rebase -i HEAD~<span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>执行命令后会自动进入 vi 编辑模式：</p><figure class="highlight plaintext"><figcaption><span>6935383 rename冲突</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pick">pick 23b1a51 debug<br><br># Rebase eb7f366..23b1a51 onto eb7f366 (2 commands)<br>#<br># Commands:<br># p, pick &lt;commit&gt; = use commit<br># r, reword &lt;commit&gt; = use commit, but edit the commit message<br># e, edit &lt;commit&gt; = use commit, but stop for amending<br># s, squash &lt;commit&gt; = use commit, but meld into previous commit<br># f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&#x27;s log message<br># x, exec &lt;command&gt; = run command (the rest of the line) using shell<br># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)<br># d, drop &lt;commit&gt; = remove commit<br># l, label &lt;label&gt; = label current HEAD with a name<br># t, reset &lt;label&gt; = reset HEAD to a label<br># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]<br># .       create a merge commit using the original merge commit&#x27;s<br># .       message (or the oneline, if no original merge commit was<br># .       specified). Use -c &lt;commit&gt; to reword the commit message.<br>#<br># These lines can be re-ordered; they are executed from top to bottom.<br>#<br># If you remove a line here THAT COMMIT WILL BE LOST.<br>#<br># However, if you remove everything, the rebase will be aborted.<br></code></pre></div></td></tr></table></figure><blockquote><p>【注】<br>p, pick = use commit<br>r, reword = use commit, but edit the commit message<br>e, edit = use commit, but stop for amending<br>s, squash = use commit, but meld into previous commit<br>f, fixup = like “squash”, but discard this commit’s log message<br>x, exec = run command (the rest of the line) using shell<br>d, drop = remove commit</p></blockquote><p>修改提交纪录并保存退出。</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">pick</span> <span class="hljs-number">6935383</span> rename冲突<br><span class="hljs-attribute">s</span> <span class="hljs-number">23</span>b<span class="hljs-number">1</span>a<span class="hljs-number">51</span> debug<br></code></pre></div></td></tr></table></figure><p>保存后到注释修改界面。</p><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta"># This is a combination of 2 commits.</span><br><span class="hljs-meta"># This is the 1st commit message:</span><br><br>rename冲突<br><br><span class="hljs-meta"># This is the commit message #2:</span><br><br>debug<br><br><span class="hljs-meta"># Please enter the commit message for your changes. Lines starting</span><br><span class="hljs-meta"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># Date:      Tue Nov 24 22:56:02 2020 +0800</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># interactive rebase in progress; onto eb7f366</span><br><span class="hljs-meta"># Last commands done (2 commands done):</span><br><span class="hljs-meta">#    pick 6935383 rename冲突</span><br><span class="hljs-meta">#    squash 23b1a51 debug</span><br><span class="hljs-meta"># No commands remaining.</span><br><span class="hljs-meta"># You are currently rebasing branch &#x27;maseter&#x27; on &#x27;eb7f366&#x27;.</span><br></code></pre></div></td></tr></table></figure><p>（非编辑状态输入dd删除一行）</p><p>保存后即合并完成。</p><blockquote><p>异常情况：<br>1、不要合并已提交远程分支的纪录<br>如果这样做，可能出现push rejected。 解决方式当然是先拉下远程的代码，进行冲突处理，再进行提交。<br>2、git rebase -i 异常操作导致退出了vim编辑页面，会提示：</p><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">$ git rebase -i head~<span class="hljs-number">2</span><br><span class="hljs-keyword">error</span>: could <span class="hljs-keyword">not</span> apply <span class="hljs-number">040</span>bd4b... commit <span class="hljs-keyword">on</span> issue<span class="hljs-number">-005</span><br>Resolve all conflicts manually, mark them <span class="hljs-keyword">as</span> resolved <span class="hljs-keyword">with</span><br><span class="hljs-string">&quot;git add/rm &lt;conflicted_files&gt;&quot;</span>, <span class="hljs-keyword">then</span> <span class="hljs-built_in">run</span> <span class="hljs-string">&quot;git rebase --continue&quot;</span>.<br>You can instead skip this commit: <span class="hljs-built_in">run</span> <span class="hljs-string">&quot;git rebase --skip&quot;</span>.<br>To abort <span class="hljs-keyword">and</span> <span class="hljs-keyword">get</span> <span class="hljs-keyword">back</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span> state <span class="hljs-keyword">before</span> <span class="hljs-string">&quot;git rebase&quot;</span>, <span class="hljs-built_in">run</span> <span class="hljs-string">&quot;git rebase --abort&quot;</span>.<br>Could <span class="hljs-keyword">not</span> apply <span class="hljs-number">040</span>bd4b... commit <span class="hljs-keyword">on</span> issue<span class="hljs-number">-005</span><br>Auto-merging README.md<br>CONFLICT (content): Merge conflict <span class="hljs-keyword">in</span> README.md<br></code></pre></div></td></tr></table></figure><p>使用 git rebase –edit-todo 会再次进入刚才编辑错误退出前的vim状态，这时候可以修改你的编辑。<br>使用git rebase –abort  表明退出当前的合并请求( 又回到原来的2个commit的状态)</p></blockquote><h3 id="3-变基"><a href="#3-变基" class="headerlink" title="3. 变基"></a>3. 变基</h3><p>使用场景：本地与远端同一分支提交历史不一致</p><p>多个人在同一个分支上协作时，比如由我和A一同开发。我在修复了一个bug以后准备提交。</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">add</span> .<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git commit -<span class="hljs-keyword">m</span> <span class="hljs-string">&quot;debug the world&quot;</span><br>[master a40d43c] <span class="hljs-keyword">debug</span> the world<br> <span class="hljs-number">1</span> <span class="hljs-keyword">file</span> changed, <span class="hljs-number">0</span> insertions(+), <span class="hljs-number">0</span> deletions(-)<br> create <span class="hljs-keyword">mode</span> <span class="hljs-number">100644</span> aa.txt<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git push origin master<br>To github.<span class="hljs-keyword">com</span>:Zhangtao153/learngit.git<br> ! [rejected]        master -&gt; master (non-fast-forward)<br>error: failed <span class="hljs-keyword">to</span> push some refs <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;github.com:Zhangtao153/learngit.git&#x27;</span><br>hin<span class="hljs-variable">t:</span> Updates were rejected because the tip of your current branch <span class="hljs-keyword">is</span> behind<br>hin<span class="hljs-variable">t:</span> its remote counterpart. Integrate the remote <span class="hljs-keyword">changes</span> (<span class="hljs-keyword">e</span>.g.<br>hin<span class="hljs-variable">t:</span> <span class="hljs-string">&#x27;git pull ...&#x27;</span>) before pushing again.<br>hin<span class="hljs-variable">t:</span> See the <span class="hljs-string">&#x27;Note about fast-forwards&#x27;</span> in <span class="hljs-string">&#x27;git push --help&#x27;</span> <span class="hljs-keyword">for</span> details.<br></code></pre></div></td></tr></table></figure><p>push失败了，说明A在我之前已经提交了，我本地master分支的提交历史已经落后远端了，需要先pull一下，与远端同步后才能push</p><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git pull<br>Merge made <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> README.md | <span class="hljs-number">3</span> ++-<br> <span class="hljs-number">1</span> <span class="hljs-built_in">file</span> changed, <span class="hljs-number">2</span> insertions(+), <span class="hljs-number">1</span> deletion(-)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--oneline --graph</span><br>*   <span class="hljs-number">912</span>bb85 (HEAD -&gt; master) Merge branch <span class="hljs-string">&#x27;master&#x27;</span> <span class="hljs-keyword">of</span> github.com:Zhangtao153/learngit <span class="hljs-keyword">into</span> master<br>|\<br>| * <span class="hljs-number">7</span>ad4fd6 (origin/master) <span class="hljs-built_in">add</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span><br>* | a40d43c debug <span class="hljs-keyword">the</span> world<br>|/<br>* a8d2e0d 手动删除<br>* <span class="hljs-number">1</span>d243ca <span class="hljs-built_in">add</span> test <span class="hljs-built_in">file</span><br>* <span class="hljs-number">8438389</span> wrote <span class="hljs-keyword">a</span> readme <span class="hljs-built_in">file</span><br></code></pre></div></td></tr></table></figure><p>竟然分叉了！由于我本地master的提交历史和远端的master分支的提交历史不一致，所以git为我进行了自动合并，然后生成了一个新的提交历史。</p><p>这个时候就可以用 git rebase 解决分叉的问题。</p><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git rebase<br>Successfully rebased <span class="hljs-keyword">and</span> updated refs/heads/master.<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br><span class="hljs-symbol">$</span> git <span class="hljs-built_in">log</span> --oneline --graph<br><span class="hljs-comment">* 4178b6e (HEAD -&gt; master) debug the world</span><br><span class="hljs-comment">* 7ad4fd6 (origin/master) add a new function</span><br><span class="hljs-comment">* a8d2e0d 手动删除</span><br><span class="hljs-comment">* 1d243ca add test file</span><br><span class="hljs-comment">* 8438389 wrote a readme file</span><br></code></pre></div></td></tr></table></figure><p>然后再push，将本地修改同步到远端。</p><p>git pull –rebase 和上面的效果一致。</p><h3 id="4-合并分支"><a href="#4-合并分支" class="headerlink" title="4. 合并分支"></a>4. 合并分支</h3><p>先创建一个分支用于解决bug</p><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">$ git checkout -b issues<span class="hljs-number">-001</span><br>Switched <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> branch <span class="hljs-string">&#x27;issues-001&#x27;</span><br></code></pre></div></td></tr></table></figure><p>接下解决bug，然后保存提交</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (issues-<span class="hljs-number">001</span>)<br>$ git add .<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (issues-<span class="hljs-number">001</span>)<br>$ git commit -m <span class="hljs-string">&quot;issues-001&quot;</span><br>[issues-<span class="hljs-number">001</span> <span class="hljs-number">7</span>a55a26] issues-<span class="hljs-number">001</span><br> <span class="hljs-number">1</span> <span class="hljs-keyword">file</span> changed, <span class="hljs-number">1</span> insertion(+)<br></code></pre></div></td></tr></table></figure><p>先尝试通过 merge 合并：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issues<span class="hljs-number">-001</span>)<br>$ git <span class="hljs-keyword">switch</span> master<br>Switched <span class="hljs-built_in">to</span> branch <span class="hljs-string">&#x27;master&#x27;</span><br>Your branch is ahead <span class="hljs-keyword">of</span> <span class="hljs-string">&#x27;origin/master&#x27;</span> <span class="hljs-keyword">by</span> <span class="hljs-number">1</span> commit.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> <span class="hljs-built_in">to</span> publish your <span class="hljs-built_in">local</span> commits)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">merge</span> issues<span class="hljs-number">-001</span><br>Merge made <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> aa.txt | <span class="hljs-number">1</span> +<br> <span class="hljs-number">1</span> <span class="hljs-built_in">file</span> changed, <span class="hljs-number">1</span> insertion(+)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--oneline --graph</span><br>*   ae02ea0 (HEAD -&gt; master) Merge branch <span class="hljs-string">&#x27;issues-001&#x27;</span> <span class="hljs-keyword">into</span> master<br>|\<br>| * <span class="hljs-number">7</span>a55a26 (issues<span class="hljs-number">-001</span>) issues<span class="hljs-number">-001</span><br>* | d36d166 commit <span class="hljs-keyword">on</span> <span class="hljs-title">master</span><br>|/<br>* <span class="hljs-number">4178</span>b6e (origin/master) debug <span class="hljs-keyword">the</span> world<br>* <span class="hljs-number">7</span>ad4fd6 <span class="hljs-built_in">add</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span><br>* a8d2e0d 手动删除<br>* <span class="hljs-number">1</span>d243ca <span class="hljs-built_in">add</span> test <span class="hljs-built_in">file</span><br>* <span class="hljs-number">8438389</span> wrote <span class="hljs-keyword">a</span> readme <span class="hljs-built_in">file</span><br></code></pre></div></td></tr></table></figure><p>虽然合并成功，但是Master已经保存了合并历史，出现开叉了！</p><p>通过rebase合并分支</p><p>先将代码回退到merge之前</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^</span><br>HEAD <span class="hljs-keyword">is</span> now at d36d166 <span class="hljs-keyword">commit</span> <span class="hljs-keyword">on</span> master<br></code></pre></div></td></tr></table></figure><p>先切换回issues-001分支，在issues-001分支上执行: git rebase master</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (master)<br>$ git <span class="hljs-keyword">switch</span> issues-<span class="hljs-number">001</span><br>Switched to branch <span class="hljs-string">&#x27;issues-001&#x27;</span><br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (issues-<span class="hljs-number">001</span>)<br>$ git rebase master<br>Successfully rebased and updated refs<span class="hljs-regexp">/heads/i</span>ssues-<span class="hljs-number">001</span>.<br></code></pre></div></td></tr></table></figure><p>【注】如果rebase出现冲突，先解决冲突，然后通过add添加，之前的rebase其实只是完成了一半，由于出现冲突而终止，冲突解决之后，可以通过git rebase —continue继续完成之前的rebase操作。</p><p>切换到主分支master，将issues-001分支上的提交合并过来。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issues<span class="hljs-number">-001</span>)<br>$ git <span class="hljs-keyword">switch</span> master<br>Switched <span class="hljs-built_in">to</span> branch <span class="hljs-string">&#x27;master&#x27;</span><br>Your branch is ahead <span class="hljs-keyword">of</span> <span class="hljs-string">&#x27;origin/master&#x27;</span> <span class="hljs-keyword">by</span> <span class="hljs-number">1</span> commit.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> <span class="hljs-built_in">to</span> publish your <span class="hljs-built_in">local</span> commits)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">merge</span> issues<span class="hljs-number">-001</span><br>Updating d36d166.<span class="hljs-number">.43823</span>d4<br>Fast-forward<br> aa.txt | <span class="hljs-number">1</span> +<br> <span class="hljs-number">1</span> <span class="hljs-built_in">file</span> changed, <span class="hljs-number">1</span> insertion(+)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--oneline --graph</span><br>* <span class="hljs-number">43823</span>d4 (HEAD -&gt; master, issues<span class="hljs-number">-001</span>) issues<span class="hljs-number">-001</span><br>* d36d166 commit <span class="hljs-keyword">on</span> <span class="hljs-title">master</span><br>* <span class="hljs-number">4178</span>b6e (origin/master) debug <span class="hljs-keyword">the</span> world<br>* <span class="hljs-number">7</span>ad4fd6 <span class="hljs-built_in">add</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span><br>* a8d2e0d 手动删除<br>* <span class="hljs-number">1</span>d243ca <span class="hljs-built_in">add</span> test <span class="hljs-built_in">file</span><br>* <span class="hljs-number">8438389</span> wrote <span class="hljs-keyword">a</span> readme <span class="hljs-built_in">file</span><br></code></pre></div></td></tr></table></figure><p>master是一条直线了。最后删除掉issues-001分支。</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (master)<br>$ git branch -d issues-<span class="hljs-number">001</span><br>Deleted branch issues-<span class="hljs-number">001</span> (was <span class="hljs-number">43823</span>d4).<br></code></pre></div></td></tr></table></figure><p>​</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——java8新特性之Lambda 表达式</title>
    <link href="/2021/11/28/java%E2%80%94%E2%80%94jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/11/28/java%E2%80%94%E2%80%94jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>lambda 表达式本质上是一段匿名内部类，也可以是一段可以传递的代码</p><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h4><p>完整的 Lambda 表达式由三部分组成：参数列表、箭头、声明语句；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"> (Type1 param1, Type2 param2, ..., TypeN paramN) ‐&gt; &#123; statment1;<br>statment2; <span class="hljs-comment">//............. return statmentM;&#125;</span><br></code></pre></div></td></tr></table></figure><ol><li>绝大多数情况，编译器都可以从上下文环境中推断出lambda表达式的参数类型，所以参数可以省略：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">(param1,param2, ..., paramN) ‐&gt; &#123; statment1; statment2; <span class="hljs-comment">//............. r</span><br>eturn statmentM;&#125;<br></code></pre></div></td></tr></table></figure></li><li>当lambda表达式的参数个数只有一个，可以省略小括号：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">param1 ‐&gt; &#123; statment1; statment2; <span class="hljs-comment">//............. return statmentM;&#125;</span><br></code></pre></div></td></tr></table></figure></li><li>当lambda表达式只包含一条语句时，可以省略大括号、return和语句结尾的分号：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">param1 ‐&gt; statment<br></code></pre></div></td></tr></table></figure></li></ol><h4 id="2-函数接口"><a href="#2-函数接口" class="headerlink" title="2. 函数接口"></a>2. 函数接口</h4><p>函数接口是只有一个抽象方法的接口， 用作 Lambda 表达式的返回类型。<br>包路径为 java.util.function 接口类上面都有@FunctionalInterface这个注解。</p><h4 id="3-类型检查、类型推断"><a href="#3-类型检查、类型推断" class="headerlink" title="3.  类型检查、类型推断"></a>3.  类型检查、类型推断</h4><p>Java编译器根据 Lambda 表达式上下文信息就能推断出参数的正确类型。 程序依然要经过类型检查来保证运行的安全性， 但不用再显式声明类型罢了。 这就是所谓的类型推断。</p><h4 id="4-局部变量限制"><a href="#4-局部变量限制" class="headerlink" title="4.  局部变量限制"></a>4.  局部变量限制</h4><p>Lambda表达式也允许使用自由变量（不是参数，而是在外层作用域中定义的变量），就像匿名类一样。 它们被称作捕获Lambda。 Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为final，或事实上是final。</p><p>Lambda 表达式访问外部变量：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String[] strings = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;;<br>    <span class="hljs-keyword">for</span> (Integer i : Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)) &#123;<br>        Stream.of(strings).map(string -&gt; string + i).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>为什么局部变量有这些限制？<br>实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。因此， Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String[] strings = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>    Stream.of(strings).map(string -&gt; string + i).forEach(System.out::println);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>上面的代码会报编译错误，lambda 表达式引用的变量需要时final或等效final的变量。</strong></p><h4 id="5-Lambda表达式的方法和构造器引用"><a href="#5-Lambda表达式的方法和构造器引用" class="headerlink" title="5.  Lambda表达式的方法和构造器引用"></a>5.  Lambda表达式的方法和构造器引用</h4><p>方法引用的语法格式有以下三种：</p><ol><li>objectName::instanceMethod</li><li>ClassName::staticMethod</li><li>ClassName::instanceMethod</li></ol><blockquote><p>前两种等同于把lambda表达式的参数当成 instanceMethod | staticMethod 的参数来调用。<br>例如： Math::max等同于(x, y)-&gt;Math.max(x,y)</p><p>后一种等于把lambda表达式的第一个参数当成instanceMethod 的目标对象，其他参数当成该方法的参数。<br>例如： String::toLowerCase() 等同于 x-&gt;x.toLowerCase()</p></blockquote><p><em>构造器引用语法如下</em></p><p>ClassName::new</p><blockquote><p>把 lambda 表达式的参数当成 ClassName 构造器的参数。例如： BigDecimal::new 等同于 x-&gt;new BigDecimal(x)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis——入门</title>
    <link href="/2021/11/28/Redis%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"/>
    <url>/2021/11/28/Redis%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-NoSQL介绍"><a href="#1-NoSQL介绍" class="headerlink" title="1.  NoSQL介绍"></a>1.  NoSQL介绍</h2><p>NoSQL （Not Only SQL）指的是非关系型的数据库，是对不同于传统的关系型数据库的数据库管理系统的统称。NoSQL用于超大规模数据的存储。Redis就属于非关系型数据库,传统的Mysql ,oracle ,sql server 等 都是关系型数据库。</p><h2 id="2-为什么需要NoSQL"><a href="#2-为什么需要NoSQL" class="headerlink" title="2. 为什么需要NoSQL"></a>2. 为什么需要NoSQL</h2><p>主要应对以下问题时，传统关系型数据库力不从心</p><p>  高并发读写<br>  海量数据的高效率存储和访问<br>  高可扩展性和高可用性</p><h2 id="3-Redis-简介"><a href="#3-Redis-简介" class="headerlink" title="3. Redis 简介"></a>3. Redis 简介</h2><p>Redis 是一个高性能的 key-value 数据库。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><p>Redis 与其他 key - value 缓存产品相比有以下三个特点：<br>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。<br>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>Redis支持数据的备份，即master-slave模式的数据备份。<br>Redis的应用场景<br>缓存<br>任务队列<br>网站访问统计<br>数据过期处理<br>应用排行榜<br>分布式集群架构中的session分离<br>Redis 支持的五种数据类型：<br>字符串（String）<br>字符串列表（list）<br>哈希（hash）<br>字符串集合（set）<br>有序字符串集合（zset）</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
