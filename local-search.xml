<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Java——java8新特性之Optional</title>
    <link href="/2021/12/03/Java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BOptional/"/>
    <url>/2021/12/03/Java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BOptional/</url>
    
    <content type="html"><![CDATA[<p>优雅的使用Java8 Optional<br>Java8 增加了很多有用的API，其他的不说，今天只说说 Optional<br>仅是解决NPE问题吗？<br>简单看过Optional说明的同学可能认为它是解决NPE(NullPointExcepiton)问题的，于是代码是这样：<br>List<Order> getOrders(User u){<br> Optional<User> user = Optional.ofNullable(u);<br> if(user.isPresent()){<br> return user.get().getOrders();<br> }<br> return Collections.emptyList();<br>}<br>这样的写法对吗？<br>对，没问题，可这样与我们原来的写法有区别吗？<br>List<Order> getOrders(User u){<br> if(u != null){<br> return user.getOrders();<br> }<br> return Collections.emptyList();<br>}<br>其实没区别，因为思维还在原地踏步，本能的认为不过是User 实例的包装。<br>那既然一样，使用Optional需要写的还更多一些，这个API不就是没有意义了吗？<br>那是我们没有理解设计者的意图，没有优雅使用！<br>如何优雅？<br>当切换到Java 8 的 Optional 时, 不能继承性的对待过往 null 时的那种思维, 应该掌握好新的, 正确的使<br>用姿势.<br>需要了解一点点java函数编程的知识，附件有Optional 用到的函数接口的说明<br>在使用正确的姿势前，错误的姿势有哪些？</p><ol><li>调用isPresent()方法</li><li>调用get()方法</li><li>Optional 类型作为类/实例属性</li><li>Optional 类型作为方法参数 generated by haroopad<br>2018/3/31 Optional.html<br>file:///E:/%E5%B7%A5%E4%BD%9C/%E5%9F%B9%E8%AE%AD%E4%B8%8E%E5%88%86%E4%BA%AB/java/Optional.html 2/5<br>解释下：</li><li>使用isPresent() 和使用obj!=null 无任何分别</li><li>直接调用get()方法虽然不抛出NPE了，但如果没有值是会抛出NoSuchElementException。<br>这个方法的源码如下：<br>/**</li></ol><ul><li>If a value is present in this {@code Optional}, returns the value,</li><li>otherwise throws {@code NoSuchElementException}.</li><li></li><li>@return the non-null value held by this {@code Optional}</li><li>@throws NoSuchElementException if there is no value present</li><li></li><li>@see Optional#isPresent()</li><li>/<br>public T get() {<br>if (value == null) {<br>throw new NoSuchElementException(“No value present”);<br>}<br>return value;<br>}<br>3和4 是将Optional类型作为属性或是方法参数，这样使用更是不可取。<br>所以Optional 中可以依赖的应该是除了isPresent()和get()的其他方法：<br>方法 描述<br>public<U> Optional<U> map(Function&lt;? super T, ?<br>extends U&gt; mapper)<br>如果值存在，就对该值执行提供的<br>mapping函数的调用<br>public T orElse(T other)<br>如果有值则将其返回，否则返回一个<br>默认值<br>public T orElseGet(Supplier&lt;? extends T&gt; other)<br>如果有值则将其返回，否则返回一个<br>由指定的Supplier接口生成的值<br>public void ifPresent(Consumer&lt;? super T&gt;<br>consumer)<br>如果值存在，就执行使用该值的方法<br>调用，否则什么也不做<br>public Optional<T> filter(Predicate&lt;? super T&gt;<br>predicate)<br>如果值存在并且满足提供的谓词，就<br>返回包含该值的Optional对象<br>public<U> Optional<U> flatMap(Function&lt;? super T,<br>Optional<U>&gt; mapper)<br>如果值存在，就对该值执行提供的<br>mapping函数调用<br>public <X extends Throwable> T<br>orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier)<br>throws X<br>如果有值则将其返回，否则抛出一个<br>由指定的Supplier接口生成的异常<br>generated by haroopad<br>2018/3/31 Optional.html<br>file:///E:/%E5%B7%A5%E4%BD%9C/%E5%9F%B9%E8%AE%AD%E4%B8%8E%E5%88%86%E4%BA%AB/java/Optional.html 3/5<br>在介绍以上7个方法之前先提Optional的三种构造方式：<br>Optional.of(obj)<br>Optional.ofNullable(obj)<br>Optional.empty()<br>Optional.of(obj): 它要求传入的 obj 不能是 null 值的, 否则还没开始进入角色就倒在了<br>NullPointerException 异常上了.<br>Optional.ofNullable(obj): 它以一种智能的, 宽容的方式来构造一个 Optional 实例. 来者不拒, 传 null 进到<br>就得到 Optional.empty(), 非 null 就调用 Optional.of(obj).<br>Optional.empty():空值的Optional<br>那是不是我们只要用 Optional.ofNullable(obj) 一劳永逸, 以不变应二变的方式来构造 Optional 实例就行<br>了呢?<br>那也未必, 否则 Optional.of(obj) 何必如此暴露呢, 私有则可?<br>可以这样理解：<br>当我们非常非常的明确将要传给 Optional.of(obj) 的 obj 参数不可能为 null 时, 比如它是一个刚 new 出<br>来的对象(Optional.of(new User(…))), 或者是一个非 null 常量时; 2. 当想为 obj 断言不为 null 时, 即我们<br>想在万一 obj 为 null 立即报告 NullPointException 异常, 立即修改, 而不是隐藏空指针异常时, 我们就应<br>该果断的用 Optional.of(obj) 来构造 Optional 实例, 而不让任何不可预计的 null 值有可乘之机隐身于<br>Optional 中.<br>现在才开始怎么去使用一个已有的 Optional 实例, 假定我们有一个实例 Optional user, 下面是几个普遍<br>的, 应避免 if(user.isPresent()) { … } else { … } 几中应用方式.<br>存在即返回, 无则提供默认值<br>return user.orElse(null); //而不是 return user.isPresent() ? user.get() : null;<br>return user.orElse(UNKNOWN_USER);<br>存在即返回, 无则由函数来产生<br>存在才对它做点什么<br>user.ifPresent(System.out::println);<br>//而不要下边那样<br>if (user.isPresent()) {<br>System.out.println(user.get());<br>}<br>map函数的使用<br>return user.orElseGet(() -&gt; fetchAUserFromDatabase()); //而不要 return user.isPresent() ?<br>generated by haroopad<br>2018/3/31 Optional.html<br>file:///E:/%E5%B7%A5%E4%BD%9C/%E5%9F%B9%E8%AE%AD%E4%B8%8E%E5%88%86%E4%BA%AB/java/Optional.html 4/5<br>当 user.isPresent() 为真, 获得它关联的 orders, 为假则返回一个空集合时, 我们用上面的 orElse,<br>orElseGet 方法都乏力时, map函数就可以出马了， 我们可以这样一行：<br>return user.map(u -&gt; u.getOrders()).orElse(Collections.emptyList())<br>而java 8之前的写法：<br>if(user.isPresent()) {<br>return user.get().getOrders();<br>} else {<br>return Collections.emptyList();<br>}<br>而且map是可以级联的，在深一层：<br>return user.map(u -&gt; u.getUsername())<br>.map(name -&gt; name.toUpperCase())<br>.orElse(null);<br>这要是放到以前我们得这么写：<br>User user = …..<br>if(user != null) {<br>String name = user.getUsername();<br>if(name != null) {<br>return name.toUpperCase();<br>} else {<br>return null;<br>}<br>} else {<br>return null;<br>}<br>用了 isPresent() 处理 NullPointerException 不叫优雅, 有了 orElse, orElseGet 等, 特别是 map 方法才<br>叫优雅.<br>filter的使用<br>//filter方法检查给定的Option值是否满足某些条件。<br>//如果满足则返回同一个Option实例，否则返回空Optional。<br>Optional<String> longName = name.filter((value) -&gt; value.length() &gt; 6);<br>System.out.println(longName.orElse(“The name is less than 6 characters”));//输出Sanaulla<br>//另一个例子是Optional值不满足filter指定的条件。<br>Optional<String> anotherName = Optional.of(“Sana”);<br>Optional<String> shortName = anotherName.filter((value) -&gt; value.length() &gt; 6);<br>generated by haroopad<br>2018/3/31 Optional.html<br>file:///E:/%E5%B7%A5%E4%BD%9C/%E5%9F%B9%E8%AE%AD%E4%B8%8E%E5%88%86%E4%BA%AB/java/Optional.html 5/5<br>//输出：name长度不足6字符<br>System.out.println(shortName.orElse(“The name is less than 6 characters”));<br>orElseThrow的使用<br>return user.orElseThrow(()-&gt;new NullPointE</li></ul>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——java8新特性之Stream</title>
    <link href="/2021/12/01/java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/"/>
    <url>/2021/12/01/java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/</url>
    
    <content type="html"><![CDATA[<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p><strong>A sequence of elements supporting sequential and parallel aggregate operations .</strong></p><ol><li>Stream 是元素的集合，这点让 Stream 看起来用些类似 Iterator；</li><li>可以支持顺序和并行的对原Stream进行汇聚的操作；</li></ol><blockquote><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulkdata operation)。</p></blockquote><p>Stream API 借助于 Lambda 表达式，极大的提高编程效率和程序可读性。同时提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势（使用 fork/join框架，fork 递归式地分解问题，然后每段并行执行，最终由 join 合并结果，返回最后的值）。</p><p>[例] 统计列表中不为 null 的元素个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; nums = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">6</span>);<br><br><span class="hljs-comment">//原始版本</span><br><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (Integer item : nums) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != item) &#123;<br>        count++;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Stream 版本</span><br><span class="hljs-keyword">long</span> count1 = nums.stream().filter(Objects::nonNull).count();<br></code></pre></td></tr></table></figure><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h3><p><img src="https://user-images.githubusercontent.com/45761474/144250337-a744591a-f7ef-4877-8876-c01a7ede3661.jpg" alt="Stream表达式"></p><p>一条语句分为三部分：</p><ol><li>红色框中的语句是一个 Stream 的生命开始的地方，负责创建一个Stream实例；</li><li>绿色框中的语句是赋予 Stream 灵魂的地方，把一个 Stream 转换成另外一个 Stream；</li><li>蓝色框中的语句是汇聚的地方，把 Stream 里面包含的内容按照某种算法来汇聚成一个值。</li></ol><blockquote><p>使用Stream的基本步骤：</p><ol><li>创建Stream；</li><li>转换Stream，每次转换原有Stream对象不改变，返回一个新的Stream对象（可以有多次转换）；</li><li>对Stream进行聚合（Reduce）操作，获取想要的结果</li></ol></blockquote><h3 id="3-创建-Stream"><a href="#3-创建-Stream" class="headerlink" title="3. 创建 Stream"></a>3. 创建 Stream</h3><p>常见创建 Stream 的方式有三种：</p><ul><li>通过 Stream 接口的静态工厂方法</li><li>通过 Collection 接口的默认方法 stream() 把一个 Collection 对象转换为 Stream</li><li>通过数组，Arrays.stream(T array)</li></ul><ol><li><p>of 方法：有两个 overload 方法，一个接受变长参数，一个接口单一值；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>Stream&lt;String&gt; stringStream = Stream.of(<span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>generator 方法<br>生成一个无限长度的 Stream ，其元素生成时通过给定的 Supplier 接口提供</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.generate(<span class="hljs-keyword">new</span> Supplier&lt;Double&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Math.random();<br>    &#125;<br>&#125;);<br>Stream.generate(()-&gt;Math.random());<br><br>Stream.generate(Math::random);<br></code></pre></td></tr></table></figure><p>生成一个无限长度的Stream，其中值是随机的。这个无限长度Stream是懒加载。</p><ol start="3"><li>iterate 方法：</li></ol><p>也是生成无限长度的 Stream，和 generator 不同的是，其元素的生成是重复对给定的种子值(seed)调用用户指定函数来生成的。其中包含的元素可以认为是：seed，f(seed),f(f(seed))无限循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先获取一个无限长度的正整数集合的Stream，然后取出前10个打印。</span><br>      Stream.iterate(<span class="hljs-number">1</span>, item -&gt; item * <span class="hljs-number">2</span>).limit(<span class="hljs-number">10</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><ol start="4"><li>通过 Collection 子类获取 Stream<br>Collection接口有一个stream方法，所以其所有子类都都可以获取对应的Stream对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integerList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">3</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>integerList.stream();<br>Set&lt;Integer&gt; integerSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>integerSet.stream();<br>Map&lt;String, String&gt; stringMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>stringMap.entrySet().stream();<br>stringMap.keySet().stream();<br>stringMap.values().stream();<br></code></pre></td></tr></table></figure></li><li>Arrays.stream(T array)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.stream(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);<br></code></pre></td></tr></table></figure><h3 id="4-转换Stream"><a href="#4-转换Stream" class="headerlink" title="4. 转换Stream"></a>4. 转换Stream</h3><p>转换Stream就是把一个 Stream 通过某些行为转换成一个新的 Stream。</p><p>Stream 接口中几个常用的转换方法:</p><ul><li>disinct</li><li>filter</li><li>map</li><li>flatmap</li><li>peek</li><li>limit</li><li>skip</li></ul><h4 id="4-1-distinct"><a href="#4-1-distinct" class="headerlink" title="4.1 distinct"></a>4.1 distinct</h4><p>对于 Stream 中包含的元素进行去重操作(依赖于元素的 equals 方法)，新生成的Stream 中没有重复的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>    list.stream().distinct().forEach(item -&gt; System.out.print(item+ <span class="hljs-string">&quot;  &quot;</span>));<br>    <span class="hljs-comment">// 1  null  2  3  4  5  6  7  8  9 </span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-filter"><a href="#4-2-filter" class="headerlink" title="4.2 filter"></a>4.2 filter</h4><p>对于 Stream 中包含的元素使用给定的过滤函数进行过滤，新生成的 Stream 只包含符合条件的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>list.stream().distinct().filter(Objects::nonNull).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br><span class="hljs-comment">// 1  2  3  4  5  6  7  8  9  </span><br></code></pre></td></tr></table></figure><h4 id="4-3-map"><a href="#4-3-map" class="headerlink" title="4.3 map"></a>4.3 map</h4><p>对于 Stream 中包含的元素使用给定的转换函数进行转换操作，新生成的 Stream 只包含转换生成的元素。这个方法有三个对于原始类型的变种方法，分别是：mapToInt，mapToLong 和 mapToDouble。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>list.stream().distinct().filter(Objects::nonNull).map(i -&gt; i * <span class="hljs-number">2</span>).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br><span class="hljs-comment">// 2  4  6  8  10  12  14  16  18 </span><br><br>DoubleStream stream = DoubleStream.of(<span class="hljs-number">23.0</span>, <span class="hljs-number">25.4</span>, <span class="hljs-number">32.5</span>, <span class="hljs-number">45.9</span>);<br>stream.mapToInt(item -&gt; (<span class="hljs-keyword">int</span>) item).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br><span class="hljs-comment">// 23  25  32  45          </span><br></code></pre></td></tr></table></figure><h4 id="4-4-flatMap"><a href="#4-4-flatMap" class="headerlink" title="4.4 flatMap"></a>4.4 flatMap</h4><p>和map类似，不同的是其每个元素转换得到的是Stream对象，会把子Stream中的元素压缩到父集合中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; teamIndia = Arrays.asList(<span class="hljs-string">&quot;Virat&quot;</span>, <span class="hljs-string">&quot;Dhoni&quot;</span>, <span class="hljs-string">&quot;Jadeja&quot;</span>);<br>List&lt;String&gt; teamAustralia = Arrays.asList(<span class="hljs-string">&quot;Warner&quot;</span>, <span class="hljs-string">&quot;Watson&quot;</span>, <span class="hljs-string">&quot;Smith&quot;</span>);<br>List&lt;List&lt;String&gt;&gt; players = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>players.add(teamIndia);<br>players.add(teamAustralia);<br>players.stream().flatMap(Collection::stream).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br></code></pre></td></tr></table></figure><h4 id="4-5-peek"><a href="#4-5-peek" class="headerlink" title="4.5. peek"></a>4.5. peek</h4><p>生成一个包含原 Stream 的所有元素的新 Stream，同时会提供一个消费函数（Consumer实例），新 Stream 每个元素被消费的时候都会执行给定的消费函数；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>System.out.println(<span class="hljs-string">&quot;\n&quot;</span>+integers.stream().peek(System.out::print).count());<br><span class="hljs-comment">//16789</span><br><span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><h4 id="4-6-limit"><a href="#4-6-limit" class="headerlink" title="4.6 limit"></a>4.6 limit</h4><p>对一个 Stream 进行截断操作，获取其前N个元素，如果原 Stream 中包含的元素个数小于N，则获取其所有的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>integers.stream().limit(<span class="hljs-number">3</span>).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;   &quot;</span>));<br><span class="hljs-comment">// 1   6   7</span><br></code></pre></td></tr></table></figure><h4 id="4-7-skip"><a href="#4-7-skip" class="headerlink" title="4.7 skip"></a>4.7 skip</h4><p>返回一个丢弃原 Stream 的前 N 个元素后剩下元素组成的新 Stream，如果原Stream中包含的元素个数小于N，那么返回空 Stream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>integers.stream().skip(<span class="hljs-number">2</span>).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;   &quot;</span>));<br><span class="hljs-comment">// 7   8   9  </span><br></code></pre></td></tr></table></figure><p>  <strong>转换操作都是 lazy 的，多个转换操作只会在汇聚操作的时候融合起来，一次循环完成。可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在汇聚操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</strong></p><h3 id="5-汇聚（reduce）Stream"><a href="#5-汇聚（reduce）Stream" class="headerlink" title="5. 汇聚（reduce）Stream"></a>5. 汇聚（reduce）Stream</h3><p>Reduce 操作接受一个元素序列为输入，反复使用某个合并操作，把序列中的元素合并成一个汇总的结果。</p><p>比如查找一个数字列表的总和或者最大值，或者把这些数字累积成一个List对象。</p><p>Stream接口通用的汇聚操作</p><ul><li>reduce()</li><li>collect()</li><li>count() </li><li>sum()</li><li>allMatch：判断是否是全部的元素都满足给定匹配条件</li><li>noneMatch：判断是否是全部的元素都不满足给定匹配条件</li><li>anyMatch：判断是否至少有一个元素满足给定匹配条件</li><li>findFirst：返回第一个元素</li><li>max()：使用比较器（Operator），返回 Stream 中最大的元素</li></ul><p>注意：sum 方法不是所有的 Stream 对象都有的，只有 IntStream、LongStream 和 DoubleStream是实例才有。</p><h4 id="5-1-collect"><a href="#5-1-collect" class="headerlink" title="5.1  collect"></a>5.1  collect</h4><p>把输入的元素累积到一个可变的容器中，比如 Collection 或者 StringBuilder。<br>可变汇聚对应的方法只有一个：collect，它的作用就是把Stream中的所有元素收集到一个结果容器中。</p><p><strong>方法定义1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R&gt; <span class="hljs-function">R <span class="hljs-title">collect</span><span class="hljs-params">(Supplier&lt;R&gt; supplier,</span></span><br><span class="hljs-params"><span class="hljs-function">              BiConsumer&lt;R, ? <span class="hljs-keyword">super</span> T&gt; accumulator,</span></span><br><span class="hljs-params"><span class="hljs-function">              BiConsumer&lt;R, R&gt; combiner)</span></span><br></code></pre></td></tr></table></figure><p>方法参数：</p><ul><li>Supplier<R> supplier：工厂函数，用来生成一个新的容器。</li><li>BiConsumer&lt;R, ? super T&gt; accumulator：用来把 Stream 中的元素添加到结果容器</li><li>BiConsumer&lt;R, R&gt; combiner：用来把中间状态的多个结果容器合并成一个（并发时）</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>ArrayList&lt;Integer&gt; collect = integers.stream().filter(Objects::nonNull)<br>        .collect(ArrayList::<span class="hljs-keyword">new</span>, ArrayList::add, ArrayList::addAll);<br>System.out.println(collect.toString());<br><span class="hljs-comment">// [1, 6, 7, 8, 9]</span><br></code></pre></td></tr></table></figure><p><strong>方法定义2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R, A&gt; <span class="hljs-function">R <span class="hljs-title">collect</span><span class="hljs-params">(Collector&lt;? <span class="hljs-keyword">super</span> T, A, R&gt; collector)</span></span>;<br></code></pre></td></tr></table></figure><p>Collectors 已经定义了一些静态工厂方法：</p><ul><li>Collectors.toCollection() 收集到 Collection 中</li><li>Collectors.toList() 收集到 List 中</li><li>Collectors.toSet() 收集到 Set 中</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>List&lt;Integer&gt; collect = integers.stream().filter(Objects::nonNull)<br>        .collect(Collectors.toList());<br>System.out.println(collect.toString());<br><span class="hljs-comment">// [1, 6, 7, 8, 9]</span><br></code></pre></td></tr></table></figure><h4 id="5-2-reduce"><a href="#5-2-reduce" class="headerlink" title="5.2 reduce"></a>5.2 reduce</h4><p><strong>方法定义1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">reduce</span><span class="hljs-params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;<br></code></pre></td></tr></table></figure><p>接受一个 BinaryOperator 类型的参数，BinaryOperator 函数有两个参数</p><ul><li>第一个参数是上次函数执行的返回值（中间结果）</li><li>第二个参数是 Stream 中的元素</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>Integer integer = integers.stream().filter(Objects::nonNull).<br>        reduce((sum, item) -&gt; sum + item).get();<br>System.out.println(integer);<br><span class="hljs-comment">// 31</span><br></code></pre></td></tr></table></figure><p><strong>方法定义2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">T <span class="hljs-title">reduce</span><span class="hljs-params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;<br></code></pre></td></tr></table></figure><p>和上面的类似，不同的是允许提供一个初始值，如果 Stream 为空，则直接返回初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>Integer integer = integers.stream().filter(Objects::nonNull).<br>        reduce(<span class="hljs-number">100</span>,(sum, item) -&gt; sum + item);<br>System.out.println(integer);<br><span class="hljs-comment">// 131</span><br></code></pre></td></tr></table></figure><p><strong>方法定义3</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;U&gt; <span class="hljs-function">U <span class="hljs-title">reduce</span><span class="hljs-params">(U identity,</span></span><br><span class="hljs-params"><span class="hljs-function">             BiFunction&lt;U, ? <span class="hljs-keyword">super</span> T, U&gt; accumulator,</span></span><br><span class="hljs-params"><span class="hljs-function">             BinaryOperator&lt;U&gt; combiner)</span></span>;<br></code></pre></td></tr></table></figure><p>功能和上面的类似，不同的是允许用户提供一个 combiner 函数用来处理并发场景下的数据汇总。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>Integer integer = integers.parallelStream().filter(Objects::nonNull).<br>        reduce(<span class="hljs-number">0</span>, (sum, item) -&gt; sum + item, (result, fragment) -&gt; result + fragment);<br>System.out.println(integer);<br><span class="hljs-comment">// 31</span><br></code></pre></td></tr></table></figure><h4 id="5-3-count-方法"><a href="#5-3-count-方法" class="headerlink" title="5.3 count 方法"></a>5.3 count 方法</h4><p>统计 Stream 中的元素的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><span class="hljs-keyword">long</span> count = integers.parallelStream().filter(Objects::nonNull).count();<br>System.out.println(count);<br><span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><h3 id="6-Collectors"><a href="#6-Collectors" class="headerlink" title="6. Collectors"></a>6. Collectors</h3><p>Collector接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><br></code></pre></td></tr></table></figure><p>//T 元素， A 容器类型， R 结果类型public interface Collector&lt;T, A, R&gt; {// supplier参数用于生成结果容器，容器类型为ASupplier<A> supplier();// accumulator用于消费元素，也就是归纳元素，这里的T就是元素，它会将流中的元素一个一个与结果容器A发生操作BiConsumer&lt;A, T&gt; accumulator();// combiner用于两个两个合并并行执行的线程的执行结果，将其合并为一个最终结果ABinaryOperator<A> combiner();// finisher用于将之前整合完的结果R转换成为AFunction&lt;A, R&gt; finisher();// characteristics表示当前Collector的特征值，这是个不可变SetSet<Characteristics> characteristics();}Collectors是一个工具类，是JDK预实现Collector的工具类，它内部提供了多种CollectorCollectors 除了提供了上文介绍过的收集方法外还提供了一组非常有用方法：joining连接收集的结果Collector&lt;CharSequence, ?, String&gt; joining()List<Integer> ints = Lists.newArrayList(1, 2, 3, 4, 5, 6, 7, 8, 9)System.out.println(“” + ints.stream().map(String::valueOf).collect(Collectors.joining()));// 123456789以序列顺序进行join，没有分隔Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter)参数为分隔符举例：指定间隔符’-‘, 对序列进行joinList<Integer> ints = Lists.newArrayList(1, 2, 3, 4, 5, 6, 7, 8, 9)System.out.println(“” + ints.stream().map(String::valueOf).collect(Collectors.joining(“-“)));// 1-2-3-4-5-6-7-8-9Collector&lt;CharSequence, ?, String&gt; joining(CharSequence delimiter,CharSequence prefix, CharSequence suffix)参数为：间隔符，前缀和后缀举例：指定间隔符’-‘，前缀’$’和后缀’#’ 对序列连接List<Integer> ints = Lists.newArrayList(1, 2, 3, 4, 5, 6, 7, 8, 9)System.out.println(“” + ints.stream().map(String::valueOf).collect(Collectors.joining(“-“,”$”,”#”)));// $1-2-3-4-5-6-7-8-9#collectingAndThen&lt;T,A,R,RR&gt; Collector&lt;T,A,RR&gt; collectingAndThen(Collector&lt;T,A,R&gt; downstream, Function&lt;R,RR&gt; finisher是对汇聚后的结果进行再操作, 操作通过第二个参数 Function 函数提供举例，收集后逆序排列List<Integer> ints = Lists.newArrayList(1, 2, 3, 4, 5, 6, 7, 8, 9);System.out.println(“” + ints.stream().map(String::valueOf).collect(Collectors.collectingAndThen(Collectors.toList(), Lists::reverse)));// [9, 8, 7, 6, 5, 4, 3, 2, 1]groupingBy这个方法是用于生成一个拥有分组功能的Collector，它也有三个重载方法// 只需一个分组参数classifier，内部自动将结果保存到一个map中，// 每个map的键为?类型（即classifier的结果类型），值为一个list，// 这个list中保存在属于这个组的元素。&lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List<T>&gt;&gt; groupingBy(Function&lt;? super T, ? extends K&gt; classifier)// 在上面方法的基础上增加了对流中元素的处理方式的Collecto</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——函数式编程</title>
    <link href="/2021/11/30/java%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/11/30/java%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1-重新认识接口"><a href="#1-重新认识接口" class="headerlink" title="1. 重新认识接口"></a>1. 重新认识接口</h3><h4 id="1-1-java8之前"><a href="#1-1-java8之前" class="headerlink" title="1.1 java8之前"></a>1.1 java8之前</h4><p>接口的作用：定义该类型实例具有的功能，不关心如何进行这些工作。所以，接口定义中只有抽象方法（public abstract）和常量（public static final），并且接口中不允许定义实例变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInterface</span> </span>&#123;<br>    Integer age = <span class="hljs-number">18</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-java8之后"><a href="#1-2-java8之后" class="headerlink" title="1.2 java8之后"></a>1.2 java8之后</h4><p>从JKD8开始，接口可以加入静态方法和默认方法<br>默认方法允许接口方法定义默认实现，而所有子类都继承该方法及实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInterface</span> </span>&#123;<br>    Integer age = <span class="hljs-number">18</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printHello</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getString</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>默认方法的优势</strong></p><ol><li>默认方法的主要优势是提供一种拓展接口的方法，而不破坏现有代码。增加新的方法，并且能保证对使用这个接口的老版本代码的兼容性。<br>在JDK8以前，如果为一个现有接口增加一个新方法，则我们必须在所有实现类中添加该方法的实现，否则编译会出现异常。<br>如果实现类比较多或者我们没有权限修改实现类源代码，这样可能就比较麻烦。<br>默认方法则解决了这个问题，它提供了一个实现，当没有显式提供其他实现时就采用这个实现，这样新添加的方法将不会破坏现有代码。</li><li>另一个优势是该方法是可选，子类可以根据不同的需求Override默认实现。<br>例如，我们定义一个集合接口，其中有增、删、改等操作。如果实现类90%都是以数组保存数据，那么可以定义针对这些方法给出默认实现，而对于其他非数组集合或者有其他类似业务，可以选择性复写接口中默认方法。</li></ol><h3 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2.函数式接口"></a>2.函数式接口</h3><p><strong>定义：</strong></p><blockquote><p>如果一个接口定义唯一一个抽象方法，那么这个接口就成为函数式接口。</p></blockquote><p>java.lang.Runnable 就是一个函数式接口，因为它只有一个抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认方法不是abstract的，所以一个函数式接口里可以定义任意多的默认方法。<br>为了标明函数式接口Java8引入了一个新的注解： @FunctionalInterface</p><p><strong>函数接口特性</strong></p><ul><li>@FunctionInterface 注解只能标记在有且仅有一个抽象方法的接口上；</li><li>Java8接口中的静态方法和默认方法，都不算是抽象方法；</li><li>接口默认继承 java.lang.Object ,所以如果接口声明覆盖了Object中的方法，那么也不算抽象方法；</li><li>注解不是必须的，如果接口符合函数式接口的定义，那么不加注解也没有影响。加上则编译器可以进行检查。如果不是函数接口而加上了注解，则编译器会报错。</li></ul><h3 id="3-函数式编程"><a href="#3-函数式编程" class="headerlink" title="3.  函数式编程"></a>3.  函数式编程</h3><p>函数编程特性：</p><p><strong>a. 闭包与高阶函数</strong><br>函数编程支持函数作为第一类对象，有时称为 闭包或者 仿函数（functor）对象。实质上，闭包是起函数的作用并可以像对象一样操作的对象。高阶函数可以用另一个函数作为其输入参数，也可以返回一个函数作为其输出参数。</p><p><strong>b. 惰性计算</strong><br>在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算。延迟的计算可以编写可能潜在地生成无穷输出的函数。因为不会计算多于程序的其余部分所需要的值，所以不需要担心由无穷计算所导致的 out-of-memory 错误。</p><p><strong>c. 没有“副作用”</strong><br>所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p><blockquote><p>综上所述，函数式编程可以简言之是： 使用不可变值和函数， 通过函数对一个值进行处理， 映射成另一个值。这个值在面向对象语言中可以理解为对象，另外这个值还可以作为函数的输入。</p></blockquote><p>Java8 中的函数式编程</p><ul><li>内建的函数式接口</li><li>Optional API</li><li>Lambda表达式</li><li>Stream API</li></ul><h4 id="3-1-内建的函数式接口"><a href="#3-1-内建的函数式接口" class="headerlink" title="3.1 内建的函数式接口"></a>3.1 内建的函数式接口</h4><p>Java8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。</p><table><thead><tr><th align="center">name</th><th align="center">type</th><th align="center">description</th></tr></thead><tbody><tr><td align="center">Consumer(消费者)</td><td align="center">Consumer<T></td><td align="center">接收 T 对象，不返回值</td></tr><tr><td align="center">Predicate(谓词)</td><td align="center">Predicate<T></td><td align="center">接收 T 对象并返回boolean</td></tr><tr><td align="center">Function(函数)</td><td align="center">Function&lt;T,R&gt;</td><td align="center">接收 T 对象，返回 R 对象</td></tr><tr><td align="center">Supplier(提供者)</td><td align="center">Supplier<T></td><td align="center">提供T对象，不接收值</td></tr><tr><td align="center">UnaryOperator(一元运算符)</td><td align="center">UnaryOperator<T></td><td align="center">接收T对象，返回T对象</td></tr><tr><td align="center">BinaryOperator(二元操作)</td><td align="center">BinaryOperator<T></td><td align="center">接收两个T对象，返回T对象</td></tr></tbody></table><blockquote><p>以上四种为基本的函数接口，在此之上JDK又提供了若干扩展：</p><ol><li>以上前三种添加了Bi的前缀：BiConsumer,BiPredicate,BiFunction,入参变为两个；</li><li>对Function的扩展产生了UnaryOperator(一元运算符)，接收T返回T；</li><li>对BiFunction的扩展产生了BinaryOperator(二元操作)，收两个T对象，返回T对象</li><li>增加了若干具体基本类型的接口，可参见function包下具体接口说明。</li></ol></blockquote><h4 id="3-2-Optional-API"><a href="#3-2-Optional-API" class="headerlink" title="3.2 Optional API"></a>3.2 Optional API</h4><p>Java8中引入的 Optional 是一种优雅解决NPE(NullPointExcepiton)问题的方法，是通过函数式接口实现的。</p><p>Optional 提供的方法：</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">public<U> Optional<U> map(Function&lt;? super T, ? extends U&gt; mapper)</td><td align="center">如果当前 Optional 为 Optional.empty，则依旧返回 Optional.empty；否则返回一个新的 Optional，该 Optional 包含的是：函数 mapper 在以 value 作为输入时的输出值。</td></tr><tr><td align="center">public T orElse(T other)</td><td align="center">如果有值则将其返回，否则返回一个默认值</td></tr><tr><td align="center">public T orElseGet(Supplier&lt;? extends T&gt; other)</td><td align="center">如果有值则将其返回，否则返回一个由指定的Supplier接口生成的值</td></tr></tbody></table><p>如果当前 Optional 为 Optional.empty，则依旧返回 Optional.empty；否则返回一个新的 Optional，该 Optional 包含的是：函数 mapper 在以 value 作为输入时的输出值。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git——rebase命令</title>
    <link href="/2021/11/29/Git%E2%80%94%E2%80%94rebase%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/11/29/Git%E2%80%94%E2%80%94rebase%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h3><ul><li>合并多次提交记录</li><li>分支合并</li><li>对一个分支做『变基』操作</li></ul><h3 id="2-合并多次提交记录"><a href="#2-合并多次提交记录" class="headerlink" title="2. 合并多次提交记录"></a>2. 合并多次提交记录</h3><p>合并最近两次commit:</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> rebase -i HEAD~<span class="hljs-number">2</span><br></code></pre></td></tr></table></figure><p>执行命令后会自动进入 vi 编辑模式：</p><figure class="highlight plaintext"><figcaption><span>6935383 rename冲突</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs pick">pick 23b1a51 debug<br><br># Rebase eb7f366..23b1a51 onto eb7f366 (2 commands)<br>#<br># Commands:<br># p, pick &lt;commit&gt; = use commit<br># r, reword &lt;commit&gt; = use commit, but edit the commit message<br># e, edit &lt;commit&gt; = use commit, but stop for amending<br># s, squash &lt;commit&gt; = use commit, but meld into previous commit<br># f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&#x27;s log message<br># x, exec &lt;command&gt; = run command (the rest of the line) using shell<br># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)<br># d, drop &lt;commit&gt; = remove commit<br># l, label &lt;label&gt; = label current HEAD with a name<br># t, reset &lt;label&gt; = reset HEAD to a label<br># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]<br># .       create a merge commit using the original merge commit&#x27;s<br># .       message (or the oneline, if no original merge commit was<br># .       specified). Use -c &lt;commit&gt; to reword the commit message.<br>#<br># These lines can be re-ordered; they are executed from top to bottom.<br>#<br># If you remove a line here THAT COMMIT WILL BE LOST.<br>#<br># However, if you remove everything, the rebase will be aborted.<br></code></pre></td></tr></table></figure><blockquote><p>【注】<br>p, pick = use commit<br>r, reword = use commit, but edit the commit message<br>e, edit = use commit, but stop for amending<br>s, squash = use commit, but meld into previous commit<br>f, fixup = like “squash”, but discard this commit’s log message<br>x, exec = run command (the rest of the line) using shell<br>d, drop = remove commit</p></blockquote><p>修改提交纪录并保存退出。</p><figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs apache"><span class="hljs-attribute">pick</span> <span class="hljs-number">6935383</span> rename冲突<br><span class="hljs-attribute">s</span> <span class="hljs-number">23</span>b<span class="hljs-number">1</span>a<span class="hljs-number">51</span> debug<br></code></pre></td></tr></table></figure><p>保存后到注释修改界面。</p><figure class="highlight vala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs vala"><span class="hljs-meta"># This is a combination of 2 commits.</span><br><span class="hljs-meta"># This is the 1st commit message:</span><br><br>rename冲突<br><br><span class="hljs-meta"># This is the commit message #2:</span><br><br>debug<br><br><span class="hljs-meta"># Please enter the commit message for your changes. Lines starting</span><br><span class="hljs-meta"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># Date:      Tue Nov 24 22:56:02 2020 +0800</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># interactive rebase in progress; onto eb7f366</span><br><span class="hljs-meta"># Last commands done (2 commands done):</span><br><span class="hljs-meta">#    pick 6935383 rename冲突</span><br><span class="hljs-meta">#    squash 23b1a51 debug</span><br><span class="hljs-meta"># No commands remaining.</span><br><span class="hljs-meta"># You are currently rebasing branch &#x27;maseter&#x27; on &#x27;eb7f366&#x27;.</span><br></code></pre></td></tr></table></figure><p>（非编辑状态输入dd删除一行）</p><p>保存后即合并完成。</p><blockquote><p>异常情况：<br>1、不要合并已提交远程分支的纪录<br>如果这样做，可能出现push rejected。 解决方式当然是先拉下远程的代码，进行冲突处理，再进行提交。<br>2、git rebase -i 异常操作导致退出了vim编辑页面，会提示：</p><figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs applescript">$ git rebase -i head~<span class="hljs-number">2</span><br><span class="hljs-keyword">error</span>: could <span class="hljs-keyword">not</span> apply <span class="hljs-number">040</span>bd4b... commit <span class="hljs-keyword">on</span> issue<span class="hljs-number">-005</span><br>Resolve all conflicts manually, mark them <span class="hljs-keyword">as</span> resolved <span class="hljs-keyword">with</span><br><span class="hljs-string">&quot;git add/rm &lt;conflicted_files&gt;&quot;</span>, <span class="hljs-keyword">then</span> <span class="hljs-built_in">run</span> <span class="hljs-string">&quot;git rebase --continue&quot;</span>.<br>You can instead skip this commit: <span class="hljs-built_in">run</span> <span class="hljs-string">&quot;git rebase --skip&quot;</span>.<br>To abort <span class="hljs-keyword">and</span> <span class="hljs-keyword">get</span> <span class="hljs-keyword">back</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span> state <span class="hljs-keyword">before</span> <span class="hljs-string">&quot;git rebase&quot;</span>, <span class="hljs-built_in">run</span> <span class="hljs-string">&quot;git rebase --abort&quot;</span>.<br>Could <span class="hljs-keyword">not</span> apply <span class="hljs-number">040</span>bd4b... commit <span class="hljs-keyword">on</span> issue<span class="hljs-number">-005</span><br>Auto-merging README.md<br>CONFLICT (content): Merge conflict <span class="hljs-keyword">in</span> README.md<br></code></pre></td></tr></table></figure><p>使用 git rebase –edit-todo 会再次进入刚才编辑错误退出前的vim状态，这时候可以修改你的编辑。<br>使用git rebase –abort  表明退出当前的合并请求( 又回到原来的2个commit的状态)</p></blockquote><h3 id="3-变基"><a href="#3-变基" class="headerlink" title="3. 变基"></a>3. 变基</h3><p>使用场景：本地与远端同一分支提交历史不一致</p><p>多个人在同一个分支上协作时，比如由我和A一同开发。我在修复了一个bug以后准备提交。</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs vim">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">add</span> .<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git commit -<span class="hljs-keyword">m</span> <span class="hljs-string">&quot;debug the world&quot;</span><br>[master a40d43c] <span class="hljs-keyword">debug</span> the world<br> <span class="hljs-number">1</span> <span class="hljs-keyword">file</span> changed, <span class="hljs-number">0</span> insertions(+), <span class="hljs-number">0</span> deletions(-)<br> create <span class="hljs-keyword">mode</span> <span class="hljs-number">100644</span> aa.txt<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git push origin master<br>To github.<span class="hljs-keyword">com</span>:Zhangtao153/learngit.git<br> ! [rejected]        master -&gt; master (non-fast-forward)<br>error: failed <span class="hljs-keyword">to</span> push some refs <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;github.com:Zhangtao153/learngit.git&#x27;</span><br>hin<span class="hljs-variable">t:</span> Updates were rejected because the tip of your current branch <span class="hljs-keyword">is</span> behind<br>hin<span class="hljs-variable">t:</span> its remote counterpart. Integrate the remote <span class="hljs-keyword">changes</span> (<span class="hljs-keyword">e</span>.g.<br>hin<span class="hljs-variable">t:</span> <span class="hljs-string">&#x27;git pull ...&#x27;</span>) before pushing again.<br>hin<span class="hljs-variable">t:</span> See the <span class="hljs-string">&#x27;Note about fast-forwards&#x27;</span> in <span class="hljs-string">&#x27;git push --help&#x27;</span> <span class="hljs-keyword">for</span> details.<br></code></pre></td></tr></table></figure><p>push失败了，说明A在我之前已经提交了，我本地master分支的提交历史已经落后远端了，需要先pull一下，与远端同步后才能push</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git pull<br>Merge made <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> README.md | <span class="hljs-number">3</span> ++-<br> <span class="hljs-number">1</span> <span class="hljs-built_in">file</span> changed, <span class="hljs-number">2</span> insertions(+), <span class="hljs-number">1</span> deletion(-)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--oneline --graph</span><br>*   <span class="hljs-number">912</span>bb85 (HEAD -&gt; master) Merge branch <span class="hljs-string">&#x27;master&#x27;</span> <span class="hljs-keyword">of</span> github.com:Zhangtao153/learngit <span class="hljs-keyword">into</span> master<br>|\<br>| * <span class="hljs-number">7</span>ad4fd6 (origin/master) <span class="hljs-built_in">add</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span><br>* | a40d43c debug <span class="hljs-keyword">the</span> world<br>|/<br>* a8d2e0d 手动删除<br>* <span class="hljs-number">1</span>d243ca <span class="hljs-built_in">add</span> test <span class="hljs-built_in">file</span><br>* <span class="hljs-number">8438389</span> wrote <span class="hljs-keyword">a</span> readme <span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure><p>竟然分叉了！由于我本地master的提交历史和远端的master分支的提交历史不一致，所以git为我进行了自动合并，然后生成了一个新的提交历史。</p><p>这个时候就可以用 git rebase 解决分叉的问题。</p><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git rebase<br>Successfully rebased <span class="hljs-keyword">and</span> updated refs/heads/master.<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br><span class="hljs-symbol">$</span> git <span class="hljs-built_in">log</span> --oneline --graph<br><span class="hljs-comment">* 4178b6e (HEAD -&gt; master) debug the world</span><br><span class="hljs-comment">* 7ad4fd6 (origin/master) add a new function</span><br><span class="hljs-comment">* a8d2e0d 手动删除</span><br><span class="hljs-comment">* 1d243ca add test file</span><br><span class="hljs-comment">* 8438389 wrote a readme file</span><br></code></pre></td></tr></table></figure><p>然后再push，将本地修改同步到远端。</p><p>git pull –rebase 和上面的效果一致。</p><h3 id="4-合并分支"><a href="#4-合并分支" class="headerlink" title="4. 合并分支"></a>4. 合并分支</h3><p>先创建一个分支用于解决bug</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">$ git checkout -b issues<span class="hljs-number">-001</span><br>Switched <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> branch <span class="hljs-string">&#x27;issues-001&#x27;</span><br></code></pre></td></tr></table></figure><p>接下解决bug，然后保存提交</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (issues-<span class="hljs-number">001</span>)<br>$ git add .<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (issues-<span class="hljs-number">001</span>)<br>$ git commit -m <span class="hljs-string">&quot;issues-001&quot;</span><br>[issues-<span class="hljs-number">001</span> <span class="hljs-number">7</span>a55a26] issues-<span class="hljs-number">001</span><br> <span class="hljs-number">1</span> <span class="hljs-keyword">file</span> changed, <span class="hljs-number">1</span> insertion(+)<br></code></pre></td></tr></table></figure><p>先尝试通过 merge 合并：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issues<span class="hljs-number">-001</span>)<br>$ git <span class="hljs-keyword">switch</span> master<br>Switched <span class="hljs-built_in">to</span> branch <span class="hljs-string">&#x27;master&#x27;</span><br>Your branch is ahead <span class="hljs-keyword">of</span> <span class="hljs-string">&#x27;origin/master&#x27;</span> <span class="hljs-keyword">by</span> <span class="hljs-number">1</span> commit.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> <span class="hljs-built_in">to</span> publish your <span class="hljs-built_in">local</span> commits)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">merge</span> issues<span class="hljs-number">-001</span><br>Merge made <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> aa.txt | <span class="hljs-number">1</span> +<br> <span class="hljs-number">1</span> <span class="hljs-built_in">file</span> changed, <span class="hljs-number">1</span> insertion(+)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--oneline --graph</span><br>*   ae02ea0 (HEAD -&gt; master) Merge branch <span class="hljs-string">&#x27;issues-001&#x27;</span> <span class="hljs-keyword">into</span> master<br>|\<br>| * <span class="hljs-number">7</span>a55a26 (issues<span class="hljs-number">-001</span>) issues<span class="hljs-number">-001</span><br>* | d36d166 commit <span class="hljs-keyword">on</span> <span class="hljs-title">master</span><br>|/<br>* <span class="hljs-number">4178</span>b6e (origin/master) debug <span class="hljs-keyword">the</span> world<br>* <span class="hljs-number">7</span>ad4fd6 <span class="hljs-built_in">add</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span><br>* a8d2e0d 手动删除<br>* <span class="hljs-number">1</span>d243ca <span class="hljs-built_in">add</span> test <span class="hljs-built_in">file</span><br>* <span class="hljs-number">8438389</span> wrote <span class="hljs-keyword">a</span> readme <span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure><p>虽然合并成功，但是Master已经保存了合并历史，出现开叉了！</p><p>通过rebase合并分支</p><p>先将代码回退到merge之前</p><figure class="highlight pgsql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs pgsql">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^</span><br>HEAD <span class="hljs-keyword">is</span> now at d36d166 <span class="hljs-keyword">commit</span> <span class="hljs-keyword">on</span> master<br></code></pre></td></tr></table></figure><p>先切换回issues-001分支，在issues-001分支上执行: git rebase master</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs gradle">Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (master)<br>$ git <span class="hljs-keyword">switch</span> issues-<span class="hljs-number">001</span><br>Switched to branch <span class="hljs-string">&#x27;issues-001&#x27;</span><br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (issues-<span class="hljs-number">001</span>)<br>$ git rebase master<br>Successfully rebased and updated refs<span class="hljs-regexp">/heads/i</span>ssues-<span class="hljs-number">001</span>.<br></code></pre></td></tr></table></figure><p>【注】如果rebase出现冲突，先解决冲突，然后通过add添加，之前的rebase其实只是完成了一半，由于出现冲突而终止，冲突解决之后，可以通过git rebase —continue继续完成之前的rebase操作。</p><p>切换到主分支master，将issues-001分支上的提交合并过来。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs livecodeserver">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issues<span class="hljs-number">-001</span>)<br>$ git <span class="hljs-keyword">switch</span> master<br>Switched <span class="hljs-built_in">to</span> branch <span class="hljs-string">&#x27;master&#x27;</span><br>Your branch is ahead <span class="hljs-keyword">of</span> <span class="hljs-string">&#x27;origin/master&#x27;</span> <span class="hljs-keyword">by</span> <span class="hljs-number">1</span> commit.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> <span class="hljs-built_in">to</span> publish your <span class="hljs-built_in">local</span> commits)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">merge</span> issues<span class="hljs-number">-001</span><br>Updating d36d166.<span class="hljs-number">.43823</span>d4<br>Fast-forward<br> aa.txt | <span class="hljs-number">1</span> +<br> <span class="hljs-number">1</span> <span class="hljs-built_in">file</span> changed, <span class="hljs-number">1</span> insertion(+)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--oneline --graph</span><br>* <span class="hljs-number">43823</span>d4 (HEAD -&gt; master, issues<span class="hljs-number">-001</span>) issues<span class="hljs-number">-001</span><br>* d36d166 commit <span class="hljs-keyword">on</span> <span class="hljs-title">master</span><br>* <span class="hljs-number">4178</span>b6e (origin/master) debug <span class="hljs-keyword">the</span> world<br>* <span class="hljs-number">7</span>ad4fd6 <span class="hljs-built_in">add</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span><br>* a8d2e0d 手动删除<br>* <span class="hljs-number">1</span>d243ca <span class="hljs-built_in">add</span> test <span class="hljs-built_in">file</span><br>* <span class="hljs-number">8438389</span> wrote <span class="hljs-keyword">a</span> readme <span class="hljs-built_in">file</span><br></code></pre></td></tr></table></figure><p>master是一条直线了。最后删除掉issues-001分支。</p><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs awk">Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (master)<br>$ git branch -d issues-<span class="hljs-number">001</span><br>Deleted branch issues-<span class="hljs-number">001</span> (was <span class="hljs-number">43823</span>d4).<br></code></pre></td></tr></table></figure><p>​</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——java8新特性之Lambda 表达式</title>
    <link href="/2021/11/28/java%E2%80%94%E2%80%94jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/11/28/java%E2%80%94%E2%80%94jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>lambda 表达式本质上是一段匿名内部类，也可以是一段可以传递的代码</p><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h4><p>完整的 Lambda 表达式由三部分组成：参数列表、箭头、声明语句；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> (Type1 param1, Type2 param2, ..., TypeN paramN) ‐&gt; &#123; statment1;<br>statment2; <span class="hljs-comment">//............. return statmentM;&#125;</span><br></code></pre></td></tr></table></figure><ol><li>绝大多数情况，编译器都可以从上下文环境中推断出lambda表达式的参数类型，所以参数可以省略：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(param1,param2, ..., paramN) ‐&gt; &#123; statment1; statment2; <span class="hljs-comment">//............. r</span><br>eturn statmentM;&#125;<br></code></pre></td></tr></table></figure></li><li>当lambda表达式的参数个数只有一个，可以省略小括号：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">param1 ‐&gt; &#123; statment1; statment2; <span class="hljs-comment">//............. return statmentM;&#125;</span><br></code></pre></td></tr></table></figure></li><li>当lambda表达式只包含一条语句时，可以省略大括号、return和语句结尾的分号：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">param1 ‐&gt; statment<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-函数接口"><a href="#2-函数接口" class="headerlink" title="2. 函数接口"></a>2. 函数接口</h4><p>函数接口是只有一个抽象方法的接口， 用作 Lambda 表达式的返回类型。<br>包路径为 java.util.function 接口类上面都有@FunctionalInterface这个注解。</p><h4 id="3-类型检查、类型推断"><a href="#3-类型检查、类型推断" class="headerlink" title="3.  类型检查、类型推断"></a>3.  类型检查、类型推断</h4><p>Java编译器根据 Lambda 表达式上下文信息就能推断出参数的正确类型。 程序依然要经过类型检查来保证运行的安全性， 但不用再显式声明类型罢了。 这就是所谓的类型推断。</p><h4 id="4-局部变量限制"><a href="#4-局部变量限制" class="headerlink" title="4.  局部变量限制"></a>4.  局部变量限制</h4><p>Lambda表达式也允许使用自由变量（不是参数，而是在外层作用域中定义的变量），就像匿名类一样。 它们被称作捕获Lambda。 Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为final，或事实上是final。</p><p>Lambda 表达式访问外部变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String[] strings = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;;<br>    <span class="hljs-keyword">for</span> (Integer i : Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)) &#123;<br>        Stream.of(strings).map(string -&gt; string + i).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>为什么局部变量有这些限制？<br>实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。因此， Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] strings = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>    Stream.of(strings).map(string -&gt; string + i).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>上面的代码会报编译错误，lambda 表达式引用的变量需要时final或等效final的变量。</strong></p><h4 id="5-Lambda表达式的方法和构造器引用"><a href="#5-Lambda表达式的方法和构造器引用" class="headerlink" title="5.  Lambda表达式的方法和构造器引用"></a>5.  Lambda表达式的方法和构造器引用</h4><p>方法引用的语法格式有以下三种：</p><ol><li>objectName::instanceMethod</li><li>ClassName::staticMethod</li><li>ClassName::instanceMethod</li></ol><blockquote><p>前两种等同于把lambda表达式的参数当成 instanceMethod | staticMethod 的参数来调用。<br>例如： Math::max等同于(x, y)-&gt;Math.max(x,y)</p><p>后一种等于把lambda表达式的第一个参数当成instanceMethod 的目标对象，其他参数当成该方法的参数。<br>例如： String::toLowerCase() 等同于 x-&gt;x.toLowerCase()</p></blockquote><p><em>构造器引用语法如下</em></p><p>ClassName::new</p><blockquote><p>把 lambda 表达式的参数当成 ClassName 构造器的参数。例如： BigDecimal::new 等同于 x-&gt;new BigDecimal(x)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis——入门</title>
    <link href="/2021/11/28/Redis%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"/>
    <url>/2021/11/28/Redis%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-NoSQL介绍"><a href="#1-NoSQL介绍" class="headerlink" title="1.  NoSQL介绍"></a>1.  NoSQL介绍</h2><p>NoSQL （Not Only SQL）指的是非关系型的数据库，是对不同于传统的关系型数据库的数据库管理系统的统称。NoSQL用于超大规模数据的存储。Redis就属于非关系型数据库,传统的Mysql ,oracle ,sql server 等 都是关系型数据库。</p><h2 id="2-为什么需要NoSQL"><a href="#2-为什么需要NoSQL" class="headerlink" title="2. 为什么需要NoSQL"></a>2. 为什么需要NoSQL</h2><p>主要应对以下问题时，传统关系型数据库力不从心</p><p>  高并发读写<br>  海量数据的高效率存储和访问<br>  高可扩展性和高可用性</p><h2 id="3-Redis-简介"><a href="#3-Redis-简介" class="headerlink" title="3. Redis 简介"></a>3. Redis 简介</h2><p>Redis 是一个高性能的 key-value 数据库。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><p>Redis 与其他 key - value 缓存产品相比有以下三个特点：<br>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。<br>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>Redis支持数据的备份，即master-slave模式的数据备份。<br>Redis的应用场景<br>缓存<br>任务队列<br>网站访问统计<br>数据过期处理<br>应用排行榜<br>分布式集群架构中的session分离<br>Redis 支持的五种数据类型：<br>字符串（String）<br>字符串列表（list）<br>哈希（hash）<br>字符串集合（set）<br>有序字符串集合（zset）</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
