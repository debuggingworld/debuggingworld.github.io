<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>Go——testify</title>
    <link href="/2021/12/22/Go%E2%80%94%E2%80%94testify/"/>
    <url>/2021/12/22/Go%E2%80%94%E2%80%94testify/</url>
    
    <content type="html"><![CDATA[<h3 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h3><p>创建目录并初始化：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">$ mkdir -p testify &amp;&amp; cd testify<br>$ go mod init github.com/darjun/go-daily-lib/testify<br></code></pre></div></td></tr></table></figure><p>安装 testify 库：</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">$ <span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/stretchr/testify<br></code></pre></div></td></tr></table></figure><p>如果 go  get 失败：</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">$ go env -w GO111MODULE=on<br>$ go env -w GOPROXY=https:<span class="hljs-comment">//goproxy.cn,direct</span><br></code></pre></div></td></tr></table></figure><p>estify 模块：</p><ul><li>assert</li><li>http</li><li>mock</li><li>require</li><li>suite</li></ul><h3 id="2-assert"><a href="#2-assert" class="headerlink" title="2. assert"></a>2. assert</h3><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Equal</span><span class="hljs-params">(t TestingT, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotEqual</span><span class="hljs-params">(t TestingT, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Nil</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotNil</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-comment">/* 断言object是空，根据object中存储的实际类型，空的含义不同：</span><br><span class="hljs-comment">   指针：nil；</span><br><span class="hljs-comment">   整数：0；</span><br><span class="hljs-comment">   浮点数：0.0；</span><br><span class="hljs-comment">   字符串：空串&quot;&quot;；</span><br><span class="hljs-comment">   布尔：false；</span><br><span class="hljs-comment">   切片或 channel：长度为 0。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Empty</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotEmpty</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NoError</span><span class="hljs-params">(t TestingT, err error, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 断言err不为nil</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Error</span><span class="hljs-params">(t TestingT, err error, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 断言err表示的 error 链中至少有一个和target匹配</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ErrorAs</span><span class="hljs-params">(t TestingT, err error, target <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 断言err的 error 链中有target</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ErrorIs</span><span class="hljs-params">(t TestingT, err, target error, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Zero</span><span class="hljs-params">(t TestingT, i <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotZero</span><span class="hljs-params">(t TestingT, i <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">True</span><span class="hljs-params">(t TestingT, value <span class="hljs-keyword">bool</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">False</span><span class="hljs-params">(t TestingT, value <span class="hljs-keyword">bool</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Len</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, length <span class="hljs-keyword">int</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-comment">// 断言 s 包含 contains。其中 s 可以是字符串，数组/切片，map。相应地，contains为子串，数组/切片元素，map 的键。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Contains</span><span class="hljs-params">(t TestingT, s, contains <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotContains</span><span class="hljs-params">(t TestingT, s, contains <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Subset</span><span class="hljs-params">(t TestingT, list, subset <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(ok <span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotSubset</span><span class="hljs-params">(t TestingT, list, subset <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(ok <span class="hljs-keyword">bool</span>)</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FileExists</span><span class="hljs-params">(t TestingT, path <span class="hljs-keyword">string</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 断言路径 path 是一个目录，如果 path 不存在或者是一个文件，断言失败。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DirExists</span><span class="hljs-params">(t TestingT, path <span class="hljs-keyword">string</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><br><span class="hljs-comment">// 断言 listA 和 listB 包含相同的元素，忽略元素出现的顺序。listA/listB 必须是数组或切片。如果有重复元素，重复元素出现的次数也必须相等。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ElementsMatch</span><span class="hljs-params">(t TestingT, listA, listB <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-comment">// 断言theError.Error()的返回值与errString相等。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">EqualError</span><span class="hljs-params">(t TestingT, theError error, errString <span class="hljs-keyword">string</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-comment">// 断言expected与actual相等，或者可以转换为相同的类型，并且相等</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">EqualValues</span><span class="hljs-params">(t TestingT, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><br></code></pre></div></td></tr></table></figure><p><strong>Assertions 对象</strong></p><p>上面的断言都是以 TestingT 为第一个参数，需要大量使用时比较麻烦。testify 提供了一种方便的方式。先以 * testing.T创建一个* Assertions 对象，Assertions 定义了前面所有的断言方法，只是不需要再传入TestingT参数了。</p><p><a href="https://blog.csdn.net/darjun/article/details/119658145">https://blog.csdn.net/darjun/article/details/119658145</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——测试</title>
    <link href="/2021/12/20/Go%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95/"/>
    <url>/2021/12/20/Go%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1-基本测试框架"><a href="#1-基本测试框架" class="headerlink" title="1. 基本测试框架"></a>1. 基本测试框架</h3><p>在 Go 语言中，所有的测试都需要以  _test.go 结尾，这样 go build 不会去编译  _test.go 结尾的文件，而  go test 会去编译  _test.go 结尾的文件。</p><p>在编写测试的时候，会用到 testing 这个包，在这个包中，常用的类型有下面这些:</p><ul><li>testing.T（单元测试）</li><li>testing.B（基准测试）</li><li>testing.M（TestMain 测试）</li><li>testing.TB（testing.T、testing.B 公用接口）</li><li>testing.PB（Next() 接口 。 判断是否继续循环）</li></ul><p>有一类测试例外，那就是 Example 测试，主要用来在文档中输出一些测试案例，Example 测试必须以 Example 开头，方法不需要任何参数，同时要指明这个实例的输出，像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleTest</span><span class="hljs-params">()</span></span> &#123;<br> fmt.Println(<span class="hljs-string">&quot;run example test&quot;</span>)<br> <span class="hljs-comment">// Output:</span><br> <span class="hljs-comment">// run example test</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>所有的测试都可以通过 go test 来发起，例如，在当前包下发起测试 go test -v ./ ，-v 参数表示打印测试的过程，会把测试过程中的标准输出都打印出来。</p><h3 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2. 单元测试"></a>2. 单元测试</h3><h4 id="2-1-语法格式："><a href="#2-1-语法格式：" class="headerlink" title="2.1 语法格式："></a>2.1 语法格式：</h4><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestXxx</span><span class="hljs-params">(*testing.T)</span></span><br></code></pre></div></td></tr></table></figure><p><font color="red">注意：Xxx 可以是任何字母数字字符串，但是第一个字母不能是小写字母。</font><br>其中参数 t 用于报告测试失败和附加的日志信息。<br>testing.T的拥有的方法如下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Error</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Fail</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">FailNow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Failed</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Fatal</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Fatalf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Log</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Logf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span> <span class="hljs-title">Parallel</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span> <span class="hljs-title">Run</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, f <span class="hljs-keyword">func</span>(t *T)</span>) <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Skip</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">SkipNow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Skipf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Skipped</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span><br><br></code></pre></div></td></tr></table></figure><ul><li>判定失败接口：<br>　　Fail 失败继续<br>　　FailNow 失败终止</li><li>打印信息接口：<br>　　Log 数据流 （cout　类似）<br>　　Logf format (printf 类似）</li><li>SkipNow 跳过当前测试</li><li>Skiped 检测是否跳过</li><li>综合接口产生：<br>　　Error / Errorf 报告出错继续 [ Log / Logf + Fail ]<br>　　Fatel / Fatelf 报告出错终止 [ Log / Logf + FailNow ]<br>　　Skip / Skipf 报告并跳过 [ Log / Logf + SkipNow ]<figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getAge</span><span class="hljs-params">(IDNumber <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int16</span></span> &#123;<br><br> strYear := IDNumber[<span class="hljs-number">6</span>:<span class="hljs-number">10</span>]<br> intYear, _ := strconv.Atoi(strYear)<br><br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">int16</span>(<span class="hljs-number">2022</span> - intYear)<br>&#125;<br></code></pre></div></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_GetAge</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br> <span class="hljs-keyword">var</span> (<br>  in       = <span class="hljs-string">&quot;610113200505189012&quot;</span><br>  expected = <span class="hljs-number">16</span><br> )<br> actual := getAge(in)<br> <span class="hljs-keyword">if</span> actual != <span class="hljs-keyword">int16</span>(expected) &#123;<br>  t.Errorf(<span class="hljs-string">&quot;Fib(%s) = %d; expected %d&quot;</span>, in, actual, expected)<br> &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure></li></ul><p>所有的测试都可以通过 go test 来发起，例如，在当前包下发起测试 go test -v ./ ，-v ：查看测试函数名称和运行时间</p><p>还可以在go test命令后添加 -run 参数，它对应一个正则表达式，只有函数名匹配上的测试函数才会被 go test 命令执行</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211220232747.png"></p><p>【注】：</p><figure class="highlight maxima"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs maxima">PS D:\workspace\zth\gotest\src\gocode\main&gt; <span class="hljs-built_in">go</span> test .    <br><span class="hljs-built_in">go</span>: <span class="hljs-built_in">go</span>.<span class="hljs-built_in">mod</span> file <span class="hljs-keyword">not</span> found <span class="hljs-keyword">in</span> current <span class="hljs-built_in">directory</span> <span class="hljs-keyword">or</span> any parent <span class="hljs-built_in">directory</span>; see &#x27;<span class="hljs-built_in">go</span> help modules&#x27; <br></code></pre></div></td></tr></table></figure><p><strong>问题原因：</strong><br>go module 是 go 从1.13 版本开始正式推荐使用依赖管理库<br>go module 可以将某个项目(文件夹)下的所有依赖整理成一个 go.mod 文件,里面写入了依赖的版本等<br>使用go module之后我们可不用将代码放置在src下了<br>使用 go module 管理依赖后会在项目根目录下生成两个文件 go.mod 和 go.sum。</p><blockquote><p>go env -w GO111MODULE=auto<br>go mod init XXX 　//初始化Go moudle，xxx为文件夹名</p></blockquote><blockquote><p>用环境变量 GO111MODULE 开启或关闭模块支持，它有三个可选值：off、on、auto，默认值是 auto。</p><ul><li>GO111MODULE=off 　无模块支持，go 会从 GOPATH 和 vendor 文件夹寻找包。</li><li>GO111MODULE=on 　模块支持，go 会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。</li><li>GO111MODULE=auto 　在 $GOPATH/src 外面且根目录有 go.mod 文件时，开启模块支持。<br>在使用模块的时候，GOPATH 是无意义的，不过它还是会把下载的依赖储存在 $GOPATH/src/mod 中，也会把 go install 的结果放在$GOPATH/bin 中。</li></ul></blockquote><h4 id="2-2-Table-Driven-Test"><a href="#2-2-Table-Driven-Test" class="headerlink" title="2.2 Table-Driven Test"></a>2.2 Table-Driven Test</h4><p>采用 Table-Driven 的方式盖更多 case。</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_GetAge2</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> ageTest = [] <span class="hljs-keyword">struct</span>&#123;<br>in       <span class="hljs-keyword">string</span><br>expected <span class="hljs-keyword">int</span><br>&#125;&#123;<br>&#123;<span class="hljs-string">&quot;610113200505189012&quot;</span>,<span class="hljs-number">16</span>&#125;,<br>&#123;<span class="hljs-string">&quot;610113202105189012&quot;</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-string">&quot;610113202005189012&quot;</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-string">&quot;610113202105189012&quot;</span>,<span class="hljs-number">2</span>&#125;,<br><br><br>&#125;<br><br><span class="hljs-keyword">for</span> _,item := <span class="hljs-keyword">range</span> ageTest&#123;<br>actual := getAge(item.in)<br><span class="hljs-keyword">if</span> actual != item.expected &#123;<br>t.Errorf(<span class="hljs-string">&quot;Fib(%s) = %d; expected %d&quot;</span>, item.in, actual, item.expected)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>t.Errorf，即使其中某个 case 失败，也不会终止测试执行。</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211220234619.png"></p><h4 id="2-3-Parallel-测试"><a href="#2-3-Parallel-测试" class="headerlink" title="2.3 Parallel 测试"></a>2.3 Parallel 测试</h4><p>被测试方法：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>data   = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)<br>locker sync.RWMutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteToMap</span><span class="hljs-params">(k, v <span class="hljs-keyword">string</span>)</span></span> &#123;<br>locker.Lock()<br><span class="hljs-keyword">defer</span> locker.Unlock()<br>data[k] = v<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadFromMap</span><span class="hljs-params">(k <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>locker.RLock()<br><span class="hljs-keyword">defer</span> locker.RUnlock()<br><span class="hljs-keyword">return</span> data[k]<br>&#125;<br></code></pre></div></td></tr></table></figure><p>单元测试方法：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">var</span> pairs = []<span class="hljs-keyword">struct</span> &#123;<br>k <span class="hljs-keyword">string</span><br>v <span class="hljs-keyword">string</span><br>&#125;&#123;<br>&#123;<span class="hljs-string">&quot;baidu&quot;</span>, <span class="hljs-string">&quot;百度&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;google&quot;</span>, <span class="hljs-string">&quot;谷歌&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;jd&quot;</span>, <span class="hljs-string">&quot;京东&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;taobao&quot;</span>, <span class="hljs-string">&quot;淘宝&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;tianmao&quot;</span>, <span class="hljs-string">&quot;天猫&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;meituan&quot;</span>, <span class="hljs-string">&quot;美团&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-comment">// 注意 TestWriteToMap 需要在 TestReadFromMap 之前</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestWriteToMap</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>t.Parallel()<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> pairs &#123;<br>time.Sleep(time.Duration(<span class="hljs-number">1</span>)*time.Second)<br>WriteToMap(tt.k, tt.v)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestReadFromMap</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>t.Parallel()<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> pairs &#123;<br>time.Sleep(time.Duration(<span class="hljs-number">1</span>)*time.Second)<br>actual := ReadFromMap(tt.k)<br><span class="hljs-keyword">if</span> actual != tt.v &#123;<br>t.Errorf(<span class="hljs-string">&quot;the value of key(%s) is %s, expected: %s&quot;</span>, tt.k, actual, tt.v)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>执行结果：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211221234812.png"></p><p>如果注释掉 WriteToMap 和 ReadFromMap 中 locker 保护的代码，执行测试，测试失败。</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211222000146.png"></p><h4 id="2-4-testing-的变量"><a href="#2-4-testing-的变量" class="headerlink" title="2.4 testing 的变量"></a>2.4 testing 的变量</h4><ul><li>test.short : 一个快速测试的标记，在测试用例中可以使用 testing.Short() 来绕开一些测试</li><li>test.outputdir : 输出目录</li><li>test.coverprofile : 测试覆盖率参数，指定输出文件</li><li>test.run : 指定正则来运行某个 / 某些测试用例</li><li>test.memprofile : 内存分析参数，指定输出文件</li><li>test.memprofilerate : 内存分析参数，内存分析的抽样率</li><li>test.cpuprofile : cpu 分析输出参数，为空则不做 cpu 分析</li><li>test.blockprofile : 阻塞事件的分析参数，指定输出文件</li><li>test.blockprofilerate : 阻塞事件的分析参数，指定抽样频率</li><li>test.timeout : 超时时间</li><li>test.cpu : 指定 cpu 数量</li><li>test.parallel : 指定运行测试用例的并行数</li></ul><p>测试覆盖率：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211221235659.png"></p><p>将覆盖率相关的信息输出到文件：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211222000959.png"></p><h3 id="3-基准测试"><a href="#3-基准测试" class="headerlink" title="3. 基准测试"></a>3. 基准测试</h3><h4 id="3-1-基本格式"><a href="#3-1-基本格式" class="headerlink" title="3.1 基本格式"></a>3.1 基本格式</h4><p>在 _test.go 结尾的测试文件中，基准测试函数形式如下：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkXxx</span><span class="hljs-params">(*testing.B)</span></span><br></code></pre></div></td></tr></table></figure><p>通过 go test 命令，加上 -bench （匹配需要执行的函数）标志来执行。多个基准测试按照顺序运行。</p><p>待测试函数：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fib</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> n<br>&#125;<br><span class="hljs-keyword">return</span> Fib(n<span class="hljs-number">-1</span>) + Fib(n<span class="hljs-number">-2</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><p>基准测试函数：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkFib10</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> n := <span class="hljs-number">0</span>; n &lt; b.N; n++ &#123;<br>Fib(<span class="hljs-number">10</span>)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/1%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211222154956.png"></p><h4 id="3-2-计时方法"><a href="#3-2-计时方法" class="headerlink" title="3.2 计时方法"></a>3.2 计时方法</h4><ol><li>StartTimer：开始对测试进行计时。该方法会在基准测试开始时自动被调用，也可以在调用 StopTimer 之后恢复计时；</li><li>StopTimer：停止对测试进行计时。当需要执行一些复杂的初始化操作，并且不想对这些操作进行测量时，就可以使用这个方法来暂时地停止计时；</li><li>ResetTimer：对已经逝去的基准测试时间以及内存分配计数器进行清零。对于正在运行中的计时器，不会产生任何效果。</li></ol><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkFibReset</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-comment">// 长耗时配置等</span><br>time.Sleep(time.Duration(<span class="hljs-number">2</span>)*time.Second)<br>b.ResetTimer()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>Fib(<span class="hljs-number">10</span>)<br>&#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>  <img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/2%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211222161446.png"></p><h4 id="3-3-内存统计"><a href="#3-3-内存统计" class="headerlink" title="3.3  内存统计"></a>3.3  内存统计</h4><p>  ReportAllocs 方法用于打开当前基准测试的内存统计功能， 与 go test 使用 -benchmem 标志类似，但 ReportAllocs 只影响那些调用了该函数的基准测试。<br>  <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go">  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkFib10Para</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>b.ReportAllocs()<br>templ := template.Must(template.New(<span class="hljs-string">&quot;test&quot;</span>).Parse(<span class="hljs-string">&quot;Hello, &#123;&#123;.&#125;&#125;!&quot;</span>))<br>b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pb *testing.PB)</span></span> &#123;<br><span class="hljs-comment">// Each goroutine has its own bytes.Buffer.</span><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br><span class="hljs-keyword">for</span> pb.Next() &#123;<br><span class="hljs-comment">// The loop body is executed b.N times total across all goroutines.</span><br>buf.Reset()<br>templ.Execute(&amp;buf, <span class="hljs-string">&quot;World&quot;</span>)<br>&#125;<br>&#125;)<br><br>&#125;<br></code></pre></div></td></tr></table></figure><br><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211222222227.png"></p><h3 id="4-子测试与子基准测试"><a href="#4-子测试与子基准测试" class="headerlink" title="4.  子测试与子基准测试"></a>4.  子测试与子基准测试</h3><p>T 和 B 的 Run 方法允许定义子单元测试和子基准测试，而不必为它们单独定义函数。这便于创建基于 Table-Driven 的基准测试和层级测试。它还提供了一种共享通用 setup 和 tear-down 代码的方法：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFoo</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-comment">// &lt;setup code&gt;</span><br>    t.Run(<span class="hljs-string">&quot;A=1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123; ... &#125;)<br>    t.Run(<span class="hljs-string">&quot;A=2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123; ... &#125;)<br>    t.Run(<span class="hljs-string">&quot;B=1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123; ... &#125;)<br>    <span class="hljs-comment">// &lt;tear-down code&gt;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p>每个子测试和子基准测试都有一个唯一的名称：由顶层测试的名称与传递给 Run 的名称组成，以斜杠分隔，并具有可选的尾随序列号，用于消除歧义。</p><p>命令行标志 -run 和 -bench 的参数是非固定的正则表达式，用于匹配测试名称。对于由斜杠分隔的测试名称，例如子测试的名称，它名称本身即可作为参数，依次匹配由斜杠分隔的每部分名称。</p><figure class="highlight js"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs js">go test -run <span class="hljs-string">&#x27;&#x27;</span>      # 执行所有测试。<br>go test -run Foo     # 执行匹配 <span class="hljs-string">&quot;Foo&quot;</span> 的顶层测试，例如 <span class="hljs-string">&quot;TestFooBar&quot;</span>。<br>go test -run Foo/A=  # 对于匹配 <span class="hljs-string">&quot;Foo&quot;</span> 的顶层测试，执行其匹配 <span class="hljs-string">&quot;A=&quot;</span> 的子测试。<br>go test -run /A=<span class="hljs-number">1</span>    # 执行所有匹配 <span class="hljs-string">&quot;A=1&quot;</span> 的子测试。<br></code></pre></div></td></tr></table></figure><p>子测试也可用于程序并行控制。只有子测试全部执行完毕后，父测试才会完成。在下述例子中，所有子测试之间并行运行，此处的 “并行” 只限于这些子测试之间，并不影响定义在其他顶层测试中的子测试：</p><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGroupedParallel</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> _, tc := <span class="hljs-keyword">range</span> tests &#123;<br>        tc := tc <span class="hljs-comment">// capture range variable</span><br>        t.Run(tc.Name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>            t.Parallel()<br>            ...<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>[object Object]</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——数据类型</title>
    <link href="/2021/12/18/Go%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/12/18/Go%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<p>在 Go 编程语言中，数据类型用于声明函数和变量。</p><p>数据类型的出现是为了把数据分成所需内存大小不同的数据，编程的时候需要用大数据的时候才需要申请大内存，就可以充分利用内存。</p><p>Go 语言按类别有以下几种数据类型：</p><p>序号    类型和描述<br>1    布尔型<br>布尔型的值只可以是常量 true 或者 false。一个简单的例子：var b bool = true。<br>2    数字类型<br>整型 int 和浮点型 float32、float64，Go 语言支持整型和浮点型数字，并且支持复数，其中位的运算采用补码。<br>3    字符串类型:<br>字符串就是一串固定长度的字符连接起来的字符序列。Go 的字符串是由单个字节连接起来的。Go 语言的字符串的字节使用 UTF-8 编码标识 Unicode 文本。<br>4    派生类型:<br>包括：<br>(a) 指针类型（Pointer）<br>(b) 数组类型<br>(c) 结构化类型(struct)<br>(d) Channel 类型<br>(e) 函数类型<br>(f) 切片类型<br>(g) 接口类型（interface）<br>(h) Map 类型<br>数字类型<br>Go 也有基于架构的类型，例如：int、uint 和 uintptr。</p><p>序号    类型和描述<br>1    uint8<br>无符号 8 位整型 (0 到 255)<br>2    uint16<br>无符号 16 位整型 (0 到 65535)<br>3    uint32<br>无符号 32 位整型 (0 到 4294967295)<br>4    uint64<br>无符号 64 位整型 (0 到 18446744073709551615)<br>5    int8<br>有符号 8 位整型 (-128 到 127)<br>6    int16<br>有符号 16 位整型 (-32768 到 32767)<br>7    int32<br>有符号 32 位整型 (-2147483648 到 2147483647)<br>8    int64<br>有符号 64 位整型 (-9223372036854775808 到 9223372036854775807)<br>浮点型<br>序号    类型和描述<br>1    float32<br>IEEE-754 32位浮点型数<br>2    float64<br>IEEE-754 64位浮点型数<br>3    complex64<br>32 位实数和虚数<br>4    complex128<br>64 位实数和虚数<br>其他数字类型<br>以下列出了其他更多的数字类型：</p><p>序号    类型和描述<br>1    byte<br>类似 uint8<br>2    rune<br>类似 int32<br>3    uint<br>32 或 64 位<br>4    int<br>与 uint 一样大小<br>5    uintptr<br>无符号整型，用于存放一个指针</p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>[object Object]</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——模板模式</title>
    <link href="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>定义一个操作的算法骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些 特定步骤。</p><p><strong>优点：</strong></p><ol><li>封装不变部分，扩展可变部分。 </li><li>提取公共代码，便于维护。</li><li>行为由父类控制，子类实现。</li></ol><p><strong>缺点：</strong></p><ul><li>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</li></ul><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211217214833.png"></p><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 猫和少年</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-12-17 21:35</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Slogan</span> 才疏学浅，少年登科；满腹经纶，白发不第</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AbstractClass abstractClass = <span class="hljs-keyword">new</span> SubClass();<br>        abstractClass.option();<br><br>        abstractClass = <span class="hljs-keyword">new</span> SubClass2();<br>        abstractClass.option();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClass</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">option</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 准备工作</span><br>        System.out.println(<span class="hljs-string">&quot;pre .......&quot;</span>);<br>        templateMethod();<br>        <span class="hljs-comment">// 结尾工作</span><br>        System.out.println(<span class="hljs-string">&quot;teardown.....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">templateMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClass</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">templateMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;subclass  executed...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">SubClass2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClass</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">templateMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;subclass2  executed...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-JDK-中的应用"><a href="#3-JDK-中的应用" class="headerlink" title="3. JDK 中的应用"></a>3. JDK 中的应用</h3><p><strong>HttpServlet</strong></p><p>通过继承 HttpServlet ，并实现 doGet 等方法来支持相应的请求。</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/GenericServlet.png"></p><p><strong>HttpServlet 响应流程</strong></p><ol><li>Web 客户向 Servlet 容器发出Http请求</li><li>Servlet 容器解析 Web 客户的 Http 请求</li><li>Servlet 容器创建一个 HttpRequest 对象，封装 Http 请求信息</li><li>Servlet 容器创建一个 HttpResponse 对象</li><li>Servlet 容器调用 HttpServlet 的 service 方法，把 HttpRequest 和 HttpResponse 对象作为 service 方法的参数传给 HttpServlet 对象</li><li>HttpServle t调用 HttpRequest 的有关方法，获取HTTP请求信息</li><li>HttpServlet 调用 HttpResponse 的有关方法，生成响应数据</li><li>Servlet 容器把 HttpServle t的响应结果传给 Web 客户</li></ol><p>其中HttpServlet首先必须读取Http请求的内容，Servlet容器负责创建HttpServlet对象，并把Http请求直接封装到HttpServlet对象中。</p><p><strong>创建 HttpServlet 步骤</strong></p><ol><li>继承 HttpServlet 抽象类</li><li>重写 HttpServlet 的部分方法，如 doGet() 或 doPost() 方法</li><li>获取 HTTP 请求信息。通过 HttpServletRequest 对象来检索 HTML 表单所提交的数据或 URL 上的查询字符串</li><li>生成 HTTP 响应结果。通过 HttpServletResponse 对象生成响应结果</li></ol><h3 id="4-Spring-中的应用"><a href="#4-Spring-中的应用" class="headerlink" title="4. Spring 中的应用"></a>4. Spring 中的应用</h3><p><strong>AbstractController</strong><br>通过继承 AbstractController 并重写  handleRequestInternal 方法，实现 Controller。AbstractController 包装的功能：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211217234313.png"></p><p>AbstractController 继承关系：</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/AbstractController.png"></p><p><a href="https://www.cnblogs.com/yif0118/p/12494239.html">SpringMVC实现Controller方式</a> </p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>行为型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——责任链模式</title>
    <link href="/2021/12/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/12/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>为请求创建了一个接收者对象的链。<br>为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p><strong>优点：</strong> </p><ol><li>降低耦合。它将请求的发送者和接收者解耦。 </li><li>可以控制执行顺序。可以动态增删责任以及调动他们的顺序。</li><li> 符合开闭原则和单一职责原则</li></ol><p><strong>缺点：</strong></p><ol><li>不能保证请求一定被接收。</li><li>系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。</li><li>可能不容易观察运行时的特征，有碍于除错。</li></ol><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/WPS%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91.png"></p><p>使用场景： 1、有多个对象处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。</p><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><p>在请求业务前，需要对请求进行请求频率控制、登录认证、访问权限验证、敏感词过滤等。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChainOfResponsibility</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Request request = <span class="hljs-keyword">new</span> Request.RequestBuilder().frequentOK(<span class="hljs-keyword">true</span>).loggedOn(<span class="hljs-keyword">false</span>).build();<br><br>        RequestFrequentHandler requestFrequentHandler = <span class="hljs-keyword">new</span> RequestFrequentHandler(<span class="hljs-keyword">new</span> LoggingHandler(<span class="hljs-keyword">null</span>));<br><br>        <span class="hljs-keyword">if</span> (requestFrequentHandler.process(request)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;业务正常处理&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;访问异常&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>责任定义:</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    Handler next;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(Handler next)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Handler <span class="hljs-title">getNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Handler next)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Request request)</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestFrequentHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RequestFrequentHandler</span><span class="hljs-params">(Handler next)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(next);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Request request)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;访问频率验证&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (request.isFrequentOK()) &#123;<br>            Handler next = getNext();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == next) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> next.process(request);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoggingHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoggingHandler</span><span class="hljs-params">(Handler next)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(next);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Request request)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;登录验证&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (request.isLoggedOn()) &#123;<br>            Handler next = getNext();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == next) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> next.process(request);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>请求定义：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> loggedOn;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> frequentOK;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isPermits;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> containsSensitiveWords;<br>    <span class="hljs-keyword">private</span> String requestBody;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Request</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> loggedOn, <span class="hljs-keyword">boolean</span> frequentOK, <span class="hljs-keyword">boolean</span> isPermits, <span class="hljs-keyword">boolean</span> containsSensitiveWords)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loggedOn = loggedOn;<br>        <span class="hljs-keyword">this</span>.frequentOK = frequentOK;<br>        <span class="hljs-keyword">this</span>.isPermits = isPermits;<br>        <span class="hljs-keyword">this</span>.containsSensitiveWords = containsSensitiveWords;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestBuilder</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> loggedOn;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> frequentOK;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isPermits;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> containsSensitiveWords;<br><br>        <span class="hljs-function">RequestBuilder <span class="hljs-title">loggedOn</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> loggedOn)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.loggedOn = loggedOn;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function">RequestBuilder <span class="hljs-title">frequentOK</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> frequentOK)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.frequentOK = frequentOK;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function">RequestBuilder <span class="hljs-title">isPermits</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isPermits)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.isPermits = isPermits;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function">RequestBuilder <span class="hljs-title">containsSensitiveWords</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> containsSensitiveWords)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.containsSensitiveWords = containsSensitiveWords;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Request <span class="hljs-title">build</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Request(loggedOn,frequentOK,isPermits,containsSensitiveWords);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/* getter  setter */</span><br><br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="3-JDK-中应用"><a href="#3-JDK-中应用" class="headerlink" title="3. JDK 中应用"></a>3. JDK 中应用</h3><p>javax.servlet.FilterChain<br>javax.servlet.Filter</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211215232225.png"></p><p>通过数组实现责任链表</p><h3 id="4-Spring-中的应用"><a href="#4-Spring-中的应用" class="headerlink" title="4. Spring 中的应用"></a>4. Spring 中的应用</h3><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211218232612.png"></p><p><a href="https://blog.csdn.net/u014082714/article/details/103463378">https://blog.csdn.net/u014082714/article/details/103463378</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>行为型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GO——入门</title>
    <link href="/2021/12/13/GO%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"/>
    <url>/2021/12/13/GO%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1-认识-Go-语言"><a href="#1-认识-Go-语言" class="headerlink" title="1. 认识 Go 语言"></a>1. 认识 Go 语言</h3><h4 id="1-1-GO-语言的-logo"><a href="#1-1-GO-语言的-logo" class="headerlink" title="1.1 GO 语言的 logo"></a>1.1 GO 语言的 logo</h4><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211214223325.png"></p><h4 id="1-2-Go-语言的吉祥物"><a href="#1-2-Go-语言的吉祥物" class="headerlink" title="1.2 Go 语言的吉祥物"></a>1.2 Go 语言的吉祥物</h4><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211214223153.png"></p><p>gopher 是一种生活在加拿大的小动物，中文名叫做囊地鼠。</p><h3 id="2-Go-语言特性"><a href="#2-Go-语言特性" class="headerlink" title="2. Go 语言特性"></a>2. Go 语言特性</h3><blockquote><ul><li>自动垃圾回收</li><li>更丰富的内置类型</li><li>函数多返回值</li><li>错误处理</li><li>匿名函数和闭包</li><li>类型和接口</li><li>并发编程</li><li>反射</li><li>语言交互性</li></ul></blockquote><h3 id="3-语言结构"><a href="#3-语言结构" class="headerlink" title="3. 语言结构"></a>3. 语言结构</h3><p>基础组成有以下几个部分：</p><ul><li>包声明</li><li>引入包</li><li>函数</li><li>变量</li><li>语句 &amp; 表达式</li><li>注释</li></ul><figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-comment">// 必须在源文件中非注释的第一行指明这个文件属于哪个包，每个 Go 应用程序都包含一个名为 main 的包。</span><br><span class="hljs-keyword">package</span> main<br><span class="hljs-comment">// 引入包</span><br><span class="hljs-keyword">import</span>  <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-comment">// 每一个可执行程序必须包含 main 函数是</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br> fmt.Println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><ul><li>注释：多行注释（/*…*/）和单行注释（//） </li><li>分隔符：在 Go 程序中，一行代表一个语句结束。如果一行只有一个语句，结尾不需要显式加分号（;），但是多个语句写在同一行，则必须使用 ; 区分。</li><li>标识符：标识符由一个或是多个字母、数字、下划线组成的序列，并且第一个字符必须是字母或下划线而不能是数字。</li><li>当标识符（包括常量、变量、类型、函数名、结构字段等等）以大写字母开头，它就可以被外部包的代码所使用（类似 java 中的public）；标识符如果以小写字母开头，则对包外是不可见的（类似 java 的 protected ）。</li></ul></blockquote><p><font color = "red"><strong>注意：</strong></font><br> { 不能单独放在一行，否则编译错误<br> <figure class="highlight go"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br>&#123;<br> fmt.Println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br></code></pre></div></td></tr></table></figure></p><h3 id="4-执行-GO-程序"><a href="#4-执行-GO-程序" class="headerlink" title="4. 执行 GO 程序"></a>4. 执行 GO 程序</h3><ol><li> 先编译再执行</li><li> 编译运行一起执行</li></ol><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211214231117.png"></p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211213234710.png"></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——策略模式</title>
    <link href="/2021/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>定义了算法族，分别封装起来，让他们之间可以相互替换，此模式的变化独立于算法的使用者。</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211211121318.png"></p><p>解决场景：一般是具有同类可替代的行为逻辑算法场景。比如；不同类型的交易方式（信用卡、支付宝、微信）、生成唯一 ID 策略（UUID、DB自增、DB+Redis、雪花算法、Leaf 算法）等，都可以使用策略模式进行行为包装，供给外部使用。 </p><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><p>场景：模拟在购买商品时使用各种类型优惠券(满减、直减、折扣、n元购)，</p><h4 id="2-1-一般实现"><a href="#2-1-一般实现" class="headerlink" title="2.1 一般实现"></a>2.1 一般实现</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CouponDiscountService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">disCountAmount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">double</span> typeContent, <span class="hljs-keyword">double</span> skuPrice, <span class="hljs-keyword">double</span> typeExt)</span> </span>&#123;<br>        <span class="hljs-comment">// 直减</span><br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> skuPrice - typeContent;<br>        &#125;<br>        <span class="hljs-comment">// 满减</span><br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> skuPrice &lt; typeContent ? skuPrice : skuPrice - typeContent;<br>        &#125;<br>        <span class="hljs-comment">// 折扣</span><br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> skuPrice * typeContent;<br>        &#125;<br>        <span class="hljs-comment">// n 元购</span><br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">return</span> typeContent;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="2-2-策略模式重构代码"><a href="#2-2-策略模式重构代码" class="headerlink" title="2.2 策略模式重构代码"></a>2.2 策略模式重构代码</h4><p><strong>优惠券接口</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 优惠券金额计算</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> couponInfo 优惠券信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> skuPrice skuji金额</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>   折扣金额</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(T couponInfo,BigDecimal skuPrice)</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>优惠券接口实现</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MJCouponDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">Map</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">String</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 满减计算</span><br><span class="hljs-comment">     * 1. 判断满⾜x元后-n元，否则不减</span><br><span class="hljs-comment">     * 2. 最低⽀付⾦额1元</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(Map&lt;String, String&gt; couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br>        String condition = couponInfo.get(<span class="hljs-string">&quot;condition&quot;</span>);<br>        String amount = couponInfo.get(<span class="hljs-string">&quot;amount&quot;</span>);<br>        <span class="hljs-comment">// ⼩于商品⾦额条件的，直接返回商品原价</span><br>        <span class="hljs-keyword">if</span> (skuPrice.compareTo(<span class="hljs-keyword">new</span> BigDecimal(condition)) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> skuPrice;<br>        <span class="hljs-comment">// 减去优惠⾦额判断</span><br>        BigDecimal discountAmount = skuPrice.subtract(<span class="hljs-keyword">new</span> BigDecimal(amount));<br>        <span class="hljs-keyword">if</span> (discountAmount.compareTo(BigDecimal.ZERO) &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span><br>                BigDecimal.ONE;<br>        <span class="hljs-keyword">return</span> discountAmount;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZJCouponDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">Double</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 直减计算</span><br><span class="hljs-comment">     * 1. 使用商品价格减去优惠价格</span><br><span class="hljs-comment">     * 2. 最低⽀付⾦额1元</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(Double couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br>        BigDecimal discountAmount = skuPrice.subtract(<span class="hljs-keyword">new</span> BigDecimal(couponInfo));<br><br>        <span class="hljs-keyword">if</span> (discountAmount.compareTo(BigDecimal.ONE) &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> BigDecimal.ONE;<br>        &#125;<br>        <span class="hljs-keyword">return</span> discountAmount;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZKCouponDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">Double</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 折扣计算</span><br><span class="hljs-comment">     * 1. 使⽤商品价格乘以折扣⽐例，为最后⽀付⾦额</span><br><span class="hljs-comment">     * 2. 保留两位⼩数</span><br><span class="hljs-comment">     * 3. 最低⽀付⾦额1元</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(Double couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br><br>        BigDecimal discountAmount = skuPrice.multiply(<span class="hljs-keyword">new</span> BigDecimal(couponInfo)).<br>                setScale(<span class="hljs-number">2</span>, BigDecimal.ROUND_HALF_UP);<br>        <span class="hljs-keyword">if</span> (discountAmount.compareTo(BigDecimal.ONE) &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> BigDecimal.ONE;<br>        &#125;<br>        <span class="hljs-keyword">return</span> discountAmount;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NYGCouponDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">Double</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * n 元购购买</span><br><span class="hljs-comment">     * 1. ⽆论原价多少钱都固定⾦额购买</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(Double couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BigDecimal(couponInfo);<br>    &#125;<br>&#125;<br><br></code></pre></div></td></tr></table></figure><p><strong>策略控制类</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> CouponDiscount&lt;T&gt; couponDiscount;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span><span class="hljs-params">(CouponDiscount&lt;T&gt; couponDiscount)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.couponDiscount = couponDiscount;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(T couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> couponDiscount.discountAmount(couponInfo, skuPrice);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>测试验证</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContextTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">discountAmount</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">// 直减；100-10，商品100元</span><br>        Context&lt;Double&gt; context = <span class="hljs-keyword">new</span> Context&lt;Double&gt;(<span class="hljs-keyword">new</span> ZJCouponDiscount());<br>        BigDecimal discountAmount = context.discountAmount(<span class="hljs-number">10D</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>));<br>        Assert.assertTrue(discountAmount.equals(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">90</span>)));<br><br>        <span class="hljs-comment">// 满100减10，商品100元</span><br>        Context&lt;Map&lt;String, String&gt;&gt; context1 = <span class="hljs-keyword">new</span> Context&lt;Map&lt;String, String&gt;&gt;(<span class="hljs-keyword">new</span> MJCouponDiscount());<br>        Map&lt;String, String&gt; mapReq = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();<br>        mapReq.put(<span class="hljs-string">&quot;condition&quot;</span>, <span class="hljs-string">&quot;100&quot;</span>);<br>        mapReq.put(<span class="hljs-string">&quot;amount&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>);<br>        BigDecimal discountAmount1 = context1.discountAmount(mapReq, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">90</span>));<br>        Assert.assertTrue(discountAmount1.equals(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">90</span>)));<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>通过策略设计模式的使用可以把方法中的 if 语句优化掉，大量的 if 语句使用会让代码难以扩展，也不好维护，同时在后期遇到各种问题也很难维护。在使用这样的设计模式后可以很好的满足隔离性与和扩展性，对于不断新增的需求也非常方便承接。</p><h3 id="3-JDK中的应用"><a href="#3-JDK中的应用" class="headerlink" title="3. JDK中的应用"></a>3. JDK中的应用</h3><p>排序时通过实现排序接口生成不同的排序类，以达到按不同的属性排序。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComparatorTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Person[] people = <span class="hljs-keyword">new</span> Person[]&#123;<span class="hljs-keyword">new</span> Person(<span class="hljs-number">10</span>,<span class="hljs-number">111</span>),<span class="hljs-keyword">new</span> Person(<span class="hljs-number">18</span>,<span class="hljs-number">99</span>),<span class="hljs-keyword">new</span> Person(<span class="hljs-number">15</span>,<span class="hljs-number">122</span>)&#125;;<br><br>        System.out.println(Arrays.toString(people));<br>        Arrays.sort(people,<span class="hljs-keyword">new</span> SortByAge());<br>        System.out.println(Arrays.toString(people));<br>        Arrays.sort(people,<span class="hljs-keyword">new</span> SortByHeight());<br>        System.out.println(Arrays.toString(people));<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  [Person&#123;age=10, height=111&#125;, Person&#123;age=18, height=99&#125;, Person&#123;age=15, height=122&#125;]</span><br><span class="hljs-comment">            [Person&#123;age=10, height=111&#125;, Person&#123;age=15, height=122&#125;, Person&#123;age=18, height=99&#125;]</span><br><span class="hljs-comment">            [Person&#123;age=15, height=122&#125;, Person&#123;age=10, height=111&#125;, Person&#123;age=18, height=99&#125;]</span><br><span class="hljs-comment">         */</span><br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortByHeight</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Person</span>&gt;</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person o1, Person o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span>  o1.getHeight()-o2.getHeight();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortByAge</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Person</span>&gt;</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person o1, Person o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> o1.getAge()-o2.getAge();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">int</span> height;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> height)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.height = height;<br>    &#125;<br>    <br>    <span class="hljs-comment">/* getter setter  toString */</span><br>&#125;<br><br></code></pre></div></td></tr></table></figure><h3 id="4-Spring-中的应用"><a href="#4-Spring-中的应用" class="headerlink" title="4. Spring 中的应用"></a>4. Spring 中的应用</h3><h4 id="4-1-InstantiationStrategy"><a href="#4-1-InstantiationStrategy" class="headerlink" title="4.1 InstantiationStrategy"></a>4.1 InstantiationStrategy</h4><p>接口 InstantiationStrategy 是实例化策略接口类，它定义了三种实例化方式，SimpleInstantiationStrategy 实现了该策略，CglibSubclassingInstantiationStrategy 又继承了 SimpleInstantiationStrategy  新增了根据 cglib 生成代理类实例化方法。</p><p><a href="https://my.oschina.net/chengxiaoyuan/blog/823655">实例化策略 InstantiationStrategy</a></p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211211125722.png"></p><p>如果工厂方法实例化直接用反射创建对象，如果是构造方法实例化的则判断是否有 MethodOverrides，如果没有MethodOverrides 也是直接用反射，如果有 MethodOverrides 就需要用 cglib 实例化对象，SimpleInstantiationStrategy 把通过 cglib 实例化的任务交给了它的子类 CglibSubclassingInstantiationStrategy。</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211211224848.png"></p><h4 id="4-2-Aop代理策略"><a href="#4-2-Aop代理策略" class="headerlink" title="4.2 Aop代理策略"></a>4.2 Aop代理策略</h4><p>首先 AopProxyFactory 接口类提供了 createAopProxy 接口，这个是策略模式的接口方法。DefaultAopProxyFactory 实现了该接口作为策略的实现者。ProxyCreatorSupport 里面引用了 AopProxyFactory，并且提供了 get、set 方法用来运行时改变策略。这里 Spring 只实现了 DefaultAopProxyFactory 这一个策略，如果需要自己也可以实现。</p><p>DefaultAopProxyFactory 里面的 createAopProxy 的逻辑如下，可以在运行时根据参数决定用 Cglib 策略还是 JDK 动态代理策略生成代理类：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> AopProxy <span class="hljs-title">createAopProxy</span><span class="hljs-params">(AdvisedSupport config)</span> <span class="hljs-keyword">throws</span> AopConfigException </span>&#123;<br><br><br>        <span class="hljs-comment">//如果XML打开了优化开关，或者设置为了代理目标类，或者目前类没有接口</span><br>        <span class="hljs-keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;<br>            Class&lt;?&gt; targetClass = config.getTargetClass();<br>            <span class="hljs-keyword">if</span> (targetClass == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopConfigException(<span class="hljs-string">&quot;TargetSource cannot determine target class: &quot;</span> +<br>                        <span class="hljs-string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-comment">//如果有接口，或者通过Proxy.newProxyInstance生成的，则使用jdk动态代理</span><br>            <span class="hljs-keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);<br>            &#125;<br><br>            <span class="hljs-comment">//使用cglib</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObjenesisCglibAopProxy(config);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//使用jdk动态代理</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);<br>        &#125;<br>    &#125;<br></code></pre></div></td></tr></table></figure><p>另外 AopProxy 也是一个策略接口类，具体实现的策略为 JdkDynamicAopProxy、CglibAopProxy、ObjenesisCglibAopProxy。</p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211211231617.png"></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>行为型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——泛型</title>
    <link href="/2021/12/09/java%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B/"/>
    <url>/2021/12/09/java%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1-理解泛型"><a href="#1-理解泛型" class="headerlink" title="1.理解泛型"></a>1.理解泛型</h3><p>什么是泛型？为什么要使用泛型？</p><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</p><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。<br>泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化（称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><p>泛型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><blockquote><p>注意：<br>泛型的类型参数只能是类类型，不能是简单类型。<br>不能对确切的泛型类型使用 instanceof 操作。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;String&gt; strings = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><span class="hljs-comment">// 编译报错：Illegal generic type for instanceo</span><br><span class="hljs-keyword">if</span> (strings <span class="hljs-keyword">instanceof</span> List&lt;String&gt;) &#123;&#125;<br></code></pre></div></td></tr></table></figure><h3 id="2-泛型类"><a href="#2-泛型类" class="headerlink" title="2. 泛型类"></a>2. 泛型类</h3><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。泛型类的类型参数声明部分可以包含一个或多个类型参数，参数间用逗号隔开。</p><p>一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</p><p>通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p><p><strong>语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名称 &lt;泛型标识：可以是任意标识号&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> 泛型标识 <span class="hljs-comment">/*（成员变量类型）*/</span> <span class="hljs-keyword">var</span>;<br>    .....<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//key这个成员变量的类型为T,T的类型由外部指定</span><br>    <span class="hljs-keyword">private</span> T key;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Generic</span><span class="hljs-params">(T key)</span> </span>&#123; <span class="hljs-comment">// 构造方法形参类型也为T，由外部指定</span><br>        <span class="hljs-keyword">this</span>.key = key;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//传入的实参类型需与泛型的类型参数类型相同，即为 Integer.</span><br>Generic&lt;Integer&gt; genericInteger = <span class="hljs-keyword">new</span> Generic&lt;Integer&gt;(<span class="hljs-number">123456</span>);<br></code></pre></div></td></tr></table></figure><h3 id="3-泛型接口"><a href="#3-泛型接口" class="headerlink" title="3. 泛型接口"></a>3. 泛型接口</h3><p>泛型类型用于接口的定义中，被称为泛型接口。</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 定义泛型接口</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">// 实现接口一</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CarGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;car&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 实现接口二</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitGenerator</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> T next;<br><br><span class="hljs-comment">// 非泛型方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FruitGenerator</span><span class="hljs-params">(T next)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        FruitGenerator&lt;String&gt; fruit = <span class="hljs-keyword">new</span> FruitGenerator&lt;String&gt;(<span class="hljs-string">&quot;Fruit&quot;</span>);<br>        System.out.println(fruit.next);<br>        <span class="hljs-comment">// Fruit</span><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="4-泛型方法"><a href="#4-泛型方法" class="headerlink" title="4. 泛型方法"></a>4. 泛型方法</h3><p>泛型方法：是在调用方法的时候指明泛型的具体类型。</p><blockquote><p>泛型类：是在实例化类的时候指明泛型的具体类型。</p></blockquote><h4 id="4-1-泛型方法的基本用法"><a href="#4-1-泛型方法的基本用法" class="headerlink" title="4.1 泛型方法的基本用法"></a>4.1 泛型方法的基本用法</h4><p>泛型方法的定义规则：</p><ul><li>所有泛型方法声明在方法返回类型之前都有类型参数声明部分（由尖括号分隔）</li><li>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。</li><li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li></ul><blockquote><p>java 中泛型标记符：</p><ul><li>E - Element (在集合中使用，因为集合中存放的是元素)</li><li>T - Type（Java 类）</li><li>K - Key（键）</li><li>V - Value（值）</li><li>N - Number（数值类型）</li><li>？ - 表示不确定的 java 类型</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 泛型方法 printArray</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(E[] inputArray)</span></span>&#123;<br>    <span class="hljs-comment">// 输出数组元素</span><br>    Arrays.stream(inputArray).forEach(System.out::println);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>    <span class="hljs-comment">// 创建不同的数组</span><br>    Integer[] intArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br>    Double[] doubleArray = &#123; <span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">3.3</span>, <span class="hljs-number">4.4</span> &#125;;<br>    Character[] charArray = &#123; <span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span> &#125;;<br><br>    System.out.println(<span class="hljs-string">&quot;整型数组元素为：&quot;</span>);<br>    printArray(intArray);<br><br>    System.out.println(<span class="hljs-string">&quot;双精度型数组元素为：&quot;</span>);<br>    printArray(doubleArray);<br><br>    System.out.println(<span class="hljs-string">&quot;字符型数组元素为：&quot;</span>);<br>    printArray(charArray);<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="4-2-泛型方法与可变参数"><a href="#4-2-泛型方法与可变参数" class="headerlink" title="4.2 泛型方法与可变参数"></a>4.2 泛型方法与可变参数</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">   <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMsg</span><span class="hljs-params">(T... args)</span></span>&#123;<br>       Arrays.stream(args).forEach(System.out::println);<br>   &#125;<br><br>printMsg(<span class="hljs-string">&quot;111&quot;</span>,<span class="hljs-number">111</span>,<span class="hljs-number">123.23</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">123L</span>);<br></code></pre></div></td></tr></table></figure><h4 id="4-3-静态方法与泛型"><a href="#4-3-静态方法与泛型" class="headerlink" title="4.3 静态方法与泛型"></a>4.3 静态方法与泛型</h4><p>静态方法无法访问类上定义的泛型，如果静态方法操作的引用数据类型不确定时，必须将泛型定义在方法上。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticGenerator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 编译错误：cannot be referenced from a static context</span><br>    <span class="hljs-comment">// public static void Show(T t) &#123;&#125;</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">(T t)</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><h3 id="5-泛型通配符"><a href="#5-泛型通配符" class="headerlink" title="5.  泛型通配符"></a>5.  泛型通配符</h3><h4 id="5-1-用-代替具体的类型参数"><a href="#5-1-用-代替具体的类型参数" class="headerlink" title="5.1 用 ? 代替具体的类型参数"></a>5.1 用 ? 代替具体的类型参数</h4><p>此处’？’是类型实参，而不是类型形参。也就是说此处的？和 Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    List&lt;String&gt; name = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    List&lt;Integer&gt; age = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    List&lt;Number&gt; number = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br><br>    name.add(<span class="hljs-string">&quot;zth&quot;</span>);<br>    age.add(<span class="hljs-number">18</span>);<br>    number.add(<span class="hljs-number">13</span>);<br>    getData(name);<br>    getData(age);<br>    getData(number);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getData</span><span class="hljs-params">(List&lt;?&gt; data)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;data: &quot;</span>+data.get(<span class="hljs-number">0</span>));<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="5-2-泛型的上边界"><a href="#5-2-泛型的上边界" class="headerlink" title="5.2 泛型的上边界"></a>5.2 泛型的上边界</h4><p>通过形如  List &lt; ? extends Number&gt;  来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; age = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Number&gt; number = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Double&gt; doubles = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    printNumber(age);<br>    printNumber(number);<br>    printNumber(doubles);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printNumber</span><span class="hljs-params">(List&lt;? extends Number&gt; data)</span> </span>&#123;<br>    data.forEach(System.out::println);<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>Ingeter 是 Number 的一个子类，但是 Generic<Integer>  不能被看作为 Generic<Number>  的子类。由此可以看出：同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。</p></blockquote><h4 id="5-3-泛型的下边界"><a href="#5-3-泛型的下边界" class="headerlink" title="5.3 泛型的下边界"></a>5.3 泛型的下边界</h4><p>通过形如 List&lt; ? super Number&gt; 来定义，表示类型只能接受 Number 及其三层父类类型，如Objec类型的实例。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Number&gt; number = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Object&gt; objects = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    printNumber(number);<br>    printNumber(objects);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printNumber</span><span class="hljs-params">(List&lt; ? <span class="hljs-keyword">super</span> Number&gt; data)</span> </span>&#123;<br>    data.forEach(System.out::println);<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>注：不能在上限泛型集合中添加元素，可以在下限泛型集合中添加元素</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">      List&lt; ? <span class="hljs-keyword">super</span> Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      <span class="hljs-comment">// 可以在下限泛型集合中添加元素</span><br>      list.add(<span class="hljs-number">111</span>);<br>      <span class="hljs-comment">//报错： add (capture&lt; ? super java.lang.Integer&gt;) in List cannot be applied  to (java.lang.Object)</span><br>      list.add(<span class="hljs-keyword">new</span> Object());<br><br><span class="hljs-comment">// 不能在上限泛型集合中添加元素</span><br>      List&lt; ? extends Number&gt; data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      <span class="hljs-comment">// 报错：add  (capture&lt; ? extends java.lang.Number&gt;) in List cannot be applied to (java.lang.Integer)</span><br>      data.add(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">111</span>));<br></code></pre></div></td></tr></table></figure><p>在日常中，只要记住 “ PECS(Producer Extends Consumer Super)原则” 即可。意思为：<br>（1）频繁往外读取内容的，适合用上界Extends。<br>（2）经常往里插入的，适合用下界Super。</p><p>参考：<a href="https://www.zhihu.com/question/20400700">https://www.zhihu.com/question/20400700</a></p><h3 id="6-泛型的生命周期"><a href="#6-泛型的生命周期" class="headerlink" title="6. 泛型的生命周期"></a>6. 泛型的生命周期</h3><p>Java的泛型信息只存在于编译期间，编译之后所有的泛型信息都会被擦除。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integerList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>List&lt;String&gt; stringList = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>System.out.println(integerList.getClass() == stringList.getClass());<br><span class="hljs-comment">// true</span><br></code></pre></div></td></tr></table></figure><p>不管是 ArrayList&lt; Integer &gt; 还是 ArrayList&lt; Long &gt;，在编译时都会被编译器擦除成了 ArrayList。</p><p>Java引入泛型是为了加强参数类型的安全性，在编译期间根据泛型声明及早发现类型转化问题，减少了类型的转换。因为在 JDK1.5 之前是没有泛型的，需要考虑向下兼容，所以对于泛型只存在于编译期间。编译成字节码后，ArrayList&lt; Integer &gt; 或 ArrayList&lt; Long &gt; 都会被擦除成 ArrayList，这样就能保持和 JDK1.5 之前版本兼容。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>list.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>Class listClass = list.getClass();<br>Method methodList = listClass.getMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);<br>methodList.invoke(list, <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>));<br><span class="hljs-keyword">for</span> (Object obj : list) &#123;<br>    System.out.println(<span class="hljs-string">&quot;obj = &quot;</span> + obj +<span class="hljs-string">&quot;, class = &quot;</span> + obj.getClass().getName());<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * obj = hello, class = java.lang.String</span><br><span class="hljs-comment"> * obj = 10, class = java.lang.Integer</span><br><span class="hljs-comment"> */</span><br></code></pre></div></td></tr></table></figure><p><strong>在运行期间获取泛型信息</strong></p><p>虽然泛型类在编译的时候会进行泛型擦除，不过泛型信息还是会保存在泛型类的字节码对象中。</p><blockquote><p>获取到泛型类型的要求：</p><ul><li>必须具有真实类型的存在。</li><li>泛型的类型是明确的（如List<User>是明确的，List<T>是不明确的）。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 为了方便其他类获取，将其作为公有属性</span><br>    Class&lt;?&gt; clazz;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Generic</span><span class="hljs-params">()</span> </span>&#123;<br>        ParameterizedType pt = (ParameterizedType)<br>                <span class="hljs-keyword">this</span>.getClass().getGenericSuperclass();<br>        <span class="hljs-comment">// 获取泛型参数列表，如Map&lt;K,V&gt;，那么返回K，V的数组</span><br>        Type[] types = pt.getActualTypeArguments();<br>        <span class="hljs-comment">//因为这里只有一个泛型T，所以获取第一个元素</span><br>        clazz = (Class&lt;?&gt;) types[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGeneric</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>&#125;<br>System.out.println(<span class="hljs-keyword">new</span> Generic1().clazz);<br><span class="hljs-comment">// class java.lang.String</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——java9新特性</title>
    <link href="/2021/12/06/Java%E2%80%94%E2%80%94java9%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2021/12/06/Java%E2%80%94%E2%80%94java9%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p><strong>java9 新特性：</strong></p><ul><li>目录结构</li><li>模块化系统</li><li>jshell</li><li>接口的私有方法</li><li>改进 try-with-resourcs </li><li>改进钻石操作符 </li><li>限制使用单独下划线标识符</li><li> String 存储结构变更</li><li> 快速创建只读集合</li><li> 增强 Stream API</li><li> 改进 Optional 类</li><li> 多分辨率图像 API</li><li> 全新 HTTP 客户端 API</li><li> 智能 JAVA 编译工具</li><li> 统一 JVM 日志系统</li><li> javadoc 的 HTML5 支持</li><li> java 动态编译</li></ul><h4 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1.目录结构"></a>1.目录结构</h4><p>JDK9具体目录结构：</p><ul><li>bin： 该目录包含所有的命令。</li><li>conf： 包含用户可以编辑的配置文件，例如以前位于 jre\lib 目录中的 .properties 和 .policy 文件。 </li><li>include： 包含一些编译本地代码时使用的 C/C++头文件。</li><li>jmods： 包含JMOD 格式的平台模块，创建自定义运行映射时需要它。 </li><li>legal： 包含法律声明。 </li><li>lib： 包含非 Windows 平台上动态链接的本地库，其子目录和文件不应由开发人员直 接编辑或使用。</li></ul><blockquote><p>JDK8 目录结构：</p><ul><li>bin： 该目录存放了 JDK 的各种工具命令，即 jdk 工具的可执行二进制文件，包括编译器，调试器等，例如：java，javac</li><li>db： 该目录是安装 Java DB 的路径。Java 自带数据库 Derby。</li><li>include： 包含一些编译本地代码时使用的 C/C++头文件。</li><li>jre： 该目录包含的是 jre 环境(Java runtime environment 即 Java 运行时环境)。</li><li>lib：该目录存放的是 java 工具命令实际执行的程序包。</li></ul></blockquote><p> <strong>注：JDK9 目录中不再有 jre 子目录。</strong></p><h4 id="2-模块化系统"><a href="#2-模块化系统" class="headerlink" title="2. 模块化系统"></a>2. 模块化系统</h4><p>JDK9 将 JDK 分成一组模块，可以在编译时，运行时或构建时进行组合。模块化可以减少内存开销；只需必要的模块，并非全部模块，可以简化各种类库和大型应用的开发和维护，八个仓库： root、corba、hotspot、jaxp、jaxws、jdk、langtools 和 nashorn </p><blockquote><p>module-info.java：该文件必须位于项目的根目录中。该文件用于定义模块需要什么依赖，以及哪些包被外部使用。<br>exports：控制哪些包可以被其他模块访问，所有不被 exports 的包默认都被封装在模块里面不 被外界所使用。<br>requires：指明对其他模块的依赖。 </p></blockquote><p><strong>示例:</strong></p><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211212225847.png"></p><p>有两个模块 jdk9 和 jdk9module1，在 jdk9 中引用 jdk9module1 的内容。</p><p>jdk9  module-info 内容：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span> jdk9 &#123;<br>    <span class="hljs-keyword">requires</span> jdk9module1;<br>    <span class="hljs-keyword">requires</span> jdk.incubator.httpclient;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>jdk9module1  module-info 内容：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">module</span> jdk9module1 &#123;<br>    <span class="hljs-keyword">exports</span> com.zth.bean;<br>    <span class="hljs-comment">//exports com.zth.common;</span><br>&#125;<br></code></pre></div></td></tr></table></figure><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211212230559.png"><br>可以看到如果没有引用 common 包，将如法使用 Util 类。</p><h4 id="3-JShell"><a href="#3-JShell" class="headerlink" title="3. JShell"></a>3. JShell</h4><p>JDK9 新增了 REPL（Read-Eval-Print Loop）工具 jshell，jshell 工具提供了一个交互式命令界面， 可以评估声明、语句和表达式，无需编译即可返回执行结果。</p><blockquote><ol><li> /list   　　　　    //列出所有的代码 </li><li> /methods 　　   //查看所有的方法 </li><li> /var          　　   //所有的变量 </li><li>/edit          　　  //打开编辑器 </li><li>/open path 　　//执行路径上的代码 如 /open C:\Users\wukong\Desktop\App.java </li></ol></blockquote><p><img src="https://cdn.jsdelivr.net/gh/debuggingworld/tuchuang/20211212231645.png"></p><h4 id="3-接口私有化方法"><a href="#3-接口私有化方法" class="headerlink" title="3. 接口私有化方法"></a>3. 接口私有化方法</h4><p>在JDK8中接口运行使用静态方法和默认方法后，JDK9可以在接口中使用私有方法 1 @FunctionalInterface 2 public interface TestFunctionalInterface { 3 //todo @FunctionalInterface注解会检测接口是否有且只有一个抽象方法，还可以有默 认方法和静态方法 4 public void test(); 5 //todo 默认方法 6 default String getName(){ 7 log(“getName”); 8 return “人参”; 9 } 10 //todo 默认方法 11 default String getDesc(){ 12 log(“getDesc”); 13 return “人参大补元气”; 14 } 15 private void log(String method){<br>16 System.out.println(“TestFunctionalInterface.”+method+”()被调用”); 17 } 18 //todo 静态方法 19 static String getName2(){ 20 return “鹿茸”; 21 } 22 } </p><p>五、改进try­with­resource JDK8中新增了try-with-resources语句，可以自动关闭需要关闭的资源文件。但是必须在try语句 后的括号中初始化需要关闭的资源。在JDK9中改进了try-with-resources语句，你可以在try外初 始化资源，然后在try后的括号中添加需要自动关的资源即可 1 public static void jdk7() { 2 FileInputStream fileInputStream = null; 34 try { 5 fileInputStream = new FileInputStream(“D:/a.txt”); 6 byte[] temp = new byte[1024]; 7 fileInputStream.read(temp); 8 System.out.println(new String(temp)); 9 } catch (Exception e) { 10 e.printStackTrace(); 11 }finally { 12 if (fileInputStream != null){ 13 try { 14 fileInputStream.close(); 15 } catch (IOException e) { 16 e.printStackTrace(); 17 } 18 } 19 } 20 } 21 public static void jdk8() { 222324 try( FileInputStream fileInputStream = new FileInputStream(“D:/a.txt”)) {2526 byte[] temp = new byte[1024]; 27 fileInputStream.read(temp);<br>28 System.out.println(new String(temp)); 29 } catch (Exception e) { 30 e.printStackTrace(); 31 } 32 } 33 public static void jdk9() throws FileNotFoundException { 3435 FileInputStream fileInputStream = new FileInputStream(“D:/a.txt”); 36 try( fileInputStream) { 37 byte[] temp = new byte[1024]; 38 fileInputStream.read(temp); 39 System.out.println(new String(temp)); 40 } catch (Exception e) { 41 e.printStackTrace(); 42 } 43 }</p><p>六、改进钻石操作符 JDK9中钻石操作符可以使用匿名实现类，可以在匿名实现类中重写方法等操作 1 public static void main(String[] args) { 2 //jdk9允许 3 Comparator<Integer> comparator = new Comparator&lt;&gt;() { 4 @Override 5 public int compare(Integer o1, Integer o2) { 6 return 0; 7 } 8 }; 9 } </p><p>七、限制使用单独下划线标识符 在JDK8之前可以使用“<em>”单独的下划线作为标识符，但在JDK9中将单独的下划线标识符限制使 用了 1 public static void main(String[] args) { 2 int _ = 20;//jdk9已禁止 3 System.out.println(</em>); 4 } </p><p>八、String存储结构变更 从很多不同应用程序收集的信息表名，字符串是堆使用的主要组成部分，而且，大多数字符串对象 只包含一个字符，这样的字符只需要一个字节的存储空间，因此这些字符串对象的内部char数组中<br>有一半的空间被闲置。 JDK9之前String底层使用char数组存储数据private final char value[]，JDK9将String底层存储数 据改为byte数组存储数据private final byte[] value。 StringBuffer和StringBuilder也同样做了变更，将以往char数组改为byte数组。 </p><p>九、快速创建只读集合 JDK9在List、Set和Map集合中新增of静态方法，快速创建只读集合 1 List<String> list = List.of(“三七”,”人参”,”鹿茸”,”紫河车”); 2 list.add(“黄连”);//会抛出异常 3 Set<String> set = Set.of(“三七”,”人参”,”鹿茸”,”紫河车”); 45 Map&lt;Integer,String&gt; map = Map.of(1,”三七”,2,”人参”,3,”鹿茸”,4,”紫河车”);</p><p>十、增强Stream API JDK9在Stream接口中新增4个方法：dropWhile、takeWhile、ofNullable,为iterate方法新增重 载方法1 Stream<String> stream = Stream.of(“三七”,”人参”,”鹿茸”,”紫河车”); 2 stream.takeWhile(item‐&gt;item.length()==2).forEach(System.out::println); 3 System.out.println(“===============================================”); 4 Stream<String> stream1 = Stream.of(“三七”,”人参”,”鹿茸”,”紫河车”); 5 stream1.dropWhile(item‐&gt;item.length()==2).forEach(System.out::println); 6 System.out.println(“===============================================”);<br>7 Stream<Integer> stream2 = Stream.of(7,40,6,333,4,4,5,2,3,3,3,3,6); 8 stream2.takeWhile(num‐&gt;num&lt;100).forEach(System.out::println); 9 System.out.println(“===============================================”); 10 Stream<Integer> stream3 = Stream.of(7,40,6,333,4,4,5,2,3,3,3,3,6); 11 stream3.dropWhile(num‐&gt;num&lt;100).forEach(System.out::println); 12 System.out.println(“===============================================”); 13 Stream<Integer> stream4 = Stream.ofNullable(null); 14 System.out.println(stream4.count()); </p><p>十一、改进Optional类 Optional 类是在JDK8中新增的类，主要是为了解决空指针异常。在JDK9中对这个类进行了改 进，主要是新增了三个方法：stream，ifPresentOrElse 和 or 1 List<String> list = new ArrayList&lt;&gt;(); 2 list.add(“人参”); 3 list.add(“当归”); 4 list.add(“鹿茸”); 5 list.add(“黄柏”); 6 Optional&lt;List<String>&gt; optional = Optional.ofNullable(list); 7 optional.stream().forEach(System.out::println); 8910 Optional<String> optional1 = Optional.of(“Mahesh”); 11 optional1.ifPresentOrElse( x ‐&gt; System.out.println(“Value: “ + x),() ‐&gt; 12 System.out.println(“Not Present.”)); 13 Supplier&lt;Optional<String>&gt; supplierString = () ‐&gt; Optional.of(“Not Prese nt”); 14 optional1 = optional1.or( supplierString); </p><p>十二、多分辨率图像API 在 java.awt.image 包下新增了支持多分辨率图片的API，用于支持多分辨率的图片。 1. 将不同分辨率的图像封装到一张（多分辨率的）图像中，作为它的变体。 2. 获取这个图像的所有变体。 3. 获取特定分辨率的图像变体，表示一张已知分辨率单位为 DPI 的特定尺寸大小的逻辑图 像，并且这张图像是最佳的变体。 4. java.awt.image.MultiResolutionImage接口的基础实现 java.awt.image.BaseMultiResolutionImage获取所需要的变体。 5. 通过接口的getResolutionVariant（double destImageWidth, double destImageHeight）方法，根据分辨率获取图像。</p><p>十三、全新的HTTP客户端API<br>HTTP，用于传输网页的协议，早在 1997 年就被采用在目前的 1.1版本中。直到 2015 年， HTTP2 才成为标准。 HTTP/1.1和HTTP/2的主要区别是如何在客户端和服务器之间构建和传输数据。HTTP/1.1 依赖于 请求/响应周期。 HTTP/2 允许服务器“push”数据：它可以发送比客户端请求更多的数据。 这 使得它可以优先处理并发送对于首先加载网页至关重要的数据。 JDK9 中有新的方式来处理 HTTP 调用。它提供了一个新的HTTP客户端(HttpClient)，它将替代仅 适用于blocking模式的HttpURLConnection(HttpURLConnection是在HTTP 1.0的时代创建的， 并使用了协议无关的方法)，并提供对 WebSocket 和 HTTP/2 的支持。 此外，HTTP客户端还提供 API 来处理 HTTP/2 的特性，比如流和服务器推送等功能。 全新的 HTTP 客户端 API 可以从 jdk.incubator.httpclient 模块中获取。因为在默认情况下，这个 模块是不能根据 classpath 获取的，需要使用 add modules 命令选项配置这个模块，将这个模块 添加到 classpath中。 1 public static void main(String[] args) { 2 //创建 builder 3 HttpClient.Builder builder = HttpClient.newBuilder(); 4 //链式调用 5 HttpClient client = builder 6 //http 协议版本 1.1 或者 2 7 .version(HttpClient.Version.HTTP_2) //.version(HttpClient.Version.HTTP_1 _1) 8 //连接完成之后的转发策略 9 .followRedirects(HttpClient.Redirect.NEVER) //.followRedirects(HttpClien t.Redirect.ALWAYS) 10 //指定线程池 11 .executor(Executors.newFixedThreadPool(5)) 1213 //认证，默认情况下 Authenticator.getDefault() 是 null 值，会报错 14 //.authenticator(Authenticator.getDefault()) 1516 //代理地址 17 //.proxy(ProxySelector.of(new InetSocketAddress(“<a href="http://www.baidu.com&quot;/">http://www.baidu.com&quot;</a>, 8080))) 1819 //缓存，默认情况下 CookieHandler.getDefault() 是 null 值，会报错 20 //.cookieHandler(CookieHandler.getDefault()) 2122 //创建完成<br>23 .build(); 24 //组装request 25 URI baiduUri = new URI(“<a href="https://www.baidu.com&quot;/">https://www.baidu.com&quot;</a>); 26 HttpRequest request = HttpRequest.newBuilder(baiduUri) 27 .version(HttpClient.Version.HTTP_2) 28 .build(); 29 //发起调用 30 HttpResponse<String> r = client.send(request, HttpResponse.BodyHandler.asString()); 31 System.out.println(r.body()); 32 }</p><p>十四、智能JAVA编译工具 智能 java 编译工具( sjavac )的第一个阶段始于 JEP139 这个项目，用于在多核处理器情况下提升 JDK 的编译速度。如今，这个项目已经进入第二阶段，即 JEP199，其目的是改进 Java 编译工 具，并取代目前 JDK 编译工具 javac，继而成为 Java 环境默认的通用的智能编译工具。 JDK 9 还更新了 javac 编译器以便能够将 java 9 代码编译运行在低版本 Java 中。</p><p>十五、统一的JVM日志系统 日志是解决问题的唯一有效途径：曾经很难知道导致 JVM 性能问题和导致 JVM 崩溃的根本原 因。不同的 JVM 日志的碎片化和日志选项（例如：JVM 组件对于日志使用的是不同的机制和规 则），这使得 JVM 难以进行调试。 解决该问题最佳方法：对所有的 JVM 组件引入一个单一的系统，这些 JVM 组件支持细粒度的和 易配置的 JVM 日志。</p><p>十六、javadoc的HTML5支持 JDK8 生成的java帮助文档是在 HTML4 中。而HTML4 已经是很久的标准了。 JDK9 的javadoc，现支持HTML5 标准。 下图是JDK8 API的HTML页面 如下图是JDK9 API的 HTML，右上角支持搜索功能。</p><p>十七、java动态编译器 JIT（Just-in-time）编译器可以在运行时将热点编译成本地代码，速度很快。但是 Java 项目现在 变得很大很复杂，因此 JIT 编译器需要花费较长时间才能热身完，而且有些 Java 方法还没法编 译，性能方面也会下降。AoT 编译就是为了解决这些问题而生的。 在 JDK 9 中， AOT（JEP 295: Ahead-of-Time Compilation）作为实验特性被引入进来，开发 者可以利用新的 jaotc 工具将重点代码转换成类似类库一样的文件。虽然仍处于试验阶段，但这个 功能使得 Java应用在被虚拟机启动之前能够先将 Java 类编译为原生代码。此功能旨在改进小型和 大型应用程序的启动时间，同时对峰值性能的影响很小。 但是 Java 技术供应商 Excelsior 的营销总监 Dmitry Leskov 担心 AoT 编译技术不够成熟，希望 Oracle 能够等到 Java 10时有个更稳定版本才发布。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java9新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——java8新特性之Optional</title>
    <link href="/2021/12/03/Java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BOptional/"/>
    <url>/2021/12/03/Java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BOptional/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Optional-介绍"><a href="#1-Optional-介绍" class="headerlink" title="1. Optional 介绍"></a>1. Optional 介绍</h3><p>Optional<T> 是在 java.util 包下的一个用于代替 null 的一个工具类</p><p><strong>仅仅是解决 NPE(NullPointerException) 问题吗？</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">List&lt;Order&gt;  <span class="hljs-title">getOrders</span><span class="hljs-params">(User user)</span></span>&#123;<br>    Optional&lt;User&gt; u = Optional.ofNullable(user);<br>    <span class="hljs-keyword">if</span> (u.isPresent())&#123;<br>        <span class="hljs-keyword">return</span> u.get().getOrders();<br>    &#125;<br>    <span class="hljs-keyword">return</span> Collections.emptyList();<br>&#125;<br><br><span class="hljs-function">List&lt;Order&gt;  <span class="hljs-title">getOrders2</span><span class="hljs-params">(User user)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != user)&#123;<br>        <span class="hljs-keyword">return</span> user.getOrders();<br>    &#125;<br>    <span class="hljs-keyword">return</span> Collections.emptyList();<br>&#125;<br></code></pre></div></td></tr></table></figure><p>第一种方法虽然使用了 Optional ，但是本质上没有区别，如何优雅的使用 Optional？    </p><p><strong>Optional 错误使用姿势</strong></p><ol><li>调用 isPresent() 方法</li><li>调用 get() 方法</li><li>Optional 类型作为类/实例属性</li><li>Optional 类型作为方法参数 </li></ol><blockquote><p>解释：</p><ul><li>使用 isPresent() 和使用 obj != null 无任何分别</li><li>直接调用 get() 方法虽然不抛出 NPE 了，但如果没有值是会抛出 NoSuchElementException。</li></ul></blockquote><p>Optional 中可以依赖的是除了 isPresent() 和 get() 的其他方法：</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">public<U> Optional<U> map(Function&lt;? super T, ? extends U&gt; mapper)</td><td align="center">如果值存在，就对该值执行提供的 mapping 函数的调用</td></tr><tr><td align="center">public T orElse(T other)</td><td align="center">如果有值则将其返回，否则返回默认值</td></tr><tr><td align="center">public T orElseGet(Supplier&lt;? extends T&gt; other)</td><td align="center">如果有值则将其返回，否则返回一个 Supplier 接口生成的值</td></tr><tr><td align="center">public void ifPresent(Consumer&lt;? super T&gt; consumer)</td><td align="center">如果值存在，就通过 consumer 消费次值，否则什么也不做</td></tr><tr><td align="center">public Optional<T> filter(Predicate&lt;? super T&gt; predicate)</td><td align="center">如果值存在并且满足提供的谓词，就返回包含该值的 Optional 对象</td></tr><tr><td align="center">public<U> Optional<U> flatMap(Function&lt;? super T, Optional<U>&gt; mapper)</td><td align="center">如果值存在，就对该值执行提供的 mapping 函数调用</td></tr><tr><td align="center">public <X extends Throwable> T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</td><td align="center">如果有值则将其返回，否则抛出一个由指定的 Supplier 接口生成的异常</td></tr></tbody></table><h3 id="2-Optional-构造方式"><a href="#2-Optional-构造方式" class="headerlink" title="2. Optional 构造方式"></a>2. Optional 构造方式</h3><ul><li>Optional.of(obj)：要求传入的 obj 不能为 null，否则还抛出 NullPointerException 异常</li><li>Optional.empty()：value 为 null 的 Optional</li><li>Optional.ofNullable(obj)：如果 obj  为 null 返回 Optional.empty()，否则返回 Optional.of(obj)</li></ul><blockquote><p>Optional.of(obj) 的作用</p><ol><li>当非常明确将要传给 Optional.of(obj) 的 obj 参数不可能为 null 时, 比如刚 new 出来的对象(Optional.of(new User(…))), 或者是一个非 null 常量时;</li><li>当想为 obj 断言不为 null 时, 即想在万一 obj 为 null 立即报告 NullPointException 异常, 立即修改, 而不是隐藏空指针异常</li></ol></blockquote><h3 id="3-Optional-使用"><a href="#3-Optional-使用" class="headerlink" title="3. Optional 使用"></a>3. Optional 使用</h3><h4 id="3-1-获取值"><a href="#3-1-获取值" class="headerlink" title="3.1 获取值"></a>3.1 获取值</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 存在即返回，否则提供默认值</span><br><span class="hljs-keyword">return</span> user.orElse(UNKNOWUSER);<br><span class="hljs-comment">// 而不是 return user.isPresent() ? user.get() : null ;</span><br><br><br><span class="hljs-comment">// 存在即返回，否则函数生成</span><br><span class="hljs-keyword">return</span> user.orElseGet(<span class="hljs-keyword">this</span>::getDefaultUser);<br><br><span class="hljs-comment">// 存在即返回，否则抛出异常</span><br><span class="hljs-keyword">return</span> user.orElseThrow(NullPointerException::<span class="hljs-keyword">new</span>);<br><br><br><span class="hljs-comment">// 存在才执行操作</span><br>user.ifPresent(System.out::print);<br><span class="hljs-comment">// 而不是</span><br><span class="hljs-keyword">if</span> (user.isPresent())&#123;<br>    System.out.println(user.get());<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="3-2-map-函数"><a href="#3-2-map-函数" class="headerlink" title="3.2 map 函数"></a>3.2 map 函数</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 当 user.isPresent() 为真, 获得 用户名，否则返回 null</span><br>String name = user.map(User::getName).orElse(<span class="hljs-string">&quot;UNKNOW&quot;</span>);<br><br><span class="hljs-comment">// java8 之前</span><br>String name2 = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">if</span> (user.isPresent())&#123;<br>    name2 = user.get().getName();<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    name2 = <span class="hljs-string">&quot;UNKNOW&quot;</span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="3-3-filter-函数"><a href="#3-3-filter-函数" class="headerlink" title="3.3 filter 函数"></a>3.3 filter 函数</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Optional&lt;String&gt; name = Optional.of(<span class="hljs-string">&quot;debugging&quot;</span>);<br>Optional&lt;String&gt; longName = name.filter(i -&gt; i.length() &gt; <span class="hljs-number">6</span>);<br>System.out.println(longName.orElse(<span class="hljs-string">&quot;The name is less than 6 characters&quot;</span>));<br><span class="hljs-comment">// debugging</span><br><br>Optional&lt;String&gt; name2 = Optional.of(<span class="hljs-string">&quot;admin&quot;</span>);<br>Optional&lt;String&gt; longName2 = name2.filter(i -&gt; i.length() &gt; <span class="hljs-number">6</span>);<br>System.out.println(longName2.orElse(<span class="hljs-string">&quot;The name is less than 6 characters&quot;</span>));<br><span class="hljs-comment">// The name is less than 6 characters</span><br><br><br>Optional&lt;String&gt; name3 = Optional.empty();<br>Optional&lt;String&gt; longName3 = name3.filter(i -&gt; i.length() &gt; <span class="hljs-number">6</span>);<br>System.out.println(longName3.orElse(<span class="hljs-string">&quot;The name is less than 6 characters&quot;</span>));<br><span class="hljs-comment">// The name is less than 6 characters</span><br></code></pre></div></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——java8新特性之Stream</title>
    <link href="/2021/12/01/java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/"/>
    <url>/2021/12/01/java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/</url>
    
    <content type="html"><![CDATA[<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p><strong>A sequence of elements supporting sequential and parallel aggregate operations .</strong></p><ol><li>Stream 是元素的集合，这点让 Stream 看起来用些类似 Iterator；</li><li>可以支持顺序和并行的对原Stream进行汇聚的操作；</li></ol><blockquote><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulkdata operation)。</p></blockquote><p>Stream API 借助于 Lambda 表达式，极大的提高编程效率和程序可读性。同时提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势（使用 fork/join框架，fork 递归式地分解问题，然后每段并行执行，最终由 join 合并结果，返回最后的值）。</p><p>[例] 统计列表中不为 null 的元素个数。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; nums = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">6</span>);<br><br><span class="hljs-comment">//原始版本</span><br><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (Integer item : nums) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != item) &#123;<br>        count++;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Stream 版本</span><br><span class="hljs-keyword">long</span> count1 = nums.stream().filter(Objects::nonNull).count();<br></code></pre></div></td></tr></table></figure><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h3><p><img src="https://user-images.githubusercontent.com/45761474/144250337-a744591a-f7ef-4877-8876-c01a7ede3661.jpg" alt="Stream表达式"></p><p>一条语句分为三部分：</p><ol><li>红色框中的语句是一个 Stream 的生命开始的地方，负责创建一个Stream实例；</li><li>绿色框中的语句是赋予 Stream 灵魂的地方，把一个 Stream 转换成另外一个 Stream；</li><li>蓝色框中的语句是汇聚的地方，把 Stream 里面包含的内容按照某种算法来汇聚成一个值。</li></ol><blockquote><p>使用Stream的基本步骤：</p><ol><li>创建Stream；</li><li>转换Stream，每次转换原有Stream对象不改变，返回一个新的Stream对象（可以有多次转换）；</li><li>对Stream进行聚合（Reduce）操作，获取想要的结果</li></ol></blockquote><h3 id="3-创建-Stream"><a href="#3-创建-Stream" class="headerlink" title="3. 创建 Stream"></a>3. 创建 Stream</h3><p>常见创建 Stream 的方式有三种：</p><ul><li>通过 Stream 接口的静态工厂方法</li><li>通过 Collection 接口的默认方法 stream() 把一个 Collection 对象转换为 Stream</li><li>通过数组，Arrays.stream(T array)</li></ul><ol><li><p>of 方法：有两个 overload 方法，一个接受变长参数，一个接口单一值；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>Stream&lt;String&gt; stringStream = Stream.of(<span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></div></td></tr></table></figure></li><li><p>generator 方法<br>生成一个无限长度的 Stream ，其元素生成时通过给定的 Supplier 接口提供</p></li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Stream.generate(<span class="hljs-keyword">new</span> Supplier&lt;Double&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Math.random();<br>    &#125;<br>&#125;);<br>Stream.generate(()-&gt;Math.random());<br><br>Stream.generate(Math::random);<br></code></pre></div></td></tr></table></figure><p>生成一个无限长度的Stream，其中值是随机的。这个无限长度Stream是懒加载。</p><ol start="3"><li>iterate 方法：</li></ol><p>也是生成无限长度的 Stream，和 generator 不同的是，其元素的生成是重复对给定的种子值(seed)调用用户指定函数来生成的。其中包含的元素可以认为是：seed，f(seed),f(f(seed))无限循环。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 先获取一个无限长度的正整数集合的Stream，然后取出前10个打印。</span><br>      Stream.iterate(<span class="hljs-number">1</span>, item -&gt; item * <span class="hljs-number">2</span>).limit(<span class="hljs-number">10</span>).forEach(System.out::println);<br></code></pre></div></td></tr></table></figure><ol start="4"><li>通过 Collection 子类获取 Stream<br>Collection接口有一个stream方法，所以其所有子类都都可以获取对应的Stream对象。<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integerList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">3</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>integerList.stream();<br>Set&lt;Integer&gt; integerSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>integerSet.stream();<br>Map&lt;String, String&gt; stringMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>stringMap.entrySet().stream();<br>stringMap.keySet().stream();<br>stringMap.values().stream();<br></code></pre></div></td></tr></table></figure></li><li>Arrays.stream(T array)</li></ol><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">Arrays.stream(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);<br></code></pre></div></td></tr></table></figure><h3 id="4-转换Stream"><a href="#4-转换Stream" class="headerlink" title="4. 转换Stream"></a>4. 转换Stream</h3><p>转换Stream就是把一个 Stream 通过某些行为转换成一个新的 Stream。</p><p>Stream 接口中几个常用的转换方法:</p><ul><li>disinct</li><li>filter</li><li>map</li><li>flatmap</li><li>peek</li><li>limit</li><li>skip</li></ul><h4 id="4-1-distinct"><a href="#4-1-distinct" class="headerlink" title="4.1 distinct"></a>4.1 distinct</h4><p>对于 Stream 中包含的元素进行去重操作(依赖于元素的 equals 方法)，新生成的Stream 中没有重复的元素。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>    list.stream().distinct().forEach(item -&gt; System.out.print(item+ <span class="hljs-string">&quot;  &quot;</span>));<br>    <span class="hljs-comment">// 1  null  2  3  4  5  6  7  8  9 </span><br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="4-2-filter"><a href="#4-2-filter" class="headerlink" title="4.2 filter"></a>4.2 filter</h4><p>对于 Stream 中包含的元素使用给定的过滤函数进行过滤，新生成的 Stream 只包含符合条件的元素</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>list.stream().distinct().filter(Objects::nonNull).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br><span class="hljs-comment">// 1  2  3  4  5  6  7  8  9  </span><br></code></pre></div></td></tr></table></figure><h4 id="4-3-map"><a href="#4-3-map" class="headerlink" title="4.3 map"></a>4.3 map</h4><p>对于 Stream 中包含的元素使用给定的转换函数进行转换操作，新生成的 Stream 只包含转换生成的元素。这个方法有三个对于原始类型的变种方法，分别是：mapToInt，mapToLong 和 mapToDouble。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>list.stream().distinct().filter(Objects::nonNull).map(i -&gt; i * <span class="hljs-number">2</span>).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br><span class="hljs-comment">// 2  4  6  8  10  12  14  16  18 </span><br><br>DoubleStream stream = DoubleStream.of(<span class="hljs-number">23.0</span>, <span class="hljs-number">25.4</span>, <span class="hljs-number">32.5</span>, <span class="hljs-number">45.9</span>);<br>stream.mapToInt(item -&gt; (<span class="hljs-keyword">int</span>) item).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br><span class="hljs-comment">// 23  25  32  45          </span><br></code></pre></div></td></tr></table></figure><h4 id="4-4-flatMap"><a href="#4-4-flatMap" class="headerlink" title="4.4 flatMap"></a>4.4 flatMap</h4><p>和map类似，不同的是其每个元素转换得到的是Stream对象，会把子Stream中的元素压缩到父集合中</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;String&gt; teamIndia = Arrays.asList(<span class="hljs-string">&quot;Virat&quot;</span>, <span class="hljs-string">&quot;Dhoni&quot;</span>, <span class="hljs-string">&quot;Jadeja&quot;</span>);<br>List&lt;String&gt; teamAustralia = Arrays.asList(<span class="hljs-string">&quot;Warner&quot;</span>, <span class="hljs-string">&quot;Watson&quot;</span>, <span class="hljs-string">&quot;Smith&quot;</span>);<br>List&lt;List&lt;String&gt;&gt; players = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>players.add(teamIndia);<br>players.add(teamAustralia);<br>players.stream().flatMap(Collection::stream).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br></code></pre></div></td></tr></table></figure><h4 id="4-5-peek"><a href="#4-5-peek" class="headerlink" title="4.5. peek"></a>4.5. peek</h4><p>生成一个包含原 Stream 的所有元素的新 Stream，同时会提供一个消费函数（Consumer实例），新 Stream 每个元素被消费的时候都会执行给定的消费函数；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>System.out.println(<span class="hljs-string">&quot;\n&quot;</span>+integers.stream().peek(System.out::print).count());<br><span class="hljs-comment">//16789</span><br><span class="hljs-comment">//5</span><br></code></pre></div></td></tr></table></figure><h4 id="4-6-limit"><a href="#4-6-limit" class="headerlink" title="4.6 limit"></a>4.6 limit</h4><p>对一个 Stream 进行截断操作，获取其前N个元素，如果原 Stream 中包含的元素个数小于N，则获取其所有的元素</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>integers.stream().limit(<span class="hljs-number">3</span>).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;   &quot;</span>));<br><span class="hljs-comment">// 1   6   7</span><br></code></pre></div></td></tr></table></figure><h4 id="4-7-skip"><a href="#4-7-skip" class="headerlink" title="4.7 skip"></a>4.7 skip</h4><p>返回一个丢弃原 Stream 的前 N 个元素后剩下元素组成的新 Stream，如果原Stream中包含的元素个数小于N，那么返回空 Stream</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>integers.stream().skip(<span class="hljs-number">2</span>).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;   &quot;</span>));<br><span class="hljs-comment">// 7   8   9  </span><br></code></pre></div></td></tr></table></figure><p>  <strong>转换操作都是 lazy 的，多个转换操作只会在汇聚操作的时候融合起来，一次循环完成。可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在汇聚操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</strong></p><h3 id="5-汇聚（reduce）Stream"><a href="#5-汇聚（reduce）Stream" class="headerlink" title="5. 汇聚（reduce）Stream"></a>5. 汇聚（reduce）Stream</h3><p>Reduce 操作接受一个元素序列为输入，反复使用某个合并操作，把序列中的元素合并成一个汇总的结果。</p><p>比如查找一个数字列表的总和或者最大值，或者把这些数字累积成一个List对象。</p><p>Stream接口通用的汇聚操作</p><ul><li>reduce()</li><li>collect()</li><li>count() </li><li>sum()</li><li>allMatch：判断是否是全部的元素都满足给定匹配条件</li><li>noneMatch：判断是否是全部的元素都不满足给定匹配条件</li><li>anyMatch：判断是否至少有一个元素满足给定匹配条件</li><li>findFirst：返回第一个元素</li><li>max()：使用比较器（Operator），返回 Stream 中最大的元素</li></ul><p>注意：sum 方法不是所有的 Stream 对象都有的，只有 IntStream、LongStream 和 DoubleStream是实例才有。</p><h4 id="5-1-collect"><a href="#5-1-collect" class="headerlink" title="5.1  collect"></a>5.1  collect</h4><p>把输入的元素累积到一个可变的容器中，比如 Collection 或者 StringBuilder。<br>可变汇聚对应的方法只有一个：collect，它的作用就是把Stream中的所有元素收集到一个结果容器中。</p><p><strong>方法定义1：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">&lt;R&gt; <span class="hljs-function">R <span class="hljs-title">collect</span><span class="hljs-params">(Supplier&lt;R&gt; supplier,</span></span><br><span class="hljs-params"><span class="hljs-function">              BiConsumer&lt;R, ? <span class="hljs-keyword">super</span> T&gt; accumulator,</span></span><br><span class="hljs-params"><span class="hljs-function">              BiConsumer&lt;R, R&gt; combiner)</span></span><br></code></pre></div></td></tr></table></figure><p>方法参数：</p><ul><li>Supplier<R> supplier：工厂函数，用来生成一个新的容器。</li><li>BiConsumer&lt;R, ? super T&gt; accumulator：用来把 Stream 中的元素添加到结果容器</li><li>BiConsumer&lt;R, R&gt; combiner：用来把中间状态的多个结果容器合并成一个（并发时）</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>ArrayList&lt;Integer&gt; collect = integers.stream().filter(Objects::nonNull)<br>        .collect(ArrayList::<span class="hljs-keyword">new</span>, ArrayList::add, ArrayList::addAll);<br>System.out.println(collect.toString());<br><span class="hljs-comment">// [1, 6, 7, 8, 9]</span><br></code></pre></div></td></tr></table></figure><p><strong>方法定义2：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">&lt;R, A&gt; <span class="hljs-function">R <span class="hljs-title">collect</span><span class="hljs-params">(Collector&lt;? <span class="hljs-keyword">super</span> T, A, R&gt; collector)</span></span>;<br></code></pre></div></td></tr></table></figure><p>Collectors 已经定义了一些静态工厂方法：</p><ul><li>Collectors.toCollection() 收集到 Collection 中</li><li>Collectors.toList() 收集到 List 中</li><li>Collectors.toSet() 收集到 Set 中</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>List&lt;Integer&gt; collect = integers.stream().filter(Objects::nonNull)<br>        .collect(Collectors.toList());<br>System.out.println(collect.toString());<br><span class="hljs-comment">// [1, 6, 7, 8, 9]</span><br></code></pre></div></td></tr></table></figure><h4 id="5-2-reduce"><a href="#5-2-reduce" class="headerlink" title="5.2 reduce"></a>5.2 reduce</h4><p><strong>方法定义1</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">reduce</span><span class="hljs-params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;<br></code></pre></div></td></tr></table></figure><p>接受一个 BinaryOperator 类型的参数，BinaryOperator 函数有两个参数</p><ul><li>第一个参数是上次函数执行的返回值（中间结果）</li><li>第二个参数是 Stream 中的元素</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>Integer integer = integers.stream().filter(Objects::nonNull).<br>        reduce((sum, item) -&gt; sum + item).get();<br>System.out.println(integer);<br><span class="hljs-comment">// 31</span><br></code></pre></div></td></tr></table></figure><p><strong>方法定义2</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function">T <span class="hljs-title">reduce</span><span class="hljs-params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;<br></code></pre></div></td></tr></table></figure><p>和上面的类似，不同的是允许提供一个初始值，如果 Stream 为空，则直接返回初始值。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>Integer integer = integers.stream().filter(Objects::nonNull).<br>        reduce(<span class="hljs-number">100</span>,(sum, item) -&gt; sum + item);<br>System.out.println(integer);<br><span class="hljs-comment">// 131</span><br></code></pre></div></td></tr></table></figure><p><strong>方法定义3</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">&lt;U&gt; <span class="hljs-function">U <span class="hljs-title">reduce</span><span class="hljs-params">(U identity,</span></span><br><span class="hljs-params"><span class="hljs-function">             BiFunction&lt;U, ? <span class="hljs-keyword">super</span> T, U&gt; accumulator,</span></span><br><span class="hljs-params"><span class="hljs-function">             BinaryOperator&lt;U&gt; combiner)</span></span>;<br></code></pre></div></td></tr></table></figure><p>功能和上面的类似，不同的是允许用户提供一个 combiner 函数用来处理并发场景下的数据汇总。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>Integer integer = integers.parallelStream().filter(Objects::nonNull).<br>        reduce(<span class="hljs-number">0</span>, (sum, item) -&gt; sum + item, (result, fragment) -&gt; result + fragment);<br>System.out.println(integer);<br><span class="hljs-comment">// 31</span><br></code></pre></div></td></tr></table></figure><h4 id="5-3-count-方法"><a href="#5-3-count-方法" class="headerlink" title="5.3 count 方法"></a>5.3 count 方法</h4><p>统计 Stream 中的元素的个数</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><span class="hljs-keyword">long</span> count = integers.parallelStream().filter(Objects::nonNull).count();<br>System.out.println(count);<br><span class="hljs-comment">// 5</span><br></code></pre></div></td></tr></table></figure><h3 id="6-Collectors"><a href="#6-Collectors" class="headerlink" title="6. Collectors"></a>6. Collectors</h3><p>Collector接口：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collector</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">A</span>, <span class="hljs-title">R</span>&gt; </span>&#123;<br> <span class="hljs-comment">// 用于生成和返回一个结果容器</span><br>    <span class="hljs-function">Supplier&lt;A&gt; <span class="hljs-title">supplier</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-comment">// 将元素 T 归纳到容器A</span><br>    <span class="hljs-function">BiConsumer&lt;A, T&gt; <span class="hljs-title">accumulator</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-comment">// 将两个结果合并并返回</span><br>    <span class="hljs-function">BinaryOperator&lt;A&gt; <span class="hljs-title">combiner</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-comment">// 将中间结果R 转换为A</span><br>    <span class="hljs-function">Function&lt;A, R&gt; <span class="hljs-title">finisher</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-comment">// characteristics 表示当前 collector的特征值，返回 Collector 特征值的 Set</span><br>    <span class="hljs-function">Set&lt;Characteristics&gt; <span class="hljs-title">characteristics</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br><br></code></pre></div></td></tr></table></figure><p>Collectors 是一个工具类，是 JDK 预实现 Collector 的工具类，它内部提供了多种 Collector。</p><p>Collectors 除了提供了上文介绍过的收集方法外还提供了一组非常有用方法。</p><h4 id="6-1-joining"><a href="#6-1-joining" class="headerlink" title="6.1 joining"></a>6.1 joining</h4><p>连接收集的结果</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>String value = integers.stream().map(String::valueOf).collect(Collectors.joining());<br><span class="hljs-comment">// 16789</span><br><br><span class="hljs-comment">// 指定间隔符</span><br>String value1 = integers.stream().map(String::valueOf).collect(Collectors.joining(<span class="hljs-string">&quot;-&quot;</span>));<br><span class="hljs-comment">// 1-6-7-8-9</span><br><br><br><span class="hljs-comment">// 指定间隔符、前缀、后缀</span><br>String value2 = integers.stream().map(String::valueOf).collect(Collectors.joining(<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;$&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>));<br><span class="hljs-comment">// $1-6-7-8-9#</span><br></code></pre></div></td></tr></table></figure><h4 id="6-2-collectingAndThen"><a href="#6-2-collectingAndThen" class="headerlink" title="6.2 collectingAndThen"></a>6.2 collectingAndThen</h4><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T,A,R,RR&gt; Collector&lt;T,A,RR&gt; <span class="hljs-title">collectingAndThen</span><span class="hljs-params">(Collector&lt;T,A,R&gt; downstream,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                            Function&lt;R,RR&gt; finisher)</span></span><br></code></pre></div></td></tr></table></figure><p>通过第二个参数 Function 函数对汇聚后的结果进行再操作</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 收集后逆序排序</span><br>      List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>      List&lt;String&gt; collect = integers.stream().map(String::valueOf).<br>              collect(Collectors.collectingAndThen(Collectors.toList(), Lists::reverse));<br>      <span class="hljs-comment">// [9, 8, 7, 6, 1]</span><br></code></pre></div></td></tr></table></figure><h4 id="6-3-groupingBy"><a href="#6-3-groupingBy" class="headerlink" title="6.3 groupingBy"></a>6.3 groupingBy</h4><p>用于生成一个拥有分组功能的 Collector，它也有三个重载方法</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 只需一个分组参数 classifier，内部自动将结果保存到一个 map 中</span><br><span class="hljs-comment">// 每个 map 的键为 ？ 类型（即 classifier 的结果类型），值为 list（保存这个组中的元素）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;<br>    groupingBy(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; classifier)<br><br><span class="hljs-comment">// 在上面方法的基础上增加了对流元素的处理方式的Collector，比如上面的默认处理方法是 Collectors.toList()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K, A, D&gt;<br>    Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; classifier,<br>                                          Collector&lt;? <span class="hljs-keyword">super</span> T, A, D&gt; downstream)<br><br><span class="hljs-comment">// 在第二个方法的基础上增加了结果 Map 的生成方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt;<br>    Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; classifier,<br>                                  Supplier&lt;M&gt; mapFactory,<br>                                  Collector&lt;? <span class="hljs-keyword">super</span> T, A, D&gt; downstream)<br><br></code></pre></div></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>Map&lt;Integer, List&lt;Integer&gt;&gt; collect = integers.stream().collect(Collectors.groupingBy(item -&gt; item % <span class="hljs-number">3</span>));<br><span class="hljs-comment">// &#123;0=[3, 6, 9], 1=[1, 4, 7], 2=[2, 5, 8]&#125;</span><br><br>Map&lt;Integer, Set&lt;Integer&gt;&gt; collect1 = integers.stream().collect(Collectors.groupingBy(item -&gt; item % <span class="hljs-number">3</span>, Collectors.toSet()));<br><span class="hljs-comment">// &#123;0=[3, 6, 9], 1=[1, 4, 7], 2=[2, 5, 8]&#125;</span><br><br><br>Map&lt;Integer, Set&lt;Integer&gt;&gt; collect2 = integers.stream()<br>        .collect(Collectors.groupingBy(item -&gt; item % <span class="hljs-number">3</span>,HashMap::<span class="hljs-keyword">new</span>, Collectors.toSet()));<br><span class="hljs-comment">// &#123;0=[3, 6, 9], 1=[1, 4, 7], 2=[2, 5, 8]&#125;</span><br></code></pre></div></td></tr></table></figure><h4 id="6-4-partitioningBy"><a href="#6-4-partitioningBy" class="headerlink" title="6.4 partitioningBy"></a>6.4 partitioningBy</h4><p>将流中的元素按照给定的校验规则分为两部分，放到一个 map 中返回，map 的键是 boolean 类型，值为元素的列表 list。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 只需要一个校验参数 predicate</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt;<br>   Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)<br><span class="hljs-comment">// 在上面的基础上增加了对流中元素的处理方式的 Collector，默认 Collector.toList()</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, D, A&gt;<br>   Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate,<br>                                                   Collector&lt;? <span class="hljs-keyword">super</span> T, A, D&gt; downstream)<br><br></code></pre></div></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><br><span class="hljs-comment">// 对序列进行奇偶分区</span><br>Map&lt;Boolean, List&lt;Integer&gt;&gt; collect = integers.stream().collect(Collectors.partitioningBy(item -&gt; item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>));<br><span class="hljs-comment">// &#123;false=[1, 1, 3, 5, 7, 9], true=[2, 4, 6, 8]&#125;</span><br><br>Map&lt;Boolean, Set&lt;Integer&gt;&gt; collect1 = integers.stream().<br>        collect(Collectors.partitioningBy(item -&gt; item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, Collectors.toSet()));<br><span class="hljs-comment">// &#123;false=[1, 3, 5, 7, 9], true=[2, 4, 6, 8]&#125;</span><br></code></pre></div></td></tr></table></figure><h4 id="6-4-reducing"><a href="#6-4-reducing" class="headerlink" title="6.4 reducing"></a>6.4 reducing</h4><p><strong>方法定义</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-comment">// 无初始值，返回一个可以生成 Optional 结果的  Collector</span><br>&lt;T&gt; Collector&lt;T, ?, T&gt;   reducing(T identity, BinaryOperator&lt;T&gt; op)<br><br><span class="hljs-comment">// 有初始值，返回一个可以直接生成结果的  Collector</span><br>&lt;T&gt; Collector&lt;T, ?, T&gt;  reducing(T identity, BinaryOperator&lt;T&gt; op)<br><br><span class="hljs-comment">// 有初始值，元素在执行操作之前先执行 mapper 进行元素转换</span><br> &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity,<br>                                Function&lt;? <span class="hljs-keyword">super</span> T, ? extends U&gt; mapper,<br>                                BinaryOperator&lt;U&gt; op)<br></code></pre></div></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><br>Optional&lt;Integer&gt; integerOptional = integers.stream().collect(Collectors.reducing(Integer::sum));<br><span class="hljs-comment">// 等价于 integers.stream().reduce(Integer::sum);</span><br>System.out.println(integerOptional.get());<br><span class="hljs-comment">// 46</span><br><br>Integer collect = integers.stream().collect(Collectors.reducing(<span class="hljs-number">10</span>, Integer::sum));<br><span class="hljs-comment">// 等价于 integers.stream().reduce(10, Integer::sum);</span><br><span class="hljs-comment">// 56</span><br><br>String s = integers.stream().collect(Collectors.reducing(<span class="hljs-string">&quot;@&quot;</span>, String::valueOf, String::concat));<br><span class="hljs-comment">// 等价于 integers.stream().map(String::valueOf).reduce(&quot;@&quot;, String::concat);</span><br><span class="hljs-comment">// @1123456789</span><br></code></pre></div></td></tr></table></figure><h4 id="6-5-综合应用"><a href="#6-5-综合应用" class="headerlink" title="6.5 综合应用"></a>6.5 综合应用</h4><p>将列表按奇偶分组，然后每组里面找最大值（两种实现）</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><br>Map&lt;Boolean, Optional&lt;Integer&gt;&gt; collect = integers.stream().collect(<br>        Collectors.partitioningBy(item -&gt; item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>,<br>                Collectors.maxBy(Comparator.comparing(Integer::valueOf))));<br><br>Map&lt;Boolean, Optional&lt;Integer&gt;&gt; collect1 = integers.stream().collect(<br>        Collectors.partitioningBy(item -&gt; item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>,<br>                Collectors.reducing(BinaryOperator.maxBy(Comparator.comparing(Integer::valueOf)))));<br><br><span class="hljs-comment">// &#123;false=Optional[9], true=Optional[8]&#125;</span><br></code></pre></div></td></tr></table></figure><h3 id="7-Stream-的关闭"><a href="#7-Stream-的关闭" class="headerlink" title="7 Stream 的关闭"></a>7 Stream 的关闭</h3><p>Steam 继承了 AutoCloseable 接口，在大多数场景下都是无需手动关闭的，仅在流的资源是 IO 通道（例如：Files.lines(Path ,Charset )）时需要调用 Stream.close() 方法关闭流，以保证 IO 资源的释放。也可以使用 try-with-resources 语法关闭 Stream。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——函数式编程</title>
    <link href="/2021/11/30/java%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/11/30/java%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1-重新认识接口"><a href="#1-重新认识接口" class="headerlink" title="1. 重新认识接口"></a>1. 重新认识接口</h3><h4 id="1-1-java8之前"><a href="#1-1-java8之前" class="headerlink" title="1.1 java8之前"></a>1.1 java8之前</h4><p>接口的作用：定义该类型实例具有的功能，不关心如何进行这些工作。所以，接口定义中只有抽象方法（public abstract）和常量（public static final），并且接口中不允许定义实例变量。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInterface</span> </span>&#123;<br>    Integer age = <span class="hljs-number">18</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><h4 id="1-2-java8之后"><a href="#1-2-java8之后" class="headerlink" title="1.2 java8之后"></a>1.2 java8之后</h4><p>从JKD8开始，接口可以加入静态方法和默认方法<br>默认方法允许接口方法定义默认实现，而所有子类都继承该方法及实现</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInterface</span> </span>&#123;<br>    Integer age = <span class="hljs-number">18</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printHello</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getString</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>默认方法的优势</strong></p><ol><li>默认方法的主要优势是提供一种拓展接口的方法，而不破坏现有代码。增加新的方法，并且能保证对使用这个接口的老版本代码的兼容性。<br>在JDK8以前，如果为一个现有接口增加一个新方法，则我们必须在所有实现类中添加该方法的实现，否则编译会出现异常。<br>如果实现类比较多或者我们没有权限修改实现类源代码，这样可能就比较麻烦。<br>默认方法则解决了这个问题，它提供了一个实现，当没有显式提供其他实现时就采用这个实现，这样新添加的方法将不会破坏现有代码。</li><li>另一个优势是该方法是可选，子类可以根据不同的需求Override默认实现。<br>例如，我们定义一个集合接口，其中有增、删、改等操作。如果实现类90%都是以数组保存数据，那么可以定义针对这些方法给出默认实现，而对于其他非数组集合或者有其他类似业务，可以选择性复写接口中默认方法。</li></ol><h3 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2.函数式接口"></a>2.函数式接口</h3><p><strong>定义：</strong></p><blockquote><p>如果一个接口定义唯一一个抽象方法，那么这个接口就成为函数式接口。</p></blockquote><p>java.lang.Runnable 就是一个函数式接口，因为它只有一个抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></div></td></tr></table></figure><p>默认方法不是abstract的，所以一个函数式接口里可以定义任意多的默认方法。<br>为了标明函数式接口Java8引入了一个新的注解： @FunctionalInterface</p><p><strong>函数接口特性</strong></p><ul><li>@FunctionInterface 注解只能标记在有且仅有一个抽象方法的接口上；</li><li>Java8接口中的静态方法和默认方法，都不算是抽象方法；</li><li>接口默认继承 java.lang.Object ,所以如果接口声明覆盖了Object中的方法，那么也不算抽象方法；</li><li>注解不是必须的，如果接口符合函数式接口的定义，那么不加注解也没有影响。加上则编译器可以进行检查。如果不是函数接口而加上了注解，则编译器会报错。</li></ul><h3 id="3-函数式编程"><a href="#3-函数式编程" class="headerlink" title="3.  函数式编程"></a>3.  函数式编程</h3><p>函数编程特性：</p><p><strong>a. 闭包与高阶函数</strong><br>函数编程支持函数作为第一类对象，有时称为 闭包或者 仿函数（functor）对象。实质上，闭包是起函数的作用并可以像对象一样操作的对象。高阶函数可以用另一个函数作为其输入参数，也可以返回一个函数作为其输出参数。</p><p><strong>b. 惰性计算</strong><br>在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算。延迟的计算可以编写可能潜在地生成无穷输出的函数。因为不会计算多于程序的其余部分所需要的值，所以不需要担心由无穷计算所导致的 out-of-memory 错误。</p><p><strong>c. 没有“副作用”</strong><br>所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p><blockquote><p>综上所述，函数式编程可以简言之是： 使用不可变值和函数， 通过函数对一个值进行处理， 映射成另一个值。这个值在面向对象语言中可以理解为对象，另外这个值还可以作为函数的输入。</p></blockquote><p>Java8 中的函数式编程</p><ul><li>内建的函数式接口</li><li>Optional API</li><li>Lambda表达式</li><li>Stream API</li></ul><h4 id="3-1-内建的函数式接口"><a href="#3-1-内建的函数式接口" class="headerlink" title="3.1 内建的函数式接口"></a>3.1 内建的函数式接口</h4><p>Java8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。</p><table><thead><tr><th align="center">name</th><th align="center">type</th><th align="center">description</th></tr></thead><tbody><tr><td align="center">Consumer(消费者)</td><td align="center">Consumer<T></td><td align="center">接收 T 对象，不返回值</td></tr><tr><td align="center">Predicate(谓词)</td><td align="center">Predicate<T></td><td align="center">接收 T 对象并返回boolean</td></tr><tr><td align="center">Function(函数)</td><td align="center">Function&lt;T,R&gt;</td><td align="center">接收 T 对象，返回 R 对象</td></tr><tr><td align="center">Supplier(提供者)</td><td align="center">Supplier<T></td><td align="center">提供T对象，不接收值</td></tr><tr><td align="center">UnaryOperator(一元运算符)</td><td align="center">UnaryOperator<T></td><td align="center">接收T对象，返回T对象</td></tr><tr><td align="center">BinaryOperator(二元操作)</td><td align="center">BinaryOperator<T></td><td align="center">接收两个T对象，返回T对象</td></tr></tbody></table><blockquote><p>以上四种为基本的函数接口，在此之上JDK又提供了若干扩展：</p><ol><li>以上前三种添加了Bi的前缀：BiConsumer,BiPredicate,BiFunction,入参变为两个；</li><li>对Function的扩展产生了UnaryOperator(一元运算符)，接收T返回T；</li><li>对BiFunction的扩展产生了BinaryOperator(二元操作)，收两个T对象，返回T对象</li><li>增加了若干具体基本类型的接口，可参见function包下具体接口说明。</li></ol></blockquote><h4 id="3-2-Optional-API"><a href="#3-2-Optional-API" class="headerlink" title="3.2 Optional API"></a>3.2 Optional API</h4><p>Java8中引入的 Optional 是一种优雅解决NPE(NullPointExcepiton)问题的方法，是通过函数式接口实现的。</p><p>Optional 提供的方法：</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">public<U> Optional<U> map(Function&lt;? super T, ? extends U&gt; mapper)</td><td align="center">如果当前 Optional 为 Optional.empty，则依旧返回 Optional.empty；否则返回一个新的 Optional，该 Optional 包含的是：函数 mapper 在以 value 作为输入时的输出值。</td></tr><tr><td align="center">public T orElse(T other)</td><td align="center">如果有值则将其返回，否则返回一个默认值</td></tr><tr><td align="center">public T orElseGet(Supplier&lt;? extends T&gt; other)</td><td align="center">如果有值则将其返回，否则返回一个由指定的Supplier接口生成的值</td></tr></tbody></table><p>如果当前 Optional 为 Optional.empty，则依旧返回 Optional.empty；否则返回一个新的 Optional，该 Optional 包含的是：函数 mapper 在以 value 作为输入时的输出值。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git——rebase命令</title>
    <link href="/2021/11/29/Git%E2%80%94%E2%80%94rebase%E5%91%BD%E4%BB%A4/"/>
    <url>/2021/11/29/Git%E2%80%94%E2%80%94rebase%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h3><ul><li>合并多次提交记录</li><li>分支合并</li><li>对一个分支做『变基』操作</li></ul><h3 id="2-合并多次提交记录"><a href="#2-合并多次提交记录" class="headerlink" title="2. 合并多次提交记录"></a>2. 合并多次提交记录</h3><p>合并最近两次commit:</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">git</span> rebase -i HEAD~<span class="hljs-number">2</span><br></code></pre></div></td></tr></table></figure><p>执行命令后会自动进入 vi 编辑模式：</p><figure class="highlight plaintext"><figcaption><span>6935383 rename冲突</span></figcaption><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pick">pick 23b1a51 debug<br><br># Rebase eb7f366..23b1a51 onto eb7f366 (2 commands)<br>#<br># Commands:<br># p, pick &lt;commit&gt; = use commit<br># r, reword &lt;commit&gt; = use commit, but edit the commit message<br># e, edit &lt;commit&gt; = use commit, but stop for amending<br># s, squash &lt;commit&gt; = use commit, but meld into previous commit<br># f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&#x27;s log message<br># x, exec &lt;command&gt; = run command (the rest of the line) using shell<br># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)<br># d, drop &lt;commit&gt; = remove commit<br># l, label &lt;label&gt; = label current HEAD with a name<br># t, reset &lt;label&gt; = reset HEAD to a label<br># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]<br># .       create a merge commit using the original merge commit&#x27;s<br># .       message (or the oneline, if no original merge commit was<br># .       specified). Use -c &lt;commit&gt; to reword the commit message.<br>#<br># These lines can be re-ordered; they are executed from top to bottom.<br>#<br># If you remove a line here THAT COMMIT WILL BE LOST.<br>#<br># However, if you remove everything, the rebase will be aborted.<br></code></pre></div></td></tr></table></figure><blockquote><p>【注】<br>p, pick = use commit<br>r, reword = use commit, but edit the commit message<br>e, edit = use commit, but stop for amending<br>s, squash = use commit, but meld into previous commit<br>f, fixup = like “squash”, but discard this commit’s log message<br>x, exec = run command (the rest of the line) using shell<br>d, drop = remove commit</p></blockquote><p>修改提交纪录并保存退出。</p><figure class="highlight apache"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs apache"><span class="hljs-attribute">pick</span> <span class="hljs-number">6935383</span> rename冲突<br><span class="hljs-attribute">s</span> <span class="hljs-number">23</span>b<span class="hljs-number">1</span>a<span class="hljs-number">51</span> debug<br></code></pre></div></td></tr></table></figure><p>保存后到注释修改界面。</p><figure class="highlight vala"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vala"><span class="hljs-meta"># This is a combination of 2 commits.</span><br><span class="hljs-meta"># This is the 1st commit message:</span><br><br>rename冲突<br><br><span class="hljs-meta"># This is the commit message #2:</span><br><br>debug<br><br><span class="hljs-meta"># Please enter the commit message for your changes. Lines starting</span><br><span class="hljs-meta"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># Date:      Tue Nov 24 22:56:02 2020 +0800</span><br><span class="hljs-meta">#</span><br><span class="hljs-meta"># interactive rebase in progress; onto eb7f366</span><br><span class="hljs-meta"># Last commands done (2 commands done):</span><br><span class="hljs-meta">#    pick 6935383 rename冲突</span><br><span class="hljs-meta">#    squash 23b1a51 debug</span><br><span class="hljs-meta"># No commands remaining.</span><br><span class="hljs-meta"># You are currently rebasing branch &#x27;maseter&#x27; on &#x27;eb7f366&#x27;.</span><br></code></pre></div></td></tr></table></figure><p>（非编辑状态输入dd删除一行）</p><p>保存后即合并完成。</p><blockquote><p>异常情况：<br>1、不要合并已提交远程分支的纪录<br>如果这样做，可能出现push rejected。 解决方式当然是先拉下远程的代码，进行冲突处理，再进行提交。<br>2、git rebase -i 异常操作导致退出了vim编辑页面，会提示：</p><figure class="highlight applescript"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs applescript">$ git rebase -i head~<span class="hljs-number">2</span><br><span class="hljs-keyword">error</span>: could <span class="hljs-keyword">not</span> apply <span class="hljs-number">040</span>bd4b... commit <span class="hljs-keyword">on</span> issue<span class="hljs-number">-005</span><br>Resolve all conflicts manually, mark them <span class="hljs-keyword">as</span> resolved <span class="hljs-keyword">with</span><br><span class="hljs-string">&quot;git add/rm &lt;conflicted_files&gt;&quot;</span>, <span class="hljs-keyword">then</span> <span class="hljs-built_in">run</span> <span class="hljs-string">&quot;git rebase --continue&quot;</span>.<br>You can instead skip this commit: <span class="hljs-built_in">run</span> <span class="hljs-string">&quot;git rebase --skip&quot;</span>.<br>To abort <span class="hljs-keyword">and</span> <span class="hljs-keyword">get</span> <span class="hljs-keyword">back</span> <span class="hljs-keyword">to</span> <span class="hljs-keyword">the</span> state <span class="hljs-keyword">before</span> <span class="hljs-string">&quot;git rebase&quot;</span>, <span class="hljs-built_in">run</span> <span class="hljs-string">&quot;git rebase --abort&quot;</span>.<br>Could <span class="hljs-keyword">not</span> apply <span class="hljs-number">040</span>bd4b... commit <span class="hljs-keyword">on</span> issue<span class="hljs-number">-005</span><br>Auto-merging README.md<br>CONFLICT (content): Merge conflict <span class="hljs-keyword">in</span> README.md<br></code></pre></div></td></tr></table></figure><p>使用 git rebase –edit-todo 会再次进入刚才编辑错误退出前的vim状态，这时候可以修改你的编辑。<br>使用git rebase –abort  表明退出当前的合并请求( 又回到原来的2个commit的状态)</p></blockquote><h3 id="3-变基"><a href="#3-变基" class="headerlink" title="3. 变基"></a>3. 变基</h3><p>使用场景：本地与远端同一分支提交历史不一致</p><p>多个人在同一个分支上协作时，比如由我和A一同开发。我在修复了一个bug以后准备提交。</p><figure class="highlight vim"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs vim">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">add</span> .<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git commit -<span class="hljs-keyword">m</span> <span class="hljs-string">&quot;debug the world&quot;</span><br>[master a40d43c] <span class="hljs-keyword">debug</span> the world<br> <span class="hljs-number">1</span> <span class="hljs-keyword">file</span> changed, <span class="hljs-number">0</span> insertions(+), <span class="hljs-number">0</span> deletions(-)<br> create <span class="hljs-keyword">mode</span> <span class="hljs-number">100644</span> aa.txt<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git push origin master<br>To github.<span class="hljs-keyword">com</span>:Zhangtao153/learngit.git<br> ! [rejected]        master -&gt; master (non-fast-forward)<br>error: failed <span class="hljs-keyword">to</span> push some refs <span class="hljs-keyword">to</span> <span class="hljs-string">&#x27;github.com:Zhangtao153/learngit.git&#x27;</span><br>hin<span class="hljs-variable">t:</span> Updates were rejected because the tip of your current branch <span class="hljs-keyword">is</span> behind<br>hin<span class="hljs-variable">t:</span> its remote counterpart. Integrate the remote <span class="hljs-keyword">changes</span> (<span class="hljs-keyword">e</span>.g.<br>hin<span class="hljs-variable">t:</span> <span class="hljs-string">&#x27;git pull ...&#x27;</span>) before pushing again.<br>hin<span class="hljs-variable">t:</span> See the <span class="hljs-string">&#x27;Note about fast-forwards&#x27;</span> in <span class="hljs-string">&#x27;git push --help&#x27;</span> <span class="hljs-keyword">for</span> details.<br></code></pre></div></td></tr></table></figure><p>push失败了，说明A在我之前已经提交了，我本地master分支的提交历史已经落后远端了，需要先pull一下，与远端同步后才能push</p><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git pull<br>Merge made <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> README.md | <span class="hljs-number">3</span> ++-<br> <span class="hljs-number">1</span> <span class="hljs-built_in">file</span> changed, <span class="hljs-number">2</span> insertions(+), <span class="hljs-number">1</span> deletion(-)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--oneline --graph</span><br>*   <span class="hljs-number">912</span>bb85 (HEAD -&gt; master) Merge branch <span class="hljs-string">&#x27;master&#x27;</span> <span class="hljs-keyword">of</span> github.com:Zhangtao153/learngit <span class="hljs-keyword">into</span> master<br>|\<br>| * <span class="hljs-number">7</span>ad4fd6 (origin/master) <span class="hljs-built_in">add</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span><br>* | a40d43c debug <span class="hljs-keyword">the</span> world<br>|/<br>* a8d2e0d 手动删除<br>* <span class="hljs-number">1</span>d243ca <span class="hljs-built_in">add</span> test <span class="hljs-built_in">file</span><br>* <span class="hljs-number">8438389</span> wrote <span class="hljs-keyword">a</span> readme <span class="hljs-built_in">file</span><br></code></pre></div></td></tr></table></figure><p>竟然分叉了！由于我本地master的提交历史和远端的master分支的提交历史不一致，所以git为我进行了自动合并，然后生成了一个新的提交历史。</p><p>这个时候就可以用 git rebase 解决分叉的问题。</p><figure class="highlight gams"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gams"><span class="hljs-symbol">$</span> git rebase<br>Successfully rebased <span class="hljs-keyword">and</span> updated refs/heads/master.<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br><span class="hljs-symbol">$</span> git <span class="hljs-built_in">log</span> --oneline --graph<br><span class="hljs-comment">* 4178b6e (HEAD -&gt; master) debug the world</span><br><span class="hljs-comment">* 7ad4fd6 (origin/master) add a new function</span><br><span class="hljs-comment">* a8d2e0d 手动删除</span><br><span class="hljs-comment">* 1d243ca add test file</span><br><span class="hljs-comment">* 8438389 wrote a readme file</span><br></code></pre></div></td></tr></table></figure><p>然后再push，将本地修改同步到远端。</p><p>git pull –rebase 和上面的效果一致。</p><h3 id="4-合并分支"><a href="#4-合并分支" class="headerlink" title="4. 合并分支"></a>4. 合并分支</h3><p>先创建一个分支用于解决bug</p><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">$ git checkout -b issues<span class="hljs-number">-001</span><br>Switched <span class="hljs-built_in">to</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> branch <span class="hljs-string">&#x27;issues-001&#x27;</span><br></code></pre></div></td></tr></table></figure><p>接下解决bug，然后保存提交</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (issues-<span class="hljs-number">001</span>)<br>$ git add .<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (issues-<span class="hljs-number">001</span>)<br>$ git commit -m <span class="hljs-string">&quot;issues-001&quot;</span><br>[issues-<span class="hljs-number">001</span> <span class="hljs-number">7</span>a55a26] issues-<span class="hljs-number">001</span><br> <span class="hljs-number">1</span> <span class="hljs-keyword">file</span> changed, <span class="hljs-number">1</span> insertion(+)<br></code></pre></div></td></tr></table></figure><p>先尝试通过 merge 合并：</p><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issues<span class="hljs-number">-001</span>)<br>$ git <span class="hljs-keyword">switch</span> master<br>Switched <span class="hljs-built_in">to</span> branch <span class="hljs-string">&#x27;master&#x27;</span><br>Your branch is ahead <span class="hljs-keyword">of</span> <span class="hljs-string">&#x27;origin/master&#x27;</span> <span class="hljs-keyword">by</span> <span class="hljs-number">1</span> commit.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> <span class="hljs-built_in">to</span> publish your <span class="hljs-built_in">local</span> commits)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">merge</span> issues<span class="hljs-number">-001</span><br>Merge made <span class="hljs-keyword">by</span> <span class="hljs-keyword">the</span> <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> aa.txt | <span class="hljs-number">1</span> +<br> <span class="hljs-number">1</span> <span class="hljs-built_in">file</span> changed, <span class="hljs-number">1</span> insertion(+)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--oneline --graph</span><br>*   ae02ea0 (HEAD -&gt; master) Merge branch <span class="hljs-string">&#x27;issues-001&#x27;</span> <span class="hljs-keyword">into</span> master<br>|\<br>| * <span class="hljs-number">7</span>a55a26 (issues<span class="hljs-number">-001</span>) issues<span class="hljs-number">-001</span><br>* | d36d166 commit <span class="hljs-keyword">on</span> <span class="hljs-title">master</span><br>|/<br>* <span class="hljs-number">4178</span>b6e (origin/master) debug <span class="hljs-keyword">the</span> world<br>* <span class="hljs-number">7</span>ad4fd6 <span class="hljs-built_in">add</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span><br>* a8d2e0d 手动删除<br>* <span class="hljs-number">1</span>d243ca <span class="hljs-built_in">add</span> test <span class="hljs-built_in">file</span><br>* <span class="hljs-number">8438389</span> wrote <span class="hljs-keyword">a</span> readme <span class="hljs-built_in">file</span><br></code></pre></div></td></tr></table></figure><p>虽然合并成功，但是Master已经保存了合并历史，出现开叉了！</p><p>通过rebase合并分支</p><p>先将代码回退到merge之前</p><figure class="highlight pgsql"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs pgsql">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-keyword">reset</span> <span class="hljs-comment">--hard HEAD^</span><br>HEAD <span class="hljs-keyword">is</span> now at d36d166 <span class="hljs-keyword">commit</span> <span class="hljs-keyword">on</span> master<br></code></pre></div></td></tr></table></figure><p>先切换回issues-001分支，在issues-001分支上执行: git rebase master</p><figure class="highlight gradle"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs gradle">Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (master)<br>$ git <span class="hljs-keyword">switch</span> issues-<span class="hljs-number">001</span><br>Switched to branch <span class="hljs-string">&#x27;issues-001&#x27;</span><br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (issues-<span class="hljs-number">001</span>)<br>$ git rebase master<br>Successfully rebased and updated refs<span class="hljs-regexp">/heads/i</span>ssues-<span class="hljs-number">001</span>.<br></code></pre></div></td></tr></table></figure><p>【注】如果rebase出现冲突，先解决冲突，然后通过add添加，之前的rebase其实只是完成了一半，由于出现冲突而终止，冲突解决之后，可以通过git rebase —continue继续完成之前的rebase操作。</p><p>切换到主分支master，将issues-001分支上的提交合并过来。</p><figure class="highlight livecodeserver"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs livecodeserver">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issues<span class="hljs-number">-001</span>)<br>$ git <span class="hljs-keyword">switch</span> master<br>Switched <span class="hljs-built_in">to</span> branch <span class="hljs-string">&#x27;master&#x27;</span><br>Your branch is ahead <span class="hljs-keyword">of</span> <span class="hljs-string">&#x27;origin/master&#x27;</span> <span class="hljs-keyword">by</span> <span class="hljs-number">1</span> commit.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> <span class="hljs-built_in">to</span> publish your <span class="hljs-built_in">local</span> commits)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">merge</span> issues<span class="hljs-number">-001</span><br>Updating d36d166.<span class="hljs-number">.43823</span>d4<br>Fast-forward<br> aa.txt | <span class="hljs-number">1</span> +<br> <span class="hljs-number">1</span> <span class="hljs-built_in">file</span> changed, <span class="hljs-number">1</span> insertion(+)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> <span class="hljs-comment">--oneline --graph</span><br>* <span class="hljs-number">43823</span>d4 (HEAD -&gt; master, issues<span class="hljs-number">-001</span>) issues<span class="hljs-number">-001</span><br>* d36d166 commit <span class="hljs-keyword">on</span> <span class="hljs-title">master</span><br>* <span class="hljs-number">4178</span>b6e (origin/master) debug <span class="hljs-keyword">the</span> world<br>* <span class="hljs-number">7</span>ad4fd6 <span class="hljs-built_in">add</span> <span class="hljs-keyword">a</span> <span class="hljs-built_in">new</span> <span class="hljs-function"><span class="hljs-keyword">function</span></span><br>* a8d2e0d 手动删除<br>* <span class="hljs-number">1</span>d243ca <span class="hljs-built_in">add</span> test <span class="hljs-built_in">file</span><br>* <span class="hljs-number">8438389</span> wrote <span class="hljs-keyword">a</span> readme <span class="hljs-built_in">file</span><br></code></pre></div></td></tr></table></figure><p>master是一条直线了。最后删除掉issues-001分支。</p><figure class="highlight awk"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs awk">Administrator@WIN-DTNF3GRDH5R MINGW64 <span class="hljs-regexp">/g/</span>learngit (master)<br>$ git branch -d issues-<span class="hljs-number">001</span><br>Deleted branch issues-<span class="hljs-number">001</span> (was <span class="hljs-number">43823</span>d4).<br></code></pre></div></td></tr></table></figure><p>​</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——java8新特性之Lambda 表达式</title>
    <link href="/2021/11/28/java%E2%80%94%E2%80%94jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/11/28/java%E2%80%94%E2%80%94jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>lambda 表达式本质上是一段匿名内部类，也可以是一段可以传递的代码</p><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h4><p>完整的 Lambda 表达式由三部分组成：参数列表、箭头、声明语句；</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"> (Type1 param1, Type2 param2, ..., TypeN paramN) ‐&gt; &#123; statment1;<br>statment2; <span class="hljs-comment">//............. return statmentM;&#125;</span><br></code></pre></div></td></tr></table></figure><ol><li>绝大多数情况，编译器都可以从上下文环境中推断出lambda表达式的参数类型，所以参数可以省略：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">(param1,param2, ..., paramN) ‐&gt; &#123; statment1; statment2; <span class="hljs-comment">//............. r</span><br>eturn statmentM;&#125;<br></code></pre></div></td></tr></table></figure></li><li>当lambda表达式的参数个数只有一个，可以省略小括号：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">param1 ‐&gt; &#123; statment1; statment2; <span class="hljs-comment">//............. return statmentM;&#125;</span><br></code></pre></div></td></tr></table></figure></li><li>当lambda表达式只包含一条语句时，可以省略大括号、return和语句结尾的分号：<figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">param1 ‐&gt; statment<br></code></pre></div></td></tr></table></figure></li></ol><h4 id="2-函数接口"><a href="#2-函数接口" class="headerlink" title="2. 函数接口"></a>2. 函数接口</h4><p>函数接口是只有一个抽象方法的接口， 用作 Lambda 表达式的返回类型。<br>包路径为 java.util.function 接口类上面都有@FunctionalInterface这个注解。</p><h4 id="3-类型检查、类型推断"><a href="#3-类型检查、类型推断" class="headerlink" title="3.  类型检查、类型推断"></a>3.  类型检查、类型推断</h4><p>Java编译器根据 Lambda 表达式上下文信息就能推断出参数的正确类型。 程序依然要经过类型检查来保证运行的安全性， 但不用再显式声明类型罢了。 这就是所谓的类型推断。</p><h4 id="4-局部变量限制"><a href="#4-局部变量限制" class="headerlink" title="4.  局部变量限制"></a>4.  局部变量限制</h4><p>Lambda表达式也允许使用自由变量（不是参数，而是在外层作用域中定义的变量），就像匿名类一样。 它们被称作捕获Lambda。 Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为final，或事实上是final。</p><p>Lambda 表达式访问外部变量：</p><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String[] strings = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;;<br>    <span class="hljs-keyword">for</span> (Integer i : Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)) &#123;<br>        Stream.of(strings).map(string -&gt; string + i).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></div></td></tr></table></figure><blockquote><p>为什么局部变量有这些限制？<br>实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。因此， Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter hljs"><div class="hljs code-wrapper"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></div></td><td class="code"><div class="hljs code-wrapper"><pre><code class="hljs java">String[] strings = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>    Stream.of(strings).map(string -&gt; string + i).forEach(System.out::println);<br>&#125;<br></code></pre></div></td></tr></table></figure><p><strong>上面的代码会报编译错误，lambda 表达式引用的变量需要时final或等效final的变量。</strong></p><h4 id="5-Lambda表达式的方法和构造器引用"><a href="#5-Lambda表达式的方法和构造器引用" class="headerlink" title="5.  Lambda表达式的方法和构造器引用"></a>5.  Lambda表达式的方法和构造器引用</h4><p>方法引用的语法格式有以下三种：</p><ol><li>objectName::instanceMethod</li><li>ClassName::staticMethod</li><li>ClassName::instanceMethod</li></ol><blockquote><p>前两种等同于把lambda表达式的参数当成 instanceMethod | staticMethod 的参数来调用。<br>例如： Math::max等同于(x, y)-&gt;Math.max(x,y)</p><p>后一种等于把lambda表达式的第一个参数当成instanceMethod 的目标对象，其他参数当成该方法的参数。<br>例如： String::toLowerCase() 等同于 x-&gt;x.toLowerCase()</p></blockquote><p><em>构造器引用语法如下</em></p><p>ClassName::new</p><blockquote><p>把 lambda 表达式的参数当成 ClassName 构造器的参数。例如： BigDecimal::new 等同于 x-&gt;new BigDecimal(x)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis——入门</title>
    <link href="/2021/11/28/Redis%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"/>
    <url>/2021/11/28/Redis%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-NoSQL介绍"><a href="#1-NoSQL介绍" class="headerlink" title="1.  NoSQL介绍"></a>1.  NoSQL介绍</h2><p>NoSQL （Not Only SQL）指的是非关系型的数据库，是对不同于传统的关系型数据库的数据库管理系统的统称。NoSQL用于超大规模数据的存储。Redis就属于非关系型数据库,传统的Mysql ,oracle ,sql server 等 都是关系型数据库。</p><h2 id="2-为什么需要NoSQL"><a href="#2-为什么需要NoSQL" class="headerlink" title="2. 为什么需要NoSQL"></a>2. 为什么需要NoSQL</h2><p>主要应对以下问题时，传统关系型数据库力不从心</p><p>  高并发读写<br>  海量数据的高效率存储和访问<br>  高可扩展性和高可用性</p><h2 id="3-Redis-简介"><a href="#3-Redis-简介" class="headerlink" title="3. Redis 简介"></a>3. Redis 简介</h2><p>Redis 是一个高性能的 key-value 数据库。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><p>Redis 与其他 key - value 缓存产品相比有以下三个特点：<br>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。<br>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>Redis支持数据的备份，即master-slave模式的数据备份。<br>Redis的应用场景<br>缓存<br>任务队列<br>网站访问统计<br>数据过期处理<br>应用排行榜<br>分布式集群架构中的session分离<br>Redis 支持的五种数据类型：<br>字符串（String）<br>字符串列表（list）<br>哈希（hash）<br>字符串集合（set）<br>有序字符串集合（zset）</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
