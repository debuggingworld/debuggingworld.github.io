<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>NLP——RNN、LSTM、GRU、CNN、Seq2Seq</title>
    <link href="/2024/08/10/NLP%E2%80%94%E2%80%94RNN%E3%80%81LSTM%E3%80%81GRU%E3%80%81CNN%E3%80%81Seq2Seq/"/>
    <url>/2024/08/10/NLP%E2%80%94%E2%80%94RNN%E3%80%81LSTM%E3%80%81GRU%E3%80%81CNN%E3%80%81Seq2Seq/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Encoder-Decoder-模型"><a href="#1-Encoder-Decoder-模型" class="headerlink" title="1. Encoder-Decoder 模型"></a>1. Encoder-Decoder 模型</h3><p>​    Encoder-Decoder 是 NLP 领域的概念，它并不特指某种具体的算法，而是一类算法的统称，称之为 Encoder-Decoder 结构更合适。Encoder-Decoder 算是一个通用的框架，在这个框架下可以使用不同的算法来解决不同的任务。Encoder-Decoder 这个框架很好的诠释了机器学习的核心思路：</p><blockquote><p>将现实问题转化为数学问题，通过求解数学问题，从而解决现实问题。</p></blockquote><p><code>Encoder</code> 又称作编码器。它的作用就是“将现实问题转化为数学问题“：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082017205.png" style="zoom:30%;" /></center><p><code>Decoder</code> 又称作解码器，它的作用是“求解数学问题，并转化为现实世界的解决方案”：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082019337.png" style="zoom:30%;" /></center><p>把两个环节连接起来，用通用的图来表达则是下面的样子：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082020548.png" style="zoom:30%;" /></center><p>关于 Encoder-Decoder，有两点需要说明：</p><ul><li>不论输入和输出的长度是多少，中间的“向量 C”长度都是固定的</li><li>根据不同的任务可以选择不同的编码器和解码器（可以是一个 RNN ，但通常是其变种 LSTM 或者 GRU ）</li></ul><blockquote><p>只要是符合上面的框架，都可以统称为 Encoder-Decoder 模型。具体实现 Encoder-Decoder 的时候，编码器和解码器都不是固定的，可选的有 CNN/RNN/BiRNN/GRU/LSTM 等等，你可以自由组合。比如说，你在编码时使用 BiRNN，解码时使用RNN，或者在编码时使用 RNN，解码时使用 LSTM 等等。</p></blockquote><p>当然提到 Encoder-Decoder 模型就经常提到一个名词——Seq2Seq。其实 Encoder-Decoder 和 Seq2Seq 几乎就是等价的，只不过 Encoder-Decoder 是一种抽象的框架概念，Seq2Seq 是具体的一种实现。</p><h3 id="2-Seq2Seq"><a href="#2-Seq2Seq" class="headerlink" title="2. Seq2Seq"></a>2. Seq2Seq</h3><p>​    Seq2Seq（即 Sequence-to-sequence），输入一个序列，输出另一个序列。这种结构最重要的地方在于输入序列和输出序列的长度是可变的。例如下图：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408092150188.gif" style="zoom:70%;" /></center><p>如上图：输入了 6 个汉字，输出了 3 个英文单词。输入和输出的长度不同。</p><p><strong>Seq2Seq 的由来</strong></p><p>在 Seq2Seq 框架提出之前，深度神经网络在图像分类等问题上取得了非常好的效果。在其擅长解决的问题中，输入和输出通常都可以表示为固定长度的向量，如果长度稍有变化，会使用补零等操作。</p><p>然而许多重要的问题，例如机器翻译、语音识别、自动对话等，表示成序列后，其长度事先并不知道。因此如何突破先前深度神经网络的局限，使其可以适应这些场景，成为了13年以来的研究热点，Seq2Seq框架应运而生。</p><p><strong>「Seq2Seq」和「Encoder-Decoder」的关系</strong></p><p>Seq2Seq（强调目的）不特指具体方法，满足「输入序列、输出序列」的目的，都可以统称为 Seq2Seq 模型。</p><p>而 Seq2Seq 使用的具体方法基本都属于 Encoder-Decoder 模型（强调方法）的范畴。</p><p>总结一下的话：</p><ul><li>Seq2Seq 属于 Encoder-Decoder 的大范畴</li><li>Seq2Seq 更强调目的，Encoder-Decoder 更强调方法</li></ul><p><a href="https://easyai.tech/ai-definition/encoder-decoder-seq2seq/">传送门</a></p><h3 id="3-RNN"><a href="#3-RNN" class="headerlink" title="3. RNN"></a>3. RNN</h3><p>​    RNN 即 Recurrent Neural Network，循环神经网络，也有人将它翻译为递归神经网络。从这个名字就可以想到，它的结构中存在着“环”。确实，RNN 和 NN/DNN 的数据单一方向传递不同。RNN 的神经元接受的输入除了“前辈”的输出，还有自身的状态信息，其状态信息在网络中循环传递。</p><h4 id="3-1-单层网络"><a href="#3-1-单层网络" class="headerlink" title="3.1 单层网络"></a>3.1 单层网络</h4><p>首先来了解一下最基本的单层网络，它的结构如图：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082027402.png" style="zoom:33%;" /></center><p><code>输入是 x</code>，经过<code>变换Wx+b</code> 和 <code>激活函数f</code> 得到<code>输出y</code>。</p><blockquote><p><code>w</code> 是模型的权重参数，它决定了每个输入特征对输出的贡献程度。<code>b</code> 是模型的偏置参数，它控制着输出的整体水平。</p></blockquote><h4 id="3-2-RNN结构（N-vs-N）"><a href="#3-2-RNN结构（N-vs-N）" class="headerlink" title="3.2 RNN结构（N vs N）"></a>3.2 RNN结构（N vs N）</h4><p>在实际应用中，我们还会遇到很多序列型的数据：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082035078.png" style="zoom:33%;" /></center><p>如：</p><ul><li>自然语言处理问题。x1 可以看做是第一个单词，x2 可以看做是第二个单词，依次类推。</li><li>语音处理。此时，x1、x2、x3……是每帧的声音信号。</li></ul><p>序列型的数据就不太好用原始的神经网络处理了。为了建模序列问题，RNN 引入了隐状态 h（hidden state）的概念，h 可以对序列形的数据提取特征，接着再转换为输出。先从h1的计算开始看：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082041437.png" style="zoom:33%;" /></center><ul><li>h1: 表示 t=1 时刻的隐状态</li><li>U: 输入层到隐含层的权值矩阵</li><li>x1: t=1 时刻的输入状态</li><li>W: 隐含层到隐含层的权值矩阵</li><li>b: 偏置元</li><li>f: 激活函数</li></ul><p>图示中记号的含义是：</p><ul><li>圆圈或方块表示的是向量。</li><li><code>一个箭头就表示对该向量做一次变换</code>。如上图中 h0 和 x1 分别有一个箭头连接，就表示对 h0 和 x1 各做了一次变换。</li></ul><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082100270.png" style="zoom:33%;" /></center><p>h2 的计算和 h1类似。要注意的是，<code>在计算时，每一步使用的参数 U、W、b 都是一样的，也就是说每个步骤的参数都是共享的</code>，这是 RNN 的重要特点，一定要牢记。</p><blockquote><p>注意：图中的 h 并不是一个神经元，而是一个神经网络块，可以简单理解为神经网络的一个隐层。</p></blockquote><p>依次计算剩下来的 h3、h4（使用相同的参数U、W、b）：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082101771.png" style="zoom:33%;" /></center><p>目前我们的 RNN 还没有输出，得到输出值的方法就是直接通过 h 进行计算。正如之前所说，一个箭头就表示对对应的向量做一次类似于 f(Wx+b) 的变换，这里的这个箭头就表示对 h1进行一次变换，得到输出 y1：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082102386.png" style="zoom:33%;" /></center><ul><li>y1：表示 t=1 时刻的输出状态</li><li>softmax：是一种激活函数，它可以把输入转化为概率分布的形式</li><li>V：隐含层到输出层的权值矩阵</li><li>h1：t=1 时刻的隐状态</li><li>c：偏置元</li></ul><p>剩下的输出类似进行（使用和y1同样的参数V和c）：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082106129.png" style="zoom: 33%;" /></center><p>OK！大功告成！这种输入序列长度为 N 且输出序列长度也为 N 的 RNN 就是最经典的 RNN 结构，我们像搭积木一样把它搭好了。它的输入是 x1, x2, …xn，输出为 y1, y2, …yn，也就是说，输入和输出序列必须要是等长的。</p><p>由于这个限制的存在，经典 RNN 的适用范围比较小，但也有一些问题适合用经典的 RNN 结构建模，如：</p><ul><li>计算视频中每一帧的分类标签。因为要对每一帧进行计算，因此输入和输出序列等长。</li><li>输入为字符，输出为下一个字符的概率。</li></ul><h4 id="3-3-N-VS-1"><a href="#3-3-N-VS-1" class="headerlink" title="3.3 N VS 1"></a>3.3 N VS 1</h4><p>​    有的时候，我们要处理的问题输入是一个序列，输出是一个单独的值而不是序列，应该怎样建模呢？实际上，我们只在最后一个h上进行输出变换就可以了：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082113077.png" style="zoom:33%;" /></center><p>这种结构通常用来处理序列分类问题。如输入一段文字判别它所属的类别，输入一个句子判断其情感倾向，输入一段视频并判断它的类别等等。</p><h4 id="3-4-1-VS-N"><a href="#3-4-1-VS-N" class="headerlink" title="3.4 1 VS N"></a>3.4 1 VS N</h4><p>输入不是序列而输出为序列的情况怎么处理？我们可以只在序列开始进行输入计算：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082115557.png" style="zoom:33%;" /></center><p>还有一种结构是把输入信息X作为每个阶段的输入（右图省略了一些X的圆圈，是一个等价表示）：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082118203.png" style="zoom:33%;" /></center><p>这种1 VS N的结构可以处理的问题有：</p><ul><li>从图像生成文字（image caption），此时输入的X就是图像的特征，而输出的y序列就是一段句子</li><li>从类别生成语音或音乐等</li></ul><h4 id="3-5-N-vs-M"><a href="#3-5-N-vs-M" class="headerlink" title="3.5 N vs M"></a>3.5 N vs M</h4><p>下面我们来介绍 RNN 最重要的一个变种：N vs M。</p><p>原始的 N vs N RNN 要求序列等长，然而我们遇到的大部分问题序列都是不等长的，如机器翻译中，源语言和目标语言的句子往往并没有相同的长度。</p><p>为此，Encoder-Decoder 结构先将输入数据编码成一个上下文向量c（context vector）：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082119369.png" style="zoom:30%;" /></center><p>得到 c 有多种方式，最简单的方法就是把 Encoder 的最后一个隐状态赋值给c，还可以对最后的隐状态做一个变换得到 c，也可以对所有的隐状态做变换，可以表示为下面三种方式：</p><ul><li>c = h <sub>4</sub></li><li>c = f(h <sub>4</sub>)</li><li>c= g(h <sub>1</sub>,h <sub>2</sub>,h <sub>3</sub>,h <sub>4</sub>)</li></ul><p>拿到 c 之后，就用另一个 RNN 网络对其进行解码，这部分 RNN 网络被称为 Decoder。具体做法就是将 c 当做之前的初始状态 h0 输入到Decoder 中：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082128634.png" style="zoom:50%;" /></center><p>还有一种做法是将c当做每一步的输入：</p><center><img src="https://i-blog.csdnimg.cn/blog_migrate/a94c808e4734a3b0482c20e027b2c88c.png" alt="decoder" style="zoom:50%;" /></center><p>Decoder 是 Encoder 的逆过程，每个状态由之前的状态和 context vector 决定，即：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408082131791.png" style="zoom:50%;" /></center><p>由于这种 Encoder-Decoder 结构不限制输入和输出的序列长度，因此应用的范围非常广泛，比如：</p><ul><li>机器翻译。Encoder-Decoder 的最经典应用，事实上这一结构就是在机器翻译 - 领域最先提出的</li><li>文本摘要。输入是一段文本序列，输出是这段文本序列的摘要序列。</li><li>阅读理解。将输入的文章和问题分别编码，再对其进行解码得到问题的答案。</li><li>语音识别。输入是语音信号序列，输出是文字序列。<br>……</li></ul><p>上面提到：Encoder 和 Decoder 之间只有一个「向量 C」来传递信息，且 C 的长度固定。这样做有两个弊端：</p><ol><li>语义向量无法完全表示整个序列的信息。</li><li>当句子长度较大时，容易丢失信息。</li></ol><p>针对信息丢失这个问题，后面提出了 Seq2Seq+Attention 的模型。</p><h3 id="4-LSTM"><a href="#4-LSTM" class="headerlink" title="4. LSTM"></a>4. LSTM</h3><p>​    长短时记忆（Long Short Term Memory，LSTM）</p><p>​    LSTM也是一种RNN，因此它也是一种循环结构，不同的是RNN神经元内部只用tan层进行计算，而LSTM是有4个全连接层进行计算的，LSTM的内部结构如下图所示。</p><p>​    相较于构造简单的 RNN 神经元，LSTM 的神经元要复杂得多，每个神经元接受的输入除了当前时刻样本输入，上一个时刻的输出，还有一个元胞状态（Cell State），LSTM 神经元结构请参见下图：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408092042460.png" style="zoom:80%;" /></center><p>​    上图中符号的含义如下图所示，黄色方框类似于CNN中的激活函数操作，粉色圆圈表示点操作，单箭头表示数据流向，下图中第四个符号表示两个向量的连接操作，第五个符号表示向量的拷贝操作，且上图中的σ表示sigmoid层(该层的输出时0-1的值，0表示不能通过，1表示能通过)。 </p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408092043785.png" style="zoom:80%;" /></center><p>​    现在来描述LSTM的内部操作，具体内容如下图所示：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408092044477.png" style="zoom:60%;" /></center><p>​    LSTM的核心是细胞状态——最上层的横穿整个细胞的水平线，它通过门来控制信息的增加或者删除。</p><p>　　那么什么是门呢？门是一种用来选择信息通过与否的方式，它由一个sigmoid层和点乘操作组成。LSTM共有三个门，分别是遗忘门，输入门和输出门，具体内容如下所述：</p><p>　　(1)遗忘门：遗忘门决定丢弃哪些信息，输入是上一个神经元细胞的计算结果ht-1以及当前的输入向量xt,二者联接并通过遗忘门后(sigmoid会决定哪些信息留下，哪些信息丢弃)，会生成一个0-1向量Γft(维度与上一个神经元细胞的输出向量Ct-1相同)，Γft与Ct-1进行点乘操作后，就会获取上一个神经元细胞经过计算后保留的信息。遗忘门控制前一步记忆单元中的信息有多大程度被遗忘掉。</p><p>　　(2)输入门：表示要保存的信息或者待更新的信息，如上图所示是ht-1与xt的连接向量，经过sigmoid层后得到的结果Γit，这就是输入门的输出结果了。但是接下来我们要计算该神经元细胞的输出结果，即新细胞的更新状态：Ct，Ct = Ct-1· Γft + Γit · <del>ct(其中</del>ct = tanh(ht-1，xt))，文字描述是：输入门的计算结果点乘 ht-1与xt的连接向量经过tanh层计算的结果后，再与上一个神经元细胞经过计算后保留的信息进行相加，则是最终要输出的Ct。输入门控制当前计算的新状态以多大程度更新到记忆单元中。</p><p>　　(3)输出门：输出门决定当前神经原细胞输出的隐向量ht，ht与Ct不同，ht要稍微复杂一点，它是Ct进过tanh计算后与输出门的计算结果进行点乘操作后的结果，用公式描述是：ht = tanh(ct) · Γot。输出门控制当前的输出有多大程度上取决于当前的记忆单元。</p><p>　　在一个训练好的网络中，当输入的序列中没有重要信息时，LSTM的遗忘门的值接近于1，输入门的值接近于0，此时过去的记忆会被保存，从而实现了长期记忆的功能；当输入的序列中出现了重要的信息时，LSTM应当把其存入记忆中，此时其输入门的值会接近于1；当输入的序列中出现了重要信息，且该信息意味着之前的记忆不再重要时，输入门的值接近于1，而遗忘门的值接近于0，这样旧的记忆被遗忘，新的重要信息被记忆。经过这样的设计，整个网络更容易学习到序列之间的长期依赖。</p><h4 id="4-1-LSTM如何避免梯度消失与梯度爆炸"><a href="#4-1-LSTM如何避免梯度消失与梯度爆炸" class="headerlink" title="4.1 LSTM如何避免梯度消失与梯度爆炸"></a>4.1 LSTM如何避免梯度消失与梯度爆炸</h4><p>　　RNN 中的梯度消失/爆炸与 CNN 中的含义不同，CNN 中不同的层有不同的参数，每个参数都有自己的梯度；而 RNN 中同样的权重在各个时间步中共享，所以最终的梯度等于各个时间步的梯度和。因此，RNN 中的梯度不会消失，它只会遗忘远距离的依赖关系，而被近距离的梯度所主导。但是 LSTM 中的梯度传播有很多条路径，最主要的一条是当前细胞的状态更新这一过程，该过程中只有逐元素的相乘和相加操作，梯度流最稳定，因此基本不会发生梯度消失或者梯度爆炸；但是其他的传播路径依然有梯度消失或者爆炸风险，而最终的梯度计算是各个梯度路径的和，因此 LSTM 仍然有梯度消失或者爆炸的风险，只是这个风险被大幅降低了。</p><h4 id="4-2-总结"><a href="#4-2-总结" class="headerlink" title="4.2 总结"></a>4.2 总结</h4><p>　LSTM 优点：LSTM 降低了梯度消失或者梯度爆炸的风险，并且比 RNN 具有更强的长距离依赖能力。</p><p>　LSTM 缺点：</p><ul><li>LSTM 处理长距离依赖的能力依然不够，因此 Transformer 横空出世，它具有比 LSTM 更强的长距离依赖处理能力。</li><li>它的计算很费时。每个细胞中都有 4 个全连接层 (MLP)，因此如果 LSTM 的时间跨度很大的话，计算量会很大也很费时。</li></ul><p><a href="https://www.cnblogs.com/liuxiaochong/p/13423872.html">LSMT理解</a></p><p><a href="http://zh.gluon.ai/chapter_recurrent-neural-networks/lstm.html">（传送门）</a></p><h3 id="5-GRU"><a href="#5-GRU" class="headerlink" title="5. GRU"></a>5. GRU</h3><p>​    GRU（Gate Recurrent Unit，循环门单元）是循环神经网络（Recurrent Neural Network, RNN）的一种。和LSTM（Long-Short Term Memory）一样，也是为了解决长期记忆和反向传播中的梯度等问题而提出来的。</p><p>　　在LSTM中引入了三个门函数：输入门、遗忘门和输出门来控制输入值、记忆值和输出值。而在GRU模型中只有两个门：分别是更新门和重置门。具体结构如下图所示：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408092202261.png" style="zoom:60%;" /></center><p>​    图中的zt和rt分别表示更新门和重置门。更新门用于控制前一时刻的状态信息被带入到当前状态中的程度，更新门的值越大说明前一时刻的状态信息带入越多。重置门控制前一状态有多少信息被写入到当前的候选集 ℎ̃<em>t</em>上，重置门越小，前一状态的信息被写入的越少。</p><p>　　GRU组合了遗忘门和输入门到一个单独的更新门当中，也合并了细胞状态 C和隐藏状态h，并且还做了一些其他的改变，使得其模型比标准LSTM模型更简单，其数学表达式为：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408092204759.png"></p><p>​    其中，门控信号zt的范围为0~1。门控信号越接近1，代表”记忆“下来的数据越多；而越接近0则代表”遗忘“的越多。</p><h3 id="6-CNN"><a href="#6-CNN" class="headerlink" title="6. CNN"></a>6. CNN</h3><p>​    CNN 是一种前馈神经网络，通常由一个或多个卷积层（Convolutional Layer）和全连接层（Fully Connected Layer，对应经典的 NN）组成，此外也会包括池化层（Pooling Layer）。</p><p>​    CNN 的结构使得它易于利用输入数据的二维结构。</p><blockquote><p>注意：前馈神经网络（Feedforward NN）指每个神经元只与前一层的神经元相连，数据从前向后单向传播的 NN。其内部结构不会形成有向环（对比后面要讲到的 RNN/LSTM）。 它是最早被发明的简单 NN 类型，前面讲到的 NN、DNN 都是前馈神经网络。</p></blockquote><p>​    每个卷积层由若干卷积单元组成——可以想象成经典 NN 的神经元，只不过激活函数变成了卷积运算。</p><p>​    卷积运算是有其严格的数学定义的。不过在 CNN 的应用中，卷积运算的形式是数学中卷积定义的一个特例，它的目的是提取输入的不同特征。</p><p>​    一般情况下，从直观角度来看，CNN 的卷积运算，就是下图这样：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408092145683.gif" style="zoom:80%;" /></center><blockquote><p>上图中左侧的蓝色大矩阵表示输入数据，在蓝色大矩阵上不断运动的绿色小矩阵叫做卷积核，每次卷积核运动到一个位置，它的每个元素就与其覆盖的输入数据对应元素相乘求积，然后再将整个卷积核内求积的结果累加，结果填注到右侧红色小矩阵中。 卷积核横向每次平移一列，纵向每次平移一行。最后将输入数据矩阵完全覆盖后，生成完整的红色小矩阵就是卷积运算的结果。</p></blockquote><p>​    CNN 经常被用于处理图像，那么对应的输入数据就是一张图片的像素信息。</p><p>​    对于这样的输入数据，第一层卷积层可能只能提取一些低级的特征，如边缘、线条、角等，更多层的网络再从低级特征中迭代提取更复杂的特征。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202408092154742.png" style="zoom:80%;" /></center><p><a href="https://www.cnblogs.com/liuxiaochong/p/13463723.html">（传送门）</a></p>]]></content>
    
    
    <categories>
      
      <category>人工智能</category>
      
    </categories>
    
    
    <tags>
      
      <tag>人工智能</tag>
      
      <tag>NLP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Debug Mysql</title>
    <link href="/2023/11/05/Debug-Mysql/"/>
    <url>/2023/11/05/Debug-Mysql/</url>
    
    <content type="html"><![CDATA[<p>合集：<a href="https://www.cnblogs.com/tianyiliang/articles/17723527.html">https://www.cnblogs.com/tianyiliang/articles/17723527.html</a></p><p><a href="https://www.codenong.com/cs106145348/">https://www.codenong.com/cs106145348/</a></p><p><a href="https://www.bilibili.com/read/cv15187227/?spm_id_from=333.999.0.0">https://www.bilibili.com/read/cv15187227/?spm_id_from=333.999.0.0</a></p><h3 id="1-mysql基本架构"><a href="#1-mysql基本架构" class="headerlink" title="1. mysql基本架构"></a>1. mysql基本架构</h3><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202311051804221.png" style="zoom:40%;" /></center><p><a href="https://zhuanlan.zhihu.com/p/587101147">https://zhuanlan.zhihu.com/p/587101147</a></p><h3 id="2-查询SQL执行过程"><a href="#2-查询SQL执行过程" class="headerlink" title="2. 查询SQL执行过程"></a>2. 查询SQL执行过程</h3><p>（1）连接器–首先客户端（python/java的mysql客户端包）创建连接，连接器为每个客户端连接创建一个新的连接线程，并校验账号密码和权限。</p><p>（2）查询缓存–如果最近已经查询过该SQL，会将 sql 和结果以 key-value 的形式保存到缓存中。执行 select 查询语句时，会先查询缓存，有的话直接返回结果。</p><p>（3）分析器–对 SQL 语句进行词法分析，语法分析。通过这一步，可以知道 sql 要做的事情。</p><p>（4）优化器–知道 sql 要做的事情，但可能有好几种方法实现。比如可以使用两个索引联合查询，到底先走哪个索引呢？这是优化器要做的事情，尽可能提高查询速度。制定一个查询扫描行数较少的执行计划。</p><p>（5）执行器–执行优化器得出的执行计划。调用存储引擎，并返回查询结果。</p><p>（6）存储引擎–存储数据，并提供读写接口</p><center><img src="https://pic2.zhimg.com/80/v2-d169d02aad0bcf7fdb825a913d4c53c5_1440w.webp" alt="img" style="zoom:40%;" /></center><p><a href="https://zhuanlan.zhihu.com/p/589592690">https://zhuanlan.zhihu.com/p/589592690</a></p><h3 id="3-更新SQL执行过程"><a href="#3-更新SQL执行过程" class="headerlink" title="3.  更新SQL执行过程"></a>3.  更新SQL执行过程</h3><p>　　(update T set c=c+1 where ID=2;)</p><p>（1）更新流程和查询流程从连接器到执行器基本都是一样流程，区别在于更新或修改数据时还涉及到两个日志模块。（redo log–重做日志 和 bin log–归档日志）</p><p>（2）mysql 有个 wal 技术（write-ahead logging），它的关键点在于先写日志，再写磁盘。</p><p>（3）redo log 仅仅在 innodb 存储引擎存在。当执行一条 update/delete/insert SQL 时，会先把记录写到 redo log 里面，并更新到内存，这个时候就算完成，后面找个空闲时间将操作记录（从内存中）更新到磁盘中。</p><p>（4）有了redo log，innodb 引擎可以保证即使数据库发生异常重启，之前提交的记录都不会丢失。这个能力称之为 crash-safe。即使数据库突然宕机了，可以通过 redo log 将数据从文件中恢复到数据库（磁盘）中。保证了四大特性中的持久性。</p><p>（5）bin log 是 server 层的，redo log 是 innodb 存储引擎特有的。两个日志的区别：</p><blockquote><p>a. redo log是物理日志，记录的是”在某个数据页某个值做了什么修改“。bin log是逻辑日志，记录的是SQL语句的原始逻辑，如”给id=2的那一行c字段数值+1“</p><p>b. redo log空间是固定的，是循环使用的。bin log是可以追加写入的，文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。bin log默认是关闭的，需要手动修改为开启。</p><p>c. bin log可以用于数据恢复（到某一时刻）使用，主从复制搭建。redo log作为异常宕机或者介质故障后的数据恢复使用。</p></blockquote><p>（6）update sql执行流程图</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202311051735153.png" style="zoom:40%;" /></center><blockquote><p>这里将 redo log 的写入拆分成 prepare 和 commit 两个阶段，称为“二阶段提交”。</p><p><strong>为什么必须有两阶段提交？</strong></p><p><strong>这是为了让两份日志之间的逻辑一致。</strong></p><p>可以换个角度考虑，如果不采用两阶段提交，而是先写一个日志，再写另一个日志。此时如果第一个日志写成功了，在写第二个时mysql服务器宕机了，导致第二个写入失败了。会导致bin log和redo log所记录的数据不一致。在后面使用bin log进行数据恢复时，或者使用redo log进行宕机后的数据重新写入数据库，状态不一致。</p><p><strong>所以，“两阶段提交”的提交就像 原子性的作用一样，让这两个日志保持逻辑上的一致。</strong> </p></blockquote><p>　　<a href="https://blog.csdn.net/Huangjiazhen711/article/details/127861169">https://blog.csdn.net/Huangjiazhen711/article/details/127861169</a></p><h3 id="4-redo-log、undo-log和binlog"><a href="#4-redo-log、undo-log和binlog" class="headerlink" title="4. redo log、undo log和binlog"></a>4. redo log、undo log和binlog</h3><p>　　<a href="https://zhuanlan.zhihu.com/p/647473227">https://zhuanlan.zhihu.com/p/647473227</a></p><h3 id="5-Redo-Log-崩溃恢复过程"><a href="#5-Redo-Log-崩溃恢复过程" class="headerlink" title="5. Redo Log 崩溃恢复过程"></a>5. Redo Log 崩溃恢复过程</h3><p>　　<a href="https://blog.csdn.net/m0_71777195/article/details/130842268">https://blog.csdn.net/m0_71777195/article/details/130842268</a></p><p>　　<code>两次写</code> <code>double write</code>，它包含<code>内存缓冲区</code>和 <code>dblwr 文件</code>两个部分，InnoDB 脏页刷盘前，都会先把脏页写入内存缓冲区，再写入 dblwr 文件，成功之后才会把脏页刷盘。</p><h3 id="6-索引"><a href="#6-索引" class="headerlink" title="6. 索引"></a>6. 索引</h3><ul><li>索引类型</li><li>索引失效</li></ul><p>　　<a href="https://zhuanlan.zhihu.com/p/635230263">https://zhuanlan.zhihu.com/p/635230263</a></p><p>　　<a href="https://zhuanlan.zhihu.com/p/430626707">https://zhuanlan.zhihu.com/p/430626707</a></p><p>　　索引优化：</p><p>　　<a href="https://zhuanlan.zhihu.com/p/258467069">https://zhuanlan.zhihu.com/p/258467069</a></p><p>　　<a href="https://zhuanlan.zhihu.com/p/613108218">https://zhuanlan.zhihu.com/p/613108218</a></p><p>　　<strong>深度分页慢sql原因：</strong></p><p>　　<a href="https://blog.csdn.net/xiaoshitou_2015/article/details/130027651">https://blog.csdn.net/xiaoshitou_2015/article/details/130027651</a></p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202311122052642.png" style="zoom:50%;" /></center><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202311122053442.png" style="zoom:50%;" /></center><p>　　MySQL索引失效原理是什么？</p><p>　　<a href="https://www.zhihu.com/question/421944348/answer/3075704071">https://www.zhihu.com/question/421944348/answer/3075704071</a></p><h3 id="7-事务"><a href="#7-事务" class="headerlink" title="7. 事务"></a>7. 事务</h3><p>　　<a href="https://zhuanlan.zhihu.com/p/425443526">https://zhuanlan.zhihu.com/p/425443526</a></p><p>　　<a href="https://zhuanlan.zhihu.com/p/129860691">https://zhuanlan.zhihu.com/p/129860691</a></p><p>　　<a href="https://zhuanlan.zhihu.com/p/117476959">https://zhuanlan.zhihu.com/p/117476959</a></p><h3 id="８-锁"><a href="#８-锁" class="headerlink" title="８.锁"></a>８.锁</h3><p>　　<a href="https://zhuanlan.zhihu.com/p/570570330">https://zhuanlan.zhihu.com/p/570570330</a></p><p>　　<a href="https://blog.csdn.net/Prior_SX/article/details/124567724">https://blog.csdn.net/Prior_SX/article/details/124567724</a></p><h3 id="９-DDL、DML、DQL、DCL"><a href="#９-DDL、DML、DQL、DCL" class="headerlink" title="９.DDL、DML、DQL、DCL"></a>９.DDL、DML、DQL、DCL</h3><p>　　<a href="https://www.jianshu.com/p/9ccf80bad7c6">https://www.jianshu.com/p/9ccf80bad7c6</a></p><p>　　DDL 优化</p><h3 id="10-MySQL是如何保证主从库数据一致性的？"><a href="#10-MySQL是如何保证主从库数据一致性的？" class="headerlink" title="10. MySQL是如何保证主从库数据一致性的？"></a>10. MySQL是如何保证主从库数据一致性的？</h3><p><a href="https://mp.weixin.qq.com/s?__biz=MzAxOTc1OTY4NA==&amp;mid=2650858366&amp;idx=1&amp;sn=0aaef3c4877bd605afbb71c25324125c&amp;chksm=80365455b741dd43e99953638695a73b432d44b8362d1be4034029be387e800a0ad54abdb15c&amp;scene=27">https://mp.weixin.qq.com/s?__biz=MzAxOTc1OTY4NA==&amp;mid=2650858366&amp;idx=1&amp;sn=0aaef3c4877bd605afbb71c25324125c&amp;chksm=80365455b741dd43e99953638695a73b432d44b8362d1be4034029be387e800a0ad54abdb15c&amp;scene=27</a></p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Debug 算法</title>
    <link href="/2023/10/31/Debug-%E7%AE%97%E6%B3%95/"/>
    <url>/2023/10/31/Debug-%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1-数组的最大连续子数组之和——kadane算法"><a href="#1-数组的最大连续子数组之和——kadane算法" class="headerlink" title="1. 数组的最大连续子数组之和——kadane算法"></a>1. 数组的最大连续子数组之和——kadane算法</h3><p><a href="https://zhuanlan.zhihu.com/p/85188269">https://zhuanlan.zhihu.com/p/85188269</a></p><h3 id="2-另一棵树的子树"><a href="#2-另一棵树的子树" class="headerlink" title="2. 另一棵树的子树"></a>2. <a href="https://leetcode.cn/problems/subtree-of-another-tree/">另一棵树的子树</a></h3><h3 id="3-买卖股票的最佳时机"><a href="#3-买卖股票的最佳时机" class="headerlink" title="3. 买卖股票的最佳时机"></a>3. <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/">买卖股票的最佳时机</a></h3><h3 id="4-买卖股票的最佳时机-II"><a href="#4-买卖股票的最佳时机-II" class="headerlink" title="4. 买卖股票的最佳时机 II"></a>4. <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/">买卖股票的最佳时机 II</a></h3><h3 id="5-买卖股票的最佳时机-III"><a href="#5-买卖股票的最佳时机-III" class="headerlink" title="5. 买卖股票的最佳时机 III"></a>5. <a href="https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-iii/">买卖股票的最佳时机 III</a></h3><h3 id="6-寻找峰值"><a href="#6-寻找峰值" class="headerlink" title="6. 寻找峰值"></a>6. <a href="https://leetcode.cn/problems/find-peak-element/">寻找峰值</a></h3><h3 id="7-最小路径和"><a href="#7-最小路径和" class="headerlink" title="7. 最小路径和"></a>7. <a href="https://leetcode.cn/problems/minimum-path-sum/">最小路径和</a></h3><h3 id="8-最长递增子序列"><a href="#8-最长递增子序列" class="headerlink" title="8. 最长递增子序列"></a>8. <a href="https://leetcode.cn/problems/longest-increasing-subsequence/">最长递增子序列</a></h3><h3 id="9-寻找明星"><a href="#9-寻找明星" class="headerlink" title="9. 寻找明星"></a>9. 寻找明星</h3><p><a href="https://www.cnblogs.com/bvac/p/6382761.html">https://www.cnblogs.com/bvac/p/6382761.html</a></p><p>红黑树</p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Debug web</title>
    <link href="/2023/10/24/Debug-web/"/>
    <url>/2023/10/24/Debug-web/</url>
    
    <content type="html"><![CDATA[<h3 id="1-http-版本"><a href="#1-http-版本" class="headerlink" title="1. http 版本"></a>1. http 版本</h3><p>参考：<a href="https://zhuanlan.zhihu.com/p/594274411">https://zhuanlan.zhihu.com/p/594274411</a></p><p>1.0 版本：链接无法复用，即不支持长链接。</p><h4 id="1-1-HTTP-1-gt-HTTP-1-1"><a href="#1-1-HTTP-1-gt-HTTP-1-1" class="headerlink" title="1.1  HTTP/1. -&gt; HTTP/1.1"></a>1.1  HTTP/1. -&gt; HTTP/1.1</h4><p>　　HTTP/1.1 是目前最常见的 HTTP 版本，其相对于 HTTP/1.0 有以下改进。</p><h5 id="①-持久连接"><a href="#①-持久连接" class="headerlink" title="① 持久连接"></a>① 持久连接</h5><p>　　HTTP/1.0 中一个 TCP 连接只能发送一个请求和响应，而 HTTP/1.1 进行了优化，同一个 TCP 连接可以发送多次 HTTP 请求，减少了建立和关闭连接的性能开销。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240041289.png" style="zoom:70%;" /></center><p>HTTP（1.1 及之后） 默认采用<strong>持续连接</strong>方式，但也可配置成非持续连接方式。在报文中使用 <code>Connection</code> 字段来表示是否使用持久连接。</p><ul><li>如果 <code>Connection</code> 字段的值为 <code>keep-alive</code>，则表明此连接为持久连接，HTTP1.1 及以后可默认不写。</li><li>如果 <code>Connection</code> 字段的值为 <code>close</code>，则表明要关闭连接。</li></ul><p>Web 服务软件一般都会提供 <code>keepalive_timeout</code> 参数，用来指定 HTTP 持久连接的超时时间。比如设置了 HTTP 持久连接的超时时间是 60 秒，Web 服务软件就会启动一个定时器，如果完成某个 HTTP 请求后，在 60 秒内都没有再发起新的请求，就会触发回调函数来释放该连接。</p><h5 id="②-管道机制"><a href="#②-管道机制" class="headerlink" title="② 管道机制"></a>② 管道机制</h5><p>　　持久连接虽然可以多个请求复用同一个连接，但是每次都需要等到上一个请求响应完成后，才能发送下一个请求。</p><p>　　管道机制中，只要第一个请求发出去了，不必等其回来，就可以发第二个请求出去，即相当于同时发出多个请求，因而可以减少整体的响应时间。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240046998.png" style="zoom:70%;" /></center><p>　　<strong>虽然客户端可以同时发出多个 HTTP 请求，不用⼀个个等待响应，但是服务器必须按照接收请求的顺序依次发送对这些管道化请求的响应</strong>，以保证客户端能够区分出每次请求的响应内容。这存在下面问题：</p><ol><li><p>如果服务端在处理一个请求时耗时比较长，那么后续请求的处理都会被阻塞住，会导致客户端迟迟收不到数据，这称为「<strong>队头堵塞</strong>」。</p></li><li><p>实际上，虽然管道机制的想法很好，但实现却非常困难，因而很多浏览器根本不支持它。一般为了提升性能，采用并行多个 TCP 连接的形式来实现请求的同时发送。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240048537.png" style="zoom:70%;" /></center></li></ol><h5 id="③-缓存控制"><a href="#③-缓存控制" class="headerlink" title="③ 缓存控制"></a>③ 缓存控制</h5><p>　　HTTP/1.1 在 HTTP/1.0 基础之上，增加了一些请求响应头，以更好的实现对缓存的控制。比如</p><ul><li>新增 <code>Cache-Control</code> 代替原先的 <code>Expires</code>；</li><li>新增 <code>If-None-Match</code> 和 <code>Etag</code> 代替原先的 <code>If-Modified-Since</code>和 <code>Last-Modified</code> 。</li></ul><h5 id="④-断点续传"><a href="#④-断点续传" class="headerlink" title="④ 断点续传"></a>④ 断点续传</h5><p>　　利⽤ HTTP 消息头使⽤分块传输编码，将实体主体分块传输。</p><h4 id="1-2-HTTP-1-1-gt-HTTP-2"><a href="#1-2-HTTP-1-1-gt-HTTP-2" class="headerlink" title="1.2 HTTP/1.1  -&gt; HTTP/2"></a>1.2 HTTP/1.1  -&gt; HTTP/2</h4><p>HTTP/2 协议本身是基于 HTTPS 的，因此更加安全，其相对于 HTTP/1.1 有以下改进。</p><h5 id="①-头部压缩"><a href="#①-头部压缩" class="headerlink" title="① 头部压缩"></a>① 头部压缩</h5><p>　　HTTP/1.1 中的请求头携带大量信息，而且每次都要重复发送，即使是同样的内容，每次请求都需要附带，这会造成性能的损耗。HTTP/2 进行了优化，引入了<strong>头信息压缩机制</strong>。</p><p>客户端和服务器<strong>同时维护一张头信息表</strong>，高频出现的字段会存入这个表，生成一个索引号。发送报文时直接使用索引号替代字段。另外，索引表中不存在的字段使用哈夫曼编码<strong>压缩</strong>。</p><p>　　同时，多个请求中，如果请求头相同，则后续请求只需要发送差异的部分，<strong>重复的部分无需再发送</strong>。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240058555.png" style="zoom:70%;" /></center><h5 id="②-二进制帧"><a href="#②-二进制帧" class="headerlink" title="② 二进制帧"></a>② 二进制帧</h5><p>　　HTTP/1.1 的报文为纯文本格式，而 HTTP/2 的报文全面采用二进制格式，并将原始的报文拆分为头信息帧（Headers Frame）和数据帧（Data Frame）。采用二进制格式有利于提升数据传输效率。</p><h5 id="③-多路复用"><a href="#③-多路复用" class="headerlink" title="③ 多路复用"></a>③ 多路复用</h5><p>　　在 HTTP/2 中定义了<strong>流（Stream）</strong>的概念，它是二进制帧的双向传输序列，一个数据流对应着一个完整的请求-响应过程，在同一个请求响应过程中，往返的帧会分配一个<strong>唯一的流编号</strong>（Stream ID）。</p><p>　　在流的支持下，HTTP/2 可以在<strong>一个 TCP 连接中传输多个请求或响应，而不用按照顺序一一对应（即实现多路复用</strong>），因为它们属于不同的流，所发送的帧头部都会携带 Stream ID，可以通过此 Stream ID 有效区分不同的请求-响应。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240100176.png" style="zoom:70%;" /></center><p>因而 HTTP/2 解决了 HTTP/1.1 的『队头阻塞』问题，多个请求 - 响应之间没有了顺序关系，不需要排队等待，降低了延迟，大幅度提高了连接的利用率。</p><p>　　举个栗子：在一个 TCP 连接里面，服务器同时收到了 A 请求和 B 请求，于是先回应 A 请求，结果发现处理过程非常耗时，于是就发送 A 请求已经处理好的部分，接着回应 B 请求，完成后，再发送 A 请求剩下的部分。</p><h5 id="④-服务端推送"><a href="#④-服务端推送" class="headerlink" title="④ 服务端推送"></a>④ 服务端推送</h5><p>在 HTTP/1.1 中，只能客户端发起请求，服务器对请求进行响应。</p><p>　　而在 HTTP/2 中，服务端可以<strong>主动</strong>给客户端推送必要的资源，以减少请求延迟时间。</p><p>　　比如当客户端向服务器请求一个 <code>HTML</code> 文件后，服务器除了将此 <code>HTML</code> 文件响应给客户端外，还可以提前主动将此 <code>HTML</code> 中所依赖的 <code>JS</code> 和 <code>CSS</code> 文件推送给客户端，这样客户端在解析 <code>HTML</code> 时，无需耗费额外的请求去得到相应的 <code>JS</code> 和 <code>CSS</code> 文件。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240103641.png" style="zoom:70%;" /></center><h4 id="1-3-HTTP-3-相比-HTTP-2-性能上的改进"><a href="#1-3-HTTP-3-相比-HTTP-2-性能上的改进" class="headerlink" title="1.3 HTTP/3 相比 HTTP/2 性能上的改进"></a>1.3 HTTP/3 相比 HTTP/2 性能上的改进</h4><p>　　Google 公司为了解决 HTTP/2 存在的一些问题，提出了 QUIC 协议，而 HTTP-over-QUIC 就是 HTTP/3，其相对于 HTTP/2 有以下改进。</p><h5 id="①-无队头阻塞"><a href="#①-无队头阻塞" class="headerlink" title="① 无队头阻塞"></a>① 无队头阻塞</h5><p>前面提到，HTTP/2 通过<strong>多路复用</strong>解决了 HTTP1.1 的『队头阻塞』问题，但其只是解决了 HTTP 这一层面的『队头阻塞』问题，底层仍然采用的 TCP 连接，HTTP/2 并没有解决 TCP 的『队头阻塞』问题。</p><p>　　TCP 是可靠的、面向字节流的协议。HTTP/2 的多个请求虽然可以跑在同一个 TCP 连接中，但如果出现丢包现象，TCP 就需要进行重传，这可能就会导致整个 TCP 连接上的所有流阻塞，直到丢的包重传成功，这就是 TCP 的『队头阻塞』问题。</p><p>　　为了解决此问题，<strong>HTTP/3 底层不再使用 TCP，而是采用 UDP</strong>！而 UDP 是无连接的，多个流互相独立，之间不再有依赖，因而即使某个流发生了丢包，只会对该流产生影响，并不会使得其他流阻塞！</p><p>　　这时候有的小伙伴可能会问了，HTTP/3 底层不采用 TCP，那怎么保证可靠传输呢？答案就是 HTTP/3 在应用层自己重新实现了可靠性机制。也就是说，<strong>HTTP/3 将原先 TCP 协议提供的部分功能上移至 QUIC，而且进行了改进。</strong></p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240106547.png" style="zoom:70%;" /><h5 id="②-优化重传机制"><a href="#②-优化重传机制" class="headerlink" title="② 优化重传机制"></a>② 优化重传机制</h5><p>　　TCP 采用<strong>序号+确认号+超时重传</strong>机制来保证消息的可靠性，即如果某条消息超过一定时间还没有得到确认，则重新发送此消息。</p><p>　　由于网络拥堵情况不断变化，因而消息的超时时间并不是固定的，而是通过不断采样消息的往返时间不断调整的，但 <strong>TCP 超时采样存在不准确的问题</strong>。</p><p>　　举个栗子：</p><p>　　客户端发送一个序号为 N 的包，然后超时了（可能丢了，也可能网络堵塞了），于是重新发送一个序号为 N 的包，之后服务器收到后返回一个确认号 ACK 为 N+1 的包。但此时客户端并无法判断这个确定包是对原始报文的确认还是重传报文的确认，那么此时往返时间应该如何计算呢？</p><ul><li>如果认为确认包是对原始报文的确认，则可能把时间算长了；</li><li>如果认为确认包是对重传报文的确认，则可能把时间算短了。</li></ul><p>　　因而 TCP 的重传超时时间计算不准确，如果计算偏大，则效率慢，很久才会重传，而如果计算偏小，则可能确认报文已经在路上了，但却重传了！</p><center>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240113095.png" style="zoom:70%;" /></center><p>　　<a href="https://zhuanlan.zhihu.com/p/588744727">QUIC</a> 是如何解决此问题呢？其定义了一个<strong>递增</strong>的序列号（不再叫 Seq，而是 Packet Number），每个序列号的包只发送一次，<strong>即使重传相同的包，其序列号也不一样</strong>。</p><p>　　举个栗子：</p><p>　　客户端发送一个序号为 N 的包，然后超时了，于是重新发送一个相同的包，但序号不再是 N，而是 N+1；那么如果返回的确认包 ACK 为 N+1，就是对原始报文的响应，如果 ACK 为 N+2，就是对重传报文的响应，因而采样时间计算相对更加准确！</p><center><img src="https://pic3.zhimg.com/80/v2-7bb38ed37d1d9503a753700365b35ece_1440w.webp" alt="img" style="zoom:70%;" /></center><p>　　那此时怎么知道包 N 和包 N+1 是同一个包呢？<strong>QUIC 定义了一个 Offset 概念</strong>。发送的数据有个偏移量 Offset，可以通过 Offset 知道数据目前发送到了哪里，因而如果某个 Offset 的包没有收到确认，就重发。</p><h5 id="③-连接迁移"><a href="#③-连接迁移" class="headerlink" title="③ 连接迁移"></a>③ 连接迁移</h5><p>众所周知，一条 TCP 连接是由<code>四元组</code>标识的，分别是<strong>源 IP、源端口、目的 IP、目的端口</strong>。一旦其中一个元素发生了变化，就需要断开重连。</p><p>　　当手机信号不稳定或者在 WIFI 与移动网络切换时，都将会导致重连，而重连就意味着需要重新进行三次握手，将产生一定的时延，用户感到卡顿，体验不友好。</p><p>　　而 QUIC 不采用<code>四元组</code>的方式标识连接，而是以一个 <strong>64 位的随机数作为 ID</strong> 来标识，通过此连接 ID 标记通信的两端，之后即使网络发生变化，IP 或端口变了，但只要 ID 不变，则无需重连，只需要复用原先连接即可，时延低，减少了用户的卡顿感，实现连接迁移。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240117413.png"></p><h4 id="1-4-总结"><a href="#1-4-总结" class="headerlink" title="1.4 总结"></a>1.4 总结</h4><center><img src="https://pic3.zhimg.com/80/v2-665f8dceea786ebadafc64787bc879ba_1440w.webp" alt="img" style="zoom:70%;" /></center><h3 id="2-HTTP-缓存"><a href="#2-HTTP-缓存" class="headerlink" title="2. HTTP 缓存"></a>2. HTTP 缓存</h3><p>　　HTTP 设计中也有缓存的概念，主要是为了<strong>加快响应速度</strong>，HTTP 缓存的实现依赖于请求报文和响应报文中的一些字段，分为强缓存和协商缓存。</p><h4 id="2-1-强缓存"><a href="#2-1-强缓存" class="headerlink" title="2.1 强缓存"></a>2.1 强缓存</h4><p>　　<strong>强缓存</strong>指的是在缓存数据未失效的情况下，那么就会直接使用浏览器的缓存数据，不会再向服务器发送任何请求，逻辑类似于 Redis、TLB 快表。</p><p>　　具体实现主要是通过 <code>Cache-Control</code>字段和 <code>Expires</code>字段。</p><p>　　Cache-Control 是一个相对时间（即多长时间后过期，http1.1 规范），Expires 是一个绝对时间（即在某个时间点过期，http1.0 规范），如果两个字段同时存在，Cache-Control 的优先级更高。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240124122.png" style="zoom:70%;" /></center><p>　　由于服务器端时间和客户端时间可能不同步，存在偏差，这也就是导致了使用 Expires 可能会存在时间误差，因此<strong>一般更推荐使用 Cache-Control 来实现强缓存</strong>。</p><p>　　以 Cache-Control 为例，强缓存的具体的实现流程如下：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240125101.png" style="zoom:70%;" /></center><ul><li><p>当浏览器第一次请求访问服务器资源时，<strong>服务器会在响应头中加上 Cache-Control</strong>。Cache-Control 中可以设置以下内容。</p></li><li><ul><li><code>max-age=秒</code>，表示缓存将于指定毫秒值后过期。比如：<code>cache-control: max-age=31536000</code>，表示缓存将于 365 天后过期。</li><li><code>no-store</code>，表示不允许缓存（包括强缓存和协商缓存）。</li><li><code>no-cache</code>，表示不使用强缓存，而是<strong>使用协商缓存</strong>，即使用之前必须要先去服务器端验证是否失效，如果没失效，则再使用缓存，如果失效了，则返回最新数据。等价于<code>max-age=0, must-revalidate</code>。</li><li><code>must-revalidate</code>，表示允许缓存，并且如果缓存不过期的话，先使用缓存，如果缓存过期的话，再去服务器端进行验证缓存是否还有效。<br>这里很多小伙伴可能会有疑问，即使没有加上 must-revalidate，有了 max-age 后，缓存过期了不也会去服务器验证吗，加不加 must-revalidate 有什么区别呢？<br>在 HTTP 协议规范中，允许客户端在某些特殊情况下直接使用过期缓存，比如校验请求错误时（如无法再次连通服务器），而加上了 must-revalidate 后，在校验请求错误时，会返回 504 错误码，而不是使用过期缓存。</li></ul></li><li><p>浏览器再次请求访问服务器中的该资源时，根据请求资源的时间与 Cache-Control 中设置的过期时间大小，计算出该资源是否过期，</p></li></ul><ol><li>如果没有过期（且 Cache-Control 没有设置 no-cache 属性和 no-store 属性），则使用该缓存，结束；</li><li>否则重新请求服务器；</li></ol><h4 id="2-2-协商缓存"><a href="#2-2-协商缓存" class="headerlink" title="2.2 协商缓存"></a>2.2 协商缓存</h4><p>　　<strong>协商缓存</strong>指的是当第一次请求后，服务器响应头 Cache-Control 字段属性设置为 no-cache 或者缓存时间过期了，那么浏览器再次请求时就会与服务器进行协商，判断缓存资源是否有效，即资源是否进行了修改更新。</p><ul><li>如果资源没有更新，那么服务器返回 304 状态码，表明缓存仍然可用，而不需要再次发送资源，减少了服务器的数据传输压力，并更新缓存时间。</li><li>如果数据有更新，服务器返回 200 状态码，新资源存放在请求体中。</li></ul><center><img src="https://pic4.zhimg.com/80/v2-5b294a5c2412dda0118b6669a27affc3_1440w.webp" alt="img" style="zoom:70%;" /></center><p>　　协商缓存可以基于以下两种方式来实现：</p><h5 id="1-HTTP-1-0-规范"><a href="#1-HTTP-1-0-规范" class="headerlink" title="1. HTTP/1.0 规范"></a>1. HTTP/1.0 规范</h5><p>　　请求头部中的 <code>If-Modified-Since</code> 字段与响应头部中的 <code>Last-Modified</code> 字段：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240132948.png" style="zoom:70%;" /></center><ul><li><p><code>Last-Modified</code>：标示这个响应资源的最后修改时间。第一次请求资源后，服务器将在响应头中带上此信息。</p></li><li><p><code>If-Modified-Since</code>：当资源过期了，浏览器再次发起请求的时候带上 Last-Modified 的时间（放在请求头 If-Modified-Since 中），服务器将此时间与被请求资源的最后修改时间进行对比，</p></li><li><ul><li>如果最后修改时间较大，说明资源有被修改过，则返回最新资源和 200 状态码；</li><li>否则说明资源无新修改，返回 304 状态码。</li></ul></li><li><p>此种方式存在以下问题：</p></li><li><ul><li>基于时间实现，可能会由于时间误差而出现不可靠问题，并且只能精确到秒级，在同一秒内，Last-Modified 无感知。</li><li>如果某些文件被修改了，但是内容并没有任何变化（比如只是修改时间发生了变化），而 Last-Modified 却改变了，导致文件没法使用缓存。</li></ul></li></ul><h5 id="2-HTTP-1-1-规范"><a href="#2-HTTP-1-1-规范" class="headerlink" title="2. HTTP/1.1 规范"></a>2. HTTP/1.1 规范</h5><p>　　请求头部中的 <code>If-None-Match</code> 字段与响应头部中的 <code>ETag</code> 字段：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310240135284.png" style="zoom:70%;" /></center><ul><li><p><code>Etag</code>：唯一标识响应资源，是一个 hash 值；第一次请求资源后，服务器将在响应头中带上此信息。</p></li><li><p><code>If-None-Match</code>：当资源过期了，浏览器再次向服务器发起请求时，会将请求头 If-None-Match 值设置为 Etag 中的值。服务器将此值与资源的 hash 值进行比对，</p></li><li><ul><li>如果二者相等，则资源没有变化，则返回 304 状态码。</li><li>如果资源变化了，则返回新资源和 200 状态码。</li></ul></li><li><p>此种方式存在的问题在于计算 Etag 会消耗系统性能，但可以解决第一种方式所存在的问题，推荐使用。</p></li></ul><p>注意 ：</p><ul><li>如果 HTTP 响应头部同时有 Etag 和 Last-Modified 字段的时候，<strong>Etag 的优先级更高</strong>，也就是先会判断 Etag 是否变化了，如果 Etag 没有变化，然后再看 Last-Modified。</li><li><code>Ctrl + F5</code> 强制刷新，会直接向服务器提取数据。</li><li>按 <code>F5</code> 刷新或浏览器的刷新按钮，默认加上 Cache-Control：max-age=0，即会走协商缓存。</li></ul><h3 id="3-HTTPS"><a href="#3-HTTPS" class="headerlink" title="3. HTTPS"></a>3. HTTPS</h3><ol><li>加密算法</li><li>摘要算法</li><li>数字证书</li><li><strong>SSL/TLS 握手</strong></li></ol><p><a href="https://zhuanlan.zhihu.com/p/597168426">https://zhuanlan.zhihu.com/p/597168426</a></p><h3 id="4-浏览器输入-URL-后回车发生了什么？"><a href="#4-浏览器输入-URL-后回车发生了什么？" class="headerlink" title="4. 浏览器输入 URL 后回车发生了什么？"></a>4. 浏览器输入 URL 后回车发生了什么？</h3><p><a href="https://zhuanlan.zhihu.com/p/591749021">https://zhuanlan.zhihu.com/p/591749021</a></p><h3 id="5-计算机网络体系结构"><a href="#5-计算机网络体系结构" class="headerlink" title="5. 计算机网络体系结构"></a>5. 计算机网络体系结构</h3><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310302041764.png" style="zoom:50%;" /></center><h4 id="1-五层协议"><a href="#1-五层协议" class="headerlink" title="1. 五层协议"></a>1. 五层协议</h4><blockquote><p><strong>应用层</strong> ：为特定应用程序提供数据传输服务，例如 HTTP、DNS 等协议。数据单位为报文。<br><strong>传输层</strong> ：为进程提供通用数据传输服务。运输层包括两种协议：传输控制协议 TCP，提供面向连接、可靠的数据传输服务，数据单位为报文段；用户数据报协议 UDP，提供无连接、尽最大努力的数据传输服务，数据单位为用户数据报。TCP 主要提供完整性服务，UDP 主要提供及时性服务。<br><strong>网络层</strong> ：负责为分组交换网上的不同主机提供通信服务。在发送数据时，网络层把运输层产生的报文段或用户数据包封装成分组或包进行传送。<br><strong>数据链路层</strong> ：网络层针对的是主机之间的数据传输服务，而主机之间可以有很多链路，链路层协议就是为同一链路的主机提供数据传输服务。数据链路层把网络层传下来的分组封装成帧。<br><strong>物理层</strong> ：考虑的是怎样在传输媒体上传输数据比特流，而不是指具体的传输媒体。物理层的作用是尽可能屏蔽传输媒体和通信手段的差异，使数据链路层感觉不到这些差异。</p></blockquote><h4 id="2-OSI"><a href="#2-OSI" class="headerlink" title="2. OSI"></a>2. OSI</h4><blockquote><p>其中表示层和会话层用途如下：<br><strong>表示层</strong> ：数据压缩、加密以及数据描述，这使得应用程序不必关心在各台主机中数据内部格式不同的问题。<br><strong>会话层</strong> ：建立及管理会话。<br>五层协议没有表示层和会话层，而是将这些功能留给应用程序开发者处理。</p></blockquote><h4 id="3-TCP-IP"><a href="#3-TCP-IP" class="headerlink" title="3. TCP/IP"></a>3. TCP/IP</h4><blockquote><p>它只有四层，相当于五层协议中数据链路层和物理层合并为网络接口层。<br>TCP/IP 体系结构不严格遵循 OSI 分层概念，应用层可能会直接使用 IP 层或者网络接口层</p></blockquote><h3 id="6-TCP-首部格式"><a href="#6-TCP-首部格式" class="headerlink" title="6. TCP 首部格式"></a>6. TCP 首部格式</h3><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310302048102.png" style="zoom:50%;" /></center><ol><li><strong>序号</strong> ：用于对字节流进行编号，例如序号为 301，表示第一个字节的编号为 301，如果携带的数据长度为 100字节，那么下一个报文段的序号应为 401。</li><li><strong>确认号</strong> ：期望收到的下一个报文段的序号。例如 B 正确收到 A 发送来的一个报文段，序号为 501，携带的数据长度为 200 字节，因此 B 期望下一个报文段的序号为 701，B 发送给 A 的确认报文段中确认号就为 701。</li><li><strong>数据偏移</strong> ：指的是数据部分距离报文段起始处的偏移量，实际上指的是首部的长度。</li><li><strong>确认 ACK</strong> ：当 ACK=1 时确认号字段有效，否则无效。TCP 规定，在连接建立后所有传送的报文段都必须把ACK 置 1。</li><li><strong>同步 SYN</strong> ：在连接建立时用来同步序号。当 SYN=1，ACK=0 时表示这是一个连接请求报文段。若对方同意建立连接，则响应报文中 SYN=1，ACK=1。</li><li><strong>终止 FIN</strong> ：用来释放一个连接，当 FIN=1 时，表示此报文段的发送方的数据已发送完毕，并要求释放连接。</li><li><strong>窗口</strong> ：窗口值作为接收方让发送方设置其发送窗口的依据。之所以要有这个限制，是因为接收方的数据缓存空间是有限的。</li></ol><h3 id="7-三次握手"><a href="#7-三次握手" class="headerlink" title="7. 三次握手"></a>7. 三次握手</h3><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310302107433.png" style="zoom:60%;" /></center><blockquote><p><strong>第一次握手</strong>：Client 将标志位 SYN 置为1，随机产生一个值 seq=J，并将该数据包发送给Server，Client进入SYN_SENT状态，等待Server确认。<br><strong>第二次握手</strong>：Server收到数据包后由标志位 SYN=1 知道 Client 请求建立连接，Server将标志位SYN和ACK都置为1，ack=J+1，随机产生一个值seq=K，并将该数据包发送给Client以确认连接请求，Server进入SYN_RCVD状态。<br><strong>第三次握手</strong>：Client 收到确认后，检查 ack 是否为 J+1，ACK是否为1，如果正确则将标志位ACK置为1，ack=K+1，并将该数据包发送给Server，Server检查ack是否为 K+1，ACK是否为1，如果正确则连接建立成功，Client和Server进入ESTABLISHED状态，完成三次握手，随后Client与Server之间可以开始传输数据了。</p></blockquote><h4 id="7-1-三次握手的原因"><a href="#7-1-三次握手的原因" class="headerlink" title="7.1 三次握手的原因"></a>7.1 三次握手的原因</h4><blockquote><p>第三次握手是为了防止失效的连接请求到达服务器，让服务器错误打开连接。<br>客户端发送的连接请求如果在网络中滞留，那么就会隔很长一段时间才能收到服务器端发回的连接确认。客户端等待一个超时重传时间之后，就会重新请求连接。但是这个滞留的连接请求最后还是会到达服务器，如果不进行三次握手，那么服务器就会打开两个连接。如果有第三次握手，客户端会忽略服务器之后发送的对滞留连接请求的连接确认，不进行第三次握手，因此就不会再次打开连接。</p></blockquote><h3 id="8-四次挥手"><a href="#8-四次挥手" class="headerlink" title="8. 四次挥手"></a>8. 四次挥手</h3><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310302110816.png" style="zoom:50%;" /></center><blockquote><p>第一次挥手：Client发送一个FIN，用来关闭Client到Server的数据传送，Client进入FIN_WAIT_1状态。<br>第二次挥手：Server收到FIN后，发送一个ACK给Client，确认序号为收到序号+1（与SYN相同，一个FIN占用一个序号），Server 进入 CLOSE_WAIT 状态。此时TCP链接处于半关闭状态，即客户端已经没有要发送的数据了，但服务端若发送数据，则客户端仍要接收。<br>第三次挥手：Server 发送一个FIN，用来关闭 Server 到 Client 的数据传送，Server 进入 LAST_ACK 状态。<br>第四次挥手：Client收到FIN后，Client进入TIME_WAIT状态，接着发送一个ACK给Server，确认序号为收到序号+1，Server进入CLOSED状态，完成四次挥手。</p></blockquote><h4 id="8-1-为什么在-TIME-WAIT-状态必须等待-2MSL（最长报文段寿命）-的时间"><a href="#8-1-为什么在-TIME-WAIT-状态必须等待-2MSL（最长报文段寿命）-的时间" class="headerlink" title="8.1 为什么在 TIME-WAIT 状态必须等待 2MSL（最长报文段寿命） 的时间?"></a>8.1 为什么在 TIME-WAIT 状态必须等待 2MSL（最长报文段寿命） 的时间?</h4><blockquote><p><strong>第一</strong>，为了保证 A 发送的最后一个ACK报文段能够到达B。这个ACK报文段有可能丢失，因而使处在 LAST-ACK 状态的 B 收不到对已发送的 FIN + ACK 报文段的确认。B会超时重传这个 FIN+ACK 报文段，而 A 就能在 2MSL 时间内收到这个重传的 FIN+ACK 报文段。接着 A 重传一次确认，重新启动 2MSL 计时器。最后，A和B都正常进入到 CLOSED 状态。如果 A 在TIME-WAIT状态不等待一段时间，而是在发送完ACK报文段后立即释放连接，那么就无法收到B重传的FIN + ACK报文段，因而也不会再发送一次确认报文段。这样，B就无法按照正常步骤进入CLOSED状态。<br> <strong>第二</strong>，防止上一节“已失效的连接请求报文段”出现在本连接中。A在发送完最后一个ACK报文段后，再经过时间2MSL，就可以使本连接持续的时间内所产生的所有报文段都从网络中消失。这样就可以使下-一个新的连接中不会出现这种旧的连接请求报文段。</p></blockquote><h3 id="9-UDP-首部格式"><a href="#9-UDP-首部格式" class="headerlink" title="9. UDP 首部格式"></a>9. UDP 首部格式</h3><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310302052769.png" style="zoom:50%;" /></center><p>首部字段只有 8 个字节，包括源端口、目的端口、长度、检验和。</p><h3 id="10-地址解析协议-ARP（网络层）"><a href="#10-地址解析协议-ARP（网络层）" class="headerlink" title="10. 地址解析协议 ARP（网络层）"></a>10. 地址解析协议 ARP（网络层）</h3><blockquote><p>每个主机都有一个 ARP 高速缓存，里面有本局域网上的各主机和路由器的 IP 地址到 MAC 地址的映射表。如果主机 A 知道主机 B 的 IP 地址，但是 ARP 高速缓存中没有该 IP 地址到 MAC 地址的映射，此时主机 A 通过广播的方式发送 ARP 请求分组，主机 B 收到该请求后会发送 ARP 响应分组给主机 A 告知其 MAC 地址，随后主机 A 向其高速缓存中写入主机 B 的 IP 地址到 MAC 地址的映射</p></blockquote><h3 id="11-UDP-和-TCP-的特点"><a href="#11-UDP-和-TCP-的特点" class="headerlink" title="11. UDP 和 TCP 的特点"></a>11. UDP 和 TCP 的特点</h3><blockquote><p>用户数据报协议 UDP（User Datagram Protocol）是无连接的，尽最大可能交付，没有拥塞控制，面向报文（对于应用程序传下来的报文不合并也不拆分，只是添加 UDP 首部），支持一对一、一对多、多对一和多对多的交互通信首部开销小。<br>传输控制协议 TCP（Transmission Control Protocol）是面向连接的，提供可靠交付，有流量控制，拥塞控制，提供全双工通信，面向字节流（把应用层传下来的报文看成字节流，把字节流组织成大小不等的数据块），每一条 TCP 连接只能是点对点的（一对一）。</p></blockquote><h3 id="12-滑动窗口机制"><a href="#12-滑动窗口机制" class="headerlink" title="12. 滑动窗口机制"></a>12. 滑动窗口机制</h3><blockquote><p>窗口是缓存的一部分，用来暂时存放字节流。发送方和接收方各有一个窗口，接收方通过 TCP 报文段中的窗口字段告诉发送方自己的窗口大小，发送方根据这个值和其它信息设置自己的窗口大小。<br>发送窗口内的字节都允许被发送，接收窗口内的字节都允许被接收。如果发送窗口左部的字节已经发送并且收到了确认，那么就将发送窗口向右滑动一定距离，直到左部第一个字节不是已发送并且已确认的状态；接收窗口的滑动类似，接收窗口左部字节已经发送确认并交付主机，就向右滑动接收窗口。<br>接收窗口只会对窗口内最后一个按序到达的字节进行确认，例如接收窗口已经收到的字节为 {31, 34, 35}，其中 {31}按序到达，而 {34, 35} 就不是，因此只对字节 31 进行确认。发送方得到一个字节的确认之后，就知道这个字节之前的所有字节都已经被接收</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310302115004.png" style="zoom:50%;" /></center>具体通过三个指针来实现的<ul><li>P1左部：已经发送并且收到了确认的字节，即滑动窗口的开始</li><li> P1~P2:已经发送,但未收到确认的字节</li><li> P3右侧：不能发送的字节，即滑动窗口的结束</li></ul></blockquote><h3 id="13-拆包和粘包"><a href="#13-拆包和粘包" class="headerlink" title="13. 拆包和粘包"></a>13. 拆包和粘包</h3><blockquote><p>UCP是基于报文发送的，UDP报文的首部会有16bit来表现UDP数据的长度，所以不同的报文之间是可以区别隔离出来的，所以应用层接收传输层的报文时，不会存在拆包和粘包的问题；<br>而TCP是基于字节流传的，应用层和传输层之前数据交互是大小不等的数据块，但TCP对这些数据块只是一连串的数据流，它并不知道哪些数据块跟哪些数据块是该一起发，哪个数据块是应该单独一块的，因为TCP并没有像UDP那样首部有数据长度，所以TCP存在拆包和粘包的问题。<br><strong>产生粘包场景</strong><br>发送端需要等缓冲区满才发送出去，造成粘包<br>接收方不及时接收缓冲区的包，造成多个包接收<br><strong>解决</strong><br>1.发送端给数据包增加首部，首部包含数据包中数据的长度，这样接收端的应用层接收数据后，根据首部中的长度就知道数据的实际长度了，可以很好处理数据了。通常设计思路，比如第1个字段使用32int表示数据的长度，接着是数据内容。<br>2.设置数据包的长度为固定的长度，不够数据则以空格填补；<br>3.应用层在发送每个数据包时，给每个数据包加分界标记，比如回车换行，</p></blockquote><h3 id="14-TCP短连接、长连接"><a href="#14-TCP短连接、长连接" class="headerlink" title="14. TCP短连接、长连接"></a>14. TCP短连接、长连接</h3><blockquote><p><strong>TCP短连接</strong>：client 向 server 发起连接请求，server 接到请求，然后双方建立连接。client 向server发送消息，server回应client，然后一次读写就完成了，这时候双方任何一个都可以发起close操作，不过一般都是client先发起close操作。短连接一般只会在 client/server 间传递一次读写操作。<br>短连接的优点是：管理起来比较简单，存在的连接都是有用的连接，不需要额外的控制手段<br><strong>TCP长连接</strong>：<br>长连接的情况，client向server发起连接，server接受client连接，双方建立连接。Client与server完成一次读写之后，它们之间的连接并不会主动关闭，后续的读写操作会继续使用这个连接。<br>长连接的优点是：减少连接建立过程的耗时。方便实现push数据<br><strong>心跳</strong><br>心跳是用来检测一个系统是否存活或者网络链路是否通畅的一种方式，做法是定时向被检测系统发送心跳包，被检测系统收到心跳包进行回复，收到回复说明对方存活。心跳能够给长连接提供保活功能，能够检测长连接是否正常，一旦链路死了，不可用了，能够尽快知道，然后做些其他的高可用措施，来保证系统的正常运行。<br><strong>长连接保活</strong><br>操作系统实现：<br>TCP 的 KeepAlive 机制（此机制并不是TCP协议规范中的内容，由操作系统去实现）KeepAlive机制开启后，在一定时间内（一般时间为7200s，参数tcp_keepalive_time）在链路上没有数据传送的情况下，TCP层将发送相应的KeepAlive探针以确定连接可用性，探测失败后重试10（参数tcp_keepalive_probes）次，每次间隔时间75s（参数tcp_keepalive_intvl），所有探测失败后，才认为当前连接已经不可用。这些参数是机器级别，可以调整。KeepAlive的保活机制只在链路空闲的情况下才会起到作用。<br><strong>心跳包使用</strong><br>方案一<br>最简单的策略当然是客户端定时n秒发送心跳包，服务端收到心跳包后，回复客户端的心跳，如果客户端连续m秒没有收到心跳包，则主动断开连接，然后重连，将正常的业务请求暂时不发送的该台服务器上。<br>方案二<br>这样传送一些无效的数据包有点多，可以做些优化。因为心跳就是一种探测请求，业务上的正常请求除了做业务处理外，还可以用作探测的功能，比如此时有请求需要发送到服务端，这个请求就可以当作是一次心跳，服务端收到请求，处理后回复，只要服务端有回复，就表明链路还是通的，如果客户端请求比较空闲的时候，服务端一直没有数据回复，就使用心跳进行探测，这样就有效利用了正常的请求来作为心跳的功能，减少无效的数据传输。</p></blockquote><h3 id="15-TCP-流量控制"><a href="#15-TCP-流量控制" class="headerlink" title="15. TCP 流量控制"></a>15. TCP 流量控制</h3><blockquote><p>流量控制是为了控制发送方发送速率，保证接收方来得及接收。接收方发送的确认报文中的窗口字段可以用来控制发送方窗口大小，从而影响发送方的发送速率。将窗口字段设置为0，则发送方不能发送数据。</p></blockquote><h3 id="16-TCP-拥塞控制"><a href="#16-TCP-拥塞控制" class="headerlink" title="16. TCP 拥塞控制"></a>16. TCP 拥塞控制</h3><blockquote><p>如果网络出现拥塞，分组将会丢失，此时发送方会继续重传，从而导致网络拥塞程度更高。因此当出现拥塞时，应当控制发送方的速率。这一点和流量控制很像，但是出发点不同。流量控制是为了让接收方能来得及接收，而拥塞控制是为了降低整个网络的拥塞程度。<br>TCP 主要通过四个算法来进行拥塞控制：慢开始、拥塞避免、快重传、快恢复。<br>发送方需要维护一个叫做拥塞窗口（cwnd）的状态变量，注意拥塞窗口与发送方窗口的区别：拥塞窗口只是一个状态变量，实际决定发送方能发送多少数据的是发送方窗口。</p><ol><li>慢开始与拥塞避免<br>发送的最初执行慢开始，令 cwnd = 1，发送方只能发送 1 个报文段；当收到确认后，将 cwnd 加倍，因此之后发送方能够发送的报文段数量为：2、4、8 …设置一个慢开始门限 ssthresh，当 cwnd &gt;= ssthresh 时，进入拥塞避免，每个轮次只将 cwnd 加 1。<br>如果出现了超时，则令 ssthresh = cwnd / 2，然后重新执行慢开始。</li><li>快重传与快恢复<br>在接收方，要求每次接收到报文段都应该对最后一个已收到的有序报文段进行确认。例如已经接收到 M1 和 M2，此时收到 M4，应当发送对 M2 的确认。<br>在发送方，如果收到三个重复确认，那么可以知道下一个报文段丢失，此时执行快重传，立即重传下一个报文段。例如收到三个 M2，则 M3 丢失，立即重传 M3。<br>在这种情况下，只是丢失个别报文段，而不是网络拥塞。因此执行快恢复，令 ssthresh = cwnd / 2 ，cwnd =ssthresh，注意到此时直接进入拥塞避免。<br>慢开始和快恢复的快慢指的是 cwnd 的设定值，而不是 cwnd 的增长速率。慢开始 cwnd 设定为 1，而快恢复 cwnd设定为 ssthresh</li></ol></blockquote><h3 id="17-http请求中的8种请求方法"><a href="#17-http请求中的8种请求方法" class="headerlink" title="17. http请求中的8种请求方法"></a>17. http请求中的8种请求方法</h3><p>1、opions   返回服务器针对特定资源所支持的HTML请求方法   或web服务器发送*测试服务器功能（允许客户端查看服务器性能）</p><p>2、Get   向特定资源发出请求（请求指定页面信息，并返回实体主体）</p><p>3、Post   向指定资源提交数据进行处理请求（提交表单、上传文件），又可能导致新的资源的建立或原有资源的修改</p><p>4、Put   向指定资源位置上上传其最新内容（从客户端向服务器传送的数据取代指定文档的内容）</p><p>5、Head  与服务器索与get请求一致的相应，响应体不会返回，获取包含在小消息头中的原信息（与get请求类似，返回的响应中没有具体内容，用于获取报头）</p><p>6、Delete   请求服务器删除request-URL所标示的资源*（请求服务器删除页面）</p><p>7、Trace   回显服务器收到的请求，用于测试和诊断</p><p>8、Connect   HTTP/1.1协议中能够将连接改为管道方式的代理服务器</p><h3 id="18-幂等性"><a href="#18-幂等性" class="headerlink" title="18. 幂等性"></a>18. 幂等性</h3><p>幂等的 HTTP 方法，同样的请求被执行一次与连续执行多次的效果是一样的，服务器的状态也是一样的。换句话说就是，幂等方法不应该具有副作用（统计用途除外）。所有的安全方法也都是幂等的。<br>在正确实现的条件下，GET，HEAD，PUT 和 DELETE 等方法都是幂等的，而 POST 方法不是</p><h3 id="19-GET和POST的区别"><a href="#19-GET和POST的区别" class="headerlink" title="19. GET和POST的区别"></a>19. GET和POST的区别</h3><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310302117884.png" style="zoom:50%;" /></center><h3 id="20-http的状态码"><a href="#20-http的状态码" class="headerlink" title="20. http的状态码"></a>20. http的状态码</h3><p>状态码如 200 OK，以 3 位数字和原因短语组成。 数字中的第一位指定了响应类别，后两位无分类。响应类别有以下 5 种。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310302215632.png" style="zoom:50%;" />  </center><p>200：OK 服务器成功处理了请求<br>301:（永久移动）请求的网页已永久移动到新位置，服务器返回此响应时，会自动将请求者转到新位置。<br>302:（临时移动）服务器目前从不同位置的网页响应请求，但请求者之后还是以原来的位置来进行以后的请求。<br>400:（错误请求）服务器不理解请求的语法。<br>403:（禁止）服务器拒绝请求。<br>404:（未找到）服务器找不到请求的网页。<br>500:（服务器内部错误)服务器遇到错误，无法完成请求。</p><h3 id="21-https与http的区别"><a href="#21-https与http的区别" class="headerlink" title="21. https与http的区别"></a>21. https与http的区别</h3><p>　　HTTPS 并不是新协议，而是让 HTTP 先和 SSL（Secure Sockets Layer）通信，再由 SSL 和 TCP 通信，相当于SSL被嵌在了HTTP和TCP之间。鉴于HTTP的缺点，HTTPS在HTTP的基础上增加了：</p><ul><li>通信加密（防窃听）</li><li>证书认定（防伪装）</li><li>完整性保护</li></ul><p>　　HTTPS和HTTP的区别主要如下：</p><ol><li>https协议需要到ca申请证书，一般免费证书较少，因而需要一定费用。</li><li>http是超文本传输协议，信息是明文传输，https则是具有安全性的ssl加密传输协议。</li><li>http和https使用的是完全不同的连接方式，用的端口也不一样，前者是80，后者是443。</li><li>http的连接很简单，是无状态的；HTTPS协议是由SSL+HTTP协议构建的可进行加密传输、身份认证的网络协议，比http协议安全。</li></ol><p> HTTP的缺点</p><ul><li>通信内容为明文，容易被窃听。 </li><li>通信双方身份没有进行验证，可能出现伪装身份的情况。 </li><li>接受报文完整性无法确定，可能中途被改动。</li></ul><p>HTTPS的缺点</p><ul><li>通信速率降低。除了进行TCP连接，发送请求外，还要进行SSL通信。通信信息量增加。</li><li>加密过程消耗资源。每个报文都要进行加密和解密的运算处理。比起HTTP消耗了更多资源。</li><li>证书开销。需要支付证书授权的高额费用</li></ul><ol><li>共享（对称）密钥加密：加密解密使用同一密钥。<br>　　优点：运算速度快。<br>　　缺点：无法安全的将密钥传输给通信方。</li><li>公开（非对称）密钥加密：加密和解密使用不同的密钥。一把是公有密钥，一把是私有密钥公有密钥是对通信双方公开的，任何人都可以获取，而私有的不公开。</li></ol><p>　　优点：可以更安全的将公开密钥传输给通信发送方。<br>　　缺点：运算速度慢。</p><ol start="3"><li>HTTPS采用的加密方式<br>HTTPS 采用了混合加密的方式。即先通过公开密钥（非对称）对共享密钥（对称）进行加密来保证传输过程的安全性，当共享密钥安全传输给对方后，双方则采用共享密钥的方式来加密报文，以此提高传输的效率。</li></ol><h3 id="22-DNS的解析过程"><a href="#22-DNS的解析过程" class="headerlink" title="22. DNS的解析过程"></a>22. DNS的解析过程</h3><p>　　1） 浏览器缓存<br>　　当用户通过浏览器访问某域名时，浏览器首先会在自己的缓存中查找是否有该域名对应的IP地址（若曾经访问过该域名且没有清空缓存便存在）；<br>　　2） 系统缓存<br>　　当浏览器缓存中无域名对应IP则会自动检查用户计算机系统Hosts文件DNS缓存是否有该域名对应IP；<br>　　3） 路由器缓存<br>　　当浏览器及系统缓存中均无域名对应IP则进入路由器缓存中检查，以上三步均为客服端的DNS缓存；<br>　　4） ISP（互联网服务提供商）DNS缓存<br>　　当在用户客服端查找不到域名对应IP地址，则将进入ISP DNS缓存中进行查询。比如你用的是电信的网络，则会进入电信的DNS缓存服务器中进行查找；<br>　　5） 根域名服务器<br>　　当以上均未完成，则进入根服务器进行查询。全球仅有13台根域名服务器，1个主根域名服务器，其余12为辅根域名服务器。根域名收到请求后给出顶级域名服务器的地址。<br>　　6） 顶级域名服务器<br>　　顶级域名服务器收到请求后查看区域文件记录，若无则将其管辖范围内主域名服务器的IP地址告诉本地DNS服务器；<br>　　7） 主域名服务器<br>　　主域名服务器接受到请求后查询自己的缓存，如果没有则进入下一级域名服务器进行查找，并重复该步骤直至找到正确纪录；<br>　　8）保存结果至缓存<br>　　本地域名服务器把返回的结果保存到缓存，以备下一次使用，同时将该结果反馈给客户端，客户端通过这个IP地址与web服务器建立链接。</p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Debug GO</title>
    <link href="/2023/10/18/Debug-GO/"/>
    <url>/2023/10/18/Debug-GO/</url>
    
    <content type="html"><![CDATA[<p>面试题汇总：</p><p><a href="https://zhuanlan.zhihu.com/p/519979757">https://zhuanlan.zhihu.com/p/519979757</a></p><p><a href="https://www.zhihu.com/people/itsanmao/posts">https://www.zhihu.com/people/itsanmao/posts</a></p><h3 id="1-Golang-调度器设计思想、GMP-协程调度模型详解"><a href="#1-Golang-调度器设计思想、GMP-协程调度模型详解" class="headerlink" title="1. Golang 调度器设计思想、GMP 协程调度模型详解"></a>1. Golang 调度器设计思想、GMP 协程调度模型详解</h3><p><a href="https://zhuanlan.zhihu.com/p/617420622">https://zhuanlan.zhihu.com/p/617420622</a></p><ol><li>GM</li><li>GMP</li><li>work stealing 机制和 hand off 机制</li><li>抢占式调度</li></ol><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310182358164.png" style="zoom:50%;" /></center><p>　</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310190006013.png" style="zoom:50%;" /></center><h3 id="2-Go内存管理和分配策略"><a href="#2-Go内存管理和分配策略" class="headerlink" title="2. Go内存管理和分配策略"></a>2. Go内存管理和分配策略</h3><p><a href="https://zhuanlan.zhihu.com/p/619865411">https://zhuanlan.zhihu.com/p/619865411</a></p><ol><li>TCMalloc：Thread Cache Malloc</li><li>Mspan、mcache、mcentral、mheap</li></ol><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310190018997.png" style="zoom:50%;" /></center><p>内存对齐：</p><p><a href="https://zhuanlan.zhihu.com/p/621129832">https://zhuanlan.zhihu.com/p/621129832</a></p><h3 id="3-GO-GC分析"><a href="#3-GO-GC分析" class="headerlink" title="3. GO GC分析"></a>3. GO GC分析</h3><p>GC触发机制：</p><p>Go语言中有三种GC的触发时机：</p><ul><li><strong>系统的定时触发</strong>：如果两分钟内没有触发GC，则会每隔两分钟进行触发一次GC。</li><li><strong>用户显示调用</strong>：用户调用runtime.GC方法，进行强制触发</li><li><strong>申请内存时触发</strong>：给对象申请堆空间的时候，可能会触发GC，调用mallocgc的方法。</li></ul><p>GO使用的GC算法：</p><ul><li>GO 1.3 mark and sweep</li><li>GO 1.5 三色并发标记法</li><li>GO 1.8混合写屏障</li></ul><p><strong>GC 中 stw 时机，各个阶段是如何解决的？</strong></p><p><a href="https://zhuanlan.zhihu.com/p/356930881">https://zhuanlan.zhihu.com/p/356930881</a></p><p><a href="https://blog.51cto.com/u_10983441/5357639">https://blog.51cto.com/u_10983441/5357639</a></p><h3 id="4-Golang-的-goroutine-是如何实现的？"><a href="#4-Golang-的-goroutine-是如何实现的？" class="headerlink" title="4. Golang 的 goroutine 是如何实现的？"></a>4. Golang 的 goroutine 是如何实现的？</h3><ul><li>GMP</li><li>调度</li><li>内存分配</li><li>GC</li></ul><p><a href="https://www.zhihu.com/question/20862617/answer/921061289">https://www.zhihu.com/question/20862617/answer/921061289</a></p><h3 id="5-深入分析Golang的Mutex"><a href="#5-深入分析Golang的Mutex" class="headerlink" title="5. 深入分析Golang的Mutex"></a>5. 深入分析Golang的Mutex</h3><p><a href="https://zhuanlan.zhihu.com/p/501972241">https://zhuanlan.zhihu.com/p/501972241</a></p><ol><li>state<code>和</code>sema</li><li><code>state</code>字段为<code>int32</code>类型，其低三位分别代表了锁的一些状态：<ul><li><code>mutexLocked</code>是<code>state</code>中的<code>低1位</code>，用二进制表示为<code>0001</code>（为了方便，这里只描述后4位），它代表该互斥锁是否被加锁。</li><li><code>mutexWoken</code>是<code>低2位</code>，用二进制表示为<code>0010</code>，它代表互斥锁上是否有被唤醒的goroutine。</li><li><code>mutexStarving</code>是<code>低3位</code>，用二进制表示为<code>0100</code>，它代表当前互斥锁是否处于饥饿模式。</li><li><code>state</code>剩下的29位用于统计在互斥锁上的等待队列中<code>goroutine</code>数目（<code>waiter</code>）。</li></ul></li></ol><p><strong>自旋的条件如下：</strong></p><p>1）还没自旋超过 4 次,</p><p>2）多核处理器，</p><p>3）GOMAXPROCS &gt; 1，</p><p>4）p 上本地 goroutine 队列为空。</p><h3 id="6-切片"><a href="#6-切片" class="headerlink" title="6. 切片"></a>6. 切片</h3><ol><li>结构</li><li>扩容</li><li>作为函数参数传参</li></ol><p><a href="https://zhuanlan.zhihu.com/p/598973739">https://zhuanlan.zhihu.com/p/598973739</a></p><h3 id="7-channel"><a href="#7-channel" class="headerlink" title="7. channel"></a>7. channel</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> hchan <span class="hljs-keyword">struct</span> &#123;<br>    qcount   <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// 当前队列中剩余元素个数</span><br>    dataqsiz <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// 环形队列长度，即可以存放的元素个数</span><br>    buf      unsafe.Pointer <span class="hljs-comment">// 环形队列指针</span><br>    elemsize <span class="hljs-keyword">uint16</span>         <span class="hljs-comment">// 每个元素的大小</span><br>    closed   <span class="hljs-keyword">uint32</span>         <span class="hljs-comment">// 标识关闭状态</span><br>    elemtype *_type         <span class="hljs-comment">// 元素类型</span><br>    sendx    <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// 队列下标，指示元素写入时存放到队列中的位置</span><br>    recvx    <span class="hljs-keyword">uint</span>           <span class="hljs-comment">// 队列下标，指示元素从队列的该位置读出</span><br>    recvq    waitq          <span class="hljs-comment">// 等待读消息的goroutine队列，即等待接收队列</span><br>    sendq    waitq          <span class="hljs-comment">// 等待写消息的goroutine队列，即等待发送队列</span><br>    lock     mutex          <span class="hljs-comment">// 互斥锁，chan不允许并发读写</span><br>&#125;<br></code></pre></td></tr></table></figure><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310192212948.png" style="zoom:50%;" />  </br></br><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310192303076.png" style="zoom:50%;" /></center><p>发送流程：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310192237574.png" style="zoom:50%;" /></center><p>接受流程：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310192253540.png" style="zoom:50%;" /></center><p>关闭流程：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310192254999.png" style="zoom:70%;" /></center><p><a href="https://zhuanlan.zhihu.com/p/604907917">https://zhuanlan.zhihu.com/p/604907917</a></p><p><a href="https://zhuanlan.zhihu.com/p/605991429">https://zhuanlan.zhihu.com/p/605991429</a></p><h3 id="8-Map"><a href="#8-Map" class="headerlink" title="8. Map"></a>8. Map</h3><ul><li>任何可比较的类型都可以是键——所有简单的标量类型（布尔、整数、浮点、复数、字符串）、指针、通道、数组、接口。</li><li>不可比较的类型——切片、映射、函数（ slice、map、function）。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A header for a Go map.</span><br><span class="hljs-keyword">type</span> hmap <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// Note: the format of the hmap is also encoded in cmd/compile/internal/reflectdata/reflect.go.</span><br>    <span class="hljs-comment">// Make sure this stays in sync with the compiler&#x27;s definition.</span><br>    count     <span class="hljs-keyword">int</span> <span class="hljs-comment">// 元素个数，调用 len(map) 时，直接返回此值</span><br>    flags     <span class="hljs-keyword">uint8</span> <span class="hljs-comment">//代表当前 map 的状态（是否处于正在写入的状态等）</span><br>    B         <span class="hljs-keyword">uint8</span>  <span class="hljs-comment">// buckets 的对数 log_2</span><br>    noverflow <span class="hljs-keyword">uint16</span> <span class="hljs-comment">// 为 map 中溢出桶的数量。当溢出的桶太多时，map 会进行 same-size map growth，其实质是避免桶过大导致内存泄露</span><br>    hash0     <span class="hljs-keyword">uint32</span> <span class="hljs-comment">// 代表生成 hash 的随机数种子</span><br><br>    buckets    unsafe.Pointer <span class="hljs-comment">// 指向 buckets 数组，大小为 2^B，如果元素个数为0，就为 nil</span><br>    oldbuckets unsafe.Pointer <span class="hljs-comment">// 是在 map 扩容时存储旧桶的，当所有旧桶中的数据都已经转移到了新桶中时，则清空</span><br>    nevacuate  <span class="hljs-keyword">uintptr</span>        <span class="hljs-comment">// 在扩容时使用，用于标记当前旧桶中小于 nevacuate 的数据都已经转移到了新桶中</span><br>    extra *mapextra <span class="hljs-comment">// 存储 map 中的溢出桶</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> mapextra <span class="hljs-keyword">struct</span> &#123;<br>  overflow    *[]*bmap  <span class="hljs-comment">// 指向已经使用的溢出桶数组</span><br>  oldoverflow *[]*bmap  <span class="hljs-comment">// 指向扩容阶段旧桶使用的溢出桶数组</span><br>  nextOverflow *bmap  <span class="hljs-comment">// 指向下个空闲溢出桶</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// A bucket for a Go map.</span><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-comment">// tophash generally contains the top byte of the hash value</span><br><span class="hljs-comment">// for each key in this bucket. If tophash[0] &lt; minTopHash,</span><br><span class="hljs-comment">// tophash[0] is a bucket evacuation state instead.</span><br>tophash [bucketCnt]<span class="hljs-keyword">uint8</span><br><span class="hljs-comment">// Followed by bucketCnt keys and then bucketCnt elems.</span><br><span class="hljs-comment">// <span class="hljs-doctag">NOTE:</span> packing all the keys together and then all the elems together makes the</span><br><span class="hljs-comment">// code a bit more complicated than alternating key/elem/key/elem/... but it allows</span><br><span class="hljs-comment">// us to eliminate padding which would be needed for, e.g., map[int64]int8.</span><br><span class="hljs-comment">// Followed by an overflow pointer.</span><br>&#125;<br></code></pre></td></tr></table></figure><p>编译期动态地创建一个新的结构:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>    topbits  [<span class="hljs-number">8</span>]<span class="hljs-keyword">uint8</span><br>    keys     [<span class="hljs-number">8</span>]keytype<br>    values   [<span class="hljs-number">8</span>]valuetype<br>    pad      <span class="hljs-keyword">uintptr</span><br>    overflow <span class="hljs-keyword">uintptr</span><br>&#125;<br><br><span class="hljs-keyword">type</span> bmap <span class="hljs-keyword">struct</span> &#123;<br>  tophash [bucketCnt]<span class="hljs-keyword">uint8</span>     <span class="hljs-comment">// 8个key的hash值的高8位，用于快速定位桶内的key</span><br>  keys    [bucketCnt]keytype   <span class="hljs-comment">// 8个key</span><br>  elems   [bucketCnt]valuetype <span class="hljs-comment">// 8个value</span><br>  padding <span class="hljs-keyword">uintptr</span>              <span class="hljs-comment">// 对齐使用，按照源码的注释可以省略。</span><br>  <span class="hljs-comment">// 当发生碰撞时，一个桶里最多放8个键值对。</span><br>  <span class="hljs-comment">// 当有第9个key被hash到该桶时，由于没有多余的位置，需要放到溢出桶</span><br>  <span class="hljs-comment">// overflow即为指向溢出桶的指针，溢出桶和桶的内部结构是一样的。</span><br>  overflow *bmap<br>&#125;<br></code></pre></td></tr></table></figure><p>不使用预分配的溢出桶：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310211648358.png" style="zoom:50%;" /></center><p>bmap 的内存布局:</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310211632410.png" style="zoom:50%;" /></center><p>最上面蓝色区域的HOBHash即为每个对应key的hash值的高8位，也即tophash数组。</p><p><a href="https://zhuanlan.zhihu.com/p/652191566">https://zhuanlan.zhihu.com/p/652191566</a></p><p><a href="https://www.jianshu.com/p/e1f380c4ae48">https://www.jianshu.com/p/e1f380c4ae48</a></p><p><a href="https://blog.51cto.com/u_13539/6761128">https://blog.51cto.com/u_13539/6761128</a></p><p><strong>不支持缩容</strong>：<a href="https://blog.csdn.net/EDDYCJY/article/details/120465701">https://blog.csdn.net/EDDYCJY/article/details/120465701</a></p><h4 id="8-1-map并发安全"><a href="#8-1-map并发安全" class="headerlink" title="8.1 map并发安全"></a>8.1 map并发安全</h4><p><a href="https://blog.csdn.net/weixin_43973689/article/details/127986224">https://blog.csdn.net/weixin_43973689/article/details/127986224</a></p><p><a href="https://www.jb51.net/jiaoben/285704yj5.htm">https://www.jb51.net/jiaoben/285704yj5.htm</a></p><p>sync.Map 实现：</p><p><a href="https://zhuanlan.zhihu.com/p/599178236">https://zhuanlan.zhihu.com/p/599178236</a></p><h3 id="9-select"><a href="#9-select" class="headerlink" title="9. select"></a>9. select</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> scase <span class="hljs-keyword">struct</span> &#123;<br>  c    *hchan         <span class="hljs-comment">// case中使用的chan</span><br>  elem unsafe.Pointer <span class="hljs-comment">// 指向case包含数据的指针</span><br>&#125;<br></code></pre></td></tr></table></figure><p>第一，Go select 语句采用的多路复用思想。</p><p>第二，select的基本用法是：通过多个case监听多个Channel的读写操作，任何一个case可以执行则选择该case执行，否则执行default。如果没有default，且所有的case均不能执行，则当前的goroutine阻塞。</p><p>第三，编译器会对select有不同的case的情况进行优化以提高性能。首先，编译器对select没有case、有单case和单case+default的情况进行单独处理。这些处理或者直接调用运行时函数，或者直接转成对channel的操作，或者以非阻塞的方式访问channel，多种灵活的处理方式能够提高性能，尤其是避免对channel的加锁。</p><p>第四，对最常出现的select有多case的情况，会调用 runtime.selectgo() 函数来获取执行 case 的索引，并生成 if 语句执行该case的代码。</p><p>第五，selectgo函数的执行分为四个步骤：首先，随机生成一个遍历case的轮询顺序 pollorder 并根据 channel 地址生成加锁顺序 lockorder，随机顺序能够避免channel饥饿，保证公平性，加锁顺序能够避免死锁；然后，根据 pollorder 的顺序查找 scases 是否有可以立即收发的channel，如果有则获取case索引进行处理；再次，如果pollorder顺序上没有可以直接处理的case，则将当前 goroutine 加入各 case 的 channel 对应的收发队列上并等待其他 goroutine 的唤醒；最后，当调度器唤醒当前 goroutine 时，会再次按照 lockorder 遍历所有的case，从中查找需要被处理的case索引进行读写处理，同时从所有case的发送接收队列中移除掉当前goroutine。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310212149797.png"></p><p><a href="https://blog.csdn.net/QcloudCommunity/article/details/128556748">https://blog.csdn.net/QcloudCommunity/article/details/128556748</a></p><h3 id="10-new和make的区别"><a href="#10-new和make的区别" class="headerlink" title="10. new和make的区别"></a>10. new和make的区别</h3><p><a href="https://zhuanlan.zhihu.com/p/648748855">https://zhuanlan.zhihu.com/p/648748855</a></p><h3 id="11-逃逸分析"><a href="#11-逃逸分析" class="headerlink" title="11. 逃逸分析"></a>11. 逃逸分析</h3><p><a href="https://cloud.tencent.com/developer/article/2206329">https://cloud.tencent.com/developer/article/2206329</a></p><p>逃逸分析原则：</p><ul><li>不同于JAVA JVM的运行时逃逸分析，Go的逃逸分析是在编译期完成的：编译期无法确定的参数类型<strong>必定</strong>放到堆中；</li><li>如果变量在函数外部存在引用，则<strong>必定</strong>放在堆中；</li><li>如果变量占用内存较大时，则<strong>优先</strong>放到堆中；</li><li>如果变量在函数外部没有引用，则<strong>优先</strong>放到栈中；</li></ul><h3 id="12-内存泄漏"><a href="#12-内存泄漏" class="headerlink" title="12. 内存泄漏"></a>12. 内存泄漏</h3><p><a href="https://blog.51cto.com/u_16099296/6700430">https://blog.51cto.com/u_16099296/6700430</a></p><h3 id="13-Go-中-uintptr-和-unsafe-Pointer-的区别"><a href="#13-Go-中-uintptr-和-unsafe-Pointer-的区别" class="headerlink" title="13.  Go 中 uintptr 和 unsafe.Pointer 的区别"></a>13.  Go 中 uintptr 和 unsafe.Pointer 的区别</h3><p><a href="https://blog.csdn.net/lengyue1084/article/details/133127480">https://blog.csdn.net/lengyue1084/article/details/133127480</a></p><h3 id="14-Go-多返回值怎么实现的"><a href="#14-Go-多返回值怎么实现的" class="headerlink" title="14. Go 多返回值怎么实现的"></a>14. Go 多返回值怎么实现的</h3><p>Go 传参和返回值是通过 FP+offset 实现，并且存储在调用函数的栈帧中。FP 栈底寄存器，指向一个函数栈的顶部;PC 程序计数器，指向下一条执行指令;SB 指向静态数据的基指针，全局符号;SP 栈顶寄存器。</p><p><a href="http://caibaojian.com/go/03.2.html">http://caibaojian.com/go/03.2.html</a></p><h3 id="15-协程池"><a href="#15-协程池" class="headerlink" title="15. 协程池"></a>15. 协程池</h3><ul><li>channel 实现</li><li>go-playground/pool</li><li><strong>ants</strong></li></ul><p><a href="https://blog.csdn.net/finghting321/article/details/106492915/">https://blog.csdn.net/finghting321/article/details/106492915/</a></p><h3 id="16-安全读写共享变量"><a href="#16-安全读写共享变量" class="headerlink" title="16. 安全读写共享变量"></a>16. 安全读写共享变量</h3><ul><li><p>将共享变量的读写放到一个 goroutine 中，其它 goroutine 通过 channel 进行读写操作。</p></li><li><p>可以用个数为 1 的信号量（semaphore）实现互斥</p></li><li><p>通过 Mutex 锁实现</p></li></ul><p>semaphore：</p><p><a href="https://zhuanlan.zhihu.com/p/389718532">https://zhuanlan.zhihu.com/p/389718532</a></p><p>WaitGroup：</p><p><a href="https://blog.csdn.net/zhanggqianglovec/article/details/127905793">https://blog.csdn.net/zhanggqianglovec/article/details/127905793</a></p><h3 id="17-context"><a href="#17-context" class="headerlink" title="17. context"></a>17. context</h3><p>context 结构：</p><p>答：Go 的 Context 的数据结构包含 Deadline，Done，Err，Value，Deadline 方法返回一个 time.Time，表示当前 Context 应该结束的时间，ok 则表示有结束时间，Done 方法当 Context 被取消或者超时时候返回的一个 close 的 channel，告诉给 context 相关的函数要停止当前工作然后返回了，Err 表示 context 被取消的原因，Value 方法表示 context 实现共享数据存储的地方，是协程安全的。context 在业务中是经常被使用的，</p><p>其主要的应用 ：</p><p>1：上下文控制，2：多个 goroutine 之间的数据交互等，3：超时控制：到某个时间点超时，过多久超时。</p><p><a href="https://www.cnblogs.com/juanmaofeifei/p/14439957.html">https://www.cnblogs.com/juanmaofeifei/p/14439957.html</a></p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty——粘包/半包、编解码器、序列化</title>
    <link href="/2023/10/11/Netty%E2%80%94%E2%80%94%E7%B2%98%E5%8C%85-%E5%8D%8A%E5%8C%85%E3%80%81%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <url>/2023/10/11/Netty%E2%80%94%E2%80%94%E7%B2%98%E5%8C%85-%E5%8D%8A%E5%8C%85%E3%80%81%E7%BC%96%E8%A7%A3%E7%A0%81%E5%99%A8%E3%80%81%E5%BA%8F%E5%88%97%E5%8C%96/</url>
    
    <content type="html"><![CDATA[<h3 id="1-粘包半包"><a href="#1-粘包半包" class="headerlink" title="1. 粘包半包"></a>1. 粘包半包</h3><h4 id="1-1-什么是TCP粘包半包"><a href="#1-1-什么是TCP粘包半包" class="headerlink" title="1.1 什么是TCP粘包半包"></a>1.1 什么是TCP粘包半包</h4><p>　　假设客户端分别发送了两个数据包 D1 和 D2 给服务端，由于服务端一次读取到的字节数是不确定的，故可能存在以下 4 种情况。</p><ol><li>服务端分两次读取到了两个独立的数据包，分别是 D1 和 D2，没有粘包和拆包；</li><li>服务端一次接收到了两个数据包，D1 和 D2 粘合在一起，被称为 TCP 粘包；</li><li>服务端分两次读取到了两个数据包，第一次读取到了完整的 D1 包和 D2 包的部分内容，第二次读取到了 D2 包的剩余内容，这被称为 TCP 拆包；</li><li>服务端分两次读取到了两个数据包，第一次读取到了 D1 包的部分内容 D1_1，第二次读取到了 D1 包的剩余内容 D1_2 和 D2 包的整包。</li></ol><p>　　如果此时服务端 TCP 接收滑窗非常小，而数据包 D1 和 D2 比较大，很有可能会发生第五种可能，即服务端分多次才能将 D1 和 D2 包接收完全，期间发生多次拆包。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310112242486.png"></p><p>服务端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoStickyHalfServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger counter = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ByteBuf in = (ByteBuf) msg;<br>        String request = in.toString(CharsetUtil.UTF_8);<br>        System.out.println(<span class="hljs-string">&quot;Server accept: &quot;</span> + request);<br>        System.out.println(<span class="hljs-string">&quot;accept counter:&quot;</span> + counter.incrementAndGet());<br><br>        String resp = <span class="hljs-string">&quot;Hello &quot;</span> + request + System.lineSeparator();<br>        ctx.writeAndFlush(Unpooled.copiedBuffer(resp.getBytes()));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端接收结果：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310112337815.png" style="zoom:50%;" /></center><p>客户端：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoStickyHalfClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger counter = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;client Accept&quot;</span> + msg.toString(CharsetUtil.UTF_8));<br>        System.out.println(<span class="hljs-string">&quot;accept counter is&quot;</span> + counter.incrementAndGet());<br>    &#125;<br><br>    <span class="hljs-comment">/*channel活跃后，做业务处理*/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String request = <span class="hljs-string">&quot;debuggingWorld&quot;</span> + System.lineSeparator();<br>        ByteBufAllocator byteBufAllocator = ctx.alloc();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>            ByteBuf byteBuf = byteBufAllocator.buffer(request.length());<br>            byteBuf.writeBytes(request.getBytes());<br>            ctx.writeAndFlush(byteBuf);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端接收结果：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310112339961.png" style="zoom:50%;" /></center><h4 id="1-2-TCP粘包-半包发生的原因"><a href="#1-2-TCP粘包-半包发生的原因" class="headerlink" title="1.2 TCP粘包/半包发生的原因"></a>1.2 TCP粘包/半包发生的原因</h4><p>　　由于 TCP 协议本身的机制（面向连接的可靠地协议-三次握手机制）客户端与服务器会维持一个连接（Channel），数据在连接不断开的情况下，可以持续不断地将多个数据包发往服务器，但是如果发送的网络数据包太小，那么他本身会启用 Nagle 算法（可配置是否启用）对较小的数据包进行合并（基于此，TCP 的网络延迟要 UDP 的高些）然后再发送（超时或者包大小足够）。那么这样的话，服务器在接收到消息（数据流）的时候就无法区分哪些数据包是客户端自己分开发送的，这样产生了粘包；服务器在接收到数据库后，放到缓冲区中，如果消息没有被及时从缓存区取走，下次在取数据的时候可能就会出现一次取出多个数据包的情况，造成粘包现象</p><p>　　UDP：本身作为无连接的不可靠的传输协议（适合频繁发送较小的数据包），他不会对数据包进行合并发送（也就没有 Nagle 算法之说了），他直接是一端发送什么数据，直接就发出去了，既然他不会对数据合并，每一个数据包都是完整的（数据+UDP头+IP头等等发一次数据封装一次）也就没有粘包一说了。</p><p>　　更具体的原因至少包括：</p><ol><li>应用程序写入数据的字节大小大于套接字发送缓冲区的大小</li><li>进行 MSS 大小的 TCP 分段。MSS 是最大报文段长度的缩写。MSS 是 TCP 报文段中的数据字段的最大长度。数据字段加上 TCP 首部才等于整个的 TCP 报文段。所以 MSS 并不是 TCP 报文段的最大长度，而是：MSS = TCP报文段长度 - TCP首部长度。</li></ol><h4 id="1-3-解决粘包半包"><a href="#1-3-解决粘包半包" class="headerlink" title="1.3 解决粘包半包"></a>1.3 解决粘包半包</h4><p>　　由于底层的 TCP 无法理解上层的业务数据，所以在底层是无法保证数据包不被拆分和重组的，这个问题只能通过上层的应用协议栈设计来解决，根据业界的主流协议的解决方案，可以归纳如下。</p><h5 id="1-增加分割符"><a href="#1-增加分割符" class="headerlink" title="1. 增加分割符"></a>1. 增加分割符</h5><p>　　比如回车换行符进行分割，例如 FTP 协议；</p><p>　　<strong>使用回车换行符进行分割</strong></p><p>Netty 提供了 LineBasedFrameDecoder，以换行符（ “\n” 或  “\r\n”）作为分隔符。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">bootstrap.group(group)<br>        .channel(NioServerSocketChannel.class)<span class="hljs-comment">/*指定使用NIO的通信模式*/</span><br>        .localAddress(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-keyword">this</span>.port))<span class="hljs-comment">/*指定监听端口*/</span><br>        .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> LineBasedFrameDecoder(<span class="hljs-number">1024</span>));<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> EchoStickyHalfServerHandler());<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310112357687.png" style="zoom:50%;" /></center><p>　　【注】LineBasedFrameDecoder 要在接收数据的 ChannelHandler 之前</p><p>　　<strong>自定义分割符</strong></p><p>　　发送数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    String request = <span class="hljs-string">&quot;debuggingWorld&quot;</span> + EchoStickyHalfServer.DELIMITER_SYMBOL;<br>    ByteBufAllocator byteBufAllocator = ctx.alloc();<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        ByteBuf byteBuf = byteBufAllocator.buffer(request.length());<br>        byteBuf.writeBytes(request.getBytes());<br>        ctx.writeAndFlush(byteBuf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　使用 DelimiterBasedFrameDecoder 自定义分隔符分隔：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String DELIMITER_SYMBOL = <span class="hljs-string">&quot;@＃&quot;</span>;<br><br>bootstrap.group(group)<br>        .channel(NioServerSocketChannel.class)<span class="hljs-comment">/*指定使用NIO的通信模式*/</span><br>        .localAddress(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-keyword">this</span>.port))<span class="hljs-comment">/*指定监听端口*/</span><br>        .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                ByteBuf byteBuf = Unpooled.copiedBuffer(DELIMITER_SYMBOL.getBytes());<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> DelimiterBasedFrameDecoder(<span class="hljs-number">1024</span>,byteBuf));<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> EchoStickyHalfServerHandler());<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><h5 id="2-消息定长"><a href="#2-消息定长" class="headerlink" title="2. 消息定长"></a>2. 消息定长</h5><p>例如每个报文的大小为固定长度 200 字节，如果不够，空位补空格；</p><p>　　使用 FixedLengthFrameDecoder 解码器。</p><p>发送数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        ByteBuf byteBuf = Unpooled.buffer(REQUEST_Length);<br>        byteBuf.writeBytes(REQUEST.getBytes());<br>        ctx.writeAndFlush(byteBuf);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　接受数据：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">bootstrap.group(eventLoopGroup)<br>        .channel(NioSocketChannel.class)<br>        .remoteAddress(<span class="hljs-keyword">new</span> InetSocketAddress(host, port))<span class="hljs-comment">/*指定服务器的IP地址和端口*/</span><br>        .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> FixedLengthFrameDecoder(REQUEST_Length));<br>                ch.pipeline().addLast(<span class="hljs-keyword">new</span> EchoStickyHalfClientHandler());<br>            &#125;<br>        &#125;);<br></code></pre></td></tr></table></figure><h5 id="3-指定长度"><a href="#3-指定长度" class="headerlink" title="3. 指定长度"></a>3. 指定长度</h5><p>　　将消息分为消息头和消息体，消息头中包含表示消息总长度（或者消息体长度）的字段，通常设计思路为消息头的第一个字段使用 int32 来表示消息的总长度，使用 LengthFieldBasedFrameDecoder。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LengthFieldBasedFrameDecoder</span><span class="hljs-params">(<span class="hljs-keyword">int</span> maxFrameLength, <span class="hljs-keyword">int</span> lengthFieldOffset, <span class="hljs-keyword">int</span> lengthFieldLength,</span></span><br><span class="hljs-params"><span class="hljs-function">                                    <span class="hljs-keyword">int</span> lengthAdjustment, <span class="hljs-keyword">int</span> initialBytesToStrip, <span class="hljs-keyword">boolean</span> failFast)</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>maxFrameLength：包的最大长度</li><li>lengthFieldOffset：长度域的偏移量，表示跳过指定个数字节之后的才是长度域</li><li>lengthFieldLength：记录该帧数据长度的字段，也就是长度域本身的长度</li><li>lengthAdjustment：长度的一个修正值，可正可负，Netty 在读取到数据包的长度值 N 后，认为接下来的 N 个字节都是需要读取的，但是根据实际情况，有可能需要增加 N 的值，也有可能需要减少 N 的值。</li><li>initialBytesToStrip：从数据帧中跳过的字节数，表示得到一个完整的数据包之后，扔掉这个数据包中多少字节数，才是后续业务实际需要的业务数据（往后传的时候，丢掉多少字节）。</li><li>failFast：如果为 true，则表示读取到长度域，TA 的值的超过 maxFrameLength，就抛出一个 TooLongFrameException，而为 false 表示只有当真正读取完长度域的值表示的字节之后，才会抛出 TooLongFrameException，默认情况下设置为 true，建议不要修改，否则可能会造成内存溢出。</li></ul><p>　　示例：以下用四元组表示以下编码（lengthFieldOffset，lengthFieldLength，lengthAdjustment，initialBytesToStrip）</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310170001704.png" style="zoom:50%;" /><br/>(0,2,0,0)</center><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310162312629.png" style="zoom:50%;" />  <br/>(0,2,0,2)</center>  <center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310162317041.png" style="zoom:50%;" />  <br/>(0,2,-2,0)</center><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310162320446.png" style="zoom:50%;" />  <br/>(2,3,0,0)</center><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310162322306.png" style="zoom:50%;" />  <br/>(0,3,2,0)</center><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310162326365.png" style="zoom:50%;" />  <br/>(1,2,1,3)</center> <center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310162329958.png" style="zoom:50%;" />  <br/>(1,2,-3,3)</center><p>　　<strong>使用示例：</strong></p><p>　　见：3.3.2  MessagePack</p><p>　　发送：</p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310162338583.png" style="zoom:50%;" /><p>　　接收：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310162340436.png" style="zoom:50%;" /></center><h4 id="1-4-辨析channelRead和channelReadComplete"><a href="#1-4-辨析channelRead和channelReadComplete" class="headerlink" title="1.4 辨析channelRead和channelReadComplete"></a>1.4 辨析channelRead和channelReadComplete</h4><p>两者的区别：</p><p>　　Netty 是在读到完整的业务请求报文后才调用一次业务 ChannelHandler 的 channelRead 方法，无论这条报文底层经过了几次 SocketChannel 的 read 调用（一包业务数据调用一次，不管分了多少包）。</p><p>　　但是 channelReadComplete 方法并不是在业务语义上的读取消息完成后被触发的，而是在每次从 SocketChannel 成功读到消息后，由系统触发，也就是说如果一个业务消息被 TCP 协议栈发送了 N 次，则服务端的 channelReadComplete 方法就会被调用 N 次（也就是读取 ByteBuf 的次数）。</p><h3 id="2-编解码器"><a href="#2-编解码器" class="headerlink" title="2. 编解码器"></a>2. 编解码器</h3><h4 id="2-1-什么是编解码器"><a href="#2-1-什么是编解码器" class="headerlink" title="2.1 什么是编解码器"></a>2.1 什么是编解码器</h4><p>　　每个网络应用程序都必须定义如何解析在两个节点之间来回传输的原始字节，以及如何将其和目标应用程序的数据格式做相互转换。这种转换逻辑由编解码器处理，编解码器由编码器和解码器组成，它们每种都可以将字节流从一种格式转换为另一种格式。那么它们的区别是什么呢？</p><p>　　如果将消息看作是对于特定的应用程序具有具体含义的结构化的字节序列，那么编码器是将消息转换为适合于传输的格式（最有可能的就是字节流）；而对应的解码器则是将网络字节流转换回应用程序的消息格式。因此，编码器操作出站数据，而解码器处理入站数据。解决粘包半包其实也是编解码器框架的一部分。</p><h4 id="2-2-解码器"><a href="#2-2-解码器" class="headerlink" title="2.2 解码器"></a>2.2 解码器</h4><p>　　+ ByteToMessageDecoder——将字节解码为消息<br>　　+ MessageToMessageDecoder——将一种消息类型解码为另一种消息类型</p><p>　　因为解码器是负责将入站数据从一种格式转换到另一种格式的，所以 Netty 的解码器实现了 ChannelInboundHandler。</p><p>　　什么时候会用到解码器呢？很简单：每当需要为 ChannelPipeline 中的下一个 ChannelInboundHandler 转换入站数据时会用到。此外，得益于 ChannelPipeline 的设计，可以将多个解码器链接在一起，以实现任意复杂的转换逻辑。</p><blockquote><p>例如通过 JSON 交换信息，而且 JSON 文本需要加密，接收端就可以：</p><ol><li>网络加密报文 -&gt; 经过 ByteToMessageDecoder -&gt; String 类型的 JSON 明文</li><li>String 类型的 JSON 文本-&gt; 经过 MessageToMessageDecoder -&gt; Java 中的对象</li></ol></blockquote><p>　　所以我们可以把 ByteToMessageDecoder 看成一次解码器，MessageToMessageDecoder 看成二次或者多次解码器。</p><h5 id="1-将字节解码为消息"><a href="#1-将字节解码为消息" class="headerlink" title="1. 将字节解码为消息"></a>1. 将字节解码为消息</h5><p>　　<strong>抽象类 ByteToMessageDecoder</strong></p><p>　　将字节解码为消息（或者另一个字节序列）是一项如此常见的任务，Netty 为它提供了一个抽象的基类：ByteToMessageDecoder。由于你不可能知道远程节点是否会一次性地发送一个完整的消息，所以这个类会对入站数据进行缓冲，直到它准备好处理。</p><p>　　它最重要方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteToMessageDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>  ......<br>&#125;<br></code></pre></td></tr></table></figure><p>　　是必须实现的唯一抽象方法。decode() 方法被调用时将会传入一个包含了传入数据的 ByteBuf，以及一个用来添加解码消息的 List。对这个方法的调用将会重复进行，直到确定没有新的元素被添加到该 List，或者该 ByteBuf 中没有更多可读取的字节时为止。然后，如果该 List 不为空，那么它的内容将会被传递给 ChannelPipeline 中的下一个 ChannelInboundHandler。</p><h5 id="2-将一种消息类型解码为另一种"><a href="#2-将一种消息类型解码为另一种" class="headerlink" title="2. 将一种消息类型解码为另一种"></a>2. 将一种消息类型解码为另一种</h5><p>　　在两个消息格式之间进行转换（例如，从 String-&gt;Integer）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageToMessageDecoder</span>&lt;<span class="hljs-title">I</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    ....<br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, I msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>　　对于每个需要被解码为另一种格式的入站消息来说，该方法都将会被调用。解码消息随后会被传递给 ChannelPipeline 中的下一个 ChannelInboundHandler。</p><p>　　MessageToMessageDecoder&lt;I&gt; 其中 I 代表源数据的类型。</p><h5 id="3-TooLongFrameException"><a href="#3-TooLongFrameException" class="headerlink" title="3. TooLongFrameException"></a>3. TooLongFrameException</h5><p>　　由于 Netty 是一个异步框架，所以需要在字节可以解码之前在内存中缓冲它们。因此，不能让解码器缓冲大量的数据以至于耗尽可用的内存。为了解除这个常见的顾虑，Netty 提供了 TooLongFrameException 类，其将由解码器在帧超出指定的大小限制时抛出。</p><p>　　为了避免这种情况，你可以设置一个最大字节数的阈值，如果超出该阈值，则会导致抛出一个 TooLongFrameException（随后会被 ChannelHandler.exceptionCaught() 方法捕获）。然后，如何处理该异常则完全取决于该解码器的用户。某些协议（如 HTTP）可能允许你返回一个特殊的响应。而在其他的情况下，唯一的选择可能就是关闭对应的连接。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310142346167.png" style="zoom:50%;" /></center><h4 id="2-3-编码器"><a href="#2-3-编码器" class="headerlink" title="2.3 编码器"></a>2.3 编码器</h4><p>　　解码器的功能正好相反。Netty 提供了一组类，用于编写具有以下功能的编码器：</p><ul><li>MessageToByteEncoder&lt;I&gt;——将消息编码为字节</li><li>MessageToMessageEncoder&lt;T&gt;——将消息编码为消息，T 代表源数据的类型</li></ul><blockquote><p>还是上面的业务场景，两端通信，通过 JSON 交换信息，而且 JSON 文本需要加密，发送端就可以：</p><p>Java 中的对象-&gt; 经过 MessageToMessageEncoder -&gt; String 类型的 JSON 文本</p><p>String 类型的 JSON 明文 -&gt; 经过 MessageToByteEncoder -&gt; 网络加密报文</p></blockquote><p>　　所以我们可以把 MessageToByteEncoder 看成网络报文编码器，MessageToMessageEncoder 看成业务编码器。</p><h5 id="1-将消息编码为字节"><a href="#1-将消息编码为字节" class="headerlink" title="1. 将消息编码为字节"></a>1. 将消息编码为字节</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">I</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelOutboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, I msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>　　encode() 方法是你需要实现的唯一抽象方法。它被调用时将会传入要被该类编码为 ByteBuf 的出站消息（类型为 I ）。该 ByteBuf 随后将会被转发给 ChannelPipeline 中的下一个 ChannelOutboundHandler。</p><h5 id="2-将消息编码为消息"><a href="#2-将消息编码为消息" class="headerlink" title="2. 将消息编码为消息"></a>2. 将消息编码为消息</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageToMessageEncoder</span>&lt;<span class="hljs-title">I</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelOutboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, I msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br><br></code></pre></td></tr></table></figure><p>　　这是需要实现的唯一方法。每个通过 write() 方法写入的消息都将会被传递给 encode() 方法，以编码为一个或者多个出站消息。随后，这些出站消息将会被转发给 ChannelPipeline 中的下一个 ChannelOutboundHandler。</p><h4 id="2-4-编解码器类"><a href="#2-4-编解码器类" class="headerlink" title="2.4 编解码器类"></a>2.4 编解码器类</h4><p>　　我们一直将解码器和编码器作为单独的实体讨论，但是有时在同一个类中管理入站和出站数据和消息的转换是很有用的。Netty 的抽象编解码器类正好用于这个目的，因为它们每个都将捆绑一个解码器/编码器对。这些类同时实现了 ChannelInboundHandler 和 ChannelOutboundHandler 接口。</p><p>　　为什么我们并没有一直优先于单独的解码器和编码器使用这些复合类呢？因为通过尽可能地将这两种功能分开，最大化了代码的可重用性和可扩展性，这是 Netty 设计的一个基本原则。</p><p>　　相关的类：</p><p>　　抽象类 <strong>ByteToMessageCodec</strong></p><p>　　抽象类 <strong>MessageToMessageCodec</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ByteToMessageCodec</span>&lt;<span class="hljs-title">I</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelDuplexHandler</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> MessageToByteEncoder#encode(ChannelHandlerContext, Object, ByteBuf)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, I msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@see</span> ByteToMessageDecoder#decode(ChannelHandlerContext, ByteBuf, List)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf in, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-5-实现SSL-TLS和Web服务"><a href="#2-5-实现SSL-TLS和Web服务" class="headerlink" title="2.5 实现SSL/TLS和Web服务"></a>2.5 实现SSL/TLS和Web服务</h4><h5 id="1-通过SSL-TLS-保护Netty-应用程序"><a href="#1-通过SSL-TLS-保护Netty-应用程序" class="headerlink" title="1. 通过SSL/TLS 保护Netty 应用程序"></a>1. 通过SSL/TLS 保护Netty 应用程序</h5><p>　　SSL 和 TLS 这样的安全协议，它们层叠在其他协议之上，用以实现数据安全。我们在访问安全网站时遇到过这些协议，但是它们也可用于其他不是基于 HTTP 的应用程序，如安全 SMTP（SMTPS）邮件服务器甚至是关系型数据库系统。</p><p>　　为了支持 SSL/TLS，Java 提供了 javax.net.ssl 包，它的 SSLContext 和 SSLEngine 类使得实现解密和加密相当简单直接。Netty 通过一个名为 SslHandler 的 ChannelHandler 实现利用了这个 API，其中 SslHandler 在内部使用 SSLEngine 来完成实际的工作。</p><p>　　在大多数情况下，SslHandler 将是 ChannelPipeline 中的第一个 ChannelHandler。</p><h5 id="2-HTTP-系列"><a href="#2-HTTP-系列" class="headerlink" title="2 HTTP 系列"></a>2 HTTP 系列</h5><p>　　HTTP 是基于请求/响应模式的：客户端向服务器发送一个 HTTP 请求，然后服务器将会返回一个 HTTP 响应。Netty 提供了多种编码器和解码器以简化对这个协议的使用。</p><p>　　一个 HTTP 请求/响应可能由多个数据部分组成，FullHttpRequest 和 FullHttpResponse 消息是特殊的子类型，分别代表了完整的请求和响应。所有类型的 HTTP 消息（FullHttpRequest、LastHttpContent 等等）都实现了HttpObject 接口。</p><ol><li>HttpRequestEncoder 将 HttpRequest、HttpContent 和 LastHttpContent 消息编码为字节</li><li>HttpResponseEncoder 将 HttpResponse、HttpContent 和 LastHttpContent 消息编码为字节</li><li>HttpRequestDecoder 将字节解码为 HttpRequest、HttpContent 和 LastHttpContent 消息</li><li>HttpResponseDecoder 将字节解码为 HttpResponse、HttpContent 和 LastHttpContent 消息</li></ol><p>　　HttpClientCodec 和 HttpServerCodec 则将请求和响应做了一个组合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpClientCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CombinedChannelDuplexHandler</span>&lt;<span class="hljs-title">HttpResponseDecoder</span>, <span class="hljs-title">HttpRequestEncoder</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpClientUpgradeHandler</span>.<span class="hljs-title">SourceCodec</span> </span>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServerCodec</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CombinedChannelDuplexHandler</span>&lt;<span class="hljs-title">HttpRequestDecoder</span>, <span class="hljs-title">HttpResponseEncoder</span>&gt;</span><br><span class="hljs-class">        <span class="hljs-keyword">implements</span> <span class="hljs-title">HttpServerUpgradeHandler</span>.<span class="hljs-title">SourceCodec</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-聚合HTTP消息"><a href="#3-聚合HTTP消息" class="headerlink" title="3 聚合HTTP消息"></a>3 聚合HTTP消息</h5><p>　　由于 HTTP 的请求和响应可能由许多部分组成，因此你需要聚合它们以形成完整的消息。为了消除这项繁琐的任务，Netty 提供了一个聚合器 HttpObjectAggregator，它可以将多个消息部分合并为 FullHttpRequest 或者 FullHttpResponse 消息。通过这样的方式，你将总是看到完整的消息内容。</p><h5 id="4-HTTP-压缩"><a href="#4-HTTP-压缩" class="headerlink" title="4 HTTP 压缩"></a>4 HTTP 压缩</h5><p>　　当使用 HTTP 时，建议开启压缩功能以尽可能多地减小传输数据的大小。虽然压缩会带来一些 CPU 时钟周期上的开销，但是通常来说它都是一个好主意，特别是对于文本数据来说。Netty 为压缩和解压缩提供了 ChannelHandler 实现，它们同时支持 gzip 和 deflate 编码。</p><h5 id="5-使用HTTPS"><a href="#5-使用HTTPS" class="headerlink" title="5 使用HTTPS"></a>5 使用HTTPS</h5><p>　　启用 HTTPS 只需要将 SslHandler 添加到 ChannelPipeline 的 ChannelHandler 组合中。</p><h5 id="6-示例"><a href="#6-示例" class="headerlink" title="6. 示例"></a>6. 示例</h5><p>　　<strong>服务端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpServer</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port = <span class="hljs-number">6789</span>; <span class="hljs-comment">//设置服务端端口</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> EventLoopGroup LOOP_GROUP = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ServerBootstrap BOOTSTRAP = <span class="hljs-keyword">new</span> ServerBootstrap();<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> SSL = <span class="hljs-keyword">true</span>;<span class="hljs-comment">/*是否开启SSL模式*/</span><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">final</span> SslContext sslCtx;<br>        <span class="hljs-keyword">if</span> (SSL) &#123;<br>            SelfSignedCertificate ssc = <span class="hljs-keyword">new</span> SelfSignedCertificate();<br>            sslCtx = SslContextBuilder.forServer(ssc.certificate(), ssc.privateKey()).build();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            sslCtx = <span class="hljs-keyword">null</span>;<br>        &#125;<br>        <span class="hljs-keyword">try</span> &#123;<br>            BOOTSTRAP.group(LOOP_GROUP).channel(NioServerSocketChannel.class)<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            ChannelPipeline pipeline = ch.pipeline();<br>                            <span class="hljs-keyword">if</span> (sslCtx != <span class="hljs-keyword">null</span>) &#123;<br>                                pipeline.addLast(sslCtx.newHandler(ch.alloc()));<br>                            &#125;<br>                            <span class="hljs-comment">/*把应答报文 编码*/</span><br>                            pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> HttpResponseEncoder());<br>                            <span class="hljs-comment">/*把请求报文 解码*/</span><br>                            pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> HttpRequestDecoder());<br>                            <span class="hljs-comment">// 以上两个 ChannelHandler 相当于 new HttpServerCodec()</span><br>                            <span class="hljs-comment">/*聚合http为一个完整的报文*/</span><br>                            pipeline.addLast(<span class="hljs-string">&quot;aggregator&quot;</span>, <span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>));<br>                            <span class="hljs-comment">/*把应答报文压缩,非必要*/</span><br>                            pipeline.addLast(<span class="hljs-string">&quot;compressor&quot;</span>, <span class="hljs-keyword">new</span> HttpContentCompressor());<br>                            pipeline.addLast(<span class="hljs-keyword">new</span> BusinessHandler());<br>                        &#125;<br>                    &#125;);<br>            <span class="hljs-comment">// 服务器绑定端口监听</span><br>            ChannelFuture channelFuture = BOOTSTRAP.bind(port).sync();<br>            System.out.println(<span class="hljs-string">&quot;服务端启动成功,端口是:&quot;</span> + port);<br>            System.out.println(<span class="hljs-string">&quot;服务器启动模式： &quot;</span> + (SSL ? <span class="hljs-string">&quot;SSL安全模式&quot;</span> : <span class="hljs-string">&quot;普通模式&quot;</span>));<br>            <span class="hljs-comment">// 监听服务器关闭监听</span><br>            channelFuture.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            LOOP_GROUP.shutdownGracefully();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　服务端业务 handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BusinessHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 发送的返回值</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> ctx     返回</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> context 消息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> status  状态</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">send</span><span class="hljs-params">(ChannelHandlerContext ctx, String context, HttpResponseStatus status)</span> </span>&#123;<br>        FullHttpResponse response = <span class="hljs-keyword">new</span> DefaultFullHttpResponse(<br>                HttpVersion.HTTP_1_1, status,<br>                Unpooled.copiedBuffer(context, CharsetUtil.UTF_8)<br>        );<br>        response.headers().set(HttpHeaderNames.CONTENT_TYPE, <span class="hljs-string">&quot;text/plain;charset=UTF-8&quot;</span>);<br>        ctx.writeAndFlush(response).addListener(ChannelFutureListener.CLOSE);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        String result = <span class="hljs-string">&quot;&quot;</span>;<br>        FullHttpRequest httpRequest = (FullHttpRequest) msg;<br>        System.out.println(httpRequest.headers());<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//获取路径</span><br>            String path = httpRequest.uri();<br>            <span class="hljs-comment">//获取body</span><br>            String body = httpRequest.content().toString(CharsetUtil.UTF_8);<br>            <span class="hljs-comment">//获取请求方法</span><br>            HttpMethod method = httpRequest.method();<br>            System.out.println(<span class="hljs-string">&quot;接收到:&quot;</span> + method + <span class="hljs-string">&quot; 请求&quot;</span>);<br>            <span class="hljs-comment">//如果不是这个路径，就直接返回错误</span><br>            <span class="hljs-keyword">if</span> (!<span class="hljs-string">&quot;/test&quot;</span>.equalsIgnoreCase(path)) &#123;<br>                result = <span class="hljs-string">&quot;非法请求!&quot;</span> + path;<br>                send(ctx, result, HttpResponseStatus.BAD_REQUEST);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br><br>            <span class="hljs-comment">//如果是GET请求</span><br>            <span class="hljs-keyword">if</span> (HttpMethod.GET.equals(method)) &#123;<br>                <span class="hljs-comment">//接受到的消息，做业务逻辑处理...</span><br>                System.out.println(<span class="hljs-string">&quot;body:&quot;</span> + body);<br>                result = <span class="hljs-string">&quot;GET请求,应答:&quot;</span> + RespConstant.getNews();<br>                send(ctx, result, HttpResponseStatus.OK);<br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>            <span class="hljs-comment">//如果是其他类型请求，如post</span><br>            <span class="hljs-keyword">if</span> (HttpMethod.POST.equals(method)) &#123;<br>                <span class="hljs-comment">//接受到的消息，做业务逻辑处理...</span><br>                <span class="hljs-comment">//....</span><br>                <span class="hljs-keyword">return</span>;<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            System.out.println(<span class="hljs-string">&quot;处理请求失败!&quot;</span>);<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">//释放请求</span><br>            httpRequest.release();<br>        &#125;<br>    &#125;<br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">     * 建立连接时，返回消息</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;连接的客户端地址:&quot;</span> + ctx.channel().remoteAddress());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　<strong>客户端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpClient</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String HOST = <span class="hljs-string">&quot;127.0.0.1&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(String host, <span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap().group(workerGroup).channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> HttpClientCodec())<br>                                    <span class="hljs-comment">/*聚合http为一个完整的报文*/</span><br>                                    .addLast(<span class="hljs-string">&quot;aggregator&quot;</span>, <span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>))<br>                                    <span class="hljs-comment">/*解压缩*/</span><br>                                    .addLast(<span class="hljs-string">&quot;decompressor&quot;</span>, <span class="hljs-keyword">new</span> HttpContentDecompressor())<br>                                    .addLast(<span class="hljs-keyword">new</span> BusinessClientInboundHandler());<br>                        &#125;<br>                    &#125;);<br><br>            ChannelFuture future = bootstrap.connect(host, port).sync();<br>            future.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">if</span> (HttpServer.SSL) &#123;<br>            System.out.println(<span class="hljs-string">&quot;服务器处于SSL模式，本客户端不支持，退出&quot;</span>);<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        HttpClient client = <span class="hljs-keyword">new</span> HttpClient();<br>        client.connect(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, HttpServer.port);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　客户端端业务 handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BusinessClientInboundHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        FullHttpResponse httpResponse = (FullHttpResponse) msg;<br>        System.out.println(httpResponse.status());<br>        System.out.println(httpResponse.headers());<br>        ByteBuf buf = httpResponse.content();<br>        System.out.println(buf.toString(CharsetUtil.UTF_8));<br>        httpResponse.release();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        URI uri = <span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;/test&quot;</span>);<br>        String msg = <span class="hljs-string">&quot;Hello&quot;</span>;<br>        DefaultFullHttpRequest request =<br>                <span class="hljs-keyword">new</span> DefaultFullHttpRequest(HttpVersion.HTTP_1_1, HttpMethod.GET, uri.toASCIIString(),<br>                        Unpooled.wrappedBuffer(msg.getBytes(StandardCharsets.UTF_8)));<br><br>        <span class="hljs-comment">// 构建http请求</span><br>        request.headers().set(HttpHeaderNames.HOST, HttpClient.HOST);<br>        request.headers().set(HttpHeaderNames.CONNECTION, HttpHeaderValues.KEEP_ALIVE);<br>        request.headers().set(HttpHeaderNames.CONTENT_LENGTH, request.content().readableBytes());<br>        <span class="hljs-comment">// 发送http请求</span><br>        ctx.writeAndFlush(request);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="7-根据客户端的访问来决定是否启用SSL"><a href="#7-根据客户端的访问来决定是否启用SSL" class="headerlink" title="7. 根据客户端的访问来决定是否启用SSL"></a>7. 根据客户端的访问来决定是否启用SSL</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AutoSSLServerHandlerInit</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">SocketChannel</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> SslContext sslCtx;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">AutoSSLServerHandlerInit</span><span class="hljs-params">(SslContext sslCtx)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sslCtx = sslCtx;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ChannelPipeline pipeline = ch.pipeline();<br><br>        <span class="hljs-comment">/*根据客户端的访问来决定是否启用SSL*/</span><br>        pipeline.addLast(<span class="hljs-keyword">new</span> OptionalSslHandler(sslCtx));<br>        <span class="hljs-comment">/*把应答报文 编码*/</span><br>        pipeline.addLast(<span class="hljs-string">&quot;encoder&quot;</span>, <span class="hljs-keyword">new</span> HttpResponseEncoder());<br>        <span class="hljs-comment">/*把请求报文 解码*/</span><br>        pipeline.addLast(<span class="hljs-string">&quot;decoder&quot;</span>, <span class="hljs-keyword">new</span> HttpRequestDecoder());<br><br>        <span class="hljs-comment">/*聚合http为一个完整的报文*/</span><br>        pipeline.addLast(<span class="hljs-string">&quot;aggregator&quot;</span>, <span class="hljs-keyword">new</span> HttpObjectAggregator(<span class="hljs-number">10</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">1024</span>));<br>        <span class="hljs-comment">/*把应答报文 压缩,非必要*/</span><br>        pipeline.addLast(<span class="hljs-string">&quot;compressor&quot;</span>, <span class="hljs-keyword">new</span> HttpContentCompressor());<br>        pipeline.addLast(<span class="hljs-keyword">new</span> BusinessHandler());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-序列化问题"><a href="#3-序列化问题" class="headerlink" title="3. 序列化问题"></a>3. 序列化问题</h3><p>　　序列化的目的主要有两个：</p><ol><li>网络传输</li><li>对象持久化</li></ol><p>　　当选行远程跨迸程服务调用时，需要把被传输的 Java 对象编码为字节数组或者 ByteBuffer 对象。而当远程服务读取到 ByteBuffer 对象或者字节数组时，需要将其解码为发送时的 Java 对象。</p><p>　　Java 序列化仅仅是 Java 编解码技术的一种，由于它的种种缺陷，衍生出了多种编解码技术和框架</p><h4 id="3-1-Java序列化的缺点"><a href="#3-1-Java序列化的缺点" class="headerlink" title="3.1 Java序列化的缺点"></a>3.1 Java序列化的缺点</h4><p>　　Java 序列化从 JDK1.1 版本就已经提供，它不需要添加额外的类库，只需实现 java.io.Serializable 并生成序列 ID 即可，因此，它从诞生之初就得到了广泛的应用。</p><p>　　但是在远程服务调用（RPC）时，很少直接使用 Java 序列化进行消息的编解码和传输，这又是什么原因呢？下面通过分析.Tava序列化的缺点来找出答案。</p><ol><li>无法跨语言</li></ol><p>　　对于跨进程的服务调用，服务提供者可能会使用 C++ 或者其他语言开发，当我们需要和异构语言进程交互时 Java 序列化就难以胜任。由于 Java 序列化技术是 Java 语言内部的私有协议，其他语言并不支持，对于用户来说它完全是黑盒。对于 Java 序列化后的字节数组，别的语言无法进行反序列化，这就严重阻碍了它的应用。</p><ol start="2"><li>序列化后的码流太大</li><li>序列化性能太低</li></ol><p>　　无论是序列化后的码流大小，还是序列化的性能，JDK 默认的序列化机制表现得都很差。因此，我们通常不会选择 Java 序列化作为远程跨节点调用的编解码框架。</p><h4 id="3-2-如何选择序列化框架"><a href="#3-2-如何选择序列化框架" class="headerlink" title="3.2 如何选择序列化框架"></a>3.2 如何选择序列化框架</h4><p>　　<strong>选择四要点：</strong></p><ol><li>是否需要跨语言的支持</li><li>空间:编码后占用空间</li><li>时间:编解码速度</li><li>是否追求可读性</li></ol><p><strong>序列化框架比较</strong></p><p>　　<a href="https://developer.aliyun.com/article/783611?utm_content=g_1000268438">（传送门：阿里开发者社区）</a></p><p>　　空间比较：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310152155741.png" style="zoom:50%;" /></center><p>　　时间比较：</p><p>　　kryo preregister 和 fst preregister 都能提供优异的性能，其中 fst pre 序列化时间就最佳，而 kryo pre 在序列化和反序列化时间开销上基本一致。所以，如果序列化时间是主要的考虑指标，可以选择 Kryo 或 FST，都能提供不错的性能体验。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310152157946.png" style="zoom:50%;" /></center><h4 id="3-3-序列化示例"><a href="#3-3-序列化示例" class="headerlink" title="3.3 序列化示例"></a>3.3 序列化示例</h4><p>　　Netty 内置了对 JBoss Marshalling 和 Protocol Buffers 的支持。</p><h5 id="1-Protocol-Buffers-示例"><a href="#1-Protocol-Buffers-示例" class="headerlink" title="1. Protocol Buffers 示例"></a>1. Protocol Buffers 示例</h5><p>　　<strong>添加依赖：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.google.protobuf<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>protobuf-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.16.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>　　<strong>服务端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProtoBufServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">bind</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        EventLoopGroup bossGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        EventLoopGroup workerGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>            bootstrap.group(bossGroup, workerGroup)<br>                    .channel(NioServerSocketChannel.class)<br>                    .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> </span>&#123;<br>                            <span class="hljs-comment">/*去除消息长度部分，同时根据这个消息长度读取实际的数据*/</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtobufVarint32FrameDecoder())<br>                                    <span class="hljs-comment">// 反序列化</span><br>                                    .addLast(<span class="hljs-keyword">new</span> ProtobufDecoder(PersonProto.Person.getDefaultInstance()))<br>                                    .addLast(<span class="hljs-keyword">new</span> ProtoBufServerHandler());<br>                        &#125;<br>                    &#125;);<br><br>            ChannelFuture f = bootstrap.bind(port).sync();<br>            System.out.println(<span class="hljs-string">&quot;init start&quot;</span>);<br>            f.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-comment">// 优雅退出，释放线程池资源</span><br>            bossGroup.shutdownGracefully();<br>            workerGroup.shutdownGracefully();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">8080</span>;<br>        <span class="hljs-keyword">new</span> ProtoBufServer().bind(port);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　服务端业务 handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProtoBufServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        PersonProto.Person req = (PersonProto.Person) msg;<br>        System.out.println(<span class="hljs-string">&quot;get data name = &quot;</span> + req.getName());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cause <span class="hljs-keyword">instanceof</span> IOException) &#123;<br>            System.out.println(<span class="hljs-string">&quot;远程客户端强迫关闭了一个现有的连接。&quot;</span>);<br>        &#125;<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　<strong>客户端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProtoBufClient</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">connect</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port, String host)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        EventLoopGroup group = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-keyword">try</span> &#123;<br>            Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>            bootstrap.group(group)<br>                    .channel(NioSocketChannel.class)<br>                    .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                        <span class="hljs-meta">@Override</span><br>                        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                            <span class="hljs-comment">/*加一个消息长度，由netty自动计算*/</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtobufVarint32LengthFieldPrepender());<br>                            <span class="hljs-comment">/*负责编码,序列化*/</span><br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtobufEncoder());<br>                            ch.pipeline().addLast(<span class="hljs-keyword">new</span> ProtoBufClientHandler());<br>                        &#125;<br>                    &#125;);<br><br>            ChannelFuture future = bootstrap.connect(host, port).sync();<br>            future.channel().closeFuture().sync();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            group.shutdownGracefully();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">8080</span>;<br>        <span class="hljs-keyword">new</span> ProtoBufClient().connect(port, <span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　客户端端业务 handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProtoBufClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Prepare to make data........&quot;</span>);<br>        PersonProto.Person.Builder builder = PersonProto.Person.newBuilder();<br>        builder.setName(<span class="hljs-string">&quot;debuggingWorld&quot;</span>);<br>        builder.setId(<span class="hljs-number">1</span>);<br>        builder.setEmail(<span class="hljs-string">&quot;debuggingWorld@xxx.com&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;send data........&quot;</span>);<br>        ctx.writeAndFlush(builder.build());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> </span>&#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-集成第三方MessagePack"><a href="#2-集成第三方MessagePack" class="headerlink" title="2. 集成第三方MessagePack"></a>2. 集成第三方MessagePack</h5><p>　　<strong>添加依赖：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.msgpack<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>msgpack<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.6.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>　　<strong>发送对象：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ToString</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@Message</span><span class="hljs-comment">//MessagePack 提供的注解，表明这是一个需要序列化的实体类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">private</span> UserContact userContact;<br>&#125;<br><br><span class="hljs-meta">@ToString</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@Message</span><span class="hljs-comment">//MessagePack 提供的注解，表明这是一个需要序列化的实体类</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserContact</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String mail;<br>    <span class="hljs-keyword">private</span> String phone;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　<strong>服务端 handler：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelInitializerImp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ch.pipeline().addLast(<span class="hljs-keyword">new</span> LengthFieldBasedFrameDecoder(<span class="hljs-number">65535</span>,<br>                <span class="hljs-number">0</span>, <span class="hljs-number">2</span>, <span class="hljs-number">0</span>, <span class="hljs-number">2</span>));<br>        ch.pipeline().addLast(<span class="hljs-keyword">new</span> MsgPackDecoder());<br>        ch.pipeline().addLast(<span class="hljs-keyword">new</span> MsgPackServerHandler());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　<strong>MessagePack 解码器：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*基于MessagePack的解码器，反序列化*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgPackDecoder</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToMessageDecoder</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">decode</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg, List&lt;Object&gt; out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> length = msg.readableBytes();<br>        <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] array = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[length];<br>        msg.getBytes(msg.readerIndex(), array, <span class="hljs-number">0</span>, length);<br>        MessagePack messagePack = <span class="hljs-keyword">new</span> MessagePack();<br>        out.add(messagePack.read(array, User.class));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　服务端业务 handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgPackServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger counter = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/*** 服务端读取到网络数据后的处理*/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">//将上一个handler生成的数据强制转型</span><br>        User user = (User) msg;<br>        System.out.println(<span class="hljs-string">&quot;Server Accept[&quot;</span> + user + <span class="hljs-string">&quot;] and the counter is:&quot;</span> + counter.incrementAndGet());<br>        <span class="hljs-comment">//服务器的应答</span><br>        String resp = <span class="hljs-string">&quot;I process user :&quot;</span> + user.getUserName() + System.getProperty(<span class="hljs-string">&quot;line.separator&quot;</span>);<br>        ctx.writeAndFlush(Unpooled.copiedBuffer(resp.getBytes()));<br>        ctx.fireChannelRead(user);<br>    &#125;<br><br>    <span class="hljs-comment">/*** 发生异常后的处理*/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　<strong>客户端 handler：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelInitializerImp</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">Channel</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(Channel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">/*告诉netty，计算一下报文的长度，然后作为报文头加在前面*/</span><br>        ch.pipeline().addLast(<span class="hljs-keyword">new</span> LengthFieldPrepender(<span class="hljs-number">2</span>));<br>        <span class="hljs-comment">/*对服务器的应答也要解码，解决粘包半包*/</span><br>        ch.pipeline().addLast(<span class="hljs-keyword">new</span> LineBasedFrameDecoder(<span class="hljs-number">1024</span>));<br><br>        <span class="hljs-comment">/*对我们要发送的数据做编码-序列化*/</span><br>       ch.pipeline().addLast(<span class="hljs-keyword">new</span> MsgPackEncode());<br>       ch.pipeline().addLast(<span class="hljs-keyword">new</span> MsgPackClientHandler(<span class="hljs-number">5</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　<strong>MessagePack 编码器：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/*基于MessagePack的编码器，序列化*/</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgPackEncode</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">MessageToByteEncoder</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(ChannelHandlerContext ctx, User msg, ByteBuf out)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        MessagePack messagePack = <span class="hljs-keyword">new</span> MessagePack();<br>        <span class="hljs-keyword">byte</span>[] raw = messagePack.write(msg);<br>        out.writeBytes(raw);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　客户端端业务 handler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MsgPackClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> sendNumber;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">MsgPackClientHandler</span><span class="hljs-params">(<span class="hljs-keyword">int</span> sendNumber)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.sendNumber = sendNumber;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> AtomicInteger counter = <span class="hljs-keyword">new</span> AtomicInteger(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-comment">/*客户端读取到网络数据后的处理*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;client Accept[&quot;</span> + msg.toString(CharsetUtil.UTF_8)<br>                + <span class="hljs-string">&quot;] and the counter is:&quot;</span> + counter.incrementAndGet());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        User[] users = makeUsers();<br>        <span class="hljs-comment">//发送数据</span><br>        <span class="hljs-keyword">for</span> (User user : users) &#123;<br>            System.out.println(<span class="hljs-string">&quot;Send user:&quot;</span> + user);<br>            ctx.write(user);<br>        &#125;<br>        ctx.flush();<br>    &#125;<br><br>    <span class="hljs-comment">/*发生异常后的处理*/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br><br>    <span class="hljs-comment">/*生成用户实体类的数组，以供发送*/</span><br>    <span class="hljs-keyword">private</span> User[] makeUsers() &#123;<br>        User[] users = <span class="hljs-keyword">new</span> User[sendNumber];<br>        User user = <span class="hljs-keyword">null</span>;<br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; sendNumber; i++) &#123;<br>            user = <span class="hljs-keyword">new</span> User();<br>            user.setAge(i);<br>            String userName = <span class="hljs-string">&quot;debug&quot;</span> + i;<br>            user.setUserName(userName);<br>            user.setId(<span class="hljs-string">&quot;No:&quot;</span> + (sendNumber - i));<br>            user.setUserContact(<br>                    <span class="hljs-keyword">new</span> UserContact(userName + <span class="hljs-string">&quot;@xxx.com&quot;</span>, <span class="hljs-string">&quot;133&quot;</span>));<br>            users[i] = user;<br>        &#125;<br>        <span class="hljs-keyword">return</span> users;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty——Netty常用组件</title>
    <link href="/2023/10/08/Netty%E2%80%94%E2%80%94Netty%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6/"/>
    <url>/2023/10/08/Netty%E2%80%94%E2%80%94Netty%E5%B8%B8%E7%94%A8%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="1-EventLoop和EventLoopGroup"><a href="#1-EventLoop和EventLoopGroup" class="headerlink" title="1.  EventLoop和EventLoopGroup"></a>1.  EventLoop和EventLoopGroup</h3><p>　　回想一下在 NIO 中是如何处理我们关心的事件的？在一个 while 循环中 select 出事件，然后依次处理每种事件。我们可以把它称为事件循环，这就是 EventLoop。interface io.netty.channel. EventLoop 定义了Netty 的核心抽象，用于处理网络连接的生命周期中所发生的事件。</p><p>　　io.netty.util.concurrent 包构建在 JDK 的 java.util.concurrent 包上。而 io.netty.channel 包中的类，为了与 Channel 的事件进行交互，扩展了这些接口/类。一个 EventLoop 将由一个永远都不会改变的 Thread 驱动，同时任务（Runnable 或者 Callable）可以直接提交给 EventLoop 实现，以立即执行或者调度执行。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082221379.png" style="zoom:67%;" /></center><p><strong>线程的分配</strong></p><p>　　服务于 Channel 的 I/O 和事件的 EventLoop 包含在 EventLoopGroup 中。</p><p>　　异步传输实现只使用了少量的 EventLoop（以及和它们相关联的 Thread），而且在当前的线程模型中，它们可能会被多个 Channel 所共享。这使得可以通过尽可能少量的 Thread 来支撑大量的 Channel，而不是每个 Channel 分配一个 Thread。EventLoopGroup 负责为每个新创建的 Channel 分配一个 EventLoop。在当前实现中，使用顺序循环（round-robin）的方式进行分配以获取一个均衡的分布，并且相同的 EventLoop 可能会被分配给多个 Channel。</p><p>　　一旦一个 Channel 被分配给一个 EventLoop，它将在它的整个生命周期中都使用这个 EventLoop（以及相关联的Thread）。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082230815.png" style="zoom:50%;" /></center><p>　　需要注意，EventLoop 的分配方式对 ThreadLocal 的使用的影响。因为一个 EventLoop 通常会被用于支撑多个 Channel，所以对于所有相关联的 Channel 来说，ThreadLocal 都将是一样的。这使得它对于实现状态追踪等功能来说是个糟糕的选择。然而，在一些无状态的上下文中，它仍然可以被用于在多个 Channel 之间共享一些重度的或者代价昂贵的对象，甚至是事件。</p><p><strong>线程管理</strong></p><p>　　在内部，当提交任务时如果<strong>（</strong>当前）调用线程正是支撑 EventLoop 的线程，那么所提交的代码块将会被（直接）执行。否则，EventLoop 将调度该任务以便稍后执行，并将它放入到内部队列中。当 EventLoop下次处理它的事件时，它会执行队列中的那些任务/事件。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082234192.png" style="zoom:50%;" /></center><h3 id="2-Channel、EventLoop-Group-和ChannelFuture"><a href="#2-Channel、EventLoop-Group-和ChannelFuture" class="headerlink" title="2. Channel、EventLoop(Group)和ChannelFuture"></a>2. Channel、EventLoop(Group)和ChannelFuture</h3><p>Netty 网络抽象的代表：</p><blockquote><ul><li><p>Channel—Socket；</p></li><li><p>EventLoop—控制流、多线程处理、并发；</p></li><li><p>ChannelFuture—异步通知。</p></li></ul></blockquote><p>　　Channel 和 EventLoop关系如图：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082250245.png" style="zoom:80%;" /></center><p>　　从图上我们可以看出 Channel 需要被注册到某个 EventLoop 上，在 Channel 整个生命周期内都由这个 EventLoop 处理 IO 事件，也就是说一个 Channel 和一个 EventLoop 进行了绑定，但是一个 EventLoop 可以同时被多个 Channel 绑定。</p><h4 id="2-1-Channel-接口"><a href="#2-1-Channel-接口" class="headerlink" title="2.1 Channel 接口"></a>2.1 Channel 接口</h4><p>　　基本的 I/O 操作（bind()、connect()、read() 和 write()）依赖于底层网络传输所提供的原语。在基于 Java 的网络编程中，其基本的构造是类 Socket。Netty 的 Channel 接口所提供的 API，被用于所有的 I/O 操作。大大地降低了直接使用 Socket 类的复杂性。此外， Channel 也是拥有许多预定义的、专门化实现的广泛类层次结构的根。</p><p>　　由于 Channel 是独一无二的，所以为了保证顺序将 Channel 声明为 java.lang.Comparable 的一个子接口。因此，如果两个不同的 Channel 实例都返回了相同的散列码，那么 AbstractChannel 中的 compareTo() 方法的实现将会抛出一个 Error。</p><h5 id="1-Channel-的生命周期状态"><a href="#1-Channel-的生命周期状态" class="headerlink" title="1. Channel 的生命周期状态"></a>1. Channel 的生命周期状态</h5><ul><li><p>ChannelUnregistered ：Channel 已经被创建，但还未注册到 EventLoop</p></li><li><p>ChannelRegistered ：Channel 已经被注册到了 EventLoop</p></li><li><p>ChannelActive ：Channel 处于活动状态（已经连接到它的远程节点）,它现在可以接收和发送数据了</p></li><li><p>ChannelInactive ：Channel 没有连接到远程节点</p></li></ul><p>　　当这些状态发生改变时，将会生成对应的事件。这些事件将会被转发给 ChannelPipeline 中的 ChannelHandler，其可以随后对它们做出响应。在我们的编程中，关注 ChannelActive 和 ChannelInactive 会更多一些。</p><h5 id="2-Channel-的重要方法"><a href="#2-Channel-的重要方法" class="headerlink" title="2. Channel 的重要方法"></a>2. Channel 的重要方法</h5><ul><li><p>eventLoop： 返回分配给 Channel 的 EventLoop</p></li><li><p>pipeline： 返回 Channel 的 ChannelPipeline，也就是说每个 Channel 都有自己的 ChannelPipeline。</p></li><li><p>isActive： 如果 Channel 是活动的，则返回 true。活动的意义可能依赖于底层的传输。例如，一个 Socket 传输一旦连接到了远程节点便是活动的，而一个 Datagram 传输一旦被打开便是活动的。</p></li><li><p>localAddress： 返回本地的 SokcetAddress</p></li><li><p>remoteAddress： 返回远程的 SocketAddress</p></li><li><p>write： 将数据写到远程节点，注意，这个写只是写往 Netty 内部的缓存，还没有真正写往 socket。</p></li><li><p>flush： 将之前已写的数据冲刷到底层 socket 进行传输。</p></li><li><p>writeAndFlush： 一个简便的方法，等同于调用 write() 并接着调用 flush()</p></li></ul><h3 id="3-ChannelPipeline和ChannelHandlerContext"><a href="#3-ChannelPipeline和ChannelHandlerContext" class="headerlink" title="3. ChannelPipeline和ChannelHandlerContext"></a>3. ChannelPipeline和ChannelHandlerContext</h3><h4 id="3-1-ChannelPipeline-接口"><a href="#3-1-ChannelPipeline-接口" class="headerlink" title="3.1 ChannelPipeline 接口"></a>3.1 ChannelPipeline 接口</h4><p>当 Channel 被创建时，它将会被自动地分配一个新的 ChannelPipeline，每个 Channel 都有自己的 ChannelPipeline。这项关联是永久性的。在 Netty 组件的生命周期中，这是一项固定的操作，不需要开发人员的任何干预。</p><p>　　ChannelPipeline 提供了 ChannelHandler 链的容器，并定义了用于在该链上传播**入站 **（也就是从网络到业务处理）和 <strong>出站</strong>（也就是从业务处理到网络）各种事件流的 API。这些 ChannelHandler  对象接收事件、执行它们所实现的处理逻辑，并将数据传递给链中的下一个 ChannelHandler，而且 ChannelHandler 对象也完全可以拦截事件不让事件继续传递。它们的执行顺序是由它们被添加的顺序所决定的。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082307737.png" style="zoom:50%;" /></center>  <h5 id="1-ChannelHandler-的生命周期"><a href="#1-ChannelHandler-的生命周期" class="headerlink" title="1. ChannelHandler 的生命周期"></a>1. ChannelHandler 的生命周期</h5><p>在 ChannelHandler 被添加到 ChannelPipeline 中或者被从 ChannelPipeline 中移除时会调用下面这些方法。这些方法中的每一个都接受一个 ChannelHandlerContext 参数。</p><ul><li><p><strong>handlerAdded</strong> 当把 ChannelHandler 添加到 ChannelPipeline 中时被调用</p></li><li><p><strong>handlerRemoved</strong> 当从 ChannelPipeline 中移除 ChannelHandler 时被调用</p></li><li><p><strong>exceptionCaught</strong> 当处理过程中在 ChannelPipeline 中有错误产生时被调用</p></li></ul><h5 id="２-ChannelPipeline中的ChannelHandler"><a href="#２-ChannelPipeline中的ChannelHandler" class="headerlink" title="２. ChannelPipeline中的ChannelHandler"></a>２. ChannelPipeline中的ChannelHandler</h5><p>　　入站和出站 ChannelHandler 被安装到同一个 ChannelPipeline 中，ChannelPipeline 以双向链表的形式进行维护管理。比如下图，我们在网络上传递的数据，要求加密，但是加密后密文比较大，需要压缩后再传输，而且按照业务要求，需要检查报文中携带的用户信息是否合法，于是我们实现了5个Handler：解压（入）Handler、压缩（出）handler、解密（入） Handler、加密（出） Handler、授权（入） Handler。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082314428.png" style="zoom:50%;" /></center><p>　　如果一个消息或者任何其他的入站事件被读取，那么它会从 ChannelPipeline 的头部开始流动，但是只被处理入站事件的 Handler 处理，也就是解压（入）Handler、解密（入） Handler、授权（入） Handler，最终，数据将会到达 ChannelPipeline 的尾端，届时，所有处理就都结束了。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082316079.png" style="zoom:50%;" /></center><p>　　数据的出站运动（即正在被写的数据）在概念上也是一样的。在这种情况下，数据将从链的尾端开始流动，但是只被处理出站事件的 Handler 处理，也就是加密（出） Handler、压缩（出）handler，直到它到达链的头部为止。在这之后，出站数据将会到达网络传输层，也就是我们的 Socket。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082317165.png" style="zoom:50%;" /></center><p>　　Netty 能区分入站事件的 Handler 和出站事件的 Handler，并确保数据只会在具有相同定向类型的两个 ChannelHandler 之间传递。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310102218508.png" style="zoom:50%;" /></center><p>　</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310102222602.png" style="zoom:50%;" /></center><p>　　所以在我们编写 Netty 应用程序时要注意，分属出站和入站不同的 Handler ，<strong>在业务没特殊要求的情况下</strong>是无所谓顺序的，而同属一个方向的 Handler 则是有顺序的，因为上一个 Handler 处理的结果往往是下一个 Handler 的要求的输入。</p><h5 id="3-ChannelPipeline上的方法"><a href="#3-ChannelPipeline上的方法" class="headerlink" title="3. ChannelPipeline上的方法"></a>3. ChannelPipeline上的方法</h5><p>　　既然 ChannelPipeline 以双向链表的形式进行维护管理 Handler，自然也提供了对应的方法在 ChannelPipeline 中增加或者删除、替换 Handler。</p><ul><li><strong>addFirst、addBefore、addAfter、addLast：</strong> 将一个 ChannelHandler 添加到 ChannelPipeline 中</li><li><strong>remove：</strong> 将一个 ChannelHandler 从 ChannelPipeline 中移除</li><li><strong>replace：</strong> 将 ChannelPipeline 中的一个 ChannelHandler 替换为另一个 ChannelHandler</li><li><strong>get：</strong> 通过类型或者名称返回 ChannelHandler</li><li><strong>context：</strong> 返回和 ChannelHandler 绑定的 ChannelHandlerContext</li><li><strong>names：</strong> 返回 ChannelPipeline 中所有 ChannelHandler 的名称</li></ul><h4 id="3-2-ChannelHandlerContext"><a href="#3-2-ChannelHandlerContext" class="headerlink" title="3.2 ChannelHandlerContext"></a>3.2 ChannelHandlerContext</h4><p>　　ChannelHandlerContext 代表了 ChannelHandler 和 ChannelPipeline 之间的关联，每当有 ChannelHandler 添加到 ChannelPipeline 中时，都会创建 ChannelHandlerContext，为什么需要这个 ChannelHandlerContext ？ChannelPipeline 以双向链表的形式进行维护管理 Handler，毫无疑问，Handler 在放入 ChannelPipeline 的时候必须要有两个指针 pre 和 next 来说明它的前一个元素和后一个元素，但是 Handler 本身来维护这两个指针合适吗？想想我们在使用 JDK 的 LinkedList 的时候，我们放入 LinkedList 的数据是不会带这两个指针的，LinkedList 内部会用类 Node 对我们的数据进行包装，而类 Node 则带有两个指针 pre 和 next。所以，ChannelHandlerContext 的主要作用就和 LinkedList 内部的类 Node 类似。</p><p>不过 ChannelHandlerContext 不仅仅只是个包装类，它还提供了很多的方法，比如让事件从当前 ChannelHandler 传递给链中的下一个 ChannelHandler，还可以被用于获取底层的 Channel，还可以用于写出站数据。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082337365.png" style="zoom:50%;" /></center><h5 id="1-Channel、ChannelPipeline和ChannelHandlerContext上的事件传播"><a href="#1-Channel、ChannelPipeline和ChannelHandlerContext上的事件传播" class="headerlink" title="1. Channel、ChannelPipeline和ChannelHandlerContext上的事件传播"></a>1. Channel、ChannelPipeline和ChannelHandlerContext上的事件传播</h5><p>　　ChannelHandlerContext 有很多的方法，其中一些方法也存在于 Channel 和 Channel-Pipeline 本身上，<strong>但是有一点重要的不同。</strong>如果调用 Channel 或者 ChannelPipeline 上的这些方法，它们将沿着整个 ChannelPipeline 进行传播。而调用位于 ChannelHandlerContext 上的相同方法，则将从当前所关联的 ChannelHandler 开始，并且只会传播给位于该 ChannelPipeline 中的下一个（入站下一个，出站上一个）能够处理该事件的 ChannelHandler。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082341270.png" style="zoom:50%;" /></center><p>　　我们用一个实际例子来说明，比如服务器收到对端发过来的报文，解压后需要进行解密，结果解密失败，要给对端一个应答。</p><p>　　如果发现解密失败原因是服务器和对端的加密算法不一致，应答报文只能以明文的压缩格式发送，就可以在解密 handler 中直接使用 ctx.write 给对端应答，这样应答报文就只经过压缩 Handler 就发往了对端；</p><p>　　其他情况下，应答报文要以加密和压缩格式发送，就可以在解密 handler 中使用 channel.write() 或者 channelpipeline.write() 给对端应答，这样应答报文就会流经整个出站处理过程。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310082352986.png" style="zoom:50%;" /></center><h5 id="2-ChannelHandlerContext-的API"><a href="#2-ChannelHandlerContext-的API" class="headerlink" title="2. ChannelHandlerContext 的API"></a>2. ChannelHandlerContext 的API</h5><ul><li> <strong>alloc</strong> 返回和这个实例相关联的 Channel 所配置的 ByteBufAllocator</li><li> <strong>bind</strong> 绑定到给定的 SocketAddress，并返回 ChannelFuture</li><li> <strong>channel</strong> 返回绑定到这个实例的 Channel</li><li> <strong>close</strong> 关闭 Channel，并返回 ChannelFuture</li><li> <strong>connect</strong> 连接给定的 SocketAddress，并返回 ChannelFuture</li><li> <strong>deregister</strong> 从之前分配的 EventExecutor 注销，并返回 ChannelFuture</li><li> <strong>disconnect</strong> 从远程节点断开，并返回 ChannelFuture</li><li> <strong>executor</strong> 返回调度事件的 EventExecutor</li><li> <strong>fireChannelActive</strong> 触发对下一个 ChannelInboundHandler 上的 channelActive() 方法（已连接）的调用</li><li> <strong>fireChannelInactive</strong> 触发对下一个 ChannelInboundHandler 上的 channelInactive() 方法（已关闭）的调用</li><li> <strong>fireChannelRead</strong> 触发对下一个 ChannelInboundHandler 上的 channelRead() 方法（已接收的消息）的调用</li><li> <strong>fireChannelReadComplete</strong> 触发对下一个 ChannelInboundHandler 上的 channelReadComplete() 方法的调用</li><li> <strong>fireChannelRegistered</strong> 触发对下一个 ChannelInboundHandler 上的 fireChannelRegistered() 方法的调用</li><li> <strong>fireChannelUnregistered</strong> 触发对下一个 ChannelInboundHandler 上的fire ChannelUnregistered() 方法的调用</li><li> <strong>fireChannelWritabilityChanged</strong> 触发对下一个 ChannelInboundHandler 上的 fireChannelWritabilityChanged() 方法的调用</li><li> <strong>fireExceptionCaught</strong> 触发对下一个 ChannelInboundHandler 上的 fireExceptionCaught(Throwable) 方法的调用</li><li> <strong>fireUserEventTriggered</strong> 触发对下一个 ChannelInboundHandler 上的 fireUserEventTriggered(Object evt) 方法的调用</li><li> <strong>handler</strong> 返回绑定到这个实例的 ChannelHandler</li><li> <strong>isRemoved</strong> 如果所关联的 ChannelHandler 已经被从 ChannelPipeline 中移除则返回 true</li><li> <strong>name</strong> 返回这个实例的唯一名称</li><li> <strong>pipeline</strong> 返回这个实例所关联的 ChannelPipeline</li><li> <strong>read</strong> 将数据从 Channel 读取到第一个入站缓冲区；如果读取成功则触发一个 channelRead 事件，并（在最后一个消息被读取完成后）通知 ChannelInboundHandler 的 channelReadComplete(ctx) 方法</li><li> <strong>write</strong> 通过这个实例写入消息并经过 ChannelPipeline</li><li> <strong>writeAndFlush</strong> 通过这个实例写入并冲刷消息并经过 ChannelPipeline</li></ul><p>　　当使用 ChannelHandlerContext 的 API  的时候，有以下两点：</p><blockquote><ul><li>ChannelHandlerContext 和 ChannelHandler 之间的关联（绑定）是永远不会改变的，所以缓存对它的引用是安全的；</li><li>相对于其他类的同名方法，ChannelHandlerContext 的方法将产生更短的事件</li></ul></blockquote><h3 id="4-ChannelHandler"><a href="#4-ChannelHandler" class="headerlink" title="4. ChannelHandler"></a>4. ChannelHandler</h3><h4 id="4-1-ChannelHandler-接口"><a href="#4-1-ChannelHandler-接口" class="headerlink" title="4.1 ChannelHandler 接口"></a>4.1 ChannelHandler 接口</h4><p>从应用程序开发人员的角度来看，Netty 的主要组件是ChannelHandler，它充当了所有处理入站和出站数据的应用程序逻辑的容器。ChannelHandler 的方法是由网络事件触发的。事实上，ChannelHandler 可专门用于几乎任何类型的动作，例如将数据从一种格式转换为另外一种格式，例如各种编解码，或者处理转换过程中所抛出的异常。</p><p>　　举例来说，ChannelInboundHandler 是一个你将会经常实现的子接口。这种类型的 ChannelHandler 接收入站事件和数据，这些数据随后将会被你的应用程序的业务逻辑所处理。当你要给连接的客户端发送响应时，也可以从 ChannelInboundHandler 直接冲刷数据然后输出到对端。应用程序的业务逻辑通常实现在一个或者多个 ChannelInboundHandler 中。</p><p>　　Netty 定义了下面两个重要的 ChannelHandler 子接口：</p><blockquote><ul><li><p>ChannelInboundHandler——处理入站数据以及各种状态变化；</p></li><li><p>ChannelOutboundHandler——处理出站数据并且允许拦截所有的操作。</p></li></ul></blockquote><h4 id="4-2-ChannelInboundHandler-接口"><a href="#4-2-ChannelInboundHandler-接口" class="headerlink" title="4.2 ChannelInboundHandler 接口"></a>4.2 ChannelInboundHandler 接口</h4><p>　　下面列出了接口 ChannelInboundHandler 的生命周期方法。这些方法将会在数据被接收时或者与其对应的 Channel 状态发生改变时被调用。正如我们前面所提到的，这些方法和 Channel 的生命周期密切相关。</p><ul><li><strong>channelRegistered</strong> 当 Channel 已经注册到它的 EventLoop 并且能够处理 I/O 时被调用</li><li><strong>channelUnregistered</strong> 当 Channel 从它的 EventLoop 注销并且无法处理任何 I/O 时被调用</li><li><strong>channelActive</strong> 当 Channel 处于活动状态时被调用；Channel 已经连接/绑定并且已经就绪</li><li><strong>channelInactive</strong> 当 Channel 离开活动状态并且不再连接它的远程节点时被调用</li><li><strong>channelReadComplete</strong> 当 Channel上的一个读操作完成时被调用</li><li><strong>channelRead</strong> 当从 Channel 读取数据时被调用</li><li><strong>ChannelWritabilityChanged</strong> 当 Channel 的可写状态发生改变时被调用。可以通过调用 Channel 的 isWritable() 方法来检测 Channel  的可写性。与可写性相关的阈值可以通过 Channel.config().setWriteHighWaterMark() 和 Channel.config().setWriteLowWaterMark() 方法来设置</li><li><strong>userEventTriggered</strong> 当 ChannelnboundHandler.fireUserEventTriggered() 方法被调用时被调用。</li></ul><h4 id="4-3-ChannelOutboundHandler-接口"><a href="#4-3-ChannelOutboundHandler-接口" class="headerlink" title="4.3 ChannelOutboundHandler 接口"></a>4.3 ChannelOutboundHandler 接口</h4><p>　　出站操作和数据将由 ChannelOutboundHandler 处理。它的方法将被 Channel、Channel-Pipeline 以及 ChannelHandlerContext 调用。</p><p>　　所有由 ChannelOutboundHandler 本身所定义的方法：</p><ul><li><strong>bind(ChannelHandlerContext,SocketAddress,ChannelPromise)</strong>  当请求将 Channel 绑定到本地地址时被调用</li><li><strong>connect(ChannelHandlerContext,SocketAddress,SocketAddress,ChannelPromise)</strong>  当请求将 Channel 连接到远程节点时被调用</li><li><strong>disconnect(ChannelHandlerContext,ChannelPromise)</strong>  当请求将 Channel 从远程节点断开时被调用</li><li><strong>close(ChannelHandlerContext,ChannelPromise)</strong>  当请求关闭 Channel 时被调用</li><li><strong>deregister(ChannelHandlerContext,ChannelPromise)</strong>  当请求将 Channel 从它的 EventLoop 注销时被调用</li><li><strong>read(ChannelHandlerContext)</strong>  当请求从 Channel 读取更多的数据时被调用</li><li>**flush(ChannelHandlerContext) ** 当请求通过 Channel 将入队数据冲刷到远程节点时被调用</li><li><strong>write(ChannelHandlerContext,Object,ChannelPromise)</strong> 当请求通过 Channel 将数据写到远程节点时被调用</li></ul><h4 id="4-4-ChannelHandler的适配器"><a href="#4-4-ChannelHandler的适配器" class="headerlink" title="4.4 ChannelHandler的适配器"></a>4.4 ChannelHandler的适配器</h4><p>　　有一些适配器类可以将编写自定义的 ChannelHandler 所需要的工作降到最低限度，因为它们提供了定义在对应接口中的所有方法的默认实现。因为你有时会忽略那些不感兴趣的事件，所以 Netty 提供了抽象基类 ChannelInboundHandlerAdapter（处理入站） 和ChannelOutboundHandlerAdapter（处理出站）。</p><p>　　我们可以使用 ChannelInboundHandlerAdapter 和 ChannelOutboundHandlerAdapter 类作为自己的 ChannelHandler 的起始点。这两个适配器分别提供了 ChannelInboundHandler 和 ChannelOutboundHandler 的基本实现。通过扩展抽象类 ChannelHandlerAdapter，它们获得了它们共同的超接口 ChannelHandler 的方法。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310092217678.png" style="zoom:25%;" /></center><p>　　不过 ChannelOutboundHandler 有个非常让人迷惑的 read 方法，ChannelOutboundHandler 不是处理出站事件的吗？怎么会有 read 方法呢？其实这个 read 方法不是表示读数据，而是表示业务发出了读（read）数据的要求，这个要求也会封装为一个事件进行传播，这个事件因为是业务发出到网络的，自然就是个出站事件，而且这个事件触发的就是 ChannelOutboundHandler 中 read 方法。</p><p>　　如果我们的 Handler 既要处理入站又要处理出站怎么办呢？这个时候就可以使用类 ChannelDuplexHandler，当然也可以同时实现 ChannelOutboundHandler, ChannelInboundHandler 这两个接口，自然就要麻烦很多了。</p><h4 id="4-5-Handler的共享和并发安全性"><a href="#4-5-Handler的共享和并发安全性" class="headerlink" title="4.5 Handler的共享和并发安全性"></a>4.5 Handler的共享和并发安全性</h4><p>　　ChannelHandlerAdapter 还提供了实用方法 isSharable()。如果其对应的实现被标注为 Sharable，那么这个方法将返回 true，表示它可以被添加到多个 ChannelPipeline。</p><p>　　这就牵涉到了我们实现的 Handler 的共享性和线程安全性。回顾我们的 Netty 代码，在往 pipeline 安装 Handler的时候，基本上是 new 出 Handle r的实例。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310092223763.png" style="zoom:50%;" /></center><p>　　因为每个 socketChannel 有自己的 pipeline 而且每个 socketChannel 又是和线程绑定的，所以这些 Handler 的实例之间完全独立的，只要 Handler 的实例之间不是共享了全局变量，Handler 的实例是线程安全的。</p><p>　　但是如果业务需要我们在多个 socketChannel 之间共享一个 Handler 的实例怎么办呢？比如统计服务器接受到和发出的业务报文总数，我们就需要用一个 Handler 的实例来横跨所有的 socketChannel 来统计所有 socketChannel 业务报文数。</p><p>　　为了实现这一点，我们可以实现一个 MessageCountHandler，并且在 MessageCountHandler 上使用 Netty 的 @Sharable 注解，然后在安装 MessageCountHandler 实例到 pipeline 时，共用一个即可。当然，因为 MessageCountHandler 实例是共享的，所以在实现 MessageCountHandler 的统计功能时，请务必注意线程安全，我们在具体实现时就使用了 Java 并发编程里的 Atomic 类来保证这一点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ChannelHandler</span>.Sharable<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageCountHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelDuplexHandler</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> AtomicLong inCount = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);<br>    <span class="hljs-keyword">private</span> AtomicLong outCount = <span class="hljs-keyword">new</span> AtomicLong(<span class="hljs-number">0</span>);<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;收到报文总数：&quot;</span>+inCount.incrementAndGet());<br>        <span class="hljs-keyword">super</span>.channelRead(ctx, msg);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">flush</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;发出报文总数：&quot;</span>+outCount.incrementAndGet());<br>        <span class="hljs-keyword">super</span>.flush(ctx);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310092252768.png" style="zoom:50%;" /></center><h4 id="4-6-资源管理和SimpleChannelInboundHandler"><a href="#4-6-资源管理和SimpleChannelInboundHandler" class="headerlink" title="4.6 资源管理和SimpleChannelInboundHandler"></a>4.6 资源管理和SimpleChannelInboundHandler</h4><p>　　<a href="https://www.skjava.com/series/article/1720220745">（传送门）</a></p><p>　　回想一下我们在 NIO 中是如何接收和发送网络数据的？都是首先创建了一个 Buffer，应用程序中的业务部分和 Channel 之间通过 Buffer 进行数据的交换：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310092255016.png" style="zoom:50%;" /></center><p>　　Netty 在处理网络数据时，同样也需要 Buffer，在 Read 网络数据时由 Netty 创建 Buffer，Write 网络数据时 Buffer 往往是由业务方创建的。不管是读和写，Buffer 用完后都必须进行释放，否则可能会造成内存泄露。</p><h5 id="1-出站Buffer"><a href="#1-出站Buffer" class="headerlink" title="1. 出站Buffer"></a>1. 出站Buffer</h5><p>　　在 Write 网络数据时，可以确保数据被写往网络了，Netty 会自动进行 Buffer 的释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    String request = <span class="hljs-string">&quot;debuggingWorld&quot;</span>;<br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++) &#123;<br>        ByteBuf byteBuf = Unpooled.buffer(request.length());<br>        byteBuf.writeBytes(request.getBytes());<br>        ctx.writeAndFlush(byteBuf); <span class="hljs-comment">// writeAndFlush 会自动释放</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　Netty 默认会在 ChannelPipeline 的收尾加上 HeadContext 和 TailContext。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310122246484.png" style="zoom:50%;" /></center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HeadContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractChannelHandlerContext</span></span><br><span class="hljs-class">            <span class="hljs-keyword">implements</span> <span class="hljs-title">ChannelOutboundHandler</span>, <span class="hljs-title">ChannelInboundHandler</span> </span>&#123;<br>  ....<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> </span>&#123;<br>            unsafe.write(msg, promise);<br>        &#125;<br>  .....<br>&#125;<br></code></pre></td></tr></table></figure><p>　　HeadContext 实现了入站和出站 ChannelHandler，在 write() 中调用 unsafe.write()，其内部会进行释放（转传送门）。</p><p>　　但是如果 Write 网络数据时，我们有 outBoundHandler 处理了 write() 操作并丢弃了数据，没有继续往下传递 Handler，要由我们负责释放这个 Buffer，就必须调用 ReferenceCountUtil.release 方法，否则就可能会造成内存泄露。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerOutReadHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelOutboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">write</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg, ChannelPromise promise)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// super.write(ctx, msg, promise);</span><br>        ReferenceCountUtil.release(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-入站Buffer"><a href="#2-入站Buffer" class="headerlink" title="2. 入站Buffer"></a>2. 入站Buffer</h5><p>　　在 Read 网络数据时，如果我们可以确保每个 InboundHandler 都把数据往后传递了，也就是调用了相关的 fireChannelRead 方法，Netty 也会帮我们释放。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// io.netty.channel.DefaultChannelPipeline.TailContext#channelRead</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>    onUnhandledInboundMessage(ctx, msg);<br>&#125;<br><br><span class="hljs-comment">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUnhandledInboundMessage</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> </span>&#123;<br>    onUnhandledInboundMessage(msg);<br>    <span class="hljs-keyword">if</span> (logger.isDebugEnabled()) &#123;<br>        logger.debug(<span class="hljs-string">&quot;Discarded message pipeline : &#123;&#125;. Channel : &#123;&#125;.&quot;</span>,<br>                     ctx.pipeline().names(), ctx.channel());<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// io.netty.channel.DefaultChannelPipeline#onUnhandledInboundMessage</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onUnhandledInboundMessage</span><span class="hljs-params">(Object msg)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        logger.debug(<br>                <span class="hljs-string">&quot;Discarded inbound message &#123;&#125; that reached at the tail of the pipeline. &quot;</span> +<br>                        <span class="hljs-string">&quot;Please check your pipeline configuration.&quot;</span>, msg);<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        ReferenceCountUtil.release(msg);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　同样的，如果我们有 InboundHandler 处理了数据，又不继续往后传递，又不调用负责释放的 ReferenceCountUtil.release 方法，就可能会造成内存泄露（比如入站数据在解密失败后应该终止传递）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    ByteBuf in = (ByteBuf) msg;<br>    String request = in.toString(CharsetUtil.UTF_8);<br>    System.out.println(<span class="hljs-string">&quot;Server accept: &quot;</span> + request);<br>    <span class="hljs-comment">// ctx.fireChannelRead(msg);</span><br>    <span class="hljs-comment">// ReferenceCountUtil.release(msg);</span><br>&#125;<br></code></pre></td></tr></table></figure><p>　　但是由于消费入站数据是一项常规任务，所以 Netty 提供了一个特殊的被称为 SimpleChannelInboundHandler 的 ChannelInboundHandler 实现。这个实现会在数据被 channelRead0() 方法消费之后自动释放数据。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310092300232.png" style="zoom:50%;" /></center><p>　　同时系统为我们提供的各种预定义 Handler 实现，都实现了数据的正确处理，所以我们自行在编写业务 Handler 时，也需要注意这一点：<strong>要么继续传递，要么自行释放</strong>。</p><h3 id="5-内置通信传输模式"><a href="#5-内置通信传输模式" class="headerlink" title="5. 内置通信传输模式"></a>5. 内置通信传输模式</h3><ul><li><p><strong>NIO</strong> io.netty.channel.socket.nio 使用 java.nio.channels 包作为基础——基于选择器的方式</p></li><li><p><strong>Epoll</strong> io.netty.channel.epoll 由 JNI 驱动的 epoll() 和非阻塞 IO。这个传输支持只有在 Linux 上可用的多种特性，如 SO_REUSEPORT，比 NIO 传输更快，而且是完全非阻塞的。将 NioEventLoopGroup 替换为 EpollEventLoopGroup ， 并且将 NioServerSocketChannel.class  替换为 EpollServerSocketChannel.class 即可。</p></li><li><p><strong>OIO</strong> io.netty.channel.socket.oio 使用 java.net 包作为基础——使用阻塞流</p></li><li><p><strong>Local</strong> io.netty.channel.local 可以在 VM 内部通过管道进行通信的本地传输</p></li><li><p><strong>Embedded</strong> io.netty.channel.embedded Embedded 传输，允许使用 ChannelHandler 而又不需要一个真正的基于网络的传输。在测试 ChannelHandler 实现时非常有用</p></li></ul><h3 id="6-引导Bootstrap"><a href="#6-引导Bootstrap" class="headerlink" title="6. 引导Bootstrap"></a>6. 引导Bootstrap</h3><p>　　有两种类型的引导：一种用于客户端（简单地称为Bootstrap），而另一种（ServerBootstrap）用于服务器。无论你的应用程序使用哪种协议或者处理哪种类型的数据，唯一决定它使用哪种引导类的是它是作为一个客户端还是作为一个服务器。</p><table><thead><tr><th></th><th><strong>Bootstrap</strong></th><th><strong>ServerBootstrap</strong></th></tr></thead><tbody><tr><td>网络编程中的作用</td><td>连接到远程主机和端口</td><td>绑定到一个本地端口</td></tr><tr><td>EventLoopGroup 的数目</td><td>1</td><td>2</td></tr></tbody></table><p>ServerBootstrap 将绑定到一个端口，因为服务器必须要监听连接，而Bootstrap 则是由想要连接到远程节点的客户端应用程序所使用的。</p><p>　　第二个区别可能更加明显。引导一个客户端只需要一个 EventLoopGroup，但是一个 ServerBootstrap 则需要两个（也可以是同一个实例）。因为服务器需要两组不同的 Channel。第一组将只包含一个 ServerChannel，代表服务器自身的已绑定到某个本地端口的正在监听的套接字。而第二组将包含所有已创建的用来处理传入客户端连接（对于每个服务器已经接受的连接都有一个）的 Channel。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310102246292.png" style="zoom:70%;" /></center><p>　　与 ServerChannel 相关联的 EventLoopGroup 将分配一个负责为传入连接请求创建 Channel 的 EventLoop。一旦连接被接受，第二个 EventLoopGroup 就会给它的 Channel 分配一个 EventLoop。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310102248220.png" style="zoom:50%;" /></center><h3 id="7-ChannelInitializer"><a href="#7-ChannelInitializer" class="headerlink" title="7. ChannelInitializer"></a>7. ChannelInitializer</h3><p>　　Netty 提供了一个特殊的 ChannelInboundHandlerAdapter 子类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Sharable</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChannelInitializer</span>&lt;<span class="hljs-title">C</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Channel</span>&gt; <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(C ch)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>  <br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">if</span> (initMap.add(ctx)) &#123; <span class="hljs-comment">// Guard against re-entrance.</span><br>            <span class="hljs-keyword">try</span> &#123;<br>                initChannel((C) ctx.channel());<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable cause) &#123;<br>                exceptionCaught(ctx, cause);<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">if</span> (!ctx.isRemoved()) &#123;<br>                    ctx.pipeline().remove(<span class="hljs-keyword">this</span>);<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>  <br>  ……<br>&#125;<br></code></pre></td></tr></table></figure><p>　　initChannel  方法提供了一种将多个 ChannelHandler 添加到一个 ChannelPipeline 中的简便方法。你只需要简单地向 Bootstrap 或 ServerBootstrap 的实例提供你的 ChannelInitializer 实现即可，并且一旦 Channel 被注册到了它的 EventLoop 之后，就会调用你的 initChannel() 版本。在该方法返回之后，ChannelInitializer 的实例将会从 ChannelPipeline 中移除它自己。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310102301446.png" style="zoom:50%;" /></center><p>　　所以，在我们自己的应用程序中，如果存在着某个 handler 只使用一次的情况，也可以仿造 ChannelInitializer，用完以后将自己从 ChannelPipeline 中移除自己，比如授权 handler，某客户端第一次连接登录以后，进行授权检查，检查通过后就可以把这个授权 handler 移除了。如果客户端关闭连接下线，下次再连接的时候，就是一个新的连接，授权 handler 依然会被安装到 ChannelPipeline ，依然会进行授权检查。</p><h3 id="8-ChannelOption"><a href="#8-ChannelOption" class="headerlink" title="8. ChannelOption"></a>8. ChannelOption</h3><p>　　ChannelOption 的各种属性在套接字选项中都有对应。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310102316410.png"></p><h4 id="8-1-ChannelOption-SO-BACKLOG"><a href="#8-1-ChannelOption-SO-BACKLOG" class="headerlink" title="8.1 ChannelOption.SO_BACKLOG"></a>8.1 ChannelOption.SO_BACKLOG</h4><p>　　ChannelOption.SO_BACKLOG 对应的是 tcp/ip 协议 listen 函数中的 backlog 参数，服务端处理客户端连接请求是顺序处理的，所以同一时间只能处理一个客户端连接，多个客户端来的时候，服务端将不能处理的客户端连接请求放在队列中等待处理。所以操作系统里一般有两个队列，一个是 ACCEP T队列，保存着已经完成了 TCP 的三次握手的连接，一个 SYN 队列，服务器正在等待 TCP 的三次握手完成的队列。</p><p>　　BSD 派生系统里 backlog 指的就是 SYN 队列的大小，在 Linux 的实现里 backlog 相对来说，就含糊不清了，有些内核版本指的是 ACCEPT 队列 + SYN 队列合起来的大小，有的是指 SYN 队列的大小。</p><p>　　但是从  Linux 2.2 开始，backlog 的参数行为在 Linux 2.2 中发生了变化，现在它指定等待接受的完全建立的套接字的队列长度，而不是不完整的连接请求的数量。 不完整套接字队列的最大长度可以使用 /proc/sys/net/ipv4/tcp_max_syn_backlog 设置，默认值为 128。</p><p>　　如果 backlog 参数大于 /proc/sys/net/core/somaxconn 中的值，那么它会被静默截断为值128。在 2.4.25 之前的内核中，此限制是硬编码值，后续内核版本也可以通过 vim /etc/sysctl.conf 来修改，包括我们前面所说的 tcp_max_syn_backlog 也可以在此处修改，然后通过命令 sysctl -p 生效。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310102311569.png" style="zoom:60%;" /></center><h4 id="8-2-ChannelOption-SO-REUSEADDR"><a href="#8-2-ChannelOption-SO-REUSEADDR" class="headerlink" title="8.2 ChannelOption.SO_REUSEADDR"></a>8.2 ChannelOption.SO_REUSEADDR</h4><p>　　ChanneOption.SO_REUSEADDR 对应于套接字选项中的 SO_REUSEADDR，这个参数表示允许重复使用本地地址和端口，比如，多网卡（IP）绑定相同端口，比如某个进程非正常退出，该程序占用的端口可能要被占用一段时间才能允许其他进程使用，而且程序死掉以后，内核一需要一定的时间才能够释放此端口，不设置 SO_REUSEADDR 就无法正常使用该端口。</p><p>　　但是注意，这个参数无法做到让应用绑定完全相同 IP + Port 来重复启动。</p><p>8.3 ChannelOption.SO_KEEPALIVE</p><p>　　Channeloption.SO_KEEPALIVE 参数对应于套接字选项中的 SO_KEEPALIVE，该参数用于设置 TCP 连接，当设置该选项以后，连接会测试链接的状态，这个选项用于可能长时间没有数据交流的连接。当设置该选项以后，如果在两小时内没有数据的通信时，TCP 会自动发送一个活动探测数据报文。</p><h4 id="8-4-ChannelOption-SO-SNDBUF和ChannelOption-SO-RCVBUF"><a href="#8-4-ChannelOption-SO-SNDBUF和ChannelOption-SO-RCVBUF" class="headerlink" title="8.4 ChannelOption.SO_SNDBUF和ChannelOption.SO_RCVBUF"></a>8.4 ChannelOption.SO_SNDBUF和ChannelOption.SO_RCVBUF</h4><p>　　ChannelOption.SO_SNDBUF 参数对应于套接字选项中的 SO_SNDBUF，ChannelOption.SO_RCVBUF 参数对应于套接字选项中的 SO_RCVBUF，这两个参数用于操作接收缓冲区和发送缓冲区的大小，接收缓冲区用于保存网络协议站内收到的数据，直到应用程序读取成功，发送缓冲区用于保存发送数据，直到发送成功。</p><h4 id="8-5-ChannelOption-SO-LINGER"><a href="#8-5-ChannelOption-SO-LINGER" class="headerlink" title="8.5 ChannelOption.SO_LINGER"></a>8.5 ChannelOption.SO_LINGER</h4><p>ChannelOption.SO_LINGER 参数对应于套接字选项中的 SO_LINGER，Linux 内核默认的处理方式是当用户调用 close（）方法的时候，函数返回，在可能的情况下，尽量发送数据，不一定保证会发生剩余的数据，造成了数据的不确定性，使用 SO_LINGER 可以阻塞 close() 的调用时间，直到数据完全发送</p><h4 id="8-6-ChannelOption-TCP-NODELAY"><a href="#8-6-ChannelOption-TCP-NODELAY" class="headerlink" title="8.6 ChannelOption.TCP_NODELAY"></a>8.6 ChannelOption.TCP_NODELAY</h4><p>　　ChannelOption.TCP_NODELAY 参数对应于套接字选项中的 TCP_NODELAY，该参数的使用与 Nagle 算法有关，Nagle 算法是将小的数据包组装为更大的帧然后进行发送，而不是输入一次发送一次，因此在数据包不足的时候会等待其他数据的到了，组装成大的数据包进行发送，虽然该方式有效提高网络的有效负载，但是却造成了延时，而该参数的作用就是禁止使用 Nagle 算法，使用于小数据即时传输，于 TCP_NODELAY 相对应的是 TCP_CORK，该选项是需要等到发送的数据量最大的时候，一次性发送数据，适用于文件传输。</p><h3 id="9-ByteBuf"><a href="#9-ByteBuf" class="headerlink" title="9. ByteBuf"></a>9. ByteBuf</h3><p>　　ByteBuf API 的优点：</p><blockquote><ul><li>它可以被用户自定义的缓冲区类型扩展；</li><li>通过内置的复合缓冲区类型实现了透明的零拷贝；</li><li>容量可以按需增长（类似于JDK 的StringBuilder）；</li><li>在读和写这两种模式之间切换不需要调用ByteBuffer 的flip()方法；</li><li>读和写使用了不同的索引；</li><li>支持方法的链式调用；</li><li>支持引用计数；</li><li>支持池化。</li></ul></blockquote><p>　　ByteBuf 维护了两个不同的索引，名称以 read 或者 write 开头的 ByteBuf 方法，将会推进其对应的索引，而名称以 set 或者 get 开头的操作则不会。</p><p>　　如果打算读取字节直到 readerIndex 达到和 writerIndex 同样的值时会发生什么。在那时，你将会到达“可以读取的”数据的末尾。就如同试图读取超出数组末尾的数据一样，试图读取超出该点的数据将会触发一个 IndexOutOf-BoundsException。</p><p>　　可以指定 ByteBuf 的最大容量。试图移动写索引（即writerIndex）超过这个值将会触发一个异常。（默认的限制是  Integer.MAX_VALUE。）</p><h4 id="9-1-使用模式"><a href="#9-1-使用模式" class="headerlink" title="9.1 使用模式"></a>9.1 使用模式</h4><h5 id="1-堆缓冲区"><a href="#1-堆缓冲区" class="headerlink" title="1. 堆缓冲区"></a>1. 堆缓冲区</h5><p>　　最常用的 ByteBuf 模式是将数据存储在 JVM 的堆空间中。这种模式被称为支撑数组（backing array），它能在没有使用池化的情况下提供快速的分配和释放。可以由 hasArray() 来判断检查 ByteBuf 是否由数组支撑。如果不是，则这是一个直接缓冲区。</p><h5 id="2-直接缓冲区"><a href="#2-直接缓冲区" class="headerlink" title="2. 直接缓冲区"></a>2. 直接缓冲区</h5><p>　　直接缓冲区是另外一种 ByteBuf 模式。</p><p>直接缓冲区的主要缺点是，相对于基于堆的缓冲区，它们的分配和释放都较为昂贵。</p><h5 id="3-复合缓冲区"><a href="#3-复合缓冲区" class="headerlink" title="3. 复合缓冲区"></a>3. 复合缓冲区</h5><p>　　复合缓冲区 CompositeByteBuf，它为多个 ByteBuf 提供一个聚合视图。比如 HTTP 协议，分为消息头和消息体，这两部分可能由应用程序的不同模块产生，各有各的 ByteBuf，将会在消息被发送的时候组装为一个 ByteBuf，此时可以将这两个 ByteBuf 聚合为一个 CompositeByteBuf，然后使用统一和通用的 ByteBuf API 来操作。</p><h4 id="9-2-分配"><a href="#9-2-分配" class="headerlink" title="9.2 分配"></a>9.2 分配</h4><p>　　如何在我们的程序中获得 ByteBuf 的实例，并使用它呢？Netty 提供了两种方式</p><h5 id="1-ByteBufAllocator-接口"><a href="#1-ByteBufAllocator-接口" class="headerlink" title="1. ByteBufAllocator 接口"></a>1. ByteBufAllocator 接口</h5><p>　　Netty 通过 interface ByteBufAllocator 分配我们所描述过的任意类型的 ByteBuf 实例。</p><table><thead><tr><th>名称</th><th>描述</th></tr></thead><tbody><tr><td>buffer()</td><td>返回一个基于堆或者直接内存存储的 ByteBuf</td></tr><tr><td>heapBuffer()</td><td>返回一个基于堆内存存储的 ByteBuf</td></tr><tr><td>directBuffer()</td><td>返回一个基于直接内存存储的 ByteBuf</td></tr><tr><td>compositeBuffer()</td><td>返回一个可以通过添加最大到指定数目的基于堆的或者直接内存存储的缓冲区来扩展的 CompositeByteBuf</td></tr><tr><td>ioBuffer()</td><td>返回一个用于套接字的 I/O 操作的 ByteBuf，当所运行的环境具有 sun.misc.Unsafe 支持时，返回基于直接内存存储的 ByteBuf，否则返回基于堆内存存储的 ByteBuf；当指定使用 PreferHeapByteBufAllocator 时，则只会返回基于堆内存存储的 ByteBuf。</td></tr></tbody></table><p>　　可以通过 Channel（每个都可以有一个不同的 ByteBufAllocator 实例）或者绑定到 ChannelHandler 的 ChannelHandlerContext 获取一个到 ByteBufAllocator 的引用。</p><p>　　Netty 提供了两种 ByteBufAllocator 的实现：PooledByteBufAllocator 和 Unpooled-ByteBufAllocator。前者池化了 ByteBuf 的实例以提高性能并最大限度地减少内存碎片。后者的实现不池化 ByteBuf 实例，并且在每次它被调用时都会返回一个新的实例。</p><p>　　Netty4.1 默认使用了 PooledByteBufAllocator。</p><h5 id="2-Unpooled-缓冲区"><a href="#2-Unpooled-缓冲区" class="headerlink" title="2. Unpooled 缓冲区"></a>2. Unpooled 缓冲区</h5><p>　　Netty 提供了一个简单的称为 Unpooled 的工具类，它提供了静态的辅助方法来创建未池化的 ByteBuf 实例。</p><table><thead><tr><th>buffer()</th><th>返回一个未池化的基于堆内存存储的 ByteBuf</th></tr></thead><tbody><tr><td>directBuffer()</td><td>返回一个未池化的基于直接内存存储的 ByteBuf</td></tr><tr><td>wrappedBuffer()</td><td>返回一个包装了给定数据的 ByteBuf</td></tr><tr><td>copiedBuffer()</td><td>返回一个复制了给定数据的 ByteBuf</td></tr></tbody></table><p>　　Unpooled 类可用于 ByteBuf，同样可用于那些并不需要 Netty 的其他组件的非网络项目。</p><h5 id="3-随机访问索引-顺序访问索引-读写操作"><a href="#3-随机访问索引-顺序访问索引-读写操作" class="headerlink" title="3. 随机访问索引/顺序访问索引/读写操作"></a>3. 随机访问索引/顺序访问索引/读写操作</h5><p>　　如同在普通的 Java 字节数组中一样，ByteBuf 的索引是从零开始的：第一个字节的索引是 0，最后一个字节的索引总是 capacity() - 1。使用那些需要一个索引值参数(<strong>随机访问</strong>,也即是数组下标)的方法（的其中）之一来访问数据既不会改变 readerIndex 也不会改变 writerIndex。如果有需要，也可以通过调用 readerIndex(index) 或者 writerIndex(index) 来手动移动这两者。<strong>顺序访问</strong>通过索引访问</p><p>有两种类别的读/写操作：</p><p>　　get() 和 set() 操作，从给定的索引开始，并且保持索引不变；get+数据字长（bool.byte,int,short,long,bytes）</p><p>　　read() 和 write() 操作，从给定的索引开始，并且会根据已经访问过的字节数对索引进行调整。</p><p><strong>更多的操作：</strong></p><table><thead><tr><th>isReadable()</th><th>如果至少有一个字节可供读取，则返回true</th></tr></thead><tbody><tr><td>isWritable()</td><td>如果至少有一个字节可被写入，则返回true</td></tr><tr><td>readableBytes()</td><td>返回可被读取的字节数</td></tr><tr><td>writableBytes()</td><td>返回可被写入的字节数</td></tr><tr><td>capacity()</td><td>capacity() 返回ByteBuf 可容纳的字节数。在此之后，它会尝试再次扩展直到达到maxCapacity()</td></tr><tr><td>maxCapacity()</td><td>返回 ByteBuf 可以容纳的最大字节数</td></tr><tr><td>hasArray()</td><td>如果 ByteBuf 由一个字节数组支撑，则返回 true</td></tr><tr><td>array()</td><td>array() 如果 ByteBuf 由一个字节数组支撑则返回该数组；否则，它将抛出一个UnsupportedOperationException 异常</td></tr></tbody></table><p><strong>可丢弃字节：</strong></p><p>　　可丢弃字节的分段包含了已经被读过的字节。通过调用 discardReadBytes() 方法，可以丢弃它们并回收空间。这个分段的初始大小为 0，存储在 readerIndex 中，会随着 read 操作的执行而增加（get* 操作不会移动 readerIndex）。</p><p>　　缓冲区上调用 discardReadBytes() 方法后，可丢弃字节分段中的空间已经变为可写的了。频繁地调用 discardReadBytes() 方法以确保可写分段的最大化，但是请注意，这将极有可能会导致内存复制，因为可读字节必须被移动到缓冲区的开始位置。建议只在有真正需要的时候才这样做。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310112203093.png" style="zoom:60%;" /></center><p><strong>可读字节：</strong></p><p>　　ByteBuf 的可读字节分段存储了实际数据。新分配的、包装的或者复制的缓冲区的默认的 readerIndex 值为 0。</p><p><strong>可写字节：</strong></p><p>　　可写字节分段是指一个拥有未定义内容的、写入就绪的内存区域。新分配的缓冲区的 writerIndex 的默认值为0。任何名称以 write 开头的操作都将从当前的 writerIndex 处开始写数据，并将它增加已经写入的字节数。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310112206687.png" style="zoom:30%;" /></center><h5 id="4-索引管理"><a href="#4-索引管理" class="headerlink" title="4. 索引管理"></a>4. 索引管理</h5><p>　　调用 markReaderIndex()、markWriterIndex()、resetWriterIndex() 和 resetReaderIndex() 来标记和重置 ByteBuf 的 readerIndex 和 writerIndex。</p><p>　　也可以通过调用 readerIndex(int) 或者 writerIndex(int) 来将索引移动到指定位置。试图将任何一个索引设置到一个无效的位置都将导致一个 IndexOutOfBoundsException。</p><p>　　可以通过调用 clear() 方法来将 readerIndex 和 writerIndex 都设置为0。注意，这并不会清除内存中的内容。</p><h5 id="5-查找操作"><a href="#5-查找操作" class="headerlink" title="5. 查找操作"></a>5. 查找操作</h5><p>　　在 ByteBuf 中有多种可以用来确定指定值的索引的方法。最简单的是使用 indexOf() 方法。</p><p>　　较复杂的查找可以通过调用 forEachByte()。</p><p>　　下面的代码展示了一个查找回车符（\r）的例子。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">ByteBuf buffer = .. .;<br><br><span class="hljs-keyword">int</span> index = buffer.forEachByte(ByteBufProcessor.FIND_CR);<br></code></pre></td></tr></table></figure><h5 id="6-派生缓冲区"><a href="#6-派生缓冲区" class="headerlink" title="6. 派生缓冲区"></a>6. 派生缓冲区</h5><p>　　派生缓冲区为 ByteBuf 提供了以专门的方式来呈现其内容的视图。这类视图是通过以下方法被创建的：</p><p>　　duplicate()；slice()；slice(int, int)；Unpooled.unmodifiableBuffer(…)；order(ByteOrder)；readSlice(int)。</p><p>　　每个这些方法都将返回一个新的 ByteBuf 实例，它具有自己的读索引、写索引和标记索引。其内部存储和 JDK 的 ByteBuffer 一样也是共享的。</p><p>　　<strong>ByteBuf</strong> 复制：如果需要一个现有缓冲区的真实副本，请使用 copy() 或者 copy(int, int) 方法。不同于派生缓冲区，由这个调用所返回的 ByteBuf 拥有独立的数据副本。</p><h5 id="7-引用计数"><a href="#7-引用计数" class="headerlink" title="7. 引用计数"></a>7. 引用计数</h5><p>　　引用计数是一种通过在某个对象所持有的资源不再被其他对象引用时释放该对象所持有的资源来优化内存使用和性能的技术。Netty 在第4 版中为 ByteBuf 引入了引用计数技术， interface ReferenceCounted。</p><h5 id="8-工具类"><a href="#8-工具类" class="headerlink" title="8. 工具类"></a>8. 工具类</h5><p>　　<strong>ByteBufUtil</strong> 提供了用于操作 ByteBuf 的静态的辅助方法。因为这个 API 是通用的，并且和池化无关，所以这些方法已然在分配类的外部实现。</p><p>　　这些静态方法中最有价值的可能就是 hexdump() 方法，它以十六进制的表示形式打印 ByteBuf 的内容。这在各种情况下都很有用，例如，出于调试的目的记录ByteBuf 的内容。十六进制的表示通常会提供一个比字节值的直接表示形式更加有用的日志条目，此外，十六进制的版本还可以很容易地转换回实际的字节表示。</p><p>　　另一个有用的方法是 boolean equals(ByteBuf, ByteBuf)，它被用来判断两个 ByteBuf 实例的相等性。</p><h5 id="9-资源释放"><a href="#9-资源释放" class="headerlink" title="9. 资源释放"></a>9. 资源释放</h5><p>　　当某个 ChannelInboundHandler 的实现重写 channelRead() 方法时，它要负责显式地释放与池化的 ByteBuf 实例相关的内存。Netty  为此提供了一个实用方法 ReferenceCountUtil.release()</p><p>　　Netty 将使用 WARN 级别的日志消息记录未释放的资源，使得可以非常简单地在代码中发现违规的实例。但是以这种方式管理资源可能很繁琐。一个更加简单的方式是使用 SimpleChannelInboundHandler，SimpleChannelInboundHandler 会自动释放资源。</p><p>　　1、对于入站请求，Netty 的 EventLoop 在处理 Channel 的读操作时进行分配 ByteBuf，对于这类 ByteBuf，需要我们自行进行释放，有三种方式：</p><blockquote><ol><li><p>使用 SimpleChannelInboundHandler；</p></li><li><p>在重写 channelRead() 方法使用 ReferenceCountUtil.release()</p></li><li><p>在重写 channelRead() 方法使用使用 ctx.fireChannelRead 继续向后传递</p></li></ol></blockquote><p>　　2、对于出站请求，不管 ByteBuf 是否由我们的业务创建的，当调用了 write 或者 writeAndFlush 方法后，Netty 会自动替我们释放，不需要我们业务代码自行释放。</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty——初识Netty</title>
    <link href="/2023/10/05/Netty%E2%80%94%E2%80%94%E5%88%9D%E8%AF%86Netty/"/>
    <url>/2023/10/05/Netty%E2%80%94%E2%80%94%E5%88%9D%E8%AF%86Netty/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Netty的优势"><a href="#1-Netty的优势" class="headerlink" title="1. Netty的优势"></a>1. Netty的优势</h3><ol><li>API 使用简单，开发门槛低；</li><li>功能强大，预置了多种编解码功能，支持多种主流协议；</li><li>定制能力强，可以通过 ChannelHandler 对通信框架进行灵活地扩展；</li><li>性能高，通过与其他业界主流的 NIO 框架对比，Netty的综合性能最优；</li><li>成熟、稳定，Netty 修复了已经发现的所有 JDK NIO BUG，业务开发人员不需要再为 NIO 的 BUG 而烦恼；</li><li>社区活跃，版本迭代周期短，发现的 BUG 可以被及时修复，同时，更多的新功能会加入；</li><li>经历了大规模的商业应用考验，质量得到验证。</li></ol><p><strong>为什么 Netty 使用 NIO 而不是 AIO？</strong></p><p>　　Netty 不看重 Windows 上的使用，在 Linux 系统上，AIO 的底层实现仍使用 EPOLL，没有很好实现 AIO，因此在性能上没有明显的优势，而且被 JDK 封装了一层不容易深度优化。</p><p>　　AIO 还有个缺点是接收数据需要预先分配缓存, 而不是 NIO 那种需要接收时才需要分配缓存, 所以对连接数量非常大但流量小的情况, 内存浪费很多。而且 Linux 上 AIO 不够成熟，处理回调结果速度跟不上处理需求。</p><p>作者原话：</p><blockquote><p>Not faster than NIO (epoll) on unix systems (which is true)</p><p>There is no daragram suppport</p><p>Unnecessary threading model (too much abstraction without usage)</p></blockquote><h3 id="2-Hello-Netty"><a href="#2-Hello-Netty" class="headerlink" title="2. Hello Netty"></a>2. Hello Netty</h3><h4 id="2-1-基础组件"><a href="#2-1-基础组件" class="headerlink" title="2.1 基础组件"></a>2.1 基础组件</h4><h5 id="1-Bootstrap、EventLoop-Group-、Channel"><a href="#1-Bootstrap、EventLoop-Group-、Channel" class="headerlink" title="1. Bootstrap、EventLoop(Group) 、Channel"></a>1. Bootstrap、EventLoop(Group) 、Channel</h5><p>Bootstrap 是 Netty 框架的启动类和主入口类，分为客户端类 Bootstrap 和服务器类 ServerBootstrap 两种。</p><p>　　Channel 是 Java NIO 的一个基本构造。它代表一个到实体（如一个硬件设备、一个文件、一个网络套接字或者一个能够执行一个或者多个不同的 I/O 操作的程序组件）的开放连接，如读操作和写操作。目前，可以把 Channel 看作是传入（入站）或者传出（出站）数据的载体。因此，它可以被打开或者被关闭，连接或者断开连接。</p><p>EventLoop 暂时可以看成一个线程、EventLoopGroup 自然就可以看成线程组。</p><h5 id="2-事件和-ChannelHandler、ChannelPipeline"><a href="#2-事件和-ChannelHandler、ChannelPipeline" class="headerlink" title="2. 事件和 ChannelHandler、ChannelPipeline"></a>2. 事件和 ChannelHandler、ChannelPipeline</h5><p>　　Netty 使用不同的事件来通知我们状态的改变或者是操作的状态。这使得我们能够基于已经发生的事件来触发适当的动作。</p><p>Netty 事件是按照它们与入站或出站数据流的相关性进行分类的。可能由入站数据或者相关的状态更改而触发的事件包括：<strong>连接已被激活或者连接失活；数据读取；用户事件；错误事件</strong>。出站事件是未来将会触发的某个动作的操作结果，这些动作包括：<strong>打开或者关闭到远程节点的连接；将数据写到或者冲刷到套接字</strong>。</p><p>每个事件都可以被分发给 ChannelHandler 类中的某个用户实现的方法，既然事件分为入站和出站，用来处理事件的 ChannelHandler 也被分为可以处理入站事件的 Handler 和出站事件的 Handler，当然有些 Handler 既可以处理入站也可以处理出站。</p><p>　　Netty 提供了大量预定义的可以开箱即用的 ChannelHandler 实现，包括用于各种协议（如 HTTP 和 SSL/TLS）的 ChannelHandler。</p><p>基于 Netty 的网络应用程序中根据业务需求会使用 Netty 已经提供的 ChannelHandler 或者自行开发 ChannelHandler，这些 ChannelHandler 都放在 ChannelPipeline 中统一管理，事件就会在 ChannelPipeline 中流动，并被其中一个或者多个 ChannelHandler 处理。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310052050776.png" style="zoom:50%;" /></center><h5 id="3-ChannelFuture"><a href="#3-ChannelFuture" class="headerlink" title="3. ChannelFuture"></a>3. ChannelFuture</h5><p>Netty 中所有的 I/O 操作都是异步的，我们知道“异步的意思就是不需要主动等待结果的返回，而是通过其他手段比如，状态通知、回调函数等”，那就是说至少我们需要一种获得异步执行结果的手段。</p><p>　　JDK 预置了 interface java.util.concurrent.Future，Future 提供了一种在操作完成时通知应用程序的方式。这个对象可以看作是一个异步操作的结果的占位符；它将在未来的某个时刻完成，并提供对其结果的访问。但是其所提供的实现，只允许手动检查对应的操作是否已经完成，或者一直阻塞直到它完成。这是非常繁琐的，所以 Netty 提供了它自己的实现 ChannelFuture，用于在执行异步操作的时候使用。</p><p>一般来说，每个 Netty 的出站 I/O 操作都将返回一个 ChannelFuture<strong>。</strong></p><h4 id="2-2-服务端"><a href="#2-2-服务端" class="headerlink" title="2.2 服务端"></a>2.2 服务端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServer</span> </span>&#123;<br>  <br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EchoServer</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.port = port;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-comment">/*线程组*/</span><br>        NioEventLoopGroup eventLoopGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-comment">/*服务端启动必备*/</span><br>        ServerBootstrap bootstrap = <span class="hljs-keyword">new</span> ServerBootstrap();<br>        bootstrap.group(eventLoopGroup)<br>                .channel(NioServerSocketChannel.class)<span class="hljs-comment">/*指定使用NIO的通信模式*/</span><br>                .localAddress(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-keyword">this</span>.port))<span class="hljs-comment">/*指定监听端口*/</span><br>                .childHandler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> EchoServerHandler());<br>                    &#125;<br>                &#125;);<br>        <span class="hljs-keyword">try</span> &#123;<br>            ChannelFuture channelFuture = bootstrap.bind().sync();<span class="hljs-comment">/*异步绑定到服务器，sync()会阻塞到完成*/</span><br>            channelFuture.channel().closeFuture().sync();<span class="hljs-comment">/*阻塞当前线程，直到服务器的ServerChannel被关闭*/</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            eventLoopGroup.shutdownGracefully().sync();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">int</span> port = <span class="hljs-number">9999</span>;<br>        EchoServer echoServer = <span class="hljs-keyword">new</span> EchoServer(port);<br>        System.out.println(<span class="hljs-string">&quot;服务器即将启动&quot;</span>);<br>        echoServer.start();<br>        System.out.println(<span class="hljs-string">&quot;服务器关闭&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务端 ChannelHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoServerHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ChannelInboundHandlerAdapter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead</span><span class="hljs-params">(ChannelHandlerContext ctx, Object msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ByteBuf in = (ByteBuf) msg;<br>        System.out.println(<span class="hljs-string">&quot;Server accept: &quot;</span>+in.toString(CharsetUtil.UTF_8));<br>        ctx.writeAndFlush(in);<br>        <span class="hljs-comment">// ctx.close();</span><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">exceptionCaught</span><span class="hljs-params">(ChannelHandlerContext ctx, Throwable cause)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        cause.printStackTrace();<br>        ctx.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-客户端"><a href="#2-3-客户端" class="headerlink" title="2.3 客户端"></a>2.3 客户端</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoClient</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String host;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">EchoClient</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port, String host)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.port = port;<br>        <span class="hljs-keyword">this</span>.host = host;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        NioEventLoopGroup eventLoopGroup = <span class="hljs-keyword">new</span> NioEventLoopGroup();<br>        <span class="hljs-comment">/*客户端启动必备*/</span><br>        Bootstrap bootstrap = <span class="hljs-keyword">new</span> Bootstrap();<br>        bootstrap.group(eventLoopGroup)<br>                .channel(NioSocketChannel.class)<br>                .remoteAddress(<span class="hljs-keyword">new</span> InetSocketAddress(host, port))<span class="hljs-comment">/*指定服务器的IP地址和端口*/</span><br>                .handler(<span class="hljs-keyword">new</span> ChannelInitializer&lt;SocketChannel&gt;() &#123;<br>                    <span class="hljs-meta">@Override</span><br>                    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initChannel</span><span class="hljs-params">(SocketChannel ch)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>                        ch.pipeline().addLast(<span class="hljs-keyword">new</span> EchoClientHandler());<br>                    &#125;<br>                &#125;);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            ChannelFuture channelFuture = bootstrap.connect().sync();<span class="hljs-comment">/*异步连接到服务器，sync()会阻塞到完成*/</span><br>            channelFuture.channel().closeFuture().sync();<span class="hljs-comment">/*阻塞当前线程，直到客户端的Channel被关闭*/</span><br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            eventLoopGroup.shutdownGracefully().sync();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        <span class="hljs-keyword">new</span> EchoClient(<span class="hljs-number">9999</span>, <span class="hljs-string">&quot;127.0.0.1&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>客户端 ChannelHandler：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EchoClientHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SimpleChannelInboundHandler</span>&lt;<span class="hljs-title">ByteBuf</span>&gt; </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelRead0</span><span class="hljs-params">(ChannelHandlerContext ctx, ByteBuf msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;client Accept&quot;</span> + msg.toString(CharsetUtil.UTF_8));<br>        <span class="hljs-comment">// ctx.close();</span><br>    &#125;<br><br>    <span class="hljs-comment">/*channel活跃后，做业务处理*/</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">channelActive</span><span class="hljs-params">(ChannelHandlerContext ctx)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        ctx.writeAndFlush(Unpooled.copiedBuffer(<span class="hljs-string">&quot;Hello,Netty&quot;</span>, CharsetUtil.UTF_8));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty——直接内存、零拷贝、epoll模型</title>
    <link href="/2023/10/04/Netty%E2%80%94%E2%80%94%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E3%80%81%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%81epoll%E6%A8%A1%E5%9E%8B/"/>
    <url>/2023/10/04/Netty%E2%80%94%E2%80%94%E7%9B%B4%E6%8E%A5%E5%86%85%E5%AD%98%E3%80%81%E9%9B%B6%E6%8B%B7%E8%B4%9D%E3%80%81epoll%E6%A8%A1%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1-直接内存"><a href="#1-直接内存" class="headerlink" title="1. 直接内存"></a>1. 直接内存</h3><p>　　在所有的网络通信和应用程序中，每个 TCP 的 Socket 内核中都有一个发送缓冲区（SO_SNDBUF）和一个接收缓冲区（SO_RECVBUF），可以使用相关套接字选项来更改该缓冲区大小。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042044616.png" style="zoom:80%;" /></center><p>　　当某个应用进程调用 write时，内核从该应用进程的缓冲区中复制所有数据到所写套接字的发送缓冲区。如果该套接字的发送缓冲区容不下该应用进程的所有数据(或是应用进程的缓冲区大于套接字的发送缓冲区，或是套接字的发送缓冲区中已有其他数据)，假设该套接字是阻塞的，则该应用进程将被投入睡眠。内核将不从 write 系统调用返回，直到应用进程缓冲区中的所有数据都复制到套接字发送缓冲区。因此，从写一个 TCP 套接字的 write 调用成功返回仅仅表示我们可以重新使用原来的应用进程缓冲区，并不表明对端的 TCP 或应用进程已接收到数据。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042051030.png" style="zoom:50%;" /></center><p>　　Java 程序自然也要遵守上述的规则。但在 Java 中存在着堆、垃圾回收等特性，所以在实际的 IO 中，在 JVM 内部的存在着这样一种机制：</p><p>　　在 IO 读写上，如果是使用堆内存，JDK 会先创建一个 DirectBuffer，再去执行真正的写操作。这是因为，当我们把一个地址通过 JNI 传递给底层的 C 库的时候，有一个基本的要求，就是这个地址上的内容不能失效。然而，在 GC 管理下的对象是会在 Java 堆中移动的。也就是说，有可能我把一个地址传给底层的 write，但是这段内存却因为 GC 整理内存而失效了。所以必须要把待发送的数据放到一个 GC 管不着的地方。这就是调用 native 方法之前，数据—定要在堆外内存的原因。</p><p>　　可见，站在网络通信的角度 DirectBuffer 并没有节省什么内存拷贝，只是 Java 网络通信里因为 HeapBuffer 必须多做一次拷贝，使用 DirectBuffer 就会少一次内存拷贝。相比没有使用堆内存的 Java 程序，使用直接内存的 Java 程序当然更快一点。</p><p>　　从垃圾回收的角度而言，直接内存不受 GC(新生代的 Minor GC) 影响，只有当执行老年代的 Full GC 时候才会顺便回收直接内存，整理内存的压力也比数据放到 HeapBuffer 要小。</p><p><strong>堆外内存的优点和缺点：</strong></p><p>优点：</p><ol><li>减少了垃圾回收的工作</li><li>加快了复制的速度。因为堆内在 flush 到远程时，会先复制到直接内存（非堆内存），然后在发送；而堆外内存相当于省略掉了这个工作。</li></ol><p>缺点：</p><ol><li>堆外内存难以控制，如果内存泄漏很难排查 </li><li>堆外内存相对来说，不适合存储很复杂的对象。一般简单的对象或者扁平化的比较适合。</li></ol><h3 id="2-零拷贝"><a href="#2-零拷贝" class="headerlink" title="2. 零拷贝"></a>2. 零拷贝</h3><h4 id="2-1-什么是零拷贝"><a href="#2-1-什么是零拷贝" class="headerlink" title="2.1 什么是零拷贝"></a>2.1 什么是零拷贝</h4><p>　　零拷贝(英语: Zero-copy) 技术是指计算机执行操作时，CPU 不需要先将数据从某处内存复制到另一个特定区域。这种技术通常用于通过网络传输文件时节省 CPU 周期和内存带宽。</p><p>➢零拷贝技术可以减少数据拷贝和共享总线操作的次数，消除传输数据在存储器之间不必要的中间拷贝次数，从而有效地提高数据传输效率</p><p>➢零拷贝技术减少了用户进程地址空间和内核地址空间之间因为上:下文切换而带来的开销</p><p>　　可以看出没有说不需要拷贝，只是说减少冗余[不必要]的拷贝。</p><p>　　使用零拷贝的组件、框架：Kafka、Netty、Rocketmq、Nginx、Apache。</p><h4 id="2-2-Linux的I-O机制与DMA"><a href="#2-2-Linux的I-O机制与DMA" class="headerlink" title="2.2 Linux的I/O机制与DMA"></a>2.2 Linux的I/O机制与DMA</h4><p>在早期计算机中，用户进程需要读取磁盘数据，需要 CPU 中断和 CPU 参与，因此效率比较低，发起 IO 请求，每次的 IO 中断，都带来 CPU 的上下文切换，因此出现了——DMA。</p><p>DMA(Direct Memory Access，直接内存存取) 是所有现代电脑的重要特色，它允许不同速度的硬件装置来沟通，而不需要依赖于 CPU 的大量中断负载。</p><p>　　DMA 控制器，接管了数据读写请求，减少 CPU 的负担。这样一来，CPU 能高效工作了。现代硬盘基本都支持 DMA。</p><p>实际因此 IO 读取，涉及两个过程：</p><ol><li>DMA 等待数据准备好，把磁盘数据读取到操作系统内核缓冲区；</li><li>用户进程，将内核缓冲区的数据 copy 到用户空间。</li></ol><p><a href="https://www.jianshu.com/p/3a26e8c9f402">（传送门）</a></p><h4 id="2-3-传统数据传送机制"><a href="#2-3-传统数据传送机制" class="headerlink" title="2.3 传统数据传送机制"></a>2.3 传统数据传送机制</h4><p>比如读取文件，再用 socket 发送出去，实际经过四次 copy。</p><p>伪码实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">buffer = File.read() <br>Socket.send(buffer)<br></code></pre></td></tr></table></figure><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042117088.png" style="zoom:50%;" /></center><p>1、第一次：将磁盘文件，读取到操作系统内核缓冲区；</p><p>2、第二次：将内核缓冲区的数据，copy 到应用程序的 buffer；</p><p>3、第三步：将 application 应用程序 buffer 中的数据，copy 到 socket 网络发送缓冲区(属于操作系统内核的缓冲区)；</p><p>4、第四次：将 socket buffer 的数据，copy 到网卡，由网卡进行网络传输。</p><p>分析上述的过程，虽然引入 DMA 来接管 CPU 的中断请求，但四次 copy 是存在“不必要的拷贝”的。实际上并不需要第二个和第三个数据副本。应用程序除了缓存数据并将其传输回套接字缓冲区之外什么都不做。相反，数据可以直接从读缓冲区传输到套接字缓冲区。</p><p>　　显然，第二次和第三次数据 copy 其实在这种场景下没有什么帮助反而带来开销，这也正是零拷贝出现的背景和意义。</p><p>　　同时，read 和 send 都属于系统调用，每次调用都牵涉到两次上下文切换：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042138197.png" style="zoom:50%;" /></center><p>　　</p><p>　　总结下，传统的数据传送所消耗的成本：4 次拷贝，4 次上下文切换。</p><p>　　4 次拷贝，其中两次是 DMA copy，两次是 CPU copy。</p><h4 id="2-4-Linux支持的-常见-零拷贝"><a href="#2-4-Linux支持的-常见-零拷贝" class="headerlink" title="2.4 Linux支持的(常见)零拷贝"></a>2.4 Linux支持的(常见)零拷贝</h4><p>　　目的：减少 IO 流程中不必要的拷贝，当然零拷贝需要 OS 支持，也就是需要 kernel 暴露　api。</p><h5 id="1-mmap内存映射"><a href="#1-mmap内存映射" class="headerlink" title="1. mmap内存映射"></a>1. mmap内存映射</h5><p>　　硬盘上文件的位置和应用程序缓冲区(application buffers)进行映射（建立一种一一对应关系），由于 mmap() 将文件直接映射到用户空间，所以实际文件读取时根据这个映射关系，直接将文件从硬盘拷贝到用户空间，只进行了一次数据拷贝，不再有文件内容从硬盘拷贝到内核空间的一个缓冲区。</p><p>　　mmap 内存映射将会经历：3次拷贝: 1次 cpu copy，2次 DMA copy；</p><p>　　以及4次上下文切换，调用 mmap 函数2次，write 函数2次。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042150357.png" style="zoom:50%;" /></center><h5 id="2-sendfile"><a href="#2-sendfile" class="headerlink" title="2. sendfile"></a>2. sendfile</h5><p>　　linux 2.1 支持的 sendfile</p><p>　　当调用 sendfile() 时，DMA 将磁盘数据复制到 kernel buffer，然后将内核中的 kernel buffer 直接拷贝到 socket buffer；但是数据并未被真正复制到 socket 关联的缓冲区内。取而代之的是，只有记录数据位置和长度的描述符被加入到 socket 缓冲区中。DMA 模块将数据直接从内核缓冲区传递给协议引擎，从而消除了遗留的最后一次复制。但是要注意，这个需要 DMA 硬件设备支持，如果不支持，CPU 就必须介入进行拷贝。</p><p>　　一旦数据全都拷贝到 socket buffer，sendfile() 系统调用将会 return、代表数据转化的完成。socket buffer 里的数据就能在网络传输了。</p><p>　　sendfile 会经历：3（2，如果硬件设备支持）次拷贝，1（0，如果硬件设备支持）次 CPU copy， 2次 DMA copy；以及2次上下文切换</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042155284.png" style="zoom:60%;" /></center><h5 id="3-splice"><a href="#3-splice" class="headerlink" title="3. splice"></a>3. splice</h5><p>　　Linux 从 2.6.17 支持 splice</p><p>　　数据从磁盘读取到 OS 内核缓冲区后，在内核缓冲区直接可将其转成内核空间其他数据 buffer，而不需要拷贝到用户空间。</p><p>　　如下图所示，从磁盘读取到内核 buffer 后，在内核空间直接与 socket buffer 建立 pipe 管道。</p><p>　　和 sendfile() 不同的是，splice() 不需要硬件支持。</p><p>　　注意 splice 和 sendfile 的不同，sendfile 是 DMA 硬件设备不支持的情况下将磁盘数据加载到 kernel buffer 后，需要一次 CPU copy，拷贝到 socket buffer。而 splice 是更进一步，连这个 CPU copy 也不需要了，直接将两个内核空间的  buffer进行 pipe。</p><p>　　splice 会经历2次拷贝: 0次 cpu copy，2次 DMA copy；以及2次上下文切换</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042208186.png" style="zoom:60%;" /></center><h4 id="2-5-Java生态圈中的零拷贝"><a href="#2-5-Java生态圈中的零拷贝" class="headerlink" title="2.5 Java生态圈中的零拷贝"></a>2.5 Java生态圈中的零拷贝</h4><p>　　Linux 提供的零拷贝技术 Java 并不是全支持，支持2种(内存映射mmap、sendfile)；</p><h5 id="1-NIO提供的内存映射-MappedByteBuffer"><a href="#1-NIO提供的内存映射-MappedByteBuffer" class="headerlink" title="1. NIO提供的内存映射 MappedByteBuffer"></a>1. NIO提供的内存映射 MappedByteBuffer</h5><p>　　NIO 中的 FileChannel.map() 方法其实就是采用了操作系统中的内存映射方式，底层就是调用 Linux mmap() 实现的。</p><p>　　将内核缓冲区的内存和用户缓冲区的内存做了一个地址映射。这种方式适合读取大文件，同时也能对文件内容进行更改，但是如果其后要通过 SocketChannel 发送，还是需要 CPU 进行数据的拷贝。</p><h5 id="2-NIO提供的sendfile"><a href="#2-NIO提供的sendfile" class="headerlink" title="2. NIO提供的sendfile"></a>2. NIO提供的sendfile</h5><p>　　Java NIO 中提供的 FileChannel 拥有 transferTo 和 transferFrom 两个方法，可直接把 FileChannel 中的数据拷贝到另外一个 Channel，或者直接把另外一个 Channel 中的数据拷贝到 FileChannel。该接口常被用于高效的网络 / 文件的数据传输和大文件拷贝。在操作系统支持的情况下，通过该方法传输数据并不需要将源数据从内核态拷贝到用户态，再从用户态拷贝到目标通道的内核态，同时也避免了两次用户态和内核态间的上下文切换，也即使用了“零拷贝”，所以其性能一般高于 Java IO 中提供的方法。</p><h5 id="3-Kafka中的零拷贝"><a href="#3-Kafka中的零拷贝" class="headerlink" title="3. Kafka中的零拷贝"></a>3. Kafka中的零拷贝</h5><p>　　Kafka 两个重要过程都使用了零拷贝技术，且都是操作系统层面的狭义零拷贝，一是 Producer 生产的数据存到 broker，二是 Consumer 从 broker 读取数据。</p><p>　　Producer 生产的数据持久化到 broker，broker 里采用 mmap 文件映射，实现顺序的快速写入；</p><p>　　Customer 从 broker 读取数据，broker 里采用 sendfile，将磁盘文件读到 OS 内核缓冲区后，直接转到 socket buffer 进行网络发送。</p><h5 id="4-Netty的零拷贝实现"><a href="#4-Netty的零拷贝实现" class="headerlink" title="4. Netty的零拷贝实现"></a>4. Netty的零拷贝实现</h5><p>　　Netty 的零拷贝主要包含三个方面：</p><p>　　在网络通信上，Netty 的接收和发送 ByteBuffer 采用 DIRECT BUFFERS，使用堆外直接内存进行 Socket 读写，不需要进行字节缓冲区的二次拷贝。如果使用传统的堆内存（HEAP BUFFERS）进行 Socket 读写，JVM 会将堆内存 Buffer 拷贝一份到直接内存中，然后才写入 Socket 中。相比于堆外直接内存，消息在发送过程中多了一次缓冲区的内存拷贝。</p><p>　　在缓存操作上，Netty 提供了 CompositeByteBuf 类，它可以将多个 ByteBuf 合并为一个逻辑上的 ByteBuf，避免了各个 ByteBuf 之间的拷贝。</p><p>　　通过 wrap 操作，我们可以将 byte[] 数组、ByteBuf、 ByteBuffer 等包装成一个 Netty ByteBuf 对象，进而避免了拷贝操作。</p><p>　　ByteBuf 支持 slice 操作，因此可以将 ByteBuf 分解为多个共享同一个存储区域的 ByteBuf，避免了内存的拷贝。</p><p>　　在文件传输上，Netty 的通过 FileRegion 包装的 FileChannel.tranferTo 实现文件传输，它可以直接将文件缓冲区的数据发送到目标 Channel，避免了传统通过循环 write 方式导致的内存拷贝问题。</p><h3 id="3-Linux网络IO模型"><a href="#3-Linux网络IO模型" class="headerlink" title="3. Linux网络IO模型"></a>3. Linux网络IO模型</h3><p><strong>同步和异步</strong></p><p>　　关注的是调用方是否主动获取结果</p><p>　　同步：同步的意思就是调用方需要主动等待结果的返回</p><p>　　异步：异步的意思就是不需要主动等待结果的返回，而是通过其他手段比如，状态通知，回调函数等。</p><p><strong>阻塞和非阻塞</strong></p><p>　　关注的是等待结果返回调用方的状态</p><p>　　阻塞：是指结果返回之前，当前线程被挂起，不做任何事</p><p>　　非阻塞：是指结果在返回之前，线程可以做一些其他事，不会被挂起。</p><p><strong>Linux下的五种I/O模型</strong></p><p><a href="https://blog.51cto.com/u_15467009/7063136">（传送门）</a></p><center>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042252521.png" style="zoom:50%;" /></center><p>　　总的来说，阻塞 IO 就是 JDK 里的 BIO 编程，IO 复用就是 JDK 里的 NIO 编程，Linux下异步 IO 的实现建立在 epoll 之上，是个伪异步实现，而且相比 IO 复用，没有体现出性能优势，使用不广。非阻塞 IO 使用轮询模式，会不断检测是否有数据到达，大量的占用 CPU 的时间，是绝不被推荐的模型。信号驱动 IO 需要在网络通信时额外安装信号处理函数，使用也不广泛。</p><p>阻塞式 I/O 模型：</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042232204.png" style="zoom:50%;" /></center><p> I/O复用模型：</p><center>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042236640.png" style="zoom:50%;" /></center><p>　　比较上面两张图，IO 复用需要使用两个系统调用（select 和 recvfrom），而 blocking IO 只调用了一个系统调用（recvfrom）。但是，用 select 的优势在于它可以同时处理多个 connection。所以，如果处理的连接数不是很高的话，使用 select/epoll 的 web server 不一定比使用 multi-threading + blocking IO 的 web server 性能更好，可能延迟还更大。select/epoll 的优势并不是对于单个连接能处理得更快，而是在于能处理更多的连接。</p><h3 id="4-Linux下的IO复用编程"><a href="#4-Linux下的IO复用编程" class="headerlink" title="4. Linux下的IO复用编程"></a>4. Linux下的IO复用编程</h3><p>　　select，poll，epoll 都是 IO 多路复用的机制。I/O 多路复用就是通过一种机制，一个进程可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。但 select，poll，epoll 本质上都是同步 I/O，因为他们都需要在读写事件就绪后自己负责进行读写，并等待读写完成。</p><h4 id="4-1-文件描述符FD"><a href="#4-1-文件描述符FD" class="headerlink" title="4.1 文件描述符FD"></a>4.1 文件描述符FD</h4><p>　　在 Linux 操作系统中，可以将一切都看作是文件，包括普通文件，目录文件，字符设备文件（如键盘，鼠标…），块设备文件（如硬盘，光驱…），套接字等等，所有一切均抽象成文件，提供了统一的接口，方便应用程序调用。</p><p>既然在 Linux 操作系统中，你将一切都抽象为了文件，那么对于一个打开的文件，我应用程序怎么对应上呢？文件描述符应运而生。</p><p>　　文件描述符：File descriptor，简称 fd，当应用程序请求内核打开/新建一个文件时，内核会返回一个文件描述符用于对应这个打开/新建的文件，其 fd 本质上就是一个非负整数。实际上，它是一个索引值，指向内核为每一个进程所维护的该进程打开文件的记录表。当程序打开一个现有文件或者创建一个新文件时，内核向进程返回一个文件描述符。</p><p>　　系统为了维护文件描述符建立了3个表：进程级的文件描述符表、系统级的文件描述符表、文件系统的 i-node 表。所谓进程级的文件描述符表，指操作系统为每一个进程维护了一个文件描述符表，该表的索引值都从 0 开始的，所以在不同的进程中可以看到相同的文件描述符，这种情况下相同的文件描述符可能指向同一个实际文件，也可能指向不同的实际文件。</p><h4 id="4-2-select"><a href="#4-2-select" class="headerlink" title="4.2 select"></a>4.2 select</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs C"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">select</span> <span class="hljs-params">(<span class="hljs-keyword">int</span> n, fd_set *readfds, fd_set *writefds, fd_set *exceptfds, struct timeval *timeout)</span></span>;<br></code></pre></td></tr></table></figure><p>　　select 函数监视的文件描述符分 3 类，分别是 writefds、readfds、和 exceptfds。调用后 select 函数会阻塞，直到有描述副就绪（有数据 可读、可写、或者有错误发生），或者超时（ timeout 指定等待时间，如果立即返回设为 null 即可）函数返回。当 select 函数返回后，可以通过遍历 fdset，来找到就绪的描述符。</p><p>　　select 目前几乎在所有的平台上支持，其良好跨平台支持也是它的一个优点。select 的一 个缺点在于单个进程能够监视的文件描述符的数量存在最大限制，在 Linux 上一般为 1024，可以通过修改宏定义甚至重新编译内核的方式提升这一限制，但是这样也会造成效率的降低。</p><h4 id="4-3-poll"><a href="#4-3-poll" class="headerlink" title="4.3 poll"></a>4.3 poll</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">poll</span> <span class="hljs-params">(struct pollfd *fds, <span class="hljs-keyword">unsigned</span> <span class="hljs-keyword">int</span> nfds, <span class="hljs-keyword">int</span> timeout)</span></span>;<br></code></pre></td></tr></table></figure><p>　　不同于 select 使用三个位图来表示三个 fdset 的方式，poll 使用一个 pollfd 的指针实现。</p><p>　　pollfd 结构包含了要监视的 event 和发生的 event，不再使用 select “参数-值”传递的方式。同时，pollfd 并没有最大数量限制（但是数量过大后性能也是会下降）。 和 select 函数一样，poll 返回后，需要轮询 pollfd 来获取就绪的描述符。</p><h4 id="4-4-epoll"><a href="#4-4-epoll" class="headerlink" title="4.4 epoll"></a>4.4 epoll</h4><p>　　epoll 是在 2.6 内核中提出的，是之前的 select 和 poll 的增强版本。相对于 select 和 poll 来说，可以看到 epoll 做了更细致的分解，包含了三个方法，使用上更加灵活。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_create</span><span class="hljs-params">(<span class="hljs-keyword">int</span> size)</span>；</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_ctl</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd, <span class="hljs-keyword">int</span> op, <span class="hljs-keyword">int</span> fd, struct epoll_event *event)</span>；</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">epoll_wait</span><span class="hljs-params">(<span class="hljs-keyword">int</span> epfd, struct epoll_event * events, <span class="hljs-keyword">int</span> maxevents, <span class="hljs-keyword">int</span> timeout)</span></span>;<br></code></pre></td></tr></table></figure><p>　　①  <strong>epoll_create()</strong>　创建一个 epoll 的句柄，size 用来告诉内核这个监听的数目一共有多大，这个参数不同于 select() 中的第一个参数，给出最大监听的 fd+1 的值，参数 size 并不是限制了 epoll 所能监听的描述符最大个数，只是对内核初始分配内部数据结构的一个建议。当创建好 epoll 句柄后，它就会占用一个 fd 值，在 linux 下如果查看 /proc/进程id/fd/，是能够看到这个 fd 的，所以在使用完 epoll 后，必须调用 close() 关闭，否则可能导致 fd 被耗尽。</p><p>　　作为类比，可以理解为　JDK NIO　编程里的　selector = Selector.open();</p><p>　　② <strong>epoll_ctl</strong>　函数是对指定描述符 fd 执行 op 操作。</p><blockquote><p>epfd：是 epoll_create() 的返回值。</p><p>op：表示操作，用三个宏来表示：添加 EPOLL_CTL_ADD，删除 EPOLL_CTL_DEL，修改 EPOLL_CTL_MOD。分别添加、删除和修改对 fd 的监听事件。</p><p>fd：是需要监听的 fd（文件描述符）</p><p>epoll_event：是告诉内核需要监听什么事，有具体的宏可以使用，比如 EPOLLIN ：表示对应的文件描述符可以读（包括对端 SOCKET 正常关闭）；EPOLLOUT：表示对应的文件描述符可以写；</p></blockquote><p>　　作为类比，可以理解为 JDK NIO 编程里的 socketChannel.register();</p><p>　　③ <strong>epoll_wait</strong> 等待 epfd 上的 io 事件，最多返回 maxevents 个事件。</p><blockquote><p>events：用来从内核得到事件的集合</p><p>maxevents：告诉内核 events 有多大，这个maxevents的值不能大于创建epoll_create()时的size。</p><p>timeout：超时时间（毫秒，0会立即返回，-1将不确定，也有说法说是永久阻塞）。该函数返回需要处理的事件数目，如返回0表示已超时。</p></blockquote><p>　　作为类比，可以理解为对应于 JDK NIO 编程里的 selector.select();</p><h4 id="4-5-select、poll、epoll-的比较"><a href="#4-5-select、poll、epoll-的比较" class="headerlink" title="4.5 select、poll、epoll 的比较"></a>4.5 select、poll、epoll 的比较</h4><p>　　select，poll，epoll 都是操作系统实现  IO 多路复用的机制。 I/O 多路复用就通过一种机制，可以监视多个描述符，一旦某个描述符就绪（一般是读就绪或者写就绪），能够通知程序进行相应的读写操作。那么这三种机制有什么区别呢。</p><table><thead><tr><th align="center">\</th><th align="center">select</th><th align="center">poll</th><th align="center">epoll</th></tr></thead><tbody><tr><td align="center">操作方式</td><td align="center">遍历</td><td align="center">遍历</td><td align="center">回调</td></tr><tr><td align="center">底层实现</td><td align="center">数组</td><td align="center">链表</td><td align="center">哈希表</td></tr><tr><td align="center">IO效率</td><td align="center">每次调用都进行线性遍历，时间复杂度为O(n)</td><td align="center">每次调用都进行线性遍历，时间复杂度为O(n)</td><td align="center">事件通知方式，每当fd就绪，系统注册的回调函数就会被调用，将就绪fd放到rdllist里面。时间复杂度O(1)</td></tr><tr><td align="center">最大连接数</td><td align="center">1024（x86）或 2048（x64）</td><td align="center">无上限</td><td align="center">无上限</td></tr><tr><td align="center">fd拷贝</td><td align="center">每次调用 select，都需要把 fd 集合从用户态拷贝到内核态</td><td align="center">每次调用 poll，都需要把 fd 集合从用户态拷贝到内核态</td><td align="center">调用 epoll_ctl 时拷贝进内核并保存，之后每次 epoll_wait 不拷贝</td></tr></tbody></table><p> 1、支持一个进程所能打开的最大连接数</p><table><thead><tr><th>select</th><th>单个进程所能打开的最大连接数有 FD_SETSIZE 宏定义，其大小是 32 个整数的大小（在32位的机器上，大小就是32<em>32，同理64位机器上FD_SETSIZE为32</em>64），当然我们可以对进行修改，然后重新编译内核，但是性能可能会受到影响。</th></tr></thead><tbody><tr><td>poll</td><td>poll本质上和select没有区别，但是它没有最大连接数的限制，原因是它是基于链表来存储的</td></tr><tr><td>epoll</td><td>虽然连接数基本上只受限于机器的内存大小</td></tr></tbody></table><p>2、FD 剧增后带来的 IO 效率问题</p><table><thead><tr><th>select</th><th>因为每次调用时都会对连接进行线性遍历，所以随着 FD 的增加会造成遍历速度慢的“线性下降性能问题”。</th></tr></thead><tbody><tr><td>poll</td><td>同上</td></tr><tr><td>epoll</td><td>因为 epoll 内核中实现是根据每个 fd 上的 callback 函数来实现的，只有活跃的 socket 才会主动调用 callback，所以在活跃 socket 较少的情况下，使用 epoll 没有前面两者的线性下降的性能问题，但是所有 socket 都很活跃的情况下，可能会有性能问题。</td></tr></tbody></table><p>3、 消息传递方式</p><table><thead><tr><th>select</th><th>内核需要将消息传递到用户空间，都需要内核拷贝动作</th></tr></thead><tbody><tr><td>poll</td><td>同上</td></tr><tr><td>epoll</td><td>epoll 通过内核和用户空间共享一块内存来实现的。</td></tr></tbody></table><p><strong>总结：</strong></p><p>综上，在选择 select，poll，epoll 时要根据具体的使用场合以及这三种方式的自身特点。</p><p>1、表面上看 epoll 的性能最好，但是在连接数少并且连接都十分活跃的情况下，select 和 poll 的性能可能比 epoll 好，毕竟 epoll 的通知机制需要很多函数回调。</p><p>2、select 低效是因为每次它都需要轮询。但低效也是相对的，视情况而定，也可通过良好的设计改善。</p><h3 id="5-epoll-原理和底层机制分析"><a href="#5-epoll-原理和底层机制分析" class="headerlink" title="5. epoll 原理和底层机制分析"></a>5. epoll 原理和底层机制分析</h3><p>　　了解 epoll 本质的第一步，要从硬件的角度看计算机怎样接收网络数据。</p><center>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051505722.png" style="zoom:50%;" /></center><p> 　　网卡收到网线传来的数据，经过硬件电路的传输，最终将数据写入到内存中的某个地址上。</p><h4 id="5-1-如何知道接收了数据？"><a href="#5-1-如何知道接收了数据？" class="headerlink" title="5.1 如何知道接收了数据？"></a>5.1 如何知道接收了数据？</h4><p>　　CPU 和操作系统如何知道网络上有数据要接收？很简单，使用中断机制。</p><p>　　<strong>中断、上半部、下半部</strong></p><p>　　内核和设备驱动是通过中断的方式来处理的。所谓中断，可以理解为当设备上有数据到达的时候，会给 CPU 的相关引脚上触发一个电压变化，以通知 CPU 来处理数据。</p><p>　　计算机执行程序时，会有优先级的需求。比如，当计算机收到断电信号时（电容可以保存少许电量，供 CPU 运行很短的一小段时间），它应立即去保存数据，保存数据的程序具有较高的优先级。</p><p>　　一般而言，由硬件产生的信号需要 cpu 立马做出回应（不然数据可能就丢失），所以它的优先级很高。cpu 理应中断掉正在执行的程序，去做出响应；当 cpu 完成对硬件的响应后，再重新执行用户程序。中断的过程如下图，和函数调用差不多。只不过函数调用是事先定好位置，而中断的位置由“信号”决定。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051511531.png" style="zoom:50%;" /></center><p>　　当网卡把数据写入到内存后，网卡向 cpu 发出一个中断信号，操作系统便能得知有新数据到来，再通过网卡中断程序去处理数据。</p><p>　　对于网络模块来说，由于处理过程比较复杂和耗时，如果在中断函数中完成所有的处理，将会导致中断处理函数（优先级过高）将过度占据 CPU，将导致 CPU 无法响应其它设备，例如鼠标和键盘的消息。</p><p>　　因此 Linux 中断处理函数是分上半部和下半部的。上半部是只进行最简单的工作，快速处理然后释放 CPU，接着 CPU 就可以允许其它中断进来。剩下将绝大部分的工作都放到下半部中，可以慢慢从容处理。2.4 以后的内核版本采用的下半部实现方式是软中断，由 ksoftirqd 内核线程全权处理。和硬中断不同的是，硬中断是通过给 CPU 物理引脚施加电压变化，而软中断是通过给内存中的一个变量的二进制值以通知软中断处理程序。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051516121.png" style="zoom:50%;" /></center><p>　　当网卡上收到数据以后，Linux 中第一个工作的模块是网络驱动。 网络驱动会以 DMA 的方式把网卡上收到的帧写到内存里。再向 CPU 发起一个中断，以通知 CPU 有数据到达。第二，当 CPU 收到中断请求后，会去调用网络驱动注册的中断处理函数。 网卡的中断处理函数并不做过多工作，发出软中断请求，然后尽快释放 CPU。ksoftirqd 检测到有软中断请求到达，调用 poll 开始轮询收包，收到后交由各级协议栈处理。最后会被放到用户 socket 的接收队列中。</p><h4 id="5-2-进程阻塞"><a href="#5-2-进程阻塞" class="headerlink" title="5.2 进程阻塞"></a>5.2 进程阻塞</h4><p>了解 epoll 本质，要从操作系统进程调度的角度来看数据接收。阻塞是进程调度的关键一环，指的是进程在等待某事件（如接收到网络数据）发生之前的等待状态，recv、select 和 epoll 都是阻塞方法。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">//创建socket</span><br><span class="hljs-keyword">int</span> s = socket(AF_INET, SOCK_STREAM, <span class="hljs-number">0</span>);   <br><span class="hljs-comment">//绑定</span><br>bind(s, ...)<br><span class="hljs-comment">//监听</span><br>listen(s, ...)<br><span class="hljs-comment">//接受客户端连接</span><br><span class="hljs-keyword">int</span> c = accept(s, ...)<br><span class="hljs-comment">//接收客户端数据</span><br>recv(c, ...);<br><span class="hljs-comment">//将数据打印出来</span><br><span class="hljs-built_in">printf</span>(...)<br></code></pre></td></tr></table></figure><p>　　这是一段最基础的网络编程代码，先新建 socket 对象，依次调用 bind、listen、accept，最后调用 recv 接收数据。recv 是个阻塞方法，当程序运行到 recv 时，它会一直等待，直到接收到数据才往下执行。</p><p>那么阻塞的原理是什么？</p><p>　　操作系统为了支持多任务，实现了进程调度的功能，会把进程分为“运行”和“等待”等几种状态。运行状态是进程获得 cpu 使用权，正在执行代码的状态；等待状态是阻塞状态，比如上述程序运行到 recv 时，程序会从运行状态变为等待状态，接收到数据后又变回运行状态。操作系统会分时执行各个运行状态的进程，由于速度很快，看上去就像是同时执行多个任务。</p><p>　　下图中的计算机中运行着 A、B、C 三个进程，其中进程 A 执行着上述基础网络程序，一开始，这3个进程都被操作系统的工作队列所引用，处于运行状态，会分时执行。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051535749.png" style="zoom:70%;" /></center><p>　　当进程 A 执行到创建 socket 的语句时，操作系统会创建一个由文件系统管理的 socket 对象。这个 socket 对象包含了发送缓冲区、接收缓冲区、等待队列等成员。等待队列是个非常重要的结构，它指向所有需要等待该 socket 事件的进程。</p><p>　　当程序执行到 recv 时，操作系统会将进程 A 从工作队列移动到该 socket 的等待队列中（如下图）。由于工作队列只剩下了进程 B 和 C，依据进程调度，cpu 会轮流执行这两个进程的程序，不会执行进程 A 的程序。所以进程 A 被阻塞，不会往下执行代码，也不会占用 cpu 资源。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051539517.png" style="zoom:70%;" /></center><p> 　　操作系统添加等待队列只是添加了对这个“等待中”进程的引用，以便在接收到数据时获取进程对象、将其唤醒，而非直接将进程管理纳入自己之下。上图为了方便说明，直接将进程挂到等待队列之下。</p><p>　　当 socket 接收到数据后，操作系统将该 socket 等待队列上的进程重新放回到工作队列，该进程变成运行状态，继续执行代码。也由于 socket 的接收缓冲区已经有了数据，recv 可以返回接收到的数据。</p><h4 id="5-3-内核接收网络数据"><a href="#5-3-内核接收网络数据" class="headerlink" title="5.3 内核接收网络数据"></a>5.3 内核接收网络数据</h4><p>　　进程在 recv 阻塞期间，计算机收到了对端传送的数据（步骤①）。数据经由网卡传送到内存（步骤②），然后网卡通过中断信号通知 cpu 有数据到达，cpu 执行中断程序（步骤③）。此处的中断程序主要有两项功能，先将网络数据写入到对应 socket 的接收缓冲区里面（步骤④），再唤醒进程 A（步骤⑤），重新将进程 A 放入工作队列中。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051543056.png" style="zoom:60%;" /></center>   <p>　　操作系统如何知道网络数据对应于哪个 socket？因为一个 socket 对应着一个端口号，而网络数据包中包含了 ip 和端口的信息，内核可以通过端口号找到对应的 socket。当然，为了提高处理速度，操作系统会维护端口号到 socket 的索引结构，以快速读取。</p><h4 id="5-4-同时监视多个-socket-的简单方法"><a href="#5-4-同时监视多个-socket-的简单方法" class="headerlink" title="5.4 同时监视多个 socket 的简单方法"></a>5.4 同时监视多个 socket 的简单方法</h4><p>　　服务端需要管理多个客户端连接，而 recv 只能监视单个 socket，这种矛盾下，人们开始寻找监视多个 socket 的方法。epoll 的要义是高效的监视多个 socket。从历史发展角度看，必然先出现一种不太高效的方法，人们再加以改进。只有先理解了不太高效的方法，才能够理解 epoll 的本质。</p><p>　　假如能够预先传入一个 socket 列表，如果列表中的 socket 都没有数据，挂起进程，直到有一个 socket 收到数据，唤醒进程。这种方法很直接，也是 select 的设计思想。</p><p>　　为方便理解，我们先看看 Linux 中 select 的用法。在如下的代码中，先准备一个数组（下面代码中的 fds），让 fds 存放着所有需要监视的 socket。然后调用 select，如果 fds 中的所有 socket 都没有数据，select 会阻塞，直到有一个 socket 接收到数据，select 返回，唤醒进程。用户可以遍历 fds，通过 FD_ISSET 判断具体哪个 socket 收到数据，然后做出处理。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> fds[] =  存放需要监听的socket<br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">int</span> n = select(..., fds, ...)<br>    <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> i=<span class="hljs-number">0</span>; i &lt; fds.count; i++)&#123;<br>        <span class="hljs-keyword">if</span>(FD_ISSET(fds[i], ...))&#123;<br>            <span class="hljs-comment">//fds[i]的数据处理</span><br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　select 的实现思路很直接。假如程序同时监视 sock1、sock2 和 sock3 三个 socket，那么在调用 select 之后，操作系统把进程 A 分别加入这三个 socket 的等待队列中。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051551762.png" style="zoom:67%;" /></center><p>　　当任何一个 socket 收到数据后，中断程序将唤起进程。所谓唤起进程，就是将进程从所有的等待队列中移除，加入到工作队列里面。当进程 A 被唤醒后，它知道至少有一个 socket 接收了数据。程序只需遍历一遍 socket 列表，就可以得到就绪的 socket。</p><p>　　这种简单方式行之有效，在几乎所有操作系统都有对应的实现。但是简单的方法往往有缺点，主要是：</p><p>　　其一，每次调用 select 都需要将进程加入到所有被监视 socket 的等待队列，每次唤醒都需要从每个队列中移除，都必须要进行遍历。而且每次都要将整个 fds 列表传递给内核，有一定的开销。正是因为遍历操作开销大，出于效率的考量，才会规定 select 的最大监视数量，默认只能监视 1024 个socket。</p><p>　　其二，进程被唤醒后，程序并不知道哪些 socket 收到数据，还需要遍历一次。</p><p>　　那么，有没有减少遍历的方法？有没有保存就绪 socket 的方法？这两个问题便是 epoll 技术要解决的。</p><h4 id="5-5-epoll的设计思路"><a href="#5-5-epoll的设计思路" class="headerlink" title="5.5 epoll的设计思路"></a>5.5 epoll的设计思路</h4><p>　　epoll 是在 select 出现 N 多年后才被发明的，是 select 和 poll 的增强版本。epoll 通过以下一些措施来改进效率。</p><p>　　措施一：功能分离</p><p>　　select 低效的原因之一是将“维护等待队列”和“阻塞进程”两个步骤合二为一。每次调用 select 都需要这两步操作，然而大多数应用场景中，需要监视的 socket 相对固定，并不需要每次都修改。epoll 将这两个操作分开，先用 epoll_ctl 维护等待队列，再调用 epoll_wait 阻塞进程。显而易见的，效率就能得到提升。</p><p>　　如下的代码中，先用 epoll_create 创建一个 epoll 对象 epfd，再通过 epoll_ctl 将需要监视的 socket 添加到 epfd 中，最后调用 epoll_wait 等待数据。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-keyword">int</span> epfd = epoll_create(...);<br>epoll_ctl(epfd, ...); <span class="hljs-comment">//将所有需要监听的socket添加到epfd中</span><br><span class="hljs-keyword">while</span>(<span class="hljs-number">1</span>)&#123;<br>    <span class="hljs-keyword">int</span> n = epoll_wait(...)<br>    <span class="hljs-keyword">for</span>(接收到数据的socket)&#123;<br>        <span class="hljs-comment">//处理</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　措施二：就绪列表</p><p>　　select 低效的另一个原因在于程序不知道哪些 socket 收到数据，只能一个个遍历。如果内核维护一个“就绪列表”，引用收到数据的 socket，就能避免遍历。</p><h4 id="5-6-epoll的原理和流程"><a href="#5-6-epoll的原理和流程" class="headerlink" title="5.6 epoll的原理和流程"></a>5.6 epoll的原理和流程</h4><p>　　当某个进程调用 epoll_create 方法时，内核会创建一个 eventpoll 对象（也就是程序中 epfd 所代表的对象）。eventpoll 对象也是文件系统中的一员，和 socket 一样，它也会有等待队列。</p><p>　　创建 epoll 对象后，可以用 epoll_ctl 添加或删除所要监听的 socket。以添加 socket 为例，如下图，如果通过 epoll_ctl 添加 sock1、sock2 和 sock3 的监视，内核会将 eventpoll 添加到这三个 socket 的等待队列中。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051606421.png" style="zoom:67%;" /></center><p>　　当 socket 收到数据后，中断程序会操作 eventpoll 对象，而不是直接操作进程。中断程序会给 eventpoll 的“就绪列表”添加 socket 引用。如下图展示的是 sock2 和 sock3 收到数据后，中断程序让 rdlist 引用这两个 socket。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051608264.png" style="zoom:67%;" /></center><p>　　eventpoll 对象相当于是 socket 和进程之间的中介，socket 的数据接收并不直接影响进程，而是通过改变 eventpoll 的就绪列表来改变进程状态。</p><p>　　当程序执行到 epoll_wait 时，如果 rdlist 已经引用了socket，那么 epoll_wait 直接返回，如果 rdlist 为空，阻塞进程。</p><p>　　假设计算机中正在运行进程 A 和进程 B，在某时刻进程 A 运行到了epoll_wait语句。如下图所示，内核会将进程 A 放入 eventpoll 的等待队列中，阻塞进程。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051610330.png" style="zoom:67%;" /></center><p>　　当 socket 接收到数据，中断程序一方面修改 rdlist，另一方面唤醒 eventpoll 等待队列中的进程，进程 A 再次进入运行状态。也因为 rdlist 的存在，进程 A 可以知道哪些 socket 发生了变化。</p><h4 id="5-7-epoll的实现细节"><a href="#5-7-epoll的实现细节" class="headerlink" title="5.7 epoll的实现细节"></a>5.7 epoll的实现细节</h4><p>　　现在对 epoll 的本质已经有一定的了解。但我们还留有一个问题，eventpoll 的数据结构是什么样子？</p><p>　　就绪队列应该应使用什么数据结构？eventpoll 应使用什么数据结构来管理通过 epoll_ctl 添加或删除的 socket？</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310051619847.png"></p><p>　　就绪列表引用着就绪的 socket，所以它应能够快速的插入数据。程序可能随时调用 epoll_ctl 添加监视 socket，也可能随时删除。当删除时，若该 socket 已经存放在就绪列表中，它也应该被移除，所以就绪列表应是一种能够快速插入和删除的数据结构。epoll 使用双向链表来实现就绪队列（即 rdllist）。</p><p>　　既然 epoll 将“维护监视队列”和“进程阻塞”分离，也意味着需要有个数据结构来保存监视的 socket。至少要方便的添加和移除，还要便于搜索，以避免重复添加。红黑树是一种自平衡二叉查找树，搜索、插入和删除时间复杂度都是O(log(N))，效率较好。epoll 使用了红黑树作为索引结构（即 rb_root_cached）。</p><h4 id="5-8总结"><a href="#5-8总结" class="headerlink" title="5.8总结"></a>5.8总结</h4><p>　　当某一进程调用 epoll_create 方法时，Linux  内核会创建一个 eventpoll 结构体，在内核 cache 里建了个红黑树用于存储以后 epoll_ctl 传来的 socket 外，还会再建立一个 rdllist 双向链表，用于存储准备就绪的事件，当 epoll_wait 调用时，仅仅观察这个 rdllist 双向链表里有没有数据即可。有数据就返回，没有数据就 sleep，等到 timeout 时间到后即使链表没数据也返回。</p><p>　　同时，所有添加到 epoll 中的事件都会与设备(如网卡)驱动程序建立回调关系，也就是说相应事件的发生时会调用这里的回调方法。这个回调方法在内核中叫做 ep_poll_callback，它会把这样的事件放到上面的 rdllist 双向链表中。</p><p>　　当调用 epoll_wait 检查是否有发生事件的连接时，只是检查 eventpoll 对象中的 rdllist 双向链表是否有 epitem 元素而已，如果 rdllist 链表不为空，则这里的事件复制到用户态内存（使用共享内存提高效率）中，同时将事件数量返回给用户。因此 epoll_waitx 效率非常高，可以轻易地处理百万级别的并发连接。</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Netty——BIO、NIO</title>
    <link href="/2023/10/03/Netty%E2%80%94%E2%80%94BIO%E3%80%81NIO/"/>
    <url>/2023/10/03/Netty%E2%80%94%E2%80%94BIO%E3%80%81NIO/</url>
    
    <content type="html"><![CDATA[<h3 id="1-BIO"><a href="#1-BIO" class="headerlink" title="1. BIO"></a>1. BIO</h3><p>在 BIO 中 ServerSocket 类负责绑定 IP 地址，启动监听端口，等待客户连接；客户端 Socket 类的实例发起连接操作，ServerSocket 接受连接后产生一个新的服务端 socket 实例负责和客户端 socket 实例通过输入和输出流进行通信。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310031809953.png" style="zoom:50%;" /></center><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerSingle</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket();<br>        serverSocket.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8888</span>));<br>        System.out.println(<span class="hljs-string">&quot;Start Server ....&quot;</span>);<br>        <span class="hljs-keyword">int</span> connectCount = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                Socket socket = serverSocket.accept();<br>                System.out.println(<span class="hljs-string">&quot;accept client socket ....total =&quot;</span> + (++connectCount));<br>                <span class="hljs-keyword">try</span> (ObjectInputStream inputStream = <span class="hljs-keyword">new</span> ObjectInputStream(socket.getInputStream());<br>                     ObjectOutputStream outputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(socket.getOutputStream())) &#123;<br><br>                    String input = inputStream.readUTF();<br>                    System.out.println(<span class="hljs-string">&quot;Accept client message:&quot;</span> + input);<br>                    outputStream.writeUTF(<span class="hljs-string">&quot;Hello,&quot;</span> + input);<br>                    outputStream.flush();<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125; <span class="hljs-keyword">finally</span> &#123;<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        socket.close();<br>                    &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                        e.printStackTrace();<br>                    &#125;<br>                &#125;<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            serverSocket.close();<br>        &#125;<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>客户端：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Client</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        Socket socket = <span class="hljs-keyword">null</span>;<br>        ObjectOutputStream output = <span class="hljs-keyword">null</span>;<br>        ObjectInputStream input = <span class="hljs-keyword">null</span>;<br>        InetSocketAddress addr = <span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-string">&quot;127.0.0.1&quot;</span>, <span class="hljs-number">8888</span>);<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            socket = <span class="hljs-keyword">new</span> Socket();<br>            socket.connect(addr);<br>            System.out.println(<span class="hljs-string">&quot;Connect Server success!!&quot;</span>);<br>            output = <span class="hljs-keyword">new</span> ObjectOutputStream(socket.getOutputStream());<br>            input = <span class="hljs-keyword">new</span> ObjectInputStream(socket.getInputStream());<br>            System.out.println(<span class="hljs-string">&quot;Ready send message.....&quot;</span>);<br>            <br>            output.writeUTF(<span class="hljs-string">&quot;debug&quot;</span>);<br>            output.flush();<br>            System.out.println(input.readUTF());<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (socket != <span class="hljs-keyword">null</span>) socket.close();<br>            <span class="hljs-keyword">if</span> (output != <span class="hljs-keyword">null</span>) output.close();<br>            <span class="hljs-keyword">if</span> (input != <span class="hljs-keyword">null</span>) input.close();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>BIO 的阻塞，主要体现在两个地方：</p><ol><li>若一个服务器启动就绪，那么主线程就一直在等待着客户端的连接，这个等待过程中主线程就一直在阻塞。</li><li>在连接建立之后，在读取到 socket 信息之前，线程也是一直在等待，一直处于阻塞的状态下的。</li></ol><p>所以在 BIO 通信里，我们往往会在服务器的实现上结合线程来处理连接以及和客户端的通信。</p><p>传统 BIO 通信模型：采用 BIO 通信模型的服务端，通常由一个独立的 Acceptor 线程负责监听客户端的连接，它接收到客户端连接请求之后为每个客户端创建一个新的线程进行链路处理，处理完成后，通过输出流返回应答给客户端，线程销毁。即典型的一请求一应答模型，同时数据的读取写入也必须阻塞在一个线程内等待其完成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Server</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket();<br>        serverSocket.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8888</span>));<br>        System.out.println(<span class="hljs-string">&quot;Start Server ....&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> ServerTask(serverSocket.accept())).start();<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            serverSocket.close();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> Socket socket = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServerTask</span><span class="hljs-params">(Socket socket)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.socket = socket;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> (ObjectInputStream inputStream = <span class="hljs-keyword">new</span> ObjectInputStream(socket.getInputStream());<br>                 ObjectOutputStream outputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(socket.getOutputStream())) &#123;<br><br>                String input = inputStream.readUTF();<br>                System.out.println(<span class="hljs-string">&quot;Accept client message:&quot;</span> + input);<br>                outputStream.writeUTF(<span class="hljs-string">&quot;Hello,&quot;</span> + input);<br>                outputStream.flush();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    socket.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>该模型最大的问题就是缺乏弹性伸缩能力，当客户端并发访问量增加后，服务端的线程个数和客户端并发访问数呈1:1的正比关系，Java中的线程也是比较宝贵的系统资源，线程数量快速膨胀后，系统的性能将急剧下降，随着访问量的继续增大，系统最终就<strong>死-掉-了</strong>。</p><p>为了改进这种一连接一线程的模型，我们可以使用线程池来管理这些线程，实现1个或多个线程处理N个客户端的模型（但是底层还是使用的同步阻塞I/O），通常被称为“伪异步I/O模型“。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerPool</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ExecutorService executorService = Executors.newFixedThreadPool(Runtime.getRuntime().availableProcessors());<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        ServerSocket serverSocket = <span class="hljs-keyword">new</span> ServerSocket();<br>        serverSocket.bind(<span class="hljs-keyword">new</span> InetSocketAddress(<span class="hljs-number">8888</span>));<br>        System.out.println(<span class="hljs-string">&quot;Start Server ....&quot;</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">while</span> (<span class="hljs-keyword">true</span>) &#123;<br>                executorService.execute(<span class="hljs-keyword">new</span> ServerTask(serverSocket.accept()));<br>            &#125;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            serverSocket.close();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServerTask</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>        <span class="hljs-keyword">private</span> Socket socket = <span class="hljs-keyword">null</span>;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ServerTask</span><span class="hljs-params">(Socket socket)</span> </span>&#123;<br>            <span class="hljs-keyword">this</span>.socket = socket;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>            <span class="hljs-keyword">try</span> (ObjectInputStream inputStream = <span class="hljs-keyword">new</span> ObjectInputStream(socket.getInputStream());<br>                 ObjectOutputStream outputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(socket.getOutputStream())) &#123;<br><br>                String input = inputStream.readUTF();<br>                System.out.println(<span class="hljs-string">&quot;Accept client message:&quot;</span> + input);<br>                outputStream.writeUTF(<span class="hljs-string">&quot;Hello,&quot;</span> + input);<br>                outputStream.flush();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125; <span class="hljs-keyword">finally</span> &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    socket.close();<br>                &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如果使用 CachedThreadPool 线程池，其实除了能自动帮我们管理线程（复用），看起来也就像是1:1的客户端：线程数模型，而使用FixedThreadPool 我们就有效的控制了线程的最大数量，保证了系统有限的资源的控制，实现了N:M的伪异步 I/O 模型。</p><h3 id="2-NIO"><a href="#2-NIO" class="headerlink" title="2.NIO"></a>2.NIO</h3><p>NIO 库是在 JDK 1.4 中引入的。NIO 弥补了原来的 BIO 的不足，它在标准 Java 代码中提供了高速的、面向块的 I/O。</p><h4 id="2-1-和-BIO-的主要区别"><a href="#2-1-和-BIO-的主要区别" class="headerlink" title="2.1 和 BIO 的主要区别"></a>2.1 和 BIO 的主要区别</h4><p><strong>面向流与面向缓冲</strong></p><p>Java NIO 和 IO 之间第一个最大的区别是，IO 是面向流的，NIO 是面向缓冲区的。 Java IO 面向流意味着每次从流中读一个或多个字节，直至读取所有字节，它们没有被缓存在任何地方。此外，它不能前后移动流中的数据。如果需要前后移动从流中读取的数据，需要先将它缓存到一个缓冲区。 Java NIO 的缓冲导向方法略有不同。数据读取到一个它稍后处理的缓冲区，需要时可在缓冲区中前后移动。这就增加了处理过程中的灵活性。但是，还需要检查是否该缓冲区中包含所有需要处理的数据。而且，需确保当更多的数据读入缓冲区时，不要覆盖缓冲区里尚未处理的数据。</p><p><strong>阻塞与非阻塞 IO</strong></p><p>Java IO 的各种流是阻塞的。这意味着，当一个线程调用 read() 或 write() 时，该线程被阻塞，直到有一些数据被读取或完全写入。该线程在此期间不能再干任何事情了。</p><p> Java NIO 的非阻塞模式，使一个线程从某通道发送请求读取数据，但是它仅能得到目前可用的数据，如果目前没有数据可用时，就什么都不会获取。而不是保持线程阻塞，所以直至数据变的可以读取之前，该线程可以继续做其他的事情。 非阻塞写也是如此。一个线程请求写入一些数据到某通道，但不需要等待它完全写入，这个线程同时可以去做别的事情。 线程通常将非阻塞 IO 的空闲时间用于在其它通道上执行 IO 操作，所以一个单独的线程现在可以管理多个输入和输出通道（channel）。</p><h4 id="2-2-NIO-三大核心组件"><a href="#2-2-NIO-三大核心组件" class="headerlink" title="2.2 NIO 三大核心组件"></a>2.2 NIO 三大核心组件</h4><p>NIO 三大核心组件：Selector 选择器、Channel 管道、buffer 缓冲区。</p><p><strong>Selector</strong></p><p>Java NIO 的选择器允许一个单独的线程来监视多个输入通道，可以注册多个通道使用一个选择器(Selectors)，然后使用一个单独的线程来操作这个选择器，进而“选择”通道：通道里已经有可以处理的输入，或者选择已准备写入的通道。</p><p>应用程序将向 Selector 对象注册需要它关注的 Channel，以及具体的某一个 Channel 会对哪些 IO 事件感兴趣。Selector 中也会维护一个“已经注册的 Channel ”的容器。</p><p><strong>Channels</strong></p><p>通道，被建立的一个应用程序和操作系统交互事件、传递内容的渠道（注意是连接到操作系统）。那么既然是和操作系统进行内容的传递，那么说明应用程序可以通过通道读取数据，也可以通过通道向操作系统写数据，而且可以同时进行读写。</p><ul><li>所有被 Selector（选择器）注册的通道，只能是继承了 SelectableChannel 类的子类。</li><li>ServerSocketChannel：应用服务器程序的监听通道。只有通过这个通道，应用程序才能向操作系统注册支持“多路复用 IO”的端口监听。同时支持 UDP 协议和 TCP 协议。</li><li>ScoketChannel：TCP Socket 套接字的监听通道，一个 Socket 套接字对应了一个客户端IP:端口 到 服务器IP:端口 的通信连接。</li></ul><p>通道中的数据总是要先读到一个 Buffer，或者总是要从一个 Buffer 中写入。</p><p><strong>buffer 缓冲区</strong></p><p>JDK NIO 是面向缓冲的。Buffer 就是这个缓冲，用于和 NIO 通道进行交互。数据是从通道读入缓冲区，从缓冲区写入到通道中的。以写为例，应用程序都是将数据写入缓冲，再通过通道把缓冲的数据发送出去，读也是一样，数据总是先从通道读到缓冲，应用程序再读缓冲的数据。</p><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存（其实就是数组）。这块内存被包装成 NIO Buffer 对象，并提供了一组方法，用来方便的访问该块内存。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310032157431.png"></p><h4 id="2-3-示例"><a href="#2-3-示例" class="headerlink" title="2.3 示例"></a>2.3 示例</h4><p><strong>服务端：</strong></p><p>NioServer</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioServer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        NioServerHandle nioServerHandle = <span class="hljs-keyword">new</span> NioServerHandle(DEFAULT_PORT);<br>        <span class="hljs-keyword">new</span> Thread(nioServerHandle, <span class="hljs-string">&quot;Server&quot;</span>).start();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>NioServerHandle</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioServerHandle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> started;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 构造方法</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> port 指定要监听的端口号</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioServerHandle</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">/*创建选择器的实例*/</span><br>            selector = Selector.open();<br>            <span class="hljs-comment">/*创建ServerSocketChannel的实例*/</span><br>            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<br>            <span class="hljs-comment">/*设置通道为非阻塞模式*/</span><br>            serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>            <span class="hljs-comment">/*绑定端口*/</span><br>            serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> InetSocketAddress(port));<br>            <span class="hljs-comment">/*注册事件，表示关心客户端连接*/</span><br>            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<br><br>            started = <span class="hljs-keyword">true</span>;<br>            System.out.println(<span class="hljs-string">&quot;服务器已启动，端口号：&quot;</span> + port);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (started) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">/*获取当前有哪些事件*/</span><br>                selector.select(<span class="hljs-number">1000</span>);<br>                <span class="hljs-comment">/*获取事件的集合*/</span><br>                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>                Iterator&lt;SelectionKey&gt; iterator = selectionKeys.iterator();<br>                <span class="hljs-keyword">while</span> (iterator.hasNext()) &#123;<br>                    SelectionKey key = iterator.next();<br>                    <span class="hljs-comment">/*我们必须首先将处理过的 SelectionKey 从选定的键集合中删除。</span><br><span class="hljs-comment">                    如果我们没有删除处理过的键，那么它仍然会在主集合中以一个激活</span><br><span class="hljs-comment">                    的键出现，这会导致我们尝试再次处理它。*/</span><br>                    iterator.remove();<br>                    handleInput(key);<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*处理事件的发生*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleInput</span><span class="hljs-params">(SelectionKey selectionKey)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (selectionKey.isValid()) &#123;<br>            <span class="hljs-comment">/*处理新接入的客户端的请求*/</span><br>            <span class="hljs-keyword">if</span> (selectionKey.isAcceptable()) &#123;<br>                <span class="hljs-comment">/*获取关心当前事件的Channel*/</span><br>                ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.channel();<br>                <span class="hljs-comment">/*接受连接*/</span><br>                SocketChannel socketChannel = serverSocketChannel.accept();<br>                System.out.println(<span class="hljs-string">&quot;==========建立连接=========&quot;</span>);<br>                socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>                <span class="hljs-comment">/*关注读事件*/</span><br>                socketChannel.register(selector, SelectionKey.OP_READ);<br>            &#125;<br>            <span class="hljs-comment">/*处理对端的发送的数据*/</span><br>            <span class="hljs-keyword">if</span> (selectionKey.isReadable()) &#123;<br>                SocketChannel socketChannel = (SocketChannel) selectionKey.channel();<br>                <span class="hljs-comment">/*创建ByteBuffer，开辟一个缓冲区*/</span><br>                ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                <span class="hljs-comment">/*从通道里读取数据，然后写入buffer*/</span><br>                <span class="hljs-keyword">int</span> readBytes = socketChannel.read(buffer);<br>                <span class="hljs-keyword">if</span> (readBytes &gt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">/*将缓冲区当前的limit设置为position,position=0，</span><br><span class="hljs-comment">                    用于后续对缓冲区的读取操作*/</span><br>                    buffer.flip();<br>                    <span class="hljs-comment">/*根据缓冲区可读字节数创建字节数组*/</span><br>                    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buffer.remaining()];<br>                    <span class="hljs-comment">/*将缓冲区可读字节数组复制到新建的数组中*/</span><br>                    buffer.get(bytes);<br>                    String message = <span class="hljs-keyword">new</span> String(bytes, StandardCharsets.UTF_8);<br>                    System.out.println(<span class="hljs-string">&quot;服务器收到消息：&quot;</span> + message);<br>                    <span class="hljs-comment">/*处理数据*/</span><br>                    String result = Const.response(message);<br>                    <span class="hljs-comment">/*发送应答消息*/</span><br>                    doWrite(socketChannel, result);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readBytes &lt; <span class="hljs-number">0</span>) &#123;<br>                    <span class="hljs-comment">/*取消特定的注册关系*/</span><br>                    selectionKey.cancel();<br>                    <span class="hljs-comment">/*关闭通道*/</span><br>                    socketChannel.close();<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/*发送应答消息*/</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(SocketChannel sc, String response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] bytes = response.getBytes();<br>        ByteBuffer buffer = ByteBuffer.allocate(bytes.length);<br>        buffer.put(bytes);<br>        buffer.flip();<br>        sc.write(buffer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        started = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端：</strong></p><p> NioClient</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioClient</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> NioClientHandle nioClientHandle;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>        nioClientHandle = <span class="hljs-keyword">new</span> NioClientHandle(DEFAULT_SERVER_IP, DEFAULT_PORT);<br>        <span class="hljs-keyword">new</span> Thread(nioClientHandle, <span class="hljs-string">&quot;client&quot;</span>).start();<br>    &#125;<br><br>    <span class="hljs-comment">//向服务器发送消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        nioClientHandle.sendMsg(msg);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        start();<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        <span class="hljs-keyword">while</span> (NioClient.sendMsg(scanner.next())) ;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>NioClientHandle</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioClientHandle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String host;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> port;<br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> SocketChannel socketChannel;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> started;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioClientHandle</span><span class="hljs-params">(String ip, <span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.host = ip;<br>        <span class="hljs-keyword">this</span>.port = port;<br><br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">/*创建选择器的实例*/</span><br>            selector = Selector.open();<br>            <span class="hljs-comment">/*创建SocketChannel的实例*/</span><br>            socketChannel = SocketChannel.open();<br>            <span class="hljs-comment">/*设置通道为非阻塞模式*/</span><br>            socketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<br>            started = <span class="hljs-keyword">true</span>;<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            doConnect();<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            System.exit(<span class="hljs-number">1</span>);<br>        &#125;<br><br>        <span class="hljs-comment">//循环遍历selector</span><br>        <span class="hljs-keyword">while</span> (started) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//无论是否有读写事件发生，selector每隔1s被唤醒一次</span><br>                selector.select(<span class="hljs-number">1000</span>);<br>                <span class="hljs-comment">//获取当前有哪些事件可以使用</span><br>                Set&lt;SelectionKey&gt; keys = selector.selectedKeys();<br>                Iterator&lt;SelectionKey&gt; selectionKeyIterator = keys.iterator();<br>                SelectionKey selectionKey;<br>                <span class="hljs-keyword">while</span> (selectionKeyIterator.hasNext()) &#123;<br>                    selectionKey = selectionKeyIterator.next();<br>                    selectionKeyIterator.remove();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        handleInput(selectionKey);<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        <span class="hljs-keyword">if</span> (selectionKey != <span class="hljs-keyword">null</span>) &#123;<br>                            selectionKey.cancel();<br>                            <span class="hljs-keyword">if</span> (selectionKey.channel() != <span class="hljs-keyword">null</span>) &#123;<br>                                selectionKey.channel().close();<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>                System.exit(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//selector关闭后会自动释放里面管理的资源</span><br>        <span class="hljs-keyword">if</span> (selector != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">try</span> &#123;<br>                selector.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//具体的事件处理方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleInput</span><span class="hljs-params">(SelectionKey key)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">if</span> (!key.isValid()) &#123;<br>            <span class="hljs-keyword">return</span>;<br>        &#125;<br>        <span class="hljs-comment">//获得关心当前事件的channel</span><br>        SocketChannel socketChannel = (SocketChannel) key.channel();<br>        <span class="hljs-comment">//连接事件</span><br>        <span class="hljs-keyword">if</span> (key.isConnectable()) &#123;<br>            <span class="hljs-keyword">if</span> (socketChannel.finishConnect()) &#123;<br>                <span class="hljs-keyword">this</span>.socketChannel.register(selector, SelectionKey.OP_READ);<br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                System.exit(<span class="hljs-number">1</span>);<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//有数据可读事件</span><br>        <span class="hljs-keyword">if</span> (key.isReadable()) &#123;<br>            ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>            <span class="hljs-keyword">int</span> readBytes = socketChannel.read(buffer);<br>            <span class="hljs-keyword">if</span> (readBytes &gt; <span class="hljs-number">0</span>) &#123;<br>                buffer.flip();<br>                <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buffer.remaining()];<br>                buffer.get(bytes);<br>                String result = <span class="hljs-keyword">new</span> String(bytes, StandardCharsets.UTF_8);<br>                System.out.println(<span class="hljs-string">&quot;客户端收到消息：&quot;</span> + result);<br>            &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readBytes &lt; <span class="hljs-number">0</span>) &#123;<br>                key.cancel();<br>                socketChannel.close();<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(SocketChannel channel, String request)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] bytes = request.getBytes();<br>        ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);<br>        writeBuffer.put(bytes);<br>        writeBuffer.flip();<br>        <span class="hljs-comment">/*关心事件和读写网络并不冲突*/</span><br>        channel.write(writeBuffer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doConnect</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-comment">/*非阻塞的连接*/</span><br>        <span class="hljs-keyword">if</span> (socketChannel.connect(<span class="hljs-keyword">new</span> InetSocketAddress(host, port))) &#123;<br>            socketChannel.register(selector, SelectionKey.OP_READ);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            socketChannel.register(selector, SelectionKey.OP_CONNECT);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//写数据对外暴露的API</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sendMsg</span><span class="hljs-params">(String msg)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        doWrite(socketChannel, msg);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        started = <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-SelectionKey"><a href="#2-4-SelectionKey" class="headerlink" title="2.4 SelectionKey"></a>2.4 SelectionKey</h4><p>SelectionKey 是一个抽象类，表示 selectableChannel 在 Selector 中注册的标识。每个 Channel 向 Selector 注册时，都将会创建一个 SelectionKey。SelectionKey 将 Channel 与 Selector 建立了关系，并维护了 channel 事件。</p><p>可以通过 cancel 方法取消键，取消的键不会立即从 selector 中移除，而是添加到 cancelledKeys 中,在下一次 select 操作时移除它。所以在调用某个 key 时，需要使用 isValid 进行校验。</p><p><strong>SelectionKey 类型和就绪条件：</strong></p><p>在向 Selector 对象注册感兴趣的事件时，JAVA NIO 共定义了四种：OP_READ、OP_WRITE、OP_CONNECT、OP_ACCEPT（定义在 SelectionKey 中），分别对应读、写、请求连接、接受连接等网络 Socket 操作。</p><table><thead><tr><th><strong>操作类型</strong></th><th><strong>就绪条件及说明</strong></th></tr></thead><tbody><tr><td>OP_READ</td><td>当操作系统读缓冲区有数据可读时就绪。并非时刻都有数据可读，所以一般需要注册该操作，仅当有就绪时才发起读操作，有的放矢，避免浪费CPU。</td></tr><tr><td>OP_WRITE</td><td>当操作系统写缓冲区有空闲空间时就绪。一般情况下写缓冲区都有空闲空间，小块数据直接写入即可，没必要注册该操作类型，否则该条件不断就绪浪费CPU；但如果是写密集型的任务，比如文件下载等，缓冲区很可能满，注册该操作类型就很有必要，同时注意写完后取消注册。</td></tr><tr><td>OP_CONNECT</td><td>当SocketChannel.connect()请求连接成功后就绪。该操作只给客户端使用。</td></tr><tr><td>OP_ACCEPT</td><td>当接收到一个客户端连接请求时就绪。该操作只给服务器使用。</td></tr></tbody></table><p><strong>服务端和客户端分别感兴趣的类型：</strong></p><p>ServerSocketChannel 和 SocketChannel 可以注册自己感兴趣的操作类型，当对应操作类型的就绪条件满足时 OS 会通知 channel，下表描述各种 Channel 允许注册的操作类型，Y 表示允许注册，N 表示不允许注册，其中服务器 SocketChannel 指由服务器ServerSocketChannel.accept() 返回的对象。</p><table><thead><tr><th></th><th>OP_READ</th><th>OP_WRITE</th><th>OP_CONNECT</th><th>OP_ACCEPT</th></tr></thead><tbody><tr><td>服务器ServerSocketChannel</td><td></td><td></td><td></td><td><strong>Y</strong></td></tr><tr><td>服务器 SocketChannel</td><td><strong>Y</strong></td><td><strong>Y</strong></td><td></td><td></td></tr><tr><td>客户端SocketChannel</td><td><strong>Y</strong></td><td><strong>Y</strong></td><td><strong>Y</strong></td><td></td></tr></tbody></table><p>服务器启动 ServerSocketChannel，关注 OP_ACCEPT 事件。</p><p>客户端启动 SocketChannel，连接服务器，关注 OP_CONNECT事件</p><p>服务器接受连接，启动一个服务器的 SocketChannel，这个 SocketChannel 可以关注 OP_READ、OP_WRITE 事件，一般连接建立后会直接关注 OP_READ 事件</p><p>客户端 SocketChannel 发现连接建立后，可以关注 OP_READ、OP_WRITE 事件。</p><h4 id="2-5-写事件监听示例"><a href="#2-5-写事件监听示例" class="headerlink" title="2.5 写事件监听示例"></a>2.5 写事件监听示例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NioServerHandleWriteable</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Selector selector;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">boolean</span> started;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">NioServerHandleWriteable</span><span class="hljs-params">(<span class="hljs-keyword">int</span> port)</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            selector = Selector.open();<br>            ServerSocketChannel serverSocketChannel = ServerSocketChannel.open();<br>            serverSocketChannel.configureBlocking(<span class="hljs-keyword">false</span>);<span class="hljs-comment">//开启非阻塞模式</span><br>            serverSocketChannel.socket().bind(<span class="hljs-keyword">new</span> InetSocketAddress(port), <span class="hljs-number">1024</span>);<br>            serverSocketChannel.register(selector, SelectionKey.OP_ACCEPT);<br>            started = <span class="hljs-keyword">true</span>;<br>            System.out.println(<span class="hljs-string">&quot;服务器已启动，端口号：&quot;</span> + port);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>            System.exit(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">while</span> (started) &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">//阻塞,只有当至少一个注册的事件发生的时候才会继续.</span><br>                selector.select();<br>                Set&lt;SelectionKey&gt; selectionKeys = selector.selectedKeys();<br>                Iterator&lt;SelectionKey&gt; selectionKeyIterator = selectionKeys.iterator();<br>                SelectionKey selectionKey = <span class="hljs-keyword">null</span>;<br>                <span class="hljs-keyword">while</span> (selectionKeyIterator.hasNext()) &#123;<br>                    selectionKey = selectionKeyIterator.next();<br>                    selectionKeyIterator.remove();<br>                    <span class="hljs-keyword">try</span> &#123;<br>                        handleInput(selectionKey);<br>                    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                        <span class="hljs-keyword">if</span> (selectionKey != <span class="hljs-keyword">null</span>) &#123;<br>                            selectionKey.cancel();<br>                            <span class="hljs-keyword">if</span> (selectionKey.channel() != <span class="hljs-keyword">null</span>) &#123;<br>                                selectionKey.channel().close();<br>                            &#125;<br>                        &#125;<br>                    &#125;<br>                &#125;<br>            &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>                t.printStackTrace();<br>            &#125;<br>        &#125;<br>        <span class="hljs-comment">//selector关闭后会自动释放里面管理的资源</span><br>        <span class="hljs-keyword">if</span> (selector != <span class="hljs-keyword">null</span>)<br>            <span class="hljs-keyword">try</span> &#123;<br>                selector.close();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleInput</span><span class="hljs-params">(SelectionKey selectionKey)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;当前通道的事件：&quot;</span> + selectionKey.interestOps());<br>        <span class="hljs-keyword">if</span> (selectionKey.isValid()) &#123;<br>            <span class="hljs-keyword">if</span> (selectionKey.isAcceptable()) &#123;<br>                ServerSocketChannel serverSocketChannel = (ServerSocketChannel) selectionKey.channel();<br>                <span class="hljs-comment">//通过ServerSocketChannel的accept创建SocketChannel实例</span><br>                <span class="hljs-comment">//完成该操作意味着完成TCP三次握手，TCP物理链路正式建立</span><br>                SocketChannel sc = serverSocketChannel.accept();<br>                System.out.println(<span class="hljs-string">&quot;======socket channel 建立连接=======&quot;</span>);<br>                <span class="hljs-comment">//设置为非阻塞的</span><br>                sc.configureBlocking(<span class="hljs-keyword">false</span>);<br>                <span class="hljs-comment">//连接已经完成了，可以开始关心读事件了</span><br>                sc.register(selector, SelectionKey.OP_READ);<br>            &#125;<br>            <span class="hljs-keyword">if</span> (selectionKey.isReadable()) &#123;<br>                System.out.println(<span class="hljs-string">&quot;======socket channel 数据准备完成，可以去读取=======&quot;</span>);<br>                SocketChannel socketChannel = (SocketChannel) selectionKey.channel();<br>                ByteBuffer buffer = ByteBuffer.allocate(<span class="hljs-number">1024</span>);<br>                <span class="hljs-keyword">int</span> readBytes = socketChannel.read(buffer);<br>                <span class="hljs-keyword">if</span> (readBytes &gt; <span class="hljs-number">0</span>) &#123;<br>                    buffer.flip();<br>                    <span class="hljs-keyword">byte</span>[] bytes = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[buffer.remaining()];<br>                    buffer.get(bytes);<br>                    String message = <span class="hljs-keyword">new</span> String(bytes, StandardCharsets.UTF_8);<br>                    System.out.println(<span class="hljs-string">&quot;服务器收到消息：&quot;</span> + message);<br>                    String result = response(message);<br>                    doWrite(socketChannel, result);<br>                &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (readBytes &lt; <span class="hljs-number">0</span>) &#123;<br>                    selectionKey.cancel();<br>                    socketChannel.close();<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">if</span> (selectionKey.isWritable()) &#123;<br>                SocketChannel socketChannel = (SocketChannel) selectionKey.channel();<br>                ByteBuffer buffer = (ByteBuffer) selectionKey.attachment();<br>                <span class="hljs-keyword">if</span> (buffer.hasRemaining()) &#123;<br>                    <span class="hljs-keyword">int</span> count = socketChannel.write(buffer);<br>                    System.out.println(<span class="hljs-string">&quot;write :&quot;</span> + count + <span class="hljs-string">&quot;byte, remaining:&quot;</span> + buffer.hasRemaining());<br>                &#125; <span class="hljs-keyword">else</span> &#123;<br>                    <span class="hljs-comment">/*取消对写的注册*/</span><br>                    selectionKey.interestOps(SelectionKey.OP_READ);<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">//发送应答消息</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doWrite</span><span class="hljs-params">(SocketChannel channel, String response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        <span class="hljs-keyword">byte</span>[] bytes = response.getBytes();<br>        ByteBuffer writeBuffer = ByteBuffer.allocate(bytes.length);<br>        writeBuffer.put(bytes);<br>        writeBuffer.flip();<br>        channel.register(selector, SelectionKey.OP_WRITE | SelectionKey.OP_READ, writeBuffer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        started = <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>写操作完成之后需要取消OP_WRITE的注册。</p><h4 id="2-6-Buffer"><a href="#2-6-Buffer" class="headerlink" title="2.6 Buffer"></a>2.6 Buffer</h4><h5 id="1-重要属性"><a href="#1-重要属性" class="headerlink" title="1. 重要属性"></a>1. 重要属性</h5><p><strong>capacity</strong></p><p>作为一个内存块，Buffer 有一个固定的大小值，也叫“capacity”。你只能往里写 capacity 个 byte、long，char 等类型。一旦 Buffer 满了，需要将其清空（通过读数据或者清除数据）才能继续写数据往里写数据。</p><p><strong>position</strong></p><p>当你写数据到 Buffer 中时，position 表示当前能写的位置。初始的 position 值为 0。当一个 byte、long 等数据写到 Buffer 后， position 会向前移动到下一个可插入数据的 Buffer 单元。position 最大可为 capacity – 1.</p><p>当读取数据时，也是从某个特定位置读。当将 Buffer 从写模式切换到读模式，position 会被重置为 0。当从 Buffer 的 position 处读取数据时，position 向前移动到下一个可读的位置。 </p><p><strong>limit</strong></p><p>在写模式下，Buffer 的 limit 表示你最多能往 Buffer 里写多少数据。 写模式下，limit 等于 Buffer 的 capacity。当切换 Buffer 到读模式时， limit 表示你最多能读到多少数据。因此，当切换 Buffer 到读模式时，limit 会被设置成写模式下的  position值。</p><h5 id="2-Buffer的分配"><a href="#2-Buffer的分配" class="headerlink" title="2. Buffer的分配"></a>2. Buffer的分配</h5><p>要想获得一个 Buffer 对象首先要进行分配。 每一个 Buffer 类都有 <strong>allocate</strong> 方法(可以在堆上分配，也可以在直接内存上分配)。</p><p>分配48字节 capacity 的 ByteBuffer 的例子: ByteBuffer buf = ByteBuffer.allocate(48);</p><p>分配一个可存储1024个字符的CharBuffer：CharBuffer buf = CharBuffer.allocate(1024);</p><p><strong>wrap方法</strong>：把一个 byte 数组或 byte 数组的一部分包装成 ByteBuffer：</p><p>ByteBuffer wrap(byte [] array)</p><p>ByteBuffer wrap(byte [] array, int offset, int length) </p><h5 id="3-直接内存"><a href="#3-直接内存" class="headerlink" title="3. 直接内存"></a>3. 直接内存</h5><p>HeapByteBuffer 与 DirectByteBuffer，在原理上，前者可以看出分配的 buffer 是在 heap 区域的，其实真正 flush 到远程的时候会先拷贝到直接内存，再做下一步操作；在 NIO 的框架下，很多框架会采用 DirectByteBuffer 来操作，这样分配的内存不再是在 java heap 上，经过性能测试，可以得到非常快速的网络交互，在大量的网络交互下，一般速度会比 HeapByteBuffer 要快速好几倍。</p><p>直接内存（Direct Memory）并不是虚拟机运行时数据区的一部分，也不是 Java 虚拟机规范中定义的内存区域，但是这部分内存也被频繁地使用，而且也可能导致 OutOfMemoryError 异常出现。 </p><p>NIO 可以使用 Native 函数库直接分配堆外内存，然后通过一个存储在 Java 堆里面的 DirectByteBuffer 对象作为这块内存的引用进行操作。这样能在一些场景中显著提高性能，因为避免了在 Java 堆和 Native 堆中来回复制数据。</p><p><strong>直接内存（堆外内存）与堆内存比较：</strong></p><p>直接内存申请空间耗费更高的性能，当频繁申请到一定量时尤为明显</p><p>直接内存 IO 读写的性能要优于普通的堆内存，在多次读写操作的情况下差异明显</p><h5 id="4-Buffer的读写"><a href="#4-Buffer的读写" class="headerlink" title="4. Buffer的读写"></a>4. Buffer的读写</h5><p><strong>向 Buffer 中写数据：</strong></p><ul><li>读取 Channel 写到 Buffer</li><li>通过 Buffer  的 put() 方法写到 Buffer 里</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 从Channel写到Buffer的例子</span><br><span class="hljs-keyword">int</span> readBytes = socketChannel.read(buffer);<br><span class="hljs-comment">//通过put方法写Buffer的例子：</span><br>buffer.put(bytes);<br></code></pre></td></tr></table></figure><p>put 方法有很多版本，允许你以不同的方式把数据写入到 Buffer 中。例如， 写到一个指定的位置，或者把一个字节数组写入到 Buffer。在比如：put(byte b)，向 position 的位置写入一个 byte，并将 postion+1，为下次读写作准备。</p><p><strong>flip()方法</strong></p><p>flip方法将 Buffer 从写模式切换到读模式。调用 flip() 方法会将 position 设回 0，并将 limit 设置成之前 position 的值。</p><p><strong>从 Buffer 中读取数据</strong></p><ol><li>从 Buffer 读取数据写入到 Channel</li><li>使用 get() 方法从 Buffer 中读取数据</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">socketChannel.write(writeBuffer);<br>buffer.get(bytes);<br></code></pre></td></tr></table></figure><p>get 方法有很多版本，允许你以不同的方式从 Buffer 中读取数据。例如，从指定 position 读取，或者从 Buffer 中读取数据到字节数组，再比如 get() 属于相对读，从 position 位置读取一个 byte，并将 position+1，为下次读写作准备;</p><p><strong>使用 Buffer 读写数据常见步骤：</strong></p><ol><li>写入数据到 Buffer</li><li>调用flip()方法</li><li>从 Buffer 中读取数据</li><li>调用 clear() 方法或者 compact() 方法，准备下一次的写入</li></ol><p>当向 buffer 写入数据时，buffer 会记录下写了多少数据。一旦要读取数据，需要通过 flip() 方法将 Buffer 从写模式切换到读模式。在读模式下，可以读取之前写入到 buffer 的所有数据。一旦读完了所有的数据，就需要清空缓冲区，让它可以再次被写入。有两种方式能清空缓冲区：调用 clear() 或 compact() 方法。clear() 方法会清空整个缓冲区。compact() 方法只会清除已经读过的数据。</p><h5 id="5-其他常用操作"><a href="#5-其他常用操作" class="headerlink" title="5. 其他常用操作"></a>5. 其他常用操作</h5><p><strong>绝对读写</strong></p><p>put(int index, byte b) 绝对写，向 byteBuffer 底层的 bytes 中下标为 index 的位置插入 byte b，不改变 position 的值。</p><p> get(int index) 属于绝对读，读取 byteBuffer 底层的 bytes 中下标为 index 的 byte，不改变 position。</p><p><strong>rewind()</strong></p><p>Buffer.rewind() 将 position 设回 0，所以你可以重读 Buffer 中的所有数据。limit 保持不变，仍然表示能从 Buffer 中读取多少个元素（byte、char等）。</p><p><strong>clear() 与 compact()</strong></p><p>一旦读完 Buffer 中的数据，需要让 Buffer 准备好再次被写入。可以通过 clear() 或 compact() 方法来完成。</p><p>如果调用的是 clear() 方法，position 将被设回 0，limit 被设置成 capacity 的值。换句话说，Buffer 被清空了。Buffer 中的数据并未清除，只是这些标记告诉我们可以从哪里开始往 Buffer 里写数据。compact() 方法将所有未读的数据拷贝到 Buffer 起始处。然后将 position 设到最后一个未读元素正后面。现在 Buffer 准备好写数据了，但是不会覆盖未读的数据。</p><p><strong>mark() 与 reset() 方法</strong></p><p>通过调用 Buffer.mark() 方法，可以标记 Buffer 中的一个特定 position。之后可以通过调用 Buffer.reset()  方法恢复到这个position。</p><p><strong>equals() 与 compareTo() 方法</strong></p><p>equals()：</p><p>当满足下列条件时，表示两个Buffer相等：</p><ol><li>有相同的类型（byte、char、int等）。</li><li>Buffer 中剩余的 byte、char 等的个数相等。</li><li>Buffer 中所有剩余的 byte、char 等都相同。</li></ol><p>compareTo()：</p><p>compareTo() 方法比较两个 Buffer 的剩余元素(byte、char等)， 如果满足下列条件，则认为一个 Buffer  “小于”另一个 Buffer：</p><ol><li>第一个不相等的元素小于另一个Buffer中对应的元素 。</li><li>所有元素都相等，但第一个 Buffer 比另一个先耗尽(第一个 Buffer 的元素个数比另一个少)。</li></ol><h5 id="6-Buffer方法总结"><a href="#6-Buffer方法总结" class="headerlink" title="6. Buffer方法总结"></a>6. Buffer方法总结</h5><table><thead><tr><th>limit(), limit(10)等</th><th>其中读取和设置这4个属性的方法的命名和jQuery中的val(),val(10)类似，一个负责get，一个负责set</th></tr></thead><tbody><tr><td>reset()</td><td>把 position 设置成 mark 的值，相当于之前做过一个标记，现在要退回到之前标记的地方</td></tr><tr><td>clear()</td><td>position = 0;limit = capacity;mark = -1</td></tr><tr><td>flip()</td><td>limit = position;position = 0;mark = -1</td></tr><tr><td>rewind()</td><td>把 position 设为 0，mark 设为 -1，不改变 limit 的值</td></tr><tr><td>remaining()</td><td>返回 limit  和position 之间相对位置差</td></tr><tr><td>hasRemaining()</td><td>返回是否还有未读内容</td></tr><tr><td>compact()</td><td>把从 position 到 limit 中的内容移到 0 到 limit-position 的区域内</td></tr><tr><td>get()</td><td>相对读，从 position 位置读取一个 byte，并将 position+1，为下次读写作准备</td></tr><tr><td>get(int index)</td><td>绝对读，读取 byteBuffer 底层的 bytes 中下标为 index 的 byte，不改变 position</td></tr><tr><td>get(byte[] dst, int offset, int length)</td><td>从 position 位置开始相对读，读 length 个 byte，并写入 dst 下标从 offset 到 offset+length 的区域</td></tr><tr><td>put(byte b)</td><td>相对写，向 position 的位置写入一个 byte，并将 postion+1，为下次读写作准备</td></tr><tr><td>put(int index, byte b)</td><td>绝对写，向 byteBuffer 底层的 bytes 中下标为 index 的位置插入byte b，不改变 position</td></tr><tr><td>put(ByteBuffer src)</td><td>用相对写，把src中可读的部分（也就是 position 到 limit ）写入此byteBuffer</td></tr><tr><td>put(byte[] src, int offset, int length)</td><td>从 src 数组中的 offset 到 offset+length 区域读取数据并使用相对写写入此 byteBuffer</td></tr></tbody></table><h4 id="2-7-Reactor模式类型"><a href="#2-7-Reactor模式类型" class="headerlink" title="2.7 Reactor模式类型"></a>2.7 Reactor模式类型</h4><h5 id="1-单线程Reactor模式流程"><a href="#1-单线程Reactor模式流程" class="headerlink" title="1. 单线程Reactor模式流程"></a>1. 单线程Reactor模式流程</h5><ul><li>服务器端的 Reactor 是一个线程对象，该线程会启动事件循环，并使用 Selector (选择器)来实现 IO 的多路复用。注册一个 Acceptor 事件处理器到 Reactor 中，Acceptor 事件处理器所关注的事件是 ACCEPT 事件，这样 Reactor 会监听客户端向服务器端发起的连接请求事件(ACCEPT事件)。</li><li>客户端向服务器端发起一个连接请求，Reactor 监听到了该 ACCEPT 事件的发生并将该 ACCEPT 事件派发给相应的 Acceptor 处理器来进行处理。Acceptor 处理器通过 accept() 方法得到与这个客户端对应的连接(SocketChannel)，然后将该连接所关注的 READ 事件以及对应的 READ 事件处理器注册到 Reactor 中，这样一来 Reactor 就会监听该连接的 READ 事件了。</li><li>当 Reactor 监听到有读或者写事件发生时，将相关的事件派发给对应的处理器进行处理。比如，读处理器会通过 SocketChannel 的 read() 方法读取数据，此时 read() 操作可以直接读取到数据，而不会堵塞与等待可读的数据到来。</li><li>每当处理完所有就绪的感兴趣的 I/O 事件后，Reactor 线程会再次执行 select() 阻塞等待新的事件就绪并将其分派给对应处理器进行处理。</li></ul><p>注意，Reactor 的单线程模式的单线程主要是针对于 I/O 操作而言，也就是所有的 I/O 的 accept()、read()、write() 以及 connect() 操作都在一个线程上完成的。</p><p>但在目前的单线程 Reactor 模式中，不仅 I/O 操作在该 Reactor 线程上，连非 I/O 的业务操作也在该线程上进行处理了，这可能会大大延迟 I/O 请求的响应。所以我们应该将非 I/O 的业务逻辑操作从 Reactor 线程上卸载，以此来加速 Reactor  线程对 I/O 请求的响应。</p><center>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042006610.png" style="zoom:50%;" /></center><h5 id="2-单线程Reactor，工作者线程池"><a href="#2-单线程Reactor，工作者线程池" class="headerlink" title="2. 单线程Reactor，工作者线程池"></a>2. 单线程Reactor，工作者线程池</h5><p>与单线程 Reactor 模式不同的是，添加了一个工作者线程池，并将非 I/O 操作从 Reactor 线程中移出转交给工作者线程池来执行。这样能够提高 Reactor 线程的 I/O 响应，不至于因为一些耗时的业务逻辑而延迟对后面 I/O 请求的处理。</p><p>使用线程池的优势：</p><p>① 通过重用现有的线程而不是创建新线程，可以在处理多个请求时分摊在线程创建和销毁过程产生的巨大开销。</p><p>② 当请求到达时，工作线程通常已经存在，因此不会由于等待创建线程而延迟任务的执行，从而提高了响应性。</p><p>③ 通过适当调整线程池的大小，可以创建足够多的线程以便使处理器保持忙碌状态。同时还可以防止过多线程相互竞争资源而使应用程序耗尽内存或失败。</p><p>改进的版本中，I/O 操作依旧由一个 Reactor 来完成，包括 I/O 的 accept()、read()、write() 以及 connect() 操作。</p><p>对于一些小容量应用场景，可以使用单线程模型。但是对于高负载、大并发或大数据量的应用场景却不合适，主要原因如下：</p><p>① 一个 NIO 线程同时处理成百上千的链路，性能上无法支撑，即便 NIO 线程的 CPU 负荷达到100%，也无法满足海量消息的读取和发送；</p><p>② 当 NIO 线程负载过重之后，处理速度将变慢，这会导致大量客户端连接超时，超时之后往往会进行重发，这更加重了 NIO 线程的负载，最终会导致大量消息积压和处理超时，成为系统的性能瓶颈；</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042014630.png" style="zoom:50%;" /></center><h5 id="3-多线程主从Reactor模式"><a href="#3-多线程主从Reactor模式" class="headerlink" title="3. 多线程主从Reactor模式"></a>3. 多线程主从Reactor模式</h5><p>Reactor 线程池中的每一 Reactor 线程都会有自己的 Selector、线程和分发的事件循环逻辑。</p><p>mainReactor 可以只有一个，但 subReactor 一般会有多个。mainReactor 线程主要负责接收客户端的连接请求，然后将接收到的 SocketChannel 传递给 subReactor，由 subReactor 来完成和客户端的通信。</p><p>流程：</p><p>① 注册一个 Acceptor 事件处理器到 mainReactor 中，Acceptor 事件处理器所关注的事件是 ACCEPT 事件，这样 mainReactor 会监听客户端向服务器端发起的连接请求事件(ACCEPT事件)。启动 mainReactor 的事件循环。</p><p>② 客户端向服务器端发起一个连接请求，mainReactor 监听到了该 ACCEPT 事件并将该 ACCEPT 事件派发给 Acceptor 处理器来进行处理。Acceptor 处理器通过 accept() 方法得到与这个客户端对应的连接(SocketChannel)，然后将这个 SocketChannel 传递给 subReactor 线程池。</p><p>③ subReactor 线程池分配一个 subReactor 线程给这个 SocketChannel，即，将 SocketChannel 关注的 READ 事件以及对应的 READ 事件处理器注册到 subReactor 线程中。Reactor 线程池中的每一 Reactor 线程都会有自己的 Selector、线程和分发的循环逻辑。</p><p>④ 当有 I/O 事件就绪时，相关的 subReactor 就将事件派发给响应的处理器处理。注意，这里 subReactor 线程只负责完成 I/O 的 read() 操作，在读取到数据后将业务逻辑的处理放入到线程池中完成，若完成业务逻辑后需要返回数据给客户端，则相关的 I/O 的 write 操作还是会被提交回 subReactor 线程来完成。</p><p>注意，所有的 I/O 操作(包括，I/O 的 accept()、read()、write() 以及 connect() 操作)依旧还是在 Reactor 线程( mainReactor 线程 或  subReactor 线程)中完成的。Thread Pool(线程池)仅用来处理非 I/O 操作的逻辑。</p><p>多 Reactor 线程模式将“接受客户端的连接请求”和“与该客户端的通信”分在了两个 Reactor 线程来完成。mainReactor 完成接收客户端连接请求的操作，它不负责与客户端的通信，而是将建立好的连接转交给 subReactor 线程来完成与客户端的通信，这样一来就不会因为 read() 数据量太大而导致后面的客户端连接请求得不到即时处理的情况。并且多 Reactor 线程模式在海量的客户端并发请求的情况下，还可以通过实现 subReactor 线程池来将海量的连接分发给多个 subReactor 线程，在多核的操作系统中这能大大提升应用的负载和吞吐量。</p><center><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202310042023285.png" style="zoom:50%;" /></center><h5 id="4-和观察者模式的区别"><a href="#4-和观察者模式的区别" class="headerlink" title="4. 和观察者模式的区别"></a>4. 和观察者模式的区别</h5><p><strong>观察者模式：</strong>也可以称为为 发布-订阅 模式，主要适用于多个对象依赖某一个对象的状态，并且当某对象状态发生改变时，要通知其他依赖对象做出更新。是一种一对多的关系。当然，如果依赖的对象只有一个时，也是一种特殊的一对一关系。通常，观察者模式适用于消息事件处理，监听者监听到事件时通知事件处理者对事件进行处理。</p><p><strong>Reactor模式：</strong> 即反应器模式，是一种高效的异步 IO 模式，特征是回调，当 IO 完成时，回调对应的函数进行处理。这种模式并非是真正的异步，而是运用了异步的思想，当 IO 事件触发时，通知应用程序作出 IO 处理。模式本身并不调用系统的异步 IO 函数。</p><p>reactor模式与观察者模式有点像。不过，观察者模式与单个事件源关联，而反应器模式则与多个事件源关联 。当一个主体发生改变时，所有依属体都得到通知。</p>]]></content>
    
    
    <categories>
      
      <category>Netty</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Netty</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo——服务导出和服务引入</title>
    <link href="/2023/06/15/Dubbo%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E5%AF%BC%E5%87%BA%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%BC%95%E5%85%A5/"/>
    <url>/2023/06/15/Dubbo%E2%80%94%E2%80%94%E6%9C%8D%E5%8A%A1%E5%AF%BC%E5%87%BA%E5%92%8C%E6%9C%8D%E5%8A%A1%E5%BC%95%E5%85%A5/</url>
    
    <content type="html"><![CDATA[<p>不管是服务导出还是服务引入，都发生在应用启动过程中。在启动类上加上 @EnableDubbo 时，该注解上有一个 @DubboComponentScan 注解，@DubboComponentScan 注解 Import 了一个 DubboComponentScanRegistrar，DubboComponentScanRegistrar 中会调用 DubboSpringInitializer.initialize()，该方法中会注册一个 DubboDeployApplicationListener，而 DubboDeployApplicationListener 会监听 Spring 容器启动完成事件 ContextRefreshedEvent，一旦接收到这个事件后，就会开始 Dubbo 的启动流程，就会执行 DefaultModuleDeployer 的 start() 进行<strong>服务导出</strong>与<strong>服务引入</strong>。</p><p>Dubbo3.0源码：<a href="https://gitee.com/archguide/dubbo-dubbo-3.0.7">https://gitee.com/archguide/dubbo-dubbo-3.0.7</a></p><p>服务导出和引入整体流程：<a href="https://www.processon.com/view/link/62c441e80791293dccaebded">https://www.processon.com/view/link/62c441e80791293dccaebded</a></p><p>在启动过程中，在做完<strong>服务导出</strong>与<strong>服务引入</strong>后，还会做几件非常重要的事情：</p><ol><li>导出一个应用元数据服务（就是一个 MetadataService 服务，这个服务也会注册到注册中心），或者将应用元数据注册到元数据中心。</li><li>生成当前应用的实例信息对象 ServiceInstance，比如应用名、实例 ip、实例 port，并将实例信息注册到注册中心，也就是应用级注册。</li></ol><h3 id="1-服务导出"><a href="#1-服务导出" class="headerlink" title="1. 服务导出"></a>1. 服务导出</h3><p>在<strong>某个接口的实现类</strong>上加上 <strong>@DubboService</strong> 后，就表示定义了一个 Dubbo 服务，应用启动时 Dubbo 只要扫描到了 @DubboService，就会解析对应的类，得到服务相关的配置信息，比如：</p><ol><li>服务的类型，也就是接口，接口名就是服务名</li><li>服务的具体实现类，也就是当前类</li><li>服务的 version、timeout 等信息，就是 @DubboService 中所定义的各种配置</li></ol><p>解析完服务的配置信息后，就会把这些配置信息封装成为一个 ServiceConfig 对象，并调用其 export() 进行服务导出，此时一个 ServiceConfig 对象就表示一个 Dubbo 服务。</p><p>而所谓的服务导出，主要就是完成三件事情：</p><ol><li>确定服务的最终参数配置</li><li>按不同协议启动对应的 Server（<strong>服务暴露</strong>）</li><li>将服务注册到注册中心（<strong>服务注册</strong>）</li></ol><h4 id="1-1-确定服务参数"><a href="#1-1-确定服务参数" class="headerlink" title="1.1 确定服务参数"></a>1.1 确定服务参数</h4><p>一个 Dubbo 服务，除开服务的名字，也就是接口名，还会有很多其他的属性，比如超时时间、版本号、服务所属应用名、所支持的协议及绑定的端口等众多信息。</p><p>但是，通常这些信息并不会全部在 @DubboService 中进行定义，比如，一个 Dubbo 服务肯定是属于某个应用的，而一个应用下可以有多个 Dubbo 服务，所以我们可以在应用级别定义一些通用的配置，比如协议。</p><p>我们在 application.yml 中定义：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dubbo:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">order-application</span><br>  <span class="hljs-attr">protocol:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">tri</span><br>    <span class="hljs-attr">port:</span> <span class="hljs-number">20880</span><br></code></pre></td></tr></table></figure><p>表示当前应用下所有的 Dubbo 服务都支持通过 tri 协议进行访问，并且访问端口为 20880，所以在进行<strong>某个服务</strong>的服务导出时，就需要将应用中的这些配置信息合并到当前服务的配置信息中。</p><h4 id="1-2-服务注册"><a href="#1-2-服务注册" class="headerlink" title="1.2 服务注册"></a>1.2 服务注册</h4><p>当确定好了最终的服务配置后，Dubbo 就会根据这些配置信息生成对应的<strong>服务 URL</strong>，比如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">tri://192.168.110.140:50051/com.debuggingWorld.mall.service.OrderService?anyhost=true&amp;application=order-application<br></code></pre></td></tr></table></figure><p>这个 URL 就表示了一个 Dubbo 服务，服务消费者只要能获得到这个服务 URL，就知道了关于这个 Dubbo 服务的全部信息，包括服务名、支持的协议、ip、port、各种配置。</p><p>确定了服务 URL 之后，服务注册要做的事情就是把这个服务 URL 存到注册中心（比如 Zookeeper）中去，说的再简单一点，就是把这个字符串存到 Zookeeper 中去，这个步骤其实是非常简单的，实现这个功能的源码在 RegistryProtocol 中的 export() 方法中，最终服务 URL 存在了 Zookeeper 的  <strong>/dubbo/ 接口名 /providers</strong> 目录下。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306210156440.png"></p><p>但是服务注册并不仅仅就这么简单，既然上面的这个 URL 表示一个服务，并且还包括了服务的一些配置信息，那这些配置信息如果改变了呢？比如利用 Dubbo 管理台中的动态配置功能（注意，并不是配置中心）来修改服务配置，动态配置可以应用运行过程中动态的修改服务的配置，并实时生效。</p><p>如果利用动态配置功能修改了服务的参数，那此时就要重新生成服务 URL 并重新注册到注册中心，这样服务消费者就能及时的获取到服务配置信息。</p><p>而对于服务提供者而言，在服务注册过程中，还需要能监听到动态配置的变化，一旦发生了变化，就根据最新的配置重新生成服务 URL，并重新注册到中心。</p><h4 id="1-3-应用级注册"><a href="#1-3-应用级注册" class="headerlink" title="1.3 应用级注册"></a>1.3 应用级注册</h4><p>在 Dubbo3.0 之前，Dubbo 是接口级注册，服务注册就是把接口名以及服务配置信息注册到注册中心中，注册中心存储的数据格式大概为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">接口名1：tri://192.168.110.140:50051/接口名1?application=应用名<br>接口名2：tri://192.168.110.140:50051/接口名2?application=应用名<br>接口名3：tri://192.168.110.140:50051/接口名3?application=应用名<br></code></pre></td></tr></table></figure><p>key 是接口名，value 就是服务 URL，上面的内容就表示现在有一个应用，该应用下有 3 个接口，应用实例部署在 192.168.110.140，此时，如果给该应用增加一个实例，实例 ip 为 192.168.110.141，那么新的实例也需要进行服务注册，会向注册中心新增 3 条数据：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell">接口名1：tri://192.168.110.140:50051/接口名1?application=应用名<br>接口名2：tri://192.168.110.140:50051/接口名2?application=应用名<br>接口名3：tri://192.168.110.140:50051/接口名3?application=应用名<br><br>接口名1：tri://192.168.110.141:50051/接口名1?application=应用名<br>接口名2：tri://192.168.110.141:50051/接口名2?application=应用名<br>接口名3：tri://192.168.110.141:50051/接口名3?application=应用名<br></code></pre></td></tr></table></figure><p>可以发现，如果一个应用中有 3 个 Dubbo 服务，那么每增加一个实例，就会向注册中心增加 3 条记录，那如果一个应用中有 10 个 Dubbo 服务，那么每增加一个实例，就会向注册中心增加 10 条记录，注册中心的压力会随着应用实例的增加而剧烈增加。</p><p>反过来，如果一个应用有 3 个 Dubbo 服务，5 个实例，那么注册中心就有 15 条记录，此时增加一个 Dubbo 服务，那么注册中心就会新增 5 条记录，注册中心的压力也会剧烈增加。</p><p>注册中心的数据越多，数据就变化的越频繁，比如修改服务的 timeout，那么对于注册中心和应用都需要消耗资源用来处理数据变化。</p><p>所以为了降低注册中心的压力，Dubbo3.0 支持了应用级注册，同时也兼容接口级注册，用户可以逐步迁移成应用级注册，而一旦采用应用级注册，最终注册中心的数据存储就变成为：</p><blockquote><p>应用名：192.168.110.140:20880<br>应用名：192.168.110.141:20880</p></blockquote><p>表示在注册中心中，只记录应用所对应的实例信息（IP+绑定的端口），这样只有一个应用的实例增加了，那么注册中心的数据才会增加，而不关心一个应用中到底有多少个 Dubbo 服务。</p><p>这样带来的好处就是，注册中心存储的数据变少了，注册中心中数据的变化频率变小了，并且使用应用级注册，使得 Dubbo3 能实现与异构微服务体系如 Spring Cloud、Kubernetes Service 等在地址发现层面更容易互通， 为连通 Dubbo 与其他微服务体系提供可行方案。</p><p>应用级注册带来了好处，但是对于 Dubbo 来说又出现了一些新的问题，比如：原本，服务消费者可以直接从注册中心就知道某个 Dubbo 服务的所有服务提供者以及相关的协议、ip、port、配置等信息，那现在注册中心上只有 ip、port，那对于服务消费者而言：<strong>服务消费者怎么知道现在它要用的某个 Dubbo 服务，也就是某个接口对应的应用是哪个呢？</strong></p><p>对于这个问题，在进行服务导出的过程中，会在 Zookeeper 中存一个映射关系，在服务导出的最后一步，在 ServiceConfig 的 exported() 方法中，会保存这个映射关系：</p><blockquote><p>接口名：应用名</p></blockquote><p>这个映射关系存在 Zookeeper 的  <strong>/dubbo/mapping 目录</strong>下，存了这个信息后，消费者就能根据接口名找到所对应的应用名了。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306210239652.png"></p><p>消费者知道了要使用的 Dubbo 服务在哪个应用，那也就能从注册中心中根据应用名查到应用的所有实例信息（ip+port），也就是可以发送方法调用请求了，但是在真正发送请求之前，还得知道服务的配置信息，对于消费者而言，它得知道当前要调用的这个Dubbo服务支持什么协议、timeout是多少，<strong>那服务的配置信息从哪里获取呢？</strong></p><p>之前的服务配置信息是直接从注册中心就可以获取到的，就是服务 URL 后面，但是现在不行了，现在需要从服务提供者的元数据服务获取，前面提到过，在应用启动过程中会进行服务导出和服务引入，然后就会暴露一个<strong>应用元数据服务</strong>，其实这个应用元数据服务就是一个 Dubbo 服务（Dubbo框架内置的，自己实现的），消费者可以调用这个服务来获取某个应用中所提供的所有 Dubbo 服务以及服务配置信息，这样也就能知道服务的配置信息了。</p><h5 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h5><p>首先，可以通过配置 <strong>dubbo.application.register-mode</strong> 来控制：</p><ol><li>instance：表示只进行应用级注册</li><li>interface：表示只进行接口级注册</li><li>all：表示应用级注册和接口级注册都进行，默认</li></ol><p>不管是什么注册，都需要存数据到注册中心，而 Dubbo3 的源码实现中会根据所配置的注册中心生成两个 URL（不是服务 URL，可以理解为注册中心 URL，用来访问注册中心的）:</p><blockquote><ol><li>service-discovery-registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=order-application&amp;dubbo=2.0.2&amp;pid=13072&amp;qos.enable=false®istry=zookeeper×tamp=1651755501660</li><li>registry://127.0.0.1:2181/org.apache.dubbo.registry.RegistryService?application=order-application&amp;dubbo=2.0.2&amp;pid=13072&amp;qos.enable=false®istry=zookeeper×tamp=1651755501660</li></ol></blockquote><p>这两个 URL 只有 schema 不一样，一个是 service-discovery-registry，一个是 registry，而 registry 是 Dubbo3 之前就存在的，也就代表接口级服务注册，而 service-discovery-registry 就表示应用级服务注册。</p><p>在服务注册相关的源码中，当调用 RegistryProtocol 的 export() 方法处理 registry:// 时，会利用 ZookeeperRegistry 把服务 URL 注册到 Zookeeper 中去，这就是接口级注册。</p><p>而类似，当调用 RegistryProtocol 的 export() 方法处理 service-discovery-registry:// 时，会利用 ServiceDiscoveryRegistry 来进行相关逻辑的处理，那是不是就是在这里把应用信息注册到注册中心去呢？并没有这么简单。</p><ol><li>首先，不可能每导出一个服务就进行一次应用注册，太浪费了，应用注册只要做一次就行了</li><li>另外，如果一个应用支持了多个端口，那么应用注册时只要挑选其中一个端口作为实例端口就可以了（该端口只要能接收到数据就行）</li><li>前面提到，应用启动过程中要暴露应用元数据服务，所以在此处也还是要收集当前所暴露的服务配置信息，以提供给应用元数据服务</li></ol><p>所以 ServiceDiscoveryRegistry 在注册一个服务 URL 时，并不会往注册中心存数据，而只是把服务 URL 存到到一个 MetadataInfo 对象中，MetadataInfo 对象中就保存了当前应用中所有的 Dubbo 服务信息（服务名、支持的协议、绑定的端口、timeout 等）</p><p>前面提到过，在应用启动的最后，才会进行应用级注册，而应用级注册就是当前的应用实例上相关的信息存入注册中心，包括：</p><ol><li>应用的名字</li><li>获取应用元数据的方式</li><li>当前实例的 ip 和 port</li><li>当前实例支持哪些协议以及对应的 port</li></ol><p>例如：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306300014867.png"></p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;order-application&quot;</span>,<br><span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;192.168.110.140:50051&quot;</span>,<br><span class="hljs-attr">&quot;address&quot;</span>: <span class="hljs-string">&quot;192.168.110.140&quot;</span>,<br><span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">50051</span>,<br><span class="hljs-attr">&quot;sslPort&quot;</span>: <span class="hljs-literal">null</span>,<br><span class="hljs-attr">&quot;payload&quot;</span>: &#123;<br><span class="hljs-attr">&quot;@class&quot;</span>: <span class="hljs-string">&quot;org.apache.dubbo.registry.zookeeper.ZookeeperInstance&quot;</span>,<br><span class="hljs-attr">&quot;id&quot;</span>: <span class="hljs-string">&quot;192.168.110.140:50051&quot;</span>,<br><span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;order-application&quot;</span>,<br><span class="hljs-attr">&quot;metadata&quot;</span>: &#123;<br><span class="hljs-attr">&quot;dubbo.endpoints&quot;</span>: <span class="hljs-string">&quot;[&#123;\&quot;port\&quot;:50051,\&quot;protocol\&quot;:\&quot;tri\&quot;&#125;]&quot;</span>,<br><span class="hljs-attr">&quot;dubbo.metadata-service.url-params&quot;</span>: <span class="hljs-string">&quot;&#123;\&quot;connections\&quot;:\&quot;1\&quot;,\&quot;version\&quot;:\&quot;1.0.0\&quot;,\&quot;dubbo\&quot;:\&quot;2.0.2\&quot;,\&quot;release\&quot;:\&quot;3.1.9\&quot;,\&quot;side\&quot;:\&quot;provider\&quot;,\&quot;ipv6\&quot;:\&quot;2408:8270:1038:5f20:0:0:0:e7d9\&quot;,\&quot;port\&quot;:\&quot;50052\&quot;,\&quot;protocol\&quot;:\&quot;tri\&quot;&#125;&quot;</span>,<br><span class="hljs-attr">&quot;dubbo.metadata.revision&quot;</span>: <span class="hljs-string">&quot;0b944e47ab5cd306cd6ffa9ba20633b4&quot;</span>,<br><span class="hljs-attr">&quot;dubbo.metadata.storage-type&quot;</span>: <span class="hljs-string">&quot;local&quot;</span>,<br><span class="hljs-attr">&quot;ipv6&quot;</span>: <span class="hljs-string">&quot;2408:8270:1038:5f20:0:0:0:e7d9&quot;</span>,<br><span class="hljs-attr">&quot;timestamp&quot;</span>: <span class="hljs-string">&quot;1687276820990&quot;</span><br>&#125;<br>&#125;,<br><span class="hljs-attr">&quot;registrationTimeUTC&quot;</span>: <span class="hljs-number">1687276823174</span>,<br><span class="hljs-attr">&quot;serviceType&quot;</span>: <span class="hljs-string">&quot;DYNAMIC&quot;</span>,<br><span class="hljs-attr">&quot;uriSpec&quot;</span>: <span class="hljs-literal">null</span><br>&#125;<br></code></pre></td></tr></table></figure><p>一个实例上可能支持多个协议以及多个端口，<strong>那如何确定实例的 ip 和端口呢？</strong></p><p>答案是：获取 MetadataInfo 对象中保存的所有服务URL，优先取 dubbo 协议对应 ip 和 port，没有 dubbo 协议则所有服务 URL 中的第一个 URL 的 ip 和 port。</p><p>另外一个协议一般只会对应一个端口，但是如果就是对应了多个，比如：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dubbo:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">order-application</span><br>  <span class="hljs-attr">protocols:</span><br>    <span class="hljs-attr">p1:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">dubbo</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">20881</span><br>    <span class="hljs-attr">p2:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">dubbo</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">20882</span><br>    <span class="hljs-attr">p3:</span><br>      <span class="hljs-attr">name:</span> <span class="hljs-string">tri</span><br>      <span class="hljs-attr">port:</span> <span class="hljs-number">50051</span><br></code></pre></td></tr></table></figure><p>如果是这样，最终存入 endpoint 中的会保证一个协议只对应一个端口，另外那个将被忽略，最终服务消费者在进行服务引入时将会用到这个 endpoint 信息。</p><p>确定好实例信息后之后，就进行最终的应用注册了，就把实例信息存入注册中心的 <strong>/services/ 应用名目录</strong>下：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306292103819.png"></p><p>可以看出 services 节点下存的是应用名，应用名的节点下存的是实例 ip 和实例 port，而 ip 和 port 这个节点中的内容就是实例的一些基本信息。</p><p>另外，可以配置 dubbo.metadata.storage-type，默认是 local，可以通过配置改为 remote：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dubbo:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">order-application</span><br>    <span class="hljs-attr">metadata-type:</span> <span class="hljs-string">remote</span><br></code></pre></td></tr></table></figure><p>这个配置其实跟应用元数据服务（MetadataService 服务，用于返回 metadata）有关系：</p><ol><li>如果为 local，那就会启用<strong>应用元数据服务</strong>，最终服务消费者就会调用元数据服务获取到应用元数据信息（接口注册的方式调用，将接口注册到注册中心）</li><li>如果为 remote，那就不会暴露应用元数据服务，那么服务消费者从<strong>元数据中心</strong>获取应用元数据呢？ </li></ol><p>在 Dubbo2.7 中就有了元数据中心，它其实就是用来减轻注册中心的压力的，Dubbo 会把服务信息完整的存一份到元数据中心，元数据中心也可以用 Zookeeper 来实现，在暴露完元数据服务之后，在注册实例信息到注册中心之前，就会把 MetadataInfo 存入元数据中心，比如：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306292122160.png"></p><p>节点内容为：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs json">&#123;<br><span class="hljs-attr">&quot;app&quot;</span>: <span class="hljs-string">&quot;order-application&quot;</span>,<br><span class="hljs-attr">&quot;revision&quot;</span>: <span class="hljs-string">&quot;3ea21c46ac0131239cf39512bc691907&quot;</span>,<br><span class="hljs-attr">&quot;services&quot;</span>: &#123;<br><span class="hljs-attr">&quot;com.debuggingWorld.mall.service.OrderService:tri&quot;</span>: &#123;<br><span class="hljs-attr">&quot;name&quot;</span>: <span class="hljs-string">&quot;com.debuggingWorld.mall.service.OrderService&quot;</span>,<br><span class="hljs-attr">&quot;params&quot;</span>: &#123;<br><span class="hljs-attr">&quot;side&quot;</span>: <span class="hljs-string">&quot;provider&quot;</span>,<br><span class="hljs-attr">&quot;release&quot;</span>: <span class="hljs-string">&quot;3.1.9&quot;</span>,<br><span class="hljs-attr">&quot;methods&quot;</span>: <span class="hljs-string">&quot;getOrderByUserId&quot;</span>,<br><span class="hljs-attr">&quot;deprecated&quot;</span>: <span class="hljs-string">&quot;false&quot;</span>,<br><span class="hljs-attr">&quot;dubbo&quot;</span>: <span class="hljs-string">&quot;2.0.2&quot;</span>,<br><span class="hljs-attr">&quot;interface&quot;</span>: <span class="hljs-string">&quot;com.debuggingWorld.mall.service.OrderService&quot;</span>,<br><span class="hljs-attr">&quot;service-name-mapping&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>,<br><span class="hljs-attr">&quot;generic&quot;</span>: <span class="hljs-string">&quot;false&quot;</span>,<br><span class="hljs-attr">&quot;metadata-type&quot;</span>: <span class="hljs-string">&quot;remote&quot;</span>,<br><span class="hljs-attr">&quot;application&quot;</span>: <span class="hljs-string">&quot;order-application&quot;</span>,<br><span class="hljs-attr">&quot;background&quot;</span>: <span class="hljs-string">&quot;false&quot;</span>,<br><span class="hljs-attr">&quot;dynamic&quot;</span>: <span class="hljs-string">&quot;true&quot;</span>,<br><span class="hljs-attr">&quot;anyhost&quot;</span>: <span class="hljs-string">&quot;true&quot;</span><br>&#125;,<br><span class="hljs-attr">&quot;path&quot;</span>: <span class="hljs-string">&quot;com.debuggingWorld.mall.service.OrderService&quot;</span>,<br><span class="hljs-attr">&quot;port&quot;</span>: <span class="hljs-number">50051</span>,<br><span class="hljs-attr">&quot;protocol&quot;</span>: <span class="hljs-string">&quot;tri&quot;</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面就记录了当前实例上提供了哪些服务以及对应的协议，注意并没有保存对应的端口，所以后面服务消费者得利用实例信息中的 endpoint，因为 endpoint中记录了协议对应的端口。</p><p>其实元数据中心和元数据服务提供的功能是一样的，都可以用来获取某个实例的 MetadataInfo，上面中的 UUID 表示实例编号，只不过元数据中心是<strong>集中</strong>式的，元数据服务式<strong>分散</strong>在各个提供者实例中的，如果整个微服务集群压力不大，那么效果差不多，如果微服务集群压力大，那么元数据中心的压力就大，此时单个元数据服务就更适合，所以默认也是采用的元数据服务。</p><p>注册中心和元数据中心也可以分别设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dubbo:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">order-application</span><br>    <span class="hljs-attr">metadata-type:</span> <span class="hljs-string">remote</span><br>    <span class="hljs-attr">register-mode:</span> <span class="hljs-string">instance</span><br>  <span class="hljs-attr">protocol:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">tri</span><br>  <span class="hljs-attr">registry:</span><br>    <span class="hljs-attr">address:</span> <span class="hljs-string">zookeeper://127.0.0.1:2181</span><br>  <span class="hljs-attr">metadata-report:</span><br>    <span class="hljs-attr">address:</span> <span class="hljs-string">zookeeper://127.0.0.1:2182</span><br></code></pre></td></tr></table></figure><p>至此，应用级服务注册的原理就分析完了，总结一下：</p><ol><li>在导出某个 Dubbo 服务URL时，会把服务 URL 存入 MetadataInfo 中</li><li>导出完某个 Dubbo 服务后，就会把<strong>服务接口名:应用名</strong>存入元数据中心（可以用 Zookeeper 实现）</li><li>导出所有服务后，完成服务引入后</li><li>判断要不要启动元数据服务，如果要就进行导出，固定使用 Dubbo 协议</li><li>将 MetadataInfo 存入元数据中心</li><li>确定当前实例信息（应用名、ip、port、endpoint）</li><li>将实例信息存入注册中心，完成应用注册</li></ol><p>应用注册查找过程：</p><p>OrderService —&gt; mapping —&gt; 应用名—-&gt;实例1—&gt;实例ip + port —&gt; 实例元数据  —&gt; endpoints —&gt;OrderService:tri —-&gt;tri协议端口  —&gt; tri://示例端口：tri协议端口/OrderService —&gt; TripleInvoker</p><p>OrderService —&gt; mapping —&gt; 应用名—-&gt;实例2—&gt;实例ip + port  —&gt;实例元数据  —&gt; endpoints —&gt; OrderService:dubbo —-&gt;dubbo协议端口  —&gt; dubbo://示例端口：dubbo协议端口/OrderService —&gt; DubboInvoker</p><p>ClusterInvoker —&gt; OrderService 代理对象</p><p>ClusterInvoker .invoke(Invovation) —&gt; TripleInvoker.invoke() —&gt; tri —&gt; 实例ip：tri协议端口</p><h4 id="1-4-服务暴露"><a href="#1-4-服务暴露" class="headerlink" title="1.4 服务暴露"></a>1.4 服务暴露</h4><p>服务暴露就是根据不同的协议启动不同的 Server，比如 dubbo 和 tri 协议启动的都是 Netty，像 Dubbo2.7 中的 http 协议启动的就是 Tomcat，这块在服务调用的时候再来分析。</p><p>1：10：00</p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Dubbo——Dubbo3.0新特性</title>
    <link href="/2023/06/01/Dubbo%E2%80%94%E2%80%94Dubbo3-0%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2023/06/01/Dubbo%E2%80%94%E2%80%94Dubbo3-0%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是-Dubbo"><a href="#1-什么是-Dubbo" class="headerlink" title="1. 什么是 Dubbo"></a>1. 什么是 Dubbo</h3><p>Apache Dubbo 是一款 RPC 服务开发框架，用于解决微服务架构下的服务治理与通信问题，官方提供了 Java、Golang 等多语言 SDK 实现。使用 Dubbo 开发的微服务原生具备相互之间的远程地址发现与通信能力， 利用 Dubbo 提供的丰富服务治理特性，可以实现诸如服务发现、负载均衡、流量调度等服务治理诉求。Dubbo 被设计为高度可扩展，用户可以方便的实现流量拦截、选址的各种定制逻辑</p><p>官网地址：<a href="http://dubbo.apache.org/zh/">http://dubbo.apache.org/zh/</a></p><h3 id="2-快速开始"><a href="#2-快速开始" class="headerlink" title="2. 快速开始"></a>2. 快速开始</h3><ol><li>添加 dubbo 核心依赖</li><li>添加要使用的注册中心依赖</li><li>添加要使用的协议的依赖</li><li>配置 dubbo 相关的基本信息</li><li>配置注册中心地址</li><li>配置所使用的协议</li></ol><h4 id="2-1-添加依赖"><a href="#2-1-添加依赖" class="headerlink" title="2.1 添加依赖"></a>2.1 添加依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-rpc-dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-registry-nacos<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-2-公共服务"><a href="#2-2-公共服务" class="headerlink" title="2.2 公共服务"></a>2.2 公共服务</h4><p>OrderService 接口在服务提供者和服务调用方都使用到了，所以提取为公共服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderService</span> </span>&#123;<br>    <span class="hljs-function">ResponseEntity <span class="hljs-title">getOrderByUserId</span><span class="hljs-params">(Integer userId)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306012143825.png"></p><h4 id="2-3-provider"><a href="#2-3-provider" class="headerlink" title="2.3 provider"></a>2.3 provider</h4><ol><li><p><font color="red"><strong>@DubboService</strong> </font>标注该类为  Dubbo Service</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DubboService</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">getOrderByUserId</span><span class="hljs-params">(Integer userId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p><font color="red"><strong>@EnableDubbo</strong> </font>开启 Dubbo</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableDubbo(scanBasePackages = &quot;com.debuggingWorld.service&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(Application.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">dubbo.application.name</span>=<span class="hljs-string">order-application</span><br><span class="hljs-meta">dubbo.protocol.name</span>=<span class="hljs-string">dubbo</span><br><span class="hljs-meta">dubbo.protocol.port</span>=<span class="hljs-string">20880</span><br><span class="hljs-comment">#dubbo.registry.address=zookeeper://127.0.0.1:2181</span><br><span class="hljs-meta">dubbo.registry.address</span>=<span class="hljs-string">nacos://192.168.60.10:8848</span><br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306012153165.png"></p></li><li><p>兼容</p><p>但是在开发过程中，很有可能有其他多个应用在调用 provider 应用，对于 provider 应用要做到，既要能支持 dubbo 协议调用，也要能支持 http 调用（和 controller 效果一样），所以，要么仍然保留 SpringMVC 那一套，如果不想保留那一套，就可以开启 dubbo 中的 rest 协议。</p><p><strong>添加依赖：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-rpc-rest<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>修改配置：</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">dubbo.application.name</span>=<span class="hljs-string">order-application</span><br><br><span class="hljs-meta">dubbo.protocols.p1.name</span>=<span class="hljs-string">dubbo</span><br><span class="hljs-meta">dubbo.protocols.p1.port</span>=<span class="hljs-string">20880</span><br><br><span class="hljs-meta">dubbo.protocols.p2.name</span>=<span class="hljs-string">rest</span><br><span class="hljs-meta">dubbo.protocols.p2.port</span>=<span class="hljs-string">8082</span><br><br><span class="hljs-meta">dubbo.registry.address</span>=<span class="hljs-string">nacos://192.168.60.10:8848</span><br></code></pre></td></tr></table></figure><p><strong>改造接口实现：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DubboService</span><br><span class="hljs-meta">@Path(&quot;/user&quot;)</span><br><span class="hljs-meta">@Produces</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-meta">@GET</span><br>    <span class="hljs-meta">@Path(&quot;/&#123;userId&#125;&quot;)</span><br>    <span class="hljs-meta">@Produces(MediaType.APPLICATION_JSON)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">getOrderByUserId</span><span class="hljs-params">(<span class="hljs-meta">@PathParam(&quot;userId&quot;)</span> Integer userId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试：</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306012212007.png"></p></li></ol><h4 id="2-4-consumer"><a href="#2-4-consumer" class="headerlink" title="2.4 consumer"></a>2.4 consumer</h4><ol><li><p>引入服务</p><p>通过 <font color="red">@DubboReference </font>注解来引入一个 Dubbo 服务</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-meta">@DubboReference</span><br>    OrderService orderService;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">getUser</span><span class="hljs-params">(Integer userId)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> orderService.getOrderByUserId(userId);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8081</span><br><span class="hljs-meta">dubbo.application.name</span>=<span class="hljs-string">user-application</span><br><span class="hljs-meta">dubbo.registry.address</span> =<span class="hljs-string">nacos://192.168.60.10:8848</span><br></code></pre></td></tr></table></figure></li><li><p>开启 Dubbo</p><p>启动类添加 @EnableDubbo</p></li></ol><h3 id="3-Dubbo3-0-新特性介绍"><a href="#3-Dubbo3-0-新特性介绍" class="headerlink" title="3. Dubbo3.0 新特性介绍"></a>3. Dubbo3.0 新特性介绍</h3><h4 id="3-1-注册模型的改变"><a href="#3-1-注册模型的改变" class="headerlink" title="3.1 注册模型的改变"></a>3.1 注册模型的改变</h4><p> 　　在服务注册领域，有两种模型，一种是应用级注册，一种是接口级注册，在Spring Cloud中，一个应用是一个微服务，而在 Dubbo2.7 中，一个接口是一个微服务。</p><p>　　Spring Cloud 在进行服务注册时，是把应用名以及应用所在服务器的 IP 地址和应用所绑定的端口注册到注册中心，相当于 key 是应用名，value 是 ip+port，而在 Dubbo2.7 中，是把接口名以及对应应用的 IP 地址和所绑定的端口注册到注册中心，相当于 key 是接口名，value 是 ip+port。所以在 Dubbo2.7 中，一个应用如果提供了 10 个 Dubbo 服务，那么注册中心中就会存储 10 对 keyvalue，而 Spring Cloud 就只会存一对 keyvalue，所以以 Spring Cloud 为首的应用级注册是更加适合的。</p><p>　　所以 Dubbo3.0 中将注册模型也改为了应用级注册，提升效率节省资源的同时，通过统一注册模型，也为各个微服务框架的互通打下了基础。</p><h4 id="3-2-Triple-协议"><a href="#3-2-Triple-协议" class="headerlink" title="3.2 Triple 协议"></a>3.2 Triple 协议</h4><ol><li>HTTP1.x 协议中，多余无用的字符太多了，比如回车符、换行符，这些字符占用了网络带宽，降低了网络 IO 的效率。</li><li>HTTP1.x 协议中，一条 Socket 连接，一次只能发送一个 HTTP 请求，因为如果连续发送两个 HTTP 请求，然后收到了一个响应，那怎么知道这个响应对应的是哪个请求呢，这样导致 Socket 连接的利用低，并发、吞吐量低。</li></ol><p>　　dubbo 协议相比于 http1.x 协议，性能会更好，因为请求中没有多余的无用的字节，都是必要的字节，并且每个 Dubbo 请求和响应中都有一个请求 ID，这样可以基于一个 Socket 连接同时发送多个 Dubbo 请求，不用担心请求和响应对不上，所以 dubbo 协议成为了 Dubbo 框架中的默认协议。</p><p>dubbo 协议格式：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306020027164.png"></p><p>　　但是 dubbo 协议一旦涉及到跨 RPC 框架，比如一个 Dubbo 服务要调用 gPRC 服务，就比较麻烦了，因为发一个 dubbo 协议的请求给一个 gPRC 服务，gPRC 服务只会按照 gRPC 的格式来解析字节流，最终肯定会解析不成功的。dubbo 协议虽好，但是不够通用，所以这就出现了 Triple 协议。</p><p>　　Triple 协议是基于 HTTP2，没有性能问题，另外 HTTP 协议非常通用，全世界都认它，兼容起来也比较简单，而且还有很多额外的功能，比如流式调用。</p><p>triple、dubbo、rest 协议对比：</p><ul><li>triple 协议基于的是 HTTP2，rest 协议目前基于的是 HTTP1，都可以做到跨语言。</li><li>triple 协议兼容了 gPRC（Triple 服务可以直接调用 gRPC 服务，反过来也可以），rest 协议不行</li><li>triple 协议支持流式调用，rest 协议不行</li><li>rest 协议更方便浏览器、客户端直接调用，triple 协议不行（原理上支持，当得对 triple 协议的底层实现比较熟悉才行，得知道具体的请求头、请求体是怎么生成的）</li><li>dubbo 协议是 Dubbo3.0 之前的默认协议，triple 协议是 Dubbo3.0 之后的默认协议，优先用 Triple 协议</li><li>dubbo 协议不是基于的 HTTP，不够通用，triple 协议底层基于 HTTP 所以更通用（比如跨语言、跨异构系统实现起来比较方便）</li><li>dubbo 协议不支持流式调用</li></ul><p><strong>Triple 协议的使用：</strong></p><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-rpc-triple<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>修改配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">dubbo.protocol.name</span>=<span class="hljs-string">tri</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="3-3-Triple-协议的流式调用"><a href="#3-3-Triple-协议的流式调用" class="headerlink" title="3.3 Triple 协议的流式调用"></a>3.3 Triple 协议的流式调用</h4><p>StreamObserver 在 dubbo-common 模块下，所以添加  dubbo-common 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-common<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.9<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>公共服务中的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">HelloService</span> </span>&#123;<br>    <span class="hljs-comment">// UNARY</span><br>    <span class="hljs-function">String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span></span>;<br><br>    <span class="hljs-comment">// SERVER_STREAM</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHelloServerStream</span><span class="hljs-params">(String name, StreamObserver&lt;String&gt; response)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">// CLIENT_STREAM / BI_STREAM</span><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> StreamObserver&lt;String&gt; <span class="hljs-title">sayHelloStream</span><span class="hljs-params">(StreamObserver&lt;String&gt; response)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> response;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="1-UNARY"><a href="#1-UNARY" class="headerlink" title="1. UNARY"></a>1. UNARY</h5><p>就是正常的调用方法</p><p>服务实现类对应的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">sayHello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Hello &quot;</span> + name;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务消费者调用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">String result = helloService.sayHello(<span class="hljs-string">&quot;debuggingWorld&quot;</span>);<br></code></pre></td></tr></table></figure><h5 id="2-SERVER-STREAM"><a href="#2-SERVER-STREAM" class="headerlink" title="2. SERVER_STREAM"></a>2. SERVER_STREAM</h5><p>服务实现类对应的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHelloServerStream</span><span class="hljs-params">(String name, StreamObserver&lt;String&gt; response)</span> </span>&#123;<br>    response.onNext(<span class="hljs-string">&quot;hello:&quot;</span> + name);<br>    response.onNext(<span class="hljs-string">&quot;bye:&quot;</span> + name);<br>    response.onCompleted();<br>&#125;<br></code></pre></td></tr></table></figure><p>服务消费者调用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">helloService.sayHelloServerStream(<span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-keyword">new</span> StreamObserver&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String data)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;收到结果：&quot;</span>+data);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;接收结束&quot;</span>);<br>    &#125;<br>&#125;);<br></code></pre></td></tr></table></figure><h5 id="3-CLIENT-STREAM"><a href="#3-CLIENT-STREAM" class="headerlink" title="3. CLIENT_STREAM"></a>3. CLIENT_STREAM</h5><p>也叫双端流</p><p>服务实现类对应的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> StreamObserver&lt;String&gt; <span class="hljs-title">sayHelloStream</span><span class="hljs-params">(StreamObserver&lt;String&gt; response)</span> </span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StreamObserver&lt;String&gt;() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String data)</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;服务端接收：&quot;</span>+data);<br>            <span class="hljs-comment">// 服务端响应</span><br>            response.onNext(<span class="hljs-string">&quot;hello &quot;</span>+ data);<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;<br>        &#125;<br><br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;服务端接收结束&quot;</span>);<br>            response.onCompleted();<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>服务消费者调用方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java">StreamObserver&lt;String&gt; streamObserver = helloService.sayHelloStream(<span class="hljs-keyword">new</span> StreamObserver&lt;String&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onNext</span><span class="hljs-params">(String data)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;客户端收到：&quot;</span>+data);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onError</span><span class="hljs-params">(Throwable throwable)</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onCompleted</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;客户端接收结束&quot;</span>);<br><br>    &#125;<br>&#125;);<br>streamObserver.onNext(<span class="hljs-string">&quot;debugging&quot;</span>);<br>streamObserver.onNext(<span class="hljs-string">&quot;world&quot;</span>);<br>streamObserver.onCompleted();<br></code></pre></td></tr></table></figure><p>测试：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306020224620.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306020238672.png"></p><h5 id="4-BI-STREAM"><a href="#4-BI-STREAM" class="headerlink" title="4 BI_STREAM"></a>4 BI_STREAM</h5><p>和 CLIENT_STREAM 一样</p><h3 id="4-Dubbo3-0-跨语言调用"><a href="#4-Dubbo3-0-跨语言调用" class="headerlink" title="4. Dubbo3.0 跨语言调用"></a>4. Dubbo3.0 跨语言调用</h3><p>Dubbo 一开始是用 Java 语言实现的，那现在就需要一个 go 语言实现的 Dubbo 框架，也就是现在的 dubbo-go，然后在 go 项目中引入 dubbo-go，从而可以在 go 项目中使用 dubbo，比如使用 go 语言去暴露和使用 Dubbo 服务。</p><p>在使用 Java 语言开发一个 Dubbo 服务时，会把服务接口和相关类，单独抽象成为一个 Maven 项目，实际上就相当于一个单独的 jar 包，这个 jar 能被 Java 项目所使用，但不能被 go 项目所使用，所以 go 项目中该如何使用 Java 语言所定义的接口呢？直接用是不太可能的，只能通过间接的方式来解决这个问题，除开 Java 语言之外，那有没有其他技术也能定义接口呢？并且该技术也是 Java 和 go 都支持，这就是 protobuf。</p><h4 id="4-1-protobuf"><a href="#4-1-protobuf" class="headerlink" title="4.1 protobuf"></a>4.1 protobuf</h4><p>我们可以通过 protobuf 来定义接口，然后通过 protobuf 的编译器将接口编译为特定语言的实现。</p><p>在 provider 项目中定义一个 orderservice.proto 文件，路径为 src/main/proto/userservorderservicece.proto</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs protobuf">syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-keyword">package</span> api;<br><br><span class="hljs-keyword">option</span> go_package = <span class="hljs-string">&quot;./;api&quot;</span>;<br><span class="hljs-keyword">option</span> java_multiple_files = <span class="hljs-literal">true</span>;<br><span class="hljs-keyword">option</span> java_package = <span class="hljs-string">&quot;com.debuggingWorld&quot;</span>;<br><span class="hljs-keyword">option</span> java_outer_classname = <span class="hljs-string">&quot;OrderServiceProto&quot;</span>;<br><br><span class="hljs-class"><span class="hljs-keyword">service</span> <span class="hljs-title">OrderService</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">rpc</span> GetOrderByUserId (OrderRequest ) <span class="hljs-keyword">returns</span> (OrderResponse) </span>&#123;&#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">OrderRequest</span> </span>&#123;<br>  <span class="hljs-built_in">string</span> userId = <span class="hljs-number">1</span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">message</span> <span class="hljs-title">OrderResponse</span> </span>&#123;<br>  <span class="hljs-built_in">int32</span> code = <span class="hljs-number">1</span>;<br>  <span class="hljs-built_in">string</span> msg = <span class="hljs-number">2</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义 OrderService 服务，并且定义了一个 GetOrderByUserId 方法，接收 OrderRequest 类型的参数，返回 OrderResponse 类型的对象。</p><h4 id="4-2-编译成-Java"><a href="#4-2-编译成-Java" class="headerlink" title="4.2 编译成 Java"></a>4.2 编译成 Java</h4><p>在 provider 项目中的 pom 文件中添加相关 maven 插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">extensions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">extension</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>kr.motd.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>os-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">extension</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">extensions</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-compiler-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.7.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">target</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">target</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.xolstice.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>protobuf-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.6.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">protocArtifact</span>&gt;</span>com.google.protobuf:protoc:3.7.1:exe:$&#123;os.detected.classifier&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">protocArtifact</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>&gt;</span>build/generated/source/proto/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">outputDirectory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">clearOutputDirectory</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">clearOutputDirectory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">protocPlugins</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">protocPlugin</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.dubbo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>dubbo-compiler<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>0.0.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">mainClass</span>&gt;</span>org.apache.dubbo.gen.dubbo.Dubbo3Generator<span class="hljs-tag">&lt;/<span class="hljs-name">mainClass</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">protocPlugin</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">protocPlugins</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>test-compile<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.codehaus.mojo<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>build-helper-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>generate-sources<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>add-source<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                        <span class="hljs-tag">&lt;<span class="hljs-name">sources</span>&gt;</span><br>                            <span class="hljs-tag">&lt;<span class="hljs-name">source</span>&gt;</span>build/generated/source/proto/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">source</span>&gt;</span><br>                        <span class="hljs-tag">&lt;/<span class="hljs-name">sources</span>&gt;</span><br>                    <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>并且把 common 依赖去掉，然后运行 provider 中 lifecycle 的 compile，就会进行编译了。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306132230080.png"></p><p>其中就包括了一个 OrderService 接口，所以我们的 OrderServiceImpl 就可以实现这个接口了：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DubboService</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderServiceImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">OrderService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> OrderResponse <span class="hljs-title">getOrderByUserId</span><span class="hljs-params">(OrderRequest request)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> OrderResponse.newBuilder().setCode(<span class="hljs-number">1</span>).setMsg(<span class="hljs-string">&quot;success&quot;</span>).build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-go-消费者调用-java-服务"><a href="#4-3-go-消费者调用-java-服务" class="headerlink" title="4.3 go 消费者调用 java 服务"></a>4.3 go 消费者调用 java 服务</h4><p>首先，新建一个 go 模块，然后把 orderservice.proto 复制到 go-consumer/proto下，然后进行编译，编译成为 go 语言对应的服务代码，只不过 go 语言中没有 maven 可以帮助我们编译，只能用原生的 protobuf 的编译器进行编译。</p><p>下载、安装 protobuf的编译器：protoc</p><ol><li>下载地址：<a href="https://github.com/protocolbuffers/protobuf/releases/download/v3.20.1/protoc-3.20.1-win64.zip">https://github.com/protocolbuffers/protobuf/releases/download/v3.20.1/protoc-3.20.1-win64.zip</a></li><li>解压之后，把 protoc-3.20.1-win64\bin 添加到环境变量中</li><li>在 cmd 中执行 protoc –version，能正常看到版本号即表示安装成功</li></ol><p>然后在 go-consumer 下新建文件夹 api，进入到 go-consumer/proto下，运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell">go env -w GO111MODULE=on<br>go env -w GOPROXY=https://goproxy.cn,direct<br><br>go get -u github.com/dubbogo/tools/cmd/protoc-gen-go-triple<br>go install github.com/golang/protobuf/protoc-gen-go<br>go install github.com/dubbogo/tools/cmd/protoc-gen-go-triple<br><br>protoc -I. orderservice.proto  --go_out=../api --go-triple_out=../api<br></code></pre></td></tr></table></figure><p>这样就会在 go-consumer/api 下生成一个 orderservice.pb.go 文件和 orderservice_triple.pb.go 文件。</p><p>然后就可以写 go 语言的服务消费者了，新建一个 consumer.go：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> (<br>   <span class="hljs-string">&quot;context&quot;</span><br>   <span class="hljs-string">&quot;dubbo.apache.org/dubbo-go/v3/common/logger&quot;</span><br>   <span class="hljs-string">&quot;dubbo.apache.org/dubbo-go/v3/config&quot;</span><br>   _ <span class="hljs-string">&quot;dubbo.apache.org/dubbo-go/v3/imports&quot;</span><br>   <span class="hljs-string">&quot;go-consumer/api&quot;</span><br>)<br><br><span class="hljs-keyword">var</span> userServiceImpl = <span class="hljs-built_in">new</span>(api.OrderServiceClientImpl)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>   config.SetConsumerService(userServiceImpl)<br>   config.Load()<br><br>   logger.Info(<span class="hljs-string">&quot;start to test dubbo&quot;</span>)<br>   req := &amp;api.OrderRequest&#123;<br>      UserId: <span class="hljs-string">&quot;1&quot;</span>,<br>   &#125;<br><br>   order, err := userServiceImpl.GetOrderByUserId(context.Background(), req)<br>   <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>      logger.Error(err)<br>   &#125;<br>   logger.Infof(<span class="hljs-string">&quot;client response result: %v\n&quot;</span>, order)<br>&#125;<br></code></pre></td></tr></table></figure><p>然后在 go-consumer 下新建 conf/dubbogo.yml，用来配置注册中心：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">dubbo:</span><br>  <span class="hljs-attr">registries:</span><br>    <span class="hljs-attr">demoZK:</span><br>      <span class="hljs-attr">protocol:</span> <span class="hljs-string">nacos</span><br>      <span class="hljs-attr">address:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.60</span><span class="hljs-number">.10</span><span class="hljs-string">:8848</span><br>  <span class="hljs-attr">consumer:</span><br>    <span class="hljs-attr">references:</span><br>      <span class="hljs-attr">OrderServiceClientImpl:</span><br>        <span class="hljs-attr">protocol:</span> <span class="hljs-string">tri</span><br>        <span class="hljs-attr">interface:</span> <span class="hljs-string">com.debuggingWorld.OrderService</span><br></code></pre></td></tr></table></figure><p>在 environment 中添加一个参数：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306140029900.png"></p><p>运行测试：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202306140030133.png"></p>]]></content>
    
    
    <categories>
      
      <category>Dubbo</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring-Cloud-Alibaba——微服务调用Feign&amp;Dubbo</title>
    <link href="/2023/05/16/Spring-Cloud-Alibaba%E2%80%94%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8Feign-Dubbo/"/>
    <url>/2023/05/16/Spring-Cloud-Alibaba%E2%80%94%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E8%B0%83%E7%94%A8Feign-Dubbo/</url>
    
    <content type="html"><![CDATA[<h3 id="1-RPC-概述"><a href="#1-RPC-概述" class="headerlink" title="1. RPC  概述"></a>1. RPC  概述</h3><p>RPC 全称是 Remote Procedure Call ，即远程过程调用，与其对应的是本地调用。RPC 的目的是：让调用远程方法像调用本地方法一样。</p><p><strong>RPC框架架构：</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305160141779.png"></p><h3 id="2-Spring-Cloud-整合-Feign"><a href="#2-Spring-Cloud-整合-Feign" class="headerlink" title="2.  Spring Cloud 整合 Feign"></a>2.  Spring Cloud 整合 Feign</h3><p>Feign 是 Netflix 开发的声明式、模板化的 HTTP 客户端，Feign 可帮助我们更加便捷、优雅地调用 HTTP API。</p><p>Feign 可以做到使用 HTTP 请求远程服务时就像调用本地方法一样的体验，开发者完全感知不到这是远程方法，更感知不到这是个 HTTP 请求。它像 Dubbo 一样，consumer 直接调用接口方法调用 provider，而不需要通过常规的 Http Client 构造请求再解析返回数据。它解决了让开发者调用远程接口就跟调用本地方法一样，无需关注与远程的交互细节，更无需关注分布式环境开发。</p><p>Spring Cloud openfeign 对 Feign 进行了增强，使其支持 Spring MVC 注解，另外还整合了Ribbon 和 Eureka，从而使得 Feign 的使用更加方便。</p><p><a href="https://blog.csdn.net/qq_41573234/article/details/106663378">Feign 和 OpenFeign 的区别</a></p><h4 id="2-1-Feign-的设计架构"><a href="#2-1-Feign-的设计架构" class="headerlink" title="2.1 Feign 的设计架构"></a>2.1 Feign 的设计架构</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305160147082.png"></p><h4 id="2-2-Spring-Cloud-Alibaba-快速整合-Feign"><a href="#2-2-Spring-Cloud-Alibaba-快速整合-Feign" class="headerlink" title="2.2  Spring Cloud Alibaba 快速整合 Feign"></a>2.2  Spring Cloud Alibaba 快速整合 Feign</h4><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- openfeign 远程调用 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>【注】：openfeign 使用 Ribbon 作为负载均衡。</p></li><li><p>编写调用接口 + @FeignClient 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;mall-order&quot;, path = &quot;/order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderFeignService</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/findOrderByUserId/&#123;userId&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">findOrderByUserId</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;userId&quot;)</span> Integer userId)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>发起调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> OrderFeignService orderFeignService;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">UserController</span><span class="hljs-params">(OrderFeignService orderFeignService)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.orderFeignService = orderFeignService;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/getOrderByUserId/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">findOrderByUserId</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> orderFeignService.findOrderByUserId(id);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>启动类上添加 @EnableFeignClients 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableFeignClients</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MallUserApplication</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(MallUserApplication.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-3-Spring-Cloud-Feign-扩展"><a href="#2-3-Spring-Cloud-Feign-扩展" class="headerlink" title="2.3 Spring Cloud Feign 扩展"></a>2.3 Spring Cloud Feign 扩展</h4><p>Feign 提供了很多的扩展机制，让用户可以更加灵活的使用。</p><h5 id="1-日志配置"><a href="#1-日志配置" class="headerlink" title="1. 日志配置"></a>1. 日志配置</h5><p>有时候我们遇到 Bug，比如接口调用失败、参数没收到等问题，或者想看看调用性能，就需要配置 Feign 的日志了，以此让 Feign 把请求信息输出来。</p><ol><li><p>全局配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> feign.Logger;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-keyword">public</span> Logger.<span class="hljs-function">Level <span class="hljs-title">feignLoggerLevel</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Logger.Level.FULL;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305242331203.png"></p><ul><li><strong>NONE</strong>【性能最佳，适用于生产】：不记录任何日志（默认值）。</li><li><strong>BASIC</strong>【适用于生产环境追踪问题】：仅记录请求方法、URL、响应状态代码以及执行时间。</li><li><strong>HEADERS</strong>：记录BASIC级别的基础上，记录请求和响应的header。</li><li><strong>FULL</strong>【比较适用于开发及测试环境定位问题】：记录请求和响应的header、body和元数据。</li></ul></li><li><p>局部配置</p><p>让调用的微服务生效</p><p><strong>方法一：</strong></p><p>在 @FeignClient 注解中指定使用的配置类</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305242322235.png"></p><p>【注】此时 FeignConfig 不能添加 @Configuration</p><p><strong>方法二：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">mall-order:</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span><br></code></pre></td></tr></table></figure></li></ol><p>【注】在配置文件中配置 FeignClient 的日志级别才能正常输出日志。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">com.debuggingWorld.user.service:</span> <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h5 id="2-契约配置"><a href="#2-契约配置" class="headerlink" title="2. 契约配置"></a>2. 契约配置</h5><p>Spring Cloud 在 Feign 的基础上做了扩展，可以让 Feign 支持 Spring MVC 的注解来调用。原生的 Feign 是不支持 Spring MVC 注解的，如果你想在 Spring Cloud 中使用原生的注解方式来定义客户端也是可以的，通过配置契约来改变这个配置，Spring Cloud 中默认的是 SpringMvcContract。</p><ol><li><p>修改契约配置，支持 Feign 原生的注解</p><p><strong>全局配置：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Contract <span class="hljs-title">feignContract</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Contract.Default();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>局部配置：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">mall-order:</span><br>        <span class="hljs-attr">loggerLevel:</span> <span class="hljs-string">FULL</span><br>        <span class="hljs-attr">contract:</span> <span class="hljs-string">feign.Contract.Default</span>   <span class="hljs-comment">#指定Feign原生注解契约配置</span><br></code></pre></td></tr></table></figure></li><li><p>使用 Feign 原生的注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FeignClient(value = &quot;mall-order&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">OrderFeignService</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@RequestLine(&quot;POST /order/findOrderByUserId/&#123;userId&#125;&quot;)</span><br>    <span class="hljs-function">ResponseEntity <span class="hljs-title">findOrderByUserId</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;userId&quot;)</span> Integer userId)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>【注】注意是 @Param</p></li></ol><h5 id="3-通过拦截器实现参数传递"><a href="#3-通过拦截器实现参数传递" class="headerlink" title="3. 通过拦截器实现参数传递"></a>3. 通过拦截器实现参数传递</h5><p>通常我们调用的接口都是有权限控制的，很多时候可能认证的值是通过参数去传递的，还有就是通过请求头去传递认证信息，比如 Basic 认证方式。<br>Feign 可以直接配置 Basic 认证：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BasicAuthRequestInterceptor <span class="hljs-title">basicAuthRequestInterceptor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BasicAuthRequestInterceptor(<span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305282109435.png"></p><p>**扩展点： feign.RequestInterceptor **</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">RequestInterceptor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(RequestTemplate template)</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicAuthRequestInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RequestInterceptor</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用场景：</strong></p><ol><li>统一添加 header 信息</li><li>对 body 中的信息做修改或替换</li></ol><p><strong>自定义拦截器实现认证逻辑：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignAuthRequestInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">RequestInterceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">apply</span><span class="hljs-params">(RequestTemplate requestTemplate)</span> </span>&#123;<br>        <span class="hljs-comment">// 业务逻辑</span><br>        String access_token = UUID.randomUUID().toString();<br>        requestTemplate.header(<span class="hljs-string">&quot;Authorization&quot;</span>,access_token);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FeignAuthRequestInterceptor <span class="hljs-title">feignAuthRequestInterceptor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FeignAuthRequestInterceptor();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>可以在 yml 中配置：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">mall-order:</span><br>        <span class="hljs-string">requestInterceptors[0]:</span><br>          <span class="hljs-string">com.debuggingWorld.user.config.FeignAuthRequestInterceptor</span><br></code></pre></td></tr></table></figure><p>mall-order 端可以通过 @RequestHeader 获取请求参数，建议在 filter,interceptor 中处理。</p><h5 id="4-超时时间配置"><a href="#4-超时时间配置" class="headerlink" title="4. 超时时间配置"></a>4. 超时时间配置</h5><p>通过 Options 可以配置连接超时时间和读取超时时间，Options 的第一个参数是连接的超时时间（ms），默认值是 2s；第二个是请求处理的超时时间（ms），默认值是 5s。</p><p><strong>全局配置：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-keyword">public</span> Request.<span class="hljs-function">Options <span class="hljs-title">options</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Request.Options(<span class="hljs-number">5000</span>, <span class="hljs-number">4000</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>局部配置：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">mall-order:</span><br>        <span class="hljs-attr">connectTimeout:</span> <span class="hljs-number">5000</span><br>        <span class="hljs-attr">readTimeout:</span> <span class="hljs-number">4000</span><br></code></pre></td></tr></table></figure><p>【注】Feign 的底层用的是 Ribbon，但超时时间以 Feign 配置为准。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305282248343.png"></p><h5 id="5-客户端组件配置"><a href="#5-客户端组件配置" class="headerlink" title="5. 客户端组件配置"></a>5. 客户端组件配置</h5><p>Feign 中默认使用 JDK 原生的 URLConnection 发送 HTTP 请求，我们可以集成别的组件来替换掉 URLConnection，比如 Apache HttpClient，OkHttp。<br>Feign 发起调用真正执行逻辑：<strong>feign.Client#execute   （扩展点）</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305282324338.png"></p><p><strong>配置 Apache HttpClient</strong></p><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.httpcomponents<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.5.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-httpclient<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>10.1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在 yml 配置中启用 Feign 的 Apache HttpClient</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">httpclient:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol><p>关于配置可参考源码： org.springframework.cloud.openfeign.FeignAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnClass(ApacheHttpClient.class)</span><br><span class="hljs-meta">@ConditionalOnMissingClass(&quot;com.netflix.loadbalancer.ILoadBalancer&quot;)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(CloseableHttpClient.class)</span><br><span class="hljs-meta">@ConditionalOnProperty(value = &quot;feign.httpclient.enabled&quot;, matchIfMissing = true)</span><br><span class="hljs-meta">@Conditional(HttpClient5DisabledConditions.class)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpClientFeignConfiguration</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>配置 OkHttp</strong></p><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.github.openfeign<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>     <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>feign-okhttp<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>在 yml 配置中禁用 Feign 的 HttpClient ，启用 OkHttp</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">httpclient:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br>  <span class="hljs-attr">okhttp:</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol><p>配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@ConditionalOnClass(OkHttpClient.class)</span><br><span class="hljs-meta">@ConditionalOnMissingClass(&quot;com.netflix.loadbalancer.ILoadBalancer&quot;)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(okhttp3.OkHttpClient.class)</span><br><span class="hljs-meta">@ConditionalOnProperty(&quot;feign.okhttp.enabled&quot;)</span><br><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OkHttpFeignConfiguration</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="6-GZIP-压缩配置"><a href="#6-GZIP-压缩配置" class="headerlink" title="6. GZIP 压缩配置"></a>6. GZIP 压缩配置</h5><p>开启压缩可以有效节约网络资源，提升接口性能，我们可以配置 GZIP 来压缩数据：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">compression:</span><br>    <span class="hljs-attr">request:</span><br>      <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br>      <span class="hljs-comment"># 配置压缩的类型</span><br>      <span class="hljs-attr">mime-types:</span> <span class="hljs-string">text/xml,application/xml,application/json</span><br>      <span class="hljs-comment"># 最小压缩值</span><br>      <span class="hljs-attr">min-request-size:</span> <span class="hljs-number">2048</span><br>    <span class="hljs-attr">response:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305290137530.png"></p><p>【注】<strong>只有当 Feign 的 Http Client 不是 okhttp3 的时候</strong>，压缩才会生效，配置源码在 FeignAcceptGzipEncodingAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@EnableConfigurationProperties(FeignClientEncodingProperties.class)</span><br><span class="hljs-meta">@ConditionalOnClass(Feign.class)</span><br><span class="hljs-meta">@ConditionalOnBean(Client.class)</span><br><span class="hljs-meta">@ConditionalOnProperty(value = &quot;feign.compression.response.enabled&quot;,</span><br><span class="hljs-meta">      matchIfMissing = false)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(type = &quot;okhttp3.OkHttpClient&quot;)</span><br><span class="hljs-meta">@AutoConfigureAfter(FeignAutoConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FeignAcceptGzipEncodingAutoConfiguration</span> </span>&#123;<br><br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> FeignAcceptGzipEncodingInterceptor <span class="hljs-title">feignAcceptGzipEncodingInterceptor</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">         FeignClientEncodingProperties properties)</span> </span>&#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FeignAcceptGzipEncodingInterceptor(properties);<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="7-编码器解码器配置"><a href="#7-编码器解码器配置" class="headerlink" title="7. 编码器解码器配置"></a>7. 编码器解码器配置</h5><p>Feign 中提供了自定义的编码解码器设置，同时也提供了多种编码器的实现，比如 Gson、Jaxb、Jackson。我们可以用不同的编码解码器来处理数据的传输。如果你想传输 XML 格式的数据，可以自定义 XML 编码解码器来实现获取使用官方提供的 Jaxb。</p><p>扩展点：Encoder &amp; Decoder </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Decoder</span> </span>&#123;<br>  <span class="hljs-function">Object <span class="hljs-title">decode</span><span class="hljs-params">(Response response, Type type)</span> <span class="hljs-keyword">throws</span> IOException, DecodeException, FeignException</span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Encoder</span> </span>&#123;<br>  <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">encode</span><span class="hljs-params">(Object object, Type bodyType, RequestTemplate template)</span> <span class="hljs-keyword">throws</span> EncodeException</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Java配置方式：</strong></p><p>配置编码解码器只需要在 Feign 的配置类中注册 Decoder 和 Encoder 这两个类即可:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Decoder <span class="hljs-title">decoder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JacksonDecoder();<br>&#125;<br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Encoder <span class="hljs-title">encoder</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JacksonEncoder();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>yml配置方式：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">feign:</span><br>  <span class="hljs-attr">client:</span><br>    <span class="hljs-attr">config:</span><br>      <span class="hljs-attr">mall-order:</span><br>        <span class="hljs-comment"># 配置编解码器</span><br>        <span class="hljs-attr">encoder:</span> <span class="hljs-string">feign.jackson.JacksonEncoder</span><br>        <span class="hljs-attr">decoder:</span> <span class="hljs-string">feign.jackson.JacksonDecoder</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud Alibaba</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Dubbo</tag>
      
      <tag>Spring Cloud Alibaba</tag>
      
      <tag>Feign</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Alibaba——负载均衡器Ribbon&amp;LoadBalancer</title>
    <link href="/2023/05/14/Spring-Cloud-Alibaba%E2%80%94%E2%80%94%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8Ribbon-LoadBalancer/"/>
    <url>/2023/05/14/Spring-Cloud-Alibaba%E2%80%94%E2%80%94%E8%B4%9F%E8%BD%BD%E5%9D%87%E8%A1%A1%E5%99%A8Ribbon-LoadBalancer/</url>
    
    <content type="html"><![CDATA[<h3 id="1-负载均衡"><a href="#1-负载均衡" class="headerlink" title="1. 负载均衡"></a>1. 负载均衡</h3><p>负载均衡（Load Balance），其含义就是指将负载（工作任务）进行平衡、分摊到多个操作单元上进行运行，例如 FTP 服务器、Web 服务器、企业核心应用服务器和其它主要任务服务器等，从而协同完成工作任务。</p><p>目前主流的负载均衡方案分为以下两种：</p><ul><li>集中式负载均衡，在消费者和服务提供方中间使用独立的代理方式进行负载，有硬件的（比如 F5），也有软件的（比如 Nginx）。</li><li>客户端根据自己的请求情况做负载均衡，Ribbon 就属于客户端自己做负载均衡。</li></ul><h4 id="1-1-客户端的负载均衡"><a href="#1-1-客户端的负载均衡" class="headerlink" title="1.1 客户端的负载均衡"></a>1.1 客户端的负载均衡</h4><p>例如 spring cloud 中的 ribbon，客户端会有一个服务器地址列表，在发送请求前通过负载均衡算法选择一个服务器，然后进行访问，这是客户端负载均衡；即在客户端就进行负载均衡算法分配。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305141316164.png"></p><h4 id="1-2-服务端的负载均衡"><a href="#1-2-服务端的负载均衡" class="headerlink" title="1.2 服务端的负载均衡"></a>1.2 服务端的负载均衡</h4><p>例如 Nginx，通过 Nginx 进行负载均衡，先发送请求，然后通过负载均衡算法在多个服务器之间选择一个进行访问。即在服务器端再进行负载均衡算法分配。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305141318624.png"></p><h4 id="1-3-常见负载均衡算法"><a href="#1-3-常见负载均衡算法" class="headerlink" title="1.3  常见负载均衡算法"></a>1.3  常见负载均衡算法</h4><ul><li>随机：通过随机选择服务进行执行，一般这种方式使用较少;</li><li>轮训：负载均衡默认实现方式，请求来之后排队处理;</li><li>加权轮训：通过对服务器性能的分型，给高配置，低负载的服务器分配更高的权重，均衡各个服务器的压力;</li><li>地址 hash：通过客户端请求的地址的hash值取模映射进行服务器调度。</li><li>最小连接数：即使请求均衡了，压力不一定会均衡，最小连接数法就是根据服务器的情况，比如请求积压数等参数，将请求分配到当前压力最小的服务器上。 </li></ul><h3 id="2-什么是-Ribbon"><a href="#2-什么是-Ribbon" class="headerlink" title="2. 什么是 Ribbon"></a>2. 什么是 Ribbon</h3><p>Spring Cloud Ribbon 是基于 Netflix Ribbon 实现的一套客户端的负载均衡工具，Ribbon 客户端组件提供一系列的完善的配置，如超时，重试等。通过 Load Balancer 获取到服务提供的所有机器实例，Ribbon 会自动基于某种规则（轮询，随机）去调用这些服务。Ribbon 也可以实现我们自己的负载均衡算法。</p><h4 id="2-1-Spring-Cloud-Alibaba-整合-Ribbon-快速开始"><a href="#2-1-Spring-Cloud-Alibaba-整合-Ribbon-快速开始" class="headerlink" title="2.1 Spring Cloud Alibaba 整合 Ribbon 快速开始"></a>2.1 Spring Cloud Alibaba 整合 Ribbon 快速开始</h4><ol><li><p>引入 ribbon 依赖</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--添加ribbon的依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 【注】nacos-discovery 依赖了 ribbon，可以不用再引入 ribbon 依赖</p><p> <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305141339692.png"></p></li><li><p>RestTemplate 添加 @LoadBalanced 注解，让 RestTemplate 在请求时拥有客户端负载均衡的能力。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span>  <span class="hljs-comment">//开启负载均衡</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试，使用微服务名发起调用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br><span class="hljs-meta">@RequestMapping(value = &quot;/getOrderByUserId/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">findOrderByUserId</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;<br>    String url = <span class="hljs-string">&quot;http://mall-order/order/findOrderByUserId/&quot;</span>+id;<br>    <span class="hljs-keyword">return</span> restTemplate.getForObject(url,ResponseEntity.class);<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-2-Ribbon-内核原理"><a href="#2-2-Ribbon-内核原理" class="headerlink" title="2.2  Ribbon 内核原理"></a>2.2  Ribbon 内核原理</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305141346021.png"></p><p><strong>@LoadBalanced 注解原理：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Qualifier</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> LoadBalanced &#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>LoadBalancerAutoConfiguration 中拿到加了 @LoadBalanced 的 RestTemplate。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadBalancerAutoConfiguration</span> </span>&#123;<br><br><span class="hljs-meta">@LoadBalanced</span><br><span class="hljs-meta">@Autowired(required = false)</span><br><span class="hljs-keyword">private</span> List&lt;RestTemplate&gt; restTemplates = Collections.emptyList();<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> SmartInitializingSingleton <span class="hljs-title">loadBalancedRestTemplateInitializerDeprecated</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">final</span> ObjectProvider&lt;List&lt;RestTemplateCustomizer&gt;&gt; restTemplateCustomizers)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> SmartInitializingSingleton() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterSingletonsInstantiated</span><span class="hljs-params">()</span> </span>&#123;<br>                restTemplateCustomizers.ifAvailable((List&lt;RestTemplateCustomizer&gt; customizers) -&gt; &#123;<br>                    <span class="hljs-keyword">for</span> (RestTemplate restTemplate : LoadBalancerAutoConfiguration.<span class="hljs-keyword">this</span>.restTemplates) &#123;<br>                        <span class="hljs-keyword">for</span> (RestTemplateCustomizer customizer : customizers) &#123;<br>                            customizer.customize(restTemplate);<br>                        &#125;<br>                    &#125;<br>                &#125;);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>被 @LoadBalanced 注解的 restTemplate 会被定制，添加 LoadBalancerInterceptor 拦截器。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadBalancerInterceptorConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@ConditionalOnMissingBean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplateCustomizer <span class="hljs-title">restTemplateCustomizer</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">            <span class="hljs-keyword">final</span> LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplateCustomizer() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(RestTemplate restTemplate)</span> </span>&#123;<br>                List&lt;ClientHttpRequestInterceptor&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(<br>                        restTemplate.getInterceptors());<br>                list.add(loadBalancerInterceptor);<br>                restTemplate.setInterceptors(list);<br>            &#125;<br>        &#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>LoadBalancerInterceptor 会获取 LoadBalancerClient，而 RibbonLoadBalancerClient 是其实现类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoadBalancerInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ClientHttpRequestInterceptor</span> </span>&#123;<br><br>   <span class="hljs-keyword">private</span> LoadBalancerClient loadBalancer;<br>   <span class="hljs-keyword">private</span> LoadBalancerRequestFactory requestFactory;<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoadBalancerInterceptor</span><span class="hljs-params">(LoadBalancerClient loadBalancer,</span></span><br><span class="hljs-params"><span class="hljs-function">         LoadBalancerRequestFactory requestFactory)</span> </span>&#123;<br>      <span class="hljs-keyword">this</span>.loadBalancer = loadBalancer;<br>      <span class="hljs-keyword">this</span>.requestFactory = requestFactory;<br>   &#125;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> ClientHttpResponse <span class="hljs-title">intercept</span><span class="hljs-params">(<span class="hljs-keyword">final</span> HttpRequest request, <span class="hljs-keyword">final</span> <span class="hljs-keyword">byte</span>[] body,</span></span><br><span class="hljs-params"><span class="hljs-function">         <span class="hljs-keyword">final</span> ClientHttpRequestExecution execution)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>      <span class="hljs-keyword">final</span> URI originalUri = request.getURI();<br>      String serviceName = originalUri.getHost();<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.loadBalancer.execute(serviceName,<br>            <span class="hljs-keyword">this</span>.requestFactory.createRequest(request, body, execution));<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RibbonLoadBalancerClient</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LoadBalancerClient</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p><font color="red"> 注意： SmartInitializingSingleton 是在所有的 bean 都实例化完成之后才会调用的，所以在 bean 的实例化期间使用 @LoadBalanced 修饰的 restTemplate 是不具备负载均衡作用的。</font></p><p>如果不使用 @LoadBalanced 注解，也可以通过添加 LoadBalancerInterceptor 拦截器让 restTemplate 起到负载均衡器的作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">(LoadBalancerInterceptor loadBalancerInterceptor)</span> </span>&#123;<br>    RestTemplate restTemplate = <span class="hljs-keyword">new</span> RestTemplate();<br>    <span class="hljs-comment">//注入loadBalancerInterceptor 拦截器</span><br>    restTemplate.setInterceptors(Collections.singletonList(loadBalancerInterceptor));<br>    <span class="hljs-keyword">return</span> restTemplate;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-Ribbon-扩展功能"><a href="#2-3-Ribbon-扩展功能" class="headerlink" title="2.3 Ribbon 扩展功能"></a>2.3 Ribbon 扩展功能</h4><h5 id="1-Ribbon-相关接口"><a href="#1-Ribbon-相关接口" class="headerlink" title="1. Ribbon 相关接口"></a>1. Ribbon 相关接口</h5><p>参考： org.springframework.cloud.netflix.ribbon.<strong>RibbonClientConfiguration</strong></p><p><font color="red"><strong>IRule</strong></font>：Ribbon 的负载均衡策略，默认采用 <strong>ZoneAvoidanceRule</strong> 实现，该策略能够在多区域环境下选出最佳区域的实例进行访问。</p><p><font color="red"><strong>ILoadBalancer</strong></font>：负载均衡器，默认采用 <strong>ZoneAwareLoadBalancer</strong> 实现，它具备了区域感知的能力。</p><p><strong>IClientConfig</strong>：Ribbon 的客户端配置，默认采用 <strong>DefaultClientConfigImpl</strong> 实现。</p><p><strong>IPing</strong>：Ribbon 的实例检查策略，默认采用 <strong>DummyPing</strong> 实现，该检查策略是一个特殊的实现，实际上它并不会检查实例是否可用，而是始终返回t rue，默认认为所有服务实例都是可用的。</p><p><strong>ServerList</strong>：服务实例清单的维护机制，默认采用 <strong>ConfigurationBasedServerList</strong> 实现。</p><p><strong>ServerListFilter</strong>：服务实例清单过滤机制，默认采 <strong>ZonePreferenceServerListFilter</strong>，该策略能够优先过滤出与请求方处于同区域的服务实例。    </p><h5 id="2-Ribbon-负载均衡策略"><a href="#2-Ribbon-负载均衡策略" class="headerlink" title="2. Ribbon 负载均衡策略"></a>2. Ribbon 负载均衡策略</h5><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305142220956.png"></p><ol><li><strong>RandomRule</strong>： 随机选择一个 Server。</li><li><strong>RetryRule</strong>： 对选定的负载均衡策略机上重试机制，在一个配置时间段内当选择 Server 不成功，则一直尝试使用 subRule 的方式选择一个可用的 server。</li><li><strong>RoundRobinRule</strong>： 轮询选择， 轮询 index，选择 index 对应位置的 Server。</li><li><strong>AvailabilityFilteringRule</strong>： 过滤掉一直连接失败的被标记为 circuit tripped 的后端 Server，并过滤掉那些高并发的后端 Server 或者使用一个AvailabilityPredicate 来包含过滤 server 的逻辑，其实就是检查 status 里记录的各个 Server 的运行状态。</li><li><strong>BestAvailableRule</strong>： 选择一个最小的并发请求的 Server，逐个考察 Server，如果 Serve r被 tripped 了，则跳过。</li><li><strong>WeightedResponseTimeRule</strong>： 根据响应时间加权，响应时间越长，权重越小，被选中的可能性越低。</li><li><strong>ZoneAvoidanceRule</strong>： 默认的负载均衡策略，即复合判断 Server 所在区域和 Server 的可用性选择 Server，在没有区域的环境下，类似于轮询 。</li><li><strong>NacosRule:</strong>  优先调用同一集群的实例，基于随机权重。</li></ol><h5 id="3-修改默认负载均衡策略"><a href="#3-修改默认负载均衡策略" class="headerlink" title="3. 修改默认负载均衡策略"></a>3. 修改默认负载均衡策略</h5><p><strong>全局配置：</strong>调用的微服务，一律使用指定的负载均衡策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">ribbonRule</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 指定使用 Nacos 提供的负载均衡策略</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NacosRule();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>局部配置</strong>：调用指定微服务时，使用对应的负载均衡策略</p><p>修改 application.yml</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 被调用的微服务名</span><br><span class="hljs-attr">mall-order:</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-comment"># 指定使用 Nacos 提供的负载均衡策略</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.alibaba.cloud.nacos.ribbon.NacosRule</span><br></code></pre></td></tr></table></figure><p>【注】这消费者服务中添加</p><p><strong>实现原理：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// org.springframework.cloud.netflix.ribbon.RibbonClientConfiguration#ribbonRule</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">ribbonRule</span><span class="hljs-params">(IClientConfig config)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.propertiesFactory.isSet(IRule.class, name)) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.propertiesFactory.get(IRule.class, config, name);<br>   &#125;<br>   ZoneAvoidanceRule rule = <span class="hljs-keyword">new</span> ZoneAvoidanceRule();<br>   rule.initWithNiwsConfig(config);<br>   <span class="hljs-keyword">return</span> rule;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PropertiesFactory</span> </span>&#123;<br><br>   <span class="hljs-keyword">private</span> Map&lt;Class, String&gt; classToProperty = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PropertiesFactory</span><span class="hljs-params">()</span> </span>&#123;<br>      classToProperty.put(ILoadBalancer.class, <span class="hljs-string">&quot;NFLoadBalancerClassName&quot;</span>);<br>      classToProperty.put(IPing.class, <span class="hljs-string">&quot;NFLoadBalancerPingClassName&quot;</span>);<br>      classToProperty.put(IRule.class, <span class="hljs-string">&quot;NFLoadBalancerRuleClassName&quot;</span>);<br>      classToProperty.put(ServerList.class, <span class="hljs-string">&quot;NIWSServerListClassName&quot;</span>);<br>      classToProperty.put(ServerListFilter.class, <span class="hljs-string">&quot;NIWSServerListFilterClassName&quot;</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-自定义负载均衡策略"><a href="#4-自定义负载均衡策略" class="headerlink" title="4. 自定义负载均衡策略"></a>4. 自定义负载均衡策略</h5><p>通过实现 IRule 接口可以自定义负载策略，主要的选择服务逻辑在 choose 方法中。</p><ol><li><p>实现基于 Nacos 权重的负载均衡策略</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NacosRandomWithWeightRule</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLoadBalancerRule</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> NacosDiscoveryProperties nacosDiscoveryProperties;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Server <span class="hljs-title">choose</span><span class="hljs-params">(Object key)</span> </span>&#123;<br>        DynamicServerListLoadBalancer loadBalancer = (DynamicServerListLoadBalancer) getLoadBalancer();<br>        String serviceName = loadBalancer.getName();<br>        NamingService namingService = nacosDiscoveryProperties.namingServiceInstance();<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//nacos 基于权重的算法</span><br>            Instance instance = namingService.selectOneHealthyInstance(serviceName);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NacosServer(instance);<br>        &#125; <span class="hljs-keyword">catch</span> (NacosException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initWithNiwsConfig</span><span class="hljs-params">(IClientConfig clientConfig)</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>配置自定义的策略</p><p><strong>全局配置：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> IRule <span class="hljs-title">ribbonRule</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NacosRandomWithWeightRule();<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>局部配置：</strong> </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mall-order:</span><br>  <span class="hljs-attr">ribbon:</span><br>    <span class="hljs-attr">NFLoadBalancerRuleClassName:</span> <span class="hljs-string">com.debuggingWorld.user.config.NacosRandomWithWeightRule</span><br></code></pre></td></tr></table></figure></li></ol><h5 id="5-饥饿加载"><a href="#5-饥饿加载" class="headerlink" title="5. 饥饿加载"></a>5. 饥饿加载</h5><p>Ribbon 默认懒加载，意味着只有在发起调用的时候才会创建客户端。有可能会导致服务调用超时。</p><p>开启饥饿加载，解决第一次调用慢的问题。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">ribbon:</span><br>  <span class="hljs-attr">eager-load:</span><br>    <span class="hljs-attr">clients:</span> <span class="hljs-string">mall-order</span><br>    <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure><p>参数说明：</p><ul><li>ribbon.eager-load.enabled：开启 ribbon 的饥饿加载模式</li><li>ribbon.eager-load.clients：指定需要饥饿加载的服务名，也就是需要调用的服务，如果有多个服务，则用逗号隔开。</li></ul><h3 id="3-什么是-LoadBalancer"><a href="#3-什么是-LoadBalancer" class="headerlink" title="3. 什么是  LoadBalancer"></a>3. 什么是  LoadBalancer</h3><p>Spring Cloud LoadBalancer 是 Spring Cloud 官方自己提供的客户端负载均衡器, 用来替代 Ribbon。</p><p>Spring 官方提供了两种客户端都可以使用 loadbalancer：</p><p><strong>RestTemplate：</strong></p><p>RestTemplate 是 Spring 提供的用于访问 Rest 服务的客户端，RestTemplate 提供了多种便捷访问远程 Http 服务的方法，能够大大提高客户端的编写效率。默认情况下，RestTemplate 默认依赖 jdk 的 HTTP 连接工具。</p><p><strong>WebClient：</strong></p><p>WebClient 是从 Spring WebFlux 5.0 版本开始提供的一个非阻塞的基于响应式编程的进行 Http 请求的客户端工具。它的响应式编程的基于 Reactor 的。WebClient 中提供了标准 Http 请求方式对应的 get、post、put、delete 等方法，可以用来发起相应的请求。</p><h4 id="3-1-RestTemplate-整合-LoadBalancer"><a href="#3-1-RestTemplate-整合-LoadBalancer" class="headerlink" title="3.1 RestTemplate 整合 LoadBalancer"></a>3.1 RestTemplate 整合 LoadBalancer</h4><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- LoadBalancer --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 提供了RestTemplate支持 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- nacos服务注册与发现  移除ribbon支持--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意： nacos-discovery 中引入了 ribbon，需要移除 ribbon 的包。</p><p>如果不移除，也可以在 yml 中配置不使用 ribbon。默认情况下，如果同时拥有 RibbonLoadBalancerClient 和 BlockingLoadBalancerClient，为了保持向后兼容性，将使用 RibbonLoadBalancerClient。要覆盖它，可以设置 spring.cloud.loadbalancer.ribbon.enabled 属性为 false。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">mall-user</span><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.60</span><span class="hljs-number">.10</span><span class="hljs-string">:8848</span><br>    <span class="hljs-comment"># 不使用ribbon，使用loadbalancer</span><br>    <span class="hljs-attr">loadbalancer:</span><br>      <span class="hljs-attr">ribbon:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305150103332.png"></p></li><li><p>使用 @LoadBalanced 注解修饰 RestTemplate，开启客户端负载均衡功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/getOrderByUserId/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">findOrderByUserId</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;<br>        String url = <span class="hljs-string">&quot;http://mall-order/order/findOrderByUserId/&quot;</span>+id;<br>        <span class="hljs-keyword">return</span> restTemplate.getForObject(url,ResponseEntity.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="3-2-WebClient-整合-LoadBalancer"><a href="#3-2-WebClient-整合-LoadBalancer" class="headerlink" title="3.2 WebClient 整合 LoadBalancer"></a>3.2 WebClient 整合 LoadBalancer</h4><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- LoadBalancer --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-loadbalancer<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- webflux --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-webflux<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- nacos服务注册与发现 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-ribbon<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置 WebClient 作为负载均衡器的 client</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebClientConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@LoadBalanced</span><br>    <span class="hljs-meta">@Bean</span><br>    WebClient.<span class="hljs-function">Builder <span class="hljs-title">webClientBuilder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> WebClient.builder();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function">WebClient <span class="hljs-title">webClient</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> webClientBuilder().build();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> WebClient webClient;<br><br><span class="hljs-meta">@RequestMapping(value = &quot;/findOrderByUserId2/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&gt; <span class="hljs-title">findOrderByUserIdWithWebClient</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;<br><br>    String url = <span class="hljs-string">&quot;http://mall-order/order/findOrderByUserId/&quot;</span>+id;<br>    <span class="hljs-comment">//基于WebClient</span><br>    Mono&lt;ResponseEntity&gt; result = webClient.get().uri(url)<br>            .retrieve().bodyToMono(ResponseEntity.class);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure><p>原理： 底层会使用ReactiveLoadBalancer</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305150153890.png"></p><p>引入 webFlux：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> ReactorLoadBalancerExchangeFilterFunction lbFunction;<br><br><span class="hljs-meta">@RequestMapping(value = &quot;/findOrderByUserId3/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Mono&lt;ResponseEntity&gt; <span class="hljs-title">findOrderByUserIdWithWebFlux</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;<br><br>    String url = <span class="hljs-string">&quot;http://mall-order/order/findOrderByUserId/&quot;</span>+id;<br>    <span class="hljs-comment">//基于WebClient+webFlux</span><br>    Mono&lt;ResponseEntity&gt; result = WebClient.builder()<br>            .filter(lbFunction)<br>            .build()<br>            .get()<br>            .uri(url)<br>            .retrieve()<br>            .bodyToMono(ResponseEntity.class);<br>    <span class="hljs-keyword">return</span> result;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud Alibaba</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Cloud Alibaba</tag>
      
      <tag>负载均衡器</tag>
      
      <tag>Ribbon</tag>
      
      <tag>LoadBalancer</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Alibaba——注册中心Nacos</title>
    <link href="/2023/05/10/Spring-Cloud-Alibaba%E2%80%94%E2%80%94%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83Nacos/"/>
    <url>/2023/05/10/Spring-Cloud-Alibaba%E2%80%94%E2%80%94%E6%B3%A8%E5%86%8C%E4%B8%AD%E5%BF%83Nacos/</url>
    
    <content type="html"><![CDATA[<h3 id="1-注册中心"><a href="#1-注册中心" class="headerlink" title="1. 注册中心"></a>1. 注册中心</h3><h4 id="1-1-注册中心的作用"><a href="#1-1-注册中心的作用" class="headerlink" title="1.1 注册中心的作用"></a>1.1 注册中心的作用</h4><p>服务注册中心的作用就是服务注册与发现</p><ul><li>服务注册：就是将提供某个服务的模块信息（通常是这个服务的 ip 和端口）注册到一个公共的组件上去。</li><li>服务发现：就是新注册的这个服务模块能够及时的被其他调用者发现。不管是服务新增和服务删减都能实现自动发现。   </li></ul><p>实现服务发现的设计思路：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305100029676.png"></p><h4 id="1-2-注册中心设计思路分析"><a href="#1-2-注册中心设计思路分析" class="headerlink" title="1.2 注册中心设计思路分析"></a>1.2 注册中心设计思路分析</h4><p><a href="https://www.processon.com/view/link/5e71cc85e4b011fcce9d604d">https://www.processon.com/view/link/5e71cc85e4b011fcce9d604d</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305100045698.png"></p><h4 id="1-3-注册中心对比"><a href="#1-3-注册中心对比" class="headerlink" title="1.3 注册中心对比"></a>1.3 注册中心对比</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305100053608.png"></p><h3 id="2-什么是-Nacos"><a href="#2-什么是-Nacos" class="headerlink" title="2. 什么是 Nacos"></a>2. 什么是 Nacos</h3><p>Nacos 是 Dynamic Naming and Configuration Service 的首字母简称；一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</p><p>Nacos 致力于帮助您发现、配置和管理微服务。Nacos 提供了一组简单易用的特性集，帮助您快速实现动态服务发现、服务配置、服务元数据及流量管理。</p><p>Nacos 的关键特性包括:</p><ul><li>服务发现和服务健康监测</li><li>动态配置服务</li><li>动态 DNS 服务</li><li>服务及其元数据管理</li></ul><p>官方文档： <a href="https://nacos.io/zh-cn/docs/what-is-nacos.html">https://nacos.io/zh-cn/docs/what-is-nacos.html</a></p><p>OpenAPI文档：<a href="https://nacos.io/zh-cn/docs/open-api.html">https://nacos.io/zh-cn/docs/open-api.html</a></p><p><strong>Nacos 优势</strong> </p><ul><li><strong>易用</strong>：简单的数据模型，标准的 restfulAPI，易用的控制台，丰富的使用文档。</li><li><strong>稳定</strong>：99.9% 高可用，脱胎于历经阿里巴巴 10 年生产验证的内部产品，支持具有数百万服务的大规模场景，具备企业级 SLA 的开源产品。 </li><li><strong>实时</strong>：数据变更毫秒级推送生效；1w 级，SLA 承诺 1w 实例上下线 1s，99.9% 推送完成；10w 级，SLA 承诺 1w 实例上下线 3s，99.9% 推送完成；100w 级别，SLA 承诺 1w 实例上下线 9s 99.9% 推送完成。 </li><li><strong>规模：</strong>十万级服务/配置，百万级连接，具备强大扩展性。</li></ul><h3 id="3-Nacos-作为注册中心"><a href="#3-Nacos-作为注册中心" class="headerlink" title="3. Nacos 作为注册中心"></a>3. Nacos 作为注册中心</h3><h4 id="3-1-Nacos-注册中心架构和基本概念"><a href="#3-1-Nacos-注册中心架构和基本概念" class="headerlink" title="3.1 Nacos 注册中心架构和基本概念"></a>3.1 Nacos 注册中心架构和基本概念</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305100111058.png"></p><ul><li><p><strong>服务 (Service)</strong></p><p>服务是指一个或一组软件功能（例如特定信息的检索或一组操作的执行），其目的是不同的客户端可以为不同的目的重用（例如通过跨进程的网络调用）。Nacos 支持主流的服务生态，如 Kubernetes Service、gRPC|Dubbo RPC Service 或者 Spring Cloud RESTful Service。</p></li><li><p><strong>服务注册中心 (Service Registry)</strong></p><p>服务注册中心，它是服务及其实例和元数据的数据库。服务实例在启动时注册到服务注册表，并在关闭时注销。服务和路由器的客户端查询服务注册表以查找服务的可用实例。服务注册中心可能会调用服务实例的健康检查 API 来验证它是否能够处理请求。</p></li><li><p><strong>服务元数据 (Service Metadata)</strong></p><p>服务元数据是指包括服务端点(endpoints)、服务标签、服务版本号、服务实例权重、路由规则、安全策略等描述服务的数据。</p></li><li><p><strong>服务提供方 (Service Provider)</strong></p><p>是指提供可复用和可调用服务的应用方。</p></li><li><p><strong>服务消费方 (Service Consumer)</strong></p><p>是指会发起对某个服务调用的应用方。</p></li></ul><h4 id="3-2-Nacos-注册中心核心功能"><a href="#3-2-Nacos-注册中心核心功能" class="headerlink" title="3.2 Nacos 注册中心核心功能"></a>3.2 Nacos 注册中心核心功能</h4><p><strong>服务注册</strong>：Nacos Client 会通过发送 REST 请求的方式向 Nacos Server 注册自己的服务，提供自身的元数据，比如 ip 地址、端口等信息。Nacos Server 接收到注册请求后，就会把这些元数据信息存储在一个双层的内存 Map 中。</p><p><strong>服务心跳</strong>：在服务注册后，Nacos Client 会维护一个定时心跳来持续通知 Nacos Server，说明服务一直处于可用状态，防止被剔除。默认5s发送一次心跳。</p><p><strong>服务同步</strong>：Nacos Server 集群之间会互相同步服务实例，用来保证服务信息的一致性。    </p><p><strong>服务发现</strong>：服务消费者（Nacos Client）在调用服务提供者的服务时，会发送一个 REST 请求给 Nacos Server，获取上面注册的服务清单，并且缓存在 Nacos Client 本地，同时会在 Nacos Client 本地开启一个定时任务定时拉取服务端最新的注册表信息更新到本地缓存。</p><p><strong>服务健康检查</strong>：Nacos Server 会开启一个定时任务用来检查注册服务实例的健康情况，对于超过 15s 没有收到客户端心跳的实例会将它的 healthy 属性置为false(客户端服务发现时不会发现)，如果某个实例超过30秒没有收到心跳，直接剔除该实例(被剔除的实例如果恢复发送心跳则会重新注册)</p><h4 id="3-3-Nacos-注册中心（Nacos-Server）环境搭建"><a href="#3-3-Nacos-注册中心（Nacos-Server）环境搭建" class="headerlink" title="3.3 Nacos 注册中心（Nacos Server）环境搭建"></a>3.3 Nacos 注册中心（Nacos Server）环境搭建</h4><p>Nacos 版本： v2.1.0</p><h5 id="1-单机模式"><a href="#1-单机模式" class="headerlink" title="1. 单机模式"></a>1. 单机模式</h5><p>官方文档： <a href="https://nacos.io/zh-cn/docs/deployment.html">https://nacos.io/zh-cn/docs/deployment.html</a></p><p>安装包下载地址：<a href="https://github.com/alibaba/nacos/releases/download/2.1.0/nacos-server-2.1.0.tar.gz">https://github.com/alibaba/nacos/releases/download/2.1.0/nacos-server-2.1.0.tar.gz</a></p><p>解压，进入 nacos 目录，单机模式启动 nacos：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">单机模式启动nacos</span><br>sh startup.sh -m standalone<br></code></pre></td></tr></table></figure><p>也可以修改启动脚本方式：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305100155240.png"></p><p>访问 nacos 的管理端：192.168.60.10:8848/nacos/ ，默认的用户名/密码：nacos/nacos</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305100209397.png"></p><h5 id="2-集群模式"><a href="#2-集群模式" class="headerlink" title="2. 集群模式"></a>2. 集群模式</h5><p>官网文档： <a href="https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html">https://nacos.io/zh-cn/docs/cluster-mode-quick-start.html</a></p><p><strong>1）环境准备</strong></p><ul><li>JDK：需要 1.8 及其以上版本</li><li>建议: 2核 CPU / 4G 内存 及其以上</li><li>建议: 生产环境 3 个节点 及其以上</li></ul><p>注意：在单台服务器上搭建伪集群不能使用连续端口号（比如 8848,8849,8850）， 因为使用 8848（grpc会占用 9848，9849），8849（grpc会占用9849,9850），会导致端口冲突。</p><p>原因：Nacos2.x 版本相比 1.X 新增了 gRPC 的通信方式，因此需要增加 2 个端口。新增端口是在配置的主端口（server.port）基础上，进行一定偏移量自动生成。</p><table><thead><tr><th>端口</th><th>与主端口的偏移量</th><th>描述</th></tr></thead><tbody><tr><td>9848</td><td>1000</td><td>客户端 gRPC 请求服务端端口，用于客户端向服务端发起连接和请求</td></tr><tr><td>9849</td><td>1001</td><td>服务端 gRPC 请求服务端端口，用于服务间同步等</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 准备三台服务器</span><br>192.168.60.10:8848<br>192.168.60.10:8858<br>192.168.60.10:8868<br></code></pre></td></tr></table></figure><p><strong>2）以 192.168.60.10:8848 为例，进入nacos目录</strong></p><ol><li><p>修改 conf/application.properties，使用外置数据源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## If use MySQL as datasource:</span></span><br>spring.datasource.platform=mysql<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## Count of DB:</span></span><br>db.num=1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"><span class="hljs-comment">## Connect URL of DB:</span></span><br>db.url.0=jdbc:mysql://192.168.60.1:3306/nacos_config?characterEncoding=utf8&amp;connectTimeout=1000&amp;socketTimeout=3000&amp;autoReconnect=true&amp;useUnicode=true&amp;useSSL=false&amp;serverTimezone=UTC<br>db.user.0=root<br>db.password.0=mysql<br></code></pre></td></tr></table></figure></li><li><p>将 conf/cluster.conf.example 改为 cluster.conf，添加节点配置</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">it is ip</span><br>192.168.60.10:8848<br>192.168.60.10:8858<br>192.168.60.10:8868        <br></code></pre></td></tr></table></figure><p>注意：不要使用 localhost 或 127.0.0.1，针对多网卡环境，nacos 可以指定网卡或 ip</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">多网卡选择</span><br><span class="hljs-meta">#</span><span class="bash">ip-address参数可以直接设置nacos的ip</span><br><span class="hljs-meta">#</span><span class="bash">该参数设置后，将会使用这个IP去cluster.conf里进行匹配，请确保这个IP的值在cluster.conf里是存在的</span><br>nacos.inetutils.ip-address=192.168.65.206<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">use-only-site-local-interfaces参数可以让nacos使用局域网ip，这个在nacos部署的机器有多网卡时很有用，可以让nacos选择局域网网卡</span><br>nacos.inetutils.use-only-site-local-interfaces=true<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">ignored-interfaces支持网卡数组，可以让nacos忽略多个网卡</span><br>nacos.inetutils.ignored-interfaces[0]=eth0<br>nacos.inetutils.ignored-interfaces[1]=eth1<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">preferred-networks参数可以让nacos优先选择匹配的ip，支持正则匹配和前缀匹配</span><br>nacos.inetutils.preferred-networks[0]=30.5.124.             <br></code></pre></td></tr></table></figure><p>192.168.60.10:8858、192.168.60.10:8868 按同样的方式配置</p></li></ol><p><strong>3) mysql 中创建 nacos 配置数据库</strong></p><p>sql脚本：<a href="https://github.com/alibaba/nacos/blob/2.1.0/distribution/conf/nacos-mysql.sql">https://github.com/alibaba/nacos/blob/2.1.0/distribution/conf/nacos-mysql.sql</a></p><p><strong>4)  如果内存不够，可以调整jvm参数</strong></p><p>startup.sh：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305110002671.png"></p><p><strong>5)  分别启动三个 nacos 实例</strong></p><p>以 192.168.60.10:8848 为例，启动 nacos：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">./bin/startup.sh<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305102257075.png"></p><p><strong>6) 访问 nacos 管理界面</strong></p><p>登录 <a href="http://192.168.60.10:8848/nacos%EF%BC%8C%E7%94%A8%E6%88%B7%E5%90%8D%E5%92%8C%E5%AF%86%E7%A0%81%E9%83%BD%E6%98%AF">http://192.168.60.10:8848/nacos，用户名和密码都是</a> nacos</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305110009140.png"></p><h4 id="3-4-Spring-Cloud-Alibaba-Nacos-快速开始"><a href="#3-4-Spring-Cloud-Alibaba-Nacos-快速开始" class="headerlink" title="3.4 Spring Cloud Alibaba Nacos 快速开始"></a>3.4 Spring Cloud Alibaba Nacos 快速开始</h4><h5 id="1-Spring-Cloud-Alibaba-版本选型"><a href="#1-Spring-Cloud-Alibaba-版本选型" class="headerlink" title="1. Spring Cloud Alibaba 版本选型"></a>1. Spring Cloud Alibaba 版本选型</h5><p>版本说明：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E</a></p><table><thead><tr><th>Spring Cloud Alibaba Version</th><th>Spring Cloud Version</th><th>Spring Boot Version</th><th>Nacos Version</th></tr></thead><tbody><tr><td>2.2.8.RELEASE</td><td>Spring Cloud Hoxton.SR12</td><td>2.3.12.RELEASE</td><td>2.1.0</td></tr></tbody></table><p><strong>父pom配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Hoxton.SR12<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud-alibaba.version</span>&gt;</span>2.2.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud-alibaba.version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud-alibaba.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="2-微服务（Nacos-Client）整合-Nacos-注册中心（Nacos-Server）"><a href="#2-微服务（Nacos-Client）整合-Nacos-注册中心（Nacos-Server）" class="headerlink" title="2. 微服务（Nacos Client）整合 Nacos 注册中心（Nacos Server）"></a>2. 微服务（Nacos Client）整合 Nacos 注册中心（Nacos Server）</h5><p><strong>配置服务提供者 mall-order</strong></p><p>服务提供者可以通过 Nacos 的服务注册发现功能将其服务注册到 Nacos server 上。</p><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置 nacos 注册中心</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8050</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">mall-order</span>  <span class="hljs-comment">#微服务名称</span><br><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.60</span><span class="hljs-number">.10</span><span class="hljs-string">:8848</span><br></code></pre></td></tr></table></figure><p>更多配置：<a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-discovery">https://github.com/alibaba/spring-cloud-alibaba/wiki/Nacos-discovery</a></p><table><thead><tr><th>配置项</th><th>Key</th><th>默认值</th><th>说明</th></tr></thead><tbody><tr><td><code>服务端地址</code></td><td><code>spring.cloud.nacos.discovery.server-addr</code></td><td><code>无</code></td><td><code>Nacos Server 启动监听的ip地址和端口</code></td></tr><tr><td><code>服务名</code></td><td><code>spring.cloud.nacos.discovery.service</code></td><td><code>$&#123;spring.application.name&#125;</code></td><td><code>给当前的服务命名</code></td></tr><tr><td><code>服务分组</code></td><td><code>spring.cloud.nacos.discovery.group</code></td><td><code>DEFAULT_GROUP</code></td><td><code>设置服务所处的分组</code></td></tr><tr><td><code>权重</code></td><td><code>spring.cloud.nacos.discovery.weight</code></td><td><code>1</code></td><td><code>取值范围 1 到 100，数值越大，权重越大</code></td></tr><tr><td><code>网卡名</code></td><td><code>spring.cloud.nacos.discovery.network-interface</code></td><td><code>无</code></td><td><code>当IP未配置时，注册的IP为此网卡所对应的IP地址，如果此项也未配置，则默认取第一块网卡的地址</code></td></tr><tr><td><code>注册的IP地址</code></td><td><code>spring.cloud.nacos.discovery.ip</code></td><td><code>无</code></td><td><code>优先级最高</code></td></tr><tr><td><code>注册的端口</code></td><td><code>spring.cloud.nacos.discovery.port</code></td><td><code>-1</code></td><td><code>默认情况下不用配置，会自动探测</code></td></tr><tr><td><code>命名空间</code></td><td><code>spring.cloud.nacos.discovery.namespace</code></td><td><code>无</code></td><td><code>常用场景之一是不同环境的注册的区分隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</code></td></tr><tr><td><code>AccessKey</code></td><td><code>spring.cloud.nacos.discovery.access-key</code></td><td><code>无</code></td><td><code>当要上阿里云时，阿里云上面的一个云账号名</code></td></tr><tr><td><code>SecretKey</code></td><td><code>spring.cloud.nacos.discovery.secret-key</code></td><td><code>无</code></td><td><code>当要上阿里云时，阿里云上面的一个云账号密码</code></td></tr><tr><td><code>Metadata</code></td><td><code>spring.cloud.nacos.discovery.metadata</code></td><td><code>无</code></td><td><code>使用Map格式配置，用户可以根据自己的需要自定义一些和服务相关的元数据信息</code></td></tr><tr><td><code>日志文件名</code></td><td><code>spring.cloud.nacos.discovery.log-name</code></td><td><code>无</code></td><td></td></tr><tr><td><code>集群</code></td><td><code>spring.cloud.nacos.discovery.cluster-name</code></td><td><code>DEFAULT</code></td><td><code>配置成Nacos集群名称</code></td></tr><tr><td><code>接入点</code></td><td><code>spring.cloud.nacos.discovery.enpoint</code></td><td><code>UTF-8</code></td><td><code>地域的某个服务的入口域名，通过此域名可以动态地拿到服务端地址</code></td></tr><tr><td><code>是否集成Ribbon</code></td><td><code>ribbon.nacos.enabled</code></td><td><code>true</code></td><td><code>一般都设置成true即可</code></td></tr><tr><td><code>是否开启Nacos Watch</code></td><td><code>spring.cloud.nacos.discovery.watch.enabled</code></td><td><code>true</code></td><td><code>可以设置成false来关闭 watch</code></td></tr><tr><td><code>注册的IP地址类型</code></td><td><code>spring.cloud.nacos.discovery.ip-type</code></td><td><code>IPv4</code></td><td><code>可以配置IPv4和IPv6两种类型</code></td></tr></tbody></table></li><li><p>启动服务，查看是否注册成功</p><p>【注】启动类不需要：@EnableDiscoveryClient</p><p>启动两个实例：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305132353346.png"></p><p>nacos 管理端界面查看是否成功注册：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305132357297.png"></p><p>通过 <a href="https://nacos.io/zh-cn/docs/open-api.html">Open API</a> 查询实例列表：</p><p><a href="http://192.168.60.10:8848/nacos/v1/ns/instance/list?serviceName=mall-order">http://192.168.60.10:8848/nacos/v1/ns/instance/list?serviceName=mall-order</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305140001034.png"></p></li></ol><p><strong>配置服务消费者 mall-user</strong></p><p>服务消费者可以通过 Nacos 的服务发现功能从 Nacos server 上获取到它要调用的服务。</p><ol><li><p>引入依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-starter-alibaba-nacos-discovery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>配置 nacos 注册中心 </p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8060</span><br><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">mall-user</span>  <span class="hljs-comment">#微服务名称</span><br><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.60</span><span class="hljs-number">.10</span><span class="hljs-string">:8848</span><br></code></pre></td></tr></table></figure></li><li><p>启动 mall-user，nacos 管理端界面查看是否成功注册</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305140005347.png"></p></li><li><p>使用 RestTemplate 进行服务调用</p><p>给 RestTemplate 实例添加 @LoadBalanced 注解，开启 @LoadBalanced 与 Ribbon 的集成。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RestConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@LoadBalanced</span>  <span class="hljs-comment">// 微服务名替换为具体的ip:port</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> RestTemplate <span class="hljs-title">restTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> RestTemplate();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> RestTemplate restTemplate;<br><br>    <span class="hljs-meta">@RequestMapping(value = &quot;/getOrderByUserId/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity <span class="hljs-title">findOrderByUserId</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer id)</span> </span>&#123;<br>        log.info(<span class="hljs-string">&quot;根据userId:&quot;</span> + id + <span class="hljs-string">&quot;查询订单信息&quot;</span>);<br>        <span class="hljs-comment">// mall-order  ip:port</span><br>        String url = <span class="hljs-string">&quot;http://mall-order/order/findOrderByUserId/&quot;</span> + id;<br>        <span class="hljs-keyword">return</span> restTemplate.getForObject(url, ResponseEntity.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>测试</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305140013477.png"></p></li></ol><h4 id="3-5-Nacos-注册中心常见配置"><a href="#3-5-Nacos-注册中心常见配置" class="headerlink" title="3.5 Nacos 注册中心常见配置"></a>3.5 Nacos 注册中心常见配置</h4><h5 id="1-服务分级存储模型"><a href="#1-服务分级存储模型" class="headerlink" title="1. 服务分级存储模型"></a>1. 服务分级存储模型</h5><p>​    注册中心的核心数据是服务的名字和它对应的网络地址，当服务注册了多个实例时，我们需要对不健康的实例进行过滤或者针对实例的某些特征进行流量的分配，那么就需要在实例上存储一些例如：健康状态、权重等属性。随着服务规模的扩大，渐渐的又需要在整个服务级别设定一些权限规则、 以及对所有实例都生效的一些开关，于是在服务级别又会设立一些属性。再往后，我们又发现单个服务的实例又会有划分为多个子集的需求，例如一个服务是多机房部署的，那么可能需要对每个机房的实例做不同的配置，这样又需要在服务和实例之间再设定一个数据级别。</p><p>Nacos 在经过内部多年生产经验后提炼出的数据模型，则是一种：服务-集群-实例的三层模型。这样基本可以满足服务在所有场景下的数据存储和管理。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305140026153.png"></p><h5 id="2-服务逻辑隔离"><a href="#2-服务逻辑隔离" class="headerlink" title="2. 服务逻辑隔离"></a>2. 服务逻辑隔离</h5><p>Nacos 数据模型 Key 由三元组唯一确定, Namespace 默认是空串，公共命名空间（public），分组默认是 DEFAULT_GROUP。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305140039637.png"></p><h5 id="3-Namespace-隔离设计"><a href="#3-Namespace-隔离设计" class="headerlink" title="3. Namespace 隔离设计"></a>3. Namespace 隔离设计</h5><p>命名空间（Namespace）用于进行租户（用户）粒度的隔离，Namespace 的常用场景之一是不同环境的隔离，例如开发测试环境和生产环境的资源（如配置、服务）隔离等。</p><p>新建命名空间：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305140041268.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305140044281.png"></p><p>修改 yml 配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">application:</span><br>    <span class="hljs-attr">name:</span> <span class="hljs-string">mall-user</span><br><br>  <span class="hljs-attr">cloud:</span><br>    <span class="hljs-attr">nacos:</span><br>      <span class="hljs-attr">discovery:</span><br>        <span class="hljs-attr">server-addr:</span> <span class="hljs-number">192.168</span><span class="hljs-number">.60</span><span class="hljs-number">.10</span><span class="hljs-string">:8848</span><br>        <span class="hljs-attr">namespace:</span> <span class="hljs-string">0bf30700-cc40-48d9-83a1-83262a36324a</span><br></code></pre></td></tr></table></figure><p>启动 mall-user，进入 nacos 控制台可以看到 mall-user 注册成功，所属 namespace 是 debug：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305140051776.png"></p><p>测试：<a href="http://127.0.0.1:8060/user/getOrderByUserId/1%EF%BC%8C%E6%8A%A5%E9%94%99">http://127.0.0.1:8060/user/getOrderByUserId/1，报错</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305140052003.png"></p><p>原因：mall-order 和 mall-user 使用了不同的 namespace，导致服务隔离。</p><h5 id="4-group-服务分组"><a href="#4-group-服务分组" class="headerlink" title="4. group 服务分组"></a>4. group 服务分组</h5><p>不同的服务可以归类到同一分组，group 也可以起到服务隔离的作用。yml 中可以通过 spring.cloud.nacos.discovery.group 参数配置</p><h5 id="5-设置集群"><a href="#5-设置集群" class="headerlink" title="5. 设置集群"></a>5. 设置集群</h5><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">spring.cloud.nacos.discovery.cluster-name</span>: <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><h5 id="6-临时实例和持久化实例"><a href="#6-临时实例和持久化实例" class="headerlink" title="6. 临时实例和持久化实例"></a>6. 临时实例和持久化实例</h5><p>​    在定义上区分临时实例和持久化 实例的关键是健康检查的方式。临时实例使用客户端上报模式，而持久化实例使用服务端反向探测模式。临时实例需要能够自动摘除不健康实例，而且无需持久化存储实例。持久化实例使用服务端探测的健康检查方式，因为客户端不会上报心跳， 所以不能自动摘除下线的实例。</p><p>​    在大中型的公司里，这两种类型的服务往往都有。一些基础的组件例如数据库、缓存等，这些往往不能上报心跳，这种类型的服务在注册时，就需要作为持久化实例注册。而上层的业务服务，例如 微服务或者 Dubbo 服务，服务的 Provider 端支持添加汇报心跳的逻辑，此时就可以使用动态服务的注册方式。</p><p>​    Nacos 1.x 中持久化及非持久化的属性是作为实例的一个元数据进行存储和识别。Nacos 2.x 中继续沿用了持久化及非持久化的设定，但是有了一些调整。在Nacos2.0 中将是否持久化的数据抽象至服务级别， 且不再允许一个服务同时存在持久化实例和非持久化实例，实例的持久化属性继承自服务的持久化属性。   </p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment"># 持久化实例</span><br><span class="hljs-meta">spring.cloud.nacos.discovery.ephemeral</span>: <span class="hljs-string">false </span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud Alibaba</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Cloud Alibaba</tag>
      
      <tag>Nacos</tag>
      
      <tag>注册中心</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Cloud Alibaba——微服务架构</title>
    <link href="/2023/05/09/Spring-Cloud-Alibaba%E2%80%94%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/"/>
    <url>/2023/05/09/Spring-Cloud-Alibaba%E2%80%94%E2%80%94%E5%BE%AE%E6%9C%8D%E5%8A%A1%E6%9E%B6%E6%9E%84/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.processon.com/view/link/60519545f346fb348a97c9d5">https://www.processon.com/view/link/60519545f346fb348a97c9d5</a></p><h3 id="1-单体架构vs微服务架构"><a href="#1-单体架构vs微服务架构" class="headerlink" title="1. 单体架构vs微服务架构"></a>1. 单体架构vs微服务架构</h3><h4 id="1-1-单机架构"><a href="#1-1-单机架构" class="headerlink" title="1.1 单机架构"></a>1.1 单机架构</h4><p>一个归档包（例如 war 格式）包含了应用所有功能的应用程序，我们通常称之为单体应用。架构单体应用的方法论，我们称之为单体应用架构。</p><p><strong>单体架构示意图：</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305090144235.png"></p><p><strong>单体架构的优缺点：</strong></p><p><strong>优点:</strong></p><ul><li> 架构简单明了</li><li>开发，测试，部署简单</li></ul><p><strong>缺点</strong>:</p><ul><li>随着业务扩展，代码越来越复杂，代码质量参差不齐(开发人员的水平不一)，会让你每次提交代码 ，修改每一个小bug都是心惊胆战的。</li><li>部署慢(由于单体架构，功能复杂) 能想像下一个来自200W+代码部署的速度(15分钟)</li><li>扩展成本高，根据单体架构图 假设用户模块是一个 CPU 密集型的模块(涉及到大量的运算)，那么我们需要替换更加牛逼的 CPU，而我们的订单模块是一个 IO密集模块（涉及大量的读写磁盘）,那我们需要替换更加牛逼的内存以及高效的磁盘。但是我们的单体架构上 无法针对单个功能模块进行扩展，那么就需要替换更牛逼的 CPU，更牛逼的内存，更牛逼的磁盘，价格蹭蹭的往上涨。</li><li>阻碍了新技术的发展。。。。。。比如我们的 web 架构模块从 struts2 迁移到 springboot，那么就会成为灾难</li></ul><h4 id="1-2-微服务以及微服务架构"><a href="#1-2-微服务以及微服务架构" class="headerlink" title="1.2 微服务以及微服务架构"></a>1.2 微服务以及微服务架构</h4><h5 id="1-微服务的定义"><a href="#1-微服务的定义" class="headerlink" title="1. 微服务的定义"></a>1. 微服务的定义</h5><p>①：英文:<a href="https://martinfowler.com/articles/microservices.html">https://martinfowler.com/articles/microservices.html</a></p><p>②: 中文:<a href="http://blog.cuicc.com/blog/2015/07/22/microservices">http://blog.cuicc.com/blog/2015/07/22/microservices</a></p><p>微服务核心就是把传统的单机应用，根据业务将单机应用拆分为一个一个的服务，彻底的解耦，每一个服务都是提供特定的功能，一个服务只做一件事,类似进程，每个服务都能够单独部署，甚至可以拥有自己的数据库。这样的一个一个的小服务就是微服务。</p><p>①: 比如传统的单机电商应用，有订单/支付/库存/物流/积分等模块（理解为 service）</p><p>②: 我们根据业务模型来拆分，可以拆分为订单服务、支付服务、库存服务、物流服务、积分服务</p><p>③: 若不拆分的时候，我的非核心业务积分模块出现了重大 bug，系统内存溢出，导致整个服务宕机。若拆分之后，只是积分微服务不可用，整个系统核心功能还是能使用</p><h5 id="2-微服务的特点"><a href="#2-微服务的特点" class="headerlink" title="2. 微服务的特点"></a>2. 微服务的特点</h5><ol><li><p>独立部署，灵活扩展</p><p>传统的单体架构是以整个系统为单位进行部署，而微服务则是以每一个独立组件（例如用户服务，商品服务）为单位进行部署。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305090153507.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305090154315.png"></p></li><li><p>资源的有效隔离</p><p>微服务设计的原则之一，就是每一个微服务拥有独立的数据源，假如微服务 A 想要读写微服务 B 的数据库，只能调用微服务 B 对外暴露的接口来完成。这样有效避免了服务之间争用数据库和缓存资源所带来的问题。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305090156521.png"></p></li><li><p>团队组织架构的调整</p><p>微服务设计的思想也改变了原有的企业研发团队组织架构。传统的研发组织架构是水平架构，前端有前端的团队，后端有后端的团队，DBA有DBA的团队，测试有测试的团队。而微服务的设计思想对团队的划分有着一定的影响，使得团队组织架构的划分更倾向于垂直架构，比如用户业务是一个团队来负责，支付业务是一个团队来负责。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305090158498.png"></p></li></ol><h5 id="3-微服务架构是什么"><a href="#3-微服务架构是什么" class="headerlink" title="3. 微服务架构是什么"></a>3. 微服务架构是什么</h5><p>微服务架构风格是一种将单个应用程序作为一套小型服务开发的方法，每种应用程序都在自己的进程中运行，并与轻量级机制（通常是 HTTP 资源 API）进行通信。 这些服务是围绕业务功能构建的，可以通过全自动部署机制独立部署。 这些服务的集中管理最少，可以用不同的编程语言编写，并使用不同的数据存储技术。</p><p>SOA 架构强调的是异构系统之间的通信和解耦合，而微服务架构强调的是系统按业务边界做细粒度的拆分和部署。</p><p>微服务架构是一个架构风格, 提倡: </p><ul><li>将一个单一应用程序开发为一组小型服务</li><li>每个服务运行在自己的进程中</li><li>服务之间通过轻量级的通信机制(http rest api)</li><li>每个服务都能够独立的部署</li><li>每个服务甚至可以拥有自己的数据库</li></ul><p>微服务以及微服务架构的是二个完全不同的概念。微服务强调的是服务的大小和对外提供的单一功能，而微服务架构是指把 一个一个的微服务组合管理起来，对外提供一套完整的服务。</p><h5 id="4-微服务的优缺点"><a href="#4-微服务的优缺点" class="headerlink" title="4. 微服务的优缺点"></a>4. 微服务的优缺点</h5><p><strong>优点</strong>:</p><ul><li>每个服务足够小，足够内聚，代码更加容易理解,专注一个业务功能点(对比传统应用，可能改几行代码 需要了解整个系统)</li><li> 开发简单，一个服务只干一个事情</li><li>按需伸缩，服务松耦合</li><li>前后端分离, 作为 java 开发人员，我们只要关系后端接口的安全性以及性能，不要去关注页面的人机交互</li><li>一个服务可拥有自己的数据库，也可以多个服务连接同一个数据库。</li></ul><p><strong>缺点</strong>:</p><ul><li>增加了运维人员的工作量，以前只要部署一个war包，现在可能需要部署成百上千个war包 (k8s+docker+jenkins )</li><li>服务之间相互调用，增加通信成本</li><li>数据一致性问题(分布式事务问题)</li><li>性能监控等,问题定位……………………..</li></ul><h3 id="2-Spring-Cloud-微服务技术栈"><a href="#2-Spring-Cloud-微服务技术栈" class="headerlink" title="2. Spring Cloud 微服务技术栈"></a>2. Spring Cloud 微服务技术栈</h3><p>Spring Cloud 是分布式微服务架构的一站式解决方案，是多种微服务架构落地技术的集合体，俗称微服务全家桶。 </p><p>Spring Cloud 为开发人员提供了快速构建分布式系统中的一些常见模式的工具（例如配置管理、服务发现、断路器、智能路由、微代理、控制总线、一次性令牌、全局锁、领导选举、分布式会话、集群状态）。</p><p>官网： <a href="https://spring.io/projects/spring-cloud">https://spring.io/projects/spring-cloud</a></p><p>中文文档： <a href="https://www.springcloud.cc/">https://www.springcloud.cc/</a></p><p>Spring Cloud中国社区：<a href="http://springcloud.cn/">http://springcloud.cn/</a></p><h4 id="2-1-SpringCloud-微服务架构生态圈"><a href="#2-1-SpringCloud-微服务架构生态圈" class="headerlink" title="2.1  SpringCloud 微服务架构生态圈"></a>2.1  SpringCloud 微服务架构生态圈</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305090258232.png"></p><h4 id="2-2-Spring-Cloud-Netflix-包含的组件"><a href="#2-2-Spring-Cloud-Netflix-包含的组件" class="headerlink" title="2.2 Spring Cloud Netflix 包含的组件"></a>2.2 Spring Cloud Netflix 包含的组件</h4><ul><li>Eureka：服务注册和发现，它提供了一个服务注册中心、服务发现的客户端，还有一个方便查看所有注册服务的界面。 </li><li>Zuul：网关，所有的客户端请求通过这个网关访问后台的服务。他可以使用一定的路由配置来判断某一个 URL 由哪个服务来处理。并从 Eureka 获取注册的服务来转发请求。</li><li>Ribbon：即负载均衡，Zuul 网关将一个请求发送给某一个服务的应用的时候，如果一个服务启动了多个实例，就会通过 Ribbon 来通过一定的负载均衡策略来发送给某一个服务实例。</li><li>Feign：服务客户端，服务之间如果需要相互访问，可以使用 RestTemplate，也可以使用 Feign 客户端访问。它默认会使用 Ribbon 来实现负载均衡。</li><li>Hystrix：监控和断路器。我们只需要在服务接口上添加 Hystrix 标签，就可以实现对这个接口的监控和断路器功能。</li><li>Hystrix Dashboard：监控面板，他提供了一个界面，可以监控各个服务上的服务调用所消耗的时间等。</li><li>Turbine：监控聚合，使用 Hystrix 监控，我们需要打开每一个服务实例的监控信息来查看。而 Turbine 可以帮助我们把所有的服务实例的监控信息聚合到一个地方统一查看。这样就不需要挨个打开一个个的页面一个个查看。</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305090254966.png"></p><h4 id="2-3-Spring-Cloud-Alibaba-技术栈"><a href="#2-3-Spring-Cloud-Alibaba-技术栈" class="headerlink" title="2.3 Spring Cloud Alibaba 技术栈"></a>2.3 Spring Cloud Alibaba 技术栈</h4><p>同 Spring Cloud 一样，Spring Cloud Alibaba 也是一套微服务解决方案，包含开发分布式应用微服务的必需组件，方便开发者通过 Spring Cloud 编程模型轻松使用这些组件来开发分布式应用服务。</p><p>依托 Spring Cloud Alibaba，您只需要添加一些注解和少量配置，就可以将 Spring Cloud 应用接入阿里微服务解决方案，通过阿里中间件来迅速搭建分布式应用系统。</p><p>作为 Spring Cloud 体系下的新实现，Spring Cloud Alibaba 跟官方的组件或其它的第三方实现如 Netflix, Consul，Zookeeper 等对比，具备了更多的功能:</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305090230818.png"></p><h5 id="1-Spring-Cloud-Alibaba-包含组件"><a href="#1-Spring-Cloud-Alibaba-包含组件" class="headerlink" title="1. Spring Cloud Alibaba 包含组件"></a>1. Spring Cloud Alibaba 包含组件</h5><p>阿里开源组件</p><ul><li>Nacos：一个更易于构建云原生应用的动态服务发现、配置管理和服务管理平台。</li><li>Sentinel：把流量作为切入点，从流量控制、熔断降级、系统负载保护等多个维度保护服务的稳定性。</li><li>RocketMQ：开源的分布式消息系统，基于高可用分布式集群技术，提供低延时的、高可靠的消息发布与订阅服务。</li><li>Dubbo：在国内应用非常广泛的一款高性能 Java RPC 框架。</li><li>Seata：阿里巴巴开源产品，一个易于使用的高性能微服务分布式事务解决方案。</li><li>Arthas：开源的Java动态追踪工具，基于字节码增强技术，功能非常强大。</li></ul><p>阿里商业化组件</p><ul><li>Alibaba Cloud ACM：一款在分布式架构环境中对应用配置进行集中管理和推送的应用配置中心产品。</li><li>Alibaba Cloud OSS：阿里云对象存储服务（Object Storage Service，简称 OSS），是阿里云提供的云存储服务。</li><li>Alibaba Cloud SchedulerX：阿里中间件团队开发的一款分布式任务调度产品，提供秒级、精准的定时（基于 Cron 表达式）任务调度服务。</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305090233845.png"></p><h5 id="2-Spring-Cloud-Alibaba-版本选择"><a href="#2-Spring-Cloud-Alibaba-版本选择" class="headerlink" title="2. Spring Cloud Alibaba 版本选择"></a>2. Spring Cloud Alibaba 版本选择</h5><p><a href="https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E">https://github.com/alibaba/spring-cloud-alibaba/wiki/%E7%89%88%E6%9C%AC%E8%AF%B4%E6%98%8E</a></p><p>版本选择： Spring Cloud Alibaba 2.2.8.RELEASE</p><p>父 pom 如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debuggingWorld<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>debug-spring-cloud-alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.3.12.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">java.version</span>&gt;</span>1.8<span class="hljs-tag">&lt;/<span class="hljs-name">java.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud.version</span>&gt;</span>Hoxton.SR12<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud.version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">spring-cloud-alibaba.version</span>&gt;</span>2.2.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">spring-cloud-alibaba.version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba.cloud<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-cloud-alibaba-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;spring-cloud-alibaba.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">type</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">type</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>import<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>​                        </p>]]></content>
    
    
    <categories>
      
      <category>Spring Cloud Alibaba</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Cloud Alibaba</tag>
      
      <tag>微服务</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot——自定义starter</title>
    <link href="/2023/04/29/Spring-Boot%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89starter/"/>
    <url>/2023/04/29/Spring-Boot%E2%80%94%E2%80%94%E8%87%AA%E5%AE%9A%E4%B9%89starter/</url>
    
    <content type="html"><![CDATA[<p>SpringBoot 最强大的功能就是把我们常用的场景抽取成了一个个 starter（场景启动器），我们通过引入 springboot 提供的这些场景启动器，我们再进行少量的配置就能使用相应的功能。即使是这样，springboot 也不能囊括我们所有的使用场景，往往我们需要自定义 starter，来简化我们对 springboot 的使用。</p><h3 id="1-如何自定义-starter"><a href="#1-如何自定义-starter" class="headerlink" title="1. 如何自定义 starter"></a>1. 如何自定义 starter</h3><h4 id="1-1-实例"><a href="#1-1-实例" class="headerlink" title="1.1 实例"></a>1.1 实例</h4><p>参照 @WebMvcAutoConfiguration 为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfiguration(after = &#123;DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span><br><span class="hljs-meta">        ValidationAutoConfiguration.class&#125;)</span><br><span class="hljs-meta">@ConditionalOnWebApplication(type = ConditionalOnWebApplication.Type.SERVLET)</span><br><span class="hljs-meta">@ConditionalOnClass(&#123;Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class&#125;)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span><br><span class="hljs-meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcAutoConfiguration</span> </span>&#123;<br><br>    <span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br>    <span class="hljs-meta">@Import(org.springframework.boot.autoconfigure.web.servlet.WebMvcAutoConfiguration.EnableWebMvcConfiguration.class)</span><br>    <span class="hljs-meta">@EnableConfigurationProperties(&#123;WebMvcProperties.class, WebProperties.class&#125;)</span><br>    <span class="hljs-meta">@Order(0)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcAutoConfigurationAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span>, <span class="hljs-title">ServletContextAware</span> </span>&#123;<br><br>        <span class="hljs-meta">@Bean</span><br>        <span class="hljs-meta">@ConditionalOnBean(View.class)</span><br>        <span class="hljs-meta">@ConditionalOnMissingBean</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> BeanNameViewResolver <span class="hljs-title">beanNameViewResolver</span><span class="hljs-params">()</span> </span>&#123;<br>            BeanNameViewResolver resolver = <span class="hljs-keyword">new</span> BeanNameViewResolver();<br>            resolver.setOrder(Ordered.LOWEST_PRECEDENCE - <span class="hljs-number">10</span>);<br>            <span class="hljs-keyword">return</span> resolver;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>@Configuration      // 指定这个类是一个配置类<br>@ConditionalOnXXX   // 指定条件成立的情况下自动配置类生效<br>@AutoConfigureOrder // 指定自动配置类的顺序<br>@Bean               // 向容器中添加组件<br>@ConfigurationProperties        // 用于自动配置绑定，可以将配置中的值注入到bean对象上<br>@EnableConfigurationProperties  // 将使用@ConfigurationProperties注解对应的类加入Spring容器</p></blockquote><p>自动配置类要能加载，需要将自动配置类配置在 META‐INF/spring.factories 中：</p><p><a href="https://blog.csdn.net/weixin_38972910/article/details/123632630">Spring.factories</a></p><p>mybatis-spring-boot-starter：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305082130700.png"></p><p>mybatis-spring-boot-starter  pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>spring-boot-starter  pom ：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.8.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ul><li>启动器（starter）是一个空的 jar 文件，仅仅提供辅助性依赖管理，这些依赖可能用于自动装配或其他类库。</li><li>需要专门写一个类似 spring-boot-autoconfigure 的配置模块。</li><li>用的时候只需要引入启动器 starter，就可以使用自动配置了。</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305082144802.png"></p><h4 id="1-2-命名规范"><a href="#1-2-命名规范" class="headerlink" title="1.2 命名规范"></a>1.2 命名规范</h4><p>官方命名空间</p><pre><code class="hljs">+ 前缀：spring-boot-starter-+ 模式：spring-boot-starter-模块名+ 举例：spring-boot-starter-web、spring-boot-starter-jdbc</code></pre><p>自定义命名空间</p><pre><code class="hljs">+ 后缀：-spring-boot-starter+ 模式：模块-spring-boot-starter+ 举例：mybatis-spring-boot-starter</code></pre><h3 id="2-自定义-starter"><a href="#2-自定义-starter" class="headerlink" title="2. 自定义 starter"></a>2. 自定义 starter</h3><p>先创建一个父 maven 项目： springboot_custom_starter，两个 Module：debuggingWorld_spring_boot_starter 和 debuggingWorld_spring_boot_autoconfigure。</p><p>springboot_custom_starter 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debuggingWorld<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot_custom_starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>pom<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>debuggingWorld_spring_boot_starter<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>debuggingWorld_spring_boot_autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-1-debuggingWorld-spring-boot-starter"><a href="#2-1-debuggingWorld-spring-boot-starter" class="headerlink" title="2.1 debuggingWorld_spring_boot_starter"></a>2.1 debuggingWorld_spring_boot_starter</h4><ol><li>pom.xml <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debuggingWorld<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot_custom_starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>debuggingWorld_spring_boot_starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-comment">&lt;!--引入autoconfigure--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debuggingWorld<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>debuggingWorld_spring_boot_autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!-- 如果当前starter 还需要其他的类库就在这里引用 --&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="2-2-debuggingWorld-spring-boot-autoconfigure"><a href="#2-2-debuggingWorld-spring-boot-autoconfigure" class="headerlink" title="2.2 debuggingWorld_spring_boot_autoconfigure"></a>2.2 debuggingWorld_spring_boot_autoconfigure</h4><ol><li><p>pom.xml</p> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag"> <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debuggingWorld<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springboot_custom_starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>debuggingWorld_spring_boot_autoconfigure<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--导入配置文件处理器，配置文件进行绑定就会有提示--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p> 添加 spring-boot-configuration-processor 后并开启：</p><p> <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305082256271.png"></p></li></ol><ol start="2"><li><p>DebugProperties：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ConfigurationProperties(&quot;debuggingworld.hello&quot;)</span><br><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugProperties</span> </span>&#123;<br><span class="hljs-keyword">private</span> String name;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>IndexController：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IndexController</span> </span>&#123;<br><span class="hljs-meta">@Autowired</span><br>DebugProperties debugProperties;<br><br><span class="hljs-meta">@RequestMapping(&quot;/&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">index</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> debugProperties.getName()+<span class="hljs-string">&quot;欢迎您&quot;</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>MyAutoConfiguration：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConfigurationProperties(value = &quot;debuggingworld.hello.name&quot;)</span><br><span class="hljs-meta">@EnableConfigurationProperties(DebugProperties.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyAutoConfiguration</span> </span>&#123;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> IndexController <span class="hljs-title">indexController</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IndexController();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>spring.factories:</p><p>在 resources 下创建文件夹 META-INF 并在 META-INF 下创建文件 spring.factories：</p> <figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">org.springframework.boot.autoconfigure.EnableAutoConfiguration</span>=<span class="hljs-string">\</span><br><span class="hljs-string">com.starter.debuggingWorld.MyAutoConfiguration</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="3-测试自定义-starter"><a href="#3-测试自定义-starter" class="headerlink" title="3. 测试自定义 starter"></a>3. 测试自定义 starter</h3><p>创建个Module: debugStarter，来测试自定义的 stater：</p><ol><li>pom.xml:</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debuggingWorld<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>debuggingWorld_spring_boot_starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><ol start="2"><li>application.properties:</li></ol><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">debuggingworld.hello.name</span>=<span class="hljs-string">debuggingWorld</span><br></code></pre></td></tr></table></figure><ol start="3"><li>访问</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202305082358805.png"></p>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot——整合Druid&amp;MyBatis</title>
    <link href="/2023/04/27/Spring-Boot%E2%80%94%E2%80%94%E6%95%B4%E5%90%88Druid-MyBatis/"/>
    <url>/2023/04/27/Spring-Boot%E2%80%94%E2%80%94%E6%95%B4%E5%90%88Druid-MyBatis/</url>
    
    <content type="html"><![CDATA[<h3 id="1-整合-Druid"><a href="#1-整合-Druid" class="headerlink" title="1.  整合 Druid"></a>1.  整合 Druid</h3><h4 id="1-1-原生整合"><a href="#1-1-原生整合" class="headerlink" title="1.1 原生整合"></a>1.1 原生整合</h4><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>application.yml 配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-comment"># 数据源</span><br><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/debuggingworld?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br><br>    <span class="hljs-comment">#   数据源其他配置</span><br>    <span class="hljs-attr">initialSize:</span> <span class="hljs-number">5</span><br>    <span class="hljs-attr">minIdle:</span> <span class="hljs-number">5</span><br>    <span class="hljs-attr">maxActive:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">maxWait:</span> <span class="hljs-number">60000</span><br>    <span class="hljs-attr">timeBetweenEvictionRunsMillis:</span> <span class="hljs-number">60000</span><br>    <span class="hljs-attr">minEvictableIdleTimeMillis:</span> <span class="hljs-number">300000</span><br>    <span class="hljs-attr">validationQuery:</span> <span class="hljs-string">SELECT</span> <span class="hljs-number">1</span> <span class="hljs-string">FROM</span> <span class="hljs-string">DUAL</span><br>    <span class="hljs-attr">testWhileIdle:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">testOnBorrow:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">testOnReturn:</span> <span class="hljs-literal">false</span><br>    <span class="hljs-attr">poolPreparedStatements:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-comment">#   配置监控统计拦截的filters，去掉后监控界面sql无法统计，&#x27;wall&#x27;用于防火墙</span><br>    <span class="hljs-attr">filters:</span> <span class="hljs-string">stat,wall</span><br>    <span class="hljs-attr">maxPoolPreparedStatementPerConnectionSize:</span> <span class="hljs-number">20</span><br>    <span class="hljs-attr">useGlobalDataSourceStat:</span> <span class="hljs-literal">true</span><br>    <span class="hljs-attr">connectionProperties:</span> <span class="hljs-string">druid.stat.mergeSql=true;druid.stat.slowSqlMillis=500</span><br>    <span class="hljs-comment">#初始化时运行sql脚本</span><br>  <span class="hljs-attr">sql:</span><br>    <span class="hljs-attr">init:</span><br>      <span class="hljs-attr">schema-locations:</span> <span class="hljs-string">classpath:sql/schema.sql</span><br>      <span class="hljs-attr">mode:</span> <span class="hljs-string">always</span><br></code></pre></td></tr></table></figure></li><li><p>配置类 DruidConfig</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ConditionalOnProperty(&quot;spring.datasource.type&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DruidConfig</span> </span>&#123;<br><br>    <span class="hljs-comment">/*</span><br><span class="hljs-comment">    @Bean</span><br><span class="hljs-comment">    // 自动绑定配置文件中 spring.datasource 开头的配置</span><br><span class="hljs-comment">    @ConfigurationProperties(prefix = &quot;spring.datasource&quot;)</span><br><span class="hljs-comment">    public DataSource dataSource()&#123;</span><br><span class="hljs-comment">        return new DruidDataSource();</span><br><span class="hljs-comment">    &#125;*/</span><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DataSource <span class="hljs-title">dataSource</span><span class="hljs-params">(DataSourceProperties properties)</span></span>&#123;<br>        <span class="hljs-comment">// 根据配置动态构建一个 DataSource</span><br>        <span class="hljs-keyword">return</span> properties.initializeDataSourceBuilder().build();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     *  监控台的servlet</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean&lt;StatViewServlet&gt; <span class="hljs-title">statViewServlet</span><span class="hljs-params">()</span> </span>&#123;<br>        ServletRegistrationBean&lt;StatViewServlet&gt; servletRegistrationBean = <span class="hljs-keyword">new</span> ServletRegistrationBean&lt;&gt;();<br>        servletRegistrationBean.setServlet(<span class="hljs-keyword">new</span> StatViewServlet());<br>        servletRegistrationBean.addUrlMappings(<span class="hljs-string">&quot;/druid/*&quot;</span>);<br>        <span class="hljs-comment">/* &lt;init-param&gt;</span><br><span class="hljs-comment">            &lt;param-name&gt;loginUsername&lt;/param-name&gt;</span><br><span class="hljs-comment">            &lt;param-value&gt;admin&lt;/param-value&gt;</span><br><span class="hljs-comment">        &lt;/init-param&gt; */</span><br>        <span class="hljs-comment">// 添加IP白名单</span><br>        servletRegistrationBean.addInitParameter(<span class="hljs-string">&quot;allow&quot;</span>, <span class="hljs-string">&quot;127.0.0.1&quot;</span>);<br>        <span class="hljs-comment">// 添加IP黑名单，当白名单和黑名单重复时，黑名单优先级更高</span><br>        <span class="hljs-comment">// servletRegistrationBean.addInitParameter(&quot;deny&quot;, &quot;127.0.0.1&quot;);</span><br>        <span class="hljs-comment">// 添加控制台管理用户</span><br>        servletRegistrationBean.addInitParameter(<span class="hljs-string">&quot;loginUsername&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>);<br>        servletRegistrationBean.addInitParameter(<span class="hljs-string">&quot;loginPassword&quot;</span>, <span class="hljs-string">&quot;123456&quot;</span>);<br>        <span class="hljs-comment">// 是否能够重置数据</span><br>        servletRegistrationBean.addInitParameter(<span class="hljs-string">&quot;resetEnable&quot;</span>, <span class="hljs-string">&quot;false&quot;</span>);<br>        <span class="hljs-keyword">return</span> servletRegistrationBean;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 配置服务过滤器 :监控哪些访问</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> 返回过滤器配置对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> FilterRegistrationBean&lt;WebStatFilter&gt; <span class="hljs-title">statFilter</span><span class="hljs-params">()</span> </span>&#123;<br>        FilterRegistrationBean&lt;WebStatFilter&gt; filterRegistrationBean = <span class="hljs-keyword">new</span> FilterRegistrationBean&lt;&gt;();<br>        filterRegistrationBean.setFilter(<span class="hljs-keyword">new</span> WebStatFilter());<br><br>        <span class="hljs-comment">// 添加过滤规则</span><br>        filterRegistrationBean.addUrlPatterns(<span class="hljs-string">&quot;/*&quot;</span>);<br>        <span class="hljs-comment">// 忽略过滤格式</span><br>        filterRegistrationBean.addInitParameter(<span class="hljs-string">&quot;exclusions&quot;</span>, <span class="hljs-string">&quot;*.js,*.gif,*.jpg,*.png,*.css,*.ico,/druid/*,&quot;</span>);<br>        <span class="hljs-keyword">return</span> filterRegistrationBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="1-2-通过启动器整合"><a href="#1-2-通过启动器整合" class="headerlink" title="1.2 通过启动器整合"></a>1.2 通过启动器整合</h4><p>使用场景启动器无需配置，开箱即用。</p><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>添加配置</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/debuggingworld?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>    <span class="hljs-attr">druid:</span><br>      <span class="hljs-attr">stat-view-servlet:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>     <span class="hljs-comment"># 开启监控台</span><br>        <span class="hljs-attr">allow:</span> <span class="hljs-number">127.0</span><span class="hljs-number">.0</span><span class="hljs-number">.1</span><br>        <span class="hljs-attr">login-username:</span> <span class="hljs-string">admin</span><br>        <span class="hljs-attr">login-password:</span> <span class="hljs-number">123456</span><br>      <span class="hljs-attr">web-stat-filter:</span><br>        <span class="hljs-attr">enabled:</span> <span class="hljs-literal">true</span>     <span class="hljs-comment"># 开启过滤</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="2-整合-MyBatis"><a href="#2-整合-MyBatis" class="headerlink" title="2. 整合 MyBatis"></a>2. 整合 MyBatis</h3><h4 id="2-1-生成-MyBatis-代码"><a href="#2-1-生成-MyBatis-代码" class="headerlink" title="2.1 生成 MyBatis 代码"></a>2.1 生成 MyBatis 代码</h4><p><a href="https://debuggingworld.github.io/2022/12/28/Mybatis-Plus%E2%80%94%E2%80%94%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4-SQL%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BF%9D%E6%8A%A4-%E4%B9%90%E8%A7%82%E9%94%81-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/#6-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8">代码生成器</a></p><p><a href="https://debuggingworld.github.io/2022/12/04/Mybatis%E2%80%94%E2%80%94%E2%80%94%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/#2-MyBatis%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B">MyBatis逆向工程</a></p><ol><li><p>pom.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- Mybatis-Generator插件，自动生成代码 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.3.5<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">configurationFile</span>&gt;</span>$&#123;project.basedir&#125;/src/main/resources/generatorConfig.xml<span class="hljs-tag">&lt;/<span class="hljs-name">configurationFile</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">verbose</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">verbose</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">overwrite</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">overwrite</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>                <span class="hljs-comment">&lt;!--必須要引入数据库驱动--&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>                    <span class="hljs-comment">&lt;!--必须制定版本--&gt;</span><br>                    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>                <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>generatorConfig.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">generatorConfiguration</span> <span class="hljs-meta-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;simple&quot;</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3Simple&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressAllComments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--数据源 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/debuggingworld?serverTimezone=UTC&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;root&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/resources&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;XMLMAPPER&quot;</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>/&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;emp&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Emp&quot;</span> <span class="hljs-attr">mapperName</span>=<span class="hljs-string">&quot;EmpMapper&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Dept&quot;</span> <span class="hljs-attr">mapperName</span>=<span class="hljs-string">&quot;DeptMapper&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>运行插件，生成代码</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304280051208.png"></p></li></ol><h4 id="2-2-整合-Mybatis"><a href="#2-2-整合-Mybatis" class="headerlink" title="2.2  整合 Mybatis"></a>2.2  整合 Mybatis</h4><h5 id="1-整合方法"><a href="#1-整合方法" class="headerlink" title="1. 整合方法"></a>1. 整合方法</h5><ol><li><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>配置类：MybatisAutoConfiguration</p></li><li><p>配置文件</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">mapper-locations:</span> <span class="hljs-string">classpath:com/debuggingWorld/mapper/*Mapper.xml</span><br>  <span class="hljs-attr">type-aliases-package:</span> <span class="hljs-string">com.debuggingWorld.pojo</span><br></code></pre></td></tr></table></figure></li><li><p>启动类</p><p>添加 @MapperScan 注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.debuggingWorld.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(Application.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h5 id="2-MyBatis-自动配置原理"><a href="#2-MyBatis-自动配置原理" class="headerlink" title="2. MyBatis 自动配置原理"></a>2. MyBatis 自动配置原理</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@org</span>.springframework.context.annotation.Configuration<br><span class="hljs-meta">@ConditionalOnClass(&#123; SqlSessionFactory.class, SqlSessionFactoryBean.class &#125;)</span><br><span class="hljs-meta">@ConditionalOnSingleCandidate(DataSource.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(MybatisProperties.class)</span><br><span class="hljs-meta">@AutoConfigureAfter(DataSourceAutoConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MybatisAutoConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span> </span>&#123;<br><br>  <span class="hljs-meta">@Bean</span><br>  <span class="hljs-meta">@ConditionalOnMissingBean</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> SqlSessionFactory <span class="hljs-title">sqlSessionFactory</span><span class="hljs-params">(DataSource dataSource)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    SqlSessionFactoryBean factory = <span class="hljs-keyword">new</span> SqlSessionFactoryBean();<br>    factory.setDataSource(dataSource);<br>    factory.setVfs(SpringBootVFS.class);<br>    <span class="hljs-comment">// 设置Mybaits的全局配置文件</span><br>    <span class="hljs-keyword">if</span> (StringUtils.hasText(<span class="hljs-keyword">this</span>.properties.getConfigLocation())) &#123;<br>      factory.setConfigLocation(<span class="hljs-keyword">this</span>.resourceLoader.getResource(<span class="hljs-keyword">this</span>.properties.getConfigLocation()));<br>    &#125;<br>    <span class="hljs-comment">// 另一种定制方式</span><br>    applyConfiguration(factory);<br>    <span class="hljs-comment">// 相当于mybatis全局配置文件中</span><br>    <span class="hljs-comment">/*&lt;properties&gt;</span><br><span class="hljs-comment">        &lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</span><br><span class="hljs-comment">    &lt;/properties&gt;*/</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.properties.getConfigurationProperties() != <span class="hljs-keyword">null</span>) &#123;<br>      factory.setConfigurationProperties(<span class="hljs-keyword">this</span>.properties.getConfigurationProperties());<br>    &#125;<br>    <span class="hljs-comment">// 就是配置插件‐拦截器 只需要配置一个实现了Interceptor的接口为Bean</span><br>    <span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(<span class="hljs-keyword">this</span>.interceptors)) &#123;<br>      factory.setPlugins(<span class="hljs-keyword">this</span>.interceptors);<br>    &#125;<br>    <span class="hljs-comment">// 设置数据库厂商id</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.databaseIdProvider != <span class="hljs-keyword">null</span>) &#123;<br>      factory.setDatabaseIdProvider(<span class="hljs-keyword">this</span>.databaseIdProvider);<br>    &#125;<br>    <span class="hljs-comment">// 设置别名：从application.yml中获取mybatis.typeAliasesPackage</span><br>    <span class="hljs-keyword">if</span> (StringUtils.hasLength(<span class="hljs-keyword">this</span>.properties.getTypeAliasesPackage())) &#123;<br>      factory.setTypeAliasesPackage(<span class="hljs-keyword">this</span>.properties.getTypeAliasesPackage());<br>    &#125;<br>    <span class="hljs-comment">// 可以通过父类过滤哪些类需要使用别名</span><br>    <span class="hljs-comment">// mybatis.typeAliasesSuperType: com.debuggingworld.pojo.basePojo</span><br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.properties.getTypeAliasesSuperType() != <span class="hljs-keyword">null</span>) &#123;<br>      factory.setTypeAliasesSuperType(<span class="hljs-keyword">this</span>.properties.getTypeAliasesSuperType());<br>    &#125;<br>    <span class="hljs-comment">// 设置类型处理器</span><br>    <span class="hljs-comment">/*&lt;typeHandlers&gt;</span><br><span class="hljs-comment">        &lt;package name=&quot;&quot;/&gt;</span><br><span class="hljs-comment">    &lt;/typeHandlers&gt;*/</span><br>    <span class="hljs-keyword">if</span> (StringUtils.hasLength(<span class="hljs-keyword">this</span>.properties.getTypeHandlersPackage())) &#123;<br>      factory.setTypeHandlersPackage(<span class="hljs-keyword">this</span>.properties.getTypeHandlersPackage());<br>    &#125;<br>    <span class="hljs-comment">/*&lt;typeHandlers&gt;</span><br><span class="hljs-comment">        &lt;typeHandler handler=&quot;&quot; </span><br><span class="hljs-comment">    &lt;/typeHandlers&gt;*/</span><br>    <span class="hljs-keyword">if</span> (!ObjectUtils.isEmpty(<span class="hljs-keyword">this</span>.properties.resolveMapperLocations())) &#123;<br>      factory.setMapperLocations(<span class="hljs-keyword">this</span>.properties.resolveMapperLocations());<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> factory.getObject();<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>如果依然放不下 mybatis 全局配置文件， springboot 还是支持的：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">mybatis</span>:<span class="hljs-string"></span><br>  <span class="hljs-meta">config-location</span>: <span class="hljs-string">classpath:mybatis-config.xml</span><br></code></pre></td></tr></table></figure></li><li><p>mybatis-config.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--就是DOCTYPE后面对应的根节点--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--&lt;properties&gt;</span><br><span class="hljs-comment">        &lt;property name=&quot;&quot; value=&quot;&quot;/&gt;</span><br><span class="hljs-comment">    &lt;/properties&gt;--&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- mybatis的设置选项  可以改变mybatis运行时行为--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>如果要设置 mybatis 的 settings 怎么设置呢？</p><ol><li><p>可以通过 mybatis 全局配置文件设置</p></li><li><p>也可以通过在 application.yml 中配置 configuration</p><p>configuration 封装 mybatis 所有信息</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">mybatis:</span><br>  <span class="hljs-attr">configuration:</span><br>    <span class="hljs-attr">map-underscore-to-camel-case:</span> <span class="hljs-literal">true</span><br></code></pre></td></tr></table></figure></li></ol></li><li><p>定制 mybatis</p><ol><li>使用 mybatis 全局配置文件</li><li>可以使用 application.yml 中配置 configuration + ConfigurationCustomizer</li><li>要么使用 mybatis 的配置，要么使用 springboot 的配置， 只能用一种</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">applyConfiguration</span><span class="hljs-params">(SqlSessionFactoryBean factory)</span> </span>&#123;<br>  Configuration configuration = <span class="hljs-keyword">this</span>.properties.getConfiguration();<br>  <span class="hljs-comment">// application.yml中没有配置configuration时为 null</span><br>  <span class="hljs-keyword">if</span> (configuration == <span class="hljs-keyword">null</span> &amp;&amp; !StringUtils.hasText(<span class="hljs-keyword">this</span>.properties.getConfigLocation())) &#123;<br>    <span class="hljs-comment">// 没有在application.yml中配置config-location才会 new</span><br>    configuration = <span class="hljs-keyword">new</span> Configuration();<br>  &#125;<br>  <span class="hljs-keyword">if</span> (configuration != <span class="hljs-keyword">null</span> &amp;&amp; !CollectionUtils.isEmpty(<span class="hljs-keyword">this</span>.configurationCustomizers)) &#123;<br>    <span class="hljs-keyword">for</span> (ConfigurationCustomizer customizer : <span class="hljs-keyword">this</span>.configurationCustomizers) &#123;<br>      customizer.customize(configuration);<br>    &#125;<br>  &#125;<br>  factory.setConfiguration(configuration);<br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li><p>ConfigurationCustomizer 方式配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfigurationCustomizer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ConfigurationCustomizer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(Configuration configuration)</span> </span>&#123;<br>        configuration.setMapUnderscoreToCamelCase(<span class="hljs-keyword">true</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot——SpringBoot&amp;Servlet容器</title>
    <link href="/2023/04/25/Spring-Boot%E2%80%94%E2%80%94SpringBoot%E4%B8%8EServlet%E5%AE%B9%E5%99%A8/"/>
    <url>/2023/04/25/Spring-Boot%E2%80%94%E2%80%94SpringBoot%E4%B8%8EServlet%E5%AE%B9%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<p>SpringBoot 默认的 Servlet 容器是：Tomcat</p><h3 id="1-嵌入式-Servlet-容器配置修改"><a href="#1-嵌入式-Servlet-容器配置修改" class="headerlink" title="1.  嵌入式 Servlet 容器配置修改"></a>1.  嵌入式 Servlet 容器配置修改</h3><h4 id="1-1-通过全局配置文件修改"><a href="#1-1-通过全局配置文件修改" class="headerlink" title="1.1 通过全局配置文件修改"></a>1.1 通过全局配置文件修改</h4><p>可以通过 server.xxx 来进行 web 服务配置， 没有带服务器名称的则是通用配置，通过带了具体的服务器名称则是单独对该服务器进行设置，比如server.tomcat.xxx  就是专门针对 tomcat 的配置。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8088</span><br><span class="hljs-meta">server.servlet.context-path</span>=<span class="hljs-string">/debugging</span><br></code></pre></td></tr></table></figure><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/application-properties.html#appendix.application-properties.server">（文档说明）</a></p><h4 id="1-2-通过-WebServerFactoryCustomizer-的-Bean-修改"><a href="#1-2-通过-WebServerFactoryCustomizer-的-Bean-修改" class="headerlink" title="1.2 通过 WebServerFactoryCustomizer 的 Bean 修改"></a>1.2 通过 WebServerFactoryCustomizer 的 Bean 修改</h4><ul><li>修改 server.xxx 配置的相关内容</li><li>会跟配置文件形成互补</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomizationBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebServerFactoryCustomizer</span>&lt;<span class="hljs-title">ConfigurableServletWebServerFactory</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(ConfigurableServletWebServerFactory serverFactory)</span> </span>&#123;<br>        serverFactory.setPort(<span class="hljs-number">8088</span>);<br>        serverFactory.setContextPath(<span class="hljs-string">&quot;/debugging&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-注册-servlet-三大组件"><a href="#2-注册-servlet-三大组件" class="headerlink" title="2. 注册 servlet 三大组件"></a>2. 注册 servlet 三大组件</h3><p>三大组件：servlet、listener、filter</p><h4 id="2-1-servlet3-0-规范提供的注解方式注册"><a href="#2-1-servlet3-0-规范提供的注解方式注册" class="headerlink" title="2.1 servlet3.0 规范提供的注解方式注册"></a>2.1 servlet3.0 规范提供的注解方式注册</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet</span><br><span class="hljs-meta">@WebListener</span><br><span class="hljs-meta">@WebFilter</span><br></code></pre></td></tr></table></figure><ol><li><p>声明 servlet 及映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(name = &quot;helloServlet&quot;, urlPatterns = &quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        PrintWriter writer = resp.getWriter();<br>        writer.println(<span class="hljs-string">&quot;hello debuggingWorld&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>添加 @ServletComponentScan</p><p>加上 @ServletComponentScan 才会扫描上面个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@ServletComponentScan</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(Application.class, args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-2-SpringBoot-提供的注册"><a href="#2-2-SpringBoot-提供的注册" class="headerlink" title="2.2 SpringBoot 提供的注册"></a>2.2 SpringBoot 提供的注册</h4><p>使用 ServletRegistrationBean、FilterRegistrationBean 以及 ServletListenerRegistrationBean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        PrintWriter writer = resp.getWriter();<br>        writer.println(<span class="hljs-string">&quot;hello BeanServlet&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyServletRegistration</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ServletRegistrationBean&lt;Servlet&gt; <span class="hljs-title">myServlet</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 声明一个servlet注册器Bean</span><br>        ServletRegistrationBean&lt;Servlet&gt; registrationBean = <span class="hljs-keyword">new</span> ServletRegistrationBean&lt;&gt;();<br>        <span class="hljs-comment">// 设置相应的servlet</span><br>        registrationBean.setServlet(<span class="hljs-keyword">new</span> BeanServlet());<br>        <span class="hljs-comment">// 设置名字</span><br>        registrationBean.setName(<span class="hljs-string">&quot;BeanServlet&quot;</span>);<br>        <span class="hljs-comment">// 添加映射规则</span><br>        registrationBean.addUrlMappings(<span class="hljs-string">&quot;/BeanServlet&quot;</span>);<br>        <span class="hljs-keyword">return</span> registrationBean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-切换其他嵌入式-Servlet-容器"><a href="#3-切换其他嵌入式-Servlet-容器" class="headerlink" title="3. 切换其他嵌入式 Servlet 容器"></a>3. 切换其他嵌入式 Servlet 容器</h3><p>Spring Boot 包含对嵌入式 Tomcat，Jetty 和 Undertow 服务器的支持</p><ul><li>tomcat（默认）</li><li>Jetty（socket）</li><li>Undertow（响应式）</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--排除tomcat--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br><span class="hljs-comment">&lt;!--jetty 依赖--&gt;</span><br><span class="hljs-comment">&lt;!--&lt;dependency&gt;</span><br><span class="hljs-comment">    &lt;groupId&gt;org.springframework.boot&lt;/groupId&gt;</span><br><span class="hljs-comment">    &lt;artifactId&gt;spring-boot-starter-jetty&lt;/artifactId&gt;</span><br><span class="hljs-comment">&lt;/dependency&gt;--&gt;</span><br><br><span class="hljs-comment">&lt;!--undertow 依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-undertow<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-嵌入式-Servlet-容器自动配置原理"><a href="#4-嵌入式-Servlet-容器自动配置原理" class="headerlink" title="4. 嵌入式  Servlet  容器自动配置原理"></a>4. 嵌入式  Servlet  容器自动配置原理</h3><p> servlet 容器自动配置类：ServletWebServerFactoryAutoConfiguration</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfiguration</span><br><span class="hljs-meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="hljs-comment">// 只要依赖任意一个servlet容器都会存在该来ServletRequest</span><br><span class="hljs-meta">@ConditionalOnClass(ServletRequest.class)</span><br><span class="hljs-meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span><br><span class="hljs-comment">// 启用servet.xxx的所有的配置信息绑定到ServerProperties</span><br><span class="hljs-meta">@EnableConfigurationProperties(ServerProperties.class)</span><br><span class="hljs-meta">@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,</span><br><span class="hljs-meta">      ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,</span><br><span class="hljs-meta">      ServletWebServerFactoryConfiguration.EmbeddedJetty.class,</span><br><span class="hljs-meta">      ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServletWebServerFactoryAutoConfiguration</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-1-为什么可以根据配置的依赖自动使用对应的-servlet-容器？"><a href="#4-1-为什么可以根据配置的依赖自动使用对应的-servlet-容器？" class="headerlink" title="4.1 为什么可以根据配置的依赖自动使用对应的 servlet 容器？"></a>4.1 为什么可以根据配置的依赖自动使用对应的 servlet 容器？</h4><ol><li><p>通过 @Import 导入Embeddedxxxx</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Import(&#123; ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar.class,</span><br><span class="hljs-meta">      ServletWebServerFactoryConfiguration.EmbeddedTomcat.class,</span><br><span class="hljs-meta">      ServletWebServerFactoryConfiguration.EmbeddedJetty.class,</span><br><span class="hljs-meta">      ServletWebServerFactoryConfiguration.EmbeddedUndertow.class &#125;)</span><br></code></pre></td></tr></table></figure></li><li><p>每个 Embeddedxxxx 中都配置了相应的 @ConditionalOnClass，会根据当前 servlet 容器 start 依赖判断 classpath 是否存在对应的类， 如果存在就使用对应的 servlet 容器。 比如 EmbeddedTomcat：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-comment">// 只要添加了tomcat的场景启动器 则该注解才会生效</span><br><span class="hljs-meta">@ConditionalOnClass(&#123; Servlet.class, Tomcat.class, UpgradeProtocol.class &#125;)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(value = ServletWebServerFactory.class, search = SearchStrategy.CURRENT)</span><br><span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EmbeddedTomcat</span> </span>&#123;<br><br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-function">TomcatServletWebServerFactory <span class="hljs-title">tomcatServletWebServerFactory</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">         ObjectProvider&lt;TomcatConnectorCustomizer&gt; connectorCustomizers,</span></span><br><span class="hljs-params"><span class="hljs-function">         ObjectProvider&lt;TomcatContextCustomizer&gt; contextCustomizers,</span></span><br><span class="hljs-params"><span class="hljs-function">         ObjectProvider&lt;TomcatProtocolHandlerCustomizer&lt;?&gt;&gt; protocolHandlerCustomizers)</span> </span>&#123;<br>      TomcatServletWebServerFactory factory = <span class="hljs-keyword">new</span> TomcatServletWebServerFactory();<br>      factory.getTomcatConnectorCustomizers()<br>            .addAll(connectorCustomizers.orderedStream().collect(Collectors.toList()));<br>      factory.getTomcatContextCustomizers()<br>            .addAll(contextCustomizers.orderedStream().collect(Collectors.toList()));<br>      factory.getTomcatProtocolHandlerCustomizers()<br>            .addAll(protocolHandlerCustomizers.orderedStream().collect(Collectors.toList()));<br>      <span class="hljs-keyword">return</span> factory;<br>   &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>如果没有对应的 tomcat 场景启动器该注解就不会生效</p></li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304242235841.png"></p><h4 id="4-2-怎么根据配置文件中-server-xxx-和-WebServerFactoryCustomizer-设置-servlet-容器？"><a href="#4-2-怎么根据配置文件中-server-xxx-和-WebServerFactoryCustomizer-设置-servlet-容器？" class="headerlink" title="4.2 怎么根据配置文件中 server.xxx 和 WebServerFactoryCustomizer 设置 servlet 容器？"></a>4.2 怎么根据配置文件中 server.xxx 和 WebServerFactoryCustomizer 设置 servlet 容器？</h4><ol><li><p>Servlet 容器配置文件通用定制器</p><p>ServletWebServerFactoryAutoConfiguration#servletWebServerFactoryCustomizer：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ServletWebServerFactoryCustomizer <span class="hljs-title">servletWebServerFactoryCustomizer</span><span class="hljs-params">(ServerProperties serverProperties,</span></span><br><span class="hljs-params"><span class="hljs-function">  ObjectProvider&lt;WebListenerRegistrar&gt; webListenerRegistrars,</span></span><br><span class="hljs-params"><span class="hljs-function">  ObjectProvider&lt;CookieSameSiteSupplier&gt; cookieSameSiteSuppliers)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ServletWebServerFactoryCustomizer(serverProperties,<br> webListenerRegistrars.orderedStream().collect(Collectors.toList()),<br> cookieSameSiteSuppliers.orderedStream().collect(Collectors.toList()));<br>&#125;<br></code></pre></td></tr></table></figure><p> ServletWebServerFactoryCustomizer：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ServletWebServerFactoryCustomizer</span></span><br><span class="hljs-class">  <span class="hljs-keyword">implements</span> <span class="hljs-title">WebServerFactoryCustomizer</span>&lt;<span class="hljs-title">ConfigurableServletWebServerFactory</span>&gt;, <span class="hljs-title">Ordered</span> </span>&#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">customize</span><span class="hljs-params">(ConfigurableServletWebServerFactory factory)</span> </span>&#123;<br>  PropertyMapper map = PropertyMapper.get().alwaysApplyingWhenNonNull();<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties::getPort).to(factory::setPort);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties::getAddress).to(factory::setAddress);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties.getServlet()::getContextPath).to(factory::setContextPath);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties.getServlet()::getApplicationDisplayName).to(factory::setDisplayName);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties.getServlet()::isRegisterDefaultServlet).to(factory::setRegisterDefaultServlet);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties.getServlet()::getSession).to(factory::setSession);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties::getSsl).to(factory::setSsl);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties.getServlet()::getJsp).to(factory::setJsp);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties::getCompression).to(factory::setCompression);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties::getHttp2).to(factory::setHttp2);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties::getServerHeader).to(factory::setServerHeader);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties.getServlet()::getContextParameters).to(factory::setInitParameters);<br>  map.from(<span class="hljs-keyword">this</span>.serverProperties.getShutdown()).to(factory::setShutdown);<br>  <span class="hljs-keyword">for</span> (WebListenerRegistrar registrar : <span class="hljs-keyword">this</span>.webListenerRegistrars) &#123;<br> registrar.register(factory);<br>  &#125;<br>  <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(<span class="hljs-keyword">this</span>.cookieSameSiteSuppliers)) &#123;<br> factory.setCookieSameSiteSuppliers(<span class="hljs-keyword">this</span>.cookieSameSiteSuppliers);<br>  &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p> ServletWebServerFactoryCustomizer 实现了 WebServerFactoryCustomizer，说明它也是定制 servlet 容器的。</p><p> <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304242259697.png"></p><p> 根据配置文件中 server.xxx 来进行定制 servlet 容器。</p></li><li><p> Tomcat 配置文件定制器</p></li></ol><p>   ServletWebServerFactoryAutoConfiguration#tomcatServletWebServerFactoryCustomizer：</p>   <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnClass(name = &quot;org.apache.catalina.startup.Tomcat&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> TomcatServletWebServerFactoryCustomizer <span class="hljs-title">tomcatServletWebServerFactoryCustomizer</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">  ServerProperties serverProperties)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TomcatServletWebServerFactoryCustomizer(serverProperties);<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TomcatServletWebServerFactoryCustomizer</span></span><br><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">WebServerFactoryCustomizer</span>&lt;<span class="hljs-title">TomcatServletWebServerFactory</span>&gt;, <span class="hljs-title">Ordered</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>   根据配置文件中 servet.tomcat.xxxx 定制 servlet 容器。</p><p><strong>怎么让所有的 WebServerFactoryCustomizer Bean 顺序调用的</strong></p><p>ServletWebServerFactoryAutoConfiguration.BeanPostProcessorsRegistrar</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanPostProcessorsRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span>, <span class="hljs-title">BeanFactoryAware</span> </span>&#123;<br>   <span class="hljs-comment">// ....</span><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata,</span></span><br><span class="hljs-params"><span class="hljs-function">         BeanDefinitionRegistry registry)</span> </span>&#123;<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.beanFactory == <span class="hljs-keyword">null</span>) &#123;<br>         <span class="hljs-keyword">return</span>;<br>      &#125;<br>      registerSyntheticBeanIfMissing(registry, <span class="hljs-string">&quot;webServerFactoryCustomizerBeanPostProcessor&quot;</span>,<br>            WebServerFactoryCustomizerBeanPostProcessor.class,<br>            WebServerFactoryCustomizerBeanPostProcessor::<span class="hljs-keyword">new</span>);<br>      registerSyntheticBeanIfMissing(registry, <span class="hljs-string">&quot;errorPageRegistrarBeanPostProcessor&quot;</span>,<br>            ErrorPageRegistrarBeanPostProcessor.class, ErrorPageRegistrarBeanPostProcessor::<span class="hljs-keyword">new</span>);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>注册了：WebServerFactoryCustomizerBeanPostProcessor</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebServerFactoryCustomizerBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span>, <span class="hljs-title">BeanFactoryAware</span> </span>&#123;<br><br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>      <span class="hljs-comment">// 判断当前创建的bean是不是WebServerFactory</span><br>      <span class="hljs-keyword">if</span> (bean <span class="hljs-keyword">instanceof</span> WebServerFactory) &#123;<br>         postProcessBeforeInitialization((WebServerFactory) bean);<br>      &#125;<br>      <span class="hljs-keyword">return</span> bean;<br>   &#125;<br><br>   <span class="hljs-meta">@SuppressWarnings(&quot;unchecked&quot;)</span><br>   <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(WebServerFactory webServerFactory)</span> </span>&#123;<br>      <span class="hljs-comment">// 调用getCustomizers()</span><br>      LambdaSafe.callbacks(WebServerFactoryCustomizer.class, getCustomizers(), webServerFactory)<br>            .withLogger(WebServerFactoryCustomizerBeanPostProcessor.class)<br>            .invoke((customizer) -&gt; customizer.customize(webServerFactory));<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>当对应 Embeddedxxxx 启用时， 就会在里面配置一个 WebServerFactory 类型的一个 Bean, 负责创建对应的容器和启动。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304250105090.png"></p><ol><li><p>调用 getCustomizers()</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> Collection&lt;WebServerFactoryCustomizer&lt;?&gt;&gt; getCustomizers() &#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.customizers == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-comment">// Look up does not include the parent context</span><br>      <span class="hljs-keyword">this</span>.customizers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(getWebServerFactoryCustomizerBeans());<br>      <span class="hljs-keyword">this</span>.customizers.sort(AnnotationAwareOrderComparator.INSTANCE);<br>      <span class="hljs-keyword">this</span>.customizers = Collections.unmodifiableList(<span class="hljs-keyword">this</span>.customizers);<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.customizers;<br>&#125;<br><br><span class="hljs-meta">@SuppressWarnings(&#123; &quot;unchecked&quot;, &quot;rawtypes&quot; &#125;)</span><br><span class="hljs-keyword">private</span> Collection&lt;WebServerFactoryCustomizer&lt;?&gt;&gt; getWebServerFactoryCustomizerBeans() &#123;<br>   <span class="hljs-keyword">return</span> (Collection) <span class="hljs-keyword">this</span>.beanFactory.getBeansOfType(WebServerFactoryCustomizer.class, <span class="hljs-keyword">false</span>, <span class="hljs-keyword">false</span>).values();<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>getWebServerFactoryCustomizerBeans() 就获取了所有实现了 WebServerFactoryCustomizer 接口的 Bean。</p><p>此时会获取到自定义的、ServletWebServerFactoryCustomizer、TomcatServletWebServerFactoryCustomizer</p></li><li><p>在 invoke 方法中循环调用所有实现了 WebServerFactoryCustomizer 接口的 Bean 的 customize 方法进行一一定制</p></li></ol><h4 id="4-3-嵌入式-servlet-容器是怎么启动的"><a href="#4-3-嵌入式-servlet-容器是怎么启动的" class="headerlink" title="4.3 嵌入式 servlet 容器是怎么启动的"></a>4.3 嵌入式 servlet 容器是怎么启动的</h4><p>自动配置中根据不同的依赖， 启动对应一个 Embeddedxxxx， 然后配置一个对应的 servlet 容器工厂类， 比如 tomcat:TomcatServletWebServerFactory。<br>在 springboot 应用启动的时候 ， 就会调用容器 refresh 方法，  onRefresh() –&gt; createWebServer()  –&gt; getWebServer()， 创建 servlet 及启动。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> WebServer <span class="hljs-title">getWebServer</span><span class="hljs-params">(ServletContextInitializer... initializers)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.disableMBeanRegistry) &#123;<br>      Registry.disableRegistry();<br>   &#125;<br>   Tomcat tomcat = <span class="hljs-keyword">new</span> Tomcat();<br>   File baseDir = (<span class="hljs-keyword">this</span>.baseDirectory != <span class="hljs-keyword">null</span>) ? <span class="hljs-keyword">this</span>.baseDirectory : createTempDir(<span class="hljs-string">&quot;tomcat&quot;</span>);<br>   tomcat.setBaseDir(baseDir.getAbsolutePath());<br>   <span class="hljs-keyword">for</span> (LifecycleListener listener : <span class="hljs-keyword">this</span>.serverLifecycleListeners) &#123;<br>      tomcat.getServer().addLifecycleListener(listener);<br>   &#125;<br>   Connector connector = <span class="hljs-keyword">new</span> Connector(<span class="hljs-keyword">this</span>.protocol);<br>   connector.setThrowOnFailure(<span class="hljs-keyword">true</span>);<br>   tomcat.getService().addConnector(connector);<br>   customizeConnector(connector);<br>   tomcat.setConnector(connector);<br>   tomcat.getHost().setAutoDeploy(<span class="hljs-keyword">false</span>);<br>   configureEngine(tomcat.getEngine());<br>   <span class="hljs-keyword">for</span> (Connector additionalConnector : <span class="hljs-keyword">this</span>.additionalTomcatConnectors) &#123;<br>      tomcat.getService().addConnector(additionalConnector);<br>   &#125;<br>   prepareContext(tomcat.getHost(), initializers);<br>   <span class="hljs-keyword">return</span> getTomcatWebServer(tomcat);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> TomcatWebServer <span class="hljs-title">getTomcatWebServer</span><span class="hljs-params">(Tomcat tomcat)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TomcatWebServer(tomcat, getPort() &gt;= <span class="hljs-number">0</span>, getShutdown());<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TomcatWebServer</span><span class="hljs-params">(Tomcat tomcat, <span class="hljs-keyword">boolean</span> autoStart, Shutdown shutdown)</span> </span>&#123;<br>   Assert.notNull(tomcat, <span class="hljs-string">&quot;Tomcat Server must not be null&quot;</span>);<br>   <span class="hljs-keyword">this</span>.tomcat = tomcat;<br>   <span class="hljs-keyword">this</span>.autoStart = autoStart;<br>   <span class="hljs-keyword">this</span>.gracefulShutdown = (shutdown == Shutdown.GRACEFUL) ? <span class="hljs-keyword">new</span> GracefulShutdown(tomcat) : <span class="hljs-keyword">null</span>;<br>   initialize();<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initialize</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> WebServerException </span>&#123;<br>   logger.info(<span class="hljs-string">&quot;Tomcat initialized with port(s): &quot;</span> + getPortsDescription(<span class="hljs-keyword">false</span>));<br>   <span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.monitor) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>         addInstanceIdToEngineName();<br>         Context context = findContext();<br>         context.addLifecycleListener((event) -&gt; &#123;<br>            <span class="hljs-keyword">if</span> (context.equals(event.getSource()) &amp;&amp; Lifecycle.START_EVENT.equals(event.getType())) &#123;<br>               <span class="hljs-comment">// Remove service connectors so that protocol binding doesn&#x27;t</span><br>               <span class="hljs-comment">// happen when the service is started.</span><br>               removeServiceConnectors();<br>            &#125;<br>         &#125;);<br><br>         <span class="hljs-comment">// Start the server to trigger initialization listeners</span><br>         <span class="hljs-comment">// 启动tomcat</span><br>         <span class="hljs-keyword">this</span>.tomcat.start();<br><br>         rethrowDeferredStartupExceptions();<br>         ContextBindings.bindClassLoader(context, context.getNamingToken(), getClass().getClassLoader());<br>         <br>         <span class="hljs-comment">// Unlike Jetty, all Tomcat threads are daemon threads. We create a</span><br>         <span class="hljs-comment">// blocking non-daemon to stop immediate shutdown</span><br>         startDaemonAwaitThread();<br>      &#125;<br>      <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>         stopSilently();<br>         destroySilently();<br>         <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> WebServerException(<span class="hljs-string">&quot;Unable to start embedded Tomcat&quot;</span>, ex);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-使用外部-Servlet-容器"><a href="#5-使用外部-Servlet-容器" class="headerlink" title="5. 使用外部 Servlet 容器"></a>5. 使用外部 Servlet 容器</h3><ol><li><p>下载 tomcat 服务</p></li><li><p>设置当前 maven 项目的打包方式</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--默认是jar--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>war<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>排除 tomcat 依赖不参与打包</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-tomcat<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>Tomcat 支持 springboot</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TomcatStartSpringBoot</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SpringBootServletInitializer</span> </span>&#123;<br>    <span class="hljs-comment">// tomcat 启动的时候会调用 configure 方法，从而启动 SpringBoot</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title">configure</span><span class="hljs-params">(SpringApplicationBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> builder.sources(Application.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 idea 中运行</p></li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304252158486.png"></p><h3 id="6-外部-Servlet-容器启动-SpringBoot-应用原理"><a href="#6-外部-Servlet-容器启动-SpringBoot-应用原理" class="headerlink" title="6. 外部 Servlet 容器启动 SpringBoot 应用原理"></a>6. 外部 Servlet 容器启动 SpringBoot 应用原理</h3><p>Tomcat 不会主动去启动 springboot 应用 ，所以 tomcat 启动的时候肯定调用了 SpringBootServletInitializer 的 configure()，就会启动 springboot。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TomcatStartSpringBoot</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">SpringBootServletInitializer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title">configure</span><span class="hljs-params">(SpringApplicationBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> builder.sources(Application.class);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>servlet3.0 规范官方文档： 8.2.4 节</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304252235673.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304252243192.png"></p><p><a href="https://debuggingworld.github.io/2022/11/06/SpringMVC%E2%80%94%E2%80%94%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/#3-2-SPI%E6%96%B9%E5%BC%8F">SPI 传送门</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304252303598.png"></p><p>【注】 AbstractDispatcherServletInitializer 和 AbstractContextLoaderInitializer 是用来注册 ContextLoaderListener 和 DispatcherServlet 的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// @HandlesTypes 会将 WebApplicationInitializer 所有实现类传递到 onStartup()，包括上面的 </span><br><span class="hljs-meta">@HandlesTypes(WebApplicationInitializer.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringServletContainerInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContainerInitializer</span> </span>&#123;<br>   <span class="hljs-meta">@Override</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(<span class="hljs-meta">@Nullable</span> Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span></span><br><span class="hljs-function">         <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br><br>      List&lt;WebApplicationInitializer&gt; initializers = Collections.emptyList();<br><br>      <span class="hljs-keyword">if</span> (webAppInitializerClasses != <span class="hljs-keyword">null</span>) &#123;<br>         initializers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(webAppInitializerClasses.size());<br>         <span class="hljs-keyword">for</span> (Class&lt;?&gt; waiClass : webAppInitializerClasses) &#123;<br>            <span class="hljs-comment">// 如果不是接口 不是抽象 跟WebApplicationInitializer有关系 就会实例化</span><br>            <span class="hljs-keyword">if</span> (!waiClass.isInterface() &amp;&amp; !Modifier.isAbstract(waiClass.getModifiers()) &amp;&amp;<br>                  WebApplicationInitializer.class.isAssignableFrom(waiClass)) &#123;<br>                 initializers.add((WebApplicationInitializer)<br>                        ReflectionUtils.accessibleConstructor(waiClass).newInstance());<br>            &#125;<br>         &#125;<br>      &#125;<br><br>      <span class="hljs-keyword">if</span> (initializers.isEmpty()) &#123;<br>         servletContext.log(<span class="hljs-string">&quot;No Spring WebApplicationInitializer types detected on classpath&quot;</span>);<br>         <span class="hljs-keyword">return</span>;<br>      &#125;<br><br>      servletContext.log(initializers.size() + <span class="hljs-string">&quot; Spring WebApplicationInitializers detected on classpath&quot;</span>);<br>      <span class="hljs-comment">// 排序</span><br>      AnnotationAwareOrderComparator.sort(initializers);<br>      <span class="hljs-keyword">for</span> (WebApplicationInitializer initializer : initializers) &#123;<br>         <span class="hljs-comment">// 调用实例化对象的 onStartup()</span><br>         initializer.onStartup(servletContext);<br>      &#125;<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SpringBootServletInitializer#onStartup：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(ServletContext servletContext)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>   servletContext.setAttribute(LoggingApplicationListener.REGISTER_SHUTDOWN_HOOK_PROPERTY, <span class="hljs-keyword">false</span>);<br>   WebApplicationContext rootApplicationContext = createRootApplicationContext(servletContext);<br>   <span class="hljs-keyword">if</span> (rootApplicationContext != <span class="hljs-keyword">null</span>) &#123;<br>      servletContext.addListener(<span class="hljs-keyword">new</span> SpringBootContextLoaderListener(rootApplicationContext, servletContext));<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title">createRootApplicationContext</span><span class="hljs-params">(ServletContext servletContext)</span> </span>&#123;<br>   SpringApplicationBuilder builder = createSpringApplicationBuilder();<br>   builder.main(getClass());<br>   ApplicationContext parent = getExistingRootWebApplicationContext(servletContext);<br>   <span class="hljs-keyword">if</span> (parent != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">this</span>.logger.info(<span class="hljs-string">&quot;Root context already created (using as parent).&quot;</span>);<br>      servletContext.setAttribute(WebApplicationContext.ROOT_WEB_APPLICATION_CONTEXT_ATTRIBUTE, <span class="hljs-keyword">null</span>);<br>      builder.initializers(<span class="hljs-keyword">new</span> ParentContextApplicationContextInitializer(parent));<br>   &#125;<br>   builder.initializers(<span class="hljs-keyword">new</span> ServletContextApplicationContextInitializer(servletContext));<br>   builder.contextFactory((webApplicationType) -&gt; <span class="hljs-keyword">new</span> AnnotationConfigServletWebServerApplicationContext());<br>   <span class="hljs-comment">// 调用configure</span><br>   builder = configure(builder);<br>   builder.listeners(<span class="hljs-keyword">new</span> WebEnvironmentPropertySourceInitializer(servletContext));<br>   SpringApplication application = builder.build();<br>   <span class="hljs-keyword">if</span> (application.getAllSources().isEmpty()<br>         &amp;&amp; MergedAnnotations.from(getClass(), SearchStrategy.TYPE_HIERARCHY).isPresent(Configuration.class)) &#123;<br>      application.addPrimarySources(Collections.singleton(getClass()));<br>   &#125;<br>   Assert.state(!application.getAllSources().isEmpty(),<br>         <span class="hljs-string">&quot;No SpringApplication sources have been defined. Either override the &quot;</span><br>               + <span class="hljs-string">&quot;configure method or add an @Configuration annotation&quot;</span>);<br>   <span class="hljs-comment">// Ensure error pages are registered</span><br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.registerErrorPageFilter) &#123;<br>      application.addPrimarySources(Collections.singleton(ErrorPageFilterConfiguration.class));<br>   &#125;<br>   application.setRegisterShutdownHook(<span class="hljs-keyword">false</span>);<br>   <span class="hljs-keyword">return</span> run(application);<br>&#125;<br></code></pre></td></tr></table></figure><p>当调用 configure()  就会来到 TomcatStartSpringBoot.configure()。</p><ul><li><p>将 Springboot 启动类传入到 builder.source()，得到 SpringApplicationBuilder。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> SpringApplicationBuilder <span class="hljs-title">configure</span><span class="hljs-params">(SpringApplicationBuilder builder)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> builder.sources(Application.class);<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>builder.build() 就会根据传入的 Springboot 启动类来构建一个SpringApplication。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> SpringApplication <span class="hljs-title">build</span><span class="hljs-params">(String... args)</span> </span>&#123;<br>   configureAsChildIfNecessary(args);<br>   <span class="hljs-keyword">this</span>.application.addPrimarySources(<span class="hljs-keyword">this</span>.sources);<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.application;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>run(application) 就会启动 springboot 应用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> WebApplicationContext <span class="hljs-title">run</span><span class="hljs-params">(SpringApplication application)</span> </span>&#123;<br>   <span class="hljs-keyword">return</span> (WebApplicationContext) application.run();<br>&#125;<br></code></pre></td></tr></table></figure><p>相当于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication.run(Application.class, args);<br>&#125;<br></code></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Swagger</title>
    <link href="/2023/04/08/Swagger/"/>
    <url>/2023/04/08/Swagger/</url>
    
    <content type="html"><![CDATA[<h2 id="1-Swagger2"><a href="#1-Swagger2" class="headerlink" title="1. Swagger2"></a>1. Swagger2</h2><h3 id="1-1-使用"><a href="#1-1-使用" class="headerlink" title="1.1 使用"></a>1.1 使用</h3><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-swagger-ui<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.9.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableSwagger2</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(Application.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问：</p><p><a href="http://localhost:8080/swagger-ui.html">http://localhost:8080/swagger-ui.html</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304090033563.png"></p><p>【注】当的 spring-boot 版本是 2.6.x 的时候，项目启动会报错 Failed to start bean ‘documentationPluginsBootstrapper’; nested exception is java.lang.NullPointerException</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304090038141.png"></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">mvc:</span><br>  <span class="hljs-attr">pathmatch:</span><br>    <span class="hljs-attr">matching-strategy:</span> <span class="hljs-string">ANT_PATH_MATCHER</span><br></code></pre></td></tr></table></figure><h3 id="1-2-配置"><a href="#1-2-配置" class="headerlink" title="1.2 配置"></a>1.2 配置</h3><h4 id="1-基础信息配置"><a href="#1-基础信息配置" class="headerlink" title="1. 基础信息配置"></a>1. 基础信息配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Docket 是 Swagger 中的全局配置对象</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span></span>&#123;<br>    Docket docket = <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2);<br>    <span class="hljs-comment">// API文档描述信息</span><br>    ApiInfo apiInfo = <span class="hljs-keyword">new</span> ApiInfoBuilder()<br>            <span class="hljs-comment">// 文档主体信息</span><br>            .contact(<span class="hljs-keyword">new</span> Contact(<span class="hljs-string">&quot;debuggingWorld文档&quot;</span>,<span class="hljs-string">&quot;https://debuggingworld.github.io&quot;</span>,<span class="hljs-string">&quot;admin@debug.com&quot;</span>))<br>            .title(<span class="hljs-string">&quot;debuggingWorld开发文档&quot;</span>)<br>            .description(<span class="hljs-string">&quot;debuggingWorld开发文档详细描述&quot;</span>)<br>            .version(<span class="hljs-string">&quot;2.1&quot;</span>)<br>            .build();<br>    docket.apiInfo(apiInfo);<br>    <span class="hljs-keyword">return</span> docket;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304090103163.png"></p><h4 id="2-开关设置"><a href="#2-开关设置" class="headerlink" title="2. 开关设置"></a>2. 开关设置</h4><p>生产环境需要关闭。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Docket <span class="hljs-title">docket</span><span class="hljs-params">()</span></span>&#123;<br>  <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Docket(DocumentationType.SWAGGER_2).enable(<span class="hljs-keyword">false</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304092339074.png"></p><h4 id="3-扫描包配置"><a href="#3-扫描包配置" class="headerlink" title="3. 扫描包配置"></a>3. 扫描包配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">docket<br>        .select()   <span class="hljs-comment">// 获取 Docket 中的选择器，返回 ApiSelectorBuilder 选择器构建器</span><br>        <span class="hljs-comment">// 设定扫描哪些包的注解</span><br>        .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.debuggingWorld.controller&quot;</span>)).build();<br></code></pre></td></tr></table></figure><h4 id="4-设置自定义注解不生成接口文档"><a href="#4-设置自定义注解不生成接口文档" class="headerlink" title="4. 设置自定义注解不生成接口文档"></a>4. 设置自定义注解不生成接口文档</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@NotIncludeSwagger</span><br><span class="hljs-meta">@RequestMapping(&quot;/req&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">req</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;req&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">docket<br>        .select()   <span class="hljs-comment">// 获取 Docket 中的选择器，返回 ApiSelectorBuilder 选择器构建器</span><br>        <span class="hljs-comment">// 设定扫描哪些包的注解</span><br>        .apis(RequestHandlerSelectors.basePackage(<span class="hljs-string">&quot;com.debuggingWorld.controller&quot;</span>))<br>        <span class="hljs-comment">// 包含 NotIncludeSwagger 注解时不生成接口文档</span><br>        .apis(Predicates.not(RequestHandlerSelectors.withMethodAnnotation(NotIncludeSwagger.class))).build();;<br></code></pre></td></tr></table></figure><h4 id="5-路径范围配置"><a href="#5-路径范围配置" class="headerlink" title="5. 路径范围配置"></a>5. 路径范围配置</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">docket.select()<br>        <span class="hljs-comment">// 使用正则表达式约束生成接口文档的路径范围</span><br>        .paths(<br>                Predicates.or(<br>                        PathSelectors.regex(<span class="hljs-string">&quot;/debugging/.*&quot;</span>),<br>                        PathSelectors.regex(<span class="hljs-string">&quot;/debugging2/.*&quot;</span>)<br>                )).build();<br></code></pre></td></tr></table></figure><h3 id="1-3-常用注解"><a href="#1-3-常用注解" class="headerlink" title="1.3 常用注解"></a>1.3 常用注解</h3><h4 id="1-Api"><a href="#1-Api" class="headerlink" title="1. Api"></a>1. Api</h4><p>作用域：类</p><p>属性：</p><ul><li>tags：给当前类定义别名，几个别名就在 UI 中显示几个控制器访问菜单</li><li>description：当前类描述信息</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@Api(tags = &#123;&quot;MyController&quot;, &quot;Swagger控制器&quot;&#125;,description = &quot;MyController 描述信息&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyController</span> </span>&#123;<br>    <span class="hljs-meta">@PostMapping(&quot;/debugging/post&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">post</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;post&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>UI 显示效果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304091110565.png"></p><h4 id="2-ApiOperation"><a href="#2-ApiOperation" class="headerlink" title="2. ApiOperation"></a>2. ApiOperation</h4><p>作用域：类、方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/debugging/post&quot;)</span><br><span class="hljs-meta">@ApiOperation(value = &quot;post 方法，用于数据新增&quot;,notes = &quot;MyController post 方法&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">post</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;post&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@PostMapping(&quot;/debugging/debug&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">debug</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;debug&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304091119092.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304091156831.png"></p><h4 id="3-ApiParam"><a href="#3-ApiParam" class="headerlink" title="3. ApiParam"></a>3. ApiParam</h4><p>作用域：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ElementType.PARAMETER, ElementType.METHOD, ElementType.FIELD<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/debugging/post&quot;)</span><br><span class="hljs-meta">@ApiOperation(value = &quot;post 方法，用于数据新增&quot;, notes = &quot;MyController post 方法&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">post</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-meta">@ApiParam(name = &quot;用户名(name)&quot;, value = &quot;新增用户名称&quot;)</span> String name,</span></span><br><span class="hljs-params"><span class="hljs-function">        <span class="hljs-meta">@ApiParam(name = &quot;密码(pwd)&quot;, value = &quot;新增用户密码&quot;)</span> String pwd)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;post&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@PostMapping(&quot;/debugging/debug&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">debug</span><span class="hljs-params">(String name, String pwd)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;debug&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>效果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304091204746.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304091207238.png"></p><h4 id="4-ApiIgnore"><a href="#4-ApiIgnore" class="headerlink" title="4. ApiIgnore"></a>4. ApiIgnore</h4><p>作用域：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&#123;ElementType.METHOD, ElementType.TYPE, ElementType.PARAMETER&#125;<br></code></pre></td></tr></table></figure><p>忽略当前方法或类型不生成接口文档。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ApiIgnore</span><br><span class="hljs-meta">@GetMapping(&quot;/debugging/get&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">get</span><span class="hljs-params">(String name, String pwd)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;get&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-ApiImplicitParam"><a href="#5-ApiImplicitParam" class="headerlink" title="5. ApiImplicitParam"></a>5. ApiImplicitParam</h4><p>作用域：方法</p><p>参数说明：</p><ul><li>name：参数名</li><li>value：参数描述</li><li>required：是否必须参数</li><li>paramType：参数位置<ul><li>header：请求参数的获取 –&gt; @RequestHeader</li><li>query：请求参数的获取 –&gt; @RequestParam（get 方法默认值）</li><li>body ：请求参数的获取 –&gt;@RequestBody （post 方法默认值）</li><li>path：请求参数的获取 –&gt; @PathVariable（用于 restful 接口）</li><li>div</li><li>form</li></ul></li><li>dataType：参数类型，默认值：String</li><li>defaultValue：参数默认值</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/debugging/debug&quot;)</span><br><span class="hljs-comment">//@ApiImplicitParam( name = &quot;name&quot;, value = &quot;新增用户名称&quot;,required = true,paramType = &quot;query&quot;,dataType = &quot;string&quot;)</span><br><span class="hljs-meta">@ApiImplicitParams(value = &#123;</span><br><span class="hljs-meta">        @ApiImplicitParam(name = &quot;name&quot;, value = &quot;新增用户名称&quot;, required = true, paramType = &quot;query&quot;, dataType = &quot;string&quot;),</span><br><span class="hljs-meta">        @ApiImplicitParam(name = &quot;pwd&quot;, value = &quot;新增用户密码&quot;, paramType = &quot;query&quot;, dataType = &quot;string&quot;)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">debug</span><span class="hljs-params">(String name, String pwd)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;debug&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304092309045.png"></p><h4 id="6-ApiModel、ApiModelProperty"><a href="#6-ApiModel、ApiModelProperty" class="headerlink" title="6. ApiModel、ApiModelProperty"></a>6. ApiModel、ApiModelProperty</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 描述生成接口文档返回值类型</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@ApiModel(value = &quot;用户实体&quot;,description = &quot;保存用户数据&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserEntity</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-meta">@ApiModelProperty(value = &quot;主键&quot;,name = &quot;主键(id)&quot;,required = false,example = &quot;1&quot;,hidden = true)</span><br>    <span class="hljs-keyword">private</span> String id;<br>    <span class="hljs-meta">@ApiModelProperty(value = &quot;姓名&quot;,name = &quot;姓名(name)&quot;,required = true,example = &quot;debuggingWorld&quot;,hidden = false)</span><br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-meta">@ApiModelProperty(value = &quot;密码&quot;,name = &quot;密码(pwd)&quot;,required = true,example = &quot;admin&quot;,hidden = false)</span><br>    <span class="hljs-keyword">private</span> String pwd;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/debugging/user&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> UserEntity <span class="hljs-title">getUser</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserEntity();<br>&#125;<br></code></pre></td></tr></table></figure><p>UI显示：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304091244743.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304091245156.png"></p><h4 id="7-ApiResponses、ApiResponse"><a href="#7-ApiResponses、ApiResponse" class="headerlink" title="7. ApiResponses、ApiResponse"></a>7. ApiResponses、ApiResponse</h4><p>描述响应信息</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/debugging/user/&#123;id&#125;&quot;)</span><br><span class="hljs-meta">@ApiOperation(&quot;根据用户ID获取用户信息&quot;)</span><br><span class="hljs-meta">@ApiImplicitParam(name = &quot;id&quot;,value = &quot;用户编号&quot;,required = true,paramType = &quot;path&quot;)</span><br><span class="hljs-meta">@ApiResponses(&#123;</span><br><span class="hljs-meta">        @ApiResponse(code = 400,message = &quot;参数不合法&quot;),</span><br><span class="hljs-meta">        @ApiResponse(code = 410,message = &quot;获取用户信息失败&quot;),</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> UserEntity <span class="hljs-title">getUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> String id)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserEntity(id,<span class="hljs-string">&quot;debuggingWorld&quot;</span>,<span class="hljs-string">&quot;admin&quot;</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304092326405.png"></p><h2 id="2-Swagger3"><a href="#2-Swagger3" class="headerlink" title="2. Swagger3"></a>2. Swagger3</h2><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>io.springfox<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>springfox-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@EnableOpenApi</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(Application.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>访问：</p><p><a href="http://localhost:8080/swagger-ui/index.html">http://localhost:8080/swagger-ui/index.html</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304090014174.png"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Swagger</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot——Web开发&amp;SpringMvc自动配置</title>
    <link href="/2023/04/06/Spring-Boot%E2%80%94%E2%80%94Web%E5%BC%80%E5%8F%91-SpringMvc%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/"/>
    <url>/2023/04/06/Spring-Boot%E2%80%94%E2%80%94Web%E5%BC%80%E5%8F%91-SpringMvc%E8%87%AA%E5%8A%A8%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="1-SpringMVC-快速使用"><a href="#1-SpringMVC-快速使用" class="headerlink" title="1. SpringMVC 快速使用"></a>1. SpringMVC 快速使用</h3><h4 id="1-1-基于-restful-接口的-CRUD"><a href="#1-1-基于-restful-接口的-CRUD" class="headerlink" title="1.1 基于 restful 接口的 CRUD"></a>1.1 基于 restful 接口的 CRUD</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    UserService userService;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;User&gt; <span class="hljs-title">getUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> </span>&#123;<br>        User user = userService.getUserById(id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result&lt;&gt;(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;查询成功&quot;</span>, user);<br>    &#125;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/add&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">addUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> </span>&#123;<br>        userService.add(user);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result&lt;&gt;(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;添加成功&quot;</span>, userService.getAllUser());<br>    &#125;<br><br>    <span class="hljs-meta">@PutMapping(&quot;/edit&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">editUser</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> </span>&#123;<br>        userService.update(user);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result&lt;&gt;(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;修改成功&quot;</span>, userService.getAllUser());<br>    &#125;<br><br>    <span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">deleteUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> </span>&#123;<br>        userService.delete(id);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;删除成功&quot;</span>, userService.getAllUser());<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="1-2-rest-接口调用"><a href="#1-2-rest-接口调用" class="headerlink" title="1.2 rest 接口调用"></a>1.2 rest 接口调用</h4><h5 id="1-通过-RestTemplate-调用"><a href="#1-通过-RestTemplate-调用" class="headerlink" title="1. 通过 RestTemplate 调用"></a>1. 通过 <strong>RestTemplate</strong> 调用</h5><p>WebClient 也可以调用远程服务， 区别是 webclient 依赖 webflux , webclient 请求远程服务是无阻塞的。 RestTemplate 它是阻塞的，需要等待请求响应后才能执行下一句代码。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304070153213.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderController</span> </span>&#123;<br>    <br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> RestTemplate restTemplate;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">OrderController</span><span class="hljs-params">(RestTemplateBuilder restTemplateBuilder)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.restTemplate = restTemplateBuilder.build();<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/order&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 查询</span><br>        Result result = restTemplate.getForObject(<span class="hljs-string">&quot;http://localhost:8080/user/&#123;id&#125;&quot;</span>, Result.class, <span class="hljs-number">1</span>);<br>        System.out.println(result);<br><br>        <br>        <span class="hljs-comment">// 增加</span><br>        <span class="hljs-comment">// object : post请求的参数</span><br>        <span class="hljs-comment">// Class&lt;T&gt;：返回的类型</span><br>        <span class="hljs-comment">// ...Object: 是@PathVariable占位符的参数</span><br>        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;QA&quot;</span>);<br>        ResponseEntity&lt;Result&gt; responseEntity = restTemplate.postForEntity(<span class="hljs-string">&quot;http://localhost:8080/user/add&quot;</span>, user, Result.class);<br>        <span class="hljs-comment">// 200 OK</span><br>        System.out.println(responseEntity.getStatusCode());<br>        <span class="hljs-comment">// 200</span><br>        System.out.println(responseEntity.getStatusCodeValue());<br>        <span class="hljs-comment">// Result(code=200, message=添加成功, data=null)</span><br>        System.out.println(responseEntity.getBody());<br><br><br>        <span class="hljs-comment">// 修改</span><br>        User user1 = <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;QA&quot;</span>);<br>        <span class="hljs-comment">// put 没有返回值</span><br>        <span class="hljs-comment">// restTemplate.put(&quot;http://localhost:8080/user/edit&quot;,user1);</span><br>        HttpEntity&lt;User&gt; userHttpEntity = <span class="hljs-keyword">new</span> HttpEntity&lt;&gt;(user1);<br>        ResponseEntity&lt;Result&gt; response = restTemplate.exchange(<span class="hljs-string">&quot;http://localhost:8080/user/edit&quot;</span>, HttpMethod.PUT, userHttpEntity, Result.class);<br><br><br>        <span class="hljs-comment">//删除  delete无返回值</span><br>        ResponseEntity&lt;Result&gt; response1 = restTemplate.exchange(<span class="hljs-string">&quot;http://localhost:8080/user/&#123;id&#125;&quot;</span>, HttpMethod.DELETE, <span class="hljs-keyword">null</span>, Result.class, <span class="hljs-number">1</span>);<br><br>        <span class="hljs-keyword">return</span> response1.toString();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>也可以在单元测试下使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationTest</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">contextLoads</span><span class="hljs-params">()</span> </span>&#123;<br>        TestRestTemplate restTemplate = <span class="hljs-keyword">new</span> TestRestTemplate();<br>        ResponseEntity&lt;Result&gt; response = restTemplate.exchange(<span class="hljs-string">&quot;http://localhost:8080/user/&#123;id&#125;&quot;</span>, HttpMethod.DELETE, <span class="hljs-keyword">null</span>, Result.class, <span class="hljs-number">1</span>);<br><br>        System.out.println(response);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【注】在当前服务中增加单元测试，并且需要启动当前服务。</p><h5 id="2-通过-MockMvc-测试"><a href="#2-通过-MockMvc-测试" class="headerlink" title="2. 通过 MockMvc 测试"></a>2. 通过 MockMvc 测试</h5><p>MockMvc 是由 spring-test 包提供，实现了对 Http 请求的模拟，能够直接使用网络的形式，转换到 Controller 的调用，使得测试速度快、不依赖网络环境。同时提供了一套验证的工具，结果的验证十分方便。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@AutoConfigureMockMvc</span>   <span class="hljs-comment">// 依赖junit5,如果没有该注解需要通过代码构建MockMvc</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MockMvcTest</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    MockMvc mockMvc;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testMockMvcGet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-comment">// 发起一个模拟请求，不依赖 web 服务，不需要启动 web 应用</span><br>        mockMvc.perform(<br>                        MockMvcRequestBuilders.get(<span class="hljs-string">&quot;/user/&#123;id&#125;&quot;</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment">// 发送 get 请求</span><br>                                .accept(MediaType.APPLICATION_JSON) <span class="hljs-comment">// 设置响应的文本类型</span><br>                        <span class="hljs-comment">// .param(name,value)   ?name=xx&amp;age=xx</span><br>                )<br>                <span class="hljs-comment">// 设置断言</span><br>                .andExpect(MockMvcResultMatchers.status().isOk())  <span class="hljs-comment">// 设置断言</span><br>                .andExpect(MockMvcResultMatchers.jsonPath(<span class="hljs-string">&quot;$.data.username&quot;</span>).value(<span class="hljs-string">&quot;zhangsan&quot;</span>))<br>                .andDo(MockMvcResultHandlers.print());<br>    &#125;<br>    <br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testMockMvcPost</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        String user = <span class="hljs-string">&quot;&#123;\&quot;username\&quot;:\&quot;debuggingWorld\&quot;,\&quot;address\&quot;:\&quot;aaa\&quot;&#125;&quot;</span>;<br><br>        mockMvc.perform(<br>                        MockMvcRequestBuilders.post(<span class="hljs-string">&quot;/user/add&quot;</span>, <span class="hljs-number">1</span>)  <span class="hljs-comment">// 发送 get 请求</span><br>                                .accept(MediaType.APPLICATION_JSON) <span class="hljs-comment">// 设置响应文本类型</span><br>                                .contentType(MediaType.APPLICATION_JSON)    <span class="hljs-comment">// 设置请求文本类型</span><br>                                .content(user)  <span class="hljs-comment">// json 数据</span><br>                )<br>                <span class="hljs-comment">// 设置断言</span><br>                .andExpect(MockMvcResultMatchers.status().isOk())  <span class="hljs-comment">// 设置断言</span><br>                .andExpect(MockMvcResultMatchers.jsonPath(<span class="hljs-string">&quot;$.data.length()&quot;</span>).value(<span class="hljs-number">6</span>))<br>                .andDo(MockMvcResultHandlers.print());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试结果打印：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304081227011.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304081228536.png"></p><h3 id="2-SpringMVC-自动配置原理"><a href="#2-SpringMVC-自动配置原理" class="headerlink" title="2. SpringMVC 自动配置原理"></a>2. SpringMVC 自动配置原理</h3><p>Spring Boot 为 Spring MVC 提供了自动配置，可与大多数应用程序完美配合。</p><p>自动配置在 Spring 的默认值之上添加了以下功能：</p><ul><li>Inclusion of <code>ContentNegotiatingViewResolver</code> and <code>BeanNameViewResolver</code> beans.</li><li>Support for serving static resources, including support for WebJars </li><li>Automatic registration of <code>Converter</code>, <code>GenericConverter</code>, and <code>Formatter</code> beans.</li><li>Support for <code>HttpMessageConverters</code> </li><li>Automatic registration of <code>MessageCodesResolver</code> </li><li>Static <code>index.html</code> support.</li><li>Automatic use of a <code>ConfigurableWebBindingInitializer</code> bean </li></ul><h4 id="2-1-自动配置视图解析器"><a href="#2-1-自动配置视图解析器" class="headerlink" title="2.1 自动配置视图解析器"></a>2.1 自动配置视图解析器</h4><p>包含 ContentNegotiatingViewResolver 和 BeanNameViewResolver，都是 SpringMVC 内置的视图解析器。</p><ol><li><p>ContentNegotiatingViewResolver </p><p>他并不会解析视图、而是委派给其他视图解析器进行解析。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> View <span class="hljs-title">resolveViewName</span><span class="hljs-params">(String viewName, Locale locale)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>   RequestAttributes attrs = RequestContextHolder.getRequestAttributes();<br>   Assert.state(attrs <span class="hljs-keyword">instanceof</span> ServletRequestAttributes, <span class="hljs-string">&quot;No current ServletRequestAttributes&quot;</span>);<br>   List&lt;MediaType&gt; requestedMediaTypes = getMediaTypes(((ServletRequestAttributes) attrs).getRequest());<br>   <span class="hljs-keyword">if</span> (requestedMediaTypes != <span class="hljs-keyword">null</span>) &#123;<br>   <span class="hljs-comment">// 获得所有匹配的视图</span><br>  List&lt;View&gt; candidateViews = getCandidateViews(viewName, locale, requestedMediaTypes);<br>   <span class="hljs-comment">// 获取最终的这个</span><br>  View bestView = getBestView(candidateViews, requestedMediaTypes, attrs);<br>  <span class="hljs-keyword">if</span> (bestView != <span class="hljs-keyword">null</span>) &#123;<br> <span class="hljs-keyword">return</span> bestView;<br>  &#125;<br>   &#125;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 委派给其他视图解析器进行解析：</p><p> ContentNegotiatingViewResolver#initServletContext</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initServletContext</span><span class="hljs-params">(ServletContext servletContext)</span> </span>&#123;<br>   Collection&lt;ViewResolver&gt; matchingBeans =<br> BeanFactoryUtils.beansOfTypeIncludingAncestors(obtainApplicationContext(), ViewResolver.class).values();<br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.viewResolvers == <span class="hljs-keyword">null</span>) &#123;<br>  <span class="hljs-keyword">this</span>.viewResolvers = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;(matchingBeans.size());<br>  <span class="hljs-keyword">for</span> (ViewResolver viewResolver : matchingBeans) &#123;<br> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != viewResolver) &#123;<br><span class="hljs-keyword">this</span>.viewResolvers.add(viewResolver);<br> &#125;<br>  &#125;<br>   &#125;<br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><ol start="2"><li><p>BeanNameViewResolver</p><p>会根据 handler 方法返回的视图名称 (DebugView), 去 ioc 容器中到到名字叫 DebugView 的一个 Bean，并且这个 bean 要实现 VIew 接口.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@GetMapping(&quot;/test&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;debugView&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugView</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">View</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getContentType</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span>  <span class="hljs-string">&quot;text/html&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">render</span><span class="hljs-params">(Map&lt;String, ?&gt; model, HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        response.getWriter().print(<span class="hljs-string">&quot;Welcome to debuggingWorld&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-2-静态资源支持"><a href="#2-2-静态资源支持" class="headerlink" title="2.2 静态资源支持"></a>2.2 静态资源支持</h4><p>支持提供静态资源，包括对 WebJars 的支持。</p><p>以前要访问 jpg、css、js 等这些静态资源文件，需要在 web.xml 配置 。在 springboot 不需要配置，只需要放在约定文件夹中就可以（<strong>约定大于配置</strong>）。</p><p>WebMvcAutoConfigurationAdapter#addResourceHandlers：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addResourceHandlers</span><span class="hljs-params">(ResourceHandlerRegistry registry)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.resourceProperties.isAddMappings()) &#123;<br>      logger.debug(<span class="hljs-string">&quot;Default resource handling disabled&quot;</span>);<br>      <span class="hljs-keyword">return</span>;<br>   &#125;<br>   addResourceHandler(registry, <span class="hljs-string">&quot;/webjars/**&quot;</span>, <span class="hljs-string">&quot;classpath:/META-INF/resources/webjars/&quot;</span>);<br>   addResourceHandler(registry, <span class="hljs-keyword">this</span>.mvcProperties.getStaticPathPattern(), (registration) -&gt; &#123;<br>      registration.addResourceLocations(<span class="hljs-keyword">this</span>.resourceProperties.getStaticLocations());<br>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.servletContext != <span class="hljs-keyword">null</span>) &#123;<br>         ServletContextResource resource = <span class="hljs-keyword">new</span> ServletContextResource(<span class="hljs-keyword">this</span>.servletContext, SERVLET_LOCATION);<br>         registration.addResourceLocations(resource);<br>      &#125;<br>   &#125;);<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>WebJars </p><p>WebJars 就是将静态资源放在 jar 包中进行访问。官网：<a href="https://www.webjars.org/">https://www.webjars.org/</a></p><p>当访问 /webjars/** 时就会映射到 classpath:/META-INF/resources/webjars/</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.webjars<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jquery<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.6.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304192316598.png"></p><p><a href="http://127.0.0.1:8080/webjars/jquery/3.6.4/jquery.js">http://127.0.0.1:8080/webjars/jquery/3.6.4/jquery.js</a>  ===&gt; /META-INF/resources/webjars/juqery/3.6.4/jquery.js</p></li><li><p>静态文件映射</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String[] CLASSPATH_RESOURCE_LOCATIONS = &#123; <span class="hljs-string">&quot;classpath:/META-INF/resources/&quot;</span>,<br>      <span class="hljs-string">&quot;classpath:/resources/&quot;</span>, <span class="hljs-string">&quot;classpath:/static/&quot;</span>, <span class="hljs-string">&quot;classpath:/public/&quot;</span> &#125;;<br><br><span class="hljs-keyword">private</span> String[] staticLocations = CLASSPATH_RESOURCE_LOCATIONS;<br><br><span class="hljs-keyword">public</span> String[] getStaticLocations() &#123;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.staticLocations;<br>&#125;<br><br></code></pre></td></tr></table></figure></li><li><p>配置欢迎页</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> Optional&lt;Resource&gt; <span class="hljs-title">getWelcomePage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 拿到上面静态资源地址</span><br>    String[] locations = getResourceLocations(<span class="hljs-keyword">this</span>.resourceProperties.getStaticLocations());<br>    <span class="hljs-comment">// 去里面找一个index.html的首页</span><br>    <span class="hljs-keyword">return</span> Arrays.stream(locations).map(<span class="hljs-keyword">this</span>::getIndexHtml).filter(<span class="hljs-keyword">this</span>::isReadable).findFirst();<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-3-自动注册-Converter，GenericConverter-和-Formatter"><a href="#2-3-自动注册-Converter，GenericConverter-和-Formatter" class="headerlink" title="2.3 自动注册 Converter，GenericConverter 和 Formatter"></a>2.3 自动注册 Converter，GenericConverter 和 Formatter</h4><h4 id="2-4-支持-HttpMessageConverters"><a href="#2-4-支持-HttpMessageConverters" class="headerlink" title="2.4 支持 HttpMessageConverters"></a>2.4 支持 HttpMessageConverters</h4><p>HttpMessageConverters 负责 http 请求和响应的报文处理。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304202247507.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfiguration(</span><br><span class="hljs-meta">      after = &#123; GsonAutoConfiguration.class, JacksonAutoConfiguration.class, JsonbAutoConfiguration.class &#125;)</span><br><span class="hljs-meta">@ConditionalOnClass(HttpMessageConverter.class)</span><br><span class="hljs-meta">@Conditional(NotReactiveWebApplicationCondition.class)</span><br><span class="hljs-meta">@Import(&#123; JacksonHttpMessageConvertersConfiguration.class, GsonHttpMessageConvertersConfiguration.class,</span><br><span class="hljs-meta">      JsonbHttpMessageConvertersConfiguration.class &#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HttpMessageConvertersAutoConfiguration</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-5-自动注册-MessageCodesResolver"><a href="#2-5-自动注册-MessageCodesResolver" class="headerlink" title="2.5 自动注册 MessageCodesResolver"></a>2.5 自动注册 MessageCodesResolver</h4><p>修改 4xx 错误下类型转换错误的错误代码。</p><p>默认格式：errorCode + “.” + object name + “.” + field    例：typeMismatch.user.birthday</p><p>可以通过 spring.mvc.message-codes-resolver-format=POSTFIX_ERROR_CODE  修改为：object name + “.” + field + “.” + errorCode</p><h4 id="2-6-静态-index-html-支持"><a href="#2-6-静态-index-html-支持" class="headerlink" title="2.6 静态 index.html 支持"></a>2.6 静态 index.html 支持</h4><p>在 springboot 中可以直接返回 html 的视图</p><p>因为在自动 WebMvcAutoConfiguration 配置类配置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> InternalResourceViewResolver <span class="hljs-title">defaultViewResolver</span><span class="hljs-params">()</span> </span>&#123;<br>   InternalResourceViewResolver resolver = <span class="hljs-keyword">new</span> InternalResourceViewResolver();<br>   resolver.setPrefix(<span class="hljs-keyword">this</span>.mvcProperties.getView().getPrefix());<br>   resolver.setSuffix(<span class="hljs-keyword">this</span>.mvcProperties.getView().getSuffix());<br>   <span class="hljs-keyword">return</span> resolver;<br>&#125;<br></code></pre></td></tr></table></figure><p>在配置文件中配置：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">spring.mvc.view.prefix</span>=<span class="hljs-string">/pages/</span><br><span class="hljs-meta">spring.mvc.view.suffix</span>=<span class="hljs-string">.html</span><br></code></pre></td></tr></table></figure><h4 id="2-7-自动使用-ConfigurableWebBindingInitializer"><a href="#2-7-自动使用-ConfigurableWebBindingInitializer" class="headerlink" title="2.7 自动使用 ConfigurableWebBindingInitializer"></a>2.7 自动使用 ConfigurableWebBindingInitializer</h4><h3 id="3-定制-SpringMvc-的自动配置"><a href="#3-定制-SpringMvc-的自动配置" class="headerlink" title="3. 定制 SpringMvc 的自动配置"></a>3. 定制 SpringMvc 的自动配置</h3><p>SpringMVC的自动配置类：WebMvcAutoConfiguration</p><p>在大多数情况，SpringBoot 在自动配置中标记了很多 @ConditionalOnMissingBean(xxxxxxxxx.class) (如果容器中没有，当前的 @bean 才会生效）。 只需要在自己的配置类中配置对应的一个 @Bean 就可以覆盖默认自动配置。</p><h4 id="3-1-通过-WebMvcConfigurer-进行扩展"><a href="#3-1-通过-WebMvcConfigurer-进行扩展" class="headerlink" title="3.1 通过 WebMvcConfigurer 进行扩展"></a>3.1 通过 WebMvcConfigurer 进行扩展</h4><h5 id="1-扩展拦截器"><a href="#1-扩展拦截器" class="headerlink" title="1. 扩展拦截器"></a>1. 扩展拦截器</h5><p>拦截器定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TimeInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>    LocalDateTime begin;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        begin = LocalDateTime.now();<br>        log.info(<span class="hljs-string">&quot;当前请求：&quot;</span> + request.getRequestURI() + <span class="hljs-string">&quot; 开始时间：&quot;</span> + begin);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        LocalDateTime end = LocalDateTime.now();<br>        Duration between = Duration.between(begin, end);<br>        <span class="hljs-keyword">long</span> time = between.toMillis();<br>        log.info(<span class="hljs-string">&quot;当前请求：&quot;</span> + request.getRequestURI() + <span class="hljs-string">&quot; 执行时间：&quot;</span> + time + <span class="hljs-string">&quot;毫秒&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        <span class="hljs-comment">// 添加拦截器</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> TimeInterceptor())<br>                <span class="hljs-comment">// 拦截映射规则</span><br>                .addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>)<br>                <span class="hljs-comment">//设置排除的映射规则</span><br>                .excludePathPatterns(<span class="hljs-string">&quot;/pages/**&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-扩展全局-CORS"><a href="#2-扩展全局-CORS" class="headerlink" title="2. 扩展全局 CORS"></a>2. 扩展全局 CORS</h5><p>CORS：跨域资源访问</p><p>全局 CORS 配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyWebMvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addCorsMappings</span><span class="hljs-params">(CorsRegistry registry)</span> </span>&#123;<br>        <span class="hljs-comment">// 映射跨域访问的接口</span><br>        registry.addMapping(<span class="hljs-string">&quot;/user/*&quot;</span>)<br>                <span class="hljs-comment">// 配置哪些来源可以跨域访问</span><br>                .allowedOrigins(<span class="hljs-string">&quot;http://127.0.0.1:8081&quot;</span>)<br>                <span class="hljs-comment">// 配置跨域访问的请求方法</span><br>                .allowedMethods(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;POST&quot;</span>, <span class="hljs-string">&quot;DELETE&quot;</span>, <span class="hljs-string">&quot;PUT&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>指定接口 CORS 配置：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@DeleteMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-meta">@CrossOrigin</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">deleteUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> </span>&#123;<br>    userService.delete(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-number">200</span>, <span class="hljs-string">&quot;删除成功&quot;</span>, userService.getAllUser());<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="3-WebMvcConfigurer-原理"><a href="#3-WebMvcConfigurer-原理" class="headerlink" title="3. WebMvcConfigurer 原理"></a>3. WebMvcConfigurer 原理</h5><p>实现 WebMvcConfigurer 接口既可以扩展 Mvc 实现， 又可以保留 SpringBoot 的自动配置。</p><ol><li><p>SpringMVC 的自动配置类 WebMvcAutoConfiguration 中有一个内部类 WebMvcAutoConfigurationAdapter，实现了 WebMvcConfigurer。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration(proxyBeanMethods = false)</span><br><span class="hljs-meta">@Import(EnableWebMvcConfiguration.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties(&#123; WebMvcProperties.class, WebProperties.class &#125;)</span><br><span class="hljs-meta">@Order(0)</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcAutoConfigurationAdapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span>, <span class="hljs-title">ServletContextAware</span> </span>&#123;<br>   <span class="hljs-comment">// ……</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>导入了 EnableWebMvcConfiguration。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EnableWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ResourceLoaderAware</span> </span>&#123;<br><span class="hljs-comment">// ……</span><br>&#125;<br></code></pre></td></tr></table></figure><p> EnableWebMvcConfiguration 父类 DelegatingWebMvcConfiguration 实现：</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WebMvcConfigurerComposite configurers = <span class="hljs-keyword">new</span> WebMvcConfigurerComposite();<br><br>   <span class="hljs-meta">@Autowired(required = false)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setConfigurers</span><span class="hljs-params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>&#123;<br>  <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;<br> <span class="hljs-keyword">this</span>.configurers.addWebMvcConfigurers(configurers);<br>  &#125;<br>   &#125;<br><br><span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>将容器中所有实现了 WebMvcConfigurer 接口的 Bean 都自动注入进来， 添加到 configurers 变量中。</p><p>添加到 delegates 委派器中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addWebMvcConfigurers</span><span class="hljs-params">(List&lt;WebMvcConfigurer&gt; configurers)</span> </span>&#123;<br>   <span class="hljs-keyword">if</span> (!CollectionUtils.isEmpty(configurers)) &#123;<br>      <span class="hljs-keyword">this</span>.delegates.addAll(configurers);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>底层调用 WebMvcConfigurer 对应的方法时，就是拿到之前注入到 delegates 的 WebMvcConfigurer，依次调用。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>   <span class="hljs-keyword">for</span> (WebMvcConfigurer delegate : <span class="hljs-keyword">this</span>.delegates) &#123;<br>  delegate.addInterceptors(registry);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><strong>添加了 @EnableWebMvc 就不会使用 SpringMVC 自动配置类的默认配置了</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Import(DelegatingWebMvcConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableWebMvc &#123;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li><p>在 @EnableWebMvc 中引入 DelegatingWebMvcConfiguration。</p> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DelegatingWebMvcConfiguration</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">WebMvcConfigurationSupport</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>在 WebMvcAutoConfiguration 中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfiguration(after = &#123; DispatcherServletAutoConfiguration.class, TaskExecutionAutoConfiguration.class,</span><br><span class="hljs-meta">      ValidationAutoConfiguration.class &#125;)</span><br><span class="hljs-meta">@ConditionalOnWebApplication(type = Type.SERVLET)</span><br><span class="hljs-meta">@ConditionalOnClass(&#123; Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class &#125;)</span><br><span class="hljs-meta">@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</span><br><span class="hljs-meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE + 10)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebMvcAutoConfiguration</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>@ConditionalOnMissingBean(WebMvcConfigurationSupport.class) 当容器中不存在 WebMvcConfigurationSupport 这个 Bean 的时候当前自动配置类才会生效。正因为通过 @EnableWebMvc 导入了 DelegatingWebMvcConfiguration 从而使自动配置类失效。</p></li></ol><h4 id="3-2-Json-开发"><a href="#3-2-Json-开发" class="headerlink" title="3.2 Json 开发"></a>3.2 Json 开发</h4><p>Spring Boot 提供了与三个 JSON 映射库的集成：</p><ul><li>Gson</li><li>Jackson（默认）</li><li>JSON-B</li></ul><h5 id="1-jsckson-的使用"><a href="#1-jsckson-的使用" class="headerlink" title="1. jsckson 的使用"></a>1. jsckson 的使用</h5><ol><li><p>@JsonIgnore</p><p>进行排除 json 序列化，标注在不需要序列化的属性上。</p></li><li><p>@JsonFormat</p><p>日期格式化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JsonFormat(pattern = &quot;yyyy-MM-dd HH:mm:ss&quot;, timezone = &quot;GMT+8&quot;)</span><br></code></pre></td></tr></table></figure></li><li><p>@JsonInclude</p><p>复合条件序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JsonInclude(JsonInclude.Include.NON_EMPTY)</span><br></code></pre></td></tr></table></figure></li><li><p>@JsonProperty</p><p>设置别名</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JsonProperty(&quot;name&quot;)</span><br></code></pre></td></tr></table></figure></li></ol><h5 id="2-JsonComponent"><a href="#2-JsonComponent" class="headerlink" title="2. @JsonComponent"></a>2. @JsonComponent</h5><p>根据自己的业务需求进行 json 的序列化和反序列化。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@JsonComponent</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserJsonCustom</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Serializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JsonObjectSerializer</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">serializeObject</span><span class="hljs-params">(User user, JsonGenerator jsonGen, SerializerProvider provider)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>            jsonGen.writeObjectField(<span class="hljs-string">&quot;id&quot;</span>, user.getId());<br>            jsonGen.writeObjectField(<span class="hljs-string">&quot;uname&quot;</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>);<br>            <span class="hljs-comment">// 根据需求自定义。如二次查询、根据不同的权限序列化不同的数据</span><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Deserializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">JsonObjectDeserializer</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">protected</span> User <span class="hljs-title">deserializeObject</span><span class="hljs-params">(JsonParser jsonParser, DeserializationContext context, ObjectCodec codec, JsonNode tree)</span> </span>&#123;<br>            User user = <span class="hljs-keyword">new</span> User();<br>            user.setId(tree.findValue(<span class="hljs-string">&quot;id&quot;</span>).asInt());<br>            <span class="hljs-keyword">return</span> user;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-国际化"><a href="#3-3-国际化" class="headerlink" title="3.3 国际化"></a>3.3 国际化</h4><h5 id="1-添加国际化资源文件"><a href="#1-添加国际化资源文件" class="headerlink" title="1.  添加国际化资源文件"></a>1.  添加国际化资源文件</h5><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304210103875.png"></p><h5 id="2-配置-messageResource"><a href="#2-配置-messageResource" class="headerlink" title="2. 配置 messageResource"></a>2. 配置 messageResource</h5><ol><li>在 Springboot 中提供了 MessageSourceAutoConfiguration 所以，我们不需要去配置 messageResource。</li></ol><p>​    MessageSourceAutoConfiguration 定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@AutoConfiguration</span><br><span class="hljs-comment">// 如果自己配置了名字叫 messageSource 的 bean 就会用自定义的</span><br><span class="hljs-meta">@ConditionalOnMissingBean(name = AbstractApplicationContext.MESSAGE_SOURCE_BEAN_NAME, search = SearchStrategy.CURRENT)</span><br><span class="hljs-meta">@AutoConfigureOrder(Ordered.HIGHEST_PRECEDENCE)</span><br><span class="hljs-comment">// @Conditional 自定义条件匹配 会传入一个实现了Condition接口的类——ResourceBundleCondition</span><br><span class="hljs-comment">// ResourceBundleCondition 会重写matches， 自定义匹配规则 ， 如果该方法返回true 就匹配成功</span><br><span class="hljs-meta">@Conditional(ResourceBundleCondition.class)</span><br><span class="hljs-meta">@EnableConfigurationProperties</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageSourceAutoConfiguration</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;<br>   String classOrMethodName = getClassOrMethodName(metadata);<br>   <span class="hljs-keyword">try</span> &#123;<br>      <span class="hljs-comment">// getMatchOutcome 具体的匹配规则就在这个里面</span><br>      ConditionOutcome outcome = getMatchOutcome(context, metadata);<br>      logOutcome(classOrMethodName, outcome);<br>      recordEvaluation(context, classOrMethodName, outcome);<br>      <span class="hljs-keyword">return</span> outcome.isMatch();<br>   &#125;<br>   <span class="hljs-keyword">catch</span> (RuntimeException ex) &#123;<br>      <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<span class="hljs-string">&quot;Error processing condition on &quot;</span> + getName(metadata), ex);<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ConditionOutcome <span class="hljs-title">getMatchOutcome</span><span class="hljs-params">(ConditionContext context, AnnotatedTypeMetadata metadata)</span> </span>&#123;<br>   <span class="hljs-comment">//  获取配置文件中spring.messages.basename ，默认值是：messages</span><br>   String basename = context.getEnvironment().getProperty(<span class="hljs-string">&quot;spring.messages.basename&quot;</span>, <span class="hljs-string">&quot;messages&quot;</span>);<br>   ConditionOutcome outcome = cache.get(basename);<br>   <span class="hljs-keyword">if</span> (outcome == <span class="hljs-keyword">null</span>) &#123;<br>      outcome = getMatchOutcomeForBasename(context, basename);<br>      cache.put(basename, outcome);<br>   &#125;<br>   <span class="hljs-keyword">return</span> outcome;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> ConditionOutcome <span class="hljs-title">getMatchOutcomeForBasename</span><span class="hljs-params">(ConditionContext context, String basename)</span> </span>&#123;<br>   ConditionMessage.Builder message = ConditionMessage.forCondition(<span class="hljs-string">&quot;ResourceBundle&quot;</span>);<br>   <span class="hljs-keyword">for</span> (String name : StringUtils.commaDelimitedListToStringArray(StringUtils.trimAllWhitespace(basename))) &#123;<br>      <span class="hljs-comment">//  根据messages获取 该类路径下的所有propeties的资源文件</span><br>      <span class="hljs-keyword">for</span> (Resource resource : getResources(context.getClassLoader(), name)) &#123;<br>         <span class="hljs-comment">// 只要basename的类路径下有资源文件就会匹配成功</span><br>         <span class="hljs-keyword">if</span> (resource.exists()) &#123;<br>            <span class="hljs-keyword">return</span> ConditionOutcome.match(message.found(<span class="hljs-string">&quot;bundle&quot;</span>).items(resource));<br>         &#125;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> ConditionOutcome.noMatch(message.didNotFind(<span class="hljs-string">&quot;bundle with basename &quot;</span> + basename).atAll());<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>生效条件：</strong></p><ul><li><p>必须保证在类路径下的 messages 文件夹中有国际化的资源文件</p></li><li><p>或者通过 spring.messages.basename 配置资源文件位置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">spring.messages.basename</span>=<span class="hljs-string">i18n.message</span><br></code></pre></td></tr></table></figure></li><li><p>只要找到了国际化的属性资源文件那就会设置 ConditionOutcome.match=true</p></li><li><p>当 ConditionOutcome.match=true 那么 @Conditional(ResourceBundleCondition.class) 就匹配成功</p></li><li><p>一旦匹配成功那自动配置类就会生效，就会帮我们配置一个 meesageSource</p></li></ul><h5 id="3-解析语言类型"><a href="#3-解析语言类型" class="headerlink" title="3. 解析语言类型"></a>3. 解析语言类型</h5><p>需要去解析请求头中的 accept-language 或者解析 url 参数中 ?local=</p><p>其实 WebMvcAutoConfiguration 类也帮我配置了一个解析请求头中的 accept-language 的 localResolver。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@ConditionalOnMissingBean(name = DispatcherServlet.LOCALE_RESOLVER_BEAN_NAME)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> LocaleResolver <span class="hljs-title">localeResolver</span><span class="hljs-params">()</span> </span>&#123;<br>   <span class="hljs-comment">// 当配置spring.mvc.locale‐resolver=fiexd</span><br>   <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.webProperties.getLocaleResolver() == WebProperties.LocaleResolver.FIXED) &#123;<br>      <span class="hljs-comment">// 就会使用配置文件中指定的本地化语言：spring.mvc.locale=en_US</span><br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> FixedLocaleResolver(<span class="hljs-keyword">this</span>.webProperties.getLocale());<br>   &#125;<br>   <span class="hljs-comment">// 默认就是使用 AcceptHeaderLocaleResolver 作为本地化解析器</span><br>   AcceptHeaderLocaleResolver localeResolver = <span class="hljs-keyword">new</span> AcceptHeaderLocaleResolver();<br>   <span class="hljs-comment">// spring.mvc.locale=en_US 作为默认的本地化语言</span><br>   localeResolver.setDefaultLocale(<span class="hljs-keyword">this</span>.webProperties.getLocale());<br>   <span class="hljs-keyword">return</span> localeResolver;<br>&#125;<br></code></pre></td></tr></table></figure><p>org.springframework.web.servlet.i18n.AcceptHeaderLocaleResolver#resolveLocale</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Locale <span class="hljs-title">resolveLocale</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<br>   Locale defaultLocale = getDefaultLocale();<br>   <span class="hljs-comment">//  当Accept‐Languag为null 才会使用使用配置文件中设置的locale:spring.mvc.locale</span><br>   <span class="hljs-keyword">if</span> (defaultLocale != <span class="hljs-keyword">null</span> &amp;&amp; request.getHeader(<span class="hljs-string">&quot;Accept-Language&quot;</span>) == <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> defaultLocale;<br>   &#125;<br>   Locale requestLocale = request.getLocale();<br>   List&lt;Locale&gt; supportedLocales = getSupportedLocales();<br>   <span class="hljs-keyword">if</span> (supportedLocales.isEmpty() || supportedLocales.contains(requestLocale)) &#123;<br>      <span class="hljs-keyword">return</span> requestLocale;<br>   &#125;<br>   Locale supportedLocale = findSupportedLocale(request, supportedLocales);<br>   <span class="hljs-keyword">if</span> (supportedLocale != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> supportedLocale;<br>   &#125;<br>   <span class="hljs-keyword">return</span> (defaultLocale != <span class="hljs-keyword">null</span> ? defaultLocale : requestLocale);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-缓存本地语言"><a href="#4-缓存本地语言" class="headerlink" title="4. 缓存本地语言"></a>4. 缓存本地语言</h5><p>覆盖原有 localeResolver。因为自动配置类中的 localeResovler 它只会从 accept-language 中解析。</p><p>从请求参数 locale 中获取并保存到 cookie 中。</p><p><a href="http://127.0.0.1:8080/user/1?locale=en_US">http://127.0.0.1:8080/user/1?locale=en_US</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MvcConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        <span class="hljs-comment">//添加国际化拦截器</span><br>        registry.addInterceptor(<span class="hljs-keyword">new</span> LocaleChangeInterceptor()).addPathPatterns(<span class="hljs-string">&quot;/**&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> LocaleResolver <span class="hljs-title">localeResolver</span><span class="hljs-params">()</span> </span>&#123;<br>        CookieLocaleResolver localeResolver = <span class="hljs-keyword">new</span> CookieLocaleResolver();<br>        <span class="hljs-comment">// 设置过期时间</span><br>        localeResolver.setCookieMaxAge(<span class="hljs-number">60</span> * <span class="hljs-number">60</span> * <span class="hljs-number">24</span> * <span class="hljs-number">7</span>);<br>        localeResolver.setCookieName(<span class="hljs-string">&quot;locale&quot;</span>);<br>        <span class="hljs-keyword">return</span> localeResolver;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="5-通过-messageResource-获取国际化信息"><a href="#5-通过-messageResource-获取国际化信息" class="headerlink" title="5. 通过 messageResource 获取国际化信息"></a>5. 通过 messageResource 获取国际化信息</h5><p><strong>方法一：</strong></p><p>自动注入：MessageSource</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br>MessageSource messageSource;<br><br><span class="hljs-meta">@GetMapping(&quot;/&#123;id&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Result&lt;User&gt; <span class="hljs-title">getUser</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable</span> Integer id)</span> </span>&#123;<br>    String message = messageSource.getMessage(<span class="hljs-string">&quot;user.query.success&quot;</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());<br>    User user = userService.getUserById(id);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result&lt;&gt;(<span class="hljs-number">200</span>, message, user);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong><strong>方法二：</strong></strong></p><p>使用定义工具类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Utils</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> ResourceBundleMessageSource messageSource;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HttpServletRequest request;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">(String code, String... args)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> messageSource.getMessage(code, args, request.getLocale());<br>    &#125;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setMessageSource</span><span class="hljs-params">(ResourceBundleMessageSource messageSource)</span> </span>&#123;<br>        Utils.messageSource = messageSource;<br>    &#125;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setRequest</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<br>        Utils.request = request;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-4-统一异常处理"><a href="#3-4-统一异常处理" class="headerlink" title="3.4 统一异常处理"></a>3.4 统一异常处理</h4><h5 id="1-SpringBoot-统一异常处理自动配置类-ErrorMvcAutoConfiguration"><a href="#1-SpringBoot-统一异常处理自动配置类-ErrorMvcAutoConfiguration" class="headerlink" title="1. SpringBoot 统一异常处理自动配置类 ErrorMvcAutoConfiguration"></a>1. SpringBoot 统一异常处理自动配置类 ErrorMvcAutoConfiguration</h5><p>重要组件：</p><ul><li>DefaultErrorAttributes</li><li>BasicErrorController</li><li>DefaultErrorViewResolver  用来解析错误视图页面</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicErrorController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractErrorController</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>BasicErrorController 就是一个处理 /error 请求的一个控制器。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304212219807.png"></p><p><strong>处理过程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;$&#123;server.error.path:$&#123;error.path:/error&#125;&#125;&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BasicErrorController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractErrorController</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>   <span class="hljs-meta">@RequestMapping(produces = MediaType.TEXT_HTML_VALUE)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">errorHtml</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>      HttpStatus status = getStatus(request);<br>      Map&lt;String, Object&gt; model = Collections<br>            .unmodifiableMap(getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.TEXT_HTML)));<br>      response.setStatus(status.value());<br>      ModelAndView modelAndView = resolveErrorView(request, response, status, model);<br>      <span class="hljs-keyword">return</span> (modelAndView != <span class="hljs-keyword">null</span>) ? modelAndView : <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;error&quot;</span>, model);<br>   &#125;<br><br>   <span class="hljs-meta">@RequestMapping</span><br>   <span class="hljs-keyword">public</span> ResponseEntity&lt;Map&lt;String, Object&gt;&gt; error(HttpServletRequest request) &#123;<br>      HttpStatus status = getStatus(request);<br>      <span class="hljs-keyword">if</span> (status == HttpStatus.NO_CONTENT) &#123;<br>         <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(status);<br>      &#125;<br>      Map&lt;String, Object&gt; body = getErrorAttributes(request, getErrorAttributeOptions(request, MediaType.ALL));<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(body, status);<br>   &#125;<br><br>   <span class="hljs-meta">@ExceptionHandler(HttpMediaTypeNotAcceptableException.class)</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">mediaTypeNotAcceptable</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<br>      HttpStatus status = getStatus(request);<br>      <span class="hljs-keyword">return</span> ResponseEntity.status(status).build();<br>   &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="a-页面请求"><a href="#a-页面请求" class="headerlink" title="a)  页面请求"></a>a)  页面请求</h6><p>RequestMapping 的 produces 会解析请求中 Accept。    </p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304212240653.png"></p><p>如果是浏览器请求，则交给 errorHtml() 处理。</p><p>除了 text/html 的其他请求都会交给 error() 方法处理。</p><p><strong>错误视图解析过程：</strong></p><p>getErrorAttributes() 用来获取所需要的异常信息。</p><p>resolveErrorView 解析视图，会调用 DefaultErrorViewResolver 的 resolveErrorView 方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> ModelAndView <span class="hljs-title">resolveErrorView</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, HttpStatus status,</span></span><br><span class="hljs-params"><span class="hljs-function">      Map&lt;String, Object&gt; model)</span> </span>&#123;<br>   <span class="hljs-comment">// ErrorViewResolver 即为：DefaultErrorViewResolver  </span><br>   <span class="hljs-keyword">for</span> (ErrorViewResolver resolver : <span class="hljs-keyword">this</span>.errorViewResolvers) &#123;<br>      ModelAndView modelAndView = resolver.resolveErrorView(request, status, model);<br>      <span class="hljs-keyword">if</span> (modelAndView != <span class="hljs-keyword">null</span>) &#123;<br>         <span class="hljs-keyword">return</span> modelAndView;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 视图查找顺序</span><br><span class="hljs-comment"> * /&lt;templates&gt;/error/404.&lt;ext&gt;</span><br><span class="hljs-comment"> * /&lt;static&gt;/error/404.html</span><br><span class="hljs-comment"> * /&lt;templates&gt;/error/4xx.&lt;ext&gt;</span><br><span class="hljs-comment"> * /&lt;static&gt;/error/4xx.html</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">resolveErrorView</span><span class="hljs-params">(HttpServletRequest request, HttpStatus status, Map&lt;String, Object&gt; model)</span> </span>&#123;<br>   <span class="hljs-comment">// 先根据具体状态码查找视图</span><br>   ModelAndView modelAndView = resolve(String.valueOf(status.value()), model);<br>   <span class="hljs-keyword">if</span> (modelAndView == <span class="hljs-keyword">null</span> &amp;&amp; SERIES_VIEWS.containsKey(status.series())) &#123;<br>      <span class="hljs-comment">// 如果没找到则通过状态码系列找视图，如：4xx</span><br>      modelAndView = resolve(SERIES_VIEWS.get(status.series()), model);<br>   &#125;<br>   <span class="hljs-keyword">return</span> modelAndView;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> ModelAndView <span class="hljs-title">resolve</span><span class="hljs-params">(String viewName, Map&lt;String, Object&gt; model)</span> </span>&#123;<br>   String errorViewName = <span class="hljs-string">&quot;error/&quot;</span> + viewName;<br>   <span class="hljs-comment">// 先在模板视图中找</span><br>   TemplateAvailabilityProvider provider = <span class="hljs-keyword">this</span>.templateAvailabilityProviders.getProvider(errorViewName,<br>         <span class="hljs-keyword">this</span>.applicationContext);<br>   <span class="hljs-keyword">if</span> (provider != <span class="hljs-keyword">null</span>) &#123;<br>      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(errorViewName, model);<br>   &#125;<br>   <span class="hljs-comment">// 模板视图不存在则在静态资源中查找</span><br>   <span class="hljs-keyword">return</span> resolveResource(errorViewName, model);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> ModelAndView <span class="hljs-title">resolveResource</span><span class="hljs-params">(String viewName, Map&lt;String, Object&gt; model)</span> </span>&#123;<br>   <span class="hljs-keyword">for</span> (String location : <span class="hljs-keyword">this</span>.resources.getStaticLocations()) &#123;<br>      <span class="hljs-keyword">try</span> &#123;<br>         Resource resource = <span class="hljs-keyword">this</span>.applicationContext.getResource(location);<br>         resource = resource.createRelative(viewName + <span class="hljs-string">&quot;.html&quot;</span>);<br>         <span class="hljs-keyword">if</span> (resource.exists()) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-keyword">new</span> HtmlResourceView(resource), model);<br>         &#125;<br>      &#125;<br>      <span class="hljs-keyword">catch</span> (Exception ex) &#123;<br>      &#125;<br>   &#125;<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304212331263.png"></p><p><strong>定制错误页面：</strong></p><p>在上图所示路径下的 /error 目录下添加模板视图或 html 页面即可。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304232216361.png"></p><h6 id="b-ajax-请求"><a href="#b-ajax-请求" class="headerlink" title="b) ajax 请求"></a>b) ajax 请求</h6><p>error() 方法用来处理 ajax 请求。</p><p><strong>解析过程：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Map&lt;String, Object&gt; <span class="hljs-title">getErrorAttributes</span><span class="hljs-params">(HttpServletRequest request, ErrorAttributeOptions options)</span> </span>&#123;<br>   WebRequest webRequest = <span class="hljs-keyword">new</span> ServletWebRequest(request);<br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.errorAttributes.getErrorAttributes(webRequest, options);<br>&#125;<br><br><span class="hljs-comment">// DefaultErrorAttributes#getErrorAttributes()</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Map&lt;String, Object&gt; <span class="hljs-title">getErrorAttributes</span><span class="hljs-params">(WebRequest webRequest, ErrorAttributeOptions options)</span> </span>&#123;<br>   Map&lt;String, Object&gt; errorAttributes = getErrorAttributes(webRequest, options.isIncluded(Include.STACK_TRACE));<br>   <span class="hljs-keyword">if</span> (!options.isIncluded(Include.EXCEPTION)) &#123;<br>      errorAttributes.remove(<span class="hljs-string">&quot;exception&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">if</span> (!options.isIncluded(Include.STACK_TRACE)) &#123;<br>      errorAttributes.remove(<span class="hljs-string">&quot;trace&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">if</span> (!options.isIncluded(Include.MESSAGE) &amp;&amp; errorAttributes.get(<span class="hljs-string">&quot;message&quot;</span>) != <span class="hljs-keyword">null</span>) &#123;<br>      errorAttributes.remove(<span class="hljs-string">&quot;message&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">if</span> (!options.isIncluded(Include.BINDING_ERRORS)) &#123;<br>      errorAttributes.remove(<span class="hljs-string">&quot;errors&quot;</span>);<br>   &#125;<br>   <span class="hljs-keyword">return</span> errorAttributes;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304232237418.png"></p><p>根据配置文件中的配置进行控制输出哪些属性：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304232307606.png"></p><p><strong>定制异常返回：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@RequestMapping(&quot;/error&quot;)</span><br><span class="hljs-meta">@Slf4j</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CustomErrorController</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractErrorController</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CustomErrorController</span><span class="hljs-params">(ErrorAttributes errorAttributes, List&lt;ErrorViewResolver&gt; errorViewResolvers)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(errorAttributes, errorViewResolvers);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理浏览器请求</span><br><span class="hljs-comment">     * 增加日志记录</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(produces = MediaType.TEXT_HTML_VALUE)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">errorHtml</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>        HttpStatus status = getStatus(request);<br>        Map&lt;String, Object&gt; model = Collections<br>                .unmodifiableMap(getErrorAttributes(request, getErrorAttributeOptions()));<br>        response.setStatus(status.value());<br>        ModelAndView modelAndView = resolveErrorView(request, response, status, model);<br>        log.error(model.get(<span class="hljs-string">&quot;trace&quot;</span>).toString());<br>        <span class="hljs-keyword">return</span> (modelAndView != <span class="hljs-keyword">null</span>) ? modelAndView : <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;error&quot;</span>, model);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 处理 Ajax 请求</span><br><span class="hljs-comment">     * 增加日志</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Result <span class="hljs-title">error</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<br>        HttpStatus status = getStatus(request);<br>        <span class="hljs-keyword">if</span> (status == HttpStatus.NO_CONTENT) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(<span class="hljs-number">204</span>, <span class="hljs-string">&quot;No Content&quot;</span>);<br>        &#125;<br>        Map&lt;String, Object&gt; body = getErrorAttributes(request, getErrorAttributeOptions());<br>        String code = body.get(<span class="hljs-string">&quot;status&quot;</span>).toString();<br>        String message = body.get(<span class="hljs-string">&quot;message&quot;</span>).toString();<br>        log.error(body.get(<span class="hljs-string">&quot;trace&quot;</span>).toString());<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Result(Integer.valueOf(code), message);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> ErrorAttributeOptions <span class="hljs-title">getErrorAttributeOptions</span><span class="hljs-params">()</span> </span>&#123;<br>        ErrorAttributeOptions of = ErrorAttributeOptions.of(ErrorAttributeOptions.Include.MESSAGE,<br>                ErrorAttributeOptions.Include.STACK_TRACE,<br>                ErrorAttributeOptions.Include.EXCEPTION);<br>        <span class="hljs-keyword">return</span> of;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-ControllerAdivce"><a href="#2-ControllerAdivce" class="headerlink" title="2. @ControllerAdivce"></a>2. @ControllerAdivce</h5><p><a href="https://debuggingworld.github.io/2022/10/23/SpringMVC%E2%80%94%E2%80%94%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD-%E6%8B%A6%E6%88%AA%E5%99%A8-%E5%9B%BD%E9%99%85%E5%8C%96-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/#6-2-%E7%BB%9F%E4%B8%80%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86">（传送门）</a></p>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Debug Java</title>
    <link href="/2023/03/10/%E9%9D%A2%E8%AF%95/"/>
    <url>/2023/03/10/%E9%9D%A2%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1-JVM基础，JVM-GC原理，JVM怎么实现回收内存。"><a href="#1-JVM基础，JVM-GC原理，JVM怎么实现回收内存。" class="headerlink" title="1. JVM基础，JVM GC原理，JVM怎么实现回收内存。"></a>1. JVM基础，JVM GC原理，JVM怎么实现回收内存。</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111541537.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111549143.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111549172.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111547045.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111547940.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111548119.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111550112.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111550197.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111551186.png"></p><h3 id="2-Java事件机制包括哪三个部分？分别介绍"><a href="#2-Java事件机制包括哪三个部分？分别介绍" class="headerlink" title="2. Java事件机制包括哪三个部分？分别介绍"></a>2. Java事件机制包括哪三个部分？分别介绍</h3><p>1、事件。一般继承自 java.util.EventObject 类，封装了事件源对象及跟事件相关的信息。</p><p> 2、事件监听器。实现 java.util.EventListener 接口,注册在事件源上,当事件源的属性或状态改变时,取得相应的监听器调用其内部的回调方法。</p><p> 3、事件源。事件发生的地方，由于事件源的某项属性或状态发生了改变(比如BUTTON被单击、TEXTBOX的值发生改变等等)导致某项事件发生。换句话说就是生成了相应的事件对象。因为事件监听器要注册在事件源上,所以事件源类中应该要有盛装监听器的<a href="https://cloud.tencent.com/product/tke?from=10680">容器</a>(List,Set等等)。</p><h3 id="3-说说你对Spring的IOC是怎么理解的"><a href="#3-说说你对Spring的IOC是怎么理解的" class="headerlink" title="3. 说说你对Spring的IOC是怎么理解的?"></a>3. 说说你对Spring的IOC是怎么理解的?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111607640.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303112141854.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303112143183.png"></p><h3 id="4-Spring框架中都用到了哪些设计模式"><a href="#4-Spring框架中都用到了哪些设计模式" class="headerlink" title="4. Spring框架中都用到了哪些设计模式?"></a>4. Spring框架中都用到了哪些设计模式?</h3><p><a href="https://blog.csdn.net/m0_71777195/article/details/126519893">https://blog.csdn.net/m0_71777195/article/details/126519893</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111610194.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111610293.png"></p><h3 id="5-说说MyBatis的优点和缺点"><a href="#5-说说MyBatis的优点和缺点" class="headerlink" title="5. 说说MyBatis的优点和缺点"></a>5. 说说MyBatis的优点和缺点</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111611294.png"></p><h3 id="6-当实体类中的属性名和表中的字段名不一样，怎么办-Mybatis是如何进行分页的"><a href="#6-当实体类中的属性名和表中的字段名不一样，怎么办-Mybatis是如何进行分页的" class="headerlink" title="6. 当实体类中的属性名和表中的字段名不一样，怎么办?Mybatis是如何进行分页的?"></a>6. 当实体类中的属性名和表中的字段名不一样，怎么办?Mybatis是如何进行分页的?</h3><p>不一样：</p><p><a href="https://blog.csdn.net/finally_vince/article/details/126546045">https://blog.csdn.net/finally_vince/article/details/126546045</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111613392.png"></p><p>分页：</p><p><a href="https://blog.csdn.net/web13618542420/article/details/126112972">https://blog.csdn.net/web13618542420/article/details/126112972</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111614280.png"></p><h3 id="7-Spring-Boot的核心配置文件有哪几个-它们的区别是什么"><a href="#7-Spring-Boot的核心配置文件有哪几个-它们的区别是什么" class="headerlink" title="7. Spring Boot的核心配置文件有哪几个?它们的区别是什么?"></a>7. Spring Boot的核心配置文件有哪几个?它们的区别是什么?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111615301.png"></p><h3 id="8-什么时候不要使用索引-说说什么是-MVCC"><a href="#8-什么时候不要使用索引-说说什么是-MVCC" class="headerlink" title="8. 什么时候不要使用索引?说说什么是 MVCC?"></a>8. 什么时候不要使用索引?说说什么是 MVCC?</h3><p><a href="https://blog.csdn.net/weixin_69101491/article/details/125604214">https://blog.csdn.net/weixin_69101491/article/details/125604214</a></p><p>mvcc:<a href="https://blog.csdn.net/lans_g/article/details/124232192">https://blog.csdn.net/lans_g/article/details/124232192</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111616325.png"></p><h3 id="9-MVCC可以为数据库解决什么问题-说说MVCC的实现原理"><a href="#9-MVCC可以为数据库解决什么问题-说说MVCC的实现原理" class="headerlink" title="9. MVCC可以为数据库解决什么问题?说说MVCC的实现原理"></a>9. MVCC可以为数据库解决什么问题?说说MVCC的实现原理</h3><p><a href="https://blog.csdn.net/pengfei1990/article/details/128885596">https://blog.csdn.net/pengfei1990/article/details/128885596</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111617447.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303112213427.png"></p><h3 id="10-MySQL事务隔离级别"><a href="#10-MySQL事务隔离级别" class="headerlink" title="10. MySQL事务隔离级别?"></a>10. MySQL事务隔离级别?</h3><p><a href="https://blog.csdn.net/qq_34222160/article/details/124483303">https://blog.csdn.net/qq_34222160/article/details/124483303</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111617342.png"></p><h3 id="11-请说说MySQL-数据库的锁"><a href="#11-请说说MySQL-数据库的锁" class="headerlink" title="11. 请说说MySQL 数据库的锁?"></a>11. 请说说MySQL 数据库的锁?</h3><p><a href="https://blog.csdn.net/TABE_/article/details/122351648">https://blog.csdn.net/TABE_/article/details/122351648</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111618448.png"></p><h3 id="12-常用的线程池有哪些"><a href="#12-常用的线程池有哪些" class="headerlink" title="12. 常用的线程池有哪些?"></a>12. 常用的线程池有哪些?</h3><p><a href="https://www.modb.pro/db/136334">https://www.modb.pro/db/136334</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111618451.png"></p><h3 id="13-简述一下你对线程池的理解"><a href="#13-简述一下你对线程池的理解" class="headerlink" title="13. 简述一下你对线程池的理解"></a>13. 简述一下你对线程池的理解</h3><p><a href="https://baijiahao.baidu.com/s?id=1710374344849036345&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1710374344849036345&amp;wfr=spider&amp;for=pc</a></p><p><a href="https://blog.csdn.net/qq_28772075/article/details/119486482">https://blog.csdn.net/qq_28772075/article/details/119486482</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111619457.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303112231715.png"></p><ul><li> ThreadPoolExecutor.AbortPolicy:丢弃任务并抛出RejectedExecutionException异常。</li><li>  ThreadPoolExecutor.DiscardPolicy：丢弃任务，但是不抛出异常。</li><li>ThreadPoolExecutor.DiscardOldestPolicy：丢弃队列最前面的任务，然后重新提交被拒绝的任务。</li><li> ThreadPoolExecutor.CallerRunsPolicy：由调用线程处理该任务</li></ul><h3 id="14-Java程序是如何执行的锁的优化机制了解吗"><a href="#14-Java程序是如何执行的锁的优化机制了解吗" class="headerlink" title="14. Java程序是如何执行的锁的优化机制了解吗?"></a>14. Java程序是如何执行的锁的优化机制了解吗?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111621472.png"></p><h3 id="15-说说进程和线程的区别"><a href="#15-说说进程和线程的区别" class="headerlink" title="15.说说进程和线程的区别?"></a>15.说说进程和线程的区别?</h3><p>进程（Process）是操作系统分配资源的基本单位，一个进程拥有的资源有自己的堆、栈、虚存空间（页表）、文件描述符等信息。 </p><p>线程（Thread）是操作系统能够进行运算调度的基本单位。它包含在进程中，是进程中的实际运行单位。</p><p><a href="https://blog.csdn.net/zhaohuodian/article/details/126268051">https://blog.csdn.net/zhaohuodian/article/details/126268051</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111621446.png"></p><h3 id="16-产生死锁的四个必要条件"><a href="#16-产生死锁的四个必要条件" class="headerlink" title="16.产生死锁的四个必要条件?"></a>16.产生死锁的四个必要条件?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111622484.png"></p><p><a href="https://blog.csdn.net/wy749929317/article/details/124075683">https://blog.csdn.net/wy749929317/article/details/124075683</a></p><h3 id="17-如何避免死锁"><a href="#17-如何避免死锁" class="headerlink" title="17. 如何避免死锁?"></a>17. 如何避免死锁?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111622488.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111623501.png"></p><h3 id="18-线程池核心线程数怎么设置呢"><a href="#18-线程池核心线程数怎么设置呢" class="headerlink" title="18. 线程池核心线程数怎么设置呢?"></a>18. 线程池核心线程数怎么设置呢?</h3><p><a href="https://blog.csdn.net/qq_33333654/article/details/127015385">https://blog.csdn.net/qq_33333654/article/details/127015385</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111623583.png"></p><h3 id="19-在Zookeeper中Zxid是什么，有什么作用"><a href="#19-在Zookeeper中Zxid是什么，有什么作用" class="headerlink" title="19. 在Zookeeper中Zxid是什么，有什么作用?"></a>19. 在Zookeeper中Zxid是什么，有什么作用?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111624850.png"></p><p><a href="https://www.jianshu.com/p/68b45694026c/">https://www.jianshu.com/p/68b45694026c/</a></p><h3 id="20-讲解一下ZooKeeper的持久化机制"><a href="#20-讲解一下ZooKeeper的持久化机制" class="headerlink" title="20 讲解一下ZooKeeper的持久化机制"></a>20 讲解一下ZooKeeper的持久化机制</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303110037889.png"> </p><p><a href="https://www.cnblogs.com/zhangwanhua/p/9145071.html">https://www.cnblogs.com/zhangwanhua/p/9145071.html</a></p><h3 id="21-Zookeeper选举中投票信息的五元组是什么"><a href="#21-Zookeeper选举中投票信息的五元组是什么" class="headerlink" title="21. Zookeeper选举中投票信息的五元组是什么?"></a>21. Zookeeper选举中投票信息的五元组是什么?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303110908423.png"></p><h3 id="22-说说Zookeeper中的脑裂"><a href="#22-说说Zookeeper中的脑裂" class="headerlink" title="22 说说Zookeeper中的脑裂?"></a>22 说说Zookeeper中的脑裂?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303110913879.png"></p><h3 id="23-Zookeeper脑裂是什么原因导致的"><a href="#23-Zookeeper脑裂是什么原因导致的" class="headerlink" title="23. Zookeeper脑裂是什么原因导致的?"></a>23. Zookeeper脑裂是什么原因导致的?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303110915744.png"></p><h3 id="24-Zookeeper-是如何解决脑裂问题的"><a href="#24-Zookeeper-是如何解决脑裂问题的" class="headerlink" title="24. Zookeeper 是如何解决脑裂问题的?"></a>24. Zookeeper 是如何解决脑裂问题的?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111031167.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111031923.png"></p><h3 id="25-说说Redis的线程模型"><a href="#25-说说Redis的线程模型" class="headerlink" title="25 说说Redis的线程模型"></a>25 说说Redis的线程模型</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111034331.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111037000.png"></p><h3 id="26-为什么Redis需要把所有数据放到内存中"><a href="#26-为什么Redis需要把所有数据放到内存中" class="headerlink" title="26. 为什么Redis需要把所有数据放到内存中?"></a>26. 为什么Redis需要把所有数据放到内存中?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111038356.png"></p><h3 id="27-Redis-的同步机制了解是什么"><a href="#27-Redis-的同步机制了解是什么" class="headerlink" title="27. Redis 的同步机制了解是什么?"></a>27. Redis 的同步机制了解是什么?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111039369.png"></p><h3 id="29-说一下Redis有什么优点和缺点"><a href="#29-说一下Redis有什么优点和缺点" class="headerlink" title="29.说一下Redis有什么优点和缺点"></a>29.说一下Redis有什么优点和缺点</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111042412.png"></p><h3 id="30-Redis缓存刷新策略有哪些"><a href="#30-Redis缓存刷新策略有哪些" class="headerlink" title="30 Redis缓存刷新策略有哪些?"></a>30 Redis缓存刷新策略有哪些?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111044057.png"></p><h3 id="31-Redis持久化方式有哪些-以及有什么区别"><a href="#31-Redis持久化方式有哪些-以及有什么区别" class="headerlink" title="31. Redis持久化方式有哪些?以及有什么区别?"></a>31. Redis持久化方式有哪些?以及有什么区别?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111047462.png"></p><h3 id="32-什么是三阶段提交"><a href="#32-什么是三阶段提交" class="headerlink" title="32. 什么是三阶段提交?"></a>32. 什么是三阶段提交?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111048726.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111052118.png"></p><h3 id="33-什么是补偿事务"><a href="#33-什么是补偿事务" class="headerlink" title="33. 什么是补偿事务?"></a>33. 什么是补偿事务?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111058576.png"></p><h3 id="34-消息队列是怎么实现的"><a href="#34-消息队列是怎么实现的" class="headerlink" title="34. 消息队列是怎么实现的?"></a>34. 消息队列是怎么实现的?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111101620.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111111879.png"></p><h3 id="35-那你说说Sagas事务模型"><a href="#35-那你说说Sagas事务模型" class="headerlink" title="35 那你说说Sagas事务模型"></a>35 那你说说Sagas事务模型</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111120515.png"></p><h3 id="36-分布式ID生成有几种方案"><a href="#36-分布式ID生成有几种方案" class="headerlink" title="36. 分布式ID生成有几种方案?"></a>36. 分布式ID生成有几种方案?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111127561.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111129992.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111130600.png"></p><h3 id="37-幂等解决方法有哪些"><a href="#37-幂等解决方法有哪些" class="headerlink" title="37. 幂等解决方法有哪些?"></a>37. 幂等解决方法有哪些?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111139889.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111718138.png"></p><h3 id="38-常见负载均衡算法有哪些"><a href="#38-常见负载均衡算法有哪些" class="headerlink" title="38. 常见负载均衡算法有哪些?"></a>38. 常见负载均衡算法有哪些?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111142912.png"></p><h3 id="39-你知道哪些限流算法"><a href="#39-你知道哪些限流算法" class="headerlink" title="39. 你知道哪些限流算法?"></a>39. 你知道哪些限流算法?</h3><p>限流算法有四种常见算法：</p><p>计数器算法（固定窗口）</p><p>滑动窗口</p><p>漏桶算法</p><p>令牌桶算法</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111144434.png"></p><p><strong>滑动窗口算法</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111146938.png"></p><p><strong>漏桶算法</strong></p><p>漏桶算法是访问请求到达时直接放入漏桶，如当前容量已达到上限（限流值），则进行丢弃（触发限流策略）。漏桶以固定的速率进行释放访问请求（即请求通过），直到漏桶为空</p><p><strong>令牌桶算法</strong></p><p>令牌桶算法是程序以r（r=时间周期/限流值）的速度向令牌桶中增加令牌，直到令牌桶满，请求到达时向令牌桶请求令牌，如获取到令牌则通过请求，否则触发限流策略</p><h3 id="40-简述一下什么是Nginx，它有什么优势和功能"><a href="#40-简述一下什么是Nginx，它有什么优势和功能" class="headerlink" title="40. 简述一下什么是Nginx，它有什么优势和功能?"></a>40. 简述一下什么是Nginx，它有什么优势和功能?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111153155.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111156194.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111156678.png"></p><h3 id="41-Nginx是如何处理一个HTTP请求的呢"><a href="#41-Nginx是如何处理一个HTTP请求的呢" class="headerlink" title="41. Nginx是如何处理一个HTTP请求的呢?"></a>41. Nginx是如何处理一个HTTP请求的呢?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111159573.png"></p><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h3 id="44-怎么实现动态感知服务下线的呢"><a href="#44-怎么实现动态感知服务下线的呢" class="headerlink" title="44. 怎么实现动态感知服务下线的呢?"></a>44. 怎么实现动态感知服务下线的呢?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111204888.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111205219.png"></p><h3 id="45-Dubbo负载均衡策略"><a href="#45-Dubbo负载均衡策略" class="headerlink" title="45. Dubbo负载均衡策略?"></a>45. Dubbo负载均衡策略?</h3><p>随机（默认）：随机来</p><p>轮训：一个一个来</p><p>活跃度：机器活跃度来负载</p><p>一致性 hash：落到同一台机器上</p><h3 id="46-Dubbo容错策略"><a href="#46-Dubbo容错策略" class="headerlink" title="46. Dubbo容错策略"></a>46. Dubbo容错策略</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111206957.png"></p><h3 id="47-什么是Hystrix-它如何实现容错"><a href="#47-什么是Hystrix-它如何实现容错" class="headerlink" title="47. 什么是Hystrix?它如何实现容错?"></a>47. 什么是Hystrix?它如何实现容错?</h3><p>服务雪崩<br>多个微服务之间调用的时候，假设微服务 A 调用微服务 B 和微服务 C,微服务 B 和微服务 C 又调用其它的微服务,这就是所谓的“扇出”。如果扇出的链路上某个微服务的调用响应时间过长或者不可用，对微服务A的调用就会占用越来越多的系统资源，进而引|起系统崩溃,所谓的“雪崩效应”。</p><p>Hystrix<br>Hystrix 是一个用于处理分布式系统延迟和容错的开源库。在分布式系统里，许多依赖不可避免的会调用失败，比如超时、异常等,<br>Hystrix 能够保证在一个依赖出问题的情况下， 不会导致整体服务失败，避免级联故障，以提高分布式系统的弹性。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111452301.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111452209.png"></p><h3 id="48-什么是Hystrix断路器-我们需要它吗"><a href="#48-什么是Hystrix断路器-我们需要它吗" class="headerlink" title="48. 什么是Hystrix断路器?我们需要它吗?"></a>48. 什么是Hystrix断路器?我们需要它吗?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111454485.png"></p><h3 id="49-说说RPC的实现原理"><a href="#49-说说RPC的实现原理" class="headerlink" title="49. 说说RPC的实现原理"></a>49. 说说RPC的实现原理</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111502184.png"></p><h3 id="50-eureka自我保护机制是什么"><a href="#50-eureka自我保护机制是什么" class="headerlink" title="50. eureka自我保护机制是什么?"></a>50. eureka自我保护机制是什么?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111502543.png"></p><h3 id="51-什么是Ribbon"><a href="#51-什么是Ribbon" class="headerlink" title="51. 什么是Ribbon?"></a>51. 什么是Ribbon?</h3><p>ribbon是一个负载均衡客户端，可以很好的控制htt和tcp的一些行为。feign默认集成了ribbon。</p><h3 id="52-什么是feigin-它的优点是什么"><a href="#52-什么是feigin-它的优点是什么" class="headerlink" title="52. 什么是feigin?它的优点是什么?"></a>52. 什么是feigin?它的优点是什么?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111504764.png"></p><h3 id="53-Ribbon和Feign的区别"><a href="#53-Ribbon和Feign的区别" class="headerlink" title="53. Ribbon和Feign的区别?"></a>53. Ribbon和Feign的区别?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111508787.png"></p><h3 id="54-说说TCP与UDP的区别，以及各自的优缺点说一下"><a href="#54-说说TCP与UDP的区别，以及各自的优缺点说一下" class="headerlink" title="54. 说说TCP与UDP的区别，以及各自的优缺点说一下"></a>54. 说说TCP与UDP的区别，以及各自的优缺点说一下</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111510707.png"></p><h3 id="55-HTTP和HTTPS的区别"><a href="#55-HTTP和HTTPS的区别" class="headerlink" title="55. HTTP和HTTPS的区别"></a>55. HTTP和HTTPS的区别</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111511596.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111513623.png"></p><h3 id="56-说说HTTP、TCP、Socket的关系是什么"><a href="#56-说说HTTP、TCP、Socket的关系是什么" class="headerlink" title="56. 说说HTTP、TCP、Socket的关系是什么?"></a>56. 说说HTTP、TCP、Socket的关系是什么?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111515826.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111516182.png"></p><h3 id="57-说一下HTTP的长连接与短连接的区别"><a href="#57-说一下HTTP的长连接与短连接的区别" class="headerlink" title="57. 说一下HTTP的长连接与短连接的区别"></a>57. 说一下HTTP的长连接与短连接的区别</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111517857.png"></p><h3 id="58-TCP为什么要三次握手，两次不行吗-为什么"><a href="#58-TCP为什么要三次握手，两次不行吗-为什么" class="headerlink" title="58. TCP为什么要三次握手，两次不行吗?为什么?"></a>58. TCP为什么要三次握手，两次不行吗?为什么?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111521296.png"></p><h3 id="59-说一下TCP粘包是怎么产生的-怎么解决粘包问题的"><a href="#59-说一下TCP粘包是怎么产生的-怎么解决粘包问题的" class="headerlink" title="59. 说一下TCP粘包是怎么产生的?怎么解决粘包问题的?"></a>59. 说一下TCP粘包是怎么产生的?怎么解决粘包问题的?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111523803.png"></p><h3 id="60-在Git中，你如何还原已经-push并公开的提交"><a href="#60-在Git中，你如何还原已经-push并公开的提交" class="headerlink" title="60. 在Git中，你如何还原已经 push并公开的提交?"></a>60. 在Git中，你如何还原已经 push并公开的提交?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111524374.png"></p><h3 id="61-git-pull和git-fetch有什么区别"><a href="#61-git-pull和git-fetch有什么区别" class="headerlink" title="61. git pull和git fetch有什么区别?"></a>61. git pull和git fetch有什么区别?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111526916.png"></p><h3 id="62-git中的”staging-area”或”index”是什么"><a href="#62-git中的”staging-area”或”index”是什么" class="headerlink" title="62. git中的”staging area”或”index”是什么?"></a>62. git中的”staging area”或”index”是什么?</h3><p>在完成提交之前，可以在称为“staging area”或“index”的中间区域中对其进行格式化和审查。每个更改首先在暂存区域中进行验证，我将其称为“stage fifile”，然后将更改提交到存储库。</p><h3 id="63-什么是-git-stash"><a href="#63-什么是-git-stash" class="headerlink" title="63. 什么是 git stash?"></a>63. 什么是 git stash?</h3><p>首先应该解释 git stash 的必要性。通常情况下，当你一直在处理项目的某一部分时，如果你想要在某个时候切换分支去处理其他事情，事情会处于混乱的状态。问题是，你不想把完成了一半的工作的提交，以便你以后就可以回到当前的工作。解决这个问题的答案是 git stash。</p><p>再解释什么是git stash。</p><p>stash 会将你的工作目录，即修改后的跟踪文件和暂存的更改保存在一堆未完成的更改中，你可以随时重新应用这些更改</p><h3 id="64-什么是git-stash-drop"><a href="#64-什么是git-stash-drop" class="headerlink" title="64. 什么是git stash drop?"></a>64. 什么是git stash drop?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111531991.png"></p><h3 id="65-如何找到特定提交中已更改的文件列表"><a href="#65-如何找到特定提交中已更改的文件列表" class="headerlink" title="65. 如何找到特定提交中已更改的文件列表?"></a>65. 如何找到特定提交中已更改的文件列表?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303120918835.png"></p><h3 id="66-git-config的功能是什么"><a href="#66-git-config的功能是什么" class="headerlink" title="66. git config的功能是什么?"></a>66. git config的功能是什么?</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303111533015.png"></p><h3 id="67-kafka-可以脱离-zookeeper-单独使用吗？为什么？"><a href="#67-kafka-可以脱离-zookeeper-单独使用吗？为什么？" class="headerlink" title="67. kafka 可以脱离 zookeeper 单独使用吗？为什么？"></a>67. kafka 可以脱离 zookeeper 单独使用吗？为什么？</h3><p>kafka 不能脱离 zookeeper 单独使用，</p><p>因为 kafka 使用 zookeeper 管理和协调 kafka 的节点服务器。</p><h3 id="68-kafka-有几种数据保留的策略？"><a href="#68-kafka-有几种数据保留的策略？" class="headerlink" title="68. kafka 有几种数据保留的策略？"></a>68. kafka 有几种数据保留的策略？</h3><p>按照过期时间保留和按照存储的消息大小保留。</p><h3 id="69-kafka-同时设置了7天河10G清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？"><a href="#69-kafka-同时设置了7天河10G清除数据，到第五天的时候消息达到了-10G，这个时候-kafka-将如何处理？" class="headerlink" title="69. kafka 同时设置了7天河10G清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？"></a>69. kafka 同时设置了7天河10G清除数据，到第五天的时候消息达到了 10G，这个时候 kafka 将如何处理？</h3><p>这个时候 kafka 会执行数据清除工作，时间和大小不论那个满足条件，都会清空数据。</p><h3 id="70-什么情况会导致-kafka-运行变慢？"><a href="#70-什么情况会导致-kafka-运行变慢？" class="headerlink" title="70. 什么情况会导致 kafka 运行变慢？"></a>70. 什么情况会导致 kafka 运行变慢？</h3><p>cpu 性能瓶颈</p><p>磁盘读写瓶颈</p><p>网络瓶颈</p><h3 id="80-使用-kafka-集群需要注意什么？"><a href="#80-使用-kafka-集群需要注意什么？" class="headerlink" title="80. 使用 kafka 集群需要注意什么？"></a>80. 使用 kafka 集群需要注意什么？</h3><p>集群的数量不是越多越好，最好不要超过 7 个，</p><p>因为节点越多，消息复制需要的时间就越长，整个群组的吞吐量就越低。</p><h3 id="81-rabbitmq-的使用场景有哪些？"><a href="#81-rabbitmq-的使用场景有哪些？" class="headerlink" title="81. rabbitmq 的使用场景有哪些？"></a>81. rabbitmq 的使用场景有哪些？</h3><p><a href="https://www.yukx.com/jing/article/details/1892.html">https://www.yukx.com/jing/article/details/1892.html</a></p><h3 id="82-rabbitmq-有哪些重要的角色？"><a href="#82-rabbitmq-有哪些重要的角色？" class="headerlink" title="82. rabbitmq 有哪些重要的角色？"></a>82. rabbitmq 有哪些重要的角色？</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303112052141.png"></p><h3 id="83-rabbitmq-有哪些重要的组件？"><a href="#83-rabbitmq-有哪些重要的组件？" class="headerlink" title="83. rabbitmq 有哪些重要的组件？"></a>83. rabbitmq 有哪些重要的组件？</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303112052803.png"></p><h3 id="84-rabbitmq-中-vhost-的作用是什么？"><a href="#84-rabbitmq-中-vhost-的作用是什么？" class="headerlink" title="84. rabbitmq 中 vhost 的作用是什么？"></a>84. rabbitmq 中 vhost 的作用是什么？</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303112055436.png"></p><h3 id="85-rabbitmq-的消息是怎么发送的？"><a href="#85-rabbitmq-的消息是怎么发送的？" class="headerlink" title="85. rabbitmq 的消息是怎么发送的？"></a>85. rabbitmq 的消息是怎么发送的？</h3><p><a href="https://blog.csdn.net/CaptHua/article/details/123410556">https://blog.csdn.net/CaptHua/article/details/123410556</a></p><h3 id="86-rabbitmq-怎么保证消息的稳定性？"><a href="#86-rabbitmq-怎么保证消息的稳定性？" class="headerlink" title="86. rabbitmq 怎么保证消息的稳定性？"></a>86. rabbitmq 怎么保证消息的稳定性？</h3><h3 id="87-rabbitmq-怎么避免消息丢失？"><a href="#87-rabbitmq-怎么避免消息丢失？" class="headerlink" title="87. rabbitmq 怎么避免消息丢失？"></a>87. rabbitmq 怎么避免消息丢失？</h3><h3 id="88-要保证消息持久化成功的条件有哪些？"><a href="#88-要保证消息持久化成功的条件有哪些？" class="headerlink" title="88. 要保证消息持久化成功的条件有哪些？"></a>88. 要保证消息持久化成功的条件有哪些？</h3><h3 id="89-rabbitmq-持久化有什么缺点？"><a href="#89-rabbitmq-持久化有什么缺点？" class="headerlink" title="89. rabbitmq 持久化有什么缺点？"></a>89. rabbitmq 持久化有什么缺点？</h3><p>持久化的缺地就是降低了服务器的吞吐量，因为使用的是磁盘而非内存存储，从而降低了吞吐量。可尽量使用 ssd 硬盘来缓解吞吐量的问题。</p><h3 id="90-rabbitmq-有几种广播类型？"><a href="#90-rabbitmq-有几种广播类型？" class="headerlink" title="90. rabbitmq 有几种广播类型？"></a>90. rabbitmq 有几种广播类型？</h3><h3 id="91-rabbitmq-怎么实现延迟消息队列？"><a href="#91-rabbitmq-怎么实现延迟消息队列？" class="headerlink" title="91. rabbitmq 怎么实现延迟消息队列？"></a>91. rabbitmq 怎么实现延迟消息队列？</h3><h3 id="92-rabbitmq-集群有什么用？"><a href="#92-rabbitmq-集群有什么用？" class="headerlink" title="92. rabbitmq 集群有什么用？"></a>92. rabbitmq 集群有什么用？</h3><h3 id="93-rabbitmq-节点的类型有哪些？"><a href="#93-rabbitmq-节点的类型有哪些？" class="headerlink" title="93. rabbitmq 节点的类型有哪些？"></a>93. rabbitmq 节点的类型有哪些？</h3><h3 id="94-rabbitmq-集群搭建需要注意哪些问题？"><a href="#94-rabbitmq-集群搭建需要注意哪些问题？" class="headerlink" title="94. rabbitmq 集群搭建需要注意哪些问题？"></a>94. rabbitmq 集群搭建需要注意哪些问题？</h3><h3 id="95-rabbitmq-每个节点是其他节点的完整拷贝吗？为什么？"><a href="#95-rabbitmq-每个节点是其他节点的完整拷贝吗？为什么？" class="headerlink" title="95. rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？"></a>95. rabbitmq 每个节点是其他节点的完整拷贝吗？为什么？</h3><p>rabbitmq 集群中唯一一个磁盘节点崩溃了会发生什么情况？<br>rabbitmq 对集群节点停止顺序有要求吗？</p><h3 id="异常类-https-www-yukx-com-jing-article-details-1839-html"><a href="#异常类-https-www-yukx-com-jing-article-details-1839-html" class="headerlink" title="异常类  https://www.yukx.com/jing/article/details/1839.html"></a>异常类  <a href="https://www.yukx.com/jing/article/details/1839.html">https://www.yukx.com/jing/article/details/1839.html</a></h3><p>throw 和 throws 的区别？<br>final、finally、finalize 有什么区别？<br>try-catch-finally 中哪个部分可以省略？<br>try-catch-finally 中，如果 catch 中 return 了，finally 还会执行吗？<br>常见的异常类有哪些？</p>]]></content>
    
    
    <categories>
      
      <category>interview</category>
      
    </categories>
    
    
    <tags>
      
      <tag>interview</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot——日志</title>
    <link href="/2023/03/04/Spring-Boot%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97/"/>
    <url>/2023/03/04/Spring-Boot%E2%80%94%E2%80%94%E6%97%A5%E5%BF%97/</url>
    
    <content type="html"><![CDATA[<h3 id="1-日志框架发展史"><a href="#1-日志框架发展史" class="headerlink" title="1. 日志框架发展史"></a>1. 日志框架发展史</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303050009016.png"></p><h4 id="1-1-Log4J"><a href="#1-1-Log4J" class="headerlink" title="1.1 Log4J"></a>1.1 Log4J</h4><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>log4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.17<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>log4j.properties 配置文件：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#trace&lt;debug&lt;info&lt;warn&lt;error&lt;fatal</span><br><span class="hljs-meta">log4j.rootLogger</span>=<span class="hljs-string">trace, stdout</span><br><span class="hljs-meta">log4j.appender.stdout</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-meta">log4j.appender.stdout.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="hljs-string">%d %p [%c] - %m%n</span><br></code></pre></td></tr></table></figure><p>使用样例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.log4j.Logger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Log4JTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Logger logger = Logger.getLogger(Log4JTest.class);<br>        logger.info(<span class="hljs-string">&quot;test log4j&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-JUL"><a href="#1-2-JUL" class="headerlink" title="1. 2 JUL"></a>1. 2 JUL</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> java.util.logging.Logger;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JULLog</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Logger logger = Logger.getLogger(JULLog.class.getName());<br>        logger.info(<span class="hljs-string">&quot;JUL log message&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-JCL-日志门面"><a href="#1-3-JCL-日志门面" class="headerlink" title="1.3 JCL 日志门面"></a>1.3 JCL 日志门面</h4><p><strong>JCL + JUL</strong></p><p>JCL动态查找机制进行日志实例化，执行顺序为：commons­logging.properties ­­­­&gt; 系统环境变量 ­­­­­­&gt; log4j ­­­&gt; jul­­­ &gt; simplelog ­­­­&gt; nooplog</p><p>JCL 依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>commons-logging.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">org.apache.commons.logging.Log</span> = <span class="hljs-string">org.apache.commons.logging.impl.Jdk14Logger</span><br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303050122033.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.logging.Log;<br><span class="hljs-keyword">import</span> org.apache.commons.logging.LogFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JCLTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Log log = LogFactory.getLog(JCLTest.class);<br>        <span class="hljs-comment">// class org.apache.commons.logging.impl.Jdk14Logger</span><br>        System.out.println(log.getClass());<br>        log.info(<span class="hljs-string">&quot;JUL + JCL test&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-slf4j-日志门面"><a href="#1-4-slf4j-日志门面" class="headerlink" title="1.4 slf4j 日志门面"></a>1.4 slf4j 日志门面</h4><p><strong>slf4j + log4j</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303050129334.png"></p><p><strong>Slf4j与其他各种日志组件的桥接说明：</strong></p><table><thead><tr><th>jar包名</th><th>说明</th></tr></thead><tbody><tr><td><strong>slf4j-log4j12-1.7.13.jar</strong></td><td>Log4j1.2 版本的桥接器，你需要将 Log4j.jar 加入 Classpath</td></tr><tr><td>log4j-slf4j-impl.jar</td><td>Log4j2 版本的桥接器,还需要 log4j­api.jar、log4j­core.jar</td></tr><tr><td><strong>slf4j-jdk14-1.7.13.jar</strong></td><td>java.util.logging 的桥接器，Jdk 原生日志框架</td></tr><tr><td><strong>slf4j-nop-1.7.13.jar</strong></td><td>NOP桥接器，默默丢弃一切日志</td></tr><tr><td><strong>slf4j-simple-1.7.13.jar</strong></td><td>一个简单实现的桥接器，该实现输出所有事件到 System.err. 只有 Info 以及高于该级别的消息被打印</td></tr><tr><td><strong>slf4j-jcl-1.7.13.jar</strong></td><td>Jakarta Commons Logging 的桥接器. 这个桥接器将 Slf4j 所有日志委派给 Jcl</td></tr><tr><td><strong>logback-classic-1.0.13.jar(requires logback-core-1.0.13.jar)</strong></td><td>Slf4j 的原生实现，Logback 直接实现了 Slf4j 的接口，因此使用 Slf4j 与 Logback 的结合使用也意味更小的内存与计算开销</td></tr></tbody></table><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-comment">&lt;!--slf4j-log4j 桥接器--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.slf4j.Logger;<br><span class="hljs-keyword">import</span> org.slf4j.LoggerFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Slf4jTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Logger logger = LoggerFactory.getLogger(Slf4jTest.class);<br>        <span class="hljs-comment">// class org.slf4j.impl.Log4jLoggerAdapter</span><br>        System.out.println(logger.getClass());<br>        logger.info(<span class="hljs-string">&quot;test slf4t&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-5-JCL或JUL-转为slf4j"><a href="#1-5-JCL或JUL-转为slf4j" class="headerlink" title="1.5 JCL或JUL 转为slf4j"></a>1.5 JCL或JUL 转为slf4j</h4><p>日志适配器</p><p><strong>JCL 到 slf4j：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jcl-over-slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.25<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">import</span> org.apache.commons.logging.Log;<br><span class="hljs-keyword">import</span> org.apache.commons.logging.LogFactory;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">JCLTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Log log = LogFactory.getLog(JCLTest.class);<br>        <span class="hljs-comment">// class org.apache.commons.logging.impl.SLF4JLocationAwareLog</span><br>        System.out.println(log.getClass());<br>        log.info(<span class="hljs-string">&quot;JUL + JCL test&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303082355849.png"></p><h4 id="1-6-实践"><a href="#1-6-实践" class="headerlink" title="1.6 实践"></a>1.6 实践</h4><h5 id="案例一"><a href="#案例一" class="headerlink" title="案例一"></a>案例一</h5><p>log4j 和 log2j2  如何实现统一输出，这里就要用上 slf4j 的适配器，slf4j 提供了各种各样的适配器，用来将某种日志框架委托给 slf4j。其最明显的集成工作方式有如下:</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303090028996.png"></p><p>将条件填入,根据应该选 log4j-over-slf4j 适配器。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202307180153316.png"></p><p>ps：根据适配器工作原理的不同，被适配的日志框架并不是一定要删除！以上图为例，log4j 这个日志框架删不删都可以，你只要能保证 log4j 的加载顺序在 log4j-over-slf4j 后即可。因为 log4j-over-slf4j 这个适配器的工作原理是，内部提供了和 log4j 一模一样的 api 接口，因此你在程序中调用 log4j 的 api 的时候，你必须想办法让其走适配器的 api。如果你删了 log4j 这个框架，那你程序里肯定是走 log4j-over-slf4j 这个组件里的 api。如果不删 log4j，只要保证其在 classpth 里的顺序比 log4j 前即可！</p><h5 id="案例二"><a href="#案例二" class="headerlink" title="案例二"></a>案例二</h5><p><strong>如何让 spring 以 log4j2 的形式输出？</strong></p><p>spring 默认使用的是 jcl 输出日志，由于此时并没有引入 Log4j 的日志框架，jcl 会以 jul 做为日志框架。此时集成图如下：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303090039045.png"></p><p>而应用中，采用了 slf4j+log4j-core，即 log4j2 进行日志记录，那么此时集成图如下：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303090040712.png"></p><p>第一种方案，走 jcl-over-slf4j 适配器，此时集成图就变成下面这样了：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303090042072.png"></p><p>第二种方案，走 jul-to-slf4j 适配器：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202303090045752.png"></p><p>ps：这种情况下，记得在代码中执行</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">SLF4JBridgeHandler.removeHandlersForRootLogger();<br>SLF4JBridgeHandler.install();<br></code></pre></td></tr></table></figure><p>这样 jul-to-slf4j 适配器才能正常工作。</p><h3 id="2-SpringBoot-日志"><a href="#2-SpringBoot-日志" class="headerlink" title="2. SpringBoot  日志"></a>2. SpringBoot  日志</h3><h4 id="2-1-介绍"><a href="#2-1-介绍" class="headerlink" title="2.1 介绍"></a>2.1 介绍</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304022319951.png"></p><ol><li>SpringBoot 底层使用 slf4j+logback 的方式进行日志记录。<br>a. logback 桥接：logback-classic</li><li>SpringBoot 把其他的日志都适配成了 slf4j。<br>a. log4j 适配： log4j-over-slf4j<br>b. JUL 适配：jul-to-slf4j<br>c. 这两个适配器都是为了适配 Spring 的默认日志：JCL</li></ol><h4 id="2-2-使用"><a href="#2-2-使用" class="headerlink" title="2.2 使用"></a>2.2 使用</h4><h5 id="1-日志级别"><a href="#1-日志级别" class="headerlink" title="1. 日志级别"></a>1. 日志级别</h5><p>可以设置 TRACE，DEBUG，INFO，WARN，ERROR，FATAL 或 OFF 之一。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">level:</span><br>    <span class="hljs-attr">root:</span> <span class="hljs-string">error</span><br>    <span class="hljs-attr">com:</span><br>      <span class="hljs-attr">debugingLog:</span> <span class="hljs-string">trace</span><br></code></pre></td></tr></table></figure><h5 id="2-日志格式"><a href="#2-日志格式" class="headerlink" title="2. 日志格式"></a>2. 日志格式</h5><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">pattern:</span><br>    <span class="hljs-attr">console:</span> <span class="hljs-string">&quot;%clr(%d&#123;$&#123;LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSXXX&#125;&#125;)&#123;faint&#125; %clr($&#123;LOG_LEVEL_PATTERN:-%5p&#125;) %clr($&#123;PID:- &#125;)&#123;magenta&#125; %clr(---)&#123;faint&#125; %clr([%15.15t])&#123;faint&#125; %clr(%-40.40logger&#123;39&#125;)&#123;cyan&#125; %clr(:)&#123;faint&#125; %m%n$&#123;LOG_EXCEPTION_CONVERSION_WORD:-%wEx&#125;&quot;</span><br></code></pre></td></tr></table></figure><ul><li><p>%clr(%d{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS}}){faint}</p><p>日期和时间：毫秒精度，易于排序。</p><ul><li><p><font color="red"><strong>%clr</strong></font>(要显示的内容) <font color="red"><strong>{faint}</strong></font></p></li><li><p><font color="red"><strong>%d</strong></font>{${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS}}</p><ul><li><p>%d logbak 的日期显示方式</p></li><li><p>${LOG_DATEFORMAT_PATTERN:-yyyy-MM-dd HH:mm:ss.SSS}</p><ul><li><p>${value:value2} springboot 的占位符 + null 条件的表达式（如果 value 为 null 使用 value2)</p></li><li><p>LOG_DATEFORMAT_PATTERN: 系统环境变量中的值，springboot 底层会根据对应的配置项将值设置到对应的环境变量中.</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">System.out.println(System.getProperty(<span class="hljs-string">&quot;LOG_DATEFORMAT_PATTERN&quot;</span>));<br></code></pre></td></tr></table></figure><p><a href="https://docs.spring.io/spring-boot/docs/current/reference/html/features.html#features.logging.custom-log-configuration">（传送门）</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304040113085.png"></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">logging:</span><br>  <span class="hljs-attr">pattern:</span><br>    <span class="hljs-attr">dateformat:</span> <span class="hljs-string">yyyy-MM-dd</span><br></code></pre></td></tr></table></figure></li></ul></li></ul></li></ul></li><li><p>%clr(${LOG_LEVEL_PATTERN:-%5p})</p><ul><li>日志级别：ERROR，WARN，INFO，DEBUG，或TRACE。</li><li>会根据不同的日志级别输出对应的颜色</li><li>%5 代表当前内容所占字符长度</li><li>p 输出日志事件的级别</li></ul></li><li><p>PID</p><ul><li>进程ID</li><li>PID 是系统环境变量中的进程ID（由系统分配）</li></ul></li></ul><h5 id="3-文件输出"><a href="#3-文件输出" class="headerlink" title="3. 文件输出"></a>3. 文件输出</h5><p>默认情况下，Spring Boot 仅记录到控制台，不写日志文件。如果除了控制台输出外还想写日志文件，则需要设置一个 logging.file.name 或 logging.file.path 属性。</p><table><thead><tr><th align="left"><code>logging.file.name</code></th><th align="left"><code>logging.file.path</code></th><th align="left">Example</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><em>(none)</em></td><td align="left"><em>(none)</em></td><td align="left"></td><td align="left">仅控制台记录</td></tr><tr><td align="left">指定文件名</td><td align="left"><em>(none)</em></td><td align="left"><code>my.log</code></td><td align="left">写入指定的日志文件</td></tr><tr><td align="left"><em>(none)</em></td><td align="left">具体目录</td><td align="left"><code>/var/log</code></td><td align="left">写入指定的目录下 spring.log 文件</td></tr></tbody></table><ul><li>logging.file.name<ul><li>可以设置文件的名称， 如果没有设置路径会默认在项目的相对路径下。</li><li>还可以指定路径+文件名：name: D:/debuggingWorld.log。</li></ul></li><li>logging.file.path<ul><li>不可以指定文件名称， 必须要指定一个物理文件夹路径，会使用默认文件名 spring.log 。</li></ul></li></ul><h5 id="4-日志迭代（轮转）"><a href="#4-日志迭代（轮转）" class="headerlink" title="4. 日志迭代（轮转）"></a>4. 日志迭代（轮转）</h5><p>如果使用的是 Logback，则可以使用 application l文件微调日志轮播设置。对于所有其他日志记录系统，则需要直接自己配置轮转设置（例如，如果使用 Log4J2，则可以添加 log4j.xml文件）。</p><table><thead><tr><th align="left">名称</th><th align="left">描述</th></tr></thead><tbody><tr><td align="left"><code>logging.logback.rollingpolicy.file-name-pattern</code></td><td align="left">归档的文件名</td></tr><tr><td align="left"><code>logging.logback.rollingpolicy.clean-history-on-start</code></td><td align="left">如果应在应用程序启动时进行日志归档清理</td></tr><tr><td align="left"><code>logging.logback.rollingpolicy.max-file-size</code></td><td align="left">归档前日志文件的最大大小</td></tr><tr><td align="left"><code>logging.logback.rollingpolicy.total-size-cap</code></td><td align="left">删除日志档案之前可以使用的最大大小</td></tr><tr><td align="left"><code>logging.logback.rollingpolicy.max-history</code></td><td align="left">保留日志存档的天数（默认为7）</td></tr></tbody></table><p>默认文件名：${LOG_FILE}.%d{yyyy-MM-dd}.%i.gz</p><ul><li>${LOG_FILE} 对应 logging.file.name</li><li>%d{yyyy-MM-dd} 日期 年-月-日</li><li>%i 索引， 当文件超出指定大小后进行的文件索引递增</li></ul><h5 id="5-自定义日志配置文件"><a href="#5-自定义日志配置文件" class="headerlink" title="5. 自定义日志配置文件"></a>5. 自定义日志配置文件</h5><p>可以通过在类路径中包含适日志配置文件来激活各种日志记录系统或使用 logging.config。</p><table><thead><tr><th align="left">Logging System</th><th align="left">Customization</th></tr></thead><tbody><tr><td align="left">Logback</td><td align="left"><code>logback-spring.xml</code>, <code>logback-spring.groovy</code>, <code>logback.xml</code>, or <code>logback.groovy</code></td></tr><tr><td align="left">Log4j2</td><td align="left"><code>log4j2-spring.xml</code> or <code>log4j2.xml</code></td></tr><tr><td align="left">JDK (Java Util Logging)</td><td align="left"><code>logging.properties</code></td></tr></tbody></table><p><strong>注意：</strong></p><ul><li>如果使用自定义日志配置文件，会使 springboot 中全局配置文件的 logging 相关配置失效。</li><li>结合 SpringBoot 提供 Profile 来控制日志的生效。<ul><li>注意： 一定要将日志配置文件的文件名改成 logback-spring.xml, 因为 logback.xml 会在 Springboot 容器加载前先被 logback 给加载到， 那么由于 logback 无法解析 springProfile 将会报错。</li></ul></li></ul><p>logback-spring.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;100&#125; ---- %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;!dev&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;100&#125; ===== %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--控制跟细粒度的日志级别  根据包\根据类--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.debuggingLog&quot;</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;TRACE&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;error&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 将当前日志级别输出到哪个追加器上面 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>引用配置文件中的配置项：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--可以使用SpringBoot全局配置文件中的配置项--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">springProperty</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;context&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dateformat&quot;</span> <span class="hljs-attr">source</span>=<span class="hljs-string">&quot;logging.pattern.dateformat&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">defaultValue</span>=<span class="hljs-string">&quot;-yyyy-MM-dd&#x27;T&#x27;HH:mm:ss.SSSXXX&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dev&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;$&#123;dateformat&#125;&#125; [%thread] %-5level %logger&#123;100&#125; ---- %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">springProfile</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;!dev&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;$&#123;dateformat&#125;&#125; [%thread] %-5level %logger&#123;100&#125; ===== %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">springProfile</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="6-切换日志框架"><a href="#6-切换日志框架" class="headerlink" title="6. 切换日志框架"></a>6. 切换日志框架</h5><p><strong>将 logback 切换成 log4j2：</strong></p><ol><li><p>将 logback 的场景启动器排除（slf4j 只能运行有 1 个桥接器）</p><p>排除前：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304060115010.png"></p><p>排除前报错信息：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202304060120660.png"></p><p>排除：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--starter‐web里面自动添加 starter‐logging 也就是 logback 的依赖--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--排除starter‐logging 也就是 logback 的依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>添加 log4j2 的场景启动器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-log4j2<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>添加 log4j2 的配置文件</p><p>log4j2.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span> <span class="hljs-attr">status</span>=<span class="hljs-string">&quot;OFF&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appenders</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">Console</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Console&quot;</span> <span class="hljs-attr">target</span>=<span class="hljs-string">&quot;SYSTEM_OUT&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">PatternLayout</span> <span class="hljs-attr">pattern</span>=<span class="hljs-string">&quot;%d&#123;HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">Console</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appenders</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">loggers</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;info&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;Console&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">loggers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><p><strong>将 logback 切换成 log4j</strong></p><ol><li><p>将 logback 的桥接器排除</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>添加 log4j 的桥接器</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-log4j12<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li><p>添加 log4j 的配置文件</p></li></ol><p>log4j.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#trace&lt;debug&lt;info&lt;warn&lt;error&lt;fatal</span><br><span class="hljs-meta">log4j.rootLogger</span>=<span class="hljs-string">trace, stdout</span><br><span class="hljs-meta">log4j.appender.stdout</span>=<span class="hljs-string">org.apache.log4j.ConsoleAppender</span><br><span class="hljs-meta">log4j.appender.stdout.layout</span>=<span class="hljs-string">org.apache.log4j.PatternLayout</span><br><span class="hljs-meta">log4j.appender.stdout.layout.ConversionPattern</span>=<span class="hljs-string">%d %p [%c] - %m%n</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring Boot——开始&amp;配置文件</title>
    <link href="/2023/02/16/Spring-Boot%E2%80%94%E2%80%94%E5%BC%80%E5%A7%8B-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <url>/2023/02/16/Spring-Boot%E2%80%94%E2%80%94%E5%BC%80%E5%A7%8B-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="1-快速搭建"><a href="#1-快速搭建" class="headerlink" title="1. 快速搭建"></a>1. 快速搭建</h3><h4 id="1-优点"><a href="#1-优点" class="headerlink" title="1. 优点"></a>1. 优点</h4><ul><li>快速构建一个独立的 Spring 应用程序 ；</li><li>嵌入的 Tomcat 、 Jetty 或者 Undertow，无须部署 WAR 文件；</li><li>提供 starter POMs 来简化 Maven 配置和减少版本冲突所带来的问题；</li><li>对 Spring 和第三方库提供默认配置，也可修改默认值，简化框架配置；</li><li>提供生产就绪型功能，如指标、健康检查和外部配置；</li><li>无需配置 XML，无代码生成，开箱即用；</li></ul><p><strong>SpringCloud 带动了 SpringBoot ，SpringBoot 成就了 SpringCloud。</strong></p><h4 id="2-hello-world"><a href="#2-hello-world" class="headerlink" title="2. hello world"></a>2. hello world</h4><p><strong>1. 添加依赖</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">引入父Maven项目，继承父项目的所有配置信息</span><br><span class="hljs-comment">spring-boot-starter-parent 有引入父项目 spring-boot-dependencies，其中管理了第三方组件版本</span><br><span class="hljs-comment">导入依赖不需要写版本号，解决版本冲突问题（SpringBoot 仲裁中心）</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">parent</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.7.6<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">relativePath</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">parent</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    starter 场景启动器</span><br><span class="hljs-comment">    不同的场景启动器维护了对应的所有依赖，从而简化maven依赖</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>2. 创建控制器</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/world&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">helloWorld</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello world&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>3. 编写启动类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * Spring 在解析配置类的时候会去解析 <span class="hljs-doctag">@ComponentScan</span>,得到 basePackages</span><br><span class="hljs-comment"> * 如果没有配置，则会将当前类所在包当做扫描包</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        SpringApplication.run(Application.class,args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>4. 运行访问</strong></p><p>直接运行 main 方法即可。</p><p>SpringBoot 项目默认没有项目名。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302212310742.png"></p><p><strong>5. 修改配置</strong></p><p>src/main/resources/application.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8088</span><br><span class="hljs-meta">server.servlet.context-path</span>=<span class="hljs-string">/debugging</span><br></code></pre></td></tr></table></figure><p>访问路径：<a href="http://127.0.0.1:8088/debugging/hello/world">http://127.0.0.1:8088/debugging/hello/world</a></p><p><strong>6. 打包部署</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>将应用打成 jar 包，直接使用 java -jar 命令进行执行。</p><p><strong>7. 代码结构</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302220025248.png"></p><h4 id="3-使用Spring-Initializer项目"><a href="#3-使用Spring-Initializer项目" class="headerlink" title="3. 使用Spring Initializer项目"></a>3. 使用Spring Initializer项目</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302220057383.png"></p><p>默认生成的 Spring Boot 项目；</p><ul><li>主程序已经生成</li><li>resources 文件夹中目录结构<ul><li><strong>static</strong>：保存所有的静态资源； js css images；</li><li><strong>templates</strong>：保存所有的模板页面；（Spring Boot 默认 jar 包使用嵌入式的 Tomcat，默认不支持 JSP 页 面）；可以使用模板引擎（freemarker、thymeleaf）</li><li><strong>application.properties</strong>：Spring Boot 应用的配置文件，可以修改一些默认设置。</li></ul></li></ul><h4 id="4-自定义-SpringApplication"><a href="#4-自定义-SpringApplication" class="headerlink" title="4. 自定义 SpringApplication"></a>4. 自定义 SpringApplication</h4><p>可以创建一个本地实例对 SpringApplication 默认值进行自定义。</p><p>例如要关闭横幅：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SpringApplication application = <span class="hljs-keyword">new</span> SpringApplication(Application.class);<br>    application.setBannerMode(Banner.Mode.OFF);<br>    application.run(args);<br>&#125;<br></code></pre></td></tr></table></figure><p>通过构造者模式流式构造 SpringApplication:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">new</span> SpringApplicationBuilder(Application.class).bannerMode(Banner.Mode.OFF).run(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-配置文件"><a href="#2-配置文件" class="headerlink" title="2. 配置文件"></a>2. 配置文件</h3><h4 id="1-配置文件介绍"><a href="#1-配置文件介绍" class="headerlink" title="1 配置文件介绍"></a>1 配置文件介绍</h4><p>SringBoot 使用一个全局的配置文件，配置文件名<strong>在约定的情况下</strong>是固定的；</p><p>配置文件的作用：修改 SpringBoot 自动配置的默认值；</p><ul><li>application.properties</li><li>application.yml</li><li>application.yaml</li></ul><h5 id="a-配置文件格式："><a href="#a-配置文件格式：" class="headerlink" title="a. 配置文件格式："></a>a. 配置文件格式：</h5><p>在 springboot 框架中，resource 文件夹里可以存放配置的文件有两种：properties 和 yml。</p><p><strong>1、application.properties 的用法：扁平的 k/v 格式</strong></p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">server.port</span>=<span class="hljs-string">8088</span><br><span class="hljs-meta">server.servlet.context-path</span>=<span class="hljs-string">/debugging</span><br></code></pre></td></tr></table></figure><p><strong>2、application.yml的用法：树型结构</strong></p><figure class="highlight yml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8088</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/debugging</span><br></code></pre></td></tr></table></figure><p>建议使用后者，因为它的可读性更强。</p><h5 id="b-yml-基本语法"><a href="#b-yml-基本语法" class="headerlink" title="b. yml 基本语法"></a>b. yml 基本语法</h5><p>k:(空格)v：表示一对键值对（空格必须有）；<br>以空格的缩进来控制层级关系；只要是左对齐的一列数据，都是同一个层级的；<br>属性和值也是大小写敏感；<br>如果有特殊字符% &amp; 记得用单引号（‘）包起来。</p><h5 id="c-配置文件的加载顺序"><a href="#c-配置文件的加载顺序" class="headerlink" title="c.  配置文件的加载顺序"></a>c.  配置文件的加载顺序</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/application*.yml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/application*.yaml<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/application*.properties<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-外部约定配置文件加载顺序"><a href="#2-外部约定配置文件加载顺序" class="headerlink" title="2. 外部约定配置文件加载顺序"></a>2. 外部约定配置文件加载顺序</h4><p>springboot 启动还会扫描以下位置的 application.properties 或者 application.yml 文件作为 Spring boot 的默认配置文件。优先级从低到高。</p><ol><li>optional:classpath:/</li><li>optional:classpath:/config/</li><li>optional:file:./</li><li>optional:file:./config/*/</li><li>optional:file:./config/</li><li>optional:classpath:custom‐config/ ‐‐spring.config.location</li><li>optional:file:./custom‐config/ ‐‐spring.config.location</li></ol><h5 id="1-classpath-根目录下"><a href="#1-classpath-根目录下" class="headerlink" title="1. classpath 根目录下"></a>1. classpath 根目录下</h5><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302232307746.png"></p><h5 id="2-classpath-的-config-下"><a href="#2-classpath-的-config-下" class="headerlink" title="2. classpath 的 config/ 下"></a>2. classpath 的 config/ 下</h5><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302232148706.png"></p><h5 id="3-项目根目录"><a href="#3-项目根目录" class="headerlink" title="3. 项目根目录"></a>3. 项目根目录</h5><p>如果当前项目是继承/耦合关系 maven 项目的话，项目根目录就是父 maven 项目的根目录。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302232154752.png"></p><h5 id="4-项目根目录-config"><a href="#4-项目根目录-config" class="headerlink" title="4. 项目根目录 /config"></a>4. 项目根目录 /config</h5><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302232159781.png"></p><p><font color="red"><strong>【注】以上高优先级的配置会覆盖低优先级的配置，互补配置。</strong></font></p><h5 id="5-直接子目录-config"><a href="#5-直接子目录-config" class="headerlink" title="5. 直接子目录  /config"></a>5. 直接子目录  /config</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar debugSpringBoot-1.0-SNAPSHOT.jar  --spring.config.location=d:/config/<br>或<br>java -jar debugSpringBoot-1.0-SNAPSHOT.jar  --spring.config.name=application-dev<br></code></pre></td></tr></table></figure><p><font color="red"><strong>此种方式只会生效指定的配置，不会互补，配有指定的使用默认值。</strong></font></p><h4 id="3-Profile-文件的加载"><a href="#3-Profile-文件的加载" class="headerlink" title="3. Profile 文件的加载"></a>3. Profile 文件的加载</h4><p>SpringBoot 框架提供了多 profile 的管理功能，可以使用 profile 功能来区分不同环境的配置。</p><h5 id="1-多Profile文件"><a href="#1-多Profile文件" class="headerlink" title="1. 多Profile文件"></a>1. 多Profile文件</h5><p>语法： <strong>application-{profile}.properties（.yaml/.yml）</strong></p><p>开发环境（application-dev.yml）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8088</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/debugging</span><br></code></pre></td></tr></table></figure><p>生产环境（application-prod.yml）：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">server:</span><br>  <span class="hljs-attr">port:</span> <span class="hljs-number">8081</span><br>  <span class="hljs-attr">servlet:</span><br>    <span class="hljs-attr">context-path:</span> <span class="hljs-string">/hello</span><br></code></pre></td></tr></table></figure><h5 id="2-激活指定-profile"><a href="#2-激活指定-profile" class="headerlink" title="2. 激活指定 profile"></a>2. 激活指定 profile</h5><ol><li>在配置文件中指定 spring.profiles.active=dev</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302232234285.png"></p><ol start="2"><li><p>命令行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar debugSpringBoot-1.0-SNAPSHOT.jar  --spring.profiles.active=dev<br></code></pre></td></tr></table></figure></li></ol><h4 id="4-配置文件读取方式"><a href="#4-配置文件读取方式" class="headerlink" title="4. 配置文件读取方式"></a>4. 配置文件读取方式</h4><p>优先级：低­­­ —&gt; 高</p><h5 id="1-默认属性"><a href="#1-默认属性" class="headerlink" title="1. 默认属性"></a>1. 默认属性</h5><p>（通过设置指定 SpringApplication.setDefaultProperties）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Application</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        SpringApplication springApplication = <span class="hljs-keyword">new</span> SpringApplication(Application.class);<br><br>        InputStream inputStream = Application.class.getClassLoader().getResourceAsStream(<span class="hljs-string">&quot;app.properties&quot;</span>);<br>        Properties properties = <span class="hljs-keyword">new</span> Properties();<br>        properties.load(inputStream);<br><br>        springApplication.setDefaultProperties(properties);<br>        springApplication.run(args);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>会和约定的配置文件形成互补</strong></p><h5 id="2-PropertySource-Configuration-注解"><a href="#2-PropertySource-Configuration-注解" class="headerlink" title="2. @PropertySource @Configuration 注解"></a>2. @PropertySource @Configuration 注解</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PropertySource(&quot;classpath:appSource.properties&quot;)</span><br></code></pre></td></tr></table></figure><p><strong>会和约定的配置文件形成互补</strong></p><h5 id="3-配置数据"><a href="#3-配置数据" class="headerlink" title="3. 配置数据"></a>3. 配置数据</h5><p>（例如 application.properties 文件）</p><p><strong>约定配置文件</strong>（即 2.2 内容）</p><h5 id="4-操作系统环境变量"><a href="#4-操作系统环境变量" class="headerlink" title="4. 操作系统环境变量"></a>4. 操作系统环境变量</h5><p><strong>会使约定配置文件失效（1，2 手动配置的不会失效）</strong></p><p><strong>a. idea：</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302251919809.png"></p><p><strong>b. windows</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">set</span> spring.config.location=D:/config/<br><br>java -jar debugSpringBoot-1.0-SNAPSHOT.jar<br></code></pre></td></tr></table></figure><h5 id="5-Java-系统属性"><a href="#5-Java-系统属性" class="headerlink" title="5. Java 系统属性"></a>5. Java 系统属性</h5><p>（System.getProperties()）</p><p><strong>会使约定配置文件失效</strong></p><p><strong>a. idea：</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302251931983.png"></p><p><strong>b. windows</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar -Dspring.config.location=D:\config\ debugSpringBoot-1.0-SNAPSHOT.jar<br></code></pre></td></tr></table></figure><h5 id="6-JNDI-属性-java-comp-env"><a href="#6-JNDI-属性-java-comp-env" class="headerlink" title="6. JNDI 属性 java:comp/env"></a>6. JNDI 属性 java:comp/env</h5><h5 id="7-ServletContext-初始化参数"><a href="#7-ServletContext-初始化参数" class="headerlink" title="7.  ServletContext 初始化参数"></a>7.  ServletContext 初始化参数</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">ServletContext 的配置标签需要写到 web‐app （根标签）中<br>&lt;context‐param&gt;<br>    &lt;param‐name&gt;spring.config.location&lt;/param‐name&gt;<br>    &lt;param‐value&gt;xxx.properties&lt;/param‐value&gt;<br>&lt;/context‐param&gt;<br></code></pre></td></tr></table></figure><h5 id="8-ServletConfig-初始化参数"><a href="#8-ServletConfig-初始化参数" class="headerlink" title="8. ServletConfig 初始化参数"></a>8. ServletConfig 初始化参数</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml">ServletConfig 的配置标签需要写到 Servlet 标签中<br>&lt;init‐param&gt;<br>    &lt;param‐name&gt;spring.config.location&lt;/param‐name&gt;<br>    &lt;param‐value&gt;xxx.properties&lt;/param‐value&gt;<br>&lt;/init‐param&gt;<br></code></pre></td></tr></table></figure><h5 id="9-命令行参数"><a href="#9-命令行参数" class="headerlink" title="9. 命令行参数"></a>9. 命令行参数</h5><p><strong>会使约定配置文件失效</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">java -jar debugSpringBoot-1.0-SNAPSHOT.jar  --spring.config.location=d:/config/<br></code></pre></td></tr></table></figure><h5 id="10-TestPropertySource"><a href="#10-TestPropertySource" class="headerlink" title="10.  @TestPropertySource"></a>10.  @TestPropertySource</h5><p>用在单元测试上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-meta">@TestPropertySource(&quot;classpath:appSource.properties&quot;)</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ApplicationTest</span> </span>&#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;server.port&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String port;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">testPropertySource</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(port);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-配置文件值注入"><a href="#3-配置文件值注入" class="headerlink" title="3. 配置文件值注入"></a>3. 配置文件值注入</h3><h4 id="3-1-Value"><a href="#3-1-Value" class="headerlink" title="3.1 @Value"></a>3.1 @Value</h4><p>通过  @Value + SPEL 直接绑定 springBoot 配置文件中的值。</p><p>application.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">userName:</span> <span class="hljs-string">debugging</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;user.userName&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-meta">@Value(&quot;$&#123;user.age&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer age;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-ConfigurationProperties"><a href="#3-2-ConfigurationProperties" class="headerlink" title="3.2 @ConfigurationProperties"></a>3.2 @ConfigurationProperties</h4><p>@ConfigurationProperties 常用于 bean 属性和 yaml 配置文件的绑定。prefix 可以指定配置文件中的一个节点，该节点的子节点将自动和属性进行绑定，并且支持松散绑定。</p><p><strong>松散绑定：</strong></p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">userName:</span> <span class="hljs-string">debugging</span><br><br><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">user-Name:</span> <span class="hljs-string">debugging</span><br>  <br><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">user_Name:</span> <span class="hljs-string">debugging</span><br>  <br><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">username:</span> <span class="hljs-string">debugging</span><br>  <br><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">USERNAME:</span> <span class="hljs-string">debugging</span><br></code></pre></td></tr></table></figure><p>导入配置文件处理器，配置文件进行绑定就会有提示：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--会生成 META-INF 元数据，用于自动提示--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-configuration-processor<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--依赖不进行传递--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302262010904.png"></p><p>生成的 META-INF：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302262012540.png"></p><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;user&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Date birthday;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; hobbies;<br>    <span class="hljs-keyword">private</span> Map&lt;String,String&gt; friends;<br>    <span class="hljs-keyword">private</span> Address address;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Address</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String desc;<br>&#125;<br></code></pre></td></tr></table></figure><p>application.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">USERNAME:</span> <span class="hljs-string">debugging</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br>  <span class="hljs-attr">birthday:</span> <span class="hljs-number">2020</span><span class="hljs-string">/2/22</span><br>  <span class="hljs-attr">hobbies:</span> [ <span class="hljs-string">aa</span>,<span class="hljs-string">bb</span> ]<br>  <span class="hljs-attr">friends:</span> &#123; <span class="hljs-string">aa:aaa</span>,<span class="hljs-string">bb:bbb</span> &#125;<br>  <span class="hljs-attr">address:</span><br>    <span class="hljs-attr">id:</span> <span class="hljs-number">1</span><br>    <span class="hljs-attr">desc:</span> <span class="hljs-string">bbb</span><br><span class="hljs-comment">#  friends:</span><br><span class="hljs-comment">#    aa: aaa</span><br><span class="hljs-comment">#    bb: bbb</span><br><span class="hljs-comment">#  hobbies:</span><br><span class="hljs-comment">#    - aa</span><br><span class="hljs-comment">#    - bb</span><br></code></pre></td></tr></table></figure><p><strong>@Value 获取值和 @ConfigurationProperties 获取值比较：</strong></p><table><thead><tr><th></th><th>@ConfigurationProperties</th><th>@Value</th></tr></thead><tbody><tr><td>绑定</td><td>批量注入配置文件中的属性</td><td>一个个指定</td></tr><tr><td>松散绑定（松散语法）</td><td>支持</td><td>支持有限</td></tr><tr><td>SpEL</td><td>不支持</td><td>支持</td></tr><tr><td>自动提示</td><td>支持</td><td>不支持</td></tr></tbody></table><h5 id="PropertySource"><a href="#PropertySource" class="headerlink" title="@PropertySource"></a>@PropertySource</h5><p>加载指定的配置文件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;user&quot;)</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:data/user.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Date birthday;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302280032528.png"></p><h4 id="3-3-配置文件占位符"><a href="#3-3-配置文件占位符" class="headerlink" title="3.3 配置文件占位符"></a>3.3 配置文件占位符</h4><h5 id="1-随机数"><a href="#1-随机数" class="headerlink" title="1. 随机数"></a>1. 随机数</h5><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302272336902.png"></p><h5 id="2-值引用"><a href="#2-值引用" class="headerlink" title="2. 值引用"></a>2. 值引用</h5><p>占位符获取之前配置的值，如果没有可以是用:指定默认值。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">user:</span><br>  <span class="hljs-attr">user-name:</span> <span class="hljs-string">debugging</span><br>  <span class="hljs-attr">age:</span> <span class="hljs-number">18</span><br>  <span class="hljs-attr">birthday:</span> <span class="hljs-number">2020</span><span class="hljs-string">/2/22</span><br>  <span class="hljs-attr">address:</span><br>    <span class="hljs-attr">id:</span> <span class="hljs-string">$&#123;user.scoe:100&#125;</span><br>    <span class="hljs-attr">desc:</span> <span class="hljs-string">$&#123;user.user-name&#125;</span><br></code></pre></td></tr></table></figure><h4 id="3-4-配置文件注入值数据校验"><a href="#3-4-配置文件注入值数据校验" class="headerlink" title="3.4 配置文件注入值数据校验"></a>3.4 配置文件注入值数据校验</h4><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-validation<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加校验注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@ConfigurationProperties(prefix = &quot;user&quot;)</span><br><span class="hljs-meta">@Validated</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@NotNull</span><br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> Date birthday;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302280015019.png"></p><p>【注】：</p><ul><li>@Validated 需要使用在 @ConfigurationProperties 标注的类上。</li><li>校验注解使用 JSR-303 javax.validation 下的注解</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302280007791.png"></p>]]></content>
    
    
    <categories>
      
      <category>Spring Boot</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring Boot</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper——典型使用场景实战</title>
    <link href="/2023/02/13/Zookeeper%E2%80%94%E2%80%94%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AE%9E%E6%88%98/"/>
    <url>/2023/02/13/Zookeeper%E2%80%94%E2%80%94%E5%85%B8%E5%9E%8B%E4%BD%BF%E7%94%A8%E5%9C%BA%E6%99%AF%E5%AE%9E%E6%88%98/</url>
    
    <content type="html"><![CDATA[<p>命名服务是为系统中的资源提供标识能力。ZooKeeper 的命名服务主要是利用 ZooKeeper 节点的树形分层结构和子节点的顺序维护能力，来为分布式系统中的资源命名。</p><p>哪些应用场景需要用到分布式命名服务呢？典型的有：</p><ul><li>分布式API目录</li><li>分布式节点命名</li><li>分布式ID生成器</li></ul><h3 id="1-分布式API目录"><a href="#1-分布式API目录" class="headerlink" title="1. 分布式API目录"></a>1. 分布式API目录</h3><p>为分布式系统中各种 API 接口服务的名称、链接地址，提供类似 JNDI（Java命名和目录接口）中的文件系统的功能。借助于 ZooKeeper 的树形分层结构就能提供分布式的 API 调用功能。</p><p>著名的 Dubbo 分布式框架就是应用了 ZooKeeper 的分布式的 JNDI 功能。在 Dubbo 中，使用 ZooKeeper 维护的全局服务接口 API 的地址列表。大致的思路为：</p><ul><li> 服务提供者（Service Provider）在启动的时候，向 ZooKeeper 上的指定节点 /dubbo/${serviceName}/providers 写入自己的 API 地址，这个操作就相当于服务的公开。</li><li> 服务消费者（Consumer）启动的时候，订阅节点 /dubbo/{serviceName}/providers 下的服务提供者的 URL 地址，获得所有服务提供者的 API。</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302132109236.png"></p><h3 id="2-分布式节点的命名"><a href="#2-分布式节点的命名" class="headerlink" title="2. 分布式节点的命名"></a>2. 分布式节点的命名</h3><p>一个分布式系统通常会由很多的节点组成，节点的数量不是固定的，而是不断动态变化的。比如说，当业务不断膨胀和流量洪峰到来时，大量的节点可能会动态加入到集群中。而一旦流量洪峰过去了，就需要下线大量的节点。再比如说，由于机器或者网络的原因，一些节点会主动离开集群。</p><p>如何为大量的动态节点命名呢？一种简单的办法是可以通过配置文件，手动为每一个节点命名。但是，如果节点数据量太大，或者说变动频繁，手动命名则是不现实的，这就需要用到分布式节点的命名服务。</p><p>可用于生成集群节点的编号的方案：</p><p>（1）使用数据库的自增 ID 特性，用数据表存储机器的 MAC 地址或者 IP 来维护。</p><p>（2）使用 ZooKeeper 持久顺序节点的顺序特性来维护节点的 NodeId 编号。</p><p>在第2种方案中，集群节点命名服务的基本流程是：</p><ul><li>启动节点服务，连接 ZooKeeper，检查命名服务根节点是否存在，如果不存在，就创建系统的根节点。</li><li>在根节点下创建一个临时顺序 ZNode 节点，取回 ZNode 的编号把它作为分布式系统中节点的 NODEID。</li><li>如果临时节点太多，可以根据需要删除临时顺序 ZNode 节点。</li></ul><h3 id="3-分布式的ID生成器"><a href="#3-分布式的ID生成器" class="headerlink" title="3. 分布式的ID生成器"></a>3. 分布式的ID生成器</h3><p>在分布式系统中，分布式 ID 生成器的使用场景非常之多：</p><ul><li>大量的数据记录，需要分布式 ID。</li><li>大量的系统消息，需要分布式 ID。</li><li>大量的请求日志，如 restful 的操作记录，需要唯一标识，以便进行后续的用户行为分析和调用链路分析。</li><li>分布式节点的命名服务，往往也需要分布式 ID。</li><li>。。。</li></ul><p>传统的数据库自增主键已经不能满足需求。在分布式系统环境中，迫切需要一种全新的唯一 ID 系统，这种系统需要满足以下需求：</p><p>（1）全局唯一：不能出现重复 ID。</p><p>（2）高可用：ID 生成系统是基础系统，被许多关键系统调用，一旦宕机，就会造成严重影响。</p><p>有哪些分布式的 ID 生成器方案呢？大致如下：</p><ol><li>Java 的 UUID。</li><li>分布式缓存 Redis 生成 ID：利用 Redis 的原子操作 INCR 和 INCRBY，生成全局唯一的 ID。</li><li>Twitter 的 SnowFlake 算法。</li><li>ZooKeeper 生成 ID：利用 ZooKeeper 的顺序节点，生成全局唯一的 ID。</li><li>MongoDb 的 ObjectId：MongoDB 是一个分布式的非结构化 NoSQL 数据库，每插入一条记录会自动生成全局唯一的一个 “_id” 字段值，它是一个 12 字节的字符串，可以作为分布式系统中全局唯一的 ID。</li></ol><h4 id="1-基于-Zookeeper-实现分布式-ID-生成器"><a href="#1-基于-Zookeeper-实现分布式-ID-生成器" class="headerlink" title="1. 基于 Zookeeper 实现分布式 ID 生成器"></a>1. 基于 Zookeeper 实现分布式 ID 生成器</h4><p>在 ZooKeeper 节点的四种类型中，其中有以下两种类型具备自动编号的能力</p><ul><li>PERSISTENT_SEQUENTIAL 持久化顺序节点。</li><li>EPHEMERAL_SEQUENTIAL 临时顺序节点。</li></ul><p>ZooKeeper 的每一个节点都会为它的第一级子节点维护一份顺序编号，会记录每个子节点创建的先后顺序，这个顺序编号是分布式同步的，也是全局唯一的。</p><p>可以通过创建 ZooKeeper 的临时顺序节点的方法，生成全局唯一的 ID。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String  <span class="hljs-title">makeId</span><span class="hljs-params">(String path)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    String str = createSeqNode(path);<br>    <span class="hljs-keyword">if</span>(<span class="hljs-keyword">null</span> != str)&#123;<br>        <span class="hljs-comment">//获取末尾的序号</span><br>        <span class="hljs-keyword">int</span> index = str.lastIndexOf(path);<br>        <span class="hljs-keyword">if</span>(index&gt;=<span class="hljs-number">0</span>)&#123;<br>            index+=path.length();<br>            <span class="hljs-keyword">return</span> index&lt;=str.length() ? str.substring(index):<span class="hljs-string">&quot;&quot;</span>;<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> str;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> String <span class="hljs-title">createSeqNode</span><span class="hljs-params">(String pathPrefix)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-comment">//创建一个临时顺序节点</span><br>    String destPath = curatorFramework.create()<br>            .creatingParentsIfNeeded()<br>            .withMode(CreateMode.EPHEMERAL_SEQUENTIAL)<br>            .forPath(pathPrefix);<br>    <span class="hljs-keyword">return</span> destPath;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testMarkId</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    IDMaker idMaker = <span class="hljs-keyword">new</span> IDMaker();<br>    String pathPrefix = <span class="hljs-string">&quot;/idmarker/id-&quot;</span>;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++) &#123;<br>        <span class="hljs-keyword">new</span> Thread(() -&gt; &#123;<br>            <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> j = <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">10</span>; j++) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    String id = idMaker.makeId(pathPrefix);<br>                    log.info(<span class="hljs-string">&quot;&#123;&#125;线程第&#123;&#125;个创建的id为&#123;&#125;&quot;</span>, Thread.currentThread().getName(), j, id);<br>                &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                    e.printStackTrace();<br>                &#125;<br>            &#125;<br>        &#125;, <span class="hljs-string">&quot;thread&quot;</span> + i).start();<br>    &#125;<br><br>    Thread.sleep(Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-基于Zookeeper实现SnowFlakeID算法"><a href="#2-基于Zookeeper实现SnowFlakeID算法" class="headerlink" title="2. 基于Zookeeper实现SnowFlakeID算法"></a>2. 基于Zookeeper实现SnowFlakeID算法</h4><p>Twitter（推特）的 SnowFlake 算法是一种著名的分布式服务器用户 ID 生成算法。SnowFlake 算法所生成的 ID 是一个 64bit 的长整型数字。这个 64bit 被划分成四个部分，其中后面三个部分分别表示时间戳、工作机器 ID、序列号。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302132201729.png"></p><p>SnowFlakeID 的四个部分：</p><p>（1）第一位 占用 1 bit，其值始终是0，没有实际作用。</p><p>（2）时间戳 占用 41 bit，精确到毫秒，总共可以容纳约 69 年的时间。</p><p>（3）工作机器 id 占用 10 bit，最多可以容纳 1024 个节点。</p><p>（4）序列号 占用 12 bit。这个值在同一毫秒同一节点上从 0 开始不断累加，最多可以累加到 4095。</p><p>在工作节点达到 1024 顶配的场景下，SnowFlake 算法在同一毫秒最多可以生成的 ID 数量为： 1024 * 4096 =4194304，在绝大多数并发场景下都是够用的。</p><p>SnowFlake 算法的优点：</p><ul><li>生成 ID 时不依赖于数据库，完全在内存生成，高性能和高可用性。</li><li>容量大，每秒可生成几百万个 ID。</li><li>ID 呈趋势递增，后续插入数据库的索引树时，性能较高。</li></ul><p>SnowFlake 算法的缺点：</p><ul><li>依赖于系统时钟的一致性，如果某台机器的系统时钟回拨了，有可能造成 ID 冲突，或者 ID 乱序。</li><li>在启动之前，如果这台机器的系统时间回拨过，那么有可能出现 ID 重复的危险。</li></ul><p>基于 zookeeper 实现雪花算法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SnowflakeIdGenerator</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 单例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SnowflakeIdGenerator instance = <span class="hljs-keyword">new</span> SnowflakeIdGenerator();<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 初始化单例</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> workerId 节点Id,最大8091</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the 单例</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(<span class="hljs-keyword">long</span> workerId)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (workerId &gt; MAX_WORKER_ID) &#123;<br>            <span class="hljs-comment">// zk分配的workerId过大</span><br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalArgumentException(<span class="hljs-string">&quot;worker Id wrong: &quot;</span> + workerId);<br>        &#125;<br>        instance.workerId = workerId;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">SnowflakeIdGenerator</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 开始使用该算法的时间为: 2017-01-01 00:00:00</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> START_TIME = <span class="hljs-number">1483200000000L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * worker id 的bit数，最多支持8192个节点</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> WORKER_ID_BITS = <span class="hljs-number">13</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 序列号，支持单节点最高每毫秒的最大ID数1024</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> SEQUENCE_BITS = <span class="hljs-number">10</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 最大的 worker id ，8091</span><br><span class="hljs-comment">     * -1 的补码（二进制全1）右移13位, 然后取反</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> MAX_WORKER_ID = ~(-<span class="hljs-number">1L</span> &lt;&lt; WORKER_ID_BITS);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 最大的序列号，1023</span><br><span class="hljs-comment">     * -1 的补码（二进制全1）右移10位, 然后取反</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> MAX_SEQUENCE = ~(-<span class="hljs-number">1L</span> &lt;&lt; SEQUENCE_BITS);<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * worker 节点编号的移位</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> WORKER_ID_SHIFT = SEQUENCE_BITS;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 时间戳的移位</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">long</span> TIMESTAMP_LEFT_SHIFT = WORKER_ID_BITS + SEQUENCE_BITS;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 该项目的worker 节点 id</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> workerId;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 上次生成ID的时间戳</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> lastTimestamp = -<span class="hljs-number">1L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 当前毫秒生成的序列</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> sequence = <span class="hljs-number">0L</span>;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * Next id long.</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span> the nextId</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Long <span class="hljs-title">nextId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> generateId();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 生成唯一id的具体实现</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">synchronized</span> <span class="hljs-keyword">long</span> <span class="hljs-title">generateId</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> current = System.currentTimeMillis();<br><br>        <span class="hljs-keyword">if</span> (current &lt; lastTimestamp) &#123;<br>            <span class="hljs-comment">// 如果当前时间小于上一次ID生成的时间戳，说明系统时钟回退过，出现问题返回-1</span><br>            <span class="hljs-keyword">return</span> -<span class="hljs-number">1</span>;<br>        &#125;<br><br>        <span class="hljs-keyword">if</span> (current == lastTimestamp) &#123;<br>            <span class="hljs-comment">// 如果当前生成id的时间还是上次的时间，那么对sequence序列号进行+1</span><br>            sequence = (sequence + <span class="hljs-number">1</span>) &amp; MAX_SEQUENCE;<br><br>            <span class="hljs-keyword">if</span> (sequence == MAX_SEQUENCE) &#123;<br>                <span class="hljs-comment">// 当前毫秒生成的序列数已经大于最大值，那么阻塞到下一个毫秒再获取新的时间戳</span><br>                current = <span class="hljs-keyword">this</span>.nextMs(lastTimestamp);<br>            &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 当前的时间戳已经是下一个毫秒</span><br>            sequence = <span class="hljs-number">0L</span>;<br>        &#125;<br><br>        <span class="hljs-comment">// 更新上次生成id的时间戳</span><br>        lastTimestamp = current;<br><br>        <span class="hljs-comment">// 进行移位操作生成int64的唯一ID</span><br><br>        <span class="hljs-comment">//时间戳右移动23位</span><br>        <span class="hljs-keyword">long</span> time = (current - START_TIME) &lt;&lt; TIMESTAMP_LEFT_SHIFT;<br><br>        <span class="hljs-comment">//workerId 右移动10位</span><br>        <span class="hljs-keyword">long</span> workerId = <span class="hljs-keyword">this</span>.workerId &lt;&lt; WORKER_ID_SHIFT;<br><br>        <span class="hljs-keyword">return</span> time | workerId | sequence;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 阻塞到下一个毫秒</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">long</span> <span class="hljs-title">nextMs</span><span class="hljs-params">(<span class="hljs-keyword">long</span> timeStamp)</span> </span>&#123;<br>        <span class="hljs-keyword">long</span> current = System.currentTimeMillis();<br>        <span class="hljs-keyword">while</span> (current &lt;= timeStamp) &#123;<br>            current = System.currentTimeMillis();<br>        &#125;<br>        <span class="hljs-keyword">return</span> current;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-分布式锁实战"><a href="#4-分布式锁实战" class="headerlink" title="4. 分布式锁实战"></a>4. 分布式锁实战</h3><p><strong>什么是分布式锁</strong></p><p>在单体的应用开发场景中涉及并发同步的时候，大家往往采用 Synchronized（同步）或者其他同一个 JVM 内 Lock 机制来解决多线程间的同步问题。在分布式集群工作的开发场景中，就需要一种更加高级的锁机制来处理跨机器的进程之间的数据同步问题，这种跨机器的锁就是分布式锁。</p><p>目前分布式锁，比较成熟、主流的方案：</p><p>（1）基于数据库的分布式锁。db 操作性能较差，并且有锁表的风险，一般不考虑。</p><p>（2）基于 Redis 的分布式锁。适用于并发量很大、性能要求很高而可靠性问题可以通过其他方案去弥补的场景。</p><p>（3）基于 ZooKeeper 的分布式锁。适用于高可靠（高可用），而并发量不是太高的场景。</p><h4 id="1-基于数据库设计思路"><a href="#1-基于数据库设计思路" class="headerlink" title="1. 基于数据库设计思路"></a>1. 基于数据库设计思路</h4><p>可以利用数据库的唯一索引来实现，唯一索引天然具有排他性。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302142233561.png"></p><p>缺陷：获取锁后宕机会造成死锁。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Lock</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Lock</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 加锁，增加重试逻辑</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//尝试获取锁</span><br>        <span class="hljs-keyword">if</span> (tryLock()) &#123;<br>            System.out.println(<span class="hljs-string">&quot;---------获取锁---------&quot;</span>);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//等待锁 阻塞</span><br>            waitLock();<br>            <span class="hljs-comment">//重试</span><br>            lock();<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-comment">//尝试获取锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-comment">//等待锁</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitLock</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MysqlDistributedLock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLock</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> MethodlockMapper methodlockMapper;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//插入一条数据   insert into</span><br>            methodlockMapper.insert(<span class="hljs-keyword">new</span> Methodlock(<span class="hljs-string">&quot;lock&quot;</span>));<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">//插入失败</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            Thread.sleep(<span class="hljs-number">10</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//删除数据   delete</span><br>        methodlockMapper.deleteByMethodlock(<span class="hljs-string">&quot;lock&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;-------释放锁------&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Methodlock</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-comment">//保证唯一性</span><br>    <span class="hljs-keyword">private</span> String methodName;<br><br>    <span class="hljs-keyword">private</span> Date updateTime;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Methodlock</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Methodlock</span><span class="hljs-params">(String methodName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.methodName = methodName;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-基于Zookeeper设计思路"><a href="#2-基于Zookeeper设计思路" class="headerlink" title="2. 基于Zookeeper设计思路"></a>2. 基于Zookeeper设计思路</h4><p><strong>思路一：</strong></p><p>使用临时 znode 来表示获取锁的请求，创建 znode 成功的用户拿到锁。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302142259764.png"></p><p>缺陷：如果所有的锁请求者都 watch 锁持有者，当代表锁持有者的 znode 被删除以后，所有的锁请求者都会通知到，但是只有一个锁请求者能拿到锁。这就是羊群效应。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZkDistributedLock</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IZkDataListener</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> ZkClient zkClient;<br>    <span class="hljs-keyword">private</span> String path = <span class="hljs-string">&quot;/lock&quot;</span>;<br><br>    <span class="hljs-keyword">private</span> CountDownLatch countDownLatch;<br>    <span class="hljs-keyword">private</span> String config;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ZkDistributedLock</span><span class="hljs-params">(String config, String path)</span> </span>&#123;<br>        zkClient = <span class="hljs-keyword">new</span> ZkClient(config);<br>        <span class="hljs-keyword">this</span>.config = config;<br>        <span class="hljs-keyword">this</span>.path = path;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">if</span> (zkClient == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-comment">//建立连接</span><br>                zkClient = <span class="hljs-keyword">new</span> ZkClient(config);<br>            &#125;<br>            <span class="hljs-comment">// 创建临时节点</span><br>            zkClient.createEphemeral(path);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            <span class="hljs-comment">//存在节点</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//注册监听</span><br>        zkClient.subscribeDataChanges(path, <span class="hljs-keyword">this</span>);<br>        <span class="hljs-keyword">if</span> (zkClient.exists(path)) &#123;<br>            countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">try</span> &#123;<br>                countDownLatch.await();  <span class="hljs-comment">//计数器变为0之前，都会阻塞</span><br>                <span class="hljs-comment">// 解除监听</span><br>                zkClient.unsubscribeDataChanges(path, <span class="hljs-keyword">this</span>);<br>            &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (zkClient != <span class="hljs-keyword">null</span>) &#123;<br>            zkClient.delete(path);<br>            System.out.println(<span class="hljs-string">&quot;-----释放锁资源----&quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataChange</span><span class="hljs-params">(String dataPath, Object data)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataDeleted</span><span class="hljs-params">(String dataPath)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        countDownLatch.countDown();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【注】以上使用的是 zkclient 组件。</p><p><strong>思路二：</strong></p><p>使用临时顺序 znode 来表示获取锁的请求，创建最小后缀数字 znode 的用户成功拿到锁。</p><p>公平锁的实现</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302142312393.png"></p><p>在实际的开发中，如果需要使用到分布式锁，不建议去自己“重复造轮子”，而建议直接使用 Curator 客户端中的各种官方实现的分布式锁，例如其中的InterProcessMutex 可重入锁。 </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZkDistributedLock2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractLock</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IZkDataListener</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> ZkClient zkClient;<br>    <span class="hljs-keyword">private</span> String path;<br>    <span class="hljs-keyword">private</span> String config;<br><br>    <span class="hljs-keyword">private</span> CountDownLatch countDownLatch ;<br>    <span class="hljs-keyword">private</span> String beforePath; <span class="hljs-comment">// 当前节点前一个节点</span><br>    <span class="hljs-keyword">private</span> String currentPath; <span class="hljs-comment">// 当前节点</span><br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">ZkDistributedLock2</span><span class="hljs-params">(String config, String path)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.path = path;<br>        <span class="hljs-keyword">this</span>.config = config;<br>        zkClient = <span class="hljs-keyword">new</span> ZkClient(config);<br>        <span class="hljs-keyword">if</span> (!zkClient.exists(path)) &#123;<br>            <span class="hljs-comment">// 如果根节点不存在，则创建根节点</span><br>            zkClient.createPersistent(path);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">lock</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">//尝试获取锁</span><br>        <span class="hljs-keyword">boolean</span> locked = tryLock();<br>        <span class="hljs-keyword">if</span>(locked)&#123;<br>            System.out.println(<span class="hljs-string">&quot;---------获取锁---------&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">while</span> (!locked)&#123;<br>            <span class="hljs-comment">//等待锁 阻塞</span><br>            waitLock();<br>            <span class="hljs-comment">//重试</span><br>            <span class="hljs-comment">//获取等待的子节点列表</span><br>            List&lt;String&gt; children = zkClient.getChildren(path);<br>            <span class="hljs-comment">//判断，是否加锁成功</span><br>            <span class="hljs-keyword">if</span> (checkLocked(children)) &#123;<br>                locked = <span class="hljs-keyword">true</span>;<br>            &#125;<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">tryLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">//创建临时有序的节点  -e -s</span><br>            currentPath = zkClient.createEphemeralSequential(path+<span class="hljs-string">&quot;/&quot;</span>,<span class="hljs-keyword">null</span>);<br>            <span class="hljs-comment">//获取到所有子节点</span><br>            List&lt;String&gt; children = zkClient.getChildren(path);<br>            <span class="hljs-comment">//获取等待的子节点列表，判断自己是否第一个</span><br>            <span class="hljs-keyword">if</span> (checkLocked(children)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-comment">// 若不是第一个，则找到自己的前一个节点</span><br>            <span class="hljs-keyword">int</span> index =  Collections.binarySearch(children,<br>                    currentPath.substring(currentPath.lastIndexOf(<span class="hljs-string">&quot;/&quot;</span>) + <span class="hljs-number">1</span>));<br>            <span class="hljs-keyword">if</span>(index&lt;<span class="hljs-number">0</span>)&#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception(currentPath+<span class="hljs-string">&quot;节点没有找到&quot;</span> );<br>            &#125;<br>            <span class="hljs-comment">//如果自己没有获得锁，则要监听前一个节点</span><br>            beforePath = path + <span class="hljs-string">&quot;/&quot;</span> + children.get(index-<span class="hljs-number">1</span>);<br>        &#125;<span class="hljs-keyword">catch</span> (Exception e)&#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">checkLocked</span><span class="hljs-params">(List&lt;String&gt; children)</span> </span>&#123;<br><br>        <span class="hljs-comment">//节点按照编号，升序排列</span><br>        Collections.sort(children);<br>        <span class="hljs-comment">// 如果是第一个，代表自己已经获得了锁</span><br>        <span class="hljs-keyword">if</span> (currentPath.equals(path + <span class="hljs-string">&quot;/&quot;</span> +children.get(<span class="hljs-number">0</span>))) &#123;<br>            System.out.println(<span class="hljs-string">&quot;成功的获取分布式锁,节点为&quot;</span>+ currentPath);<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">waitLock</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br>            <span class="hljs-keyword">if</span>(zkClient.exists(beforePath)) &#123;<br>                <span class="hljs-comment">//订阅比自己次小顺序节点的删除事件   index-1</span><br>                zkClient.subscribeDataChanges(beforePath, <span class="hljs-keyword">this</span>);<br>                countDownLatch.await();<br>                zkClient.unsubscribeDataChanges(beforePath, <span class="hljs-keyword">this</span>);<br>            &#125;<br>        &#125; <span class="hljs-keyword">catch</span> (InterruptedException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">unlock</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">if</span>(zkClient !=<span class="hljs-keyword">null</span>)&#123;<br>            <span class="hljs-comment">//删除临时节点</span><br>            zkClient.delete(currentPath,-<span class="hljs-number">1</span>);<br>            System.out.println(currentPath+<span class="hljs-string">&quot; 节点释放锁资源&quot;</span>);<br>        &#125;<br>    &#125;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataChange</span><span class="hljs-params">(String dataPath, Object data)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">handleDataDeleted</span><span class="hljs-params">(String dataPath)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        countDownLatch.countDown(); <span class="hljs-comment">//减1</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-Curator-可重入分布式锁工作流程"><a href="#3-Curator-可重入分布式锁工作流程" class="headerlink" title="3. Curator 可重入分布式锁工作流程"></a>3. Curator 可重入分布式锁工作流程</h4><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CuratorLockTest</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Runnable</span> </span>&#123;<br><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> CuratorFramework client = CuratorFrameworkFactory.builder()<br>            .connectString(<span class="hljs-string">&quot;192.168.60.10:2181&quot;</span>)<br>            .retryPolicy(<span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">100</span>, <span class="hljs-number">1</span>)).build();<br>    <span class="hljs-keyword">private</span> OrderCodeGenerator orderCodeGenerator = <span class="hljs-keyword">new</span> OrderCodeGenerator();<br>    <span class="hljs-comment">//可重入互斥锁</span><br>    <span class="hljs-keyword">final</span> InterProcessMutex lock = <span class="hljs-keyword">new</span> InterProcessMutex(client, <span class="hljs-string">&quot;/curator_lock&quot;</span>);<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>        client.start();<br><br>        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">30</span>; i++) &#123;<br>            <span class="hljs-keyword">new</span> Thread(<span class="hljs-keyword">new</span> CuratorLockTest()).start();<br>        &#125;<br>        Thread.currentThread().join();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-comment">// 加锁</span><br>            lock.acquire();<br><br>            String orderCode = orderCodeGenerator.getOrderCode();<br>            System.out.println(<span class="hljs-string">&quot;生成订单号 &quot;</span> + orderCode);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                <span class="hljs-comment">// 释放锁</span><br>                lock.release();<br>            &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>实现流程：</p><p><a href="https://www.processon.com/view/link/5cadacd1e4b0375afbef4320">https://www.processon.com/view/link/5cadacd1e4b0375afbef4320</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302150010468.png"></p><h4 id="4-总结"><a href="#4-总结" class="headerlink" title="4. 总结"></a>4. 总结</h4><p>优点：ZooKeeper 分布式锁（如 InterProcessMutex），具备高可用、可重入、阻塞锁特性，可解决失效死锁问题，使用起来也较为简单。</p><p>缺点：因为需要频繁的创建和删除节点，性能上不如 Redis。</p><p>在高性能、高并发的应用场景下，不建议使用 ZooKeeper 的分布式锁。而由于 ZooKeeper 的高可用性，因此在并发量不是太高的应用场景中，还是推荐使用 ZooKeeper 的分布式锁。</p><h3 id="5-注册中心实战"><a href="#5-注册中心实战" class="headerlink" title="5. 注册中心实战"></a>5. 注册中心实战</h3><p>用于服务注册和服务发现   </p><p>基于 ZooKeeper 本身的特性可以实现注册中心。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302152252046.png"></p><p>使用：<a href="https://blog.csdn.net/qq_41573234/article/details/106634475">https://blog.csdn.net/qq_41573234/article/details/106634475</a></p>]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper——java操作Zookeeper</title>
    <link href="/2023/02/09/Zookeeper%E2%80%94%E2%80%94java%E6%93%8D%E4%BD%9CZookeeper/"/>
    <url>/2023/02/09/Zookeeper%E2%80%94%E2%80%94java%E6%93%8D%E4%BD%9CZookeeper/</url>
    
    <content type="html"><![CDATA[<p>ZooKeeper 应用的开发主要通过 Java 客户端 API 去连接和操作 ZooKeeper 集群。可供选择的 Java 客户端 API 有：</p><ul><li>ZooKeeper 官方的 Java 客户端 API。</li><li>第三方的 Java 客户端 API，比如 Curator。</li></ul><p>ZooKeeper 官方的客户端 API 提供了基本的操作。例如，创建会话、创建节点、读取节点、更新数据、删除节点和检查节点是否存在等。不过，对于实际开发来说，ZooKeeper 官方 API 有一些不足之处，具体如下：</p><ul><li>ZooKeeper 的 Watcher 监测是一次性的，每次触发之后都需要重新进行注册。</li><li>会话超时之后没有实现重连机制。</li><li>异常处理烦琐，ZooKeeper 提供了很多异常，对于开发人员来说可能根本不知道应该如何处理这些抛出的异常。</li><li>仅提供了简单的 byte[] 数组类型的接口，没有提供 Java POJO 级别的序列化数据处理接口。</li><li>创建节点时如果抛出异常，需要自行检查节点是否存在。</li><li>无法实现级联删除。</li></ul><p>总之，ZooKeeper 官方 API 功能比较简单，在实际开发过程中比较笨重，一般不推荐使用。</p><h3 id="1-Zookeeper-原生-Java-客户端使用"><a href="#1-Zookeeper-原生-Java-客户端使用" class="headerlink" title="1. Zookeeper 原生 Java 客户端使用"></a>1. Zookeeper 原生 Java 客户端使用</h3><p>添加 zookeeper client 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.8.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>注意：保持与服务端版本一致，不然会有很多兼容性的问题</p><p>ZooKeeper 原生客户端主要使用 org.apache.zookeeper.ZooKeeper 这个类来使用 ZooKeeper 服务。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ZooKeeper (connectString, sessionTimeout, watcher)<br></code></pre></td></tr></table></figure><ul><li>connectString：使用逗号分隔的列表，每个 ZooKeeper 节点是一个 host.port 对，host 是机器名或者 IP 地址，port 是 ZooKeeper 节点对客户端提供服务的端口号。客户端会任意选取 connectString 中的一个节点建立连接。</li><li>sessionTimeout : session timeout 时间。</li><li>watcher：用于接收到来自 ZooKeeper 集群的事件。</li></ul><p>使用 zookeeper 原生 API,连接 zookeeper 集群：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZkClientDemo</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> String CONNECT_STR = <span class="hljs-string">&quot;192.168.60.10:2181&quot;</span>;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">static</span> String CLUSTER_CONNECT_STR = <span class="hljs-string">&quot;192.168.65.156:2181,192.168.65.190:2181,192.168.65.200:2181&quot;</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-keyword">final</span> CountDownLatch countDownLatch = <span class="hljs-keyword">new</span> CountDownLatch(<span class="hljs-number">1</span>);<br>        ZooKeeper zooKeeper = <span class="hljs-keyword">new</span> ZooKeeper(CONNECT_STR, <span class="hljs-number">4000</span>, <span class="hljs-keyword">new</span> Watcher() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent event)</span> </span>&#123;<br>                <span class="hljs-keyword">if</span> (Event.KeeperState.SyncConnected == event.getState() &amp;&amp; event.getType() == Event.EventType.None) &#123;<br>                    <span class="hljs-comment">//如果收到了服务端的响应事件，连接成功</span><br>                    countDownLatch.countDown();<br>                    System.out.println(<span class="hljs-string">&quot;连接建立&quot;</span>);<br>                &#125;<br>            &#125;<br>        &#125;);<br>        System.out.print(<span class="hljs-string">&quot;连接中&quot;</span>);<br>        countDownLatch.await();<br>        <span class="hljs-comment">//CONNECTED</span><br>        System.out.println(zooKeeper.getState());<br><br>        <span class="hljs-comment">//创建持久节点</span><br>        zooKeeper.create(<span class="hljs-string">&quot;/user&quot;</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br><br>        <span class="hljs-comment">//持久监听</span><br>        zooKeeper.addWatch(<span class="hljs-string">&quot;/user&quot;</span>, <span class="hljs-keyword">new</span> Watcher() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent watchedEvent)</span> </span>&#123;<br>                System.out.println(watchedEvent);<br>            &#125;<br>        &#125;, AddWatchMode.PERSISTENT);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Zookeeper 主要方法</strong></p><ul><li>create(path, data, acl,createMode): 创建一个给定路径的 znode，并在 znode 保存 data[] 的数据，createMode 指定 znode 的类型。</li><li>delete(path, version)：如果给定 path 上的 znode 的版本和给定的 version 匹配， 删除 znode。</li><li>exists(path, watch)：判断给定 path 上的 znode 是否存在，并在 znode 设置一个 watch。 </li><li>getData(path, watch)：返回给定 path 上的 znode 数据，并在 znode 设置一个 watch。</li><li>setData(path, data, version)：如果给定 path 上的 znode 的版本和给定的 version 匹配，设置 znode 数据。</li><li>getChildren(path, watch)：返回给定 path 上的 znode 的孩子 znode 名字，并在 znode 设置一个 watch。 </li><li>sync(path)：把客户端 session 连接节点和 leader 节点进行同步。</li></ul><p>方法特点：</p><ul><li>所有获取 znode 数据的 API 都可以设置一个 watch 用来监控 znode 的变化。 </li><li>所有更新 znode 数据的 API 都有两个版本: 无条件更新版本和条件更新版本。如果 version 为 -1，更新为无条件更新。否则只有给定的 version 和 znode 当前的 version 一样，才会进行更新，这样的更新是条件更新。</li><li>所有的方法都有同步和异步两个版本。同步版本的方法发送请求给 ZooKeeper 并等待服务器的响应。异步版本把请求放入客户端的请求队列，然后马上返回。异步版本通过 callback 来接受来自服务端的响应。</li></ul><h4 id="1-同步创建节点"><a href="#1-同步创建节点" class="headerlink" title="1. 同步创建节点"></a>1. 同步创建节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> KeeperException, InterruptedException </span>&#123;<br>    String path = zooKeeper.create(ZK_NODE, <span class="hljs-string">&quot;data&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE, CreateMode.PERSISTENT);<br>    log.info(<span class="hljs-string">&quot;created path: &#123;&#125;&quot;</span>,path);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-异步创建节点"><a href="#2-异步创建节点" class="headerlink" title="2. 异步创建节点"></a>2. 异步创建节点</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">createAsycTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> InterruptedException </span>&#123;<br>     zooKeeper.create(ZK_NODE, <span class="hljs-string">&quot;data&quot;</span>.getBytes(), ZooDefs.Ids.OPEN_ACL_UNSAFE,<br>             CreateMode.PERSISTENT,<br>             (rc, path, ctx, name) -&gt; log.info(<span class="hljs-string">&quot;rc  &#123;&#125;,path &#123;&#125;,ctx &#123;&#125;,name &#123;&#125;&quot;</span>,rc,path,ctx,name),<span class="hljs-string">&quot;context&quot;</span>);<br>    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-修改节点数据"><a href="#3-修改节点数据" class="headerlink" title="3. 修改节点数据"></a>3. 修改节点数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTest</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> KeeperException, InterruptedException </span>&#123;<br><br>    Stat stat = <span class="hljs-keyword">new</span> Stat();<br>    <span class="hljs-keyword">byte</span>[] data = zooKeeper.getData(ZK_NODE, <span class="hljs-keyword">false</span>, stat);<br>    log.info(<span class="hljs-string">&quot;修改前: &#123;&#125;&quot;</span>,<span class="hljs-keyword">new</span> String(data));<br>    zooKeeper.setData(ZK_NODE, <span class="hljs-string">&quot;changed!&quot;</span>.getBytes(), stat.getVersion());<br>     <span class="hljs-keyword">byte</span>[] dataAfter = zooKeeper.getData(ZK_NODE, <span class="hljs-keyword">false</span>, stat);<br>    log.info(<span class="hljs-string">&quot;修改后: &#123;&#125;&quot;</span>,<span class="hljs-keyword">new</span> String(dataAfter));<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Curator-开源客户端使用"><a href="#2-Curator-开源客户端使用" class="headerlink" title="2. Curator 开源客户端使用"></a>2. Curator 开源客户端使用</h3><p>Curator 是 Netflix 公司开源的一套 ZooKeeper 客户端框架，和 ZkClient 一样它解决了非常底层的细节开发工作，包括连接、重连、反复注册 Watcher 的问题以及 NodeExistsException 异常等。</p><p>Curator 是 Apache 基金会的顶级项目之一，Curator 具有更加完善的文档，另外还提供了一套易用性和可读性更强的 Fluent 风格的客户端 API 框架。</p><p>Curator 还为 ZooKeeper 客户端框架提供了一些比较普遍的、开箱即用的、分布式开发用的解决方案，例如 Recipe、共享锁服务、Master 选举机制和分布式计数器等，帮助开发者避免了“重复造轮子”的无效开发工作。</p><blockquote><p> Guava is to Java that Curator to ZooKeeper</p></blockquote><p>在实际的开发场景中，使用 Curator 客户端就足以应付日常的 ZooKeeper 集群操作的需求。</p><p>官网：<a href="https://curator.apache.org/">https://curator.apache.org/</a></p><p><strong>引入依赖</strong></p><p>Curator 包含了几个包：</p><ul><li>curator-framework 是对 ZooKeeper 的底层 API 的一些封装。</li><li>curator-client 提供了一些客户端的操作，例如重试策略等。</li><li>curator-recipes 封装了一些高级特性，如：Cache 事件监听、选举、分布式锁、分布式计数器、分布式 Barrier 等。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.curator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>curator-recipes<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>zookeeper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="1-创建客户端"><a href="#1-创建客户端" class="headerlink" title="1. 创建客户端"></a>1. 创建客户端</h4><p>在使用 curator-framework 包操作 ZooKeeper 前，首先要创建一个客户端实例。这是一个 CuratorFramework 类型的对象，有两种方法：</p><ol><li> 使用工厂类 CuratorFrameworkFactory 的静态 newClient() 方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 重试策略</span><br>RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br><span class="hljs-comment">//创建客户端实例</span><br>CuratorFramework client = CuratorFrameworkFactory.newClient(CLUSTER_CONNECT_STR, retryPolicy);<br><span class="hljs-comment">//启动客户端</span><br>client.start();<br></code></pre></td></tr></table></figure><ol start="2"><li>使用工厂类 CuratorFrameworkFactory 的静态 builder 构造者方法。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">RetryPolicy retryPolicy = <span class="hljs-keyword">new</span> ExponentialBackoffRetry(<span class="hljs-number">1000</span>, <span class="hljs-number">3</span>);<br>CuratorFramework client = CuratorFrameworkFactory.builder()<br>        .connectString(<span class="hljs-string">&quot;192.168.60.10:2181,192.168.60.10:2182,192.168.60.10:2183&quot;</span>)<br>        .sessionTimeoutMs(<span class="hljs-number">5000</span>)  <span class="hljs-comment">// 会话超时时间</span><br>        .connectionTimeoutMs(<span class="hljs-number">5000</span>) <span class="hljs-comment">// 连接超时时间</span><br>        .retryPolicy(retryPolicy)<br>        .namespace(<span class="hljs-string">&quot;base&quot;</span>) <span class="hljs-comment">// 包含隔离名称</span><br>        .build();<br>client.start();<br></code></pre></td></tr></table></figure><ul><li><p>connectionString：服务器地址列表，在指定服务器地址列表的时候可以是一个地址，也可以是多个地址。如果是多个地址，那么每个服务器地址列表用逗号分隔, 如  host1:port1,host2:port2,host3；port3 。 </p></li><li><p>retryPolicy：重试策略，当客户端异常退出或者与服务端失去连接的时候，可以通过设置客户端重新连接 ZooKeeper 服务端。而 Curator 提供了 一次重试、多次重试等不同种类的实现方式。在 Curator 内部，可以通过判断服务器返回的 keeperException 的状态代码来判断是否进行重试处理，如果返回的是 OK 表示一切操作都没有问题，而 SYSTEMERROR 表示系统或服务端错误。</p></li></ul><table><thead><tr><th>策略名称</th><th>描述</th></tr></thead><tbody><tr><td>ExponentialBackoffRetry</td><td>重试一组次数，重试之间的睡眠时间增加</td></tr><tr><td>RetryNTimes</td><td>重试最大次数</td></tr><tr><td>RetryOneTime</td><td>只重试一次</td></tr><tr><td>RetryUntilElapsed</td><td>在给定的时间结束之前重试</td></tr></tbody></table><ul><li>超时时间：Curator 客户端创建过程中，有两个超时时间的设置。一个是 sessionTimeoutMs 会话超时时间，用来设置该条会话在 ZooKeeper 服务端的失效时间。另一个是 connectionTimeoutMs 客户端创建会话的超时时间，用来限制客户端发起一个会话连接到接收 ZooKeeper 服务端应答的时间。sessionTimeoutMs 作用在服务端，而 connectionTimeoutMs 作用在客户端。</li></ul><h4 id="2-创建节点"><a href="#2-创建节点" class="headerlink" title="2. 创建节点"></a>2. 创建节点</h4><p>描述一个节点要包括节点的类型，即临时节点还是持久节点、节点的数据信息、节点是否是有序节点等属性和性质。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCreate</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    String path = curatorFramework.create().forPath(<span class="hljs-string">&quot;/curator-node&quot;</span>);<br>    curatorFramework.create().withMode(CreateMode.PERSISTENT).forPath(<span class="hljs-string">&quot;/curator-node1&quot;</span>, <span class="hljs-string">&quot;some-data&quot;</span>.getBytes());<br>    curatorFramework.create()<br>            <span class="hljs-comment">// protection 模式，防止由于异常原因呆滞僵尸节点</span><br>            .withProtection()<br>            .withMode(CreateMode.PERSISTENT).forPath(<span class="hljs-string">&quot;/curator-node2&quot;</span>, <span class="hljs-string">&quot;some-data&quot;</span>.getBytes());<br><br>&#125;<br></code></pre></td></tr></table></figure><p>在 Curator 中，可以使用 create 函数创建数据节点，并通过 withMode 函数指定节点类型（持久化节点，临时节点，顺序节点，临时顺序节点，持久化顺序节点等），默认是持久化节点，之后调用 forPath 函数来指定节点的路径和数据信息。</p><p><strong>一次性创建带层级结构的节点：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCreateWithParent</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    String pathWithParent=<span class="hljs-string">&quot;/node-parent/sub-node-1&quot;</span>;<br>    String path = curatorFramework.create().creatingParentsIfNeeded().forPath(pathWithParent);<br>    log.info(<span class="hljs-string">&quot;curator create node :&#123;&#125;  successfully.&quot;</span>,path);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-获取数据"><a href="#3-获取数据" class="headerlink" title="3. 获取数据"></a>3. 获取数据</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testGetData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <span class="hljs-keyword">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="hljs-string">&quot;/curator-node1&quot;</span>);<br>    log.info(<span class="hljs-string">&quot;get data from  node :&#123;&#125;  successfully.&quot;</span>,<span class="hljs-keyword">new</span> String(bytes));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-更新节点"><a href="#4-更新节点" class="headerlink" title="4. 更新节点"></a>4. 更新节点</h4><p>我们通过客户端实例的 setData() 方法更新 ZooKeeper 服务上的数据节点，在 setData 方法的后边，通过 forPath 函数来指定更新的数据节点路径以及要更新的数据。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSetData</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    curatorFramework.setData().forPath(<span class="hljs-string">&quot;/curator-node&quot;</span>,<span class="hljs-string">&quot;changed!&quot;</span>.getBytes());<br>    <span class="hljs-keyword">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="hljs-string">&quot;/curator-node&quot;</span>);<br>    log.info(<span class="hljs-string">&quot;get data from  node /curator-node :&#123;&#125;  successfully.&quot;</span>,<span class="hljs-keyword">new</span> String(bytes));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-删除节点"><a href="#5-删除节点" class="headerlink" title="5. 删除节点"></a>5. 删除节点</h4><p>guaranteed：该函数的功能如字面意思一样，主要起到一个保障删除成功的作用，其底层工作方式是：只要该客户端的会话有效，就会在后台持续发起删除请求，直到该数据节点在 ZooKeeper 服务端被删除。</p><p>deletingChildrenIfNeeded：指定了该函数后，系统在删除该数据节点的时候会以递归的方式直接删除其子节点，以及子节点的子节点。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    String pathWithParent=<span class="hljs-string">&quot;/node-parent&quot;</span>;<br>    curatorFramework.delete().guaranteed().deletingChildrenIfNeeded().forPath(pathWithParent);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-异步接口"><a href="#6-异步接口" class="headerlink" title="6. 异步接口"></a>6. 异步接口</h4><p>Curator 引入了BackgroundCallback 接口，用来处理服务器端返回来的信息，这个处理过程是在异步线程中调用，默认在 <strong>EventThread</strong> 中调用，也可以自定义线程池。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BackgroundCallback</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">processResult</span><span class="hljs-params">(CuratorFramework client, CuratorEvent event)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上接口，主要参数为 client 客户端， 和 服务端事件 event </p><p>inBackground 异步处理默认在 EventThread 中执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    curatorFramework.getData().inBackground((client, event) -&gt; &#123;<br>        log.info(<span class="hljs-string">&quot; background: &#123;&#125;&quot;</span>, event);<br>    &#125;).forPath(<span class="hljs-string">&quot;/curator-node&quot;</span>);<br><br>    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><p> 指定线程池：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInBackground</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    ExecutorService singleThreadExecutor = Executors.newSingleThreadExecutor();<br><br>    curatorFramework.getData().inBackground((client, event) -&gt; &#123;<br>        log.info(<span class="hljs-string">&quot; background: &#123;&#125;&quot;</span>, event);<br>    &#125;,singleThreadExecutor).forPath(<span class="hljs-string">&quot;/curator-node&quot;</span>);<br><br>    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-Curator-监听器"><a href="#7-Curator-监听器" class="headerlink" title="7. Curator 监听器"></a>7. Curator 监听器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CuratorListener</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span>         <span class="hljs-title">eventReceived</span><span class="hljs-params">(CuratorFramework client, CuratorEvent event)</span> <span class="hljs-keyword">throws</span> Exception</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>针对 background 通知和错误通知。使用此监听器之后，调用inBackground 方法会异步获得监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testCuratorListener</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    curatorFramework.getCuratorListenable().addListener((CuratorFramework client, CuratorEvent event)-&gt;&#123;<br>        log.info(<span class="hljs-string">&quot; things changed1: event: &#123;&#125;,  &#123;&#125; &quot;</span>,event.getType().name(),event);<br>    &#125;);<br><br>    log.info(<span class="hljs-string">&quot;start to change data for path :&#123;&#125;&quot;</span> , <span class="hljs-string">&quot;/curator-node&quot;</span>);<br>    curatorFramework.setData().inBackground().forPath(<span class="hljs-string">&quot;/curator-node&quot;</span>,<span class="hljs-string">&quot;xxx1&quot;</span>.getBytes());<br>    log.info(<span class="hljs-string">&quot;start to change data for path :&#123;&#125; again&quot;</span> , <span class="hljs-string">&quot;/curator-node&quot;</span>);<br>    curatorFramework.setData().inBackground().forPath(<span class="hljs-string">&quot;/curator-node&quot;</span>,<span class="hljs-string">&quot;xxx2&quot;</span>.getBytes());<br><br>    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Watcher：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 watcher 机制， 为一次性监听</span><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testWatcher</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    <span class="hljs-keyword">byte</span>[] bytes = curatorFramework.getData().usingWatcher(<span class="hljs-keyword">new</span> Watcher() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">process</span><span class="hljs-params">(WatchedEvent event)</span> </span>&#123;<br>            <span class="hljs-keyword">if</span> (event.getType() == Event.EventType.NodeDataChanged) &#123;<br>                log.info(<span class="hljs-string">&quot;node &#123;&#125; data changed!&quot;</span>, event.getPath());<br>            &#125;<br>        &#125;<br>    &#125;).forPath(<span class="hljs-string">&quot;/test&quot;</span>);<br><br>    log.info(<span class="hljs-string">&quot; original data: &#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> String(bytes));<br>    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="7-Curator-Caches"><a href="#7-Curator-Caches" class="headerlink" title="7. Curator Caches"></a>7. Curator Caches</h4><p>Curator 引入了 Cache 来实现对 Zookeeper 服务端事件监听，Cache 事件监听可以理解为一个本地缓存视图与远程 Zookeeper 视图的对比过程。Cache 提供了反复注册的功能。Cache 分为两类注册类型：节点监听和子节点监听。</p><p><strong>node cache:</strong></p><p>NodeCache 对某一个节点进行监听，可以通过注册监听器来实现对当前节点数据变化的处理。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testNodeCache</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    NodeCache nodeCache = <span class="hljs-keyword">new</span> NodeCache(curatorFramework, <span class="hljs-string">&quot;/node-cache&quot;</span>);<br>    nodeCache.getListenable().addListener(<span class="hljs-keyword">new</span> NodeCacheListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">nodeChanged</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            <span class="hljs-keyword">byte</span>[] bytes = curatorFramework.getData().forPath(<span class="hljs-string">&quot;/node-cache&quot;</span>);<br>            log.info(<span class="hljs-string">&quot;data: &#123;&#125;&quot;</span>, <span class="hljs-keyword">new</span> String(bytes));<br>        &#125;<br>    &#125;);<br>    nodeCache.start();<br><br>    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>path cache:</strong>  </p><p>PathChildrenCache 会对子节点进行监听，但是不会对二级子节点进行监听。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">PathChildrenCache</span><span class="hljs-params">(CuratorFramework client,</span></span><br><span class="hljs-params"><span class="hljs-function">                         String path,</span></span><br><span class="hljs-params"><span class="hljs-function">                         <span class="hljs-keyword">boolean</span> cacheData)</span></span><br><span class="hljs-function"><span class="hljs-comment">/*</span></span><br><span class="hljs-comment"><span class="hljs-function">    Parameters:</span></span><br><span class="hljs-comment"><span class="hljs-function">    client - the client</span></span><br><span class="hljs-comment"><span class="hljs-function">    path - path to watch</span></span><br><span class="hljs-comment"><span class="hljs-function">    cacheData - if true, node contents are cached in addition to the stat</span></span><br><span class="hljs-comment"><span class="hljs-function">*/</span></span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPathCache</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    PathChildrenCache pathChildrenCache = <span class="hljs-keyword">new</span> PathChildrenCache(curatorFramework, <span class="hljs-string">&quot;/path-cache&quot;</span>, <span class="hljs-keyword">true</span>);<br>    pathChildrenCache.getListenable().addListener(<span class="hljs-keyword">new</span> PathChildrenCacheListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">childEvent</span><span class="hljs-params">(CuratorFramework client, PathChildrenCacheEvent event)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            log.info(<span class="hljs-string">&quot;event:  &#123;&#125;&quot;</span>,event);<br>        &#125;<br>    &#125;);<br>    <span class="hljs-comment">// 如果设置为true则在首次启动时就会缓存节点内容到Cache中</span><br>    pathChildrenCache.start(<span class="hljs-keyword">true</span>);<br><br>    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>tree cache:</strong></p><p>TreeCache 使用一个内部类 TreeNode 来维护这个一个树结构。并将这个树结构与 ZK 节点进行了映射。所以 TreeCache 可以监听当前节点下所有节点的事件。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testTreeCache</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    <br>    TreeCache treeCache = <span class="hljs-keyword">new</span> TreeCache(curatorFramework, <span class="hljs-string">&quot;/tree-path&quot;</span>);<br>    treeCache.getListenable().addListener(<span class="hljs-keyword">new</span> TreeCacheListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">childEvent</span><span class="hljs-params">(CuratorFramework client, TreeCacheEvent event)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>            log.info(<span class="hljs-string">&quot; tree cache: &#123;&#125;&quot;</span>,event);<br>        &#125;<br>    &#125;);<br>    treeCache.start();<br><br>    TimeUnit.SECONDS.sleep(Integer.MAX_VALUE);<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper——集群</title>
    <link href="/2023/02/08/Zookeeper%E2%80%94%E2%80%94%E9%9B%86%E7%BE%A4/"/>
    <url>/2023/02/08/Zookeeper%E2%80%94%E2%80%94%E9%9B%86%E7%BE%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="1-集群角色"><a href="#1-集群角色" class="headerlink" title="1. 集群角色"></a>1. 集群角色</h3><ul><li><p>Leader： 领导者</p><p>事务请求（写操作）的唯一调度者和处理者，保证集群事务处理的顺序性；集群内部各个服务器的调度者。对于 create、setData、delete 等有写操作的请求，则要统一转发给 leader 处理，leader 需要决定编号、执行操作，这个过程称为事务。</p></li><li><p>Follower: 跟随者</p><p>处理客户端非事务（读操作）请求（可以直接响应），转发事务请求给 Leader；参与集群 Leader 选举投票。</p></li><li><p>Observer: 观察者</p><p>对于非事务请求可以独立处理（读操作），对于事务性请求会转发给 leader 处理。Observer 节点接收来自 leader 的 inform 信息，更新自己的本地存储，不参与提交和选举投票。通常在不影响集群事务处理能力的前提下提升集群的非事务处理能力。</p></li></ul><p>Observer 应用场景：</p><ul><li>提升集群的读性能。因为 Observer 不参与提交和选举的投票过程，所以可以通过往集群里面添加 observer 节点来提高整个集群的读性能。</li><li>跨数据中心部署。 比如需要部署一个北京和香港两地都可以使用的 zookeeper 集群服务，并且要求北京和香港客户的读请求延迟都很低。解决方案就是把香港的节点都设置为 observer。</li></ul><h3 id="2-集群架构"><a href="#2-集群架构" class="headerlink" title="2. 集群架构"></a>2. 集群架构</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302082253398.png"></p><p>leader 节点可以处理读写请求，follower 只可以处理读请求。follower 在接到写请求时会把写请求转发给 leader 来处理。</p><p>Zookeeper 数据一致性保证：</p><ul><li>全局可线性化(Linearizable )写入∶先到达 leader 的写请求会被先处理，leader 决定写请求的执行顺序。</li><li>客户端 FIFO 顺序∶来自给定客户端的请求按照发送顺序执行。</li></ul><h3 id="3-集群搭建"><a href="#3-集群搭建" class="headerlink" title="3. 集群搭建"></a>3. 集群搭建</h3><p>环境准备：三台虚拟机</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">192.168.65.156<br>192.168.65.190<br>192.168.65.200<br></code></pre></td></tr></table></figure><p><strong>1)  修改 zoo.cfg 配置，添加 server 节点配置</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 修改数据存储目录</span><br>dataDir=/data/zookeeper<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">三台虚拟机 zoo.cfg 文件末尾添加配置</span><br>server.1=192.168.65.156:2888:3888<br>server.2=192.168.65.190:2888:3888<br>server.3=192.168.65.200:2888:3888<br></code></pre></td></tr></table></figure><blockquote><p>server.A=B:C:D</p><p>A 是一个数字，表示这个是第几号服务器； 集群模式下配置一个文件 myid，这个文件在 dataDir 目录下，这个文件里面有一个数据就是 A 的值，Zookeeper 启动时读取此文件，拿到里面的数据与 zoo.cfg 里面的配置信息比较从而判断到底是哪个server。 </p><p>B 是这个服务器的地址； </p><p>C 是这个服务器 Follower 与集群中的 Leader 服务器交换信息的端口； </p><p>D 是万一集群中的 Leader 服务器挂了，需要一个端口来重新进行选举，选出一个新的 Leader，而这个端口就是用来执行选举时服务器相互通信的端口。</p></blockquote><p><strong>2）创建 myid 文件，配置服务器编号</strong></p><p>在 dataDir 对应目录下创建 myid 文件，内容为对应 ip 的 zookeeper 服务器编号</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">cd /data/zookeeper<br><span class="hljs-meta">#</span><span class="bash"> 在文件中添加与 server 对应的编号（注意：上下不要有空行，左右不要有空格）</span><br>vim myid<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302082325693.png"></p><p><strong>3）启动 zookeeper server 集群</strong></p><p>启动前需要关闭防火墙(生产环境需要打开对应端口)</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 分别启动三个节点的zookeeper server</span><br>bin/zkServer.sh start<br><span class="hljs-meta">#</span><span class="bash"> 查看集群状态</span><br>bin/zkServer.sh status<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302082326970.png"></p><h3 id="4-Zookeeper-四字命令"><a href="#4-Zookeeper-四字命令" class="headerlink" title="4. Zookeeper  四字命令"></a>4. Zookeeper  四字命令</h3><p>zookeeper 支持某些特定的四字命令与其交互，用户获取 zookeeper 服务的当前状态及相关信息，用户在客户端可以通过 telenet 或者 nc（netcat） 向 zookeeper 提交相应的命令。</p><p>安装 nc 命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> centos</span><br>yum install nc <br></code></pre></td></tr></table></figure><p>四字命令格式：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">echo [command] | nc [ip] [port]<br></code></pre></td></tr></table></figure><p>ZooKeeper 常用四字命令主要如下：</p><table><thead><tr><th>四字命令</th><th>功能描述</th></tr></thead><tbody><tr><td>conf</td><td>3.3.0版本引入的。打印出服务相关配置的详细信息。</td></tr><tr><td>cons</td><td>3.3.0版本引入的。列出所有连接到这台服务器的客户端全部连接/会话详细信息。包括”接受/发送”的包数量、会话id、操作延迟、最后的操作执行等等信息。</td></tr><tr><td>crst</td><td>3.3.0版本引入的。重置所有连接的连接和会话统计信息。</td></tr><tr><td>dump</td><td>列出那些比较重要的会话和临时节点。这个命令只能在leader节点上有用。</td></tr><tr><td>envi</td><td>打印出服务环境的详细信息。</td></tr><tr><td>reqs</td><td>列出未经处理的请求</td></tr><tr><td>ruok</td><td>测试服务是否处于正确状态。如果确实如此，那么服务返回”imok”，否则不做任何相应。</td></tr><tr><td>stat</td><td>输出关于性能和连接的客户端的列表。</td></tr><tr><td>srst</td><td>重置服务器的统计。</td></tr><tr><td>srvr</td><td>3.3.0版本引入的。列出连接服务器的详细信息</td></tr><tr><td>wchs</td><td>3.3.0版本引入的。列出服务器watch的详细信息。</td></tr><tr><td>wchc</td><td>3.3.0版本引入的。通过session列出服务器watch的详细信息，它的输出是一个与watch相关的会话的列表。</td></tr><tr><td>wchp</td><td>3.3.0版本引入的。通过路径列出服务器watch的详细信息。它输出一个与session相关的路径。</td></tr><tr><td>mntr</td><td>3.4.0版本引入的。输出可用于检测集群健康状态的变量列表</td></tr></tbody></table><p><strong>开启四字命令:</strong></p><p>方法1： 在 zoo.cfg 文件里加入配置项让这些指令放行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">开启四字命令</span><br>4lw.commands.whitelist=*<br></code></pre></td></tr></table></figure><p>方法2：在 zk 的启动脚本 zkServer.sh 中新增放行指令</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">添加ＶＭ环境变量-Dzookeeper.4lw.commands.whitelist=*</span><br>ZOOMAIN=&quot;-Dzookeeper.4lw.commands.whitelist=* $&#123;ZOOMAIN&#125;&quot;<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">$</span><span class="bash"> <span class="hljs-built_in">echo</span> <span class="hljs-built_in">stat</span> | nc 192.168.65.156 2181</span><br></code></pre></td></tr></table></figure><h3 id="5-Leader-选举"><a href="#5-Leader-选举" class="headerlink" title="5. Leader 选举"></a>5. Leader 选举</h3><p>zookeeper 的 leader 选举存在两个阶段，一个是服务器启动时 leader 选举，另一个是运行过程中 leader 服务器宕机。</p><p>在分析选举原理前，先介绍几个重要的参数：</p><ul><li>服务器 ID(myid)：编号越大在选举算法中权重越大</li><li>事务 ID(zxid)：值越大说明数据越新，权重越大</li><li>逻辑时钟(epoch-logicalclock)：同一轮投票过程中的逻辑时钟值是相同的，每投完一次值会增加</li></ul><p>选举状态：</p><ul><li><p>LOOKING: 竞选状态</p></li><li><p>FOLLOWING: 随从状态，同步 leader 状态，参与投票</p></li><li><p>OBSERVING: 观察状态，同步 leader 状态，不参与投票</p></li><li><p>LEADING: 领导者状态</p></li></ul><h4 id="1-启动时的选举"><a href="#1-启动时的选举" class="headerlink" title="1. 启动时的选举"></a>1. 启动时的选举</h4><p>每个节点启动的时候都是 LOOKING 观望状态，接下来就开始进行选举主流程。这里选取三台机器组成的集群为例。第一台服务器 server1启动时，无法进行 leader 选举，当第二台服务器 server2 启动时，两台机器可以相互通信，进入 leader 选举过程。</p><ul><li><p>（1）每台 server 发出一个投票，由于是初始情况，server1 和 server2 都将自己作为 leader 服务器进行投票，每次投票包含所推举的服务器myid、zxid、epoch，使用（myid，zxid）表示，此时 server1 投票为（1,0），server2 投票为（2,0），然后将各自投票发送给集群中其他机器。</p></li><li><p>（2）接收来自各个服务器的投票。集群中的每个服务器收到投票后，首先判断该投票的有效性，如检查是否是本轮投票（epoch）、是否来自 LOOKING 状态的服务器。</p></li><li><p>（3）分别处理投票。针对每一次投票，服务器都需要将其他服务器的投票和自己的投票进行对比，对比规则如下：</p></li><li><ul><li>a. 优先比较 epoch</li><li>b. 检查 zxid，zxid 比较大的服务器优先作为 leader</li><li>c. 如果 zxid 相同，那么就比较 myid，myid 较大的服务器作为 leader 服务器</li></ul></li><li><p>（4）统计投票。每次投票后，服务器统计投票信息，判断是都有过半机器接收到相同的投票信息。server1、server2 都统计出集群中有两台机器接受了（2,0）的投票信息，此时已经选出了 server2 为 leader 节点。</p></li><li><p>（5）改变服务器状态。一旦确定了 leader，每个服务器响应更新自己的状态，如果是 follower，那么就变更为 FOLLOWING，如果是 Leader，变更为 LEADING。此时 server3 继续启动，直接加入变更自己为 FOLLOWING。</p></li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302082346061.png"></p><h4 id="2-运行过程中的选举"><a href="#2-运行过程中的选举" class="headerlink" title="2. 运行过程中的选举"></a>2. 运行过程中的选举</h4><p>当集群中 leader 服务器出现宕机或者不可用情况时，整个集群无法对外提供服务，进入新一轮的 leader 选举。</p><ul><li>（1）变更状态。leader 挂后，其他非 Oberver 服务器将自身服务器状态变更为 LOOKING。</li><li>（2）每个 server 发出一个投票。在运行期间，每个服务器上 zxid 可能不同。</li><li>（3）处理投票。规则同启动过程。</li><li>（4）统计投票。与启动过程相同。</li><li>（5）改变服务器状态。与启动过程相同。</li></ul><p><a href="https://www.jianshu.com/p/639e48b80b32">https://www.jianshu.com/p/639e48b80b32</a></p><h3 id="6-数据同步"><a href="#6-数据同步" class="headerlink" title="6. 数据同步"></a>6. 数据同步</h3><p>在 Zookeeper 中，主要依赖 ZAB 协议来实现分布式数据一致性。</p><p>ZAB 协议分为两部分：</p><ul><li>消息广播</li><li>崩溃恢复</li></ul><h4 id="1-消息广播"><a href="#1-消息广播" class="headerlink" title="1. 消息广播"></a>1. 消息广播</h4><p>Zookeeper 使用单一的主进程 Leader 来接收和处理客户端所有事务请求，并采用 ZAB 协议的原子广播协议，将事务请求以 Proposal 提议广播到所有 Follower 节点，当集群中有过半的 Follower 服务器进行正确的 ACK 反馈，那么 Leader 就会再次向所有的 Follower 服务器发送 commit 消息，将此次提案进行提交。这个过程可以简称为 2pc 事务提交，整个流程可以参考下图，注意 Observer 节点只负责同步 Leader 数据，不参与 2PC 数据同步过程。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302092126584.png"></p><h4 id="2-崩溃恢复"><a href="#2-崩溃恢复" class="headerlink" title="2. 崩溃恢复"></a>2. 崩溃恢复</h4><p>在正常情况下消息广播能运行良好，但是一旦 Leader 服务器出现崩溃，或者由于网络原因导致 Leader 服务器失去了与过半 Follower 的通信，那么就会进入崩溃恢复模式，需要选举出一个新的 Leader 服务器。在这个过程中可能会出现两种数据不一致性的隐患，需要 ZAB 协议的特性进行避免。</p><ul><li>Leader 服务器将消息 commit 发出后，立即崩溃</li><li>Leader 服务器刚提出 proposal 后，立即崩溃</li></ul><p>ZAB 协议的恢复模式使用了以下策略：</p><ul><li>选举 zxid 最大的节点作为新的 leader</li><li>新 leader 将事务日志中尚未提交的消息进行处理</li></ul>]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Zookeeper——特性与节点数据类型</title>
    <link href="/2023/02/02/Zookeeper%E2%80%94%E2%80%94%E7%89%B9%E6%80%A7%E4%B8%8E%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2023/02/02/Zookeeper%E2%80%94%E2%80%94%E7%89%B9%E6%80%A7%E4%B8%8E%E8%8A%82%E7%82%B9%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1-CAP-amp-Base-理论"><a href="#1-CAP-amp-Base-理论" class="headerlink" title="1. CAP&amp;Base 理论"></a>1. CAP&amp;Base 理论</h3><h4 id="1-1-CAP-理论"><a href="#1-1-CAP-理论" class="headerlink" title="1. 1 CAP 理论"></a>1. 1 CAP 理论</h4><p>CAP 理论指出对于一个分布式计算系统来说，不可能同时满足以下三点：</p><ul><li><strong>一致性</strong>：在分布式环境中，一致性是指数据在多个副本之间是否能够保持一致的特性，等同于所有节点访问同一份最新的数据副本。在一致性的需求下，当一个系统在数据一致的状态下执行更新操作后，应该保证系统的数据仍然处于一致的状态。</li><li><strong>可用性</strong>：每次请求都能获取到正确的响应，但是不保证获取的数据为最新数据。</li><li><strong>分区容错性</strong>：分布式系统在遇到任何网络分区故障的时候，仍然需要能够保证对外提供满足一致性和可用性的服务，除非是整个网络环境都发生了故障。</li></ul><p>一个分布式系统最多只能同时满足一致性（Consistency）、可用性（Availability）和分区容错性（Partition tolerance）这三项中的两项。<br>在这三个基本需求中，最多只能同时满足其中的两项，P 是必须的，因此只能在 CP 和 AP 中选择，zookeeper 保证的是 CP，而 eureka 实现的是 AP。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302022326136.png"></p><h4 id="1-2-BASE-理论"><a href="#1-2-BASE-理论" class="headerlink" title="1.2 BASE 理论"></a>1.2 BASE 理论</h4><p>BASE 是 Basically Available(基本可用)、Soft-state(软状态) 和 Eventually Consistent(最终一致性) 三个短语的缩写。</p><ul><li>基本可用：在分布式系统出现故障，允许损失部分可用性（服务降级、页面降级）。</li><li>软状态：允许分布式系统出现中间状态。而且中间状态不影响系统的可用性。这里的中间状态是指不同的 data replication（数据备份节点）之间的数据更新可以出现延时的最终一致性。</li><li>最终一致性：data replications 经过一段时间达到一致性。</li></ul><p>BASE 理论是对 CAP 中的一致性和可用性进行一个权衡的结果，理论的核心思想就是：我们无法做到强一致，但每个应用都可以根据自身的业务特点，采用适当的方式来使系统达到最终一致性。</p><blockquote><p><strong>强一致性</strong>：又称线性一致性(linearizability )</p><ol><li>任意时刻，所有节点中的数据是一样的</li><li>一个集群需要对外部提供强一致性，所以只要集群内部某一台服务器的数据发生了改变，那么就需要等待集群内其他服务器的数据同步完成后，才能正常的对外提供服务</li><li>保证了强一致性，务必会损耗可用性</li></ol><p><strong>弱一致性：</strong></p><ol><li>系统中的某个数据被更新后，后续对该数据的读取操作可能得到更新后的值，也可能是更改前的值。</li><li>即使过了不一致时间窗口，后续的读取也不一定能保证一致。</li></ol><p><strong>最终一致性：</strong></p><ol><li>弱一致性的特殊形式，不保证在任意时刻任意节点上的同一份数据都是相同的，但是随着时间的迁移，不同节点上的同一份数据总是在向趋同的方向变化</li><li>存储系统保证在没有新的更新的条件下，最终所有的访问都是最后更新的值</li></ol><p><strong>顺序一致性：</strong></p><ol><li>任何一次读都能读到某个数据的最近一次写的数据。</li><li>对其他节点之前的修改是可见(已同步)且确定的,并且新的写入建立在已经达成同步的基础上。</li></ol></blockquote><p><font color="red"><strong>Zookeeper 写入是强一致性，读取是顺序一致性。</strong></font></p><h3 id="2-Zookeeper-介绍"><a href="#2-Zookeeper-介绍" class="headerlink" title="2. Zookeeper 介绍"></a>2. Zookeeper 介绍</h3><h4 id="2-1-什么是-Zookeeper："><a href="#2-1-什么是-Zookeeper：" class="headerlink" title="2.1 什么是 Zookeeper："></a>2.1 什么是 Zookeeper：</h4><p>　　ZooKeeper 是一个开源的分布式协调框架，是 Apache Hadoop 的一个子项目，主要用来解决分布式集群中应用系统的一致性问题。Zookeeper 的设计目标是将复杂且容易出错的分布式一致性服务封装起来，构成一个高效可靠的原语集，并以一系列简单易用的接口提供给用户使用。</p><p>官方：<a href="https://zookeeper.apache.org/">https://zookeeper.apache.org/</a></p><p>　　ZooKeeper 本质上是一个分布式的小文件存储系统（Zookeeper=文件系统+监听机制）。提供基于类似于文件系统的目录树方式的数据存储，并且可以对树中的节点进行有效管理，从而用来维护和监控存储的数据的状态变化。通过监控这些数据状态的变化，从而可以达到基于数据的集群管理、统一命名服务、分布式配置管理、分布式消息队列、分布式锁、分布式协调等功能。</p><p>　　Zookeeper从设计模式角度来理解：是一个基于观察者模式设计的分布式服务管理框架，它负责存储和管理大家都关心的数据，然后接受观察者的注册，一旦这些数据的状态发生变化，Zookeeper 就将负责通知已经在Zookeeper上注册的那些观察者做出相应的反应。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302022327914.png"></p><h4 id="2-2-Zookeeper-安装"><a href="#2-2-Zookeeper-安装" class="headerlink" title="2.2 Zookeeper 安装"></a>2.2 Zookeeper 安装</h4><p>下载地址：<a href="https://zookeeper.apache.org/releases.html">https://zookeeper.apache.org/releases.html</a><br>运行环境：jdk8</p><p><strong>1）修改配置文件</strong></p><p>解压安装包后进入 conf 目录，复制 zoo_sample.cfg，修改为 zoo.cfg</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">cp zoo_sample.cfg  zoo.cfg <br></code></pre></td></tr></table></figure><p>修改 zoo.cfg 配置文件，将 dataDir=/tmp/zookeeper 修改为指定的 data 目录</p><p>zoo.cfg中参数含义： </p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302022258432.png"></p><p><strong>2）启动 zookeeper server</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash"> 默认加载配置路径conf/zoo.cfg</span><br>bin/zkServer.sh start conf/zoo.cfg<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash"> 查看zookeeper状态</span><br>bin/zkServer.sh status<br></code></pre></td></tr></table></figure><p><strong>3）启动 zookeeper client 连接 Zookeeper server</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs shell">bin/zkCli.sh<br><span class="hljs-meta">#</span><span class="bash"> 连接远程的zookeeper server</span><br>bin/zkCli.sh -server ip:port<br></code></pre></td></tr></table></figure><h4 id="2-3-客户端命令行操作"><a href="#2-3-客户端命令行操作" class="headerlink" title="2.3 客户端命令行操作"></a>2.3 客户端命令行操作</h4><p>输入命令 help 查看 zookeeper 支持的所有命令：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302022319076.png"></p><p>常见 cli 命令：<br><a href="https://zookeeper.apache.org/doc/r3.8.0/zookeeperCLI.html">https://zookeeper.apache.org/doc/r3.8.0/zookeeperCLI.html</a></p><table><thead><tr><th>命令基本语法</th><th>功能描述</th></tr></thead><tbody><tr><td>help</td><td>显示所有操作命令</td></tr><tr><td>ls [-s] [-w] [-R] path</td><td>使用 ls 命令来查看当前 znode 的子节点 [可监听]  -w: 监听子节点变化 -s: 节点状态信息（时间戳、版本号、数据大小等）-R: 表示递归的获取</td></tr><tr><td>create [-s] [-e] [-c] [-t ttl] path [data] [acl]</td><td>创建节点-s : 创建有序节点。-e : 创建临时节点。-c : 创建一个容器节点。t ttl] : 创建一个TTL节点， -t 时间（单位毫秒）。data：节点的数据，可选，如果不使用时，节点数据就为null。acl：访问控制</td></tr><tr><td>get [-s] [-w] path</td><td>获取节点数据信息 -s: 节点状态信息（时间戳、版本号、数据大小等） -w: 监听节点变化</td></tr><tr><td>set [-s] [-v version] path data</td><td>设置节点数据-s:表示节点为顺序节点-v: 指定版本号</td></tr><tr><td>getAcl [-s] path</td><td>获取节点的访问控制信息-s: 节点状态信息（时间戳、版本号、数据大小等）</td></tr><tr><td>setAcl [-s] [-v version] [-R] path acl</td><td>设置节点的访问控制列表-s:节点状态信息（时间戳、版本号、数据大小等）-v:指定版本号-R:递归的设置</td></tr><tr><td>stat [-w] path</td><td>查看节点状态信息</td></tr><tr><td>delete [-v version] path</td><td>删除某一节点，只能删除无子节点的节点。-v： 表示节点版本号</td></tr><tr><td>deleteall path</td><td>递归的删除某一节点及其子节点</td></tr><tr><td>setquota -n|-b val path</td><td>对节点增加限制n:表示子节点的最大个数b:数据值的最大长度，-1表示无限制</td></tr></tbody></table><h3 id="3-ZooKeeper-使用"><a href="#3-ZooKeeper-使用" class="headerlink" title="3.  ZooKeeper 使用"></a>3.  ZooKeeper 使用</h3><p>ZooKeeper 数据模型的结构与 Unix 文件系统很类似，整体上可以看作是一棵树，每个节点称做一个 ZNode。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302032315172.png"></p><p>ZooKeeper 的数据模型是层次模型，层次模型常见于文件系统。层次模型和 key-value 模型是两种主流的数据模型。ZooKeeper 使用文件系统模型主要基于以下两点考虑：</p><ol><li>文件系统的树形结构便于表达数据之间的层次关系</li><li>文件系统的树形结构便于为不同的应用分配独立的命名空间( namespace ) </li></ol><p>ZooKeeper 的层次模型称作 Data Tree，Data Tree 的每个节点叫作 Znode。不同于文件系统，每个节点都可以保存数据，每一个 ZNode 默认能够存储 1MB 的数据，每个 ZNode 都可以通过其路径唯一标识，每个节点都有一个版本(version)，版本从 0 开始计数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataTree</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> ConcurrentHashMap&lt;String, DataNode&gt; nodes = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;String, DataNode&gt;();<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WatchManager dataWatches = <span class="hljs-keyword">new</span> WatchManager();<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> WatchManager childWatches = <span class="hljs-keyword">new</span> WatchManager();<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DataNode</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Record</span> </span>&#123;<br>    <span class="hljs-keyword">byte</span> data[];<br>    Long acl;<br>    <span class="hljs-keyword">public</span> StatPersisted stat;<br>    <span class="hljs-keyword">private</span> Set&lt;String&gt; children = <span class="hljs-keyword">null</span>;<br> &#125;   <br></code></pre></td></tr></table></figure><h4 id="3-1-节点分类"><a href="#3-1-节点分类" class="headerlink" title="3.1 节点分类"></a>3.1 节点分类</h4><p>一个 znode 可以使持久性的，也可以是临时性的：</p><ol><li>持久节点(PERSISTENT): 在创建之后即使发生 ZooKeeper 集群宕机或者 client 宕机也不会丢失。</li><li>临时节点(EPHEMERAL ): client 宕机或者 client 在指定的 timeout 时间内没有给 ZooKeeper 集群发消息，这样的 znode 就会消失。</li></ol><p>如果上面两种 znode 具备顺序性，又有以下两种 znode :<br>3. 持久顺序节点(PERSISTENT_SEQUENTIAL):  除了具备持久节点的特点之外，znode 的名字具备顺序性。</p><ol start="4"><li>临时顺序节点(EPHEMERAL_SEQUENTIAL): 除了具备临时节点的特点之外，znode 的名字具备顺序性。</li></ol><p>zookeeper主要用到的是以上4种节点。</p><ol start="5"><li>Container 节点 (3.5.3版本新增)：Container 容器节点，当容器中没有任何子节点，该容器节点会被 zk 定期删除（定时任务默认60s 检查一次)。 和持久节点的区别是 ZK 服务端启动后，会有一个单独的线程去扫描，所有的容器节点，当发现容器节点的子节点数量为 0 时，会自动删除该节点。可以用于 leader 或者锁的场景中。</li><li>TTL 节点:  带过期时间节点，默认禁用，需要在 zoo.cfg 中添加 extendedTypesEnabled=true 开启。 注意：ttl 不能用于临时节点</li></ol><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs she">#创建持久节点<br>create /servers  xxx<br>#创建临时节点<br>create -e /servers/host  xxx<br>#创建临时有序节点<br>create -e -s /servers/host  xxx<br>#创建容器节点<br>create -c /container xxx<br># 创建ttl节点<br>create -t 10 /ttl<br></code></pre></td></tr></table></figure><h4 id="3-2-节点状态信息"><a href="#3-2-节点状态信息" class="headerlink" title="3.2 节点状态信息"></a>3.2 节点状态信息</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302052322192.png"></p><ul><li><p>cZxid ：Znode 创建的事务 id。</p></li><li><p>ctime：节点创建时的时间戳。</p></li><li><p>mZxid ：Znode 被修改的事务 id，即每次对 Znode 的修改都会更新 mZxid。<br>  对于 zk 来说，每次的变化都会产生一个唯一的事务 id，zxid（ZooKeeper Transaction Id），通过 zxid，可以确定更新操作的先后顺序。例如，如果 zxid1 小于 zxid2，说明 zxid1 操作先于 zxid2 发生，zxid 对于整个 zk 都是唯一的，即使操作的是不同的 znode。</p></li><li><p>pZxid: 表示该节点的子节点列表最后一次修改的事务 ID，添加子节点或删除子节点就会影响子节点列表，但是修改子节点的数据内容则不影响该 ID（注意: 只有子节点列表变更了才会变更 pzxid，子节点内容变更不会影响 pzxid）</p></li><li><p>mtime：节点最新一次更新发生时的时间戳。</p></li><li><p>cversion ：子节点的版本号。当 Znode 的子节点有变化时，cversion 的值就会增加 1。</p></li><li><p>dataVersion：数据版本号，每次对节点进行 set 操作，dataVersion 的值都会增加 1（即使设置的是相同的数据），可有效避免了数据更新时出现的先后顺序问题。</p></li><li><p>ephemeralOwner：如果该节点为临时节点, ephemeralOwner 值表示与该节点绑定的 session id。如果不是, ephemeralOwner 值为0(持久节点)。<br> 在 client 和 server 通信之前,首先需要建立连接,该连接称为 session。连接建立后,如果发生连接超时、授权失败,或者显式关闭连接，连接便处于 closed 状态, 此时 session 结束。</p></li><li><p>dataLength ： 数据的长度</p></li><li><p>numChildren ：子节点的数量（只统计直接子节点的数量）</p></li></ul><h4 id="3-3-监听通知（watcher）机制"><a href="#3-3-监听通知（watcher）机制" class="headerlink" title="3.3 监听通知（watcher）机制"></a>3.3 监听通知（watcher）机制</h4><ul><li><p>一个 Watch 事件是一个一次性的触发器，当被设置了 Watch 的数据发生了改变的时候，则服务器将这个改变发送给设置了 Watch 的客户端，以便通知它们。</p></li><li><p>Zookeeper 采用了  Watcher 机制实现数据的发布订阅功能，多个订阅者可同时监听某一特定主题对象，当该主题对象的自身状态发生变化时，例如节点内容改变、节点下的子节点列表改变等，会实时、主动通知所有订阅者。</p></li><li><p>watcher 机制与观察者模式类似，也可看作是一种观察者模式在分布式场景下的实现方式。</p></li></ul><p>watcher 的过程：</p><ol><li><p> 客户端向服务端注册 watcher</p></li><li><p>服务端事件发生触发 watcher</p></li><li><p>客户端回调 watcher 得到触发事件情况</p><p>注意：Zookeeper 中的 watch 机制，必须客户端先去服务端注册监听，这样事件发送才会触发监听，通知给客户端。</p></li></ol><p>支持的事件类型：</p><ul><li>None: 连接建立事件</li><li>NodeCreated： 节点创建</li><li>NodeDeleted： 节点删除</li><li>NodeDataChanged：节点数据变化</li><li>NodeChildrenChanged：子节点列表变化</li><li>DataWatchRemoved：节点监听被移除</li><li>ChildWatchRemoved：子节点监听被移除</li></ul><table><thead><tr><th>特性</th><th>说明</th></tr></thead><tbody><tr><td>一次性触发</td><td>watcher是一次性的，一旦被触发就会移除，再次使用时需要重新注册</td></tr><tr><td>客户端顺序回调</td><td>watcher回调是顺序串行执行的，只有回调后客户端才能看到最新的数据状态。一个watcher回调逻辑不应该太多，以免影响别的watcher执行</td></tr><tr><td>轻量级</td><td>WatchEvent是最小的通信单位，结构上只包含通知状态、事件类型和节点路径，并不会告诉数据节点变化前后的具体内容</td></tr><tr><td>时效性</td><td>watcher只有在当前session彻底失效时才会无效，若在session有效期内快速重连成功，则watcher依然存在，仍可接收到通知；</td></tr></tbody></table><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">监听节点数据的变化</span><br>get -w path <br>stat -w path<br><span class="hljs-meta">#</span><span class="bash">监听子节点增减的变化</span> <br>ls -w path <br></code></pre></td></tr></table></figure><p><font color="red"> <strong>永久性 Watch：</strong> </font></p><p>在被触发之后，仍然保留，可以继续监听 ZNode 上的变更，是 Zookeeper 3.6.0 版本新增的功能</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">addWatch [-m mode] path              <br></code></pre></td></tr></table></figure><p>addWatch 的作用是针对指定节点添加事件监听，支持两种模式</p><ul><li>PERSISTENT，持久化订阅，针对当前节点的修改和删除事件，以及当前节点的子节点的删除和新增事件。</li><li>PERSISTENT_RECURSIVE，持久化递归订阅，在 PERSISTENT 的基础上，增加了子节点修改的事件触发，以及子节点的子节点的数据变化都会触发相关事件（满足递归订阅特性）</li></ul><h4 id="3-4-使用案例"><a href="#3-4-使用案例" class="headerlink" title="3.4 使用案例"></a>3.4 使用案例</h4><h5 id="1-协同服务"><a href="#1-协同服务" class="headerlink" title="1. 协同服务"></a>1. 协同服务</h5><p>设计一个 master-worker 的组成员管理系统，要求系统中只能有一个 master , master 能实时获取系统中 worker 的情况。</p><p>保证组里面只有一个 master 的设计思路：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">master1</span><br>create -e /master &quot;m1:2223&quot;  <br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">master2</span><br>create -e /master &quot;m2:2223&quot;   # /master已经存在，创建失败<br>Node already exists: /master<br><span class="hljs-meta">#</span><span class="bash">监听/master节点</span><br>stat -w /master<br><span class="hljs-meta">#</span><span class="bash">当master2收到/master节点删除通知后可以再次发起创建节点操作</span><br>create -e /master &quot;m2:2223&quot;<br></code></pre></td></tr></table></figure><p>master 监控 worker 状态的设计思路：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta">#</span><span class="bash">master服务</span><br>create /workers<br><span class="hljs-meta">#</span><span class="bash">让master服务监控/workers下的子节点,监控是一次性的</span><br>ls -w /workers<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">worker1</span><br>create -e /workers/w1 &quot;w1:2224&quot; #创建子节点，master服务会收到子节点变化通知<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">master服务</span><br>ls -w /workers<br><span class="hljs-meta">#</span><span class="bash">worker2</span><br>create -e /workers/w2 &quot;w2:2224&quot;  #创建子节点，master服务会收到子节点变化通知<br><span class="hljs-meta"></span><br><span class="hljs-meta">#</span><span class="bash">master服务</span><br>ls -w /workers<br><span class="hljs-meta">#</span><span class="bash">worker2</span><br>quit  #worker2退出，master服务会收到子节点变化通知<br></code></pre></td></tr></table></figure><h5 id="2-条件更新"><a href="#2-条件更新" class="headerlink" title="2. 条件更新"></a>2. 条件更新</h5><p>设想用 znode  /c 实现一个 counter，使用 set 命令来实现自增 1 操作。条件更新场景∶</p><ol><li><p>客户端 1 把 /c 更新到版本 1，实现 /c 的自增 1。</p></li><li><p>客户端 2 把 /c 更新到版本 2，实现 /c 的自增 1。</p></li><li><p>客户端 1 不知道 /c 已经被客户端 2 更新过了，还用过时的版本 1 是去更新 /c，更新失败。如果客户端 1 使用的是无条件更新，/c 就会更新为 2，没有实现自增 1。</p></li></ol><p>使用条件更新可以避免出现客户端基于过期的数据进行数据更新的操作。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302062135937.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302062135933.png"></p><h4 id="3-5-节点特性"><a href="#3-5-节点特性" class="headerlink" title="3.5 节点特性"></a>3.5 节点特性</h4><ol><li><p>同一级节点 key 名称是唯一的</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302062140944.png"></p></li><li><p>创建节点时，必须要带上全路径</p></li><li><p>session 关闭，临时节点清除</p></li><li><p>自动创建顺序节点</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302062147023.png"></p></li><li><p>watch 机制，监听节点变化<br>事件监听机制类似于观察者模式，watch 流程是客户端向服务端某个节点路径上注册一个 watcher，同时客户端也会存储特定的 watcher，当节点数据或子节点发生变化时，服务端通知客户端，客户端进行回调处理。特别注意：监听事件被单次触发后，事件就失效了。</p></li><li><p>delete 命令只能一层一层删除。提示：新版本可以通过 deleteall 命令递归删除。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302062150494.png"></p></li></ol><h4 id="3-6-应用场景"><a href="#3-6-应用场景" class="headerlink" title="3.6 应用场景"></a>3.6 应用场景</h4><p>ZooKeeper适用于存储和协同相关的关键数据，不适合用于大数据量存储。</p><p>有了上述众多节点特性，使得 zookeeper 能开发不出不同的经典应用场景，比如：</p><ul><li>注册中心</li><li>数据发布/订阅（常用于实现配置中心）</li><li>负载均衡</li><li>命名服务</li><li>分布式协调/通知</li><li>集群管理</li><li>Master选举</li><li>分布式锁</li><li>分布式队列</li></ul><h5 id="1-统一命名服务"><a href="#1-统一命名服务" class="headerlink" title="1. 统一命名服务"></a>1. 统一命名服务</h5><p>在分布式环境下，经常需要对应用/服务进行统一命名，便于识别。</p><p>例如：IP不容易记住，而域名容易记住。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302062158069.png"></p><p>利用 ZooKeeper 顺序节点的特性，制作分布式的序列号生成器，或者叫 id 生成器。（分布式环境下使用作为数据库 id，另外一种是 UUID（缺点：没有规律）），ZooKeeper 可以生成有顺序的容易理解的同时支持分布式环境的编号。</p><h5 id="2-数据发布-订阅"><a href="#2-数据发布-订阅" class="headerlink" title="2. 数据发布/订阅"></a>2. 数据发布/订阅</h5><p>数据发布/订阅的一个常见的场景是配置中心，发布者把数据发布到 ZooKeeper 的一个或一系列的节点上，供订阅者进行数据订阅，达到动态获取数据的目的。</p><p>配置信息一般有几个特点:</p><ol><li>数据量小的 KV</li><li>数据内容在运行时会发生动态变化</li><li>集群机器共享，配置一致</li></ol><p>ZooKeeper 采用的是推拉结合的方式。</p><ol><li>推: 服务端会推给注册了监控节点的客户端 Watcher 事件通知</li><li>拉: 客户端获得通知后，然后主动到服务端拉取最新的数据</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302062203095.png"></p><h5 id="3-统一集群管理"><a href="#3-统一集群管理" class="headerlink" title="3. 统一集群管理"></a>3. 统一集群管理</h5><p>分布式环境中，实时掌握每个节点的状态是必要的，可根据节点实时状态做出一些调整。</p><p> ZooKeeper 可以实现实时监控节点状态变化：</p><ul><li>可将节点信息写入 ZooKeeper 上的一个 ZNode。</li><li>监听这个 ZNode 可获取它的实时状态变化。</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302062207318.png"></p><h5 id="4-负载均衡"><a href="#4-负载均衡" class="headerlink" title="4. 负载均衡"></a>4. 负载均衡</h5><p>在 Zookeeper 中记录每台服务器的访问数，让访问数最少的服务器去处理最新的客户端请求</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302062211972.png"></p><h4 id="3-7-ACL权限控制"><a href="#3-7-ACL权限控制" class="headerlink" title="3.7 ACL权限控制"></a>3.7 ACL权限控制</h4><p>zookeeper 的 ACL（Access Control List，访问控制表）权限在生产环境是特别重要的，ACL 权限可以针对节点设置相关读写等权限，保障数据安全性。</p><h5 id="1-ACL-构成"><a href="#1-ACL-构成" class="headerlink" title="1. ACL 构成"></a>1. ACL 构成</h5><p>zookeeper 的 acl 通过 <strong>[scheme : id : permissions]</strong> 来构成权限列表。</p><ul><li><strong>scheme</strong>：授权的模式，代表采用的某种权限机制，包括 world、auth、digest、ip、super 几种。</li><li><strong>id</strong>：授权对象，代表允许访问的用户。如果我们选择采用 IP 方式，使用的授权对象可以是一个 IP 地址或 IP 地址段；而如果使用 Digest 或 Super 方式，则对应于一个用户名。如果是 World 模式，是授权系统中所有的用户。</li><li><strong>permissions</strong>：授权的权限，权限组合字符串，由 cdrwa 组成，其中每个字母代表支持不同权限， 创建权限 create(c)、删除权限 delete(d)、读权限 read(r)、写权限 write(w)、管理权限 admin(a)。</li></ul><table><thead><tr><th>模式</th><th>描述</th></tr></thead><tbody><tr><td>world</td><td>授权对象只有一个anyone，代表登录到服务器的所有客户端都能对该节点执行某种权限</td></tr><tr><td>ip</td><td>对连接的客户端使用IP地址认证方式进行认证</td></tr><tr><td>auth</td><td>使用以添加认证的用户进行认证</td></tr><tr><td>digest</td><td>使用 用户:密码方式验证</td></tr></tbody></table><table><thead><tr><th>权限类型</th><th>ACL简写</th><th>描述</th></tr></thead><tbody><tr><td>read</td><td>r</td><td>读取节点及显示子节点列表的权限</td></tr><tr><td>write</td><td>w</td><td>设置节点数据的权限</td></tr><tr><td>create</td><td>c</td><td>创建子节点的权限</td></tr><tr><td>delete</td><td>d</td><td>删除子节点的权限</td></tr><tr><td>admin</td><td>a</td><td>设置该节点ACL权限的权限</td></tr></tbody></table><table><thead><tr><th>授权命令</th><th>用法</th><th>描述</th></tr></thead><tbody><tr><td>getAcl</td><td>getAcl path</td><td>读取节点的ACL</td></tr><tr><td>setAcl</td><td>setAcl path acl</td><td>设置节点的ACL</td></tr><tr><td>create</td><td>create path data acl</td><td>创建节点时设置acl</td></tr><tr><td>addAuth</td><td>addAuth scheme auth</td><td>添加认证用户，类似于登录操作</td></tr></tbody></table><h5 id="2-world-授权模式"><a href="#2-world-授权模式" class="headerlink" title="2. world 授权模式"></a>2. world 授权模式</h5><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302081953541.png"></p><h5 id="3-auth-授权模式"><a href="#3-auth-授权模式" class="headerlink" title="3. auth 授权模式"></a>3. auth 授权模式</h5><p>需要先添加用户后授权。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302082045093.png"></p><p>退出客户端重新进入后无权限，需重新添加：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302082048851.png"></p><p>创建用户：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs she">addauth digest debug:12345<br></code></pre></td></tr></table></figure><h5 id="4-digest-授权模式"><a href="#4-digest-授权模式" class="headerlink" title="4. digest 授权模式"></a>4. digest 授权模式</h5><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302082112881.png"></p><p>加密：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs she">echo -n user:12345 | openssl dgst -binary -sha1 | openssl base64<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202302082114350.png"></p><p>auth 与 digest 的区别就是，前者使用明文密码进行登录，后者使用密文密码进行登录。</p><h5 id="5-IP-授权模式"><a href="#5-IP-授权模式" class="headerlink" title="5. IP 授权模式"></a>5. IP 授权模式</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs shell">setAcl /node-ip ip:192.168.109.128:cdwra<br>create /node-ip  data  ip:192.168.109.128:cdwra<br></code></pre></td></tr></table></figure><p>多个指定 IP 可以通过逗号分隔， 如 setAcl /node-ip  ip:IP1:rw,ip:IP2:a</p><h5 id="6-Super-超级管理员模式"><a href="#6-Super-超级管理员模式" class="headerlink" title="6. Super 超级管理员模式"></a>6. Super 超级管理员模式</h5><p>这是一种特殊的 Digest 模式， 在 Super 模式下超级管理员用户可以对 Zookeeper 上的节点进行任何的操作。</p><p>需要在启动脚本上通过添加 JVM 参数开启：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs she">DigestAuthenticationProvider中定义<br>-Dzookeeper.DigestAuthenticationProvider.superDigest=admin:&lt;base64encoded(SHA1(123456))<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Zookeeper</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Zookeeper</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis-Plus——逻辑删除&amp;自动填充&amp;SQL分析&amp;数据安全保护&amp;乐观锁&amp;代码生成器</title>
    <link href="/2022/12/28/Mybatis-Plus%E2%80%94%E2%80%94%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4-SQL%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BF%9D%E6%8A%A4-%E4%B9%90%E8%A7%82%E9%94%81-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/"/>
    <url>/2022/12/28/Mybatis-Plus%E2%80%94%E2%80%94%E9%80%BB%E8%BE%91%E5%88%A0%E9%99%A4-SQL%E5%88%86%E6%9E%90-%E6%95%B0%E6%8D%AE%E5%AE%89%E5%85%A8%E4%BF%9D%E6%8A%A4-%E4%B9%90%E8%A7%82%E9%94%81-%E4%BB%A3%E7%A0%81%E7%94%9F%E6%88%90%E5%99%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1-逻辑删除"><a href="#1-逻辑删除" class="headerlink" title="1. 逻辑删除"></a>1. 逻辑删除</h3><p>逻辑删除： 从逻辑层面控制删除，通常会在表里添加一个逻辑删除的字段比如 enabled 、is_delete ，数据默认是有效的（值为1），当用户删除时将数据修改为 0， 在查询的时候就只查 where enabled=1 的数据。</p><p>1、局部单表逻辑删除，需要在对应的 pojo 类加入对应的逻辑删除标识字段。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * value:有效值 delval：无效值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@TableLogic(value = &quot;1&quot;,delval = &quot;0&quot;)</span><br>    <span class="hljs-keyword">private</span> Integer enabled;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testLogicDelete</span><span class="hljs-params">()</span> </span>&#123;<br>    userService.removeById(<span class="hljs-number">8</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212282227972.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testQuery</span><span class="hljs-params">()</span> </span>&#123;<br>    userService.list();<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212282229026.png"></p><p>2、全局配置</p><p>application.yml：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">mybatis-plus</span>:<span class="hljs-string"></span><br>  <span class="hljs-meta">global-config</span>:<span class="hljs-string"></span><br>    <span class="hljs-meta">db-config</span>:<span class="hljs-string"></span><br>      <span class="hljs-meta">logic-delete-field</span>: <span class="hljs-string">enabled # 逻辑删除字段</span><br>      <span class="hljs-meta">logic-not-delete-value</span>: <span class="hljs-string">1   # 有效值</span><br>      <span class="hljs-meta">logic-delete-value</span>: <span class="hljs-string">0       # 无效值</span><br></code></pre></td></tr></table></figure><h3 id="2-自动填充"><a href="#2-自动填充" class="headerlink" title="2. 自动填充"></a>2. 自动填充</h3><p>数据库表必备三字段：id,gmt_create,gmt_modified。</p><p>1、注解填充字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT)</span><br>    <span class="hljs-keyword">private</span> Date gmtCreate;<br>    <span class="hljs-meta">@TableField(fill = FieldFill.INSERT_UPDATE)</span><br>    <span class="hljs-keyword">private</span> Date gmtModified;<br>    <br>...<br>&#125;<br></code></pre></td></tr></table></figure><p>2、自定义填充实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyMetaObjectHandler</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MetaObjectHandler</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">insertFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;<br>        <span class="hljs-comment">// 插入时填充创建时间和修改时间</span><br>        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">&quot;gmtCreate&quot;</span>,<span class="hljs-keyword">new</span> Date(),metaObject);<br>        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">&quot;gmtModified&quot;</span>,<span class="hljs-keyword">new</span> Date(),metaObject);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">updateFill</span><span class="hljs-params">(MetaObject metaObject)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.setFieldValByName(<span class="hljs-string">&quot;gmtModified&quot;</span>,<span class="hljs-keyword">new</span> Date(),metaObject);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【注】需要注入容器中。</p><p>3、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;aaa@bb.com&quot;</span>);<br>    userService.save(user);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212282307524.png"></p><h3 id="3-SQL分析打印"><a href="#3-SQL分析打印" class="headerlink" title="3. SQL分析打印"></a>3. SQL分析打印</h3><p>1、添加依赖</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xm">&lt;dependency&gt;<br>    &lt;groupId&gt;p6spy&lt;/groupId&gt;<br>    &lt;artifactId&gt;p6spy&lt;/artifactId&gt;<br>    &lt;version&gt;3.9.1&lt;/version&gt;<br>&lt;/dependency&gt;<br></code></pre></td></tr></table></figure><p>2、application.yml 配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">datasource</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">url</span>: <span class="hljs-string">jdbc:p6spy:mysql://localhost:3306/debuggingworld</span><br>    <span class="hljs-meta">driver-class-name</span>: <span class="hljs-string">com.p6spy.engine.spy.P6SpyDriver</span><br>    <span class="hljs-attr">……</span><br></code></pre></td></tr></table></figure><p>3、spy.properties 配置</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-comment">#3.2.1以上使用</span><br><span class="hljs-attr">modulelist</span>=<span class="hljs-string">com.baomidou.mybatisplus.extension.p6spy.MybatisPlusLogFactory,com.p6spy.engine.outage.P6OutageFactory</span><br><span class="hljs-comment">#3.2.1以下使用或者不配置</span><br><span class="hljs-comment">#modulelist=com.p6spy.engine.logging.P6LogFactory,com.p6spy.engine.outage.P6OutageFactory</span><br><span class="hljs-comment"># 自定义日志打印</span><br><span class="hljs-attr">logMessageFormat</span>=<span class="hljs-string">com.baomidou.mybatisplus.extension.p6spy.P6SpyLogger</span><br><span class="hljs-comment">#日志输出到控制台</span><br><span class="hljs-attr">appender</span>=<span class="hljs-string">com.baomidou.mybatisplus.extension.p6spy.StdoutLogger</span><br><span class="hljs-comment"># 使用日志系统记录 sql</span><br><span class="hljs-comment">#appender=com.p6spy.engine.spy.appender.Slf4JLogger</span><br><span class="hljs-comment"># 设置 p6spy driver 代理</span><br><span class="hljs-attr">deregisterdrivers</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 取消JDBC URL前缀</span><br><span class="hljs-attr">useprefix</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 配置记录 Log 例外,可去掉的结果集有error,info,batch,debug,statement,commit,rollback,result,resultset.</span><br><span class="hljs-attr">excludecategories</span>=<span class="hljs-string">info,debug,result,commit,resultset</span><br><span class="hljs-comment"># 日期格式</span><br><span class="hljs-attr">dateformat</span>=<span class="hljs-string">yyyy-MM-dd HH:mm:ss</span><br><span class="hljs-comment"># 实际驱动可多个</span><br><span class="hljs-comment">#driverlist=org.h2.Driver</span><br><span class="hljs-comment"># 是否开启慢SQL记录</span><br><span class="hljs-attr">outagedetection</span>=<span class="hljs-string">true</span><br><span class="hljs-comment"># 慢SQL记录标准 2 秒</span><br><span class="hljs-attr">outagedetectioninterval</span>=<span class="hljs-string">2</span><br></code></pre></td></tr></table></figure><p>4、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMyBatisPlus</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tesQueryWrapper</span><span class="hljs-params">()</span> </span>&#123;<br><br>        QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();<br>        queryWrapper.lambda()<br>                .select(User::getName, User::getAge)<br>                .eq(User::getAge, <span class="hljs-number">18</span>);<br>        List&lt;User&gt; users = userService.list(queryWrapper);<br>        System.out.println(users);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212292232310.png"></p><h3 id="4-数据安全保护"><a href="#4-数据安全保护" class="headerlink" title="4. 数据安全保护"></a>4. 数据安全保护</h3><p>1、密钥加密</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 生成 16 位随机 AES 密钥</span><br>    String randomKey = AES.generateRandomKey();<br>    System.out.println(randomKey);<br>    <span class="hljs-comment">// 随机密钥加密</span><br>   String url = AES.encrypt(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/debuggingworld&quot;</span>, randomKey);<br>   String user = AES.encrypt(<span class="hljs-string">&quot;root&quot;</span>, randomKey);<br>   String pwd = AES.encrypt(<span class="hljs-string">&quot;mysql&quot;</span>, randomKey);<br>    System.out.println(url);<br>    System.out.println(user);<br>    System.out.println(pwd);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202301052258686.png"></p><p>2、配置文件</p><p>application-prod.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">mpw:wRoBmoVgn2n+b8ZxtSaJKQ==</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">mpw:rpKT+pzjYSdArnMgN8M2Qg==</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">mpw:p9nNvk6dwEvbvoh7qeKXUZAOMOMdzCISl1SQW9FJFK2ahVSBBjHYpDZD15YeofFo</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br></code></pre></td></tr></table></figure><p>application-dev.yml：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">datasource:</span><br>    <span class="hljs-attr">username:</span> <span class="hljs-string">root</span><br>    <span class="hljs-attr">password:</span> <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">url:</span> <span class="hljs-string">jdbc:mysql://localhost:3306/debuggingworld?serverTimezone=Asia/Shanghai</span><br>    <span class="hljs-attr">driver-class-name:</span> <span class="hljs-string">com.mysql.jdbc.Driver</span><br>    <span class="hljs-attr">type:</span> <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br></code></pre></td></tr></table></figure><p>application.yml:</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs yaml"><span class="hljs-attr">spring:</span><br>  <span class="hljs-attr">profiles:</span><br>    <span class="hljs-attr">active:</span> <span class="hljs-string">dev</span><br></code></pre></td></tr></table></figure><p>生产环境执行：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202301052338408.png"></p><h3 id="5-乐观锁"><a href="#5-乐观锁" class="headerlink" title="5. 乐观锁"></a>5. 乐观锁</h3><p>乐观锁实现方式：</p><ul><li>取出记录时，获取当前 version</li><li>更新时，带上这个 version</li><li>执行更新时， set version = newVersion where version = oldVersion</li><li>如果 version 不对，就更新失败</li></ul><p>1、配置插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title">mybatisPlusInterceptor</span><span class="hljs-params">()</span> </span>&#123;<br>    MybatisPlusInterceptor mybatisPlusInterceptor = <span class="hljs-keyword">new</span> MybatisPlusInterceptor();<br>    mybatisPlusInterceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> OptimisticLockerInnerInterceptor());<br>    <span class="hljs-keyword">return</span> mybatisPlusInterceptor;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、在实体类的字段上加上<code>@Version</code>注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Version</span><br><span class="hljs-keyword">private</span> Integer version;<br></code></pre></td></tr></table></figure><p>3、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tesCAS</span><span class="hljs-params">()</span> </span>&#123;<br>    User user1 = userService.getById(<span class="hljs-number">1</span>);<br>    User user2 = userService.getById(<span class="hljs-number">1</span>);<br>    user1.setAge(<span class="hljs-number">20</span>);<br>    user2.setAge(<span class="hljs-number">22</span>);<br><br>    <span class="hljs-comment">// 更新成功</span><br>    System.out.println(userService.updateById(user1));<br>    <span class="hljs-comment">// 更新失败</span><br>    System.out.println(userService.updateById(user2));<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202301071615201.png"></p><h3 id="6-代码生成器"><a href="#6-代码生成器" class="headerlink" title="6. 代码生成器"></a>6. 代码生成器</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.debuggingworld;<br><br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.exceptions.MybatisPlusException;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.toolkit.StringPool;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.core.toolkit.StringUtils;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.generator.AutoGenerator;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.generator.InjectionConfig;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.generator.config.*;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.generator.config.po.LikeTable;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.generator.config.po.TableInfo;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.DateType;<br><span class="hljs-keyword">import</span> com.baomidou.mybatisplus.generator.config.rules.NamingStrategy;<br><br><span class="hljs-keyword">import</span> java.util.ArrayList;<br><span class="hljs-keyword">import</span> java.util.List;<br><span class="hljs-keyword">import</span> java.util.Scanner;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneratorApp</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 读取控制台内容</span><br><span class="hljs-comment">     * &lt;/p&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> String <span class="hljs-title">scanner</span><span class="hljs-params">(String tip)</span> </span>&#123;<br>        Scanner scanner = <span class="hljs-keyword">new</span> Scanner(System.in);<br>        StringBuilder help = <span class="hljs-keyword">new</span> StringBuilder();<br>        help.append(<span class="hljs-string">&quot;请输入&quot;</span> + tip + <span class="hljs-string">&quot;：&quot;</span>);<br>        System.out.println(help.toString());<br>        <span class="hljs-comment">// 判断用户是否输入</span><br>        <span class="hljs-keyword">if</span> (scanner.hasNext()) &#123;<br>            <span class="hljs-comment">// 拿到输入内容</span><br>            String ipt = scanner.next();<br>            <span class="hljs-keyword">if</span> (StringUtils.isNotBlank(ipt)) &#123;<br>                <span class="hljs-keyword">return</span> ipt;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> MybatisPlusException(<span class="hljs-string">&quot;请输入正确的&quot;</span> + tip + <span class="hljs-string">&quot;！&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>        <span class="hljs-comment">// pms</span><br>        String moduleName = scanner(<span class="hljs-string">&quot;模块名&quot;</span>);<br>        String tableName = scanner(<span class="hljs-string">&quot;表名（多个用，号分隔，或者按前缀（pms*））&quot;</span>);<br>        String prefixName = scanner(<span class="hljs-string">&quot;需要替换的表前缀&quot;</span>);<br><br><br>        <span class="hljs-comment">// 代码生成器</span><br>        AutoGenerator mpg = <span class="hljs-keyword">new</span> AutoGenerator();<br><br>        <span class="hljs-comment">// 全局配置</span><br>        GlobalConfig gc = <span class="hljs-keyword">new</span> GlobalConfig();<br>        <span class="hljs-comment">// 获得当前项目的路径</span><br>        String projectPath = System.getProperty(<span class="hljs-string">&quot;user.dir&quot;</span>)+<span class="hljs-string">&quot;/generator&quot;</span>;<br>        <span class="hljs-comment">// 设置生成路径</span><br>        gc.setOutputDir(projectPath + <span class="hljs-string">&quot;/src/main/java&quot;</span>);<br>        <span class="hljs-comment">// 作者</span><br>        gc.setAuthor(<span class="hljs-string">&quot;debuggingWorld&quot;</span>);<br>        <span class="hljs-comment">// 代码生成是不是要打开所在文件夹</span><br>        gc.setOpen(<span class="hljs-keyword">false</span>);<br>        <span class="hljs-comment">// 生成Swagger2注解</span><br>        gc.setSwagger2(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">// 会在mapper.xml 生成一个基础的&lt;ResultMap&gt; 映射所有的字段</span><br>        gc.setBaseResultMap(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">// 同文件生成覆盖</span><br>        gc.setFileOverride(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">//gc.setDateType(DateType.ONLY_DATE)</span><br>        <span class="hljs-comment">// 实体名：直接用表名  %s=表名</span><br>        gc.setEntityName(<span class="hljs-string">&quot;%s&quot;</span>);<br>        <span class="hljs-comment">// mapper接口名</span><br>        gc.setMapperName(<span class="hljs-string">&quot;%sMapper&quot;</span>);<br>        <span class="hljs-comment">// mapper.xml 文件名</span><br>        gc.setXmlName(<span class="hljs-string">&quot;%sMapper&quot;</span>);<br>        <span class="hljs-comment">// 业务逻辑类接口名</span><br>        gc.setServiceName(<span class="hljs-string">&quot;%sService&quot;</span>);<br>        <span class="hljs-comment">// 业务逻辑类实现类名</span><br>        gc.setServiceName(<span class="hljs-string">&quot;%sImplService&quot;</span>);<br>        <span class="hljs-comment">// 将全局配置设置到AutoGenerator</span><br>        mpg.setGlobalConfig(gc);<br><br><br><br>        <span class="hljs-comment">// 数据源配置</span><br>        DataSourceConfig dsc = <span class="hljs-keyword">new</span> DataSourceConfig();<br>        dsc.setUrl(<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/debuggingworld?characterEncoding=utf8&amp;useSSL=false&amp;serverTimezone=UTC&amp;&quot;</span>);<br>        dsc.setDriverName(<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>);<br>        dsc.setUsername(<span class="hljs-string">&quot;root&quot;</span>);<br>        dsc.setPassword(<span class="hljs-string">&quot;mysql&quot;</span>);<br>        mpg.setDataSource(dsc);<br><br>        <span class="hljs-comment">// 包配置</span><br>        PackageConfig pc = <span class="hljs-keyword">new</span> PackageConfig();<br>        <span class="hljs-comment">//  模块名</span><br>        pc.setModuleName(moduleName);<br>        <span class="hljs-comment">// 包名</span><br>        pc.setParent(<span class="hljs-string">&quot;com.debuggingworld&quot;</span>);<br>        <span class="hljs-comment">// 完整的包名： com.debuggingworld.pms</span><br>        mpg.setPackageInfo(pc);<br><br><br><br>        <span class="hljs-comment">// 自定义配置</span><br>        InjectionConfig cfg = <span class="hljs-keyword">new</span> InjectionConfig() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMap</span><span class="hljs-params">()</span> </span>&#123;<br>                <span class="hljs-comment">// to do nothing</span><br>            &#125;<br>        &#125;;<br><br>        <span class="hljs-comment">// 如果模板引擎是 velocity</span><br>        String templatePath = <span class="hljs-string">&quot;/templates/mapper.xml.vm&quot;</span>;<br>        <span class="hljs-comment">// 自定义输出配置</span><br>        List&lt;FileOutConfig&gt; focList = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>        <span class="hljs-comment">// 自定义配置会被优先输出</span><br>        focList.add(<span class="hljs-keyword">new</span> FileOutConfig(templatePath) &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">outputFile</span><span class="hljs-params">(TableInfo tableInfo)</span> </span>&#123;<br>                <span class="hljs-comment">// 自定义输出文件名 ， 如果你 Entity 设置了前后缀、此处注意 xml 的名称会跟着发生变化！！</span><br>                <span class="hljs-keyword">return</span> projectPath + <span class="hljs-string">&quot;/src/main/resources/mapper/&quot;</span> + pc.getModuleName()<br>                        + <span class="hljs-string">&quot;/&quot;</span> + tableInfo.getEntityName() + <span class="hljs-string">&quot;Mapper&quot;</span> + StringPool.DOT_XML;<br>            &#125;<br>        &#125;);<br><br>        cfg.setFileOutConfigList(focList);<br>        mpg.setCfg(cfg);<br><br>        <span class="hljs-comment">// 配置模板</span><br>        TemplateConfig templateConfig = <span class="hljs-keyword">new</span> TemplateConfig();<br><br>        <span class="hljs-comment">// 把已有的xml生成置空</span><br>        templateConfig.setXml(<span class="hljs-keyword">null</span>);<br>        mpg.setTemplate(templateConfig);<br><br>        <span class="hljs-comment">// 策略配置</span><br>        StrategyConfig strategy = <span class="hljs-keyword">new</span> StrategyConfig();<br>        <span class="hljs-comment">// 表名的生成策略：下划线转驼峰 pms_product -- PmsProduct</span><br>        strategy.setNaming(NamingStrategy.underline_to_camel);<br>        <span class="hljs-comment">// 列名的生成策略：下划线转驼峰 last_name -- lastName</span><br>        strategy.setColumnNaming(NamingStrategy.underline_to_camel);<br>        <span class="hljs-comment">//strategy.setSuperEntityClass(&quot;你自己的父类实体,没有就不用设置!&quot;);</span><br>        <span class="hljs-comment">//strategy.setEntityLombokModel(true);</span><br>        <span class="hljs-comment">// 在controller类上是否生成@RestController</span><br>        strategy.setRestControllerStyle(<span class="hljs-keyword">true</span>);<br>        <span class="hljs-comment">// 公共父类</span><br>        <span class="hljs-comment">//strategy.setSuperControllerClass(&quot;你自己的父类控制器,没有就不用设置!&quot;);</span><br><br>        <span class="hljs-keyword">if</span>(tableName.indexOf(<span class="hljs-string">&#x27;*&#x27;</span>)&gt;<span class="hljs-number">0</span>)&#123;<br>            <span class="hljs-comment">// 按前缀生成表</span><br>            strategy.setLikeTable(<span class="hljs-keyword">new</span> LikeTable(tableName.replace(<span class="hljs-string">&#x27;*&#x27;</span>,<span class="hljs-string">&#x27;_&#x27;</span>)));<br>        &#125;<br>        <span class="hljs-keyword">else</span>&#123;<br>            <span class="hljs-comment">// 要生成的表名 多个用逗号分隔</span><br>             strategy.setInclude(tableName);<br>        &#125;<br>        <span class="hljs-comment">// 设置表替换前缀</span><br>        strategy.setTablePrefix(prefixName);<br>        <span class="hljs-comment">// 驼峰转连字符 比如 pms_product --&gt; controller @RequestMapping(&quot;/pms/Product&quot;)</span><br>        <span class="hljs-comment">//strategy.setControllerMappingHyphenStyle(true);</span><br>        mpg.setStrategy(strategy);<br><br>        <span class="hljs-comment">// 进行生成</span><br>        mpg.execute();<br><br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis-Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis-Plus——CRUD&amp;分页&amp;条件构造器&amp;ID策略</title>
    <link href="/2022/12/14/Mybatis-Plus%E2%80%94%E2%80%94CRUD-%E5%88%86%E9%A1%B5-%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8-ID%E7%AD%96%E7%95%A5/"/>
    <url>/2022/12/14/Mybatis-Plus%E2%80%94%E2%80%94CRUD-%E5%88%86%E9%A1%B5-%E6%9D%A1%E4%BB%B6%E6%9E%84%E9%80%A0%E5%99%A8-ID%E7%AD%96%E7%95%A5/</url>
    
    <content type="html"><![CDATA[<p><strong><a href="https://baomidou.com/">官网</a></strong></p><h3 id="1-特性"><a href="#1-特性" class="headerlink" title="1. 特性"></a>1. 特性</h3><ul><li><strong>无侵入</strong>：只做增强不做改变，引入它不会对现有工程产生影响，如丝般顺滑</li><li><strong>损耗小</strong>：启动即会自动注入基本 CURD，性能基本无损耗，直接面向对象操作</li><li><strong>强大的 CRUD 操作</strong>：内置通用 Mapper、通用 Service，仅仅通过少量配置即可实现单表大部分 CRUD 操作，更有强大的条件构造器，满足各类使用需求</li><li><strong>支持 Lambda 形式调用</strong>：通过 Lambda 表达式，方便的编写各类查询条件，无需再担心字段写错</li><li><strong>支持主键自动生成</strong>：支持多达 4 种主键策略（内含分布式唯一 ID 生成器 - Sequence），可自由配置，完美解决主键问题</li><li><strong>支持 ActiveRecord 模式</strong>：支持 ActiveRecord 形式调用，实体类只需继承 Model 类即可进行强大的 CRUD 操作</li><li><strong>支持自定义全局通用操作</strong>：支持全局通用方法注入（ Write once, use anywhere ）</li><li><strong>内置代码生成器</strong>：采用代码或者 Maven 插件可快速生成 Mapper 、 Model 、 Service 、 Controller 层代码，支持模板引擎，更有超多自定义配置等您来使用</li><li><strong>内置分页插件</strong>：基于 MyBatis 物理分页，开发者无需关心具体操作，配置好插件之后，写分页等同于普通 List 查询</li><li><strong>分页插件支持多种数据库</strong>：支持 MySQL、MariaDB、Oracle、DB2、H2、HSQL、SQLite、Postgre、SQLServer 等多种数据库</li><li><strong>内置性能分析插件</strong>：可输出 SQL 语句以及其执行时间，建议开发测试时启用该功能，能快速揪出慢查询</li><li><strong>内置全局拦截插件</strong>：提供全表 delete 、 update 操作智能分析阻断，也可自定义拦截规则，预防误操作</li></ul><h3 id="2-Mapper-CRUD"><a href="#2-Mapper-CRUD" class="headerlink" title="2. Mapper  CRUD"></a>2. Mapper  CRUD</h3><p>1、 添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>runtime<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.baomidou<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-plus-boot-starter<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.24<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework.boot<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-boot-starter-test<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p>ps：切记不可再在 pom.xml 文件中引入mybatis 与 mybatis-spring 的 maven 依赖</p><p>2、配置文件</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-attr">spring</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">datasource</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">username</span>: <span class="hljs-string">root</span><br>    <span class="hljs-attr">password</span>: <span class="hljs-string">mysql</span><br>    <span class="hljs-attr">url</span>: <span class="hljs-string">jdbc:mysql://localhost:3306/debuggingworld</span><br>    <span class="hljs-meta">driver-class-name</span>: <span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br>    <span class="hljs-attr">type</span>: <span class="hljs-string">com.alibaba.druid.pool.DruidDataSource</span><br>  <span class="hljs-attr">sql</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">init</span>:<span class="hljs-string"></span><br>      <span class="hljs-attr">mode</span>: <span class="hljs-string">never</span><br>      <span class="hljs-meta">schema-locations</span>: <span class="hljs-string">classpath:sql/schema.sql</span><br><span class="hljs-attr">logging</span>:<span class="hljs-string"></span><br>  <span class="hljs-attr">level</span>:<span class="hljs-string"></span><br>    <span class="hljs-attr">root</span>: <span class="hljs-string">info</span><br>    <span class="hljs-meta">com.debugWorld.mapper</span>: <span class="hljs-string">debug</span><br></code></pre></td></tr></table></figure><p>3、Mapper</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMapper</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、启动类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootApplication</span><br><span class="hljs-meta">@MapperScan(&quot;com.debugWorld.mapper&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>5、实体类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-meta">@TableId(type = IdType.AUTO)</span><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure><p>ps：默认开启蛇形命名转驼峰命名。</p><p>6、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMyBatisPlus</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testSelect</span><span class="hljs-params">()</span> </span>&#123;<br>        User user = userMapper.selectById(<span class="hljs-number">1</span>);<br>        System.out.println(user);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAdd</span><span class="hljs-params">()</span> </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-keyword">null</span>, <span class="hljs-string">&quot;debugWorld&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;mail&quot;</span>);<br>        userMapper.insert(user);<br>        <span class="hljs-comment">// 主键自动回填</span><br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>​    </p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212251210498.png"></p><table><thead><tr><th></th><th>描述</th><th>使用位置</th><th>备注</th></tr></thead><tbody><tr><td>@TableName</td><td>表名注解，标识实体类对应的表</td><td>实体类</td><td>默认表名和实体类名一致</td></tr><tr><td>@TableId</td><td>主键注解</td><td>实体类主键字段</td><td></td></tr><tr><td>@TableField</td><td>字段注解（非主键）</td><td>实体类字段</td><td>表字段名和实体类字段名不一致时使用<br />@TableField(exist = false) 表示非数据库字段</td></tr><tr><td>@Version</td><td>乐观锁标记注解</td><td></td><td></td></tr><tr><td>@KeySequence</td><td>序列主键策略</td><td></td><td></td></tr></tbody></table><h3 id="3-Service-CRUD"><a href="#3-Service-CRUD" class="headerlink" title="3. Service CRUD"></a>3. Service CRUD</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">IService</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Service</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserServiceImpl</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">ServiceImpl</span>&lt;<span class="hljs-title">UserMapper</span>, <span class="hljs-title">User</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">UserService</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMyBatisPlus</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">query</span><span class="hljs-params">()</span> </span>&#123;<br>        User user = userService.getById(<span class="hljs-number">6</span>);<br>        System.out.println(user);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testAdd</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 先根据主键查询，如果存在就更新，不存在则插入。</span><br>        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-number">6</span>, <span class="hljs-string">&quot;debugWorld&quot;</span>, <span class="hljs-number">18</span>, <span class="hljs-string">&quot;@mail&quot;</span>);<br>        userService.saveOrUpdate(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212251250390.png" style="zoom: 67%;" /><h3 id="4-分页"><a href="#4-分页" class="headerlink" title="4. 分页"></a>4. 分页</h3><p>1、添加插件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> MybatisPlusInterceptor <span class="hljs-title">mybatisPlusInterceptor</span><span class="hljs-params">()</span> </span>&#123;<br>    MybatisPlusInterceptor interceptor = <span class="hljs-keyword">new</span> MybatisPlusInterceptor();<br>    interceptor.addInnerInterceptor(<span class="hljs-keyword">new</span> PaginationInnerInterceptor(DbType.MYSQL));<br>    <span class="hljs-keyword">return</span> interceptor;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMyBatisPlus</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPage</span><span class="hljs-params">()</span> </span>&#123;<br>        IPage&lt;User&gt; iPage = <span class="hljs-keyword">new</span> Page&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">5</span>);<br>        IPage&lt;User&gt; page = userService.page(iPage);<br>        System.out.println(page.getRecords());<br>        System.out.println(page.getTotal());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、自定义方法实现分页</p><p>mapper 接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseMapper</span>&lt;<span class="hljs-title">User</span>&gt; </span>&#123;<br>    <span class="hljs-function">IPage&lt;User&gt; <span class="hljs-title">selectUserByAge</span><span class="hljs-params">(IPage page,<span class="hljs-keyword">int</span> age)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>mapper xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.debugWorld.mapper.UserMapper&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserByAge&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.debugWorld.pojo.User&quot;</span>&gt;</span><br>        select * FROM user where age = #&#123;age&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMyBatisPlus</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserMapper userMapper;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testPage</span><span class="hljs-params">()</span> </span>&#123;<br>        IPage&lt;User&gt; iPage = <span class="hljs-keyword">new</span> Page&lt;&gt;(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>);<br>        IPage&lt;User&gt; page = userMapper.selectUserByAge(iPage,<span class="hljs-number">18</span>);<br>        System.out.println(page.getRecords());<br>        System.out.println(page.getTotal());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212272153886.png"></p><p>【注】mybatisPlus 默认mapper xml 路径：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212272147742.png"></p><p>自定义路径：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">mybatis-plus</span>:<span class="hljs-string"></span><br>  <span class="hljs-meta">mapper-locations</span>: <span class="hljs-string">classpath:/com/debugWorld/mapper/*.xml</span><br></code></pre></td></tr></table></figure><h3 id="5-条件构造器"><a href="#5-条件构造器" class="headerlink" title="5. 条件构造器"></a>5. 条件构造器</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212272203875.png"></p><p>AbstractWrapper ： 用于查询条件封装，生成 sql 的 where 条件,QueryWrapper(LambdaQueryWrapper) 和 UpdateWrapper(LambdaUpdateWrapper) 的父类用于生成 sql 的 where 条件, entity 属性也用于生成 sql 的 where 条件。</p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212272224290.png" style="zoom:80%;" /><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SpringBootTest</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMyBatisPlus</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-keyword">private</span> UserService userService;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tesQueryWrapper</span><span class="hljs-params">()</span> </span>&#123;<br>        QueryWrapper&lt;User&gt; queryWrapper = <span class="hljs-keyword">new</span> QueryWrapper&lt;&gt;();<br>        <span class="hljs-comment">/*queryWrapper</span><br><span class="hljs-comment">                .select(&quot;name&quot;, &quot;age&quot;)</span><br><span class="hljs-comment">                .eq(&quot;age&quot;, 18);*/</span><br>        <span class="hljs-comment">// lambda 方式</span><br>        queryWrapper.lambda()<br>                .select(User::getName, User::getAge)<br>                .eq(User::getAge, <span class="hljs-number">18</span>);<br>        List&lt;User&gt; users = userService.list(queryWrapper);<br>        System.out.println(users);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tesUpdateWrapper</span><span class="hljs-params">()</span> </span>&#123;<br>        UpdateWrapper&lt;User&gt; updateWrapper = <span class="hljs-keyword">new</span> UpdateWrapper&lt;&gt;();<br>        <span class="hljs-comment">/*updateWrapper</span><br><span class="hljs-comment">                //.setSql(&quot;name = &#x27;debuggingWorld&#x27;&quot;)</span><br><span class="hljs-comment">                .set(&quot;name&quot;, &quot;debuggingWorld&quot;)</span><br><span class="hljs-comment">                .eq(&quot;id&quot;, 1);*/</span><br>        updateWrapper.lambda()<br>                .set(User::getName, <span class="hljs-string">&quot;debuggingWorld&quot;</span>)<br>                .eq(User::getId, <span class="hljs-number">1</span>);<br>        userService.update(updateWrapper);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-全局ID生成策略"><a href="#6-全局ID生成策略" class="headerlink" title="6. 全局ID生成策略"></a>6. 全局ID生成策略</h3><p>在全局配置文件中，就不需要再每个 Pojo 主键上配置了。</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">mybatis-plus</span>:<span class="hljs-string"></span><br>  <span class="hljs-meta">global-config</span>:<span class="hljs-string"></span><br>    <span class="hljs-meta">db-config</span>:<span class="hljs-string"></span><br>      <span class="hljs-meta">id-type</span>: <span class="hljs-string">auto</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@NoArgsConstructor</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-comment">//@TableId(type = IdType.AUTO)</span><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String name;<br>    <span class="hljs-keyword">private</span> Integer age;<br>    <span class="hljs-keyword">private</span> String email;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis-Plus</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Lombok</title>
    <link href="/2022/12/12/Lombok/"/>
    <url>/2022/12/12/Lombok/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Getter-Setter"><a href="#1-Getter-Setter" class="headerlink" title="1. @Getter/@Setter"></a><strong>1. @Getter/@Setter</strong></h3><p>自动生成 getter/setter</p><p>​    <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212122044356.png"></p><h3 id="2-ToString"><a href="#2-ToString" class="headerlink" title="2.  @ToString"></a>2.  @ToString</h3><p>自动重写 toString() 方法。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212122045007.png"></p><h3 id="3-EqualsAndHashCode"><a href="#3-EqualsAndHashCode" class="headerlink" title="3. @EqualsAndHashCode"></a>3. @EqualsAndHashCode</h3><p>自动生成 equals(Object other) 和 hashcode() 方法，包括所有非静态变量和非 transient 的变量。</p><p>如果某些变量不想要加进判断，可以透过 exclude 排除，也可以使用 of 指定某些字段。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212122046405.png"></p><h3 id="4-NoArgsConstructor-AllArgsConstructor-RequiredArgsConstructor"><a href="#4-NoArgsConstructor-AllArgsConstructor-RequiredArgsConstructor" class="headerlink" title="4. @NoArgsConstructor, @AllArgsConstructor, @RequiredArgsConstructor"></a>4. @NoArgsConstructor, @AllArgsConstructor, @RequiredArgsConstructor</h3><p>这三个很像，都是在自动生成该类的构造器，差别只在生成的构造器的参数不一样而已<br>@NoArgsConstructor : 生成一个没有参数的构造器</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212122048025.png"></p><p>@AllArgsConstructor : 生成一个包含所有参数的构造器</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212122048011.png"></p><p>@RequiredArgsConstructor : 生成一个包含 “特定参数” 的构造器，特定参数指的是那些有加上 final 修饰词的变量们。</p><p>如果没有用 final 修饰的变量，那就会生成一个没有参数的构造器。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212122049024.png"></p><h3 id="5-Data"><a href="#5-Data" class="headerlink" title="5. @Data"></a>5. @Data</h3><p>整合包，只要加了 @Data 这个注解，等于同时加了以下注解<br>@Getter/@Setter<br>@ToString<br>@EqualsAndHashCode<br>@RequiredArgsConstructor</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212122051200.png"></p><h3 id="6-Value"><a href="#6-Value" class="headerlink" title="6. @Value"></a>6. @Value</h3><p>也是整合包，但是他会把所有的变量都设成 final 的，其他的就跟 @Data 一样，等于同时加了以下注解<br>@Getter (注意没有setter)<br>@ToString<br>@EqualsAndHashCode<br>@RequiredArgsConstructor</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212122052401.png"></p><h3 id="7-Builder"><a href="#7-Builder" class="headerlink" title="7. @Builder"></a>7. @Builder</h3><p>生成建造器。</p><h3 id="8-Singular"><a href="#8-Singular" class="headerlink" title="8. @Singular"></a>8. @Singular</h3><p>在建造器中向集合中添加单个元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Builder</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String  name;<br>    <span class="hljs-meta">@Singular(&quot;addHobby&quot;)</span><br>    <span class="hljs-keyword">private</span> List&lt;String&gt; hobby;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        User user = User.builder().id(<span class="hljs-number">1</span>).name(<span class="hljs-string">&quot;debuggingWorld&quot;</span>).hobby(Arrays.asList(<span class="hljs-string">&quot;aa&quot;</span>,<span class="hljs-string">&quot;bb&quot;</span>)).addHobby(<span class="hljs-string">&quot;cc&quot;</span>).addHobby(<span class="hljs-string">&quot;dd&quot;</span>).build();<br>        <span class="hljs-comment">// User(id=1, name=debuggingWorld, hobby=[aa, bb, cc, dd])</span><br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-Slf4j"><a href="#8-Slf4j" class="headerlink" title="8. @Slf4j"></a>8. @Slf4j</h3><p>自动生成该类的 log 静态常量。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212122154797.png"></p><h3 id="9-SneakyThrows"><a href="#9-SneakyThrows" class="headerlink" title="9. @SneakyThrows"></a>9. @SneakyThrows</h3><p>将异常抛向外层。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@SneakyThrows(UnsupportedEncodingException.class)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">utf8ToString</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(bytes, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@SneakyThrows</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Throwable();<br>&#125;<br></code></pre></td></tr></table></figure><p>编译后：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">utf8ToString</span><span class="hljs-params">(<span class="hljs-keyword">byte</span>[] bytes)</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String(bytes, <span class="hljs-string">&quot;UTF-8&quot;</span>);<br>    &#125; <span class="hljs-keyword">catch</span> (UnsupportedEncodingException var3) &#123;<br>        <span class="hljs-keyword">throw</span> var3;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Throwable();<br>    &#125; <span class="hljs-keyword">catch</span> (Throwable var2) &#123;<br>        <span class="hljs-keyword">throw</span> var2;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-Synchronized"><a href="#10-Synchronized" class="headerlink" title="10. @Synchronized"></a>10. @Synchronized</h3><p>将方法变为同步方法。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212132017723.png"></p><h3 id="11-Cleanup"><a href="#11-Cleanup" class="headerlink" title="11. @Cleanup"></a>11. @Cleanup</h3><p>自动关闭资源</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212132025300.png"></p><h3 id="12-Accessors-chain-true"><a href="#12-Accessors-chain-true" class="headerlink" title="12. @Accessors(chain = true)"></a>12. @Accessors(chain = true)</h3><p>链式设置属性。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-meta">@Accessors(chain = true)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String  name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        user.setId(<span class="hljs-number">1</span>).setName(<span class="hljs-string">&quot;debuggingWorld&quot;</span>);<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="13-FieldNameConstants"><a href="#13-FieldNameConstants" class="headerlink" title="13. @FieldNameConstants"></a>13. @FieldNameConstants</h3><p>获取属性字段名字面值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FieldNameConstants</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> Integer id;<br>    <span class="hljs-keyword">private</span> String  name;<br>    <span class="hljs-keyword">private</span> List&lt;String&gt; hobby;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-comment">// name</span><br>        System.out.println(Fields.name);<br>        <span class="hljs-comment">// hobby</span><br>        System.out.println(User.Fields.hobby);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Lombok</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SSM框架整合</title>
    <link href="/2022/12/09/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/"/>
    <url>/2022/12/09/SSM%E6%A1%86%E6%9E%B6%E6%95%B4%E5%90%88/</url>
    
    <content type="html"><![CDATA[<p>整合 SSM 框架内容：</p><ol><li><strong>SpringMVC</strong><ol><li>web.xml<ul><li>前端调度器 DispatcherServlet</li><li>编码过滤器 filter</li><li>支持 rest 的过滤器</li></ul></li><li>springmvc.xml<ul><li>扫描 controller 包</li><li>添加 &lt;annotation-driver&gt;</li><li>视图解析器</li><li>静态资源解析</li></ul></li><li>添加控制器类</li></ol></li><li><strong>Spring</strong><ol><li>web.xml<ul><li>监听器（在启动web容器时加载）</li></ul></li><li>spring.xml<ul><li>扫描所有除了controller包的其他包</li><li>声明式事</li></ul></li></ol></li><li><strong>MyBatis</strong><ol><li>和 spring 整合<ul><li> 将 sqlSessionFactory 配置为 spring 的 bean</li><li>数据源配置为 spring 的 bean</li><li>全局配置文件</li><li>所有 mapper 映射文件</li><li>将 mapper 接口的包交给 spring</li></ul></li><li>加入全局配置文件</li></ol></li></ol><h3 id="1-添加依赖"><a href="#1-添加依赖" class="headerlink" title="1.  添加依赖"></a>1.  添加依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.source</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.source</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">maven.compiler.target</span>&gt;</span>8<span class="hljs-tag">&lt;/<span class="hljs-name">maven.compiler.target</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">SPRING.VERSION</span>&gt;</span>5.3.21<span class="hljs-tag">&lt;/<span class="hljs-name">SPRING.VERSION</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--springmvc--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;SPRING.VERSION&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--spring--&gt;</span><br>    <span class="hljs-comment">&lt;!--事务--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-orm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;SPRING.VERSION&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aop<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;SPRING.VERSION&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;SPRING.VERSION&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--spring-mybatis 适配器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-spring<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.0.7<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--mybatis核心依赖--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--连接池--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.14<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--mysql 对应版本的连接器驱动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.3<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="2-web-xml"><a href="#2-web-xml" class="headerlink" title="2. web.xml"></a>2. web.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--‐配置 DispatcherServlet--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>debugSSM<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--关联 springmvc 的配置文件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--容器启动时加载 servlet--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--‐匹配servlet的请求，/标识匹配所有请求--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>debugSSM<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--‐/*和/都是拦截所有请求，/会拦截的请求不包含*.jsp,而/*的范围更大，还会拦截*.jsp这些请求--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--spring 基于web应用的启动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--全局参数：spring配置文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-core.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--编码过滤器filter--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--同时开启请求和响应的编码设置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>characterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>debugSSM<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--支持rest的过滤器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>hiddenHttpMethod<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.HiddenHttpMethodFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>hiddenHttpMethod<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>debugSSM<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-spring-mvc-xml"><a href="#3-spring-mvc-xml" class="headerlink" title="3. spring-mvc.xml"></a>3. spring-mvc.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mvc</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/mvc&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/mvc https://www.springframework.org/schema/mvc/spring-mvc.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--扫描controller包--&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;context:component-scan base-package=&quot;com.debuggingWorld.controller&quot;&gt;&lt;/context:component-scan&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.debuggingWorld&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 添加&lt;annotation-driver&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--视图解析器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewResolver&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--静态资源解析--&gt;</span><br>    <span class="hljs-comment">&lt;!-- &lt;mvc:resources mapping=&quot;&quot; location=&quot;&quot;&gt;&lt;/mvc:resources&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-spring-core-xml"><a href="#4-spring-core-xml" class="headerlink" title="4. spring-core.xml"></a>4. spring-core.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span> <span class="hljs-attr">xmlns:tx</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/tx&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:mybatis</span>=<span class="hljs-string">&quot;http://mybatis.org/schema/mybatis-spring&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd http://www.springframework.org/schema/tx http://www.springframework.org/schema/tx/spring-tx.xsd http://mybatis.org/schema/mybatis-spring http://mybatis.org/schema/mybatis-spring.xsd&quot;</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--扫描所有除了controller包的其他包--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.debuggingWorld&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Controller&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--引入外部属性资源文件--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:db.properties&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--创建Druid数据源--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.username&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.password&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.url&#125;&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.driverClassName&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--将mapper接口交给spring管理--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mybatis:scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--SqlSessionFactory--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.mybatis.spring.SqlSessionFactoryBean&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;sqlSessionFactory&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!-- 指定spring中的数据源 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;configLocation&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:mybatis-config.xml&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapperLocations&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;classpath:com/debuggingWorld/mapper/*.xml&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--声明式事--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--基于驱动--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:annotation-driven</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-mybatis-config-xml"><a href="#5-mybatis-config-xml" class="headerlink" title="5. mybatis-config.xml"></a>5. mybatis-config.xml</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--mybatis的设置选项  可以改变mybatis运行时行为--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="6-db-properties"><a href="#6-db-properties" class="headerlink" title="6. db.properties"></a>6. db.properties</h3><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">mysql.username</span> = <span class="hljs-string">root</span><br><span class="hljs-meta">mysql.password</span>=<span class="hljs-string">mysql</span><br><span class="hljs-meta">mysql.url</span>=<span class="hljs-string">jdbc:mysql://localhost:3306/debuggingworld</span><br><span class="hljs-meta">mysql.driverClassName</span>=<span class="hljs-string">com.mysql.cj.jdbc.Driver</span><br></code></pre></td></tr></table></figure><h3 id="7-mapper接口-mapper映射文件"><a href="#7-mapper接口-mapper映射文件" class="headerlink" title="7. mapper接口\mapper映射文件"></a>7. mapper接口\mapper映射文件</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212112226853.png"></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
      <tag>Spring</tag>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis———分页插件&amp;逆向工程</title>
    <link href="/2022/12/04/Mybatis%E2%80%94%E2%80%94%E2%80%94%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/"/>
    <url>/2022/12/04/Mybatis%E2%80%94%E2%80%94%E2%80%94%E5%88%86%E9%A1%B5%E6%8F%92%E4%BB%B6-%E9%80%86%E5%90%91%E5%B7%A5%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1-分页插件"><a href="#1-分页插件" class="headerlink" title="1. 分页插件"></a>1. 分页插件</h3><p><a href="https://mybatis.org/mybatis-3/zh/configuration.html#plugins">mybatis 插件官方文档</a></p><p>Mybatis 插件典型适用场景：</p><ol><li>分页功能<br>mybatis 的分页默认是基于内存分页的（查出所有再截取），数据量大的情况下效率较低，不过使用 mybatis 插件可以改变该行为，只需要拦截 StatementHandler 类的 prepare 方法，改变要执行的 SQL 语句为分页语句即可；</li><li>公共字段统一赋值<br>一般业务系统都会有创建者，创建时间，修改者，修改时间四个字段，对于这四个字段的赋值，实际上可以在 DAO 层统一拦截处理，可以用 mybatis 插件拦截 Executor 类的 update 方法，对相关参数进行统一赋值即可</li><li>性能监控<br>对于 SQL 语句执行的性能监控，可以通过拦截 Executor 类的 update, query 等方法，用日志记录每个方法执行的时间。</li><li>其它<br>其实 mybatis 扩展性还是很强的，基于插件机制基本上可以控制 SQL 执行的各个阶段，如<strong>执行阶段，参数处理阶段，语法构建阶段，结果集处理阶段</strong>，具体可以根据项目业务来实现对应业务逻辑。</li></ol><h4 id="1-1-使用"><a href="#1-1-使用" class="headerlink" title="1.1 使用"></a>1.1 使用</h4><p><a href="https://github.com/pagehelper/Mybatis-PageHelper">Mybatis-PageHelper github 地址</a></p><p>1、添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/com.github.pagehelper/pagehelper --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.github.pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>pagehelper<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、插件注册</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span> <span class="hljs-attr">interceptor</span>=<span class="hljs-string">&quot;com.github.pagehelper.PageInterceptor&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--设置当前数据库的方言，默认会自动检查当前数据库环境实用的数据库--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;helperDialect&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--该参数默认为false--&gt;</span><br>        <span class="hljs-comment">&lt;!--设置为true时，会将RowBounds第一个参数offset当成pageNum页码使用--&gt;</span><br>        <span class="hljs-comment">&lt;!--和startPage中的pageNum效果一样--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;offsetAsPageNum&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--该参数默认为false--&gt;</span><br>        <span class="hljs-comment">&lt;!--设置为true时，使用RowBounds分页会进行count查询--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;rowBoundsWithCount&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--设置为true时，如果pageSize=0或者RowBounds.limit = 0就会查询出全部的结果--&gt;</span><br>        <span class="hljs-comment">&lt;!--（相当于没有执行分页查询，但是返回结果仍然是Page类型）--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pageSizeZero&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--分页合理化参数，默认值为false。当该参数设置为 true 时，pageNum&lt;=0 时会查询第一页， pageNum&gt;pages（超过总数时）</span><br><span class="hljs-comment">            ，会查询最后一页。默认false 时，直接根据参数进行查询--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;reasonable&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--为了支持startPage(Object params)方法，增加了该参数来配置参数映射，用于从对象中根据属性名取值，</span><br><span class="hljs-comment">             可以配置 pageNum,pageSize,count,pageSizeZero,reasonable，不配置映射的用默认值，</span><br><span class="hljs-comment">             默认值为pageNum=pageNum;pageSize=pageSize;count=countSql;reasonable=reasonable;pageSizeZero=pageSizeZero。--&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;property name=&quot;params&quot; value=&quot;pageNum=start;pageSize=limit;&quot; /&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        PageHelper.startPage(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br>        List&lt;User&gt; users = mapper.selectUser();<br><br>        PageInfo&lt;User&gt; info = <span class="hljs-keyword">new</span> PageInfo&lt;&gt;(users);<br>        System.out.println(<span class="hljs-string">&quot;当前页码：&quot;</span>+info.getPageNum());<br>        System.out.println(<span class="hljs-string">&quot;每页的记录数：&quot;</span>+info.getPageSize());<br>        System.out.println(<span class="hljs-string">&quot;总记录数：&quot;</span>+info.getTotal());<br>        System.out.println(<span class="hljs-string">&quot;总页码：&quot;</span>+info.getPages());<br>        System.out.println(<span class="hljs-string">&quot;是否第一页：&quot;</span>+info.isIsFirstPage());<br>        System.out.println(info);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212042102656.png"></p><h4 id="1-2-原理分析"><a href="#1-2-原理分析" class="headerlink" title="1.2 原理分析"></a>1.2 原理分析</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212052218331.png"></p><p>可以被代理的四大对象都是什么时候被代理的呢？Executor 是 openSession() 的时候创建的； StatementHandler 是 SimpleExecutor.doQuery() 创建的；里面包含了处理参数的 ParameterHandler 和处理结果集的 ResultSetHandler 的创建，创建之后即调用 InterceptorChain.pluginAll()，返回层层代理后的对象。代理是由 Plugin 类创建。在我们重写的 plugin() 方法里面可以直接调用 returnPlugin.wrap(target, this) 返回代理对象。</p><p>因为代理类是 Plugin，所以最后调用的是 Plugin 的 invoke() 方法。它先调用了定义的拦截器的 intercept() 方法。可以通过 invocation.proceed() 调用到被代理对象被拦截的方法。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212052259417.png"></p><p> 调用流程时序图：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212052300892.png"></p><p>首先实现 Interceptor 重写 intercept() 方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Intercepts(</span><br><span class="hljs-meta">        &#123;</span><br><span class="hljs-meta">                @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class&#125;),</span><br><span class="hljs-meta">                @Signature(type = Executor.class, method = &quot;query&quot;, args = &#123;MappedStatement.class, Object.class, RowBounds.class, ResultHandler.class, CacheKey.class, BoundSql.class&#125;),</span><br><span class="hljs-meta">        &#125;</span><br><span class="hljs-meta">)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PageInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Interceptor</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>其中调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">ExecutorUtil.pageQuery(dialect, executor,ms, parameter, rowBounds, resultHandler, boundSql, cacheKey)<br>===&gt;<br>dialect.getPageSql(ms, boundSql, parameter, rowBounds, pageKey)<br>===&gt;<br>Page page = getLocalPage()<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> ThreadLocal&lt;Page&gt; LOCAL_PAGE = <span class="hljs-keyword">new</span> ThreadLocal&lt;Page&gt;();<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function">Page&lt;T&gt; <span class="hljs-title">getLocalPage</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> LOCAL_PAGE.get();<br>&#125;<br></code></pre></td></tr></table></figure><p>调用的是 PageHelper 的一个本地线程变量中的一个 Page 对象，从其中获取我们所设置的 PageSize 与 PageNum，那么他是怎么设置值的呢？</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">PageHelper.startPage(<span class="hljs-number">2</span>,<span class="hljs-number">4</span>);<br>===&gt;<br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function">Page&lt;E&gt; <span class="hljs-title">startPage</span><span class="hljs-params">(<span class="hljs-keyword">int</span> pageNum, <span class="hljs-keyword">int</span> pageSize, <span class="hljs-keyword">boolean</span> count, Boolean reasonable, Boolean pageSizeZero)</span> </span>&#123;<br>    Page&lt;E&gt; page = <span class="hljs-keyword">new</span> Page&lt;E&gt;(pageNum, pageSize, count);<br>    page.setReasonable(reasonable);<br>    page.setPageSizeZero(pageSizeZero);<br>    <span class="hljs-comment">//当已经执行过orderBy的时候</span><br>    Page&lt;E&gt; oldPage = getLocalPage();<br>    <span class="hljs-keyword">if</span> (oldPage != <span class="hljs-keyword">null</span> &amp;&amp; oldPage.isOrderByOnly()) &#123;<br>        page.setOrderBy(oldPage.getOrderBy());<br>    &#125;<br>    setLocalPage(page);<br>    <span class="hljs-keyword">return</span> page;<br>&#125;<br>===&gt;<br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setLocalPage</span><span class="hljs-params">(Page page)</span> </span>&#123;<br>    LOCAL_PAGE.set(page);<br>&#125;<br></code></pre></td></tr></table></figure><p>在我们调用 PageHelper.startPage(2,4)  的时候，系统会调用 LOCAL_PAGE.set(page) 进行设置，从而在分页插件中可以获取到这个本地变量对象中的参数进行 SQL 的改写，由于改写有很多实现，这里以 Mysql 的实现为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getPageSql</span><span class="hljs-params">(String sql, RowBounds rowBounds, CacheKey pageKey)</span> </span>&#123;<br>    StringBuilder sqlBuilder = <span class="hljs-keyword">new</span> StringBuilder(sql.length() + <span class="hljs-number">14</span>);<br>    sqlBuilder.append(sql);<br>    <span class="hljs-keyword">if</span> (rowBounds.getOffset() == <span class="hljs-number">0</span>) &#123;<br>        sqlBuilder.append(<span class="hljs-string">&quot;\n LIMIT &quot;</span>);<br>        sqlBuilder.append(rowBounds.getLimit());<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        sqlBuilder.append(<span class="hljs-string">&quot;\n LIMIT &quot;</span>);<br>        sqlBuilder.append(rowBounds.getOffset());<br>        sqlBuilder.append(<span class="hljs-string">&quot;,&quot;</span>);<br>        sqlBuilder.append(rowBounds.getLimit());<br>        pageKey.update(rowBounds.getOffset());<br>    &#125;<br>    pageKey.update(rowBounds.getLimit());<br>    <span class="hljs-keyword">return</span> sqlBuilder.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-MyBatis逆向工程"><a href="#2-MyBatis逆向工程" class="headerlink" title="2. MyBatis逆向工程"></a>2. MyBatis逆向工程</h3><p><a href="http://mybatis.org/generator/">官方文档</a></p><p><a href="https://github.com/mybatis/generator">github 地址</a></p><p>1、添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.generator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-generator-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、配置文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">generatorConfiguration</span> <span class="hljs-meta-keyword">PUBLIC</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;-//mybatis.org//DTD MyBatis Generator Configuration 1.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-generator-config_1_0.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">generatorConfiguration</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--如果需要使用 command的方式生成需要配置数据库驱动的jar包路径</span><br><span class="hljs-comment">    &lt;classPathEntry location=&quot;指定数据驱动的磁盘路径&quot;/&gt;--&gt;</span><br><br>    <span class="hljs-comment">&lt;!--context 生成上下文 配置生成规则</span><br><span class="hljs-comment">           id 随意写</span><br><span class="hljs-comment">           targetRuntime 生成策略</span><br><span class="hljs-comment">                MyBatis3DynamicSql 默认的，会生成 动态生成sql的方式（没有xml)</span><br><span class="hljs-comment">                MyBatis3 生成通用的查询，可以指定动态where条件</span><br><span class="hljs-comment">                MyBatis3Simple 只生成简单的CRUD</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;simple&quot;</span> <span class="hljs-attr">targetRuntime</span>=<span class="hljs-string">&quot;MyBatis3Simple&quot;</span>&gt;</span><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">commentGenerator</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--设置是否生成注释  true 不生成  注意： 如果不生成注释，下次生成代码就不会进行合并--&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suppressAllComments&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">commentGenerator</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--数据源 --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">jdbcConnection</span> <span class="hljs-attr">driverClass</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">connectionURL</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/debuggingworld&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">userId</span>=<span class="hljs-string">&quot;root&quot;</span></span><br><span class="hljs-tag">                        <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br><br>        <span class="hljs-comment">&lt;!--pojo</span><br><span class="hljs-comment">        javaModelGenerator  java实体生成规则(POJO)</span><br><span class="hljs-comment">            targetPackage 生成到哪个包下</span><br><span class="hljs-comment">            targetProject 生成到当前文件的哪个相对路径下</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaModelGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--mapper xml映射文件</span><br><span class="hljs-comment">            sqlMapGenerator mapper xml映射文件生成规则</span><br><span class="hljs-comment">            targetPackage 生成到哪个包下</span><br><span class="hljs-comment">            targetProject 生成到当前文件的哪个相对路径下</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">sqlMapGenerator</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/resources&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--mapper接口</span><br><span class="hljs-comment">            javaClientGenerator mapper mapper接口生成规则</span><br><span class="hljs-comment">            type 指定生成的方式</span><br><span class="hljs-comment">                1.使用注解的方式生成  ANNOTATEDMAPPER</span><br><span class="hljs-comment">                2.使用接口绑定的方式生成（要配置sqlMapGenerator）XMLMAPPER</span><br><span class="hljs-comment">            targetPackage 生成到哪个包下</span><br><span class="hljs-comment">            targetProject 生成到当前文件的哪个相对路径下--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">javaClientGenerator</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;XMLMAPPER&quot;</span> <span class="hljs-attr">targetPackage</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper&quot;</span> <span class="hljs-attr">targetProject</span>=<span class="hljs-string">&quot;src/main/java&quot;</span>/&gt;</span><br><br>        <span class="hljs-comment">&lt;!--配置哪些表需要进行代码生成</span><br><span class="hljs-comment">        tableName 表名</span><br><span class="hljs-comment">        domainObjectName pojo类名</span><br><span class="hljs-comment">        mapperName 对应mapper接口的类名 和 mapper xml文件名</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;t_user&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;User&quot;</span> <span class="hljs-attr">mapperName</span>=<span class="hljs-string">&quot;UserMapper&quot;</span> /&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">table</span> <span class="hljs-attr">tableName</span>=<span class="hljs-string">&quot;t_dept&quot;</span> <span class="hljs-attr">domainObjectName</span>=<span class="hljs-string">&quot;Dept&quot;</span> <span class="hljs-attr">mapperName</span>=<span class="hljs-string">&quot;DeptMapper&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">context</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">generatorConfiguration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、生成代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>    List&lt;String&gt; warnings = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    <span class="hljs-keyword">boolean</span> overwrite = <span class="hljs-keyword">true</span>;<br>    File configFile = <span class="hljs-keyword">new</span> File(<span class="hljs-string">&quot;generatorConfig.xml&quot;</span>);<br>    ConfigurationParser cp = <span class="hljs-keyword">new</span> ConfigurationParser(warnings);<br>    Configuration config = cp.parseConfiguration(configFile);<br>    DefaultShellCallback callback = <span class="hljs-keyword">new</span> DefaultShellCallback(overwrite);<br>    MyBatisGenerator myBatisGenerator = <span class="hljs-keyword">new</span> MyBatisGenerator(config, callback, warnings);<br>     myBatisGenerator.generate(<span class="hljs-keyword">null</span>);<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212082139765.png"></p><p>【注】配置文件任意位置均可，上图中位于 src 同级目录。</p>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis——动态SQL&amp;缓存</title>
    <link href="/2022/11/28/Mybatis%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81sql-%E7%BC%93%E5%AD%98/"/>
    <url>/2022/11/28/Mybatis%E2%80%94%E2%80%94%E5%8A%A8%E6%80%81sql-%E7%BC%93%E5%AD%98/</url>
    
    <content type="html"><![CDATA[<h2 id="1-动态-SQL"><a href="#1-动态-SQL" class="headerlink" title="1. 动态 SQL"></a>1. 动态 SQL</h2><p>动态 sql 是基于 OGNL 的表达式的。</p><h3 id="1-1-if"><a href="#1-1-if" class="headerlink" title="1.1  if"></a>1.1  if</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span><br>    SELECT * FROM t_user WHERE<br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;createTime != 0&quot;</span>&gt;</span><br>        create_time &gt;= #&#123;createTime&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deptId != null&quot;</span>&gt;</span><br>        AND dept_id = #&#123;deptId&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>其中的条件不成立会怎么样？这个时候拼接的 sql 语句就会变得有问题。</p><p>第一个不成立或者都不成立，那么语句中就会多一个 where 或者 and 关键字。</p><p>where  问题可通过添加 “1 = 1” 恒等条件解决。但 mybatis 中也给出了具体的解决方案（trim、where、set）。</p><h3 id="1-2-trim（where、set）"><a href="#1-2-trim（where、set）" class="headerlink" title="1.2 trim（where、set）"></a>1.2 trim（where、set）</h3><p><em>where</em> 元素只会在子元素返回任何内容的情况下才插入 “WHERE” 子句。而且，若子句的开头为 “AND” 或 “OR”，<em>where</em> 元素也会将它们去除。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span><br>    SELECT * FROM t_user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;createTime != 0&quot;</span>&gt;</span><br>            create_time &gt;= #&#123;createTime&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deptId != null&quot;</span>&gt;</span><br>            AND dept_id = #&#123;deptId&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>用于动态更新语句的类似解决方案叫做 <em>set</em>。<em>set</em> 元素可以用于动态包含需要更新的列，忽略其它不更新的列。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span>&gt;</span><br>    update t_user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">set</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;createTime != 0&quot;</span>&gt;</span>create_time = #&#123;createTime&#125;,<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">if</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deptId != null&quot;</span>&gt;</span>dept_id = #&#123;deptId&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">if</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">set</span>&gt;</span><br>    where user_id=#&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br></code></pre></td></tr></table></figure><p><em>set</em> 元素会动态地在行首插入 SET 关键字，并会删掉额外的逗号（createTime 后面的逗号）。</p><p>也可以通过自定义 trim 元素来定制 。</p><p>和 <em>where</em> 元素等价的自定义 trim 元素为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">   prefix：前缀，为sql整体添加一个前缀</span><br><span class="hljs-comment">   prefixOverrides:去除整体字符串前面多余的字符</span><br><span class="hljs-comment">   suffixOverrides:去除后面多余的字符</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;WHERE&quot;</span> <span class="hljs-attr">prefixOverrides</span>=<span class="hljs-string">&quot;AND |OR &quot;</span>&gt;</span><br>    ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br></code></pre></td></tr></table></figure><p>和 <em>where</em> 元素等价的自定义 trim 元素为：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">trim</span> <span class="hljs-attr">prefix</span>=<span class="hljs-string">&quot;SET&quot;</span> <span class="hljs-attr">suffixOverrides</span>=<span class="hljs-string">&quot;,&quot;</span>&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">trim</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-3-foreach"><a href="#1-3-foreach" class="headerlink" title="1.3 foreach"></a>1.3 foreach</h3><p>动态 SQL 的另一个常见使用场景是对集合进行遍历（尤其是在构建 IN 条件语句的时候）。</p><p><em>foreach</em> 元素的功能非常强大，它允许你指定一个集合，声明可以在元素体内使用的集合项（item）和索引（index）变量。它也允许你指定开头与结尾的字符串以及集合项迭代之间的分隔符。</p><p>可以将任何可迭代对象（如 List、Set 等）、Map 对象或者数组对象作为集合参数传递给 <em>foreach</em>。当使用可迭代对象或者数组时，index 是当前迭代的序号，item 的值是本次迭代获取到的元素。当使用 Map 对象（或者 Map.Entry 对象的集合）时，index 是键，item 是值。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    collection=&quot;deptNos&quot; 指定要遍历的集合</span><br><span class="hljs-comment">    close=&quot;&quot; 表示以什么结束</span><br><span class="hljs-comment">    index=&quot;&quot; 给定一个索引值</span><br><span class="hljs-comment">    item=&quot;&quot; 遍历的每一个元素的值</span><br><span class="hljs-comment">    open=&quot;&quot; 表示以什么开始</span><br><span class="hljs-comment">    separator=&quot;&quot; 表示多个元素的分隔符</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span><br>    SELECT * FROM t_user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">foreach</span> <span class="hljs-attr">item</span>=<span class="hljs-string">&quot;item&quot;</span> <span class="hljs-attr">index</span>=<span class="hljs-string">&quot;index&quot;</span> <span class="hljs-attr">collection</span>=<span class="hljs-string">&quot;deptNos&quot;</span></span><br><span class="hljs-tag">                 <span class="hljs-attr">open</span>=<span class="hljs-string">&quot;dept_id in (&quot;</span> <span class="hljs-attr">separator</span>=<span class="hljs-string">&quot;,&quot;</span> <span class="hljs-attr">close</span>=<span class="hljs-string">&quot;)&quot;</span> &gt;</span><br>            #&#123;item&#125;<br>        <span class="hljs-tag">&lt;/<span class="hljs-name">foreach</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-4-choose-when-otherwise"><a href="#1-4-choose-when-otherwise" class="headerlink" title="1.4  choose (when, otherwise)"></a>1.4  choose (when, otherwise)</h3><p>有时候，我们不想使用所有的条件，而只是想从多个条件中选择一个使用。针对这种情况，MyBatis 提供了 choose 元素，它有点像 Java 中的 switch 语句。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span><br>    SELECT * FROM t_user<br>    <span class="hljs-tag">&lt;<span class="hljs-name">where</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">choose</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;deptId != null&quot;</span>&gt;</span><br>                dept_id = #&#123;deptId&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">when</span> <span class="hljs-attr">test</span>=<span class="hljs-string">&quot;createTime != 0&quot;</span>&gt;</span><br>                create_time &gt; #&#123;createTime&#125;<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">when</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">otherwise</span>&gt;</span><br>                user_id &gt; 1<br>            <span class="hljs-tag">&lt;/<span class="hljs-name">otherwise</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">choose</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">where</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>【注】只有一个条件会成立</p></blockquote><h3 id="1-5-bind"><a href="#1-5-bind" class="headerlink" title="1.5 bind"></a>1.5 bind</h3><p><code>bind</code> 元素允许你在 OGNL 表达式以外创建一个变量，并将其绑定到当前的上下文。比如：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bind</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;pattern&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&#x27;%&#x27; + user.getName() + &#x27;%&#x27;&quot;</span>/&gt;</span><br>    SELECT * FROM t_user<br>    WHERE<br>    user_name LIKE #&#123;pattern&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="1-6-sql"><a href="#1-6-sql" class="headerlink" title="1.6 sql"></a>1.6 sql</h3><p>用来定义可重用的 SQL 代码片段，以便在其它语句中使用。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">sql</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userColumns&quot;</span>&gt;</span> $&#123;alias&#125;.user_id,  $&#123;alias&#125;.user_name <span class="hljs-tag">&lt;/<span class="hljs-name">sql</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span>&gt;</span><br>    SELECT<br>    <span class="hljs-tag">&lt;<span class="hljs-name">include</span> <span class="hljs-attr">refid</span>=<span class="hljs-string">&quot;userColumns&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;alias&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;t&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>    FROM t_user t<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h2 id="2-MyBatis常用OGNL表达式"><a href="#2-MyBatis常用OGNL表达式" class="headerlink" title="2. MyBatis常用OGNL表达式"></a>2. MyBatis常用OGNL表达式</h2><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs oxygene">e1 <span class="hljs-keyword">or</span> e2<br>e1 <span class="hljs-keyword">and</span> e2<br>e1 == e2,e1 eq e2<br>e1 != e2,e1 neq e2<br>e1 lt e2：小于<br>e1 lte e2：小于等于，其他gt（大于）,gte（大于等于）<br>e1 <span class="hljs-keyword">in</span> e2<br>e1 <span class="hljs-keyword">not</span> <span class="hljs-keyword">in</span> e2<br>e1 + e2,e1 * e2,e1/e2,e1 ‐ e2,e1%e2<br>!e,<span class="hljs-keyword">not</span> e：非，求反<br>e.method(args)调用对象方法<br>e.property对象属性值<br>e1[ e2 ]按索引取值，List,数组和Map<br>@<span class="hljs-keyword">class</span>@<span class="hljs-function"><span class="hljs-keyword">method</span><span class="hljs-params">(args)</span>调用类的静态方法</span><br><span class="hljs-function">@<span class="hljs-title">class</span>@<span class="hljs-title">field</span>调用类的静态字段值</span><br></code></pre></td></tr></table></figure><h2 id="3-缓存"><a href="#3-缓存" class="headerlink" title="3. 缓存"></a>3. 缓存</h2><h3 id="3-1-一级缓存"><a href="#3-1-一级缓存" class="headerlink" title="3.1 一级缓存"></a>3.1 一级缓存</h3><h4 id="1-一级缓存的使用"><a href="#1-一级缓存的使用" class="headerlink" title="1. 一级缓存的使用"></a>1. 一级缓存的使用</h4><p>一级缓存是 sqlsession 级别的缓存，默认是开启的。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>        System.out.println(user);<br>        user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211302155684.png"></p><p>发送了两个相同的请求，但是sql语句仅仅执行了一次，那么就意味着第一次查询的时候已经将结果进行了缓存。</p><h4 id="2-一级缓存失效"><a href="#2-一级缓存失效" class="headerlink" title="2. 一级缓存失效"></a>2. 一级缓存失效</h4><p>1、一级缓存是 sqlSession 级别的缓存，如果在应用程序中开启了多个 sqlsession，那么会造成缓存失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>        System.out.println(user);<br>    &#125;<br>    <span class="hljs-keyword">try</span> (SqlSession sqlSession = sqlSessionFactory.openSession())&#123;<br>        UserMapper mapper = sqlSession.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211302153203.png"></p><p>2、同一 sqlSession， 如果查询语句不一样或者同一语句查询参数不一样，那么也会缓存失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>        System.out.println(user);<br>        user = mapper.selectUserById(<span class="hljs-number">3</span>);<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>3、同一 sqlSession，中间执行增删改操作，则会缓存失效。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br><br>        DeptMapper deptMapper = session.getMapper(DeptMapper.class);<br>        deptMapper.deleteDeptById(<span class="hljs-number">2</span>);<br><br>        user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>4、同一 sqlSession，手动执行清除缓存</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br><br>        session.clearCache();<br><br>        user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认缓存实现类： PerpetualCache</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211302306656.png"></p><p>一级缓存的 key：hashcode + sqlid + sql+参数+环境</p><p>执行更新操作，当前 sqlSession 缓存全部清空（会直接调用  clear 方法）。</p><h3 id="3-2-二级缓存"><a href="#3-2-二级缓存" class="headerlink" title="3.2 二级缓存"></a>3.2 二级缓存</h3><p>二级缓存作用域是全局，即 Application级。默认是开启的（cacheEnabled 默认值为 true )，但是没有实现。</p><p>Mybatis 提供二级缓存的接口以及实现，缓存实现的时候要求实体类实现 Serializable 接口，二级缓存在 sqlSession 关闭或提交之后才会生效。</p><p>一级缓存时机：查询完成进行缓存</p><p>二级缓存时机：事务提交之后（sqlSession 关闭）进行缓存</p><p>缓存查询顺序：<strong>先二级缓存再一级缓存</strong></p><h4 id="1-二级缓存的使用"><a href="#1-二级缓存的使用" class="headerlink" title="1. 二级缓存的使用"></a>1. 二级缓存的使用</h4><p>1、开启二级缓存</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--默认为true，显式声明，增加可读性--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;cacheEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211302334260.png"></p><p>2、Mapper 映射文件中添加  &lt;cache/&gt; 标签</p><p>二级缓存是基于 Mapper 映射文件实现缓存的，基于 Mapper 映射文件的命名空间来存储的。</p><p>一级 map 的 key 是  Mapper 映射文件 namespace 命名空间，value 指向二级 map（PerpetualCache 中的 map )</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211302346921.png" alt="二级缓存"></p><p>默认缓存效果：</p><ul><li>映射语句文件中的所有 select 语句的结果将会被缓存。</li><li>映射语句文件中的所有 insert、update 和 delete 语句会刷新缓存。</li><li>缓存会使用最近最少使用算法（LRU, Least Recently Used）算法来清除不需要的缓存。</li><li>缓存不会定时进行刷新（也就是说，没有刷新间隔）。</li><li>缓存会保存列表或对象（无论查询方法返回哪种）的 1024 个引用。</li><li>缓存会被视为读/写缓存，这意味着获取到的对象并不是共享的，可以安全地被调用者修改，而不干扰其他调用者或线程所做的潜在修改。</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache</span></span><br><span class="hljs-tag">  <span class="hljs-attr">eviction</span>=<span class="hljs-string">&quot;FIFO&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">flushInterval</span>=<span class="hljs-string">&quot;60000&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">size</span>=<span class="hljs-string">&quot;512&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">readOnly</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>这个更高级的配置创建了一个 FIFO 缓存，每隔 60 秒刷新，最多可以存储结果对象或列表的 512 个引用，而且返回的对象被认为是只读的，因此对它们进行修改可能会在不同线程中的调用者产生冲突。</p><p>可用的清除策略有：</p><ul><li><code>LRU</code> – 最近最少使用：移除最长时间不被使用的对象。</li><li><code>FIFO</code> – 先进先出：按对象进入缓存的顺序来移除它们。</li><li><code>SOFT</code> – 软引用：基于垃圾回收器状态和软引用规则移除对象。</li><li><code>WEAK</code> – 弱引用：更积极地基于垃圾收集器状态和弱引用规则移除对象。</li></ul><p>默认的清除策略是 LRU。</p><p>flushInterval（刷新间隔）属性可以被设置为任意的正整数，设置的值应该是一个以毫秒为单位的合理时间量。 默认情况是不设置，也就是没有刷新间隔，缓存仅仅会在调用语句时刷新。</p><p>size（引用数目）属性可以被设置为任意正整数，要注意欲缓存对象的大小和运行环境中可用的内存资源。默认值是 1024。</p><p>readOnly（只读）属性可以被设置为 true 或 false。只读的缓存会给所有调用者返回缓存对象的相同实例。 因此这些对象不能被修改。这就提供了可观的性能提升。而可读写的缓存会（通过序列化）返回缓存对象的拷贝。 速度上会慢一些，但是更安全，因此默认值是 false。</p><p>type 二级缓存实现类，默认值：org.apache.ibatis.cache.impl.PerpetualCache</p><p>3、使用到二级缓存的 javaBean 需要实现 Serializable</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202212012226849.png"></p><h4 id="2-二级缓存失效"><a href="#2-二级缓存失效" class="headerlink" title="2. 二级缓存失效"></a>2. 二级缓存失效</h4><p>1、同一命名空间进行增删改，会导致二级缓存失效。</p><p>可以将 flushCache 设置为 false 不清空缓存，默认为 true。谨慎设置！！</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span> <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>    &#125;<br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        mapper.updateUser(<span class="hljs-keyword">new</span> User(<span class="hljs-number">6</span>,<span class="hljs-string">&quot;aaa&quot;</span>,<span class="hljs-number">234</span>,<span class="hljs-string">&quot;1&quot;</span>));<br>        session.commit();<br>    &#125;<br><br>    <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>        UserMapper mapper = session.getMapper(UserMapper.class);<br>        User user = mapper.selectUserById(<span class="hljs-number">1</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>2、设置查询不缓存数据到二级缓存中。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span> <span class="hljs-attr">useCache</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>useCache  默认为 true。</p><p>另外，查询语句也有 flushCache ，但是默认值为 false。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserById&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userMap&quot;</span> <span class="hljs-attr">flushCache</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、使用 cache-ref 增删改的时候清空指定 nameSpace 的缓存。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">cache-ref</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper.DeptMapper&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>引用 nameSpace 所指定 mapper 映射文件的缓存机制，执行增删改会清空执行 nameSpace 的缓存。</p><p>限制：只能引用一个 nameSpace。</p><h3 id="3-3-整合第三方缓存"><a href="#3-3-整合第三方缓存" class="headerlink" title="3.3 整合第三方缓存"></a>3.3 整合第三方缓存</h3><p><a href="https://github.com/hazendaz/redis-cache">https://github.com/hazendaz/redis-cache</a></p><p>1、添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.mybatis.caches/mybatis-redis --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis.caches<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis-redis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0.0-beta2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、添加 redis 配置类</p><p>redis.properties：</p><figure class="highlight properties"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs properties"><span class="hljs-meta">redis.host</span>=<span class="hljs-string">localhost</span><br><span class="hljs-meta">redis.port</span>=<span class="hljs-string">6379</span><br><span class="hljs-meta">redis.connectionTimeout</span>=<span class="hljs-string">5000</span><br><span class="hljs-meta">redis.soTimeout</span>=<span class="hljs-string">5000</span><br><span class="hljs-meta">redis.password</span>=<span class="hljs-string"></span><br><span class="hljs-meta">redis.database</span>=<span class="hljs-string">0</span><br><span class="hljs-meta">redis.clientName</span>=<span class="hljs-string"></span><br></code></pre></td></tr></table></figure><p>3、设置 mybatis 二级缓存实现类</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;org.acme.FooMapper&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">cache</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;org.mybatis.caches.redis.RedisCache&quot;</span> /&gt;</span><br>  ...<br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis——参数\查询结果处理&amp;高级结果映射</title>
    <link href="/2022/11/23/Mybatis%E2%80%94%E2%80%94%E5%8F%82%E6%95%B0-%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86-%E9%AB%98%E7%BA%A7%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84/"/>
    <url>/2022/11/23/Mybatis%E2%80%94%E2%80%94%E5%8F%82%E6%95%B0-%E6%9F%A5%E8%AF%A2%E7%BB%93%E6%9E%9C%E5%A4%84%E7%90%86-%E9%AB%98%E7%BA%A7%E7%BB%93%E6%9E%9C%E6%98%A0%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<h3 id="1-参数处理"><a href="#1-参数处理" class="headerlink" title="1.  参数处理"></a>1.  参数处理</h3><h4 id="1-1-参数取值方式"><a href="#1-1-参数取值方式" class="headerlink" title="1. 1  参数取值方式"></a>1. 1  参数取值方式</h4><p>sql 语句有两种取值方式，分别是 <strong>#{}</strong> 和 **${}**。</p><ul><li>#{} 是预编译处理，${} 是字符串替换。</li><li>Mybatis 在处理 #{} 时，会将 sql 中的 #{} 替换为 ? 号，调用 PreparedStatement 的 set 方法来赋值；</li><li>Mybatis 在处理 ${} 替换成变量的值。</li><li>使用 #{} 可以有效的防止 SQL 注入，提高系统安全性。</li></ul><h5 id="方式"><a href="#方式" class="headerlink" title="#{} 方式"></a>#{} 方式</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo.User&quot;</span>&gt;</span><br>SELECT * FROM t_user WHERE id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>执行过程：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211261150309.png"></p><h5 id="方式-1"><a href="#方式-1" class="headerlink" title="${} 方式"></a>${} 方式</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo.User&quot;</span>&gt;</span><br>    SELECT * FROM t_user WHERE id = $&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>执行过程：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211261151527.png"></p><p>特殊用法：</p><ul><li>调试时可以临时使用（打印完整 sql 语句）。</li><li>实现一些特殊功能：前提一定要保证数据的安全性。 比如：动态表、动态列。</li></ul> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo.User&quot;</span>&gt;</span><br>    SELECT * FROM $&#123;table&#125; WHERE id = 1<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211261151320.png"></p><p>使用 #{} 将报错：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo.User&quot;</span>&gt;</span><br>    SELECT * FROM #&#123;table&#125; WHERE id = 1<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211261152526.png"></p><h4 id="1-2-参数传递"><a href="#1-2-参数传递" class="headerlink" title="1.2 参数传递"></a>1.2 参数传递</h4><h5 id="1-单个参数"><a href="#1-单个参数" class="headerlink" title="1. 单个参数"></a>1. 单个参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">User <span class="hljs-title">selectUser</span><span class="hljs-params">(Integer id)</span></span>;<br></code></pre></td></tr></table></figure><ul><li>mybatis 不会做任何特殊要求</li><li> 获取方式： #:{输入任何字符获取参数}</li><li> 也可用 @Param() 指定参数名</li></ul><h5 id="2-多个参数"><a href="#2-多个参数" class="headerlink" title="2. 多个参数"></a>2. 多个参数</h5> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">User <span class="hljs-title">selectUser</span><span class="hljs-params">(<span class="hljs-meta">@Param(&quot;id&quot;)</span> Integer id, <span class="hljs-meta">@Param(&quot;username&quot;)</span> String userName)</span></span>;<br></code></pre></td></tr></table></figure><ul><li> mybatis 会进行封装，会将传进来的参数封装成 map，一个值对应两个 map。</li><li> id ===&gt;  { key:arg0, value:id 的值 }，{key:param1, value:id 的值}</li><li>userName===&gt; {key:arg1, value:id 的值}, {key:param2 ,value:id 的值}</li><li>获取方式<ul><li>id ===&gt; #{arg0} 或者 #{param1}</li><li>username ===&gt; #{arg1} 或者 #{param2}</li></ul></li><li>设置参数的别名：User selectUser(@Param(“id”) Integer id, @Param(“username”) String userName)</li><li>当使用了 @Param:<ul><li>id ===&gt; #{id} 或者 #{param1}</li><li>username ===&gt; #{username} 或者 #{param2}</li></ul></li></ul><h5 id="3-javaBean-参数"><a href="#3-javaBean-参数" class="headerlink" title="3. javaBean 参数"></a>3. javaBean 参数</h5><p><strong>单个参数:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">User <span class="hljs-title">selectUser</span><span class="hljs-params">(User user)</span></span><br></code></pre></td></tr></table></figure><ul><li>获取方式：可以直接使用属性名<ul><li>user.id ===&gt; #{id}</li><li>user.name ===&gt; #{name}</li></ul></li></ul><p><strong>多个参数:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">User <span class="hljs-title">selectUser</span><span class="hljs-params">(Integer num, User user)</span></span><br></code></pre></td></tr></table></figure><ul><li>num ===&gt; #{param1} 或者 @Param()</li><li>user===&gt; 必须加上对象别名<ul><li>user.id ===&gt; #{param2.id} 或者 @Param(“user”) User user ===&gt; #{user.id}</li><li>user.name  ===&gt; #{param2.name} 或者 @Param(“user”) User user ===&gt; #{emp.username}</li></ul></li></ul><h5 id="4-集合或数组参数"><a href="#4-集合或数组参数" class="headerlink" title="4. 集合或数组参数"></a>4. 集合或数组参数</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">User <span class="hljs-title">selectUser</span><span class="hljs-params">(List&lt;String&gt; userNames)</span></span>;<br></code></pre></td></tr></table></figure><p>如果是 list，MyBatis 会自动封装为 map ： { key：”list”；value：userNames}</p><ul><li>没用 @Param 获取：userNames.get(0) ===&gt; #{ list[0] } /  #{ arg0[0] }</li><li>有 @Param(“userNames”) 获取：userNames.get(0) ===&gt; #{ userNames[0] } /  #{ param1[0] }</li></ul><p>如果是数组，MyBatis 会自动封装为 map：{ key ：”array” ；value：userNames }</p><ul><li>没用 @Param 获取：userNames.get(0) ===&gt; #{ array[0] } / #{ arg0[0] }</li><li>有 @Param(“userNames”) 获取：userNames.get(0) ===&gt; #{ userNames[0] } / #{ param1[0] } </li></ul><h5 id="5-map-参数"><a href="#5-map-参数" class="headerlink" title="5. map 参数"></a>5. map 参数</h5><p>和 javaBean 参数传递是一样。</p><h3 id="2-集合返回结果处理"><a href="#2-集合返回结果处理" class="headerlink" title="2. 集合返回结果处理"></a>2. 集合返回结果处理</h3><p>1、当返回值的结果是集合的时候，返回值的类型依然写的是集合中具体的类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">List&lt;User&gt; <span class="hljs-title">selectAllUser</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAllUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo.User&quot;</span>&gt;</span><br>    SELECT * FROM t_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、在查询的时候可以设置返回值的类型为 map，mybatis 会把列的名作为 key，列的值作为 value，转换到 map 中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Map&lt;String,Object&gt; <span class="hljs-title">selectUser</span><span class="hljs-params">(Integer id)</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>    SELECT * FROM t_user WHERE id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>3、使用 @MapKey 将集合转为 map。</p><p><a href="https://blog.csdn.net/qq_41057885/article/details/125824289">@MapKey 用法</a></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@MapKey(&quot;id&quot;)</span><br><span class="hljs-function">Map&lt;Integer,User&gt; <span class="hljs-title">selectAllUser</span><span class="hljs-params">()</span></span>;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAllUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo.User&quot;</span>&gt;</span><br>    SELECT * FROM t_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-自定义结果集-­­­resultMap"><a href="#3-自定义结果集-­­­resultMap" class="headerlink" title="3. 自定义结果集 ­­­resultMap"></a>3. 自定义结果集 ­­­resultMap</h3><p>resultType 和 resultMap  自定义结果集只能使用一个。</p><ul><li>id：唯一标识， 需要和 select 标签上的 resultMap 属性进行对应。</li><li>type：需要映射的 pojo 对象， 可以设置别名</li><li>autoMapping：自动映射（默认=true），只要字段名和属性名遵循映射规则就可以自动映射，但是不建议，哪怕属性名和字段名一一对应也要显式配置映射</li><li>extends 如果多个 resultMap 有重复映射，可以声明父 resultMap，将公共的映射提取出来， 减少子 resultMap 的映射冗余</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;common_map&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">autoMapping</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>   <span class="hljs-comment">&lt;!-- &lt;id&gt; 主键必须使用，对底层存储有性能作用</span><br><span class="hljs-comment">        column 需要映射的数据库字段名</span><br><span class="hljs-comment">        property 需要映射的 pojo 属性名</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user_map&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">autoMapping</span>=<span class="hljs-string">&quot;false&quot;</span> <span class="hljs-attr">extends</span>=<span class="hljs-string">&quot;common_map&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;createTime&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;create_time&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectAllUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;user_map&quot;</span>&gt;</span><br>    SELECT * FROM t_user<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="4-高级结果映射"><a href="#4-高级结果映射" class="headerlink" title="4.  高级结果映射"></a>4.  高级结果映射</h3><h4 id="4-1-联合查询"><a href="#4-1-联合查询" class="headerlink" title="4.1 联合查询"></a>4.1 联合查询</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 实现表联结查询的方式： 可以映射: DTO --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userQueryDTO&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;userDTO&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;useId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 实现表联结查询的方式： 可以映射map --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userQueryMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;map&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;useId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;userName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userQueryDTO&quot;</span>&gt;</span><br>    SELECT u.user_id,u.user_name,d.dept_id,  d.dept_name FROM t_user u Inner JOIN  t_dept d  ON u.user_id = d.dept_id WHERE user_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser02&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userQueryMap&quot;</span>&gt;</span><br>    SELECT u.user_id,u.user_name,d.dept_id,  d.dept_name FROM t_user u Inner JOIN  t_dept d  ON u.user_id = d.dept_id WHERE user_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-2-嵌套结果"><a href="#4-2-嵌套结果" class="headerlink" title="4.2 嵌套结果"></a>4.2 嵌套结果</h4><h5 id="1-多对一"><a href="#1-多对一" class="headerlink" title="1. 多对一"></a>1. 多对一</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> id;<br>    String name;<br>    Dept dept;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userQuery&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">         association 实现多对一中的 “一”</span><br><span class="hljs-comment">         property 指定对象中嵌套对象属性</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">association</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser03&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userQuery&quot;</span>&gt;</span><br>    SELECT u.user_id, u.user_name, d.dept_id, d.dept_name<br>    FROM t_user u<br>             Inner JOIN t_dept d ON u.user_id = d.dept_id<br>    WHERE user_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="2-一对多"><a href="#2-一对多" class="headerlink" title="2. 一对多"></a>2. 一对多</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Dept</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> deptId;<br>    String deptName;<br>    List&lt;User&gt; users;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deptWithUser&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;dept&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">         collection 映射一对多中的 “多”</span><br><span class="hljs-comment">         property 指定需要映射的“多”的属性，一般声明为List</span><br><span class="hljs-comment">         ofType 需要指定list的类型</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;users&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">collection</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-3-嵌套查询（分步查询）"><a href="#4-3-嵌套查询（分步查询）" class="headerlink" title="4.3 嵌套查询（分步查询）"></a>4.3 嵌套查询（分步查询）</h4><h5 id="1-多对一-1"><a href="#1-多对一-1" class="headerlink" title="1. 多对一"></a>1. 多对一</h5><p>联合查询和分步查询区别：</p><ul><li>性能区别不大</li><li>分步查询支持懒加载（延迟加载）</li><li>需要设置懒加载，一定要使用嵌套查询的。</li><li>要启动懒加载可以在全局配置文件中设置 lazyLoadingEnabled=true</li><li>还可以单独为某个分步查询设置立即加载 association 标签 fetchType=”eager”</li></ul><p>UserMapper.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userQuery&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">        property 指定对象中的嵌套对象属性</span><br><span class="hljs-comment">        column 指定将哪个字段传到分步查询中</span><br><span class="hljs-comment">        select 指定分步查询的 命名空间+ID</span><br><span class="hljs-comment">        以上3个属性是实现分步查询必须的属性</span><br><span class="hljs-comment">        fetchType 可选 eager|lazy ,指定属性后，将在映射中忽略全局配置参数 lazyLoadingEnabled 使用属性的值。</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span> <span class="hljs-attr">fetchType</span>=<span class="hljs-string">&quot;lazy&quot;</span></span><br><span class="hljs-tag">                 <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper.DeptMapper.selectDept&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser03&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;userQuery&quot;</span>&gt;</span><br>    SELECT *<br>    FROM t_user<br>    WHERE user_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>DeptMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--&lt;setting name=&quot;mapUnderscoreToCamelCase&quot; value=&quot;true&quot;/&gt;--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectDept&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;dept&quot;</span>&gt;</span><br>    SELECT * FROM t_dept where dept_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>未开启懒加载：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211271611984.png"></p><p>开启懒加载：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/202211271602813.png"></p><h5 id="2-一对多-1"><a href="#2-一对多-1" class="headerlink" title="2. 一对多"></a>2. 一对多</h5><p>DeptMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deptMap&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;dept&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">id</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptId&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;deptName&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_name&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">collection</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;users&quot;</span> <span class="hljs-attr">ofType</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span> <span class="hljs-attr">fetchType</span>=<span class="hljs-string">&quot;lazy&quot;</span></span><br><span class="hljs-tag">                <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper.UserMapper.selectUserByDept&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectDept&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;deptMap&quot;</span>&gt;</span><br>    SELECT * FROM t_dept where dept_id = #&#123;id&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><p>UserMapper.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">resultMap</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;users&quot;</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_id&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">result</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;user_name&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">resultMap</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUserByDept&quot;</span> <span class="hljs-attr">resultMap</span>=<span class="hljs-string">&quot;users&quot;</span>&gt;</span><br>    SELECT *<br>    FROM t_user<br>    WHERE dept_id=#&#123;deptId&#125;<br><span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-延迟查询"><a href="#5-延迟查询" class="headerlink" title="5. 延迟查询"></a>5. 延迟查询</h3><p>当我们在进行表关联的时候，有可能查询结果不需要关联对象的属性值，那么此时可以通过延迟加载来实现该功能。在全局配置文件中添加如下属性：</p><p>mybatis­config.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--开启延迟加载，所有分步查询都是懒加载 （默认是立即加载）--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadingEnabled&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--当开启时， 使用pojo中任意属性都会加载延迟查询 ,默认是false（在 3.4.1 及之前的版本中默认为 true）--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;aggressiveLazyLoading&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;false&quot;</span>/&gt;</span><br><span class="hljs-comment">&lt;!--设置对象的哪些方法调用会加载延迟查询 默认： equals,clone,hashCode,toString--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;lazyLoadTriggerMethods&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>如果设置了全局懒加载，但是希望在某一个 sql 语句查询的时候不使用延时策略，可以添加 fetchType 属性：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">association</span> <span class="hljs-attr">property</span>=<span class="hljs-string">&quot;dept&quot;</span> <span class="hljs-attr">column</span>=<span class="hljs-string">&quot;dept_id&quot;</span> <span class="hljs-attr">fetchType</span>=<span class="hljs-string">&quot;eager&quot;</span></span><br><span class="hljs-tag">             <span class="hljs-attr">select</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper.DeptMapper.selectDept&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>【注】</p><p>默认 equals,clone,hashCode,toString 触发懒加载</p><p>使用lombok默认的@ToString 打印时会默认调用的是 getField() 而非成员</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Mybatis——入门&amp;日志&amp;配置文件详解</title>
    <link href="/2022/11/16/Mybatis%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/"/>
    <url>/2022/11/16/Mybatis%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8-%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6%E8%AF%A6%E8%A7%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><p>MyBatis 是一款优秀的持久层框架/半自动的ORM，它支持自定义 SQL、存储过程以及高级映射。MyBatis 免除了几乎所有的 JDBC 代码以及设置参数和获取结果集的工作。MyBatis 可以通过简单的 XML 或注解来配置和映射原始类型、接口和 Java POJO 为数据库中的记录。 </p><p><strong>优点：</strong> </p><ol><li>与 JDBC 相比，减少了50%的代码量 </li><li>最简单的持久化框架，简单易学</li><li>SQL 代码从程序代码中彻底分离出来，可以重用</li><li>提供 XML 标签，支持编写动态 SQL</li><li>提供映射标签，支持对象与数据库的 ORM 字段关系映射 </li><li>支持缓存、连接池、数据库移植….</li></ol><p>  <strong>缺点：</strong> </p><ol><li>SQL 语句编写工作量大，熟练度要高 </li><li>数据库移植性比较差，如果需要切换数据库的话，SQL 语句会有很大的差异</li></ol><h4 id="1-1-执行流程"><a href="#1-1-执行流程" class="headerlink" title="1.1 执行流程"></a>1.1 执行流程</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221116235420.png"></p><ol><li>加载  mybatis  全局配置文件（数据源、事务、mapper映射文件等），解析配置文件，MyBatis 基于 XML 配置文件生成 Configuration，和一个个 MappedStatement（包括了参数映射配置、动态SQL语句、结果映射配置），其对应着 &lt;select | update | delete | insert&gt; 标签项。</li><li>SqlSessionFactoryBuilder 通过 Configuration 对象生成 SqlSessionFactory，用来开启 SqlSession。</li><li>SqlSession 对象完成和数据库的交互：<ul><li>用户程序调用 mybatis 接口层 api（即 Mapper 接口中的方法）</li><li>SqlSession 通过调用 api 的 Statement ID 找到对应的 MappedStatemen 对象</li><li>通过 Executor（负责动态SQL的生成和查询缓存的维护）将MappedStatement 对象进行解析，sql 参数转化、动态 sql 拼接，生成 jdbc Statement 对象</li><li>JDBC 执行 sql。</li><li>借助 MappedStatement 中的结果映射关系，将返回结果转化成 HashMap、JavaBean 等存储结构并返回。</li></ul></li></ol><h3 id="2-基本使用"><a href="#2-基本使用" class="headerlink" title="2. 基本使用"></a>2. 基本使用</h3><h4 id="2-1-pom-依赖"><a href="#2-1-pom-依赖" class="headerlink" title="2.1 pom 依赖"></a>2.1 pom 依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.30<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mybatis<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.5.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>驱动版本和数据库版本对应关系：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221115202610.png"></p><h4 id="2-2-创建数据表以及对应的实体类对象"><a href="#2-2-创建数据表以及对应的实体类对象" class="headerlink" title="2.2 创建数据表以及对应的实体类对象"></a>2.2 创建数据表以及对应的实体类对象</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Data</span><br><span class="hljs-meta">@AllArgsConstructor</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> id;<br>    String name;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">User</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-创建对应的-Mapper-接口"><a href="#2-3-创建对应的-Mapper-接口" class="headerlink" title="2.3 创建对应的 Mapper 接口"></a>2.3 创建对应的 Mapper 接口</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserMapper</span> </span>&#123;<br>    <span class="hljs-function">User <span class="hljs-title">selectUser</span><span class="hljs-params">(Integer id)</span></span>;<br><br>    <span class="hljs-meta">@Select(&quot;select * from t_user where id = #&#123;id&#125; &quot;)</span><br>    <span class="hljs-function">User <span class="hljs-title">selectUser2</span><span class="hljs-params">(Integer id)</span></span>;<br><br>    <span class="hljs-function">Integer <span class="hljs-title">insertUser</span><span class="hljs-params">(User user)</span></span>;<br><br>    <span class="hljs-function">Integer <span class="hljs-title">updateUser</span><span class="hljs-params">(User user)</span></span>;<br><br>    <span class="hljs-function">Integer <span class="hljs-title">deleteUser</span><span class="hljs-params">(Integer id)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-编写配置文件"><a href="#2-4-编写配置文件" class="headerlink" title="2.4 编写配置文件"></a>2.4 编写配置文件</h4><p><strong>mybatis-config.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.cj.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/debuggingworld&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;mapper resource=&quot;com/debuggingWorld/mapper/UserMapper.xml&quot;/&gt;--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper.UserMapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>驱动路径</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221115215302.png"></p><p><strong>UserMapper.xml</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">mapper</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Mapper 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-mapper.dtd&quot;</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mapper</span> <span class="hljs-attr">namespace</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper.UserMapper&quot;</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">select</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;selectUser&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo.User&quot;</span>&gt;</span><br>        SELECT * FROM t_user WHERE id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">select</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span>&gt;</span><br>        insert into t_user (name) values (#&#123;name&#125;)<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">update</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;updateUser&quot;</span>&gt;</span><br>        update t_user set name =  (#&#123;name&#125;) where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">update</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">delete</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;deleteUser&quot;</span>&gt;</span><br>        delete from t_user where id = #&#123;id&#125;<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">delete</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mapper</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-5-测试"><a href="#2-5-测试" class="headerlink" title="2.5 测试"></a>2.5 测试</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestMybatis</span> </span>&#123;<br>    SqlSessionFactory sqlSessionFactory;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        InputStream inputStream = Resources.getResourceAsStream(<span class="hljs-string">&quot;mybatis-config.xml&quot;</span>);<br>        <span class="hljs-keyword">this</span>.sqlSessionFactory = <span class="hljs-keyword">new</span> SqlSessionFactoryBuilder().build(inputStream);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基于 statementId 的方式执行 sql</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * &lt;mapper resource=&quot;com/debuggingWorld/mapper/UserMapper.xml&quot;/&gt;</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test01</span><span class="hljs-params">()</span> </span>&#123;<br><br>        <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>            User user = session.selectOne(<span class="hljs-string">&quot;com.debuggingWorld.mapper.UserMapper.selectUser&quot;</span>, <span class="hljs-number">1</span>);<br>            System.out.println(user);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基于接口绑定的方式</span><br><span class="hljs-comment">     * &lt;p&gt;</span><br><span class="hljs-comment">     * 1. 方法名要和 mapper 中对应操作节点 id 一致</span><br><span class="hljs-comment">     * 2. 方法返回类型要和 mapper 中对应操作节点 resultType 一致</span><br><span class="hljs-comment">     * 3. mapper 中对应操作节点的参数必须在方法参数中申明</span><br><span class="hljs-comment">     * 4. mapper 中的 namespace 必须和接口的完整限定名一致</span><br><span class="hljs-comment">     * 5. mybatis 全局配置文件 mappers 中添加申明   &lt;mapper class=&quot;com.debuggingWorld.mapper.UserMapper&quot;/&gt;</span><br><span class="hljs-comment">     * 6. 一定要将 mapper.xml 和接口放在同一级目录（maven 项目中只需要在 resources 中新建同样的目录结构即可，编译时会进行合并）</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test02</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>            UserMapper mapper = session.getMapper(UserMapper.class);<br>            User user = mapper.selectUser(<span class="hljs-number">1</span>);<br>            System.out.println(user);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 基于注解的方式</span><br><span class="hljs-comment">     * 1. 注解方式和xml方式可以共用，但是不能同一方法不能同时存在 xml id 和注解方式</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test03</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>            UserMapper mapper = session.getMapper(UserMapper.class);<br>            User user = mapper.selectUser2(<span class="hljs-number">1</span>);<br>            System.out.println(user);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test04</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">try</span> (SqlSession session = sqlSessionFactory.openSession()) &#123;<br>            UserMapper mapper = session.getMapper(UserMapper.class);<br>            User user = <span class="hljs-keyword">new</span> User(<span class="hljs-number">17</span>, <span class="hljs-string">&quot;zhangsan&quot;</span>);<br>            Integer result = mapper.updateUser(user);<br>            System.out.println(result);<br>            <span class="hljs-comment">// 默认手动提交</span><br>            session.commit();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221117214922.png"></p><h3 id="3-日志"><a href="#3-日志" class="headerlink" title="3. 日志"></a>3. 日志</h3><p><a href="https://mybatis.org/mybatis-3/zh/logging.html">mybatis 日志模块文档</a></p><p>Mybatis 通过使用内置的日志工厂提供日志功能。内置日志工厂将会把日志工作委托给下面的实现之一：</p><ul><li>SLF4J</li><li>Apache Commons Logging</li><li>Log4j 2</li><li>Log4j （3.5.9 起废弃）</li><li>JDK logging</li></ul><p>MyBatis 内置日志工厂基于运行时自省机制选择合适的日志工具。它会使用第一个查找得到的工具（按上文列举的顺序查找）。如果一个都未找到，日志功能就会被禁用。<br>如果你的应用部署在一个类路径已经包含 Commons Logging 的环境中，而你又想使用其它日志工具，你可以通过在 MyBatis 配置文件 mybatis-config.xml 里面添加一项 setting 来选择别的日志工具。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;logImpl&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;SLF4J&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-1-SLF4J-Logback"><a href="#3-1-SLF4J-Logback" class="headerlink" title="3.1 SLF4J + Logback"></a>3.1 SLF4J + Logback</h4><p><a href="https://github.com/YLongo/logback-chinese-manual">logback 中文文档</a></p><p>1、添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.slf4j<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>slf4j-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.7.36<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>ch.qos.logback<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>logback-classic<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2.11<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>2、配置文件<br>应用的类路径中创建一个名称为 logback.xml 的文件</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">appender</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;ch.qos.logback.core.ConsoleAppender&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">encoder</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">pattern</span>&gt;</span>%d&#123;HH:mm:ss.SSS&#125; [%thread] %-5level %logger&#123;36&#125; - %msg%n<span class="hljs-tag">&lt;/<span class="hljs-name">pattern</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">encoder</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">appender</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--为指定包、类设置日志级别--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">logger</span> <span class="hljs-attr">name</span> = <span class="hljs-string">&quot;com.debuggingWorld.mapper.UserMapper&quot;</span> <span class="hljs-attr">level</span> = <span class="hljs-string">&quot;DEBUG&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--全局设置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">root</span> <span class="hljs-attr">level</span>=<span class="hljs-string">&quot;ERROR&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">appender-ref</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;STDOUT&quot;</span> /&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">root</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><p>level 属性的值可以为：TRACE、DEBUG、INFO、WARN、ERROR、ALL、OFF。</p><p>3、测试</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221120201234.png"></p><h3 id="4-配置文件"><a href="#4-配置文件" class="headerlink" title="4. 配置文件"></a>4. 配置文件</h3><h4 id="4-1-全局配置文件"><a href="#4-1-全局配置文件" class="headerlink" title="4.1 全局配置文件"></a>4.1 全局配置文件</h4><p><a href="https://mybatis.org/mybatis-3/zh/configuration.html">mybatis 配置文档</a></p><p>执行器类型：</p><ul><li>SIMPLE：普通的执行器</li><li>REUSE：执行器会重用预处理语句（PreparedStatement）</li><li>BATCH：执行器不仅重用语句还会执行批量更新。</li></ul><p>内置别名</p><table><thead><tr><th><div style="width:150px">别名</div></th><th><div style="width:150px">映射的类型</div></th></tr></thead><tbody><tr><td>_byte</td><td>byte</td></tr><tr><td>_char (since 3.5.10)</td><td>char</td></tr><tr><td>_character (since 3.5.10)</td><td>char</td></tr><tr><td>_long</td><td>long</td></tr><tr><td>_short</td><td>short</td></tr><tr><td>_int</td><td>int</td></tr><tr><td>_integer</td><td>int</td></tr><tr><td>_double</td><td>double</td></tr><tr><td>_float</td><td>float</td></tr><tr><td>_boolean</td><td>boolean</td></tr><tr><td>string</td><td>String</td></tr><tr><td>byte</td><td>Byte</td></tr><tr><td>char (since 3.5.10)</td><td>Character</td></tr><tr><td>character (since 3.5.10)</td><td>Character</td></tr><tr><td>long</td><td>Long</td></tr><tr><td>short</td><td>Short</td></tr><tr><td>int</td><td>Integer</td></tr><tr><td>integer</td><td>Integer</td></tr><tr><td>double</td><td>Double</td></tr><tr><td>float</td><td>Float</td></tr><tr><td>boolean</td><td>Boolean</td></tr><tr><td>date</td><td>Date</td></tr><tr><td>decimal</td><td>BigDecimal</td></tr><tr><td>bigdecimal</td><td>BigDecimal</td></tr><tr><td>biginteger</td><td>BigInteger</td></tr><tr><td>object</td><td>Object</td></tr><tr><td>date[]</td><td>Date[]</td></tr><tr><td>decimal[]</td><td>BigDecimal[]</td></tr><tr><td>bigdecimal[]</td><td>BigDecimal[]</td></tr><tr><td>biginteger[]</td><td>BigInteger[]</td></tr><tr><td>object[]</td><td>Object[]</td></tr><tr><td>map</td><td>Map</td></tr><tr><td>hashmap</td><td>HashMap</td></tr><tr><td>list</td><td>List</td></tr><tr><td>arraylist</td><td>ArrayList</td></tr><tr><td>collection</td><td>Collection</td></tr><tr><td>iterator</td><td>Iterator</td></tr></tbody></table><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-meta">&lt;!DOCTYPE <span class="hljs-meta-keyword">configuration</span></span><br><span class="hljs-meta">        <span class="hljs-meta-keyword">PUBLIC</span> <span class="hljs-meta-string">&quot;-//mybatis.org//DTD Config 3.0//EN&quot;</span></span><br><span class="hljs-meta">        <span class="hljs-meta-string">&quot;http://mybatis.org/dtd/mybatis-3-config.dtd&quot;</span>&gt;</span><br><span class="hljs-comment">&lt;!--就是 DOCTYPE 后面对应的根节点--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--配置外部属性资源文件  通过$&#123;&#125;进行引用--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">properties</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;db.properties&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--可以在定义内部的属性  引用方式是一样的--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mysql.username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--mybatis的设置选项  可以改变mybatis运行时行为--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">settings</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--是否允许在SQL中使用别名  默认是允许： 当设置别名后会根据 SQL 的别名和属性名进行映射  </span><br><span class="hljs-comment">（不会去设置该选项）</span><br><span class="hljs-comment">        &lt;setting name=&quot;useColumnLabel&quot; value=&quot;true&quot;/&gt;--&gt;</span><br><br>        <span class="hljs-comment">&lt;!--用于当字段名和属性名自动映射不匹配时 发生的动作</span><br><span class="hljs-comment">            默认：NONE      什么都不发生，没有映射上就不赋值</span><br><span class="hljs-comment">                 WARNING   发送一条级别为WARN的日志</span><br><span class="hljs-comment">                 FAILING   当映射不上直接报错</span><br><span class="hljs-comment">                 通常不会去设置</span><br><span class="hljs-comment">        &lt;setting name=&quot;autoMappingUnknownColumnBehavior&quot; value=&quot;FAILING&quot;/&gt;</span><br><span class="hljs-comment">        --&gt;</span><br><br>        <span class="hljs-comment">&lt;!--设置默认执行器</span><br><span class="hljs-comment">        SIMPLE 就是普通的执行器； 默认</span><br><span class="hljs-comment">        REUSE 执行器会重用预处理语句（PreparedStatement）；</span><br><span class="hljs-comment">        BATCH 执行器不仅重用语句还会执行批量更新。</span><br><span class="hljs-comment">        &lt;setting name=&quot;defaultExecutorType&quot; value=&quot;REUSE&quot;/&gt;</span><br><span class="hljs-comment">        --&gt;</span><br><br>        <span class="hljs-comment">&lt;!--设置查询的超时时间  单位：秒</span><br><span class="hljs-comment">        &lt;setting name=&quot;defaultStatementTimeout&quot; value=&quot;1&quot;/&gt;</span><br><span class="hljs-comment">        --&gt;</span><br><br>        <span class="hljs-comment">&lt;!--是否将数据库的蛇形命名映射为驼峰命名</span><br><span class="hljs-comment">        可以支持 蛇形 debug_world   到驼峰 debugWorld  或 debugworld   的自动映射</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">setting</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;mapUnderscoreToCamelCase&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><br>        <span class="hljs-comment">&lt;!--当往数据库插入数据某个数据值为 null 时映射到数据库的类型</span><br><span class="hljs-comment">        默认：OTHER   mysql 是可以识别出 OTHER 类型的</span><br><span class="hljs-comment">             NULL    如果是 oracle 一定要设置成 NULL, ORACLE 识别不出 OTHER 类型</span><br><span class="hljs-comment">             VARCHAR 当属性值为空时为数据库设置一个空字符串</span><br><span class="hljs-comment">        &lt;setting name=&quot;jdbcTypeForNull&quot; value=&quot;OTHER&quot;/&gt;--&gt;</span><br><br>        <span class="hljs-comment">&lt;!--加入 mybatis 框架中实现了多个日志框架， 可以使用 logImpl 来设置使用的日志框架</span><br><span class="hljs-comment">        &lt;setting name=&quot;logImpl&quot; value=&quot;SLF4J&quot;/&gt;</span><br><span class="hljs-comment">        --&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">settings</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--类型别名可为 Java 类型设置一个缩写名字。 它仅用于 XML 配置，意在降低冗余的全限定类名书写--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">typeAliases</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--根据包设置包里面所有的类的别名 :会将类的名字作为别名（忽略大小写）</span><br><span class="hljs-comment">            还可以为包里面的类单独设置个性别名：@Alias   （默认的以类的名字作为别名就会失效）</span><br><span class="hljs-comment">            除了可以设置自定义的类的别名以为，mybatis 还内置很多常见类型的别名</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.debuggingWorld.pojo&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;typeAlias alias=&quot;User&quot; type=&quot;com.debuggingWorld.pojo.User&quot;/&gt;--&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">typeAliases</span>&gt;</span><br><br><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">     插件：可以把它理解成mybatis的拦截器，可以拦截4大对象，可以拦截SQL 给SQL去加一些公共的功能</span><br><span class="hljs-comment">     &lt;plugins&gt;</span><br><span class="hljs-comment">         &lt;plugin interceptor=&quot;org.mybatis.example.ExamplePlugin&quot;&gt;</span><br><span class="hljs-comment">             &lt;property name=&quot;someProperty&quot; value=&quot;100&quot;/&gt;</span><br><span class="hljs-comment">         &lt;/plugin&gt;</span><br><span class="hljs-comment">     &lt;/plugins&gt;--&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- environments 可以多个环境</span><br><span class="hljs-comment">       default 默认的数据库环境</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">environments</span> <span class="hljs-attr">default</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--environment  配置数据库环境  id 指定当前数据库环境的唯一表示，  会被父节点default所设置--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;development&quot;</span>&gt;</span><br>            <span class="hljs-comment">&lt;!--事务管理器 类型</span><br><span class="hljs-comment">              type = JDBC  使用jdbc的事务管理</span><br><span class="hljs-comment">                     MANAGED  不运用事务</span><br><span class="hljs-comment">            --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-comment">&lt;!--数据源</span><br><span class="hljs-comment">                type 指定连接池</span><br><span class="hljs-comment">                POOLED  指定使用mybatis的连接池</span><br><span class="hljs-comment">                UNPOOLED 不使用连接池</span><br><span class="hljs-comment">                JNDI JNDI连接池 可以在 tomcat 中使用</span><br><span class="hljs-comment">            --&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.driver&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.url&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.username&#125;&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;mysql.password&#125;&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br><br><br>        <span class="hljs-tag">&lt;<span class="hljs-name">environment</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;test&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">transactionManager</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;JDBC&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">dataSource</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;POOLED&quot;</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driver&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/mybatis_test&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">dataSource</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">environment</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">environments</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    数据库厂商表示：mybatis 提供用于跨数据库平台，用于根据不同的数据库调用不同SQL</span><br><span class="hljs-comment">    type=&quot;DB_VENDOR&quot; 利用数据库的厂商名称来区分</span><br><span class="hljs-comment">    步骤：</span><br><span class="hljs-comment">        1.为需要跨越数据库设置不同的厂商名称</span><br><span class="hljs-comment">        2.编写不同的SQL   databaseId 必须指定厂商的value</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">databaseIdProvider</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;DB_VENDOR&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;MySQL&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;Oracle&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;ora&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">databaseIdProvider</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--设置映射器--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mappers</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--4种映射方式</span><br><span class="hljs-comment">                1.&lt;mapper resource   设置MapperXml 这种方式适用根据statementId进行操作</span><br><span class="hljs-comment">                2.&lt;mapper class      设置Mapper接口 这种方式适用接口绑定的方式和注解</span><br><span class="hljs-comment">                3.&lt;mapper url        使用磁盘的绝对路径（基本不用）</span><br><span class="hljs-comment">                4.&lt;package           根据包设置包下面所有的Mapper接口, 这种方式适用接口绑定的方式和注解</span><br><span class="hljs-comment">        --&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;mapper resource=&quot;com/debuggingWorld/mapper/UserMapper.xml&quot;/&gt;--&gt;</span><br>        <span class="hljs-comment">&lt;!--&lt;mapper class=&quot;com.debuggingWorld.mapper.UserMapper&quot;/&gt;--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">package</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;com.debuggingWorld.mapper&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mappers</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="4-2-SQL-映射文件"><a href="#4-2-SQL-映射文件" class="headerlink" title="4.2 SQL 映射文件"></a>4.2 SQL 映射文件</h4><p><a href="https://mybatis.org/mybatis-3/zh/sqlmap-xml.html">xml 映射文件文档</a></p><p>SQL 映射文件只有很少的几个顶级元素（按照应被定义的顺序列出）：</p><ul><li>cache – 该命名空间的缓存配置。</li><li>cache-ref – 引用其它命名空间的缓存配置。</li><li>resultMap – 描述如何从数据库结果集中加载对象，是最复杂也是最强大的元素。</li><li>sql – 可被其它语句引用的可重用语句块。</li><li>insert – 映射插入语句。</li><li>update – 映射更新语句。</li><li>delete – 映射删除语句。</li><li>select – 映射查询语句。</li></ul><p><strong>insert、update、delete元素：</strong></p><table><thead><tr><th>属性</th><th>描述</th></tr></thead><tbody><tr><td>id</td><td>在命名空间中唯一的标识符，可以被用来引用这条语句。</td></tr><tr><td>parameterType</td><td>将会传入这条语句的参数的类全限定名或别名。这个属性是可选的，因为 MyBatis 可以通过类型处理器（TypeHandler）推断出具体传入语句的参数，默认值为未设置（unset）。</td></tr><tr><td>flushCache</td><td>将其设置为 true 后，只要语句被调用，都会导致本地缓存和二级缓存被清空，默认值：（对 insert、update 和 delete 语句）true。</td></tr><tr><td>timeout</td><td>这个设置是在抛出异常之前，驱动程序等待数据库返回请求结果的秒数。默认值为未设置（unset）（依赖数据库驱动）。</td></tr><tr><td>statementType</td><td>可选 STATEMENT，PREPARED 或 CALLABLE。这会让 MyBatis 分别使用 Statement，PreparedStatement 或 CallableStatement，默认值：PREPARED。</td></tr><tr><td>useGeneratedKeys</td><td>（仅适用于 insert 和 update）这会令 MyBatis 使用 JDBC 的 getGeneratedKeys 方法来取出由数据库内部生成的主键（比如：像 MySQL 和 SQL Server 这样的关系型数据库管理系统的自动递增字段），默认值：false。</td></tr><tr><td>keyProperty</td><td>（仅适用于 insert 和 update）指定能够唯一识别对象的属性，MyBatis 会使用 getGeneratedKeys 的返回值或 insert 语句的 selectKey 子元素设置它的值，默认值：未设置（unset）。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr><tr><td>keyColumn</td><td>（仅适用于 insert 和 update）设置生成键值在表中的列名，在某些数据库（像 PostgreSQL）中，当主键列不是表中的第一列的时候，是必须设置的。如果生成列不止一个，可以用逗号分隔多个属性名称。</td></tr><tr><td>databaseId</td><td>如果配置了数据库厂商标识（databaseIdProvider），MyBatis 会加载所有不带 databaseId 或匹配当前 databaseId 的语句；如果带和不带的语句都有，则不带的会被忽略。</td></tr></tbody></table><h5 id="主键回填"><a href="#主键回填" class="headerlink" title="主键回填"></a>主键回填</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser&quot;</span> <span class="hljs-attr">useGeneratedKeys</span>=<span class="hljs-string">&quot;true&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span>&gt;</span><br>    insert into user(user_name) values(#&#123;userName&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br><span class="hljs-comment">&lt;!--如果数据库不支持自增的话，那么可以使用如下的方式进行赋值查询--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">insert</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;insertUser2&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">selectKey</span> <span class="hljs-attr">order</span>=<span class="hljs-string">&quot;BEFORE&quot;</span> <span class="hljs-attr">keyProperty</span>=<span class="hljs-string">&quot;id&quot;</span> <span class="hljs-attr">resultType</span>=<span class="hljs-string">&quot;integer&quot;</span>&gt;</span><br>        select max(id)+1 from user<br>    <span class="hljs-tag">&lt;/<span class="hljs-name">selectKey</span>&gt;</span><br>    insert into user(id,user_name) values(#&#123;id&#125;,#&#123;userName&#125;)<br><span class="hljs-tag">&lt;/<span class="hljs-name">insert</span>&gt;</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Mybatis</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC——父子容器启动源码解析</title>
    <link href="/2022/11/06/SpringMVC%E2%80%94%E2%80%94%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/11/06/SpringMVC%E2%80%94%E2%80%94%E7%88%B6%E5%AD%90%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.processon.com/view/link/637251aa6376897f2b764170">https://www.processon.com/view/link/637251aa6376897f2b764170</a></p><h3 id="1-SPI"><a href="#1-SPI" class="headerlink" title="1. SPI"></a>1. SPI</h3><p>SPI 全称 Service Provider Interface，是 Java 提供的一套用来被第三方实现或者扩展的接口，它可以用来启用框架扩展和替换组件。 SPI 的作用就是为这些被扩展的 API 寻找服务实现。</p><h4 id="1-1-SPI-和-API"><a href="#1-1-SPI-和-API" class="headerlink" title="1.1 SPI 和 API"></a>1.1 SPI 和 API</h4><blockquote><p>API （Application Programming Interface）在大多数情况下，都是实现方制定接口并完成对接口的实现，调用方仅仅依赖接口调用，且无权选择不同实现。 从使用人员上来说，API 直接被应用开发人员使用。<br>SPI （Service Provider Interface）是调用方来制定接口规范，提供给外部来实现，调用方在调用时则选择自己需要的外部实现。  从使用人员上来说，SPI 被框架扩展人员使用。</p></blockquote><h4 id="1-2-使用"><a href="#1-2-使用" class="headerlink" title="1.2 使用"></a>1.2 使用</h4><p>1、服务提供者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IUserDao</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221108201608.png"></p><p>2、服务实现者</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUserDao</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">save</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;spi_implementer UserDaoImpl&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>resources\META-INF\services\com.debuggingWorld.dao.IUserDao</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs stylus">com<span class="hljs-selector-class">.debuggingWorld</span><span class="hljs-selector-class">.dao</span><span class="hljs-selector-class">.impl</span>.UserDaoImpl<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221108201909.png"></p><p>3、测试</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ServiceLoader&lt;IUserDao&gt; daos = ServiceLoader.load(IUserDao.class);<br>        <span class="hljs-keyword">for</span> (IUserDao dao : daos) &#123;<br>            dao.save();<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-Spring-整合-SpringMVC"><a href="#2-Spring-整合-SpringMVC" class="headerlink" title="2. Spring 整合 SpringMVC"></a>2. Spring 整合 SpringMVC</h3><h4 id="2-1-特性"><a href="#2-1-特性" class="headerlink" title="2.1 特性"></a>2.1 特性</h4><p>说到 Spring 整合 SpringMVC 唯一的体现就是父子容器：</p><ul><li>通常设置父容器（Spring）管理 Service、Dao 层的 Bean, 子容器（SpringMVC）管理 Controller 的 Bean</li><li>子容器可以访问父容器的 Bean, 父容器无法访问子容器的 Bean。</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221107212226.png"></p><h4 id="2-2-实现"><a href="#2-2-实现" class="headerlink" title="2.2 实现"></a>2.2 实现</h4><p> 相信大家在 SSM 框架整合的时候都曾在 web.xm l配置过这段：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--spring 基于web应用的启动--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">listener</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">listener-class</span>&gt;</span>org.springframework.web.context.ContextLoaderListener<span class="hljs-tag">&lt;/<span class="hljs-name">listener-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">listener</span>&gt;</span><br><span class="hljs-comment">&lt;!--全局参数：spring配置文件--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context-param</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-core.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context-param</span>&gt;</span><br><span class="hljs-comment">&lt;!--前端调度器servlet--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--设置配置文件的路径--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:spring-mvc.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--设置启动即加载--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>dispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p>有人可能只知道 DispatcherServlet 叫前端控制器，是 SpringMVC 处理前端请求的一个核心调度器。那它为什么能处理请求？处理之前做了什么准备工作呢？又是怎么和 Spring 结合起来的呢？<br>为什么有了 DispatcherServlet 还要个 ContextLoaderListener， 配一个不行吗？干嘛要配俩啊？ </p><h3 id="3-零配置整合-SpringMVC-的方式"><a href="#3-零配置整合-SpringMVC-的方式" class="headerlink" title="3. 零配置整合 SpringMVC 的方式"></a>3. 零配置整合 SpringMVC 的方式</h3><p>没有配置就需要省略掉 web.xml，怎么省略呢？</p><p>在 Servlet3.0 提供的规范文档中可以找到2种方式。</p><h4 id="3-1-注解方式"><a href="#3-1-注解方式" class="headerlink" title="3.1 注解方式"></a>3.1 注解方式</h4><p>@WebServlet<br>@WebFilter<br>@WebListener</p><p>但是这种方式不利于扩展， 并且如果编写在 jar 包中 tomcat 是无法感知到的。</p><h4 id="3-2-SPI方式"><a href="#3-2-SPI方式" class="headerlink" title="3.2 SPI方式"></a>3.2 SPI方式</h4><p>在 Serlvet3-1 的规范手册中：就提供了一种更加易于扩展可用于共享库可插拔的一种方式，参见8.2.4。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221108210913.png"></p><p>也就是在应用 META-INF/services 路径下放一个 javax.servlet.ServletContainerInitailizer</p><p>通过 ServletContext 就可以动态注册三大组件。<br>以 Servlet 注册为例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugServletContainerInitializer</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ServletContainerInitializer</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onStartup</span><span class="hljs-params">(Set&lt;Class&lt;?&gt;&gt; webAppInitializerClasses, ServletContext servletContext)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br><br>        <span class="hljs-comment">// 通过servletContext动态添加Servlet</span><br>        servletContext.addServlet(<span class="hljs-string">&quot;spiServlet&quot;</span>, <span class="hljs-keyword">new</span> HttpServlet() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>                resp.getWriter().write(<span class="hljs-string">&quot;spiServlet--doGet&quot;</span>);<br>            &#125;<br>        &#125;).addMapping(<span class="hljs-string">&quot;/spiServlet.do&quot;</span>);<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221108213454.png"></p><h3 id="4-实现基于-SPI-规范的-SpringMVC"><a href="#4-实现基于-SPI-规范的-SpringMVC" class="headerlink" title="4. 实现基于 SPI 规范的 SpringMVC"></a>4. 实现基于 SPI 规范的 SpringMVC</h3><h4 id="4-1-启动类"><a href="#4-1-启动类" class="headerlink" title="4.1 启动类"></a>4.1 启动类</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugStarterInitializer</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractAnnotationConfigDispatcherServletInitializer</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * IOC 父容器的启动类</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getRootConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Class[]&#123;RootConfig.class&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * ICO 子容器配置  web容器配置</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> Class&lt;?&gt;[] getServletConfigClasses() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Class[]&#123;WebAppConfig.class&#125;;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 前端控制器拦截路径</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">protected</span> String[] getServletMappings() &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;/&quot;</span>&#125;;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-父容器配置类"><a href="#4-2-父容器配置类" class="headerlink" title="4.2 父容器配置类"></a>4.2 父容器配置类</h4><p>扫描的包排除掉 @Controller</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.debuggingWorld&quot;,excludeFilters = &#123;</span><br><span class="hljs-meta">        @ComponentScan.Filter(type = FilterType.ANNOTATION,value = Controller.class),</span><br><span class="hljs-meta">        @ComponentScan.Filter(type = FilterType.ASSIGNABLE_TYPE,value = WebAppConfig.class)</span><br><span class="hljs-meta">&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RootConfig</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-子容器配置类"><a href="#4-3-子容器配置类" class="headerlink" title="4.3 子容器配置类"></a>4.3 子容器配置类</h4><p>扫描包含 @Controller 的 Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(value = &quot;com.debuggingWorld&quot;, includeFilters = &#123;</span><br><span class="hljs-meta">        @ComponentScan.Filter(type = FilterType.ANNOTATION, value = &#123;RestController.class, Controller.class&#125;)</span><br><span class="hljs-meta">&#125;, useDefaultFilters = false)</span><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 等价于 &lt;mvc:annotation-driven/&gt;</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@EnableWebMvc</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebAppConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 配置拦截器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DebugInterceptor <span class="hljs-title">debugInterceptor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DebugInterceptor();<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 文件上传下载的组件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MultipartResolver <span class="hljs-title">multipartResolver</span><span class="hljs-params">()</span> </span>&#123;<br>        CommonsMultipartResolver multipartResolver = <span class="hljs-keyword">new</span> CommonsMultipartResolver();<br>        multipartResolver.setDefaultEncoding(<span class="hljs-string">&quot;UTF-8&quot;</span>);<br>        multipartResolver.setMaxUploadSize(<span class="hljs-number">1024</span> * <span class="hljs-number">1024</span> * <span class="hljs-number">10</span>);<br>        <span class="hljs-keyword">return</span> multipartResolver;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 注册处理国际化资源的组件</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> AcceptHeaderLocaleResolver <span class="hljs-title">localeResolver</span><span class="hljs-params">()</span> </span>&#123;<br>        AcceptHeaderLocaleResolver acceptHeaderLocaleResolver = <span class="hljs-keyword">new</span> AcceptHeaderLocaleResolver();<br>        <span class="hljs-keyword">return</span> acceptHeaderLocaleResolver;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">addInterceptors</span><span class="hljs-params">(InterceptorRegistry registry)</span> </span>&#123;<br>        registry.addInterceptor(debugInterceptor()).addPathPatterns(<span class="hljs-string">&quot;/*&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 配置视图解析器</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> InternalResourceViewResolver <span class="hljs-title">internalResourceViewResolver</span><span class="hljs-params">()</span> </span>&#123;<br>        InternalResourceViewResolver viewResolver = <span class="hljs-keyword">new</span> InternalResourceViewResolver();<br>        viewResolver.setSuffix(<span class="hljs-string">&quot;.jsp&quot;</span>);<br>        viewResolver.setPrefix(<span class="hljs-string">&quot;/WEB-INF/jsp/&quot;</span>);<br>        <span class="hljs-keyword">return</span> viewResolver;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">configureMessageConverters</span><span class="hljs-params">(List&lt;HttpMessageConverter&lt;?&gt;&gt; converters)</span> </span>&#123;<br>        converters.add(<span class="hljs-keyword">new</span> MappingJackson2HttpMessageConverter());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-SPI-方式-SpringMVC-启动原理"><a href="#5-SPI-方式-SpringMVC-启动原理" class="headerlink" title="5. SPI 方式 SpringMVC 启动原理"></a>5. SPI 方式 SpringMVC 启动原理</h3><h4 id="5-1-加载-ServletContainerInitializer-实现类"><a href="#5-1-加载-ServletContainerInitializer-实现类" class="headerlink" title="5.1 加载 ServletContainerInitializer 实现类"></a>5.1 加载 ServletContainerInitializer 实现类</h4><p>外置 Tomcat 启动的时候通过 SPI 找到我们应用中的 /META-INF/service/javax.servlet.ServletContainerInitializer</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221108213905.png"></p><p>1、调用 SpringServletContainerInitializer.onStartUp()</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221113202229.png"></p><p>调用 onStartUp() 前会先通过 @HandlesTypes 找到所有实现了 WebApplicationInitializer 接口的类，传入到 OnStartup 的 webAppInitializerClasses 参数中，并传入Servlet上下文对象。</p><p>启动类继承关系（组成了父子容器）：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/DebugStarterInitializer%E7%BB%A7%E6%89%BF%E5%85%B3%E7%B3%BB123werwre.png"></p><p>2、找到所有 WebApplicationInitializer 接口的实现类后， 不是接口、不是抽象类则通过反射进行实例化。</p><blockquote><p>所以，会发现内部实现类都是抽象的，想让其起作用必须添加一个自定义实现类。</p></blockquote><p>3、 调用上一步实例化对象的 onStartup() 方法</p><p>在这一步完成 父子容器的创建以及 ContextLoaderListener、DispatcherServlet 的注册。</p><p>过程详见思维导图。</p><h4 id="5-2-初始化-ContextLoaderListener"><a href="#5-2-初始化-ContextLoaderListener" class="headerlink" title="5.2 初始化 ContextLoaderListener"></a>5.2 初始化 ContextLoaderListener</h4><ul><li>外置 tomcat 会帮我们调用 ContextLoaderListener#contextInitialized 进行初始化。</li><li>xml 的方式下判断容器为空时创建父容器。</li><li>在里面会调用父容器的 <strong>refresh()</strong> 方法</li><li>将父容器存入到 Servlet 域中供子容器使用</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/%E5%88%9D%E5%A7%8B%E5%8C%96ContextLoaderListener.png"></p><h4 id="5-3-初始化-DispatcherServlet"><a href="#5-3-初始化-DispatcherServlet" class="headerlink" title="5.3 初始化 DispatcherServlet"></a>5.3 初始化 DispatcherServlet</h4><p>外置 tomcat 会帮我们调用 DispatcherServlet#init()   进行初始化</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221114212011.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221114220618.png"></p><p>—-&gt;FrameworkServlet.this.onApplicationEvent(event);<br>——–&gt;onRefresh(event.getApplicationContext());<br>————–&gt;initStrategies(context);</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initStrategies</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;<br><span class="hljs-comment">//初始化我们web上下文对象的 用于文件上传下载的解析器对象</span><br>initMultipartResolver(context);<br><span class="hljs-comment">//初始化我们web上下文对象用于处理国际化资源的</span><br>initLocaleResolver(context);<br><span class="hljs-comment">//主题解析器对象初始化</span><br>initThemeResolver(context);<br><span class="hljs-comment">//初始化我们的HandlerMapping</span><br>initHandlerMappings(context);<br><span class="hljs-comment">//实例化我们的HandlerAdapters</span><br>initHandlerAdapters(context);<br><span class="hljs-comment">//实例化我们处理器异常解析器对象</span><br>initHandlerExceptionResolvers(context);<br>initRequestToViewNameTranslator(context);<br><span class="hljs-comment">//给DispatcherServlet的ViewResolvers处理器</span><br>initViewResolvers(context);<br>initFlashMapManager(context);<br>&#125;<br></code></pre></td></tr></table></figure><p>这里面的每一个方法不用太细看，  就是给 SpringMVC 准备初始化的数据，  为后续 SpringMVC 处理请求做准备</p><p>基本都是从容器中拿到已经配置的 Bean（RequestMappingHandlerMapping、RequestMappingHandlerAdapter、HandlerExceptionResolver  ）放到 dispatcherServlet 中做准备。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221114221050.png"></p><p>但是这些 Bean 又是从哪来的呢？？  </p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(value = &quot;com.debuggingWorld&quot;, includeFilters = &#123;</span><br><span class="hljs-meta">        @ComponentScan.Filter(type = FilterType.ANNOTATION, value = &#123;RestController.class, Controller.class&#125;)</span><br><span class="hljs-meta">&#125;, useDefaultFilters = false)</span><br><span class="hljs-meta">@EnableWebMvc</span>  <span class="hljs-comment">// 等价于 &lt;mvc:annotation-driven/&gt;</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">WebAppConfig</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">WebMvcConfigurer</span> </span>&#123;<br>……<br>&#125;<br></code></pre></td></tr></table></figure><p>我们在子容器配置类中使用了 @EnableWebMvc 。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Target(ElementType.TYPE)</span><br><span class="hljs-meta">@Documented</span><br><span class="hljs-meta">@Import(DelegatingWebMvcConfiguration.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> EnableWebMvc &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>导入了 DelegatingWebMvcConfiguration。<br>DelegatingWebMvcConfiguration 的父类配置了这些 Bean。<br>SpringBoot 也是用的这种方式，</p><p><a href="https://www.processon.com/view/link/610e6a167d9c082be334ec49">https://www.processon.com/view/link/610e6a167d9c082be334ec49</a></p>]]></content>
    
    
    <categories>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMVC</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC——请求过程源码解析</title>
    <link href="/2022/11/03/SpringMVC%E2%80%94%E2%80%94%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/11/03/SpringMVC%E2%80%94%E2%80%94%E8%AF%B7%E6%B1%82%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.processon.com/view/link/6367b742e401fd612f4d38c6">https://www.processon.com/view/link/6367b742e401fd612f4d38c6</a></p><h3 id="1-从-Servlet-到-SpringMVC"><a href="#1-从-Servlet-到-SpringMVC" class="headerlink" title="1. 从 Servlet 到 SpringMVC"></a>1. 从 Servlet 到 SpringMVC</h3><p>传统Servlet：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221103210258.png"></p><p>弊端：<br>1.xml 下配置 servlet 映射非常麻烦，开发效率低。<br>2.必须要继承父类、重写方法，侵入性强。<br>3.参数解析麻烦<br>4.数据响应麻烦，手动转成 json 并设置 Content-type<br>5.跳转页面麻烦</p><h3 id="2-SpringMVC-的请求流程"><a href="#2-SpringMVC-的请求流程" class="headerlink" title="2. SpringMVC 的请求流程"></a>2. SpringMVC 的请求流程</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221103212425.png"></p><ul><li>DispatcherServlet： 前端调度器 ， 负责将请求拦截下来分发到各控制器方法</li><li>HandlerMapping: 负责根据请求的 URL 和 @RequestMapping 映射去匹配， 匹配到会返回Handler（具体控制器的方法）</li><li>HandlerAdaper: 负责调用 Handler 具体方法，返回视图名字（ModelAndView）</li><li>ViewReslover: 根据 ModelAndView 里面的视图名去找到具体的 jsp 封装在 View 对象中</li><li>View：进行视图渲染（将 jsp 转换成 html 内容，这是 Servlet 容器的事情了） 最终 response 到的客户端</li></ul><ol><li>用户发送请求至前端控制器 DispatcherServlet</li><li>DispatcherServlet 收到请求调用处理器映射器 HandlerMapping。<ul><li>处理器映射器根据请求 url 找到具体的处理器，生成处理器执行链 HandlerExecutionChain (包括处理器对象和处理器拦截器) 一并返回给 DispatcherServlet。</li></ul></li><li>DispatcherServlet 根据处理器 Handler 获取处理器适配器 HandlerAdapter，执行 HandlerAdapter 处理一系列的操作，如：参数封装，数据格式转换，数据验证等操作</li><li>执行处理器 Handler(Controller，也叫页面控制器)。<ul><li>Handler 执行完成返回 ModelAndView</li><li>HandlerAdapter 将 Handler 执行结果 ModelAndView 返回到 DispatcherServlet</li></ul></li><li>DispatcherServlet 将 ModelAndView 传给 ViewReslover 视图解析器<ul><li>ViewReslover 解析后返回具体 View</li></ul></li><li>DispatcherServlet 对 View 进行渲染视图（即将模型数据 model 填充至视图中）。</li><li>DispatcherServlet 响应用户。</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221106171340.png"></p><h3 id="3-RequestMapping-解析"><a href="#3-RequestMapping-解析" class="headerlink" title="3. @RequestMapping 解析"></a>3. @RequestMapping 解析</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221106211203.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221106211337.png"></p><h3 id="4-RequestMapping-映射"><a href="#4-RequestMapping-映射" class="headerlink" title="4. @RequestMapping 映射"></a>4. @RequestMapping 映射</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221106212732.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221106212841.png"></p>]]></content>
    
    
    <categories>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMVC</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC——上传下载&amp;拦截器&amp;国际化&amp;异常处理</title>
    <link href="/2022/10/23/SpringMVC%E2%80%94%E2%80%94%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD-%E6%8B%A6%E6%88%AA%E5%99%A8-%E5%9B%BD%E9%99%85%E5%8C%96-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2022/10/23/SpringMVC%E2%80%94%E2%80%94%E4%B8%8A%E4%BC%A0%E4%B8%8B%E8%BD%BD-%E6%8B%A6%E6%88%AA%E5%99%A8-%E5%9B%BD%E9%99%85%E5%8C%96-%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="1-文件下载"><a href="#1-文件下载" class="headerlink" title="1.  文件下载"></a>1.  文件下载</h3><h4 id="1-1-servlet-原生-API-实现下载"><a href="#1-1-servlet-原生-API-实现下载" class="headerlink" title="1.1 servlet 原生 API 实现下载"></a>1.1 servlet 原生 API 实现下载</h4><p>【注】idea 需先添加 Tomcat 依赖</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221023223136.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@WebServlet(&quot;/download&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DownloadServlet</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HttpServlet</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doGet</span><span class="hljs-params">(HttpServletRequest req, HttpServletResponse resp)</span> <span class="hljs-keyword">throws</span> ServletException, IOException </span>&#123;<br>        <span class="hljs-comment">//获取要下载的文件的绝对路径</span><br>        String realPath = <span class="hljs-keyword">this</span>.getServletContext().getRealPath(<span class="hljs-string">&quot;/file/debuggingWorld.jpg&quot;</span>);<br>        File tmpFile = <span class="hljs-keyword">new</span> File(realPath);<br>        resp.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=&quot;</span> + URLEncoder.encode(tmpFile.getName(), StandardCharsets.UTF_8.name()));<br>        InputStream in = <span class="hljs-keyword">new</span> FileInputStream(realPath);<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        OutputStream out = resp.getOutputStream();<br>        <span class="hljs-keyword">while</span> ((len = in.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;<br>            out.write(buffer, <span class="hljs-number">0</span>, len);<br>        &#125;<br>        in.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-Spring-MVC-实现下载"><a href="#1-2-Spring-MVC-实现下载" class="headerlink" title="1.2 Spring MVC 实现下载"></a>1.2 Spring MVC 实现下载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DownloadController</span> </span>&#123;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/download&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">download</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>        String realPath = request.getServletContext().getRealPath(<span class="hljs-string">&quot;/file/debuggingWorld.jpg&quot;</span>);<br>        File tmpFile = <span class="hljs-keyword">new</span> File(realPath);<br>        response.setHeader(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=&quot;</span> + URLEncoder.encode(tmpFile.getName(), StandardCharsets.UTF_8.name()));<br>        InputStream in = <span class="hljs-keyword">new</span> FileInputStream(realPath);<br>        <span class="hljs-keyword">int</span> len = <span class="hljs-number">0</span>;<br>        <span class="hljs-keyword">byte</span>[] buffer = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        OutputStream out = response.getOutputStream();<br>        <span class="hljs-keyword">while</span> ((len = in.read(buffer)) &gt; <span class="hljs-number">0</span>) &#123;<br>            out.write(buffer, <span class="hljs-number">0</span>, len);<br>        &#125;<br>        in.close();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-使用-RespsonseEntity-定制响应内容"><a href="#1-3-使用-RespsonseEntity-定制响应内容" class="headerlink" title="1.3 使用 RespsonseEntity 定制响应内容"></a>1.3 使用 RespsonseEntity 定制响应内容</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * ResponseEntity 可以同时定制文件的响应内容，响应头， 响应状态码</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;/responseEntity&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ResponseEntity&lt;String&gt; <span class="hljs-title">responseEntity</span><span class="hljs-params">()</span></span>&#123;<br>    String body=<span class="hljs-string">&quot;Hello debuggingWorld&quot;</span>;<br>    HttpHeaders headers=<span class="hljs-keyword">new</span> HttpHeaders();<br>    headers.set(<span class="hljs-string">&quot;Set-Cookie&quot;</span>,<span class="hljs-string">&quot;name=debuggingWorld&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(body,headers, HttpStatus.OK);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-使用-RespsonseEntity-实现下载"><a href="#1-4-使用-RespsonseEntity-实现下载" class="headerlink" title="1.4 使用 RespsonseEntity 实现下载"></a>1.4 使用 RespsonseEntity 实现下载</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于 spring ResponseEntity 的文件下载 不支持缓冲区</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;/download2&quot;)</span><br><span class="hljs-keyword">public</span> ResponseEntity&lt;<span class="hljs-keyword">byte</span>[]&gt; download02(HttpServletRequest request) <span class="hljs-keyword">throws</span> IOException &#123;<br>    String realPath = request.getServletContext().getRealPath(<span class="hljs-string">&quot;/file/debuggingWorld.jpg&quot;</span>);<br>    String fileName = <span class="hljs-keyword">new</span> File(realPath).getName();<br>    HttpHeaders headers = <span class="hljs-keyword">new</span> HttpHeaders();<br>    headers.set(<span class="hljs-string">&quot;Content-Disposition&quot;</span>, <span class="hljs-string">&quot;attachment;filename=&quot;</span> + URLEncoder.encode(fileName, <span class="hljs-string">&quot;UTF-8&quot;</span>));<br>    InputStream in = <span class="hljs-keyword">new</span> FileInputStream(realPath);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ResponseEntity&lt;&gt;(<span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[in.available()], headers, HttpStatus.OK);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-文件上传"><a href="#2-文件上传" class="headerlink" title="2. 文件上传"></a>2. 文件上传</h3><p>Spring MVC 为文件上传提供了直接的支持，这种支持是通过即插即用的 MultipartResolver 实现的。Spring 用 Jakarta Commons FileUpload 技术实现了一个 MultipartResolver 实现类：CommonsMultipartResovler<br>Spring MVC 上下文中默认没有装配 MultipartResovler，因此默认情况下不能处理文件的上传工作，如果想使用 Spring 的文件上传功能，需现在上下文中配置 MultipartResolver。</p><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-fileupload<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>Spring 配置</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;multipartResolver&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;maxUploadSize&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;#&#123;1024*1024&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;defaultEncoding&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;utf-8&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-1-idea-映射虚拟目录"><a href="#2-1-idea-映射虚拟目录" class="headerlink" title="2.1 idea 映射虚拟目录"></a>2.1 idea 映射虚拟目录</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221024095201.png"></p><p>【注】 /debugSpringMVC/img 为图片访问地址</p><h4 id="2-2-单文件上传"><a href="#2-2-单文件上传" class="headerlink" title="2.2 单文件上传"></a>2.2 单文件上传</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于springmvc MultiPartResolver文件上传</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PostMapping(&quot;/upload01&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload01</span><span class="hljs-params">(MultipartFile file, String desc, Model model)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    String path = <span class="hljs-string">&quot;D:\\temp\\&quot;</span> + file.getOriginalFilename();<br>    file.transferTo(<span class="hljs-keyword">new</span> File(path));<br>    <span class="hljs-comment">// 上传后添加文件名到域中</span><br>    model.addAttribute(<span class="hljs-string">&quot;filename&quot;</span>, file.getOriginalFilename());<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>success.jsp</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br><br>&lt;head&gt;<br>    &lt;title&gt;Title&lt;/title&gt;<br>&lt;/head&gt;<br>&lt;body&gt;<br>上传成功！<br>&lt;img src=<span class="hljs-string">&quot;$&#123;pageContext.request.contextPath&#125;/img/$&#123;filename&#125;&quot;</span>&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><h4 id="2-3-多文件上传"><a href="#2-3-多文件上传" class="headerlink" title="2.3 多文件上传"></a>2.3 多文件上传</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 基于springmvc MultiPartResolver多文件文件上传</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@PostMapping(&quot;/upload02&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">upload02</span><span class="hljs-params">(String desc, MultipartFile[] file)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    <span class="hljs-keyword">for</span> (MultipartFile multipartFile : file) &#123;<br>        String path = <span class="hljs-string">&quot;D:\\temp\\&quot;</span> + multipartFile.getOriginalFilename();<br>        multipartFile.transferTo(<span class="hljs-keyword">new</span> File(path));<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-拦截器"><a href="#3-拦截器" class="headerlink" title="3. 拦截器"></a>3. 拦截器</h3><p>SpringMVC 提供了拦截器机制，允许运行目标方法之前进行一些拦截工作或者目标方法运行之后进行一下其他相关的处理。自定义的拦截器必须实现 HandlerInterceptor 接口。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221024212922.png"></p><ul><li>preHandle：预处理回调方法，实现处理器的预处理（如登录检查），第三个参数为响应的处理器返回值：true表示继续流程（如调用下一个拦截器或处理器）；false 表示流程中断（如登录检查失败），不会继续调用其他的拦截器或处理器，此时我们需要通过 response 来产生响应；</li><li>postHandle：后处理回调方法，实现处理器的后处理（在渲染视图之前）， 此时可以通过 modelAndView 对模型数据进行处理或对视图进行处理，modelAndView 也可能为 null。如果处理器报错则不执行此方法。</li><li>afterCompletion：整个请求处理完毕回调方法，即在视图渲染完毕时回调，如性能监控中我们可以在此记录结束时间并输出消耗时间，还可以进行一些资源清 理，类似于 try-catch-finally 中的 finally，但仅调用处理器执行链中 preHandle 返回 true 的拦截器才会执行</li></ul><p>自定义拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">HandlerInterceptor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">preHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.getClass().getName()+<span class="hljs-string">&quot;‐‐‐‐‐‐‐ &gt;preHandle&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postHandle</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.getClass().getName()+<span class="hljs-string">&quot;‐‐‐‐‐‐‐ &gt;postHandle&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.getClass().getName()+<span class="hljs-string">&quot;‐‐‐‐‐‐‐&gt;afterCompletion&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 spring 配置中配置拦截器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/user/**&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:exclude-mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/xxx&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.debuggingWorld.interceptor.DebugInterceptor&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br></code></pre></td></tr></table></figure><p>拦截器的执行顺序如下：<br>preHandle方法  ===》执行目标方法  ===》执行拦截器的 postHandle 方法  ===》 执行页面跳转   ===》 执行拦截器的 afterCompletion 方法</p><p>在配置拦截器的时候有两个需要注意的点： </p><ol><li> 如果 prehandle 方法返回值为 false，那么意味着不放行，那么后续的所有操作都中断 </li><li> 如果执行到方法中出现异常，那么后续流程不会处理但是 afterCompletion 方法会执行</li></ol><h3 id="4-过滤器"><a href="#4-过滤器" class="headerlink" title="4. 过滤器"></a>4. 过滤器</h3><p>实现过滤器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugFilter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Filter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(FilterConfig filterConfig)</span> <span class="hljs-keyword">throws</span> ServletException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;过滤器 DebugFilter 初始化&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">doFilter</span><span class="hljs-params">(ServletRequest servletRequest, ServletResponse servletResponse, FilterChain filterChain)</span> <span class="hljs-keyword">throws</span> IOException, ServletException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;过滤器 DebugFilter 执行前&quot;</span>);<br>        filterChain.doFilter(servletRequest, servletResponse);<br>        System.out.println(<span class="hljs-string">&quot;过滤器 DebugFilter 执行后&quot;</span>);<br><br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;过滤器 DebugFilter 销毁&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 web.xml 中配置过滤器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>debugFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>com.debuggingWorld.Filter.DebugFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>debugFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--‐/*和/都是拦截所有请求，/会拦截的请求不包含*.jsp,而/*的范围更大，还会拦截*.jsp这些请求--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="5-拦截器和过滤器的区别"><a href="#5-拦截器和过滤器的区别" class="headerlink" title="5. 拦截器和过滤器的区别"></a>5. 拦截器和过滤器的区别</h3><ul><li>过滤器是基于函数回调的，而拦截器是基于j ava 反射的</li><li>过滤器依赖于 servlet 容器，而拦截器不依赖与 Servlet 容器，拦截器依赖 SpringMVC</li><li>过滤器几乎对所有的请求都可以起作用（jsp等），而拦截器只能对 SpringMVC 请求起作用</li><li>拦截器可以访问处理方法的上下文，而过滤器不可以</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221024224851.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221024225052.png"></p><p><a href="https://blog.csdn.net/JokerLJG/article/details/121538821">https://blog.csdn.net/JokerLJG/article/details/121538821</a></p><h3 id="5-国际化"><a href="#5-国际化" class="headerlink" title="5. 国际化"></a>5. 国际化</h3><h4 id="5-1-基本用法"><a href="#5-1-基本用法" class="headerlink" title="5.1 基本用法"></a>5.1 基本用法</h4><p>   1、 添加国际化文件</p><p>在 resources 目录下添加国际化文件</p><p><strong>i18n_en_US.properties：</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">login.username</span>=Username<br><span class="hljs-attr">login.password</span>=Password<br></code></pre></td></tr></table></figure><p><strong>i18n_zh_CN.properties:</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">login.username</span>=用户名<br><span class="hljs-attr">login.password</span>=用户密码<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221025224902.png"></p><p>2、 在 Spring 容器中提供一个 ResourceBundleMessageSource 实例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;org.springframework.context.support.ResourceBundleMessageSource&quot;</span> id=<span class="hljs-string">&quot;messageSource&quot;</span>&gt;<br>    &lt;property name=<span class="hljs-string">&quot;basename&quot;</span> value=<span class="hljs-string">&quot;i18n&quot;</span>/&gt;<br>    &lt;property name=<span class="hljs-string">&quot;defaultEncoding&quot;</span> value=<span class="hljs-string">&quot;UTF-8&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p> 3、 jsp 中使用国际化</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;%@ taglib prefix=<span class="hljs-string">&quot;spring&quot;</span> uri=<span class="hljs-string">&quot;http://www.springframework.org/tags&quot;</span> %&gt;<br>&lt;%@ page contentType=<span class="hljs-string">&quot;text/html;charset=UTF-8&quot;</span> language=<span class="hljs-string">&quot;java&quot;</span> %&gt;<br>&lt;html&gt;<br>&lt;head&gt;&lt;title&gt;Title&lt;/title&gt;&lt;/head&gt;<br>&lt;body&gt;<br>&lt;spring:message code=<span class="hljs-string">&quot;login.username&quot;</span>/&gt; &lt;input type=<span class="hljs-string">&quot;text&quot;</span>&gt;<br>&lt;br&gt;<br>&lt;spring:message code=<span class="hljs-string">&quot;login.password&quot;</span>/&gt; &lt;input type=<span class="hljs-string">&quot;text&quot;</span>&gt;<br>&lt;br&gt;<br>&lt;/body&gt;<br>&lt;/html&gt;<br></code></pre></td></tr></table></figure><p>通过 spring:message 标签来引用变量</p><p>4、 后端使用国际化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    MessageSource messageSource;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/login&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">()</span> </span>&#123;<br>        String username = messageSource.getMessage(<span class="hljs-string">&quot;login.username&quot;</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());<br>        String password = messageSource.getMessage(<span class="hljs-string">&quot;login.password&quot;</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());<br>        System.out.println(<span class="hljs-string">&quot;username = &quot;</span> + username);<br>        System.out.println(<span class="hljs-string">&quot;password = &quot;</span> + password);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【注意】注入 MessageSource 对象</p><h4 id="5-2-AcceptHeaderLocaleResolver"><a href="#5-2-AcceptHeaderLocaleResolver" class="headerlink" title="5.2 AcceptHeaderLocaleResolver"></a>5.2 AcceptHeaderLocaleResolver</h4><ul><li>默认情况下，SpringMVC 根据 Accept-Language 参数判断客户端的本地化类型。</li><li>当收到请求时，SpringMVC 会在上下文中查找-一个本地化解析器 (LocalResolver) ，找到后使用它获取请求所对应的本地化类型信息：Locale locale = request.getLocale()</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221025230651.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221025230801.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initLocaleResolver</span><span class="hljs-params">(ApplicationContext context)</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">this</span>.localeResolver = context.getBean(LOCALE_RESOLVER_BEAN_NAME, LocaleResolver.class);<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br><span class="hljs-comment">// We need to use the default.</span><br><span class="hljs-keyword">this</span>.localeResolver = getDefaultStrategy(context, LocaleResolver.class);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221025233443.png"></p><p><strong>测试：</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221025233337.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221025233417.png"></p><p>有的时候希望语言环境直接通过请求参数来传递，而不是通过请求头来传递，可以通过 SessionLocaleResolver 或 CookieLocaleResolver l来实现。</p><h4 id="5-3-SessionLocaleResolver"><a href="#5-3-SessionLocaleResolver" class="headerlink" title="5.3 SessionLocaleResolver"></a>5.3 SessionLocaleResolver</h4><p>SessionLocaleResolver 负责区域解析。<br>拦截器 LocaleChangeInterceptor 则主要是负责参数解析的，我们在配置拦截器的时候，设置了参数名为 locale（默认即此），也就是说我们将来可以通过 locale 参数来传递当前的环境信息。</p><p>在 Spring 配置文件中提供 SessionLocaleResolver 的实例，同时配置一个拦截器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptors</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">mvc:interceptor</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">mvc:mapping</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/**&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.i18n.LocaleChangeInterceptor&quot;</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;paramName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;locale&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptor</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">mvc:interceptors</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.i18n.SessionLocaleResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;localeResolver&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221025235215.png"></p><p>此时可以直接通过 locale 参数来控制当前的语言环境，这个 locale 参数就是在前面所配置的 LocaleChangeInterceptor 拦截器中被自动解析的。</p><p>如果不想配置 LocaleChangeInterceptor 拦截器也是可以的，直接手动解析 locale 参数然后设置 locale，像下面这样：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    MessageSource messageSource;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/login&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String locale, HttpSession session)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;zh-CN&quot;</span>.equals(locale)) &#123;<br>            session.setAttribute(SessionLocaleResolver.LOCALE_SESSION_ATTRIBUTE_NAME, <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">&quot;zh&quot;</span>, <span class="hljs-string">&quot;CN&quot;</span>));<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;en-US&quot;</span>.equals(locale)) &#123;<br>            session.setAttribute(SessionLocaleResolver.LOCALE_SESSION_ATTRIBUTE_NAME, <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">&quot;en&quot;</span>, <span class="hljs-string">&quot;US&quot;</span>));<br>        &#125;<br>        String username = messageSource.getMessage(<span class="hljs-string">&quot;login.username&quot;</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());<br>        String password = messageSource.getMessage(<span class="hljs-string">&quot;login.password&quot;</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());<br>        System.out.println(<span class="hljs-string">&quot;username = &quot;</span> + username);<br>        System.out.println(<span class="hljs-string">&quot;password = &quot;</span> + password);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-4-CookieLocaleResolver"><a href="#5-4-CookieLocaleResolver" class="headerlink" title="5.4 CookieLocaleResolver"></a>5.4 CookieLocaleResolver</h4><p>SessionLocaleResolver 所实现的功能也可以通过 CookieLocaleResolver 来实现，不同的是前者将解析出来的区域信息保存在 session 中，而后者则保存在 Cookie 中。保存在 session 中，只要 session 没有发生变化，后续就不用再次传递区域语言参数了，保存在 Cookie 中，只要 Cookie 没变，后续也不用再次传递区域语言参数了。</p><p>使用 CookieLocaleResolver 的方式很简单，直接在 Spring 中提供 CookieLocaleResolver 的实例即可，如下：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.i18n.CookieLocaleResolver&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;localeResolver&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>注意这里也需要使用到 LocaleChangeInterceptor 拦截器，如果不使用该拦截器，则需要自己手动解析并配置语言环境，手动解析并配置的方式如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoginController</span> </span>&#123;<br>    <span class="hljs-meta">@Autowired</span><br>    MessageSource messageSource;<br><br>    <span class="hljs-meta">@GetMapping(&quot;/login&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">login</span><span class="hljs-params">(String locale, HttpServletRequest req, HttpServletResponse resp)</span> </span>&#123;<br>        CookieLocaleResolver resolver = <span class="hljs-keyword">new</span> CookieLocaleResolver();<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;zh-CN&quot;</span>.equals(locale)) &#123;<br>            resolver.setLocale(req, resp, <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">&quot;zh&quot;</span>, <span class="hljs-string">&quot;CN&quot;</span>));<br>        &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;en-US&quot;</span>.equals(locale)) &#123;<br>            resolver.setLocale(req, resp, <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">&quot;en&quot;</span>, <span class="hljs-string">&quot;US&quot;</span>));<br>        &#125;<br>        String username = messageSource.getMessage(<span class="hljs-string">&quot;login.username&quot;</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());<br>        String password = messageSource.getMessage(<span class="hljs-string">&quot;login.password&quot;</span>, <span class="hljs-keyword">null</span>, LocaleContextHolder.getLocale());<br>        System.out.println(<span class="hljs-string">&quot;username = &quot;</span> + username);<br>        System.out.println(<span class="hljs-string">&quot;password = &quot;</span> + password);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;login&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-异常处理"><a href="#6-异常处理" class="headerlink" title="6. 异常处理"></a>6. 异常处理</h3><h4 id="6-1-内置异常处理解析器"><a href="#6-1-内置异常处理解析器" class="headerlink" title="6.1 内置异常处理解析器"></a>6.1 内置异常处理解析器</h4><p>在 SpringMVC 中拥有一套非常强大的异常处理机制，SpringMVC 通过 HandlerExceptionResolver 处理程序的异常，包括请求映射，数据绑定以及目标方法的执行时发生的异常。</p><p>在容器启动好，进入 DispatcherServlet 之后，会对 HandlerExceptionResolver 进行初始化操作：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221031225911.png"></p><p>默认从 DispatcherServlet.properties 中找到对应的异常处理类：</p><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs stylus">org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span>.HandlerExceptionResolver=org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.mvc</span><span class="hljs-selector-class">.method</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.ExceptionHandlerExceptionResolver</span>,\<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.mvc</span><span class="hljs-selector-class">.annotation</span><span class="hljs-selector-class">.ResponseStatusExceptionResolver</span>,\<br>org<span class="hljs-selector-class">.springframework</span><span class="hljs-selector-class">.web</span><span class="hljs-selector-class">.servlet</span><span class="hljs-selector-class">.mvc</span><span class="hljs-selector-class">.support</span>.DefaultHandlerExceptionResolver<br></code></pre></td></tr></table></figure><p>AbstractHandlerMethodExceptionResolver 是 ExceptionHandlerExcpetionResolver父 类。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221031230641.png"></p><p><strong>SimpleMappingExceptionResolver</strong>：通过配置的异常类和view的对应关系解析异常<br><a href="https://blog.csdn.net/bingguang1993/article/details/104491542/">https://blog.csdn.net/bingguang1993/article/details/104491542/</a></p><p>通过 @ExceptionHandler 处理异常<br>如果 @ExceptionHandler 写在 @Controller 中只能处理当前控制器类的处理方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleException</span><span class="hljs-params">(Exception ex)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;@Controller异常处理&quot;</span>);<br>    ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView();<br>    modelAndView.setViewName(<span class="hljs-string">&quot;error&quot;</span>);<br>    modelAndView.addObject(<span class="hljs-string">&quot;ex&quot;</span>, ex);<br>    StringWriter sw = <span class="hljs-keyword">new</span> StringWriter();<br>    PrintWriter pw = <span class="hljs-keyword">new</span> PrintWriter(sw);<br>    ex.printStackTrace(pw);<br>    <span class="hljs-comment">// 日志记录</span><br>    System.out.println(sw.toString());<br>    <span class="hljs-keyword">return</span> modelAndView;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-2-统一异常处理"><a href="#6-2-统一异常处理" class="headerlink" title="6.2 统一异常处理"></a>6.2 统一异常处理</h4><p>@ControllerAdvice 是 Spring3.2 提供的新注解，它是对 Controller 的增强,可对 controller 中被 @RequestMapping 注解的方法加一些逻辑处理：</p><ol><li>全局异常处理 </li><li>全局数据绑定 </li><li>全局数据预处理</li></ol><p>@ExceptionHandler 加在 Controller 中，只处理当前控制器的异常，优先级比全局高。加在 ControllerAdvice 中 ，处理全局异常。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ControllerAdvice</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">GeneralExceptionHandler</span> </span>&#123;<br><br>    <span class="hljs-meta">@ExceptionHandler(Exception.class)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">handleException</span><span class="hljs-params">(HttpServletRequest request,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        HttpServletResponse reponse, Exception ex,</span></span><br><span class="hljs-params"><span class="hljs-function">                                        HandlerMethod handle)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;全局异常处理&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (request.getHeader(<span class="hljs-string">&quot;Accept&quot;</span>).contains(<span class="hljs-string">&quot;application/json&quot;</span>)) &#123;<br>            <span class="hljs-comment">// 集成jackson的方式：</span><br>            <span class="hljs-comment">//ModelAndView 同时支持视图返回和json返回</span><br>            <span class="hljs-comment">// 这种方式就是返回json</span><br>            ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-keyword">new</span> MappingJackson2JsonView());<br>            <span class="hljs-comment">// 通常会根据不同的异常返回不同的编码</span><br>            modelAndView.addObject(<span class="hljs-string">&quot;code&quot;</span>, HttpStatus.INTERNAL_SERVER_ERROR.value());<br>            modelAndView.addObject(<span class="hljs-string">&quot;message&quot;</span>, ex.getMessage());<br>            <span class="hljs-keyword">return</span> modelAndView;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView();<br>            modelAndView.setViewName(<span class="hljs-string">&quot;error&quot;</span>);<br>            modelAndView.addObject(<span class="hljs-string">&quot;ex&quot;</span>, ex);<br>            StringWriter sw = <span class="hljs-keyword">new</span> StringWriter();<br>            PrintWriter pw = <span class="hljs-keyword">new</span> PrintWriter(sw);<br>            ex.printStackTrace(pw);<br>            System.out.println(sw.toString());   <span class="hljs-comment">// 日志记录</span><br>            <span class="hljs-keyword">return</span> modelAndView;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC——JSON处理&amp;数据格式化&amp;数据验证</title>
    <link href="/2022/10/06/SpringMVC%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96-%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81/"/>
    <url>/2022/10/06/SpringMVC%E2%80%94%E2%80%94%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2-%E6%95%B0%E6%8D%AE%E6%A0%BC%E5%BC%8F%E5%8C%96-%E6%95%B0%E6%8D%AE%E9%AA%8C%E8%AF%81/</url>
    
    <content type="html"><![CDATA[<h3 id="1-JSON-处理"><a href="#1-JSON-处理" class="headerlink" title="1. JSON 处理"></a>1. JSON 处理</h3><p>pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-core<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-databind<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.fasterxml.jackson.core<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>jackson-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.13.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>spring 配置</strong>：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/fc3bc70b9ed3">https://www.jianshu.com/p/fc3bc70b9ed3</a><br> <a href="https://blog.csdn.net/u011066470/article/details/112438252">https://blog.csdn.net/u011066470/article/details/112438252</a></p><p>【注】idea 开发 Spring MVC，需要手动将依赖添加到 lib 下。</p><h4 id="1-1-返回-JSON-数据"><a href="#1-1-返回-JSON-数据" class="headerlink" title="1.1 返回 JSON 数据"></a>1.1 返回 JSON 数据</h4><h5 id="ResponseBody"><a href="#ResponseBody" class="headerlink" title="@ResponseBody"></a>@ResponseBody</h5><p>使用 @ResponseBody 不跳转视图，返回 json 字符串作为响应结果。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/debug&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    User user = <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;xxxxx&quot;</span>);<br>    <span class="hljs-keyword">return</span> user.toString();<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h5><p>将当前 controller 的所有接口定义为返回 json。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/debug&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;xxxxx&quot;</span>);<br>        <span class="hljs-keyword">return</span> user.toString();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-获取-JSON-数据"><a href="#1-2-获取-JSON-数据" class="headerlink" title="1.2 获取 JSON 数据"></a>1.2 获取 JSON 数据</h4><p>@RequestBody 用来接收前端传递给后端的 json 字符串中的数据(请求体中的数据)。</p><ol><li> 以简单对象接收前端传过来的 json 数据</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/debug&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> User user)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> user.toString();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221019085110.png"></p><ol start="2"><li>用字符串接收 json 对象<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@PostMapping(&quot;/debug&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-meta">@RequestBody</span> String user)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221019231042.png"></p><p><a href="https://www.cnblogs.com/zzsuje/articles/10329948.html">https://www.cnblogs.com/zzsuje/articles/10329948.html</a></p><h5 id="JsonProperty-amp-JsonAlias"><a href="#JsonProperty-amp-JsonAlias" class="headerlink" title="@JsonProperty  &amp; @JsonAlias"></a>@JsonProperty  &amp; @JsonAlias</h5><p>@JsonAlias 注解，为指定的属性添加别名。<br>@JsonProperty 注解，为指定的属性修改名称。<br>@JsonAlias 注解需要依赖于 setter、getter，而 @JsonProperty 注解不需要。</p><h3 id="2-数据格式化"><a href="#2-数据格式化" class="headerlink" title="2. 数据格式化"></a>2. 数据格式化</h3><h4 id="2-1-DateTimeFormat"><a href="#2-1-DateTimeFormat" class="headerlink" title="2.1 @DateTimeFormat"></a>2.1 @DateTimeFormat</h4><p>@DateTimeFormat 可以用来格式化 java.util.Date、java.util.Calendar 和  java.util.Long 类型</p><p>DateTimeFormat 互斥属性：</p><ul><li>iso。类型为 DateTimeFormat.ISO <ul><li>DateTimeFormat.ISO.DATE: 格式 yyyy-MM-dd。 </li><li>DateTimeFormat.ISO.DATE_TIME: 格式 yyyy-MM- dd HH:mm:ss .SSSZ。</li><li>DateTimeFormat.ISO.TIME: 格式 HH:mm:ss .SSSZ。</li><li>DateTimeFormat.ISO.NONE: 表示不使用 ISO 格式的时间。 </li></ul></li><li>pattern。类型为 String，使用自定义的时间格式化字符串。 </li><li>style。类型为 String，通过样式指定日期时间的格式，由两位字符组成，第 1 位表示日期的样式，第 2 位表示时间的格式：<ul><li> S: 短日期/时间的样式</li><li> M: 中日期/时间的样式</li><li> L: 长日期/时间的样式</li><li> F: 完整日期/时间的样式</li><li> -: 忽略日期/时间的样式</li></ul></li></ul><p><a href="https://blog.csdn.net/imVainiycos/article/details/102712056">https://blog.csdn.net/imVainiycos/article/details/102712056</a></p><p>只有在 表单请求（application/x-www-form-urlencoded）中其作用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Integer id;<br>    <span class="hljs-keyword">public</span> String userName;<br>    <span class="hljs-meta">@DateTimeFormat(pattern = &quot;yyyy/MM/dd&quot;)</span><br>    <span class="hljs-keyword">private</span> Calendar birthday;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221020200612.png"></p><h4 id="2-2-NumberFormat"><a href="#2-2-NumberFormat" class="headerlink" title="2.2 @NumberFormat"></a>2.2 @NumberFormat</h4><p>@NumberFormat 可以用来格式化任何数字的基本类型（如int，long）或 java.lang.Number的实例（如 BigDecimal, Integer)。</p><p>NumberFormat 互斥属性：</p><ul><li>pattern：类型 String，使用自定义的数字格式化串，如 ##,### 表示 50,000</li><li>style：类型 NumberFormat.Style，几个常用值<ul><li>Style.CURRENCY：货币类型</li><li>Style.NUMBER：正常数字类型</li><li>Style.PERCENT：百分比类型</li></ul></li></ul><p><a href="https://blog.csdn.net/weixin_38192427/article/details/122270716">https://blog.csdn.net/weixin_38192427/article/details/122270716</a></p><h3 id="3-数据校验"><a href="#3-数据校验" class="headerlink" title="3. 数据校验"></a>3. 数据校验</h3><p><a href="https://blog.csdn.net/weixin_44335140/article/details/111152171">https://blog.csdn.net/weixin_44335140/article/details/111152171</a></p><p>JSR303 是 Java 为 Bean 数据合法性校验提供的标准，它已经包含在 JavaEE 6.0 中 。JSR 303 （Java Specification Requests 意思是Java 规范提案) 通过在 Bean 属性上标注类似于 @NotNull、@Max 等标准的注解指定校验规则，并通过标准的验证接口对 Bean 进行验证。<br>Hibernate Validator 实现了JSR349 验证注解规范的技术。</p><p>JSR303:：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221019213246.png"></p><p>Hibernate Validator 扩展注解:</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221019213510.png"></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221020201058.png"></p><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- https://mvnrepository.com/artifact/org.hibernate.validator/hibernate-validator --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.hibernate.validator<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>hibernate-validator<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>6.0.16.Final<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> </span>&#123;<br>    <span class="hljs-keyword">public</span> Integer id;<br>    <span class="hljs-meta">@NotEmpty(message = &quot;用户名不能为空&quot;)</span><br>    <span class="hljs-keyword">public</span> String userName;<br>    <span class="hljs-meta">@Past</span><br>    <span class="hljs-keyword">private</span> Calendar birthday;<br>    <span class="hljs-meta">@Range(min = 1000, max = 100000)</span><br>    <span class="hljs-keyword">private</span> Integer salary;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/debug&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-meta">@Valid</span> <span class="hljs-meta">@RequestBody</span> User user, BindingResult result)</span> </span>&#123;<br><br>    <span class="hljs-keyword">if</span> (result.hasErrors()) &#123;<br>        <span class="hljs-keyword">return</span> result.getFieldErrors().toString();<br>    &#125;<br>    <span class="hljs-keyword">return</span> user.toString();<br>&#125;<br></code></pre></td></tr></table></figure><p>@RestControllerAdvice<br><a href="https://blog.csdn.net/qq_36829919/article/details/101210250">@ControllerAdvice 的介绍及三种用法</a></p>]]></content>
    
    
    <categories>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>SpringMVC——使用&amp;请求处理&amp;响应处理</title>
    <link href="/2022/09/14/SpringMVC%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8&amp;%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86&amp;%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86/"/>
    <url>/2022/09/14/SpringMVC%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8&amp;%E8%AF%B7%E6%B1%82%E5%A4%84%E7%90%86&amp;%E5%93%8D%E5%BA%94%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="1-SpringMVC-执行流程"><a href="#1-SpringMVC-执行流程" class="headerlink" title="1. SpringMVC 执行流程"></a>1. SpringMVC 执行流程</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/SpringMVC%E6%89%A7%E8%A1%8C%E6%B5%81%E7%A8%8Bjhjzhcuuidhai.png"></p><ol><li>DispatcherServlet：前端控制器，是整个 SpringMVC 的控制中心。DispatcherServlet 接收用户发出的请求并拦截。</li><li>HandlerMapping：处理器映射。DispatcherServlet 调用 HandlerMapping，HandlerMapping 根据请求 url 查找 Handler。 </li><li>返回处理器执行链，根据 url 查找控制器，并且将解析后的信息传递给 DispatcherServlet</li><li>HandlerAdapter：处理器适配器，其按照特定的规则去执行 handler 找到的具体处理器</li><li>Controller 将具体的执行信息返回给 HandlerAdapter，如 ModelAndView。</li><li>HandlerAdapter 将视图逻辑名或模型传递给 DispatcherServlet。</li><li>DispatcherServlet 调用视图解析器（ViewResolver）来解析 HandlerAdapter 传递的逻辑视图名。</li><li>视图解析器将解析的逻辑视图名传给 DispatcherServlet。</li><li>DispatcherServlet 根据视图解析器解析的视图结果，调用具体的视图，进行试图渲染 </li><li>将响应数据返回给客户端</li></ol><h3 id="2-基于注解的-SpringMVC"><a href="#2-基于注解的-SpringMVC" class="headerlink" title="2. 基于注解的 SpringMVC"></a>2. 基于注解的 SpringMVC</h3><h4 id="2-1-添加-pom-依赖"><a href="#2-1-添加-pom-依赖" class="headerlink" title="2.1 添加 pom 依赖"></a>2.1 添加 pom 依赖</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.22<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220914224113.png"></p><h4 id="2-2-web-xml-文件"><a href="#2-2-web-xml-文件" class="headerlink" title="2.2 web.xml 文件"></a>2.2 web.xml 文件</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">web-app</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://xmlns.jcp.org/xml/ns/javaee http://xmlns.jcp.org/xml/ns/javaee/web-app_4_0.xsd&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">version</span>=<span class="hljs-string">&quot;4.0&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--‐配置 DispatcherServlet--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>debugSpringMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-class</span>&gt;</span>org.springframework.web.servlet.DispatcherServlet<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-class</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--关联 springmvc 的配置文件--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>contextConfigLocation<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>classpath:springMVC.xml<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--容器启动时加载 servlet--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">load-on-startup</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">load-on-startup</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--‐匹配servlet的请求，/标识匹配所有请求--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">servlet-mapping</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">servlet-name</span>&gt;</span>debugSpringMVC<span class="hljs-tag">&lt;/<span class="hljs-name">servlet-name</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--‐/*和/都是拦截所有请求，/会拦截的请求不包含*.jsp,而/*的范围更大，还会拦截*.jsp这些请求--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">servlet-mapping</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">web-app</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-3-spring-配置文件"><a href="#2-3-spring-配置文件" class="headerlink" title="2.3 spring 配置文件"></a>2.3 spring 配置文件</h4><p>springMVC.xml</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:context</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/context&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd http://www.springframework.org/schema/context https://www.springframework.org/schema/context/spring-context.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.debuggingWorld&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-4-Controller"><a href="#2-4-Controller" class="headerlink" title="2.4 Controller"></a>2.4 Controller</h4><p>HelloController.java</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-meta">@RequestMapping(&quot;/hello&quot;)</span><br>    <span class="hljs-meta">@ResponseBody</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span></span>&#123;<br>        <span class="hljs-keyword">return</span> name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【注】idea 创建 web 项目需要手动将依赖加入 WEB-INF/lib</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220914225230.png"></p><h3 id="3-请求参数处理"><a href="#3-请求参数处理" class="headerlink" title="3. 请求参数处理"></a>3. 请求参数处理</h3><h4 id="3-1-SpringMVC-对请求参数的处理"><a href="#3-1-SpringMVC-对请求参数的处理" class="headerlink" title="3.1  SpringMVC 对请求参数的处理"></a>3.1  SpringMVC 对请求参数的处理</h4><ul><li>@RequestParam：获取请求的参数</li><li>@RequestHeader：获取请求头信息</li><li>@CookieValue：获取cookie中的值</li></ul><h5 id="RequestParam-的基本使用"><a href="#RequestParam-的基本使用" class="headerlink" title="@RequestParam 的基本使用"></a>@RequestParam 的基本使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认情况下，方法参数接收跟请求中参数名一致的参数值</span><br><span class="hljs-comment">     * 如果有值，直接赋值，如果没有，那么直接给空值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/param&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + name;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@RequestParam</span> 使用此注解之后，参数的名称不需要跟请求 的名称一致，但是必须有值</span><br><span class="hljs-comment">     * public String hello11(<span class="hljs-doctag">@RequestParam</span>(&quot;name&quot;) String name)</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 此注解还包含三个参数：</span><br><span class="hljs-comment">     * value:表示要获取的参数值</span><br><span class="hljs-comment">     * required：表示此参数是否必须，默认是true，如果不写参数那么会报错， 如果值为false，那么不写参数不会有任何错误</span><br><span class="hljs-comment">     * defaultValue:如果在使用的时候没有传递参数，那么定义默认值即可</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/param1&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello1</span><span class="hljs-params">(<span class="hljs-meta">@RequestParam(value = &quot;name&quot;,required = false,defaultValue = &quot;debuggingWorld&quot;)</span> String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="RequestHeader-的基本使用"><a href="#RequestHeader-的基本使用" class="headerlink" title="@RequestHeader 的基本使用"></a>@RequestHeader 的基本使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 相当于 request.getHeader(&quot;Host&quot;)</span><br><span class="hljs-comment"> * 默认 required 为 true，没有值报错</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * 注解中也包含三 个参数： value  required   defaultValue</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;/header&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">header</span><span class="hljs-params">(<span class="hljs-meta">@RequestHeader(value = &quot;Host&quot;,required = false)</span> String host)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + host;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="CookieValue-的基本使用"><a href="#CookieValue-的基本使用" class="headerlink" title="@CookieValue 的基本使用"></a>@CookieValue 的基本使用</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 相当于 :</span><br><span class="hljs-comment"> * Cookie[] cookies = request.getCookies();</span><br><span class="hljs-comment"> * for (Cookie cookie : cookies) &#123;</span><br><span class="hljs-comment"> *     System.out.println(cookie.getValue());</span><br><span class="hljs-comment"> * &#125;</span><br><span class="hljs-comment"> * </span><br><span class="hljs-comment"> * 默认 required 为 true，没有值报错</span><br><span class="hljs-comment"> * 注解中也包含三 个参数： value  required   defaultValue</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;/cookie&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">cookie</span><span class="hljs-params">(<span class="hljs-meta">@CookieValue(value = &quot;JSESSIONID&quot;, required = false)</span> String id)</span> </span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + id;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="复杂数据类型处理"><a href="#复杂数据类型处理" class="headerlink" title="复杂数据类型处理"></a>复杂数据类型处理</h5><p><strong>application/x-www-form-urlencoded 类型请求</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/addUser&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">user</span><span class="hljs-params">( User user)</span> </span>&#123;<br>    System.out.println(user);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello:&quot;</span> + user;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220921234714.png"></p><h4 id="3-2-字符编码过滤器（解决乱码）"><a href="#3-2-字符编码过滤器（解决乱码）" class="headerlink" title="3.2  字符编码过滤器（解决乱码）"></a>3.2  字符编码过滤器（解决乱码）</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">filter</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-class</span>&gt;</span>org.springframework.web.filter.CharacterEncodingFilter<span class="hljs-tag">&lt;/<span class="hljs-name">filter-class</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>utf-8<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--同时开启请求和响应的编码设置--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">init-param</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-name</span>&gt;</span>forceEncoding<span class="hljs-tag">&lt;/<span class="hljs-name">param-name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">param-value</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">param-value</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">init-param</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">filter-mapping</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">filter-name</span>&gt;</span>encoding<span class="hljs-tag">&lt;/<span class="hljs-name">filter-name</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">url-pattern</span>&gt;</span>/*<span class="hljs-tag">&lt;/<span class="hljs-name">url-pattern</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">filter-mapping</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>注意：如果配置了多个过滤器，那么字符编码过滤器一定要在最前面，否则失效。</strong></p><h4 id="3-3-SpringMVC-对原生-API-的支持"><a href="#3-3-SpringMVC-对原生-API-的支持" class="headerlink" title="3.3 SpringMVC 对原生 API 的支持"></a>3.3 SpringMVC 对原生 API 的支持</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * SpringMVC 也可以在参数上使用原生的 Servlet API</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * HttpSession</span><br><span class="hljs-comment"> * HttpServletRequest</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * java.security.Principal 安全协议相关</span><br><span class="hljs-comment"> * Locale：国际化相关的区域信息对象</span><br><span class="hljs-comment"> *  InputStream:</span><br><span class="hljs-comment"> *          ServletInputStream inputStream = request.getInputStream();</span><br><span class="hljs-comment"> *  OutputStream:</span><br><span class="hljs-comment"> *          ServletOutputStream outputStream = response.getOutputStream();</span><br><span class="hljs-comment"> *  Reader:</span><br><span class="hljs-comment"> *          BufferedReader reader = request.getReader();</span><br><span class="hljs-comment"> *  Writer:</span><br><span class="hljs-comment"> *          PrintWriter writer = response.getWriter();</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;api&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">api</span><span class="hljs-params">(HttpSession session, HttpServletRequest request, HttpServletResponse response)</span> </span>&#123;<br>    request.setAttribute(<span class="hljs-string">&quot;requestParam&quot;</span>, <span class="hljs-string">&quot;request&quot;</span>);<br>    session.setAttribute(<span class="hljs-string">&quot;sessionParam&quot;</span>, <span class="hljs-string">&quot;session&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;success&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-请求映射处理"><a href="#4-请求映射处理" class="headerlink" title="4. 请求映射处理"></a>4. 请求映射处理</h3><h4 id="4-1-RequestMapping"><a href="#4-1-RequestMapping" class="headerlink" title="4.1 @RequestMapping"></a>4.1 @RequestMapping</h4><p>@RequestMapping 用来匹配客户端发送的请求，可以在方法上使用， 也可以在类上使用。<br>方法：表示用来匹配要处理的请求<br>类上：表示为当前类的所有方法的请求地址添加一个前置路径，访问的时候必须要添加此路径</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RestController</span><br><span class="hljs-meta">@RequestMapping(&quot;/debugging&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@RequestMapping(&quot;/world&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + name;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>@RequestMapping 注解还可以添加很多额外的属性值，用来精确匹配请求</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * RequestMapping 的其他属性值：</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * value:要匹配的请求路径</span><br><span class="hljs-comment"> * method:限制发送请求的方式： POST GET</span><br><span class="hljs-comment"> * params:表示请求要接受的参数,如果定义了这个属性，那么发送的时候必须要添加参数</span><br><span class="hljs-comment"> *    params 有几种匹配规则</span><br><span class="hljs-comment"> *      1. 包含某个参数,不包含则报错  params= &#123;&quot;name&quot;&#125;</span><br><span class="hljs-comment"> *      2. 不包含某个参数,包含则报错  params= &#123;&quot;!name&quot;&#125;</span><br><span class="hljs-comment"> *      3. 请求数据中指定参数名=值   params= &#123;&quot;name=tom&quot;&#125;</span><br><span class="hljs-comment"> *      4. 请求数据中指定参数名!=值  params= &#123;&quot;name!=tom&quot;&#125;</span><br><span class="hljs-comment"> *      5. 组合使用是&quot;且&quot;的关系  params= &#123;&quot;id&quot;,&quot;name!=tom&quot;&#125;</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * headers:填写请求头需要包含或不包含的信息    https://blog.csdn.net/weixin_44137201/article/details/108567673</span><br><span class="hljs-comment"> * consumers:只接受内容类型是哪种的请求，相当于指定 Content‐Type</span><br><span class="hljs-comment"> * produces:返回的内容类型 Content‐Type：text/html;charset=utf‐8</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(value = &quot;/world&quot;,params = &#123;&quot;name =aaa&quot;&#125; ,headers = &#123;&quot;Content-Type=application/json&quot;&#125;,</span><br><span class="hljs-meta">        consumes = &#123;&quot;application/json&quot;&#125;,produces = &#123;&quot;application/json&quot;&#125;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + name;<br>&#125;<br></code></pre></td></tr></table></figure><p>@RequestMapping 支持通配符的匹配。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@RequestMapping</span> 包含三种模糊匹配的方式：</span><br><span class="hljs-comment"> * ?：能替代任意一个字符</span><br><span class="hljs-comment"> * *：能替代任意多个字符和一层路径</span><br><span class="hljs-comment"> * **：能代替多层路径</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;/**/h*llo?&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(String name)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;hello&quot;</span> + name;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-PathVariable"><a href="#4-2-PathVariable" class="headerlink" title="4.2 @PathVariable"></a>4.2 @PathVariable</h4><p>@PathVariable 注解提供了对占位符 URL 的支持，就是将 URL 中占位符参数绑定到控制器处理方法的参数中。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PostMapping(&quot;/user/&#123;id&#125;/&#123;name&#125;&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-meta">@PathVariable(&quot;id&quot;)</span> Integer userId, <span class="hljs-meta">@PathVariable(&quot;name&quot;)</span> String userName)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(userId, userName, <span class="hljs-keyword">null</span>).toString();<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-静态资源访问"><a href="#4-3-静态资源访问" class="headerlink" title="4.3 静态资源访问"></a>4.3 静态资源访问</h4><p>Spring 配置中添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--此配置表示我们自己配置的请求由 controller 来处理，不能处理的请求交由 tomcat 来处理</span><br><span class="hljs-comment">    静态资源可以访问，但是动态请求无法访问</span><br><span class="hljs-comment"> --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:default-servlet-handler</span>/&gt;</span><br><span class="hljs-comment">&lt;!--保证静态资源和动态请求都能够访问--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">mvc:annotation-driven</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><a href="http://www.yiidian.com/springmvc/static-resource.html">http://www.yiidian.com/springmvc/static-resource.html</a></p><h3 id="5-响应处理"><a href="#5-响应处理" class="headerlink" title="5. 响应处理"></a>5. 响应处理</h3><h4 id="5-1-使用默认内置视图解析器（ViewResolver）"><a href="#5-1-使用默认内置视图解析器（ViewResolver）" class="headerlink" title="5.1 使用默认内置视图解析器（ViewResolver）"></a>5.1 使用默认内置视图解析器（ViewResolver）</h4><p>【注】WEB-INF 下的 jsp 不能直接访问。</p><p>SpringMVC 默认视图解析器：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221003224751.png"></p><p>添加自定义视图解析器前访问 jsp：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;debug&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;/WEB-INF/index.jsp&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>添加自定义视图解析器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!--默认视图解析器，简化逻辑视图名称--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.web.servlet.view.InternalResourceViewResolver&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;viewResolver&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;prefix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;/WEB-INF/&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;suffix&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;.jsp&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加自定义视图解析器后访问 jsp：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/debug&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如果希望不执行自定义视图解析器,在方法返回值前面添加 forward:或 redirect:</strong></p><h4 id="5-2-使用视图控制器-lt-view-controller-gt"><a href="#5-2-使用视图控制器-lt-view-controller-gt" class="headerlink" title="5.2 使用视图控制器 &lt;view-controller&gt;"></a>5.2 使用视图控制器 &lt;view-controller&gt;</h4><p>如果有些请求只是想跳转页面，不需要来后台处理什么逻辑，不需要在 Action 中写 一个空方法来跳转，直接配置一个视图跳转控制器即可。</p><p>在 Spring 配置文件中添加：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">mvc:view-controller</span> <span class="hljs-attr">path</span>=<span class="hljs-string">&quot;/&quot;</span> <span class="hljs-attr">view-name</span>=<span class="hljs-string">&quot;index&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="5-3-使用Model，Map，ModelMap传输数据到页面"><a href="#5-3-使用Model，Map，ModelMap传输数据到页面" class="headerlink" title="5.3 使用Model，Map，ModelMap传输数据到页面"></a>5.3 使用Model，Map，ModelMap传输数据到页面</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 servlet API 方式传输数据到视图</span><br><span class="hljs-meta">@RequestMapping(&quot;debug1&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello1</span><span class="hljs-params">(HttpServletRequest request)</span> </span>&#123;<br>    request.setAttribute(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;servletAPI&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 使用 model 方式传输数据到视图</span><br><span class="hljs-meta">@RequestMapping(&quot;debug2&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello2</span><span class="hljs-params">(Model model)</span> </span>&#123;<br>    <span class="hljs-comment">// 底层会将 model 中的数据复制一份到 request 域</span><br>    model.addAttribute(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;model&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 使用 ModelMap 方式传输数据到视图</span><br><span class="hljs-meta">@RequestMapping(&quot;debug3&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello3</span><span class="hljs-params">(ModelMap modelMap)</span> </span>&#123;<br>    modelMap.addAttribute(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;ModelMap&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br><br><span class="hljs-comment">// 使用 Map 方式传输数据到视图</span><br><span class="hljs-meta">@RequestMapping(&quot;debug4&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello4</span><span class="hljs-params">(Map map)</span> </span>&#123;<br>    map.put(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;map&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用三个对象传递参数，会发现所有的参数值都设置到了 request 作用域中，那么这三个对象是什么关系呢？</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221004001551.png"></p><p>实际上三种对象的实际类型都是：<strong>BindingAwareModelMap</strong></p><h4 id="5-4-使用-ModelAndView-对象传输数据到页面"><a href="#5-4-使用-ModelAndView-对象传输数据到页面" class="headerlink" title="5.4 使用 ModelAndView 对象传输数据到页面"></a>5.4 使用 ModelAndView 对象传输数据到页面</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 使用 ModelAndView 方式传输数据到视图</span><br><span class="hljs-meta">@RequestMapping(&quot;debug&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ModelAndView <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    ModelAndView modelAndView = <span class="hljs-keyword">new</span> ModelAndView(<span class="hljs-string">&quot;index&quot;</span>);<br>    <span class="hljs-comment">// modelAndView.setViewName();</span><br>    modelAndView.addObject(<span class="hljs-string">&quot;type&quot;</span>,<span class="hljs-string">&quot;ModelAndView&quot;</span>);<br>    <span class="hljs-keyword">return</span> modelAndView;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>ps: springmvc 处理以上几种设置 model 的 request 域数据的几种方式以外，springmvc 还会隐式的将请求绑定参数自动设置到 request 域</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/update&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">(User user)</span> </span>&#123;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>jsp 页面：</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;br&gt; requestScope:$&#123;requestScope.user&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221005131119.png"></p><h4 id="5-5-使用-session-传输数据到页面"><a href="#5-5-使用-session-传输数据到页面" class="headerlink" title="5.5 使用 session 传输数据到页面"></a>5.5 使用 session 传输数据到页面</h4><h5 id="通过-servlet-api-读写-session"><a href="#通过-servlet-api-读写-session" class="headerlink" title="通过 servlet api 读写 session"></a>通过 servlet api 读写 session</h5><ol><li>通过参数绑定的方式获取 servlet api</li><li>通过自动注入的方式获取 servlet api（推荐使用这种方式）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 通过参数绑定的方式获取 Servlet API——session</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@RequestMapping(&quot;/debug01&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(HttpSession session)</span> </span>&#123;<br>    session.setAttribute(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;servletAPI——session&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br><br><span class="hljs-meta">@Autowired</span><br>HttpSession httpSession;<br><br><span class="hljs-meta">@RequestMapping(&quot;debug02&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">()</span> </span>&#123;<br>    httpSession.setAttribute(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;Autowired——session&quot;</span>);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="通过-springmvc-提供的注解读写-session"><a href="#通过-springmvc-提供的注解读写-session" class="headerlink" title="通过 springmvc 提供的注解读写 session"></a>通过 springmvc 提供的注解读写 session</h5><h6 id="1-SessionAttributes"><a href="#1-SessionAttributes" class="headerlink" title="1. @SessionAttributes"></a>1. @SessionAttributes</h6><ol><li> 用在类上，将 model 中指定的属性写入 session 。同时也会从 session 中写入指定的属性到 model。</li><li> 所以使用 @SessionAttributes 的情况下 model 和 session 是共通的。</li><li> 使用该方式设置 session 依赖 model。</li><li> 当前控制器下所有的处理方法都会将 model 指定的属性写入 session</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@SessionAttributes(&quot;type&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;debug&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;model&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>index.jsp:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;br&gt; requestScope:$&#123;requestScope.type&#125;<br>&lt;br&gt;<br>&lt;br&gt;sessionScope:$&#123;sessionScope.type&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221004223038.png"></p><p><a href="https://blog.csdn.net/abc997995674/article/details/80462450">https://blog.csdn.net/abc997995674/article/details/80462450</a></p><p><a href="https://blog.51cto.com/u_3631118/3124605">https://blog.51cto.com/u_3631118/3124605</a></p><h6 id="2-SessionAttribute"><a href="#2-SessionAttribute" class="headerlink" title="2. @SessionAttribute"></a>2. @SessionAttribute</h6><ol><li>用在请求方法参数上读取 session。</li><li>required 属性用来设置 session 中某个属性必须存在 ， 不存在则会报错。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;debug2&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(<span class="hljs-meta">@SessionAttribute(required = false,value = &quot;type&quot;)</span> String type)</span> </span>&#123;<br>    System.out.println(type);<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="3-ModelAttribute"><a href="#3-ModelAttribute" class="headerlink" title="3. @ModelAttribute"></a>3. @ModelAttribute</h6><h4 id="5-6-ModelAttribute"><a href="#5-6-ModelAttribute" class="headerlink" title="5.6 @ModelAttribute"></a>5.6 @ModelAttribute</h4><h5 id="1-写在方法上面"><a href="#1-写在方法上面" class="headerlink" title="1. 写在方法上面"></a>1. 写在方法上面</h5><p>@ModelAttribute 的方法会在当前处理器中所有的处理方法之前调用 </p><ol><li>通过 @ModelAttribute 来给全局变量赋值(不推荐） <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    HttpSession httpSession;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;debug&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">hello</span><span class="hljs-params">(Model model)</span> </span>&#123;<br>        httpSession.setAttribute(<span class="hljs-string">&quot;type&quot;</span>, <span class="hljs-string">&quot;ModelAttribute&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 通过 <span class="hljs-doctag">@ModelAttribute</span> 获取 Servlet API</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@ModelAttribute</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">hello1</span><span class="hljs-params">(HttpSession httpSession)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.httpSession = httpSession;<br>    &#125;<br><br>&#125;<br><br></code></pre></td></tr></table></figure></li><li>当调用执行全字段的更新数据库操作时，假如提供给用户的修改字段只有部分字段，这时候就会造成其他字段更新丢失<blockquote><p>解决： </p><ul><li>自己定制 update 语句， 只更新指定的那些字段 </li><li>如果无法定制 sql 语句， 可以在更新之前进行查询， 怎么在更新之前查询？只能在 springmvc 绑定请求参数之前查询， 利用 @ModelAttribute 就可以在参数绑定之前查询， 但是怎么将查询出来的对象和参数的对象进行合并？ springmvc 具有该特性， 会将 model 中和参数名相同的属性拿出来进行合并，用参数中的属性值进行自动覆盖，没有的字段进行保留。这样就可以解决这个问题。</li></ul></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/update&quot;)</span><br><span class="hljs-meta">@ResponseBody</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">(User user)</span> </span>&#123;<br>    <span class="hljs-comment">// update user set id = ? ,userName = ?,password = ? where id = ?</span><br>    <span class="hljs-keyword">return</span> user.toString();<br>&#125;<br><br><span class="hljs-meta">@ModelAttribute</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initUser</span><span class="hljs-params">(Model model)</span> </span>&#123;<br>    model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221005130607.png"></p><ol start="3"><li>将返回值放进 ModelMap 里</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span>  <span class="hljs-meta">@ModelAttribute</span> <span class="hljs-function">User <span class="hljs-title">initUser</span><span class="hljs-params">()</span> </span>&#123;<br> <br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>+index, <span class="hljs-string">&quot;admin&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ModelAttribute</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">initUser</span><span class="hljs-params">()</span> </span>&#123;<br><br>   <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>+index, <span class="hljs-string">&quot;admin&quot;</span>);<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-写在参数上面"><a href="#2-写在参数上面" class="headerlink" title="2. 写在参数上面"></a>2. 写在参数上面</h5><p>可以省略，将请求参数合并到 model 中指定的对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/update&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute(&quot;user&quot;)</span> User u)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br>    <span class="hljs-meta">@ModelAttribute</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initUser</span><span class="hljs-params">(Model model)</span> </span>&#123;<br>        model.addAttribute(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>));<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>因为 mode l和  sessionAttribute 具有共通的特性，所以如果 session 中有对应的属性也会进行合并。可以和 @SessionAttributes 结合使用。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@SessionAttributes(types = User.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/update&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute(&quot;user&quot;)</span> User u)</span> </span>&#123;<br><br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@ModelAttribute</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">initUser</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>jsp:</p><figure class="highlight jsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs jsp">&lt;br&gt; requestScope:$&#123;requestScope.user&#125;<br>&lt;br&gt; sessionScope:$&#123;sessionScope.user&#125;<br></code></pre></td></tr></table></figure><p>第一次访问：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221005210717.png"></p><p>第二次访问：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221005210936.png"></p><p>第三次访问：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221005210917.png"></p><p>model 和 session 里的值<strong>没有被</strong> @ModelAttribute 改变了。<br>因此对于 @ModelAttribute 和 @SessionAttributes 共同的使用的时候务必要注意的结论：已经添加进 session 的数据，在没用使用 SessionStatus 清除过之前，@ModelAttribute 标注的非功能方法的返回值并不会被再次更新进 session 内。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@RequestMapping(&quot;/update&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute(&quot;user&quot;)</span> User u, SessionStatus sessionStatus)</span> </span>&#123;<br><br>    sessionStatus.setComplete();<br>    <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>当给方法中的参数设置值的时候，如果添加了 @ModelAttribute 注解，那么在查找值的时候，是遵循以下方式：</p><ol><li>方法的参数使用参数的类型首字母小写，或者使用 @ModelAttribute(“”) 的值</li><li>先看之前是否在 model 中设置过该属性值，如果设置过就直接获取 </li><li>看 @SessionAttributes 注解标注类中的方法是否给 session 中赋值，如果有的话，也是直接获取，没有报异常</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-meta">@SessionAttributes(types = User.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/session&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">(HttpSession session)</span> </span>&#123;<br>        session.setAttribute(<span class="hljs-string">&quot;u&quot;</span>, <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/update&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">update</span><span class="hljs-params">(<span class="hljs-meta">@ModelAttribute(&quot;u&quot;)</span> User u)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;index&quot;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://blog.51cto.com/u_3631118/3121661">https://blog.51cto.com/u_3631118/3121661</a></p><p><a href="https://blog.51cto.com/u_3631118/3121625">https://blog.51cto.com/u_3631118/3121625</a></p><h4 id="5-7-Spring-MVC-线程安全问题"><a href="#5-7-Spring-MVC-线程安全问题" class="headerlink" title="5.7 Spring MVC 线程安全问题"></a>5.7 Spring MVC 线程安全问题</h4><p>Spring MVC  的 Controller 默认是单例的。</p><p>以 servlet API 获取为例。</p><ol><li>通过参数绑定<br>是线程安全的。因为参数绑定变量是方法级别，所以每次请求方法都会创建一个新的私有变量。</li><li>通过自动注入的方式@AutoWired<br>是线程安全的，spring 底层通过自动注入将 servlet api 封装到 ThreadLocal 中。</li><li>.通过@ModelAttribute的方式<br>不是线程安全的，控制器是单例的，并且变量声明在类的级别中（共享变量）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">HttpSession session;<br><span class="hljs-meta">@ModelAttribute</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">(HttpSession session)</span> </span>&#123;<br>    <span class="hljs-keyword">this</span>.session = session;<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><p><a href="https://blog.csdn.net/weixin_42128429/article/details/119936833">https://blog.csdn.net/weixin_42128429/article/details/119936833</a></p><h4 id="5-8-转发和重定向"><a href="#5-8-转发和重定向" class="headerlink" title="5.8 转发和重定向"></a>5.8 转发和重定向</h4><h5 id="1-转发"><a href="#1-转发" class="headerlink" title="1. 转发"></a>1. 转发</h5><p>由服务器的页面进行跳转，不需要客户端重新发送请求： </p><p>特点如下：</p><ol><li>地址栏的请求不会发生变化，显示的还是第一次请求的地址</li><li>请求的次数，有且仅有一次请求 </li><li>请求域中的数据不会丢失</li><li>根目录：localhost:8080/项目地址/，包含了项目的访问地址</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221006000619.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 默认就是转发，会参与视图解析器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 当使用转发的时候可以添加前缀 forward:index.jsp,此时是不会经过视图解析器的，所以要添加完整的名称</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/debug&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">forword</span><span class="hljs-params">(HttpSession session)</span> </span>&#123;<br>        session.setAttribute(<span class="hljs-string">&quot;user&quot;</span>, <span class="hljs-keyword">new</span> User(<span class="hljs-number">1</span>, <span class="hljs-string">&quot;debuggingWorld&quot;</span>, <span class="hljs-string">&quot;admin&quot;</span>));<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/WEB-INF/index.jsp&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/debug1&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">forword</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;forward:/debug&quot;</span>;<br>    &#125;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h5 id="2-重定向"><a href="#2-重定向" class="headerlink" title="2. 重定向"></a>2. 重定向</h5><p>在浏览器端进行页面的跳转，需要发送两次请求（第一次是人为的，第二次是自动的）</p><p>特点如下：</p><ol><li>地址栏的地址发生变化，显示最新发送请求的地址</li><li>请求次数：2次</li><li>请求域中的数据会丢失，因为是不同的请求</li><li>根目录：localhost:8080/ ，不包含项目的名称</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221006001601.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Controller</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HelloController</span> </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 重定向</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 必须加上 redirect。不会参与视图解析器</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * springMVC 默认会加上项目名，而 servlet 不会</span><br><span class="hljs-comment">     *</span><br><span class="hljs-comment">     * 相当于 response.sendRedirect(&quot;login.jsp&quot;)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@RequestMapping(&quot;/debug&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">redirect</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/login.jsp&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@RequestMapping(&quot;/debug1&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">redirect1</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;redirect:/debug&quot;</span>;<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221006004530.png"></p><h5 id="3-对比"><a href="#3-对比" class="headerlink" title="3. 对比"></a>3. 对比</h5><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221006001756.png"></p>]]></content>
    
    
    <categories>
      
      <category>SpringMVC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>SpringMVC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——事务源码解析</title>
    <link href="/2022/08/29/Spring%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/08/29/Spring%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.processon.com/view/link/631f3fa10e3e7420767c11fe">https://www.processon.com/view/link/631f3fa10e3e7420767c11fe</a></p><h3 id="1-EnableTransactionManagement工作原理"><a href="#1-EnableTransactionManagement工作原理" class="headerlink" title="1. @EnableTransactionManagement工作原理"></a>1. @EnableTransactionManagement工作原理</h3><p>开启 Spring 事务本质上就是增加了一个 Advisor，但我们使用 @EnableTransactionManagement 注解来开启 Spring 事务是该注解向 Spring 容器中添加了两个 Bean：</p><ol><li>AutoProxyRegistrar</li><li>ProxyTransactionManagementConfiguration</li></ol><p>AutoProxyRegistrar 主要的作用是向 Spring 容器中注册了一个 <strong>InfrastructureAdvisorAutoProxyCreator</strong> 的 Bean。<br>而 InfrastructureAdvisorAutoProxyCreator 继承了 <strong>AbstractAdvisorAutoProxyCreator</strong>，所以这个类的主要作用就是<strong>开启自动代理</strong>的作用，也就是一个 BeanPostProcessor，会在初始化后步骤中去寻找 Advisor 类型的 Bean，并判断当前 Bean 是否有匹配的 Advisor，是否需要利用动态代理产生一个代理对象。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220905220453.png"></p><p>ProxyTransactionManagementConfiguration 是一个配置类，它又定义了另外三个 bean：</p><ol><li>BeanFactoryTransactionAttributeSourceAdvisor：一个 Advisor</li><li>AnnotationTransactionAttributeSource：相当于 BeanFactoryTransactionAttributeSourceAdvisor 中的 Pointcut</li><li>TransactionInterceptor：相当于 BeanFactoryTransactionAttributeSourceAdvisor 中的 Advice</li></ol><p><strong>AnnotationTransactionAttributeSource</strong> 就是用来判断某个类上是否存在 @Transactional 注解，或者判断某个方法上是否存在 @Transactional 注解的。</p><p><strong>TransactionInterceptor</strong> 就是代理逻辑，当某个类中存在 @Transactional 注解时，到时就产生一个代理对象作为 Bean，代理对象在执行某个方法时，最终就会进入到 TransactionInterceptor 的 invoke() 方法。</p><h3 id="2-Spring事务基本执行原理"><a href="#2-Spring事务基本执行原理" class="headerlink" title="2. Spring事务基本执行原理"></a>2. Spring事务基本执行原理</h3><p>一个 Bean 在执行 Bean 的创建生命周期时，会经过 InfrastructureAdvisorAutoProxyCreator 的初始化后的方法，会判断当前当前 Bean 对象是否和 BeanFactoryTransactionAttributeSourceAdvisor 匹配，匹配逻辑为判断该 Bean 的类上是否存在 @Transactional 注解，或者类中的某个方法上是否存在 @Transactional 注解，如果存在则表示该 Bean 需要进行动态代理产生一个代理对象作为 Bean 对象。</p><p>该代理对象在执行某个方法时，会再次判断当前执行的方法是否和 BeanFactoryTransactionAttributeSourceAdvisor 匹配，如果匹配则执行该 Advisor 中的 TransactionInterceptor 的 invoke() 方法，执行基本流程为：</p><ol><li>利用所配置的 PlatformTransactionManager 事务管理器新建一个数据库连接</li><li>修改数据库连接的 autocommit 为 false</li><li>执行 MethodInvocation.proceed() 方法，即执行业务方法，其中就会执行 sql</li><li>如果没有抛异常，则提交</li><li>如果抛了异常，则回滚</li></ol><h3 id="3-Spring事务详细执行流程"><a href="#3-Spring事务详细执行流程" class="headerlink" title="3. Spring事务详细执行流程"></a>3. Spring事务详细执行流程</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/Spring_transaction_ab123123132.png"></p><p>Spring事务执行流程图：<a href="https://www.processon.com/view/link/5fab6edf1e0853569633cc06">https://www.processon.com/view/link/5fab6edf1e0853569633cc06</a></p><h3 id="4-Spring事务传播机制"><a href="#4-Spring事务传播机制" class="headerlink" title="4. Spring事务传播机制"></a>4. Spring事务传播机制</h3><p>在开发过程中，经常会出现一个方法调用另外一个方法，那么这里就涉及到了多种场景，比如a()调用b()：</p><ol><li>a() 和 b() 方法中的所有 sql 需要在同一个事务中吗？</li><li>a() 和 b() 方法需要单独的事务吗？</li><li>a() 需要在事务中执行，b() 还需要在事务中执行吗？</li><li>等等情况…</li></ol><p>所以，这就要求 Spring 事务能支持上面各种场景，这就是 Spring 事务传播机制的由来。那 Spring 事务传播机制是如何实现的呢?</p><p>先来看上述几种场景中的一种情况，a() 在一个事务中执行，调用 b() 方法时需要新开一个事务执行：</p><ol><li>首先，代理对象执行 a() 方法前，先利用事务管理器新建一个数据库连接 a</li><li>将数据库连接 a 的 autocommit 改为 false</li><li>把数据库连接 a 设置到 ThreadLocal 中</li><li>执行 a() 方法中的 sql</li><li>执行 a() 方法过程中，调用了 b() 方法（注意用代理对象调用 b() 方法）<ul><li>代理对象执行 b() 方法前，判断出来了当前线程中已经存在一个数据库连接 a 了，表示当前线程其实已经拥有一个 Spring 事务了，则进行<strong>挂起</strong></li><li> 挂起就是把 ThreadLocal 中的数据库连接 a 从 ThreadLocal 中移除，并放入一个<strong>挂起资源对象</strong>中</li><li>挂起完成后，再次利用事务管理器新建一个数据库连接 b</li><li> 将数据库连接 b 的 autocommit 改为 false</li><li> 把数据库连接 b 设置到 ThreadLocal 中</li><li> 执行 b() 方法中的 sql</li><li> b() 方法正常执行完，则从 ThreadLocal 中拿到数据库连接 b 进行提交</li><li> 提交之后会恢复所挂起的数据库连接 a，这里的恢复，其实只是把在<strong>挂起资源对象</strong>中所保存的数据库连接 a 再次设置到 ThreadLocal 中</li></ul></li><li>a() 方法正常执行完，则从 ThreadLocal 中拿到数据库连接 a 进行提交</li></ol><p>这个过程中最为核心的是：<strong>在执行某个方法时，判断当前是否已经存在一个事务，就是判断当前线程的 ThreadLocal 中是否存在一个数据库连接对象，如果存在则表示已经存在一个事务了。</strong></p><p>其中，以非事务方式运行，表示以非 Spring 事务运行，就是在执行这个方法时，Spring 事务管理器不会去建立数据库连接，执行 sql 时，由 Mybatis 或 JdbcTemplate 自己来建立数据库连接来执行 sql。</p><h4 id="情况1"><a href="#情况1" class="headerlink" title="情况1"></a>情况1</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserService userService;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// test方法中的sql</span><br>userService.a();<br>&#125;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// a方法中的sql</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认情况下传播机制为 <strong>REQUIRED，表示当前如果没有事务则新建一个事务，如果有事务则在当前事务中执行。</strong></p><p>所以上面这种情况的执行流程如下：</p><ol><li>新建一个数据库连接 conn</li><li>设置 conn 的 autocommit 为 false</li><li>执行 test 方法中的 sql</li><li>执行 a 方法中的 sql</li><li>执行 conn 的 commit() 方法进行提交</li></ol><h4 id="情况2"><a href="#情况2" class="headerlink" title="情况2"></a>情况2</h4><p>假如是这种情况</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserService userService;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// test方法中的sql</span><br>userService.a();<br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">100</span>/<span class="hljs-number">0</span>;<br>&#125;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// a方法中的sql</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以上面这种情况的执行流程如下：</p><ol><li>新建一个数据库连接 conn</li><li>设置 conn 的 autocommit 为 false</li><li>执行 test 方法中的 sql</li><li>执行 a 方法中的 sql</li><li>抛出异常</li><li>执行 conn 的 rollback() 方法进行回滚，所以两个方法中的 sql 都会回滚掉</li></ol><h4 id="情况3"><a href="#情况3" class="headerlink" title="情况3"></a>情况3</h4><p>假如是这种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserService userService;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// test方法中的sql</span><br>userService.a();<br>&#125;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// a方法中的sql</span><br>        <span class="hljs-keyword">int</span> result = <span class="hljs-number">100</span>/<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以上面这种情况的执行流程如下：</p><ol><li>新建一个数据库连接 conn</li><li>设置 conn 的 autocommit 为 false</li><li>执行 test 方法中的 sql</li><li>执行 a 方法中的 sql</li><li>抛出异常</li><li>执行 conn 的 rollback() 方法进行回滚，所以两个方法中的 sql 都会回滚掉</li></ol><h4 id="情况4"><a href="#情况4" class="headerlink" title="情况4"></a>情况4</h4><p>如果是这种情况：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserService userService;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// test方法中的sql</span><br>userService.a();<br>&#125;<br><br><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// a方法中的sql</span><br><span class="hljs-keyword">int</span> result = <span class="hljs-number">100</span>/<span class="hljs-number">0</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>所以上面这种情况的执行流程如下：</p><ol><li>新建一个数据库连接 conn</li><li>设置 conn 的 autocommit 为 false</li><li>执行 test 方法中的 sql</li><li>又新建一个数据库连接 conn2</li><li>执行 a 方法中的 sql</li><li>抛出异常</li><li>执行 conn2 的 rollback() 方法进行回滚</li><li><strong>继续抛异常，对于 test() 方法而言，它会接收到一个异常，然后抛出</strong></li><li>执行 conn 的 rollback() 方法进行回滚，最终还是两个方法中的 sql 都回滚了</li></ol><h3 id="5-Spring事务强制回滚"><a href="#5-Spring事务强制回滚" class="headerlink" title="5. Spring事务强制回滚"></a>5. Spring事务强制回滚</h3><p>正常情况下，a() 调用 b() 方法时，如果 b() 方法抛了异常，但是在 a() 方法捕获了，那么 a() 的事务还是会正常提交的，但是有的时候，我们捕获异常可能仅仅只是不把异常信息返回给客户端，而返回一些更友好的错误信息，此时我们还是希望事务能回滚的，那就得告诉 Spring 把当前事务回滚掉，做法就是：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br><br>    <span class="hljs-comment">// 执行sql</span><br><span class="hljs-keyword">try</span> &#123;<br>b();<br>&#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><span class="hljs-comment">// 构造友好的错误信息返回</span><br>TransactionAspectSupport.currentTransactionStatus().setRollbackOnly();<br>&#125;<br>    <br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">b</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> Exception();<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-TransactionSynchronization"><a href="#6-TransactionSynchronization" class="headerlink" title="6. TransactionSynchronization"></a>6. TransactionSynchronization</h3><p>Spring 事务有可能会提交、回滚、挂起、恢复，所以 Spring 事务提供了一种机制，可以让程序员来监听当前 Spring 事务所处于的状态。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> UserService userService;<br><br><span class="hljs-meta">@Transactional</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>&#123;<br>TransactionSynchronizationManager.registerSynchronization(<span class="hljs-keyword">new</span> TransactionSynchronization() &#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">suspend</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test被挂起了&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">resume</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test被恢复了&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeCommit</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> readOnly)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test准备要提交了&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">beforeCompletion</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test准备要提交或回滚了&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCommit</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test提交成功了&quot;</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterCompletion</span><span class="hljs-params">(<span class="hljs-keyword">int</span> status)</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test提交或回滚成功了&quot;</span>);<br>&#125;<br>&#125;);<br><br>jdbcTemplate.execute(<span class="hljs-string">&quot;insert into t1 values(1,1,1,1,&#x27;1&#x27;)&quot;</span>);<br>System.out.println(<span class="hljs-string">&quot;test&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-setGlobalRollbackOnParticipationFailure"><a href="#7-setGlobalRollbackOnParticipationFailure" class="headerlink" title="7. setGlobalRollbackOnParticipationFailure"></a>7. setGlobalRollbackOnParticipationFailure</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> PlatformTransactionManager <span class="hljs-title">platformTransactionManager</span><span class="hljs-params">()</span></span>&#123;<br>    DataSourceTransactionManager transactionManager = <span class="hljs-keyword">new</span> DataSourceTransactionManager(dataSource());<br>    <span class="hljs-comment">// 部分失败是否全局回滚，默认 true</span><br>    transactionManager.setGlobalRollbackOnParticipationFailure(<span class="hljs-keyword">false</span>);<br>    <span class="hljs-keyword">return</span> transactionManager;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    UserService userService;<br><br>    <span class="hljs-meta">@Autowired</span><br>    JdbcTemplate jdbcTemplate;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span>  </span>&#123;<br>        jdbcTemplate.update(<span class="hljs-string">&quot;insert into t_user( name, age) VALUES (?,?)&quot;</span>, <span class="hljs-string">&quot;lisi1&quot;</span>, <span class="hljs-number">18</span>);<br>        <span class="hljs-keyword">try</span> &#123;<br>            userService.add();<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br><br>        &#125;<br>    &#125;<br><br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>        jdbcTemplate.update(<span class="hljs-string">&quot;insert into t_user( name, age) VALUES (?,?)&quot;</span>, <span class="hljs-string">&quot;lisi2&quot;</span>, <span class="hljs-number">18</span>);<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    &#125;<br>&#125;<br>````<br><br>为 <span class="hljs-keyword">false</span> 时，执行 test 方法，两条都插入<br>为 <span class="hljs-keyword">true</span> 时，全部回滚<br><br>```java<br><span class="hljs-meta">@Transactional(propagation = Propagation.REQUIRES_NEW)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>    jdbcTemplate.update(<span class="hljs-string">&quot;insert into t_user( name, age) VALUES (?,?)&quot;</span>, <span class="hljs-string">&quot;lisi2&quot;</span>, <span class="hljs-number">18</span>);<br>    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>&#125;<br></code></pre></td></tr></table></figure><p>此时为 true 时，test 方法不回滚，add 方法回滚</p><p><strong>一个事务中要么全都回滚，要么全都不回滚</strong></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——事务</title>
    <link href="/2022/08/27/Spring%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1/"/>
    <url>/2022/08/27/Spring%E2%80%94%E2%80%94%E4%BA%8B%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Spring-JdbcTemplate"><a href="#1-Spring-JdbcTemplate" class="headerlink" title="1. Spring JdbcTemplate"></a>1. Spring JdbcTemplate</h3><h4 id="1-1-配置数据源"><a href="#1-1-配置数据源" class="headerlink" title="1.1 配置数据源"></a>1.1 配置数据源</h4><p><strong>pom:</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.21.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-orm<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.21.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.6.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>8.0.29<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.projectlombok<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>lombok<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.18.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>provided<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220827194209.png"></p><p><strong>dbconfig.properties:</strong></p><figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">jdbc.name</span>=root<br><span class="hljs-attr">jdbc.password</span>=mysql<br><span class="hljs-attr">jdbc.url</span>=jdbc:mysql://localhost:<span class="hljs-number">3306</span>/debuggingworld?useSSL=<span class="hljs-literal">false</span><br><span class="hljs-attr">jdbc.driverClassName</span>=com.mysql.jdbc.Driver<br></code></pre></td></tr></table></figure><h4 id="1-2-添加-dataSource-和-JdbcTemplate"><a href="#1-2-添加-dataSource-和-JdbcTemplate" class="headerlink" title="1.2 添加 dataSource 和 JdbcTemplate"></a>1.2 添加 dataSource 和 JdbcTemplate</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(&quot;com.zth&quot;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:dbConfig.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.name&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String userName;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.password&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String pwd;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.url&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String url;<br>    <span class="hljs-meta">@Value(&quot;$&#123;jdbc.driverClassName&#125;&quot;)</span><br>    <span class="hljs-keyword">private</span> String driverClassName;<br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DruidDataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;<br><br>        DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();<br>        dataSource.setUsername(userName);<br>        dataSource.setPassword(pwd);<br>        dataSource.setUrl(url);<br>        dataSource.setDriverClassName(driverClassName);<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> JdbcTemplate <span class="hljs-title">jdbcTemplate</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdbcTemplate(dataSource());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-查询"><a href="#1-3-查询" class="headerlink" title="1.3 查询"></a>1.3 查询</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoTest</span> </span>&#123;<br><br>    JdbcTemplate jdbcTemplate;<br><br>    <span class="hljs-meta">@Before</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br>        jdbcTemplate = context.getBean(JdbcTemplate.class);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> 查询单个对象_对象属性和数据库字段一致() &#123;<br>        User user = jdbcTemplate.queryForObject(<span class="hljs-string">&quot;select * from t_user where id = ?&quot;</span>,<br>                <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;&gt;(User.class), <span class="hljs-number">1</span>);<br>        System.out.println(user);<br>    &#125;<br><br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> 查询单个对象_对象属性和数据库字段不一致() &#123;<br>        User user = jdbcTemplate.queryForObject(<span class="hljs-string">&quot;select * from t_user where id = ?&quot;</span>, <span class="hljs-keyword">new</span> RowMapper&lt;User&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">mapRow</span><span class="hljs-params">(ResultSet resultSet, <span class="hljs-keyword">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>                User user = <span class="hljs-keyword">new</span> User();<br>                user.setId(resultSet.getInt(<span class="hljs-string">&quot;id&quot;</span>));<br>                user.setName(resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>                user.setAge(resultSet.getInt(<span class="hljs-string">&quot;age&quot;</span>));<br>                <span class="hljs-keyword">return</span> user;<br>            &#125;<br>        &#125;, <span class="hljs-number">1</span>);<br>        System.out.println(user);<br>    &#125;<br><br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> 查询多个对象_对象属性和数据库字段不一致() &#123;<br>        List&lt;User&gt; users = jdbcTemplate.query(<span class="hljs-string">&quot;select * from t_user where id &gt; ?&quot;</span>, <span class="hljs-keyword">new</span> RowMapper&lt;User&gt;() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">mapRow</span><span class="hljs-params">(ResultSet resultSet, <span class="hljs-keyword">int</span> i)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>                User user = <span class="hljs-keyword">new</span> User();<br>                user.setId(resultSet.getInt(<span class="hljs-string">&quot;id&quot;</span>));<br>                user.setName(resultSet.getString(<span class="hljs-string">&quot;name&quot;</span>));<br>                user.setAge(resultSet.getInt(<span class="hljs-string">&quot;age&quot;</span>));<br>                <span class="hljs-keyword">return</span> user;<br>            &#125;<br>        &#125;, <span class="hljs-number">0</span>);<br>        System.out.println(users);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-4-增删改"><a href="#1-4-增删改" class="headerlink" title="1.4 增删改"></a>1.4 增删改</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testInsert</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> result = jdbcTemplate.update(<span class="hljs-string">&quot;insert into t_user( name, age) VALUES (?,?)&quot;</span>, <span class="hljs-string">&quot;lisi&quot;</span>, <span class="hljs-number">18</span>);<br>    System.out.println(result);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testBatchInsert</span><span class="hljs-params">()</span> </span>&#123;<br>    ArrayList&lt;Object[]&gt; users = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    users.add(<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;zhangsan&quot;</span>,<span class="hljs-number">20</span>&#125;);<br>    users.add(<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;lisi&quot;</span>,<span class="hljs-number">20</span>&#125;);<br>    users.add(<span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-string">&quot;wangwu&quot;</span>,<span class="hljs-number">20</span>&#125;);<br><br>    <span class="hljs-keyword">int</span>[] result = jdbcTemplate.batchUpdate(<span class="hljs-string">&quot;insert into t_user( name, age) VALUES (?,?)&quot;</span>, users);<br>    System.out.println(result);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testUpdate</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> result = jdbcTemplate.update(<span class="hljs-string">&quot;update t_user set age = ? where id = ? &quot;</span>, <span class="hljs-number">20</span>,<span class="hljs-number">2</span>);<br>    System.out.println(result);<br>&#125;<br><br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testDelete</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> result = jdbcTemplate.update(<span class="hljs-string">&quot;delete from t_user where id = ?&quot;</span>, <span class="hljs-number">2</span>);<br>    System.out.println(result);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-5-具名参数"><a href="#1-5-具名参数" class="headerlink" title="1.5 具名参数"></a>1.5 具名参数</h4><p><strong>NamedParameterJdbcTemplate:</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> NamedParameterJdbcTemplate <span class="hljs-title">namedParameterJdbcTemplate</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> NamedParameterJdbcTemplate(dataSource());<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testNamedParameterJdbcTemplate</span><span class="hljs-params">()</span> </span>&#123;<br>    Map&lt;String,Object&gt; user = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    user.put(<span class="hljs-string">&quot;name&quot;</span>,<span class="hljs-string">&quot;aa&quot;</span>);<br>    user.put(<span class="hljs-string">&quot;age&quot;</span>,<span class="hljs-number">20</span>);<br><br>    <span class="hljs-keyword">int</span> result = namedParameterJdbcTemplate.update(<span class="hljs-string">&quot;insert into t_user(name, age) values(:name,:age)&quot;</span>, user);<br>    System.out.println(result);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-6-Spring-JdbcTemplate-整合-dao"><a href="#1-6-Spring-JdbcTemplate-整合-dao" class="headerlink" title="1.6 Spring JdbcTemplate 整合 dao"></a>1.6 Spring JdbcTemplate 整合 dao</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Repository</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserDaoImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IUserDao</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> JdbcTemplate jdbcTemplate;<br><br>    <span class="hljs-meta">@Autowired</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setDataSource</span><span class="hljs-params">(DataSource dataSource)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.jdbcTemplate = <span class="hljs-keyword">new</span> JdbcTemplate(dataSource);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> User <span class="hljs-title">getUser</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> jdbcTemplate.queryForObject(<span class="hljs-string">&quot;select * from t_user where id = ?&quot;</span>,<br>                <span class="hljs-keyword">new</span> BeanPropertyRowMapper&lt;&gt;(User.class), <span class="hljs-number">1</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-声明式事务"><a href="#2-声明式事务" class="headerlink" title="2. 声明式事务"></a>2. 声明式事务</h3><h4 id="2-1-基于注解"><a href="#2-1-基于注解" class="headerlink" title="2.1 基于注解"></a>2.1 基于注解</h4><h5 id="添加事务管理器"><a href="#添加事务管理器" class="headerlink" title="添加事务管理器"></a>添加事务管理器</h5><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> DruidDataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;<br><br>    DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();<br>    dataSource.setUsername(userName);<br>    dataSource.setPassword(pwd);<br>    dataSource.setUrl(url);<br>    dataSource.setDriverClassName(driverClassName);<br>    <span class="hljs-keyword">return</span> dataSource;<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> DataSourceTransactionManager <span class="hljs-title">dataSourceTransactionManager</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DataSourceTransactionManager(dataSource());<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="开启事务注解驱动"><a href="#开启事务注解驱动" class="headerlink" title="开启事务注解驱动"></a>开启事务注解驱动</h5><p><strong>@EnableTransactionManagement</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(&quot;com.zth&quot;)</span><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableTransactionManagement</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:dbConfig.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>    <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br>    <span class="hljs-meta">@Autowired</span><br>    UserService userService;<br>    <br>    <span class="hljs-meta">@Transactional</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>       <span class="hljs-comment">//……</span><br>        userService.add();<br>    &#125;<br><br>    <span class="hljs-meta">@Transactional(rollbackFor = Exception.class, propagation = Propagation.REQUIRES_NEW)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">()</span> </span>&#123;<br>       <span class="hljs-comment">//……</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-基于xml"><a href="#2-2-基于xml" class="headerlink" title="2.2  基于xml"></a>2.2  基于xml</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.zth&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:dbConfig.properties&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.name&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.password&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.url&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;jdbc.driverClassName&#125;&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;jdbcTemplate&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.core.JdbcTemplate&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;transactionManager&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.jdbc.datasource.DataSourceTransactionManager&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;dataSource&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 基于xml配置的事务：依赖tx名称空间和aop名称空间</span><br><span class="hljs-comment"> 1、spring中提供事务管理器（切面），配置这个事务管理器</span><br><span class="hljs-comment"> 2、配置出事务方法</span><br><span class="hljs-comment"> 3、告诉spring哪些方法是事务方法（事务切面按照切点表达式去切入事务方法） --&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txPoint&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.zth.debugSpring.service..*(..))&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:advisor</span> <span class="hljs-attr">advice-ref</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;txPoint&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">tx:advice</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;txAdvice&quot;</span> <span class="hljs-attr">transaction-manager</span>=<span class="hljs-string">&quot;transactionManager&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--事务属性--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">tx:attributes</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;get*&quot;</span> <span class="hljs-attr">read-only</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">tx:method</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;*&quot;</span> <span class="hljs-attr">rollback-for</span>=<span class="hljs-string">&quot;IOException&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">tx:attributes</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">tx:advice</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-Transactional"><a href="#3-Transactional" class="headerlink" title="3 @Transactional"></a>3 @Transactional</h3><p>@Transactional 可以标记在类上面，当前类所有的方法都运用事务<br>@Transactional 标记在方法则只是当前方法运用事务<br>如果类和方法都存在 @Transactional 会以方法的为准。 建议：@Transactional 写在方法上面，控制粒度更细，而且建议 @Transactional 写在业务逻辑层上</p><p>事务配置的属性 </p><ul><li>isolation：设置事务的隔离级别</li><li>propagation：事务的传播行为 </li><li>noRollbackFor：那些异常事务可以不回滚 </li><li>noRollbackForClassName：填写的参数是全类名 </li><li>rollbackFor：哪些异常事务需要回滚 </li><li>rollbackForClassName：填写的参数是全类名 </li><li>readOnly：设置事务是否为只读事务 </li><li>timeout：事务超出指定执行时长后自动终止并回滚,单位是秒</li></ul><h4 id="3-1-隔离级别（isolation）"><a href="#3-1-隔离级别（isolation）" class="headerlink" title="3.1 隔离级别（isolation）"></a>3.1 隔离级别（isolation）</h4><p><strong>使用方式：</strong><br>@Transactional(isolation = Isolation.REPEATABLE_READ)</p><ul><li>Isolation.DEFAULT：默认值，表示使用底层数据库的默认隔离级别。</li><li>Isolation.READ_UNCOMMITTED：该隔离级别表示一个事务可以读取另一个事务修改但还没有提交的数据。</li><li>Isolation.READ_COMMITTED：该隔离级别表示一个事务只能读取另一个事务已经提交的数据。</li><li>Isolation.REPEATABLE_READ：该隔离级别表示一个事务中多次某个查询得到的记录相同。</li><li>Isolation.SERIALIZABLE：所有的事务依次串行执行。</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/%E4%BA%8B%E5%8A%A1%E9%9A%94%E7%A6%BB%E7%BA%A7%E5%88%ABabzd.png"></p><p>并发安全：SERIALIZABLE&gt;REPEATABLE_READ&gt;READ_COMMITTED<br>运行效率：READ_COMMITTED&gt;REPEATABLE_READ&gt;SERIALIZABLE</p><h4 id="3-2-事务的传播特性"><a href="#3-2-事务的传播特性" class="headerlink" title="3.2 事务的传播特性"></a>3.2 事务的传播特性</h4><p>当一个具有事务控制的方法被另一个有事务控制的方法调用后，需要如何管理事务(新建事务?在事务中执行?把事务挂起?报异<br>常?)</p><p><strong>使用方式：</strong><br>@Transactional(propagation = Propagation.REQUIRED)</p><table><thead><tr><th>事务传播行为类型</th><th>外部不存在事务</th><th>外部存在事务</th><th>使用方式</th></tr></thead><tbody><tr><td>REQUIRED（默认）</td><td>开启新的事务</td><td>融合到外部事务中</td><td>适用增删改查</td></tr><tr><td>SUPPORTS</td><td>不开启新的事务</td><td>融合到外部事务中</td><td>适用查询</td></tr><tr><td>REQUIRES_NEW</td><td>开启新的事务</td><td>挂起外部事务，创建新的事务</td><td>适用内部事务和外部事务不存在业务关联情况，如日志</td></tr><tr><td>NOT_SUPPORTED</td><td>不开启新的事务</td><td>挂起外部事务</td><td>不常用</td></tr><tr><td>NEVER</td><td>不开启新的事务</td><td>抛出异常</td><td>不常用</td></tr><tr><td>NESTED</td><td>开启新的事务</td><td>嵌套事务内执行</td><td>不常用</td></tr><tr><td>MANDATORY</td><td>抛出异常</td><td>融合到外部事务中</td><td>不常用</td></tr></tbody></table><p><a href="https://zhuanlan.zhihu.com/p/148504094">https://zhuanlan.zhihu.com/p/148504094</a></p><p><strong>外部事务需要挂起的，外部事务和内部事务必须不在同一个类中</strong> </p><h4 id="3-3-超时属性-timeout"><a href="#3-3-超时属性-timeout" class="headerlink" title="3.3 超时属性(timeout)"></a>3.3 超时属性(timeout)</h4><p>指定事务等待的最长时间（秒） 当前事务访问数据时，有可能访问的数据被别的数据进行加锁的处理，那么此时事务就 必须等待，如果等待时间过长给用户造成的体验感差。超时直接回滚返回。</p><p><strong>使用方式：</strong><br>@Transactional(timeout = 2)</p><p>Spring事务超时 = 事务开始时到最后一个Statement创建时时间 + 最后一个Statement的执行时超时时间（即其queryTimeout）。</p><h4 id="3-4-设置事务只读-readOnly"><a href="#3-4-设置事务只读-readOnly" class="headerlink" title="3.4 设置事务只读(readOnly)"></a>3.4 设置事务只读(readOnly)</h4><p><strong>使用方式：</strong><br>@Transactional(readOnly = true)</p><p>readonly：只会设置在查询的业务方法中<br>connection.setReadOnly(true) 通知数据库当前操作是只读，数据库就会对当前只读做相应优化 </p><p>如果一次执行单条查询语句，则没有必要启用事务支持，数据库默认支持 SQL 执行期间的读一致性；<br>如果一次执行多条查询语句，例如统计查询，报表查询，在这种场景下，多条查询 SQL 必须保证整体的读一致性，否则在前一条 SQL 查询之后，后一条 SQL 查询之前，数据被其他用户改变，则该次整体的统计查询将会出现读数据不一致的状态，此时应该启用事务支持（如：设置不可重复度、幻影读级 别）。<br>对于只读事务，可以指定事务类型为 readonly，即只读事务。由于只读事务不存在数据的修改，因此数据库将会为只读事务提供一些优化手段。</p><p><a href="https://blog.csdn.net/jinwufeiyang/article/details/119300491">https://blog.csdn.net/jinwufeiyang/article/details/119300491</a></p><h4 id="3-5-异常属性"><a href="#3-5-异常属性" class="headerlink" title="3.5 异常属性"></a>3.5 异常属性</h4><p><strong>使用方式：</strong><br>@Transactional(rollbackFor = IOException.class)</p><p>设置当前事务出现哪些异常就进行回滚或者提交。 </p><p>默认对于 RuntimeException 、Error 及其子类采用的是回滚的策略。<br>默认对于 检查异常及其子类采用的是提交的策略。 </p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220828225955.png"></p><h4 id="3-6-使用推荐"><a href="#3-6-使用推荐" class="headerlink" title="3.6 使用推荐"></a>3.6 使用推荐</h4><p>如果当前业务方法是一组 增、改、删 ： @Transactional<br>如果当前业务方法是一组查询：@Transactionl(readOnly=true)<br>如果当前业务方法是单个查询：@Transactionl(propagation=propagation.SUPPORTS ,readOnly=true)</p><h3 id="4-事务失效"><a href="#4-事务失效" class="headerlink" title="4. 事务失效"></a>4. 事务失效</h3><p><a href="https://baijiahao.baidu.com/s?id=1714667126401049636&amp;wfr=spider&amp;for=pc">https://baijiahao.baidu.com/s?id=1714667126401049636&amp;wfr=spider&amp;for=pc</a></p><p><a href="https://zhuanlan.zhihu.com/p/514257018">https://zhuanlan.zhihu.com/p/514257018</a></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——AOP源码解析</title>
    <link href="/2022/08/14/Spring%E2%80%94%E2%80%94AOP%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/08/14/Spring%E2%80%94%E2%80%94AOP%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.processon.com/view/link/6308fe21f346fb0714c2314d">https://www.processon.com/view/link/6308fe21f346fb0714c2314d</a></p><h3 id="1-动态代理"><a href="#1-动态代理" class="headerlink" title="1. 动态代理"></a>1. 动态代理</h3><p>代理模式：为<strong>对象</strong>提供一种<strong>代理</strong>以控制对这个对象的访问，增强一个类中的某个方法，对程序进行扩展。</p><p>如果我们现在想在<strong>不修改 UserService 类源码</strong>前提下，给 test() 增加额外逻辑，那么就可以使用动态代理机制来创建 UserService 对象了。</p><h4 id="1-1-cglib-动态代理"><a href="#1-1-cglib-动态代理" class="headerlink" title="1.1 cglib 动态代理"></a>1.1 cglib 动态代理</h4><p>比如，现在存在一个UserService类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;test...&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debug</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;debug...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 被代理对象</span><br>UserService target = <span class="hljs-keyword">new</span> UserService();<br><br>Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>enhancer.setSuperclass(UserService.class);<br><br><span class="hljs-comment">// 定义代理逻辑</span><br>enhancer.setCallbacks(<span class="hljs-keyword">new</span> Callback[]&#123;<span class="hljs-keyword">new</span> MethodInterceptor() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * o 代理对象</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;before......&quot;</span>);<br>        <span class="hljs-comment">// 执行被代理对象方法</span><br>        <span class="hljs-comment">// Object result = methodProxy.invoke(target, objects);</span><br>        <span class="hljs-comment">// Object result = method.invoke(target, objects);</span><br>        Object result = methodProxy.invokeSuper(o, objects);  <span class="hljs-comment">// 执行代理对象的父类的方法（等同于执行被代理对象的方法）</span><br>        <span class="hljs-comment">// method.invoke(o,objects); 会无限递归（错误用法）</span><br>        System.out.println(<span class="hljs-string">&quot;after........&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;&#125;);<br>UserService userService = (UserService) enhancer.create();<br>userService.test();<br>userService.debug();<br></code></pre></td></tr></table></figure><p>userService 中的所有方法都会执行相同的代理逻辑。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java">UserService target = <span class="hljs-keyword">new</span> UserService();<br><br>Enhancer enhancer = <span class="hljs-keyword">new</span> Enhancer();<br>enhancer.setSuperclass(UserService.class);<br><br>enhancer.setCallbacks(<span class="hljs-keyword">new</span> Callback[]&#123;<span class="hljs-keyword">new</span> MethodInterceptor() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">intercept</span><span class="hljs-params">(Object o, Method method, Object[] objects, MethodProxy methodProxy)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;before......&quot;</span>);<br>        Object result = methodProxy.invoke(target, objects);<br>        System.out.println(<span class="hljs-string">&quot;after........&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;, NoOp.INSTANCE&#125;);<br><span class="hljs-comment">// NoOp.INSTANCE 为空实现</span><br><span class="hljs-comment">// debug 方法执行下标为0的拦截器，其他的执行下标为1的拦截器</span><br>enhancer.setCallbackFilter(<span class="hljs-keyword">new</span> CallbackFilter() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">accept</span><span class="hljs-params">(Method method)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (method.getName().equals(<span class="hljs-string">&quot;debug&quot;</span>)) &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-number">1</span>;<br>        &#125;<br>    &#125;<br>&#125;);<br>UserService userService = (UserService) enhancer.create();<br>userService.test();<br>userService.debug();<br></code></pre></td></tr></table></figure><p>实现不同的方法执行不同的代理逻辑。</p><p>上面是通过 cglib 来实现的代理对象的创建，是基于<strong>父子类</strong>的，被代理类（UserService）是父类，代理类是子类，代理对象就是代理类的实例对象，代理类是由 cglib 创建的。</p><h4 id="1-2-jdk-动态代理"><a href="#1-2-jdk-动态代理" class="headerlink" title="1.2 jdk 动态代理"></a>1.2 jdk 动态代理</h4><p>除了 cglib技术，jdk 本身也提供了一种创建代理对象的动态代理机制，但是它只能代理接口，也就是 UserService 得先有一个接口才能利用 jdk 动态代理机制来生成一个代理对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserInterface</span> </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserInterface</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test...&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>利用 JDK 动态代理来生成一个代理对象：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">UserService target = <span class="hljs-keyword">new</span> UserService();<br>Object proxy = Proxy.newProxyInstance(UserService.class.getClassLoader(), <span class="hljs-keyword">new</span> Class[]&#123;IUserService.class&#125;, <span class="hljs-keyword">new</span> InvocationHandler() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;before...&quot;</span>);<br>        Object result = method.invoke(target, args);<br>        System.out.println(<span class="hljs-string">&quot;after...&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;);<br>IUserService userService = (IUserService) proxy;<br>userService.test();<br></code></pre></td></tr></table></figure><p>如果你把 new Class[]{UserInterface.class}，替换成 new Class[]{UserService.class}，允许代码会直接报错：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.lang.IllegalArgumentException: com.zth.debugSpring.service.UserService is not an <span class="hljs-class"><span class="hljs-keyword">interface</span></span><br></code></pre></td></tr></table></figure><p>表示一定要是个接口。</p><p>由于这个限制，所以产生的代理对象的类型是 UserInterface，而不是 UserService。</p><p><a href="https://segmentfault.com/a/1190000041619989">https://segmentfault.com/a/1190000041619989</a></p><p><a href="https://blog.csdn.net/m0_38033199/article/details/125852733">https://blog.csdn.net/m0_38033199/article/details/125852733</a></p><p><a href="https://zhuanlan.zhihu.com/p/426867875">https://zhuanlan.zhihu.com/p/426867875</a></p><h3 id="2-ProxyFactory"><a href="#2-ProxyFactory" class="headerlink" title="2. ProxyFactory"></a>2. ProxyFactory</h3><p>在 Spring 中对以上两种动态代理技术进行了封装，封装后的类叫做 ProxyFactory，表示是创建代理对象的一个工厂。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br>UserService target = <span class="hljs-keyword">new</span> UserService();<br><br>ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory();<br>proxyFactory.setTarget(target);<br>proxyFactory.addAdvice(<span class="hljs-keyword">new</span> MethodInterceptor() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;before...&quot;</span>);<br>Object result = invocation.proceed();<br>System.out.println(<span class="hljs-string">&quot;after...&quot;</span>);<br><span class="hljs-keyword">return</span> result;<br>&#125;<br>&#125;);<br><br>UserInterface userService = (UserInterface) proxyFactory.getProxy();<br>userService.test();<br></code></pre></td></tr></table></figure><p>通过 ProxyFactory，可以不再关心到底是用 cglib 还是 jdk 动态代理了，ProxyFactory 会去判断，如果 UserService 实现了接口，那么 ProxyFactory 底层就会用 jdk 动态代理，如果没有实现接口，就会用 cglib 技术。</p><h3 id="3-Advice"><a href="#3-Advice" class="headerlink" title="3. Advice"></a>3. Advice</h3><h4 id="3-1-前置通知-MethodBeforeAdvice"><a href="#3-1-前置通知-MethodBeforeAdvice" class="headerlink" title="3.1 前置通知 MethodBeforeAdvice"></a>3.1 前置通知 MethodBeforeAdvice</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugBeforeAdvice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodBeforeAdvice</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * target：被代理对象</span><br><span class="hljs-comment">     * method：当前执行的方法</span><br><span class="hljs-comment">     * args：执行方法传入的参数</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">(Method method, Object[] args, Object target)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        <span class="hljs-comment">// 只需写代理逻辑，不需要调用被代理方法</span><br>        System.out.println(<span class="hljs-string">&quot;before.....&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-后置返回通知-AfterReturningAdvice"><a href="#3-2-后置返回通知-AfterReturningAdvice" class="headerlink" title="3.2 后置返回通知 AfterReturningAdvice"></a>3.2 后置返回通知 AfterReturningAdvice</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugAfterReturningAdvice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">AfterReturningAdvice</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * returnValue：方法返回值</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturning</span><span class="hljs-params">(Object returnValue, Method method, Object[] args, Object target)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;after return&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-异常通知-ThrowsAdvice"><a href="#3-3-异常通知-ThrowsAdvice" class="headerlink" title="3.3 异常通知 ThrowsAdvice"></a>3.3 异常通知 ThrowsAdvice</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugThrowsAdvice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ThrowsAdvice</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">(Method method,Object[] args,Object target,NullPointerException e)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;after throw nullPointerException&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>ThrowsAdvice 接口不包含任何方法。 它只是标识给定对象实现一个或多个类型化异常通知方法的标识接口,这些应该是以下形式:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">(Exception ex)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">(RemoteException)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">(Method method, Object[] args, Object target, Exception ex)</span></span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">(Method method, Object[] args, Object target, ServletException ex)</span></span><br></code></pre></td></tr></table></figure><h4 id="3-4-环绕通知-MethodInterceptor"><a href="#3-4-环绕通知-MethodInterceptor" class="headerlink" title="3.4 环绕通知 MethodInterceptor"></a>3.4 环绕通知 MethodInterceptor</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// MethodInterceptor 是 aop 包中的，不是 cglib 包中的</span><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugAroundAdvice</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MethodInterceptor</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(MethodInvocation invocation)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;around before...&quot;</span>);<br>        <span class="hljs-comment">// 执行被代理的方法，执行之前会执行其他的 前置通知</span><br>        Object result = invocation.proceed();<br>        System.out.println(<span class="hljs-string">&quot;around after...&quot;</span>);<br>        <span class="hljs-keyword">return</span> result;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Spring 会把五个注解解析为对应的 Advice 类：</p><ol><li>@Before：AspectJMethodBeforeAdvice，实际上就是一个 MethodBeforeAdvice，继承了接口 BeforeAdvice</li><li>@AfterReturning：AspectJAfterReturningAdvice，实际上就是一个 AfterReturningAdvice</li><li>@AfterThrowing：AspectJAfterThrowingAdvice，实际上就是一个MethodInterceptor</li><li>@After：AspectJAfterAdvice，实际上就是一个 MethodInterceptor</li><li>@Around：AspectJAroundAdvice，实际上就是一个 MethodInterceptor</li></ol><h3 id="4-Advisor"><a href="#4-Advisor" class="headerlink" title="4.  Advisor"></a>4.  Advisor</h3><p>一个 Advisor 是由一个 Pointcut 和一个 Advice 组成的，通过 Pointcut 可以指定要需要被代理的逻辑，比如上面的 UserService ，所有方法都会被代理，被增强，可以通过 Advisor，来控制到具体代理哪一个方法。</p><p>比如只有 debug 方法执行代理逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java">UserService target = <span class="hljs-keyword">new</span> UserService();<br><br>ProxyFactory proxyFactory = <span class="hljs-keyword">new</span> ProxyFactory();<br>proxyFactory.setTarget(target);<br><br>proxyFactory.addAdvisor(<span class="hljs-keyword">new</span> PointcutAdvisor() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Pointcut <span class="hljs-title">getPointcut</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StaticMethodMatcherPointcut() &#123;<br>            <span class="hljs-meta">@Override</span><br>            <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(Method method, Class&lt;?&gt; targetClass)</span> </span>&#123;<br>                <span class="hljs-keyword">return</span> method.getName().equals(<span class="hljs-string">&quot;debug&quot;</span>);<br>            &#125;<br>        &#125;;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Advice <span class="hljs-title">getAdvice</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DebugBeforeAdvice();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isPerInstance</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;);<br><br>UserService proxy = (UserService) proxyFactory.getProxy();<br>proxy.test();<br>proxy.debug();<br></code></pre></td></tr></table></figure><h3 id="5-创建代理对象的方式"><a href="#5-创建代理对象的方式" class="headerlink" title="5. 创建代理对象的方式"></a>5. 创建代理对象的方式</h3><p>上面介绍了 Spring 中所提供的 ProxyFactory、Advisor、Advice、PointCu t等技术来实现代理对象的创建，但是在使用 Spring 时，并不会直接去使用 ProxyFactory，比如说，希望 ProxyFactory 所产生的代理对象能直接就是 Bean，能直接从 Spring 容器中得到 UserSerivce 的代理对象，而这些，Spring 都是支持的，只不过肯定需要指定哪些类需要被代理，代理逻辑是什么。</p><h4 id="5-1-ProxyFactoryBean"><a href="#5-1-ProxyFactoryBean" class="headerlink" title="5.1 ProxyFactoryBean"></a>5.1 ProxyFactoryBean</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ProxyFactoryBean <span class="hljs-title">proxyFactoryBean</span><span class="hljs-params">()</span></span>&#123;<br><br>    ProxyFactoryBean proxyFactoryBean = <span class="hljs-keyword">new</span> ProxyFactoryBean();<br>    proxyFactoryBean.addAdvice(<span class="hljs-keyword">new</span> DebugBeforeAdvice());<br>    proxyFactoryBean.setTarget(<span class="hljs-keyword">new</span> UserService());<br><br>    <span class="hljs-keyword">return</span> proxyFactoryBean;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过这种方法来定义一个UserService的Bean，并且是经过了AOP的。但是这种方式<strong>只能针对某一个 Bean</strong>。它是一个 FactoryBean，所以利用的就是 FactoryBean 技术，间接的将 UserService 的代理对象作为了 Bean。</p><p>ProxyFactoryBean 还有额外的功能，比如可以把某个 Advise 或 Advisor 定义成为 Bean，然后在 ProxyFactoryBean 中进行设置</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> DebugBeforeAdvice <span class="hljs-title">debugBeforeAdvice</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DebugBeforeAdvice();<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ProxyFactoryBean <span class="hljs-title">userService</span><span class="hljs-params">()</span></span>&#123;<br>    ProxyFactoryBean proxyFactoryBean = <span class="hljs-keyword">new</span> ProxyFactoryBean();<br>    proxyFactoryBean.setTarget( <span class="hljs-keyword">new</span> UserService());<br>    proxyFactoryBean.setInterceptorNames(<span class="hljs-string">&quot;debugBeforeAdvice&quot;</span>);<br>    <span class="hljs-keyword">return</span> proxyFactoryBean;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-BeanNameAutoProxyCreator"><a href="#5-2-BeanNameAutoProxyCreator" class="headerlink" title="5.2 BeanNameAutoProxyCreator"></a>5.2 BeanNameAutoProxyCreator</h4><p>ProxyFactoryBean 得指定被代理的对象，而 BeanNameAutoProxyCreator 通过指定某个 bean 的名字，来对该 bean 进行代理</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> BeanNameAutoProxyCreator <span class="hljs-title">beanNameAutoProxyCreator</span><span class="hljs-params">()</span> </span>&#123;<br>    BeanNameAutoProxyCreator beanNameAutoProxyCreator = <span class="hljs-keyword">new</span> BeanNameAutoProxyCreator();<br>    <span class="hljs-comment">// 匹配 beanName</span><br>    beanNameAutoProxyCreator.setBeanNames(<span class="hljs-string">&quot;userSer*&quot;</span>);<br>    <span class="hljs-comment">// 前提是将通知作为 Bean</span><br>    beanNameAutoProxyCreator.setInterceptorNames(<span class="hljs-string">&quot;debugBeforeAdvice&quot;</span>);<br>    <span class="hljs-keyword">return</span> beanNameAutoProxyCreator;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过 BeanNameAutoProxyCreator 可以对批量的 Bean 进行 AOP，并且指定了代理逻辑，指定了一个 InterceptorName，也就是一个 Advice，前提条件是这个 Advice 也得是一个 Bean，这样 Spring 才能找到的，但是 BeanNameAutoProxyCreator 的缺点很明显，它只能根据 beanName 来指定想要代理的 Bean。</p><h4 id="5-3-DefaultAdvisorAutoProxyCreator"><a href="#5-3-DefaultAdvisorAutoProxyCreator" class="headerlink" title="5.3 DefaultAdvisorAutoProxyCreator"></a>5.3 DefaultAdvisorAutoProxyCreator</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultPointcutAdvisor <span class="hljs-title">defaultPointcutAdvisor</span><span class="hljs-params">()</span> </span>&#123;<br><br>       NameMatchMethodPointcut pointcut = <span class="hljs-keyword">new</span> NameMatchMethodPointcut();<br>       pointcut.addMethodName(<span class="hljs-string">&quot;debug&quot;</span>);<br><br>       DefaultPointcutAdvisor advisor = <span class="hljs-keyword">new</span> DefaultPointcutAdvisor();<br>       advisor.setPointcut(pointcut);<br>       advisor.setAdvice(<span class="hljs-keyword">new</span> DebugBeforeAdvice());<br>       <span class="hljs-keyword">return</span> advisor;<br>   &#125;<br>   <br><br><span class="hljs-comment">// 等价于 @Import(DefaultAdvisorAutoProxyCreator.class)</span><br>   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> DefaultAdvisorAutoProxyCreator  <span class="hljs-title">defaultAdvisorAutoProxyCreator</span><span class="hljs-params">()</span></span>&#123;<br>       <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> DefaultAdvisorAutoProxyCreator();<br>   &#125;<br></code></pre></td></tr></table></figure><p>DefaultAdvisorAutoProxyCreator 是一个 BeanPostProcessor，会使 Bean 在初始化后找到所有的 Advisor，匹配其中的 pointcut ，如果匹配则生成代理对象。</p><p>但是，通过这种方式得依靠某一个类来实现定义 Advisor，或者 Advise，或者 Pointcut，那么这个步骤能不能更加简化一点呢？</p><p>对的，通过<strong>注解</strong>！</p><h4 id="5-4-通过注解"><a href="#5-4-通过注解" class="headerlink" title="5.4 通过注解"></a>5.4 通过注解</h4><p>定义一个类，在类中的方法上通过某些注解，来定义 PointCut 以及 Advice。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugAspect</span> </span>&#123;<br>    <br>    <span class="hljs-meta">@Before(&quot;execution(public void com.zth.debugSpring.service.UserService.test())&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugBefore</span><span class="hljs-params">(JoinPoint joinPoint)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Before.....&quot;</span>);<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>对于 Spring 来说，要做的就是来解析这些注解，解析之后得到对应的 Pointcut 对象、Advice 对象，生成 Advisor 对象，放进 ProxyFactory 中，进而产生对应的代理对象（由 @EnableAspectJAutoProxy 注解完成）。</p><h3 id="6-对-Spring-AOP-的理解"><a href="#6-对-Spring-AOP-的理解" class="headerlink" title="6. 对 Spring AOP 的理解"></a>6. 对 Spring AOP 的理解</h3><p>OOP表示面向对象编程，是一种编程思想，AOP表示面向切面编程，也是一种编程思想，而上面所描述的就是 Spring 为了更加方便的做到面向切面编程所提供的技术支持，换句话说，就是 Spring 提供了一套机制，可以更加容易的来进行 AOP，这套机制可以称之为 Spring AOP。</p><p>上面所提供的注解的方式来定义 Pointcut 和 Advice，Spring 并不是首创，首创是 AspectJ，而且也不仅仅只有 Spring 提供了一套机制来支持 AOP，还有比如 JBoss 4.0、aspectwerkz 等技术都提供了对于 AOP 的支持。而刚刚说的注解的方式，Spring 是依赖了 AspectJ 的，或者说，Spring 是直接把 AspectJ 中所定义的那些注解直接拿过来用，自己没有再重复定义了，不过也仅仅只是把注解的定义复制过来了，每个注解具体底层是怎么解析的，还是 Spring 自己做的，所以在用 Spring 时，如果你想用 @Before、@Around 等注解，需要引入 aspecj 相关 jar 包的。</p><p>值得注意的是：AspectJ 是在编译时对字节码进行了修改，是直接在 UserService 类对应的字节码中进行增强的，也就是说在编译时就会去解析 @Before 这些注解，然后得到代理逻辑，加入到被代理的类中的字节码中去的，所以如果想用 AspectJ 技术来生成代理对象 ，是需要用单独的 AspectJ 编译器的。而 Spring 只是用了 @Before 这些注解，在启动 Spring 的过程中，Spring 会去解析这些注解，然后利用动态代理机制生成代理对象。</p><p>IDEA中使用Aspectj：<a href="https://blog.csdn.net/gavin_john/article/details/80156963">https://blog.csdn.net/gavin_john/article/details/80156963</a></p><h3 id="7-TargetSource-的使用"><a href="#7-TargetSource-的使用" class="headerlink" title="7. TargetSource 的使用"></a>7. TargetSource 的使用</h3><p>AOP 中被代理对象就是 Bean 对象，是由 BeanFactory 给我们创建出来的，Spring AOP 中提供了 TargetSource 机制，可以用来自定义逻辑来创建<strong>被代理对象</strong>。</p><p>当 @Lazy注解加在属性上时，会产生一个代理对象赋值给这个属性，生成代理对象的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">buildLazyResolutionProxy</span><span class="hljs-params">(<span class="hljs-keyword">final</span> DependencyDescriptor descriptor, <span class="hljs-keyword">final</span> <span class="hljs-meta">@Nullable</span> String beanName)</span> </span>&#123;<br>BeanFactory beanFactory = getBeanFactory();<br>Assert.state(beanFactory <span class="hljs-keyword">instanceof</span> DefaultListableBeanFactory,<br><span class="hljs-string">&quot;BeanFactory needs to be a DefaultListableBeanFactory&quot;</span>);<br><span class="hljs-keyword">final</span> DefaultListableBeanFactory dlbf = (DefaultListableBeanFactory) beanFactory;<br><br>TargetSource ts = <span class="hljs-keyword">new</span> TargetSource() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> Class&lt;?&gt; getTargetClass() &#123;<br><span class="hljs-keyword">return</span> descriptor.getDependencyType();<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isStatic</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getTarget</span><span class="hljs-params">()</span> </span>&#123;<br>Set&lt;String&gt; autowiredBeanNames = (beanName != <span class="hljs-keyword">null</span> ? <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;(<span class="hljs-number">1</span>) : <span class="hljs-keyword">null</span>);<br>Object target = dlbf.doResolveDependency(descriptor, beanName, autowiredBeanNames, <span class="hljs-keyword">null</span>);<br><span class="hljs-keyword">if</span> (target == <span class="hljs-keyword">null</span>) &#123;<br>Class&lt;?&gt; type = getTargetClass();<br><span class="hljs-keyword">if</span> (Map.class == type) &#123;<br><span class="hljs-keyword">return</span> Collections.emptyMap();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (List.class == type) &#123;<br><span class="hljs-keyword">return</span> Collections.emptyList();<br>&#125;<br><span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (Set.class == type || Collection.class == type) &#123;<br><span class="hljs-keyword">return</span> Collections.emptySet();<br>&#125;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchBeanDefinitionException(descriptor.getResolvableType(),<br><span class="hljs-string">&quot;Optional dependency not present for lazy injection point&quot;</span>);<br>&#125;<br><span class="hljs-keyword">if</span> (autowiredBeanNames != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">for</span> (String autowiredBeanName : autowiredBeanNames) &#123;<br><span class="hljs-keyword">if</span> (dlbf.containsBean(autowiredBeanName)) &#123;<br>dlbf.registerDependentBean(autowiredBeanName, beanName);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> target;<br>&#125;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">releaseTarget</span><span class="hljs-params">(Object target)</span> </span>&#123;<br>&#125;<br>&#125;;<br><br>ProxyFactory pf = <span class="hljs-keyword">new</span> ProxyFactory();<br>pf.setTargetSource(ts);<br>Class&lt;?&gt; dependencyType = descriptor.getDependencyType();<br><span class="hljs-keyword">if</span> (dependencyType.isInterface()) &#123;<br>pf.addInterface(dependencyType);<br>&#125;<br><span class="hljs-keyword">return</span> pf.getProxy(dlbf.getBeanClassLoader());<br>&#125;<br></code></pre></td></tr></table></figure><p>这段代码就利用了ProxyFactory来生成代理对象，以及使用了TargetSource，以达到代理对象在执行某个方法时，调用TargetSource的getTarget()方法实时得到一个<strong>被代理对象</strong>。</p><h3 id="8-ProxyFactory-选择-cglib-或-jdk-动态代理原理"><a href="#8-ProxyFactory-选择-cglib-或-jdk-动态代理原理" class="headerlink" title="8. ProxyFactory 选择 cglib 或 jdk 动态代理原理"></a>8. ProxyFactory 选择 cglib 或 jdk 动态代理原理</h3><p>ProxyFactory 在生成代理对象之前需要决定到底是使用 JDK 动态代理还是 CGLIB 技术：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// config就是ProxyFactory对象</span><br><span class="hljs-comment">// optimize为true,或proxyTargetClass为true,或用户没有给ProxyFactory对象添加interface</span><br><span class="hljs-keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;<br>Class&lt;?&gt; targetClass = config.getTargetClass();<br><span class="hljs-keyword">if</span> (targetClass == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopConfigException(<span class="hljs-string">&quot;TargetSource cannot determine target class: &quot;</span> +<br><span class="hljs-string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);<br>&#125;<br>    <span class="hljs-comment">// targetClass是接口，直接使用Jdk动态代理</span><br><span class="hljs-keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);<br>&#125;<br>    <span class="hljs-comment">// 使用Cglib</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObjenesisCglibAopProxy(config);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-comment">// 使用Jdk动态代理</span><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-代理对象的创建"><a href="#9-代理对象的创建" class="headerlink" title="9. 代理对象的创建"></a>9. 代理对象的创建</h3><h4 id="9-1-JdkDynamicAopProxy"><a href="#9-1-JdkDynamicAopProxy" class="headerlink" title="9. 1 JdkDynamicAopProxy"></a>9. 1 JdkDynamicAopProxy</h4><ol><li>在构造 JdkDynamicAopProxy 对象时，会先拿到被代理对象自己所实现的接口，并且额外的增加 SpringProxy、Advised、DecoratingProxy 三个接口，组合成一个 Class[]，并赋值给 proxiedInterfaces 属性</li><li>并且检查这些接口中是否定义了 equals()、hashcode() 方法</li><li>执行 <code>Proxy.newProxyInstance(classLoader, this.proxiedInterfaces, this)</code>，得到代理对象，<strong>JdkDynamicAopProxy</strong> 作为 InvocationHandler，代理对象在执行某个方法时，会进入到JdkDynamicAopProxy 的 <strong>invoke()</strong> 方法中</li></ol><h4 id="9-2-ObjenesisCglibAopProxy"><a href="#9-2-ObjenesisCglibAopProxy" class="headerlink" title="9.2 ObjenesisCglibAopProxy"></a>9.2 ObjenesisCglibAopProxy</h4><ol><li>创建 Enhancer 对象</li><li>设置 Enhancer 的 superClass 为通过 ProxyFactory.setTarget() 所设置的对象的类</li><li>设置 Enhancer 的 interfaces 为通过 ProxyFactory.addInterface() 所添加的接口，以及 SpringProxy、Advised、DecoratingProxy 接口</li><li>设置 Enhancer 的 Callbacks 为 DynamicAdvisedInterceptor</li><li>最后创建一个代理对象，代理对象在执行某个方法时，会进入到 DynamicAdvisedInterceptor 的 intercept() 方法中</li></ol><h3 id="10-代理对象执行过程"><a href="#10-代理对象执行过程" class="headerlink" title="10. 代理对象执行过程"></a>10. 代理对象执行过程</h3><ol><li>在使用 ProxyFactory 创建代理对象之前，需要往 ProxyFactory 先添加 Advisor</li><li>代理对象在执行某个方法时，会把 ProxyFactory 中的 Advisor 拿出来和当前正在执行的方法进行匹配筛选</li><li>把和方法所匹配的 Advisor 适配成 MethodInterceptor</li><li>把和当前方法匹配的 MethodInterceptor 链，以及被代理对象、代理对象、代理类、当前 Method 对象、方法参数封装为 MethodInvocation 对象</li><li>调用 MethodInvocation 的 proceed() 方法，开始执行各个 MethodInterceptor 以及被代理对象的对应方法</li><li>按顺序调用每个MethodInterceptor 的 invoke() 方法，并且会把 MethodInvocation 对象传入 invoke() 方法</li><li>直到执行完最后一个 MethodInterceptor 了，就会调用 invokeJoinpoint() 方法，从而执行被代理对象的当前方法</li></ol><h3 id="11-各注解对应的-MethodInterceptor"><a href="#11-各注解对应的-MethodInterceptor" class="headerlink" title="11. 各注解对应的 MethodInterceptor"></a>11. 各注解对应的 MethodInterceptor</h3><ul><li><strong>@Before</strong>  对应 AspectJMethodBeforeAdvice，在进行动态代理时会转成 <strong>MethodBeforeAdviceInterceptor</strong><ul><li>先执行 advice 对应的方法</li><li>再执行 MethodInvocation 的 proceed()，会执行下一个 Interceptor，如果没有下一个 Interceptor 了，会执行 target 对应的方法</li></ul></li><li><strong>@After</strong> 对应 AspectJAfterAdvice，直接实现了 <strong>MethodInterceptor</strong><ul><li>先执行 MethodInvocation 的 proceed()，会执行下一个 Interceptor，如果没有下一个 Interceptor了，会执行 target 对应的方法</li><li>再执行 advice 对应的方法</li></ul></li><li><strong>@Around</strong> 对应 AspectJAroundAdvice，直接实现了  <strong>MethodInterceptor</strong><ul><li>直接执行 advice 对应的方法，由 @Around 自己决定要不要继续往后面调用</li></ul></li><li><strong>@AfterThrowing</strong> 对应 AspectJAfterThrowingAdvice，直接实现了 <strong>MethodInterceptor</strong><ul><li>先执行 MethodInvocation 的 proceed()，会执行下一个 Interceptor，如果没有下一个 Interceptor 了，会执行 target 对应的方法</li><li>如果上面抛了 Throwable，那么则会执行 advice 对应的方法</li></ul></li><li><strong>@AfterReturning</strong> 对应 AspectJAfterReturningAdvice，在进行动态代理时转成 <strong>AfterReturningAdviceInterceptor</strong> <ul><li>先执行 MethodInvocation 的 proceed()，会执行下一个 Interceptor，如果没有下一个 Interceptor 了，会执行 target 对应的方法</li><li>执行上面的方法后得到最终的方法的返回值</li><li>再执行 Advice 对应的方法</li></ul></li></ul><h3 id="12-AbstractAdvisorAutoProxyCreator"><a href="#12-AbstractAdvisorAutoProxyCreator" class="headerlink" title="12. AbstractAdvisorAutoProxyCreator"></a>12. AbstractAdvisorAutoProxyCreator</h3><p>DefaultAdvisorAutoProxyCreator 的父类是 AbstractAdvisorAutoProxyCreator。</p><p>只要 Spring 容器中存在 <strong>AbstractAdvisorAutoProxyCreator</strong>  类型的 Bean，就相当于开启了 AOP，AbstractAdvisorAutoProxyCreator 实际上就是一个 BeanPostProcessor，所以在创建某个 Bean 时，就会进入到它对应的生命周期方法中，比如：在某个 Bean <strong>初始化之后</strong>，会调用 wrapIfNecessary() 方法进行 AOP，底层逻辑是，AbstractAdvisorAutoProxyCreator 会找到所有的 Advisor，然后判断当前这个 Bean 是否存在某个 Advisor 与之匹配（根据 Pointcut），如果匹配就表示当前这个 Bean 有对应的切面逻辑，需要进行 AOP，需要产生一个代理对象。</p><h3 id="13-EnableAspectJAutoProxy"><a href="#13-EnableAspectJAutoProxy" class="headerlink" title="13 @EnableAspectJAutoProxy"></a>13 @EnableAspectJAutoProxy</h3><p>这个注解主要就是往 Spring 容器中添加了一个 AnnotationAwareAspectJAutoProxyCreator 类型的 Bean。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220824223600.png"></p><p><strong>AspectJAwareAdvisorAutoProxyCreator</strong> 继承了 <strong>AbstractAdvisorAutoProxyCreator</strong>，重写了 findCandidateAdvisors() 方法，<strong>AbstractAdvisorAutoProxyCreator</strong> 只能找到所有 Advisor 类型的 Bean 对象，但是 <strong>AspectJAwareAdvisorAutoProxyCreator</strong> 除开可以找到所有 Advisor 类型的 Bean 对象，还能把 @Aspect 注解所标注的 Bean 中的 @Before 等注解及方法进行解析，并生成对应的 Advisor 对象。</p><p>所以，我们可以理解 @EnableAspectJAutoProxy，其实就是向 Spring 容器中添加了一个 AbstractAdvisorAutoProxyCreator 类型的 Bean，从而开启了 AOP，并且还会解析 @Before 等注解生成 Advisor。</p><h3 id="14-Spring-中-AOP-原理流程图"><a href="#14-Spring-中-AOP-原理流程图" class="headerlink" title="14. Spring 中 AOP 原理流程图"></a>14. Spring 中 AOP 原理流程图</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220821204534.png"><br><a href="https://www.processon.com/view/link/5faa4ccce0b34d7a1aa2a9a5">https://www.processon.com/view/link/5faa4ccce0b34d7a1aa2a9a5</a></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——AOP的使用</title>
    <link href="/2022/08/06/Spring%E2%80%94%E2%80%94AOP%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/08/06/Spring%E2%80%94%E2%80%94AOP%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1-AOP-概念"><a href="#1-AOP-概念" class="headerlink" title="1. AOP 概念"></a>1. AOP 概念</h3><p>面向切面编程（Aspect-oriented Programming 简称 AOP），是相对面向对象编程（Object-oriented Programming 简称OOP）的框架，作为 OOP 的一种功能补充.。OOP 主要的模块单元是类（class）。而 AOP 则是切面（aspect）。切面会将诸如事务管理这样跨越多个类型和对象的关注点模块化（在AOP 的语义中，这类关注点被称为横切关注点（crosscutting））。</p><h4 id="1-1-切面（Aspect）"><a href="#1-1-切面（Aspect）" class="headerlink" title="1.1 切面（Aspect）"></a>1.1 切面（Aspect）</h4><p>指关注点模块化，这个关注点可能会横切多个对象。 在 Spring AOP 中，切面可以用普通类基于 schema 的方式或者以 @Aspect 注解来实现。</p><p>它是通知（Advice）和切点（Pointcut）合起来的抽象，它定义了一个切点（Pointcut）用来匹配连接点（Join point），也就是需要对需要拦截的那些方法进行定义；它定义了一系列的通知（Advice）用来对拦截到的方法进行增强。</p><h4 id="1-2-连接点（Join-point）"><a href="#1-2-连接点（Join-point）" class="headerlink" title="1.2 连接点（Join point）"></a>1.2 连接点（Join point）</h4><p>在程序执行过程中某个特定的点，例如某个方法调用的时间点或者处理异常的时间点。在Spring AOP中，一个连接点总是代表一个方法的执行。</p><p>org.aspectj.lang.JoinPoint 接口表示目标类连接点对象，它定义这些主要方法。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220809212859.png"></p><p>org.aspectj.lang.ProceedingJoinPoint 继承了 JoinPoint 接口，该对象只用在 @Around 的切面方法中,添加了以下两个方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 执行目标方法</span><br><span class="hljs-function">Object <span class="hljs-title">proceed</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Throwable </span><br><span class="hljs-function"> <span class="hljs-comment">// 传入的新的参数去执行目标方法 </span></span><br><span class="hljs-function">Object <span class="hljs-title">proceed</span><span class="hljs-params">(Object[] var1)</span> <span class="hljs-keyword">throws</span> Throwable</span><br></code></pre></td></tr></table></figure><h4 id="1-3-通知（Advice）"><a href="#1-3-通知（Advice）" class="headerlink" title="1.3 通知（Advice）"></a>1.3 通知（Advice）</h4><p>在切面的某个特定的连接点上执行的动作。许多 AOP 框架，包括 Spring 在内，都是以拦截器做通知模型的，并维护着一个以连接点为中心的拦截器链。</p><p>Spring AOP 包含以下类型的通知：</p><ul><li>前置通知（Before advice）: 在连接点之前运行但无法阻止执行流程进入连接点的通知（除非它引发异常）。</li><li>后置返回通知（After returning advice）:在连接点正常完成后执行的通知（例如，当方法没有抛出任何异常并正常返回时）。</li><li>后置异常通知（After throwing advice）: 在方法抛出异常退出时执行的通知。</li><li>后置通知（总会执行）（After (finally) advice）: 当连接点退出的时候执行的通知（无论是正常返回还是异常退出）。</li><li>环绕通知（Around Advice）:环绕连接点的通知，例如方法调用。这是最强大的一种通知类型。环绕通知可以在方法调用前后完成自定义的行为。它可以选择是否继续执行连接点或直接返回自定义的返回值又或抛出异常将执行结束。</li></ul><p>通知方法的执行顺序：<br>1、正常执行：@Before—&gt;@After—&gt;@AfterReturning<br>2、异常执行：@Before—&gt;@After—&gt;@AfterThrowing</p><p><strong><font color="red">Spring 在 5.2.7 之后就改变的 advice 的执行顺序。</font></strong><br>1、正常执行：@Before—&gt;@AfterReturning—&gt;@After<br>2、异常执行：@Before—&gt;@AfterThrowing—&gt;@After</p><h4 id="1-4-切点（Pointcut）"><a href="#1-4-切点（Pointcut）" class="headerlink" title="1.4 切点（Pointcut）"></a>1.4 切点（Pointcut）</h4><p>匹配连接点的断言。通知和切点表达式相关联，并在满足这个切点的连接点上运行（例如当执行某个特定名称的方法时）。切点表达式如何和连接点匹配是 AOP 的核心，Spring 默认使用 AspectJ 切点语义。</p><p>Spring AOP 支持使用以下 AspectJ 切点标识符(PCD)，用于切点表达式：</p><ul><li>execution：用于匹配<strong>方法</strong>执行连接点。</li><li>within: 限制匹配<strong>类</strong>中的连接点。</li><li>this:  匹配代理对象实现了某个接口的连接点。</li><li>target: 匹配目标对象实现了某个接口的连接点。</li><li>args: 限制与连接点的匹配，其中变量是给定类型的实例。</li><li>@target: 限制与连接点的匹配，其中执行对象的类具有给定类型的注解。</li><li>@args: 限制匹配连接点，其中传递的实际参数的运行时类型具有给定类型的注解。</li><li>@within: 限制与具有给定注解的类型中的连接点匹配。</li><li>@annotation:限制匹配连接点（在Spring AOP中执行的方法具有给定的注解）。</li></ul><p>表达式语法：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220809224055.png"></p><p>除返回类型模式（ret-type-pattern ）以外的所有部件、名称模式和参数模式都是可选的。通常，可以使用 * 作为返回类型模式，它匹配任何返回类型。只有当方法返回给定类型时，完全限定的类型名称才会匹配。名称模式与方法名称匹配，可以将 * 通配符用作名称模式的全部或部分。 如果指定声明类型模式，则需要有后缀 <strong>.</strong> 将其加入到名称模式组件中。参数模式稍微复杂一点。() 匹配没有参数的方法。(..) 匹配任意个数的参数（0个或多个）。 (*) 匹配任何类型的单个参数。(*,String) 匹配有两个参数而且第一个参数是任意类型，第二个必须是 String 的方法。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220809224141.png"></p><ol><li>within 表达式<br>通过类名进行匹配，粗粒度的切入点表达式。<br>在 within 表达式中可以使用 * 号通配符，例如匹配指定包下所有的类：</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;within(cn.tulingxueyuan.service.*)&quot;</span></span><br></code></pre></td></tr></table></figure><ol start="2"><li>execution 表达式<br>细粒度的切入点表达式，可以以方法为单位定义切入点规则</li></ol><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* cn.tulingxueyuan.service.*.query())&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;pc1&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><ol start="3"><li>合并切点表达式<br>可以使用 &amp;&amp;, || 和 ! 等符号进行合并操作。也可以通过名字来指向切点表达式。 </li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;execution(public * *(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">anyPublicOperation</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><span class="hljs-meta">@Pointcut(&quot;within(com.xyz.someapp.trading..*)&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">inTrading</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br><span class="hljs-meta">@Pointcut(&quot;anyPublicOperation() &amp;&amp; inTrading()&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">tradingOperation</span><span class="hljs-params">()</span> </span>&#123;&#125;<br></code></pre></td></tr></table></figure><h4 id="1-5-引入（Introduction）"><a href="#1-5-引入（Introduction）" class="headerlink" title="1.5 引入（Introduction）"></a>1.5 引入（Introduction）</h4><p>声明额外的方法或者某个类型的字段。Spring 允许引入新的接口（以及一个对应的实现）到任何被通知的对象上。例如，可以使用引入来使 bean 实现  IsModified 接口， 以便简化缓存机制（在 AspectJ 社区，引入也被称为内部类型声明（inter））。</p><p>@DeclareParents<br><a href="https://blog.csdn.net/swh1234567/article/details/116454743">https://blog.csdn.net/swh1234567/article/details/116454743</a></p><h4 id="1-6-目标对象（Target-object）"><a href="#1-6-目标对象（Target-object）" class="headerlink" title="1.6 目标对象（Target object）"></a>1.6 目标对象（Target object）</h4><p>被一个或者多个切面所通知的对象。也被称作被通知（advised）对象。既然 Spring AOP 是通过运行时代理实现的，那么这个对象永远是一个被代理（proxied）的对象。</p><h4 id="1-7-AOP代理（AOP-proxy）"><a href="#1-7-AOP代理（AOP-proxy）" class="headerlink" title="1.7 AOP代理（AOP proxy）"></a>1.7 AOP代理（AOP proxy）</h4><p>AOP 框架创建的对象，用来实现切面契约（aspect contract）（包括通知方法执行等功能）。在 Spring 中，AOP 代理可以是 JDK 动态代理或 CGLIB 代理。</p><h4 id="1-8-织入（Weaving）"><a href="#1-8-织入（Weaving）" class="headerlink" title="1.8 织入（Weaving）"></a>1.8 织入（Weaving）</h4><p>把切面连接到其它的应用程序类型或者对象上，并创建一个被通知的对象的过程。这个过程可以在编译时（例如使用 AspectJ 编译器）、类加载时或运行时中完成。 Spring 和其他纯 Java AOP 框架一样，是在运行时完成织入的。</p><p>一个连接点可以同时匹配多个切点，而切点所对应的增强在连接点上织入顺序的规则是这样的：<br>①如果在同一个切面类中声明的增强，则按照增强在切面类中定义的顺序进行织入；<br>②如果增强位于不同的切面类中，并且这些切面类都实现了org.springframework.core.Ordered 接口，则由 Ordered 方法的顺序号决定(顺序号小的先织入)；<br>③如果增强位于不同的切面类中，但这些切面类没有实现org.springframework.core.Ordered 接口，织入的顺序是不确定的。</p><p>两个切面类 A 与 B，都实现了 Ordered 接口，A 的顺序号为 1，B 的顺序号为 2。切面类 A 与 B 都定义了 3 个增强，那么同时匹配这 6 个增强的织入顺序如下图所示：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220809220528.png"></p><h3 id="2-基于-AspectJ的AOP支持"><a href="#2-基于-AspectJ的AOP支持" class="headerlink" title="2. 基于@AspectJ的AOP支持"></a>2. 基于@AspectJ的AOP支持</h3><p>添加依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-aspects<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.3.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-1-启用-AspectJ支持"><a href="#2-1-启用-AspectJ支持" class="headerlink" title="2.1 启用@AspectJ支持"></a>2.1 启用@AspectJ支持</h4><ol><li>使用 Java @Configuration 启用 @AspectJ 支持</li></ol> <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@EnableAspectJAutoProxy</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p> <br> 2. 使用 XML 配置启用 @AspectJ 支持</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspectj-autoproxy</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-2-声明切面"><a href="#2-2-声明切面" class="headerlink" title="2.2 声明切面"></a>2.2 声明切面</h4><p>启用了 @AspectJ 支持后，在应用程序上下文中定义的 有 @Aspect 注解的 bean 都将被 Spring 自动检测用于配置 Spring AOP。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugAspect</span> </span>&#123;<br>    <br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-声明切点"><a href="#2-3-声明切点" class="headerlink" title="2.3 声明切点"></a>2.3 声明切点</h4><p>切点决定了匹配的连接点，从而能够控制通知何时执行。Spring AOP 只支持使用 Spring bean 的方法执行连接点，所以可以将切点看做是匹配 Spring bean 上方法的执行。 切点的声明包含两个部分：包含名称和任意参数的签名，以及明确需要匹配的方式执行的切点表达式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* com.zth.debugSpring.service..*(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>表达式的抽取</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Pointcut(&quot;execution(* com.zth.debugSpring.service..*(..))&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">allService</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br><span class="hljs-meta">@Before(&quot;allService()&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span></span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-声明通知"><a href="#2-4-声明通知" class="headerlink" title="2.4 声明通知"></a>2.4 声明通知</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugAspect</span> </span>&#123;<br>    <span class="hljs-meta">@Pointcut(&quot;execution(* com.zth.debugSpring.service.UserService.getUser(..))&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">allService</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 前置通知</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Before(&quot;allService()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">before</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;before 执行&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 后置返回通知</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@AfterReturning(pointcut = &quot;allService()&quot;, returning = &quot;revalue&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterReturning</span><span class="hljs-params">(Object revalue)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;AfterReturning,返回值：&quot;</span> + revalue);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 后置异常通知</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@AfterThrowing(pointcut = &quot;allService()&quot;, throwing = &quot;ex&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterThrowing</span><span class="hljs-params">(Exception ex)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;afterThrowing,返回异常：&quot;</span> + ex);<br>    &#125;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 后置通知(总会执行)</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@After(&quot;allService()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">After</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;After 执行&quot;</span>);<br>    &#125;<br><br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 使用 <span class="hljs-doctag">@Around</span>注解来定义环绕通知，第一个参数必须是 ProceedingJoinPoint类型的。</span><br><span class="hljs-comment">     * 在通知中调用 ProceedingJoinPoint中的 proceed()方法来引用执行的方法。</span><br><span class="hljs-comment">     * proceed 方法也可以被调用传递数组对象- 数组的值将会被当作参数在方法执行时被使用。</span><br><span class="hljs-comment">     * proceed 方法也可以传入 Object[]。 数组中的值在进行时用作方法执行的参数。</span><br><span class="hljs-comment">     */</span><br><br>    <span class="hljs-meta">@Around(&quot;allService()&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">around</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Around before&quot;</span>);<br>        pjp.proceed();<br>        System.out.println(<span class="hljs-string">&quot;Around after&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="通知的参数"><a href="#通知的参数" class="headerlink" title="通知的参数"></a>通知的参数</h5><p>任何通知方法都可以声明一个类型为 org.aspectj.lang.JoinPoint 的参数作为其第一个参数（注意，需要使用 ProceedingJoinPoint  来声明 around advice  的第一个参数， 它是JoinPoint的一个子类）。JoinPoint接口提供很多有用的方法：:</p><ul><li>getArgs(): 返回方法参数.</li><li>getThis(): 返回代理对象.</li><li>getTarget(): 返回目标对象.</li><li>getSignature():返回正在通知的方法的描述.</li><li>toString(): 打印方法被通知的有用描述.</li></ul><h5 id="传递参数给通知"><a href="#传递参数给通知" class="headerlink" title="传递参数给通知"></a>传递参数给通知</h5><p>上面已经看到了如何绑定返回的值或异常值（在返回之后和抛出通知之后使用）。为了在通知代码段中使用参数值，可以使用绑定 args 的形式。如果在参数表达式中使用参数名代替类型名称， 则在调用通知时，要将相关的参数值当作参数传递。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(&quot;execution(* com.zth.debugSpring.service.UserService.getUser(..)) &amp;&amp; args(userId)&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testArgs</span><span class="hljs-params">(Integer userId)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Before 执行,args:&quot;</span>+userId);<br>&#125;<br><br><span class="hljs-meta">@Pointcut(&quot;execution(* com.zth.debugSpring.service.UserService.getUser(..)) &amp;&amp; args(userId)&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">argsPointcut</span><span class="hljs-params">(Integer userId)</span></span>&#123;<br><br>&#125;<br><span class="hljs-meta">@Before(value = &quot;argsPointcut(userId)&quot;, argNames = &quot;userId&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testArgs2</span><span class="hljs-params">(Integer userId)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;Before 执行,args:&quot;</span>+userId);<br>&#125;<br></code></pre></td></tr></table></figure><p>代理对象( this)，目标对象 ( target)和注解 ( @within, @target, @annotation, and @args)都可以以类似的方式绑定。</p><h5 id="声明参数的名字"><a href="#声明参数的名字" class="headerlink" title="声明参数的名字"></a>声明参数的名字</h5><p>参数在通知中的绑定依赖于名字匹配，重点在切点表达式中定义的参数名的方法签名上（通知和切点）。</p><ul><li>如果用户已明确指定参数名称，则使用指定的参数名称。通知和切点注解都有一个可选的argNames属性，您可以使用该属性指定带注解的方法的参数名称。 这些参数名称在运行时可用。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Before(value=&quot;com.xyz.lib.Pointcuts.anyPublicMethod() &amp;&amp; target(bean) &amp;&amp; @annotation(auditable)&quot;,</span><br><span class="hljs-meta">        argNames=&quot;bean,auditable&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">audit</span><span class="hljs-params">(Object bean, Auditable auditable)</span> </span>&#123;<br>    AuditCode code = auditable.value();<br>    <span class="hljs-comment">// ... use code and bean</span><br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用’argNames’属性有点笨拙，所以如果没有指定’argNames’属性，Spring AOP会查看该类的调试信息，并尝试从局部变量表中确定参数名称。</li><li>如果代码是在没有必要的调试信息的情况下编译的，那么Spring AOP将尝试推断绑定变量与参数的配对（例如，如果在切点表达式中只绑定了一个变量，并且该通知方法只需要一个参数，此时两者匹配是明显的）。 如果给定了可用信息，变量的绑定是不明确的话，则会引发 AmbiguousBindingException 异常。</li><li>如果上述所有策略都失败，则抛出 IllegalArgumentException 异常。</li></ul><h4 id="2-5-引入"><a href="#2-5-引入" class="headerlink" title="2.5 引入"></a>2.5 引入</h4><p>引入（作为 AspectJ 中内部类型的声明）允许切面定义通知的对象实现给定的接口，并代表这些对象提供该接口的实现.。</p><p>引入使用 @DeclareParents 注解来定义，这个注解用于声明匹配拥有新的父类的类型。例如， 给定名为 UsageTracked 的接口和名为 DefaultUsageTracked 的接口的实现，以下切面声明服务接口的所有实现者也实现 UsageTracked 接口。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Aspect</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UsageTracking</span> </span>&#123;<br><br>    <span class="hljs-meta">@DeclareParents(value=&quot;com.xzy.myapp.service.*+&quot;, defaultImpl=DefaultUsageTracked.class)</span><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UsageTracked mixin;<br><br>    <span class="hljs-meta">@Before(&quot;com.xyz.myapp.SystemArchitecture.businessService() &amp;&amp; this(usageTracked)&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recordUsage</span><span class="hljs-params">(UsageTracked usageTracked)</span> </span>&#123;<br>        usageTracked.incrementUseCount();<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>要实现的接口由注解属性的类型来确定。 @DeclareParents注解的value值是AspectJ类型模式引过来的。服务 bean 可以直接作为 UsageTracked 接口的实现，等同于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">UsageTracked usageTracked = (UsageTracked) context.getBean(<span class="hljs-string">&quot;myService&quot;</span>);<br></code></pre></td></tr></table></figure><h3 id="3-基于Schema的AOP支持"><a href="#3-基于Schema的AOP支持" class="headerlink" title="3. 基于Schema的AOP支持"></a>3. 基于Schema的AOP支持</h3><p>在 Spring 配置中，所有 aspect 和 advisor 元素必须放在 &lt;aop:config&gt; 元素中（在应用程序上下文配置中可以有多个 &lt;aop:config&gt;元素）。 &lt;aop:config&gt; 元素可以包含切点，通知者和切面元素。</p><h4 id="3-1-声明切面"><a href="#3-1-声明切面" class="headerlink" title="3.1 声明切面"></a>3.1 声明切面</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;debugAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.DebugAspect&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;debugAspect&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-2-声明切点"><a href="#3-2-声明切点" class="headerlink" title="3.2 声明切点"></a>3.2 声明切点</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userPointCut&quot;</span></span><br><span class="hljs-tag">                          <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.zth.debugSpring.service.UserService.getUser(..))&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="3-3-声明通知"><a href="#3-3-声明通知" class="headerlink" title="3.3  声明通知"></a>3.3  声明通知</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;debugAspect&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.DebugAspect&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userPointCut&quot;</span></span><br><span class="hljs-tag">                  <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.zth.debugSpring.service.UserService.getUser(..))&quot;</span>/&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;debugAspect&quot;</span>&gt;</span><br>        <span class="hljs-comment">&lt;!--前置通知--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;userPointCut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;debugBefore&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--后置返回通知--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-returning</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;userPointCut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;debugAfterReturning&quot;</span> <span class="hljs-attr">returning</span>=<span class="hljs-string">&quot;revalue&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--后置异常通知--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after-throwing</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;userPointCut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;debugAfterThrowing&quot;</span> <span class="hljs-attr">throwing</span>=<span class="hljs-string">&quot;ex&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--后置通知(总会执行的)--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:after</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;userPointCut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;debugAfter&quot;</span>/&gt;</span><br>        <span class="hljs-comment">&lt;!--环绕通知--&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:around</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;userPointCut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;debugAround&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugAspect</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugBefore</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;before 执行&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugAfterReturning</span><span class="hljs-params">(Object revalue)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;AfterReturning,返回值：&quot;</span> + revalue);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugAfterThrowing</span><span class="hljs-params">(Exception ex)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;afterThrowing,返回异常：&quot;</span> + ex);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugAfter</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;After 执行&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugAround</span><span class="hljs-params">(ProceedingJoinPoint pjp)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Around before&quot;</span>);<br>        pjp.proceed();<br>        System.out.println(<span class="hljs-string">&quot;Around after&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>通知参数</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">aop:config</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">aop:aspect</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;myAspect&quot;</span> <span class="hljs-attr">ref</span>=<span class="hljs-string">&quot;debugAspect&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:pointcut</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userPointCut&quot;</span></span><br><span class="hljs-tag">                      <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;execution(* com.zth.debugSpring.service.UserService.getUser(Integer)) and args(userId)&quot;</span>/&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">aop:before</span> <span class="hljs-attr">pointcut-ref</span>=<span class="hljs-string">&quot;userPointCut&quot;</span> <span class="hljs-attr">method</span>=<span class="hljs-string">&quot;debugArgs&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">aop:aspect</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">aop:config</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">debugArgs</span><span class="hljs-params">(Integer userId)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;debugArgs userId:&quot;</span>+userId);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-4-引入"><a href="#3-4-引入" class="headerlink" title="3.4 引入"></a>3.4 引入</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;aop:aspect id=<span class="hljs-string">&quot;usageTrackerAspect&quot;</span> ref=<span class="hljs-string">&quot;usageTracking&quot;</span>&gt;<br><br>    &lt;aop:declare-parents<br>        types-matching=<span class="hljs-string">&quot;com.xzy.myapp.service.*+&quot;</span><br>        implement-<span class="hljs-class"><span class="hljs-keyword">interface</span></span>=<span class="hljs-string">&quot;com.xyz.myapp.service.tracking.UsageTracked&quot;</span><br>        <span class="hljs-keyword">default</span>-impl=<span class="hljs-string">&quot;com.xyz.myapp.service.tracking.DefaultUsageTracked&quot;</span>/&gt;<br><br>    &lt;aop:before<br>        pointcut=<span class="hljs-string">&quot;com.xyz.myapp.SystemArchitecture.businessService()</span><br><span class="hljs-string">            and this(usageTracked)&quot;</span><br>            method=<span class="hljs-string">&quot;recordUsage&quot;</span>/&gt;<br><br>&lt;/aop:aspect&gt;<br></code></pre></td></tr></table></figure><p>然后，支持usageTrackingbean的类将包含以下方法:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">recordUsage</span><span class="hljs-params">(UsageTracked usageTracked)</span> </span>&#123;<br>    usageTracked.incrementUseCount();<br>&#125;<br><br><br>UsageTracked usageTracked = (UsageTracked) context.getBean(<span class="hljs-string">&quot;myService&quot;</span>);<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——整合Mybatis源码解析</title>
    <link href="/2022/07/30/Spring%E2%80%94%E2%80%94%E6%95%B4%E5%90%88Mybatis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/07/30/Spring%E2%80%94%E2%80%94%E6%95%B4%E5%90%88Mybatis%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.processon.com/view/link/62e7f4367d9c08072e703b21">https://www.processon.com/view/link/62e7f4367d9c08072e703b21</a></p><h3 id="1-整合核心思路"><a href="#1-整合核心思路" class="headerlink" title="1. 整合核心思路"></a>1. 整合核心思路</h3><p>第三方框架和 Spring 进行整合的核心思想就是把第三方框架所产生的对象放到 Spring 容器中，让其成为 Bean。</p><p>比如 Mybatis，Mybatis 框架可以单独使用，而单独使用 Mybatis 框架就需要用到 Mybatis 所提供的一些类构造出对应的对象，然后使用该对象，就能使用到 Mybatis 框架给我们提供的功能。Spring 整合 Mybatis 就是为了将这些对象放入Spring 容器中成为 Bean，只要成为了 Bean，在 Spring 中就能很方便的使用这些对象了，也就能很方便的使用 Mybatis 框架所提供的功能了。</p><h3 id="2-Mybatis-Spring-1-3-2-版本底层源码执行流程"><a href="#2-Mybatis-Spring-1-3-2-版本底层源码执行流程" class="headerlink" title="2. Mybatis-Spring 1.3.2 版本底层源码执行流程"></a>2. Mybatis-Spring 1.3.2 版本底层源码执行流程</h3><ol><li>通过 @MapperScan 导入了 MapperScannerRegistrar 类</li><li>MapperScannerRegistrar 类实现了 ImportBeanDefinitionRegistrar 接口，所以 Spring 在启动时会调用 MapperScannerRegistrar 类中的 registerBeanDefinitions 方法</li><li>在registerBeanDefinitions 方法中定义了一个 ClassPathMapperScanner 对象，用来扫描 mapper</li><li>设置 ClassPathMapperScanner 对象可以扫描到接口，因为在 Spring 中是不会扫描接口的</li><li>同时因为 ClassPathMapperScanner 中重写了 isCandidateComponent 方法，导致 isCandidateComponent 只会认为接口是备选者 Component</li><li>通过利用 Spring 的扫描后，会把接口扫描出来并且得到对应的 BeanDefinition</li><li>接下来把扫描得到的 BeanDefinition 进行修改，把 BeanClass 修改为 MapperFactoryBean，把 AutowireMode 修改为 byType</li><li>扫描完成后，Spring 就会基于 BeanDefinition 去创建 Bean 了，相当于每个 Mapper 对应一个 FactoryBean</li><li>在 MapperFactoryBean 中的 getObject 方法中，调用了 getSqlSession() 去得到一个 sqlSession 对象，然后根据对应的 Mapper 接口生成一个 Mapper 接口代理对象，这个代理对象就成为 Spring 容器中的 Bean<br><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220731211441.png"></li><li>sqlSession 对象是 Mybatis 中的，一个 sqlSession 对象需要 SqlSessionFactory 来产生</li><li>MapperFactoryBean 的 AutowireMode 为 byType，所以 Spring 会自动调用 set 方法，有两个 set 方法，一个 setSqlSessionFactory，一个 setSqlSessionTemplate，而这两个方法执行的前提是根据方法参数类型能找到对应的 bean，所以 Spring 容器中要存在 SqlSessionFactory 类型的 bean 或者 SqlSessionTemplate 类型的 bean。</li><li>如果你定义的是一个 SqlSessionFactory 类型的 bean，那么最终也会被包装为一个 SqlSessionTemplate 对象，并且赋值给 sqlSession 属性（SqlSessionTemplate 中包含 SqlSession 的代理对象）<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">SqlSessionTemplate</span><span class="hljs-params">(SqlSessionFactory sqlSessionFactory, ExecutorType executorType,</span></span><br><span class="hljs-params"><span class="hljs-function">    PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;<br><br>  notNull(sqlSessionFactory, <span class="hljs-string">&quot;Property &#x27;sqlSessionFactory&#x27; is required&quot;</span>);<br>  notNull(executorType, <span class="hljs-string">&quot;Property &#x27;executorType&#x27; is required&quot;</span>);<br><br>  <span class="hljs-keyword">this</span>.sqlSessionFactory = sqlSessionFactory;<br>  <span class="hljs-keyword">this</span>.executorType = executorType;<br>  <span class="hljs-keyword">this</span>.exceptionTranslator = exceptionTranslator;<br>  <span class="hljs-keyword">this</span>.sqlSessionProxy = (SqlSession) newProxyInstance(<br>      SqlSessionFactory.class.getClassLoader(),<br>      <span class="hljs-keyword">new</span> Class[] &#123; SqlSession.class &#125;,<br>      <span class="hljs-keyword">new</span> SqlSessionInterceptor());<br>&#125;<br></code></pre></td></tr></table></figure></li><li>而在 SqlSessionTemplate 类中就存在一个 getMapper 方法，这个方法中就产生一个 Mapper 接口代理对象</li><li>当执行该代理对象的某个方法时，就会进入到 Mybatis 框架的底层执行流程。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// org.mybatis.spring.SqlSessionTemplate#getMapper</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> getConfiguration().getMapper(type, <span class="hljs-keyword">this</span>);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Configuration <span class="hljs-title">getConfiguration</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sqlSessionFactory.getConfiguration();<br>&#125;<br><br><span class="hljs-comment">// org.apache.ibatis.session.Configuration#getMapper</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.mapperRegistry.getMapper(type, sqlSession);<br>&#125;<br><br><span class="hljs-comment">// org.apache.ibatis.binding.MapperRegistry#getMapper</span><br><span class="hljs-keyword">public</span> &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getMapper</span><span class="hljs-params">(Class&lt;T&gt; type, SqlSession sqlSession)</span> </span>&#123;<br>    MapperProxyFactory&lt;T&gt; mapperProxyFactory = (MapperProxyFactory) <span class="hljs-keyword">this</span>.knownMappers.get(type);<br>    <span class="hljs-keyword">if</span> (mapperProxyFactory == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">&quot;Type &quot;</span> + type + <span class="hljs-string">&quot; is not known to the MapperRegistry.&quot;</span>);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">try</span> &#123;<br>            <span class="hljs-keyword">return</span> mapperProxyFactory.newInstance(sqlSession);<br>        &#125; <span class="hljs-keyword">catch</span> (Exception var5) &#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BindingException(<span class="hljs-string">&quot;Error getting mapper instance. Cause: &quot;</span> + var5, var5);<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">// org.apache.ibatis.binding.MapperProxyFactory#newInstance(org.apache.ibatis.binding.MapperProxy&lt;T&gt;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">newInstance</span><span class="hljs-params">(SqlSession sqlSession)</span> </span>&#123;<br>    MapperProxy&lt;T&gt; mapperProxy = <span class="hljs-keyword">new</span> MapperProxy(sqlSession, <span class="hljs-keyword">this</span>.mapperInterface, <span class="hljs-keyword">this</span>.methodCache);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.newInstance(mapperProxy);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> T <span class="hljs-title">newInstance</span><span class="hljs-params">(MapperProxy&lt;T&gt; mapperProxy)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> Proxy.newProxyInstance(<span class="hljs-keyword">this</span>.mapperInterface.getClassLoader(), <span class="hljs-keyword">new</span> Class[]&#123;<span class="hljs-keyword">this</span>.mapperInterface&#125;, mapperProxy);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="SqlSessionTemplate"><a href="#SqlSessionTemplate" class="headerlink" title="SqlSessionTemplate"></a>SqlSessionTemplate</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220731221526.png"></p><p>SqlSessionTemplate 含有一个 SqlSessionFactory 工厂类，一个执行器类型（SqlSession 底层使用的 ExecutorType 类型），一个 SqlSessionProxy JDK 生成的代理对象， 还有一个异常转换器。</p><p>SqlSessionTemplate 实现了 SqlSession 的所有方法，但内部全部委托了JDK 代理的 SqlSessionProxy 来实现。 </p><p>SqlSessionTemplate 有一个拦截器内部类，该类就是创建 JDK 动态代理时的那个拦截类， 我们看看该类的 invoke 方法实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">private</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SqlSessionInterceptor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InvocationHandler</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">invoke</span><span class="hljs-params">(Object proxy, Method method, Object[] args)</span> <span class="hljs-keyword">throws</span> Throwable </span>&#123;<br>    <span class="hljs-comment">// 拿到 DefaultSqlSession</span><br>        SqlSession sqlSession = getSqlSession(<br>                SqlSessionTemplate.<span class="hljs-keyword">this</span>.sqlSessionFactory,<br>                SqlSessionTemplate.<span class="hljs-keyword">this</span>.executorType,<br>                SqlSessionTemplate.<span class="hljs-keyword">this</span>.exceptionTranslator);<br>        <span class="hljs-keyword">try</span> &#123;<br>    <span class="hljs-comment">// 真正执行 sql</span><br>            Object result = method.invoke(sqlSession, args);<br>            <span class="hljs-keyword">if</span> (!isSqlSessionTransactional(sqlSession, SqlSessionTemplate.<span class="hljs-keyword">this</span>.sqlSessionFactory)) &#123;<br>                <span class="hljs-comment">// force commit even on non-dirty sessions because some databases require</span><br>                <span class="hljs-comment">// a commit/rollback before calling close()</span><br>                sqlSession.commit(<span class="hljs-keyword">true</span>);<br>            &#125;<br>            <span class="hljs-keyword">return</span> result;<br>        &#125; <span class="hljs-keyword">catch</span> (Throwable t) &#123;<br>            Throwable unwrapped = unwrapThrowable(t);<br>            <span class="hljs-keyword">if</span> (SqlSessionTemplate.<span class="hljs-keyword">this</span>.exceptionTranslator != <span class="hljs-keyword">null</span> &amp;&amp; unwrapped <span class="hljs-keyword">instanceof</span> PersistenceException) &#123;<br>                <span class="hljs-comment">// release the connection to avoid a deadlock if the translator is no loaded. See issue #22</span><br>                closeSqlSession(sqlSession, SqlSessionTemplate.<span class="hljs-keyword">this</span>.sqlSessionFactory);<br>                sqlSession = <span class="hljs-keyword">null</span>;<br>                Throwable translated = SqlSessionTemplate.<span class="hljs-keyword">this</span>.exceptionTranslator.translateExceptionIfPossible((PersistenceException) unwrapped);<br>                <span class="hljs-keyword">if</span> (translated != <span class="hljs-keyword">null</span>) &#123;<br>                    unwrapped = translated;<br>                &#125;<br>            &#125;<br>            <span class="hljs-keyword">throw</span> unwrapped;<br>        &#125; <span class="hljs-keyword">finally</span> &#123;<br>            <span class="hljs-keyword">if</span> (sqlSession != <span class="hljs-keyword">null</span>) &#123;<br>                closeSqlSession(sqlSession, SqlSessionTemplate.<span class="hljs-keyword">this</span>.sqlSessionFactory);<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>首先调用 SqlSessionUtils 的静态方法 getSqlSession 获取 SqlSession 对象， 然后调用 SqlSession 的响应方法， 检测事务是否由 Spring 管理，并根据此结果决定是否提交事务。 最后，返回结果，并在 finally 块中清除 Session（将 Connection 赋值为 null）。</p><p>也就是说，在执行 SqlSession 的 SelectOne 之类的方法的时候，都会经过该类。每条 SQL 的事务也都是在这里进行处理（如果 Spring 没有管理的话）。</p><p>SqlSessionTemplate.selectOne() —&gt;SqlSession.selectOne() –&gt;DefaultSqlSession.selectOne()</p><p>SqlSessionTemplate 是线程安全的，而 DefaultSqlSession 不是。</p><p>SqlSessionTemplate 判断当前线程在 ThreadLocal 中有没有 DefaultSqlSession,如果有直接使用，如果没有则创建，从而保证线程安全。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> SqlSession <span class="hljs-title">getSqlSession</span><span class="hljs-params">(SqlSessionFactory sessionFactory, ExecutorType executorType, PersistenceExceptionTranslator exceptionTranslator)</span> </span>&#123;<br>    <br>    <span class="hljs-comment">// 先从缓存（ThreadLocal）中获取 sqlSession,</span><br>    SqlSessionHolder holder = (SqlSessionHolder) TransactionSynchronizationManager.getResource(sessionFactory);<br>    SqlSession session = sessionHolder(executorType, holder);<br>    <span class="hljs-keyword">if</span> (session != <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">return</span> session;<br>    &#125;<br>    <span class="hljs-comment">// 缓存中没有则重新生成</span><br>    session = sessionFactory.openSession(executorType);<br>    <span class="hljs-comment">// 加入缓存</span><br>    registerSessionHolder(sessionFactory, executorType, exceptionTranslator, session);<br>    <span class="hljs-keyword">return</span> session;<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerSessionHolder</span><span class="hljs-params">(SqlSessionFactory sessionFactory, ExecutorType executorType,</span></span><br><span class="hljs-params"><span class="hljs-function">                                          PersistenceExceptionTranslator exceptionTranslator, SqlSession session)</span> </span>&#123;<br>    SqlSessionHolder holder;<br>    <span class="hljs-comment">// 如果开启了事务加入缓存</span><br>    <span class="hljs-comment">// 如果没有开启事务则不加入，导致每次拿到的是新的 sqlSession,导致了 spring 整合 mybatis 以及缓存失效</span><br>    <span class="hljs-keyword">if</span> (TransactionSynchronizationManager.isSynchronizationActive()) &#123;<br>        Environment environment = sessionFactory.getConfiguration().getEnvironment();<br><br>        <span class="hljs-keyword">if</span> (environment.getTransactionFactory() <span class="hljs-keyword">instanceof</span> SpringManagedTransactionFactory) &#123;<br>            holder = <span class="hljs-keyword">new</span> SqlSessionHolder(session, executorType, exceptionTranslator);<br>            TransactionSynchronizationManager.bindResource(sessionFactory, holder);<br>            TransactionSynchronizationManager.registerSynchronization(<span class="hljs-keyword">new</span> SqlSessionUtils.SqlSessionSynchronization(holder, sessionFactory));<br>            holder.setSynchronizedWithTransaction(<span class="hljs-keyword">true</span>);<br>            holder.requested();<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-keyword">if</span> (TransactionSynchronizationManager.getResource(environment.getDataSource()) == <span class="hljs-keyword">null</span>) &#123;<br>              <br>            &#125; <span class="hljs-keyword">else</span> &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> TransientDataAccessResourceException(<br>                        <span class="hljs-string">&quot;SqlSessionFactory must be using a SpringManagedTransactionFactory in order to use Spring transaction synchronization&quot;</span>);<br>            &#125;<br>        &#125;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-keyword">if</span> (LOGGER.isDebugEnabled()) &#123;<br>            LOGGER.debug(<span class="hljs-string">&quot;SqlSession [&quot;</span> + session + <span class="hljs-string">&quot;] was not registered for synchronization because synchronization is not active&quot;</span>);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-Mybatis-Spring-2-0-6-版本底层源码执行流程"><a href="#3-Mybatis-Spring-2-0-6-版本底层源码执行流程" class="headerlink" title="3. Mybatis-Spring  2.0.6 版本底层源码执行流程"></a>3. Mybatis-Spring  2.0.6 版本底层源码执行流程</h3><ol><li>通过 @MapperScan 导入了 MapperScannerRegistrar 类</li><li>MapperScannerRegistrar 类实现了 ImportBeanDefinitionRegistrar 接口，所以 Spring 在启动时会调用 MapperScannerRegistrar 类中的 registerBeanDefinitions 方法</li><li><strong>在 registerBeanDefinitions 方法中注册一个 MapperScannerConfigurer 类型的 BeanDefinition</strong></li><li>而 MapperScannerConfigurer 实现了 BeanDefinitionRegistryPostProcessor 接口，所以 Spring 在启动过程中时会调用它的 postProcessBeanDefinitionRegistry() 方法</li><li>在 postProcessBeanDefinitionRegistry 方法中会生成一个 ClassPathMapperScanner 对象，然后进行扫描</li><li>后续逻辑和 1.3.2 版本一样。</li></ol><p>带来的好处是，可以不使用 @MapperScan 注解，而可以直接定义一个Bean，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> MapperScannerConfigurer <span class="hljs-title">mapperScannerConfigurer</span><span class="hljs-params">()</span></span>&#123;<br>    MapperScannerConfigurer configurer = <span class="hljs-keyword">new</span> MapperScannerConfigurer();<br>    configurer.setBasePackage(<span class="hljs-string">&quot;com.zth.debuggingSpring&quot;</span>);<br>    <span class="hljs-keyword">return</span> configurer;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-Spring-整合-Mybatis-后一级缓存失效问题"><a href="#4-Spring-整合-Mybatis-后一级缓存失效问题" class="headerlink" title="4. Spring 整合 Mybatis 后一级缓存失效问题"></a>4. Spring 整合 Mybatis 后一级缓存失效问题</h3><p>Mybatis 中的一级缓存是基于 SqlSession 来实现的，所以在执行同一个 sql 时，如果使用的是同一个 SqlSession 对象，那么就能利用到一级缓存，提高 sql 的执行效率。</p><p>但是在 Spring 整合 Mybatis 后，在执行某个方法时，该方法上没有加 @Transactional 注解，也就是没有开启 Spring 事务，那么后面在执行具体 sql 时，每执行一个 sql 时都会新生成一个 SqlSession 对象来执行该 sql，这就是我们说的一级缓存失效（也就是没有使用同一个 SqlSession 对象），而如果开启了 Spring 事务，那么该 Spring 事务中的多个 sql，在执行时会使用同一个 SqlSession 对象，从而一级缓存生效。</p><p>个人理解：实际上 Spring 整合 Mybatis 后一级缓存失效并<strong>不是问题</strong>，是正常的实现，因为，一个方法如果没有开启 Spring 事务，那么在执行 sql 时候，那就是每个 sql 单独一个事务来执行，也就是单独一个 SqlSession 对象来执行该 sql，如果开启了 Spring 事务，那就是多个 sql 属于同一个事务，那自然就应该用一个 SqlSession 来执行这多个 sql。所以，在没有开启 Spring 事务的时候，SqlSession 的一级缓存并不是<strong>失效</strong>了，而是存在的生命周期太短了（执行完一个 sql 后就被销毁了，下一个 sql 执行时又是一个新的 SqlSession 了）。</p><h3 id="5-Spring-整合-Mybatis-之后-SQL-执行流程："><a href="#5-Spring-整合-Mybatis-之后-SQL-执行流程：" class="headerlink" title="5. Spring 整合 Mybatis 之后 SQL 执行流程："></a>5. Spring 整合 Mybatis 之后 SQL 执行流程：</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220731204002.png"></p><p><a href="https://www.processon.com/view/link/6152cc385653bb6791db436c">https://www.processon.com/view/link/6152cc385653bb6791db436c</a></p><h3 id="6-事务相关"><a href="#6-事务相关" class="headerlink" title="6. 事务相关"></a>6. 事务相关</h3><p>开启事务，由事务管理器建立数据库连接。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// protected Transaction transaction;</span><br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">(Log statementLog)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>  Connection connection = transaction.getConnection();<br>  <span class="hljs-keyword">if</span> (statementLog.isDebugEnabled()) &#123;<br>    <span class="hljs-keyword">return</span> ConnectionLogger.newInstance(connection, statementLog, queryStack);<br>  &#125; <span class="hljs-keyword">else</span> &#123;<br>    <span class="hljs-keyword">return</span> connection;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SpringManagedTransaction</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Transaction</span> </span>&#123;<br>  <span class="hljs-meta">@Override</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> Connection <span class="hljs-title">getConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.connection == <span class="hljs-keyword">null</span>) &#123;<br>      openConnection();<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.connection;<br>  &#125;<br>  <br>  <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">openConnection</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>    <span class="hljs-keyword">this</span>.connection = DataSourceUtils.getConnection(<span class="hljs-keyword">this</span>.dataSource);<br>    <span class="hljs-keyword">this</span>.autoCommit = <span class="hljs-keyword">this</span>.connection.getAutoCommit();<br>    <span class="hljs-keyword">this</span>.isConnectionTransactional = DataSourceUtils.isConnectionTransactional(<span class="hljs-keyword">this</span>.connection, <span class="hljs-keyword">this</span>.dataSource);<br><br>    LOGGER.debug(() -&gt; <span class="hljs-string">&quot;JDBC Connection [&quot;</span> + <span class="hljs-keyword">this</span>.connection + <span class="hljs-string">&quot;] will&quot;</span><br>        + (<span class="hljs-keyword">this</span>.isConnectionTransactional ? <span class="hljs-string">&quot; &quot;</span> : <span class="hljs-string">&quot; not &quot;</span>) + <span class="hljs-string">&quot;be managed by Spring&quot;</span>);<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>【补充】<a href="https://www.jianshu.com/p/c2b2d6f90ba5">https://www.jianshu.com/p/c2b2d6f90ba5</a></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
      <category>Mybatis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——配置类解析源码解析</title>
    <link href="/2022/07/25/Spring%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E7%B1%BB%E8%A7%A3%E6%9E%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/07/25/Spring%E2%80%94%E2%80%94%E9%85%8D%E7%BD%AE%E7%B1%BB%E8%A7%A3%E6%9E%90%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.processon.com/view/link/62e0189b63768979df38f399">https://www.processon.com/view/link/62e0189b63768979df38f399</a></p><h3 id="1-解析配置类"><a href="#1-解析配置类" class="headerlink" title="1.解析配置类"></a>1.解析配置类</h3><p>【注】上图以 Spring 5.2 为例</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220725195647.png"></p><p><a href="https://www.processon.com/view/link/5f9512d5e401fd06fda0b2dd">https://www.processon.com/view/link/5f9512d5e401fd06fda0b2dd</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220725201039.png"><br><a href="https://www.processon.com/view/link/614c83cae0b34d7b342f6d14#map">https://www.processon.com/view/link/614c83cae0b34d7b342f6d14#map</a></p><ol><li>在启动 Spring 时，需要传入一个 AppConfig.class 给 ApplicationContext，ApplicationContext 会根据 AppConfig 类封装为一个BeanDefinition，这种BeanDefinition 称为配置类 BeanDefinition。</li><li>ConfigurationClassPostProcessor 中会把配置类 BeanDefinition 取出来</li><li>构造一个 ConfigurationClassParser 用来解析配置类 BeanDefinition，并且会生成一个配置类对象 ConfigurationClass</li><li>如果配置类上存在 @Component 注解，那么<strong>解析配置类中的内部类（递归，如果内部类也是配置类的话）</strong></li><li>如果配置类上存在 @PropertySource 注解，那么则解析该注解，并得到 PropertySource 对象，并添加到 environment 中去<br>   <a href="https://blog.csdn.net/qq_37312838/article/details/108237678">https://blog.csdn.net/qq_37312838/article/details/108237678</a></li><li>如果配置类上存在 @ComponentScan 注解，那么则解析该注解，进行扫描，扫描得到一系列的 BeanDefinition 对象，然后判断这些 BeanDefinition 是不是也是配置类 BeanDefinition（只要存在 @Component 注解就是配置类，所以基本上扫描出来的都是配置类），如果是则继续解析该配置类，<strong>（也有递归）</strong>，并且会生成对应的 ConfigurationClass</li><li>如果配置类上存在 @Import 注解，那么则判断 Import 的类的类型：<ol><li>如果是 ImportSelector，那么调用执行 selectImports 方法得到类名，然后在把这个类当做配置类进行解析 <strong>（也是递归）</strong></li><li>如果是 ImportBeanDefinitionRegistrar，那么则生成一个 ImportBeanDefinitionRegistrar 实例对象，并添加到配置类对象中（ConfigurationClass）的 <strong>importBeanDefinitionRegistrars</strong> 属性中。</li></ol></li><li>如果配置类上存在 @ImportResource 注解，那么则把导入进来的资源路径存在配置类对象中的 <strong>importedResources</strong> 属性中。</li><li>如果配置类中存在 @Bean 的方法，那么则把这些方法封装为 BeanMethod 对象，并添加到配置类对象中的 <strong>beanMethods</strong> 属性中。</li><li>如果配置类实现了某些接口，则看这些接口内是否定义了 @Bean 的默认方法</li><li>如果配置类有父类，则把父类当做配置类进行解析</li><li>AppConfig 这个配置类会对应一个 ConfigurationClass，同时在解析的过程中也会生成另外的一些 ConfigurationClass，接下来就利用 reader 来进一步解析 ConfigurationClass<ol><li>如果 ConfigurationClass 是通过 @Import 注解导入进来的，则把这个类生成一个 BeanDefinition，同时解析这个类上 @Scope,@Lazy 等注解信息，并注册 BeanDefinition</li><li>如果 ConfigurationClass 中存在一些 BeanMethod，也就是定义了一些 @Bean，那么则解析这些 @Bean，并生成对应的 BeanDefinition，并注册</li><li>如果 ConfigurationClass 中导入了一些资源文件，比如 xx.xml，那么则解析这些 xx.xml 文件，得到并注册 BeanDefinition</li><li>如果 ConfigurationClass 中导入了一些 ImportBeanDefinitionRegistrar，那么则执行对应的 registerBeanDefinitions 进行 BeanDefinition 的注册</li></ol></li></ol><p><strong>总结：</strong></p><ol><li>解析 AppConfig 类，生成对应的 ConfigurationClass</li><li>再扫描，扫描到的类都会生成对应的 BeanDefinition，并且同时这些类也是 ConfigurationClass</li><li>再解析 ConfigurationClass 的其他信息，比如 @ImportResource 注解的处理，@Import 注解的处理，@Bean 注解的处理</li></ol><h3 id="2-BeanDefinition-覆盖"><a href="#2-BeanDefinition-覆盖" class="headerlink" title="2. BeanDefinition 覆盖"></a>2. BeanDefinition 覆盖</h3><p>两个 @Compont  注解导入 BeanName 相同，则报错<br>两个 @Bean  注解导入 BeanName 相同，不会报错，但是只会生成一个 BeanDefinition（依赖注入时会选择参数多的）<br> @Compont 和 @Bean 两个 BeanName 相同时，@Bean 覆盖  @Compont </p><h3 id="3-Configuration-的-Full-和-Lite-模式"><a href="#3-Configuration-的-Full-和-Lite-模式" class="headerlink" title="3. @Configuration 的 Full 和 Lite 模式"></a>3. @Configuration 的 Full 和 Lite 模式</h3><p>Full 模式会生成代理对象而 Lite 模式不会</p><p><a href="https://blog.csdn.net/demon7552003/article/details/107988310">https://blog.csdn.net/demon7552003/article/details/107988310</a></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——启动过程源码解析</title>
    <link href="/2022/07/13/Spring%E2%80%94%E2%80%94%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/07/13/Spring%E2%80%94%E2%80%94%E5%90%AF%E5%8A%A8%E8%BF%87%E7%A8%8B%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.processon.com/view/link/62e0189b63768979df38f399">https://www.processon.com/view/link/62e0189b63768979df38f399</a></p><h3 id="1-概述"><a href="#1-概述" class="headerlink" title="1.概述"></a>1.概述</h3><p>通常，我们说的 Spring 启动，就是构造 ApplicationContext 对象以及调用 refresh() 方法的过程。</p><p>首先，Spring 启动过程主要做了这么几件事情：</p><ol><li>构造一个 BeanFactory 对象</li><li>解析配置类，得到 BeanDefinition，并注册到 BeanFactory 中<ul><li>解析 @ComponentScan，此时就会完成扫描</li><li>解析 @Import</li><li>解析 @Bean</li><li>…</li></ul></li><li>因为 ApplicationContext 还支持国际化，所以还需要初始化 MessageSource 对象</li><li>因为 ApplicationContext 还支持事件机制，所以还需要初始化 ApplicationEventMulticaster 对象</li><li>把用户定义的 ApplicationListener 对象添加到 ApplicationContext 中，等 Spring 启动完了就要发布事件了</li><li>创建<strong>非懒加载的单例</strong> Bean 对象，并存在 BeanFactory 的单例池中。</li><li>调用 Lifecycle Bean 的 start() 方法</li><li>发布 <strong>ContextRefreshedEvent</strong> 事件</li></ol><p>由于 Spring 启动过程中要创建非懒加载的单例 Bean 对象，那么就需要用到 BeanPostProcessor，所以 Spring 在启动过程中就需要做两件事：</p><ol><li>生成默认的 BeanPostProcessor 对象，并添加到 BeanFactory 中<ul><li> AutowiredAnnotationBeanPostProcessor：处理 @Autowired、@Value</li><li> CommonAnnotationBeanPostProcessor：处理 @Resource、@PostConstruct、@PreDestroy</li><li> ApplicationContextAwareProcessor：处理 ApplicationContextAware 等回调</li></ul></li><li>找到外部用户所定义的 BeanPostProcessor 对象（类型为 BeanPostProcessor 的 Bean 对象），并添加到 BeanFactory 中</li></ol><h3 id="2-BeanFactoryPostProcessor"><a href="#2-BeanFactoryPostProcessor" class="headerlink" title="2. BeanFactoryPostProcessor"></a>2. BeanFactoryPostProcessor</h3><p>BeanPostProcessor 表示 Bean 的后置处理器，是用来对 Bean 进行加工的，类似的，BeanFactoryPostProcessor 理解为 BeanFactory 的后置处理器，用来对 BeanFactory 进行加工的。</p><p>Spring 支持用户定义 BeanFactoryPostProcessor 的实现类 Bean，来对 BeanFactory 进行加工，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>BeanDefinition beanDefinition = beanFactory.getBeanDefinition(<span class="hljs-string">&quot;userService&quot;</span>);<br>beanDefinition.setAutowireCandidate(<span class="hljs-keyword">false</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>以上代码，就利用了 BeanFactoryPostProcessor 来拿到 BeanFactory，然后获取 BeanFactory 内的某个 BeanDefinition 对象并进行修改，注意这一步是发生在 Spring 启动时，创建单例 Bean 之前的，所以此时对 BeanDefinition 进行修改是会生效的。</p><p>注意：在 ApplicationContext 内部有一个核心的 DefaultListableBeanFactory，它实现了 ConfigurableListableBeanFactory 和BeanDefinitionRegistry 接口，所以 ApplicationContext 和 DefaultListableBeanFactory 是可以注册 BeanDefinition 的，但是 ConfigurableListableBeanFactory 是不能注册 BeanDefinition 的，只能获取 BeanDefinition，然后做修改。</p><p>所以 Spring 还提供了一个 BeanFactoryPostProcessor 的子接口：<strong>BeanDefinitionRegistryPostProcessor</strong></p><h3 id="3-BeanDefinitionRegistryPostProcessor"><a href="#3-BeanDefinitionRegistryPostProcessor" class="headerlink" title="3. BeanDefinitionRegistryPostProcessor"></a>3. BeanDefinitionRegistryPostProcessor</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>BeanDefinitionRegistryPostProcessor 继承了 BeanFactoryPostProcessor 接口，并新增了一个方法，注意方法的参数为 BeanDefinitionRegistry，所以如果一个类实现了 BeanDefinitionRegistryPostProcessor，那么在 postProcessBeanDefinitionRegistry() 方法中就可以注册 BeanDefinition 了。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugBeanDefinitionRegistryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanDefinitionRegistryPostProcessor</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanDefinitionRegistry</span><span class="hljs-params">(BeanDefinitionRegistry registry)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();<br>beanDefinition.setBeanClass(User.class);<br>registry.registerBeanDefinition(<span class="hljs-string">&quot;user&quot;</span>, beanDefinition);<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>BeanDefinition beanDefinition = beanFactory.getBeanDefinition(<span class="hljs-string">&quot;userService&quot;</span>);<br>beanDefinition.setAutowireCandidate(<span class="hljs-keyword">false</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-refresh-作用"><a href="#4-refresh-作用" class="headerlink" title="4. refresh() 作用"></a>4. refresh() 作用</h3><p>org.springframework.context.ConfigurableApplicationContext#refresh</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Load or refresh the persistent representation of the configuration,</span><br><span class="hljs-comment"> * which might an XML file, properties file, or relational database schema.</span><br><span class="hljs-comment"> * &lt;p&gt;As this is a startup method, it should destroy already created singletons</span><br><span class="hljs-comment"> * if it fails, to avoid dangling resources. In other words, after invocation</span><br><span class="hljs-comment"> * of that method, either all or no singletons at all should be instantiated.</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> BeansException if the bean factory could not be initialized</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@throws</span> IllegalStateException if already initialized and multiple refresh</span><br><span class="hljs-comment"> * attempts are not supported</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">refresh</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException, IllegalStateException</span>;<br></code></pre></td></tr></table></figure><p>翻译：加载或刷新持久化的配置，可能是XML文件、属性文件或关系数据库中存储的。由于这是一个启动方法，如果失败，它应该销毁已经创建的单例，以避免暂用资源。换句话说，在调用该方法之后，应该实例化所有的单例，或者根本不实例化单例 。</p><p><strong>ApplicationContext 关闭之后不代表 JVM 也关闭了，ApplicationContext 是属于 JVM 的，说白了 ApplicationContext 也是 JVM 中的一个对象。</strong></p><p>在 Spring 的设计中，也提供可以重复刷新的 ApplicationContext 和不可以重复刷新的  ApplicationContext。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">AbstractRefreshableApplicationContext extends AbstractApplicationContext</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-keyword">if</span> (hasBeanFactory()) &#123;<br>destroyBeans();<br>closeBeanFactory();<br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br>DefaultListableBeanFactory beanFactory = createBeanFactory();<br>beanFactory.setSerializationId(getId());<br>customizeBeanFactory(beanFactory);<br>loadBeanDefinitions(beanFactory);<br><span class="hljs-keyword">this</span>.beanFactory = beanFactory;<br>&#125;<br><span class="hljs-keyword">catch</span> (IOException ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> ApplicationContextException(<span class="hljs-string">&quot;I/O error parsing bean definition source for &quot;</span> + getDisplayName(), ex);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>就是可以重复刷新的</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">GenericApplicationContext extends AbstractApplicationContext</span><br><span class="hljs-function"></span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">void</span> <span class="hljs-title">refreshBeanFactory</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> IllegalStateException </span>&#123;<br><span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.refreshed.compareAndSet(<span class="hljs-keyword">false</span>, <span class="hljs-keyword">true</span>)) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> IllegalStateException(<br><span class="hljs-string">&quot;GenericApplicationContext does not support multiple refresh attempts: just call &#x27;refresh&#x27; once&quot;</span>);<br>&#125;<br><span class="hljs-keyword">this</span>.beanFactory.setSerializationId(getId());<br>&#125;<br></code></pre></td></tr></table></figure><p>就是不可以重复刷新的。</p><p>AnnotationConfigApplicationContext 继承的是 GenericApplicationContext，所以它是不能刷新的。<br>AnnotationConfigWebApplicationContext 继承的是 AbstractRefreshableWebApplicationContext，所以它是可以刷的。</p><p><strong>不能重复刷新是指只能调用一次 refresh 方法，第二次时会报错。</strong></p><h3 id="5-refresh-底层原理流程"><a href="#5-refresh-底层原理流程" class="headerlink" title="5. refresh() 底层原理流程"></a>5. refresh() 底层原理流程</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220713220403.png"></p><p>底层原理流程图：<a href="https://www.processon.com/view/link/5f60a7d71e08531edf26a919">https://www.processon.com/view/link/5f60a7d71e08531edf26a919</a></p><p>下面以 AnnotationConfigApplicationContext 为例子，来介绍 refresh 的底层原理。</p><ol><li>在调用 AnnotationConfigApplicationContext 的构造方法之前，会调用父类 GenericApplicationContext 的无参构造方法，会构造一个BeanFactory，为 <strong>DefaultListableBeanFactory</strong>。</li><li>构造 AnnotatedBeanDefinitionReader（<strong>主要作用添加一些基础的 PostProcessor，同时可以通过 reader 进行BeanDefinition 的注册</strong>），同时对 BeanFactory 进行设置和添加 <strong>PostProcessor</strong>（后置处理器）<ol><li>设置 dependencyComparator：AnnotationAwareOrderComparator，它是一个 Comparator，是用来进行排序的，会获取某个对象上的 <strong>Order 注解</strong>或者通过实现 <strong>Ordered 接口</strong> 所定义的值进行排序，在日常开发中可以利用这个类来进行排序。</li><li>设置 autowireCandidateResolver：ContextAnnotationAutowireCandidateResolver，用来解析某个 Bean 能不能进行自动注入，比如某个 Bean 的 autowireCandidate 属性是否等于 true</li><li>向 BeanFactory 中添加 <strong>ConfigurationClassPostProcessor</strong> 对应的 BeanDefinition，它是一个 BeanDefinitionRegistryPostProcessor，并且实现了 PriorityOrdered 接口</li><li>向 BeanFactory 中添加 <strong>AutowiredAnnotationBeanPostProcessor</strong> 对应的 BeanDefinition，它是一个 InstantiationAwareBeanPostProcessorAdapter，MergedBeanDefinitionPostProcessor</li><li>向 BeanFactory 中添加 CommonAnnotationBeanPostProcessor 对应的 BeanDefinition，它是一个 InstantiationAwareBeanPostProcessor，InitDestroyAnnotationBeanPostProcessor</li><li>向 BeanFactory 中添加 EventListenerMethodProcessor 对应的 BeanDefinition，它是一个 BeanFactoryPostProcessor，SmartInitializingSingleton</li><li>向 BeanFactory 中添加 DefaultEventListenerFactory 对应的 BeanDefinition，它是一个 EventListenerFactory</li></ol></li><li>构造 ClassPathBeanDefinitionScanner（<strong>主要作用可以用来扫描得到并注册 BeanDefinition</strong>），同时进行设置：<ol><li>设置 <strong>this.includeFilters = AnnotationTypeFilter(Component.class)</strong></li><li>设置 environment</li><li>设置 resourceLoader</li></ol></li><li>利用 reader 注册 AppConfig 为 BeanDefinition，类型为 AnnotatedGenericBeanDefinition</li><li><strong>接下来就是调用 refresh 方法</strong></li><li>prepareRefresh()：<ol><li>记录启动时间</li><li>可以允许子容器设置一些内容到 Environment 中</li><li>验证 Environment 中是否包括了必须要有的属性</li></ol></li><li>obtainFreshBeanFactory()：进行 BeanFactory 的 refresh，在这里会去调用子类的 refreshBeanFactory 方法，具体子类是怎么刷新的得看子类，然后再调用子类的 getBeanFactory 方法，重新得到一个 BeanFactory</li><li>prepareBeanFactory(beanFactory)：<ol><li>设置 beanFactory 的类加载器</li><li>设置表达式解析器：StandardBeanExpressionResolver，用来解析 Spring 中的表达式</li><li>添加 PropertyEditorRegistrar：ResourceEditorRegistrar，PropertyEditorRegistrar 类型转化器注册器，用来注册一些默认的 PropertyEditor</li><li>添加一个 Bean 的后置处理器：ApplicationContextAwareProcessor，是一个 BeanPostProcessor，用来执行 EnvironmentAware、ApplicationEventPublisherAware 等回调方法</li><li>添加 <strong>ignoredDependencyInterface</strong>：可以向这个属性中添加一些接口，如果某个类实现了这个接口，并且这个类中的某些 set 方法在接口中也存在，那么这个 set 方法在自动注入的时候是不会执行的，比如 EnvironmentAware 这个接口，如果某个类实现了这个接口，那么就必须实现它的 setEnvironment 方法，而这是一个 set 方法，和 Spring 中的 autowire 是冲突的，那么 Spring 在自动注入时是不会调用 setEnvironment 方法的，而是等到回调 Aware 接口时再来调用（注意，这个功能仅限于 spring 自带的 autowire，@Autowired 注解是忽略这个属性的）<ol><li>EnvironmentAware</li><li>EmbeddedValueResolverAware</li><li>ResourceLoaderAware</li><li>ApplicationEventPublisherAware</li><li>MessageSourceAware</li><li>ApplicationContextAware</li><li>另外其实在构造 BeanFactory 的时候就已经提前添加了另外三个：</li><li>BeanNameAware</li><li>BeanClassLoaderAware</li><li>BeanFactoryAware</li></ol></li><li>添加 <strong>resolvableDependencies</strong>：在 byType 进行依赖注入时，会先从这个属性中根据类型找 bean<ol><li>BeanFactory.class：当前 BeanFactory 对象</li><li>ResourceLoader.class：当前 ApplicationContext 对象</li><li>ApplicationEventPublisher.class：当前 ApplicationContext 对象</li><li>ApplicationContext.class：当前 ApplicationContext 对象</li></ol></li><li>添加一个 Bean 的后置处理器：ApplicationListenerDetector，是一个 BeanPostProcessor，用来判断某个 Bean 是不是 ApplicationListener，如果是则把这个 Bean 添加到 ApplicationContext 中去，注意一个 ApplicationListener 只能是单例的</li><li>添加一个 Bean 的后置处理器：LoadTimeWeaverAwareProcessor，是一个 BeanPostProcessor，用来判断某个 Bean 是不是实现了 LoadTimeWeaverAware 接口，如果实现了则把 ApplicationContext 中的 loadTimeWeaver 回调 setLoadTimeWeaver 方法设置给该 Bean。</li><li>添加一些单例 bean 到单例池：<ol><li>“environment”：Environment 对象</li><li>“systemProperties”：System.getProperties() 返回的 Map 对象</li><li>“systemEnvironment”：System.getenv() 返回的 Map 对象</li></ol></li></ol></li><li>postProcessBeanFactory(beanFactory) ： 提供给 AbstractApplicationContext 的子类进行扩展，具体的子类，可以继续向 BeanFactory 中再添加一些东西</li><li>invokeBeanFactoryPostProcessors(beanFactory)：<strong>执行 BeanFactoryPostProcessor</strong><ol><li>此时在 BeanFactory 中会存在一个 BeanFactoryPostProcessor：<strong>ConfigurationClassPostProcessor</strong>，它也是一个 <strong>BeanDefinitionRegistryPostProcessor</strong></li><li><strong>第一阶段</strong></li><li>从 BeanFactory 中找到类型为 BeanDefinitionRegistryPostProcessor 的 beanName，也就是 <strong>ConfigurationClassPostProcessor</strong>， 然后调用 BeanFactory 的 getBean 方法得到实例对象</li><li>执行 <strong>ConfigurationClassPostProcessor 的 postProcessBeanDefinitionRegistry()</strong> 方法:<ol><li>解析 AppConfig 类</li><li>扫描得到 BeanDefinition 并注册</li><li>解析 @Import，@Bean 等注解得到 BeanDefinition 并注册</li><li>这些 BeanDefinition 中可能存在 BeanFactoryPostProcessor 和 BeanDefinitionRegistryPostProcessor，所以执行完ConfigurationClassPostProcessor 的 postProcessBeanDefinitionRegistry() 方法后，还需要继续执行其他 BeanDefinitionRegistryPostProcessor 的 postProcessBeanDefinitionRegistry() 方法</li></ol></li><li>执行其他 BeanDefinitionRegistryPostProcessor 的  <strong>postProcessBeanDefinitionRegistry()</strong> 方法</li><li>执行所有 BeanDefinitionRegistryPostProcessor 的 <strong>postProcessBeanFactory()</strong> 方法</li><li><strong>第二阶段</strong></li><li>从 BeanFactory 中找到类型为 BeanFactoryPostProcessor 的 beanName，而这些 BeanFactoryPostProcessor 包括了上面的 BeanDefinitionRegistryPostProcessor</li><li>执行还没有执行过的 BeanFactoryPostProcessor 的 <strong>postProcessBeanFactory()</strong> 方法</li></ol></li><li>到此，所有的 BeanFactoryPostProcessor 的逻辑都执行完了，主要做的事情就是得到 BeanDefinition 并注册到 BeanFactory 中</li><li>registerBeanPostProcessors(beanFactory)：因为上面的步骤完成了扫描，这个过程中程序员可能自己定义了一些 BeanPostProcessor，在这一步就会把 BeanFactory 中所有的 BeanPostProcessor 找出来并实例化得到一个对象，并添加到 BeanFactory 中去（属性 <strong>beanPostProcessors</strong>），最后再重新添加一个 ApplicationListenerDetector 对象（之前其实就添加了过，这里是为了把 ApplicationListenerDetector 移动到最后）</li><li>initMessageSource()： 设置 ApplicationContext 的 MessageSource,要么是用户设置的，要么是 DelegatingMessageSource，让 ApplicationContext 拥有<strong>国际化</strong>的功能</li><li>initApplicationEventMulticaster()：设置 ApplicationContext 的 applicationEventMulticaster，要么是用户设置的，要么是 SimpleApplicationEventMulticaster，让 ApplicationContext 拥有<strong>事件发布</strong>的功能</li><li>onRefresh()：提供给 AbstractApplicationContex t的子类进行扩展</li><li>registerListeners()：从 BeanFactory 中获取 ApplicationListener 类型的 beanName，然后添加到 ApplicationContext 中的事件广播器 <strong>applicationEventMulticaster</strong> 中去，到这一步因为 FactoryBean 还没有调用 getObject() 方法生成 Bean 对象，所以这里要再根据类型找一下 ApplicationListener，记录一下对应的 beanName</li><li>finishBeanFactoryInitialization(beanFactory)：完成 BeanFactory 的初始化，主要就是<strong>实例化非懒加载的单例 Bean</strong></li><li>finishRefresh()：BeanFactory 的初始化完后，就到了 Spring 启动的最后一步了</li><li>设置 ApplicationContext 的 lifecycleProcessor，默认情况下设置的是 DefaultLifecycleProcessor</li><li>调用 lifecycleProcessor 的 onRefresh() 方法，如果是 DefaultLifecycleProcessor，那么会获取所有类型为 Lifecycle 的 Bean 对象，然后调用它的 start() 方法，这就是 ApplicationContext 的生命周期扩展机制</li><li>发布 <strong>ContextRefreshedEvent</strong> 事件</li></ol><h3 id="6-执行BeanFactoryPostProcessor"><a href="#6-执行BeanFactoryPostProcessor" class="headerlink" title="6. 执行BeanFactoryPostProcessor"></a>6. 执行BeanFactoryPostProcessor</h3><ol><li>执行通过 ApplicationContext 添加进来的 BeanDefinitionRegistryPostProcessor 的 <font color="red">postProcessBeanDefinitionRegistry()</font> 方法</li><li>执行 BeanFactory 中实现了 PriorityOrdered 接口的 BeanDefinitionRegistryPostProcessor 的 <font color="red">postProcessBeanDefinitionRegistry()</font> 方法</li><li>执行 BeanFactory 中实现了 Ordered 接口的 BeanDefinitionRegistryPostProcessor 的 <font color="red">postProcessBeanDefinitionRegistry()</font> 方法</li><li>执行 BeanFactory 中其他的 BeanDefinitionRegistryPostProcessor 的 <font color="red">postProcessBeanDefinitionRegistry()</font> 方法</li><li>执行上面所有的 BeanDefinitionRegistryPostProcessor 的 <font color="green">postProcessBeanFactory()</font> 方法</li><li>执行通过 ApplicationContext 添加进来的 BeanFactoryPostProcessor 的 <font color="green">postProcessBeanFactory()</font> 方法</li><li>执行 BeanFactory 中实现了 PriorityOrdered 接口的 BeanFactoryPostProcessor 的 <font color="green">postProcessBeanFactory()</font> 方法</li><li>执行 BeanFactory 中实现了 Ordered 接口的 BeanFactoryPostProcessor 的 <font color="green">postProcessBeanFactory()</font> 方法</li><li>执行 BeanFactory 中其他的 BeanFactoryPostProcessor 的 <font color="green">postProcessBeanFactory()</font> 方法</li></ol><h3 id="7-Lifecycle的使用"><a href="#7-Lifecycle的使用" class="headerlink" title="7. Lifecycle的使用"></a>7. Lifecycle的使用</h3><p>Lifecycle 表示的是 ApplicationContext 的生命周期，可以定义一个 SmartLifecycle 来监听 ApplicationContext 的启动和关闭：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugLifecycle</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">SmartLifecycle</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isRunning = <span class="hljs-keyword">false</span>;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">start</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;启动&quot;</span>);<br>isRunning = <span class="hljs-keyword">true</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">stop</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 要触发stop()，要调用context.close()，或者注册关闭钩子（context.registerShutdownHook();）</span><br>System.out.println(<span class="hljs-string">&quot;停止&quot;</span>);<br>isRunning = <span class="hljs-keyword">false</span>;<br>&#125;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">isRunning</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> isRunning;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-事件相关类"><a href="#8-事件相关类" class="headerlink" title="8. 事件相关类"></a>8. 事件相关类</h3><h4 id="事件监听器"><a href="#事件监听器" class="headerlink" title="事件监听器"></a>事件监听器</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugApplicationListener</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ApplicationListener</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ApplicationEvent event)</span> </span>&#123;<br>        <span class="hljs-comment">// 事件发布 context.publishEvent(&quot;deBugWord&quot;);</span><br>        PayloadApplicationEvent applicationEvent = (PayloadApplicationEvent) event;<br>        System.out.println(applicationEvent.getPayload());<br>    &#125;<br>&#125;<br>````<br><br>普通 Bean 中：<br>```java<br>    <span class="hljs-meta">@EventListener</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">aa</span><span class="hljs-params">(ApplicationEvent applicationEvent)</span></span>&#123;<br>        System.out.println(applicationEvent);<br>    &#125;<br></code></pre></td></tr></table></figure><h4 id="ApplicationListenerDetector"><a href="#ApplicationListenerDetector" class="headerlink" title="ApplicationListenerDetector"></a>ApplicationListenerDetector</h4><p>ApplicationListenerDetector 是一个 BeanPostProcessor，用于检查一个 Bean 是不是 ApplicationListener。</p><h4 id="EventListenerMethodProcessor"><a href="#EventListenerMethodProcessor" class="headerlink" title="EventListenerMethodProcessor"></a>EventListenerMethodProcessor</h4><p>EventListenerMethodProcessor 是一个 SmartInitializingSingleton，利用 EventListenerFactory 将加了 @EventListener 注解的方法封装成 ApplicationListener 对象</p><h4 id="SimpleApplicationEventMulticaster"><a href="#SimpleApplicationEventMulticaster" class="headerlink" title="SimpleApplicationEventMulticaster"></a>SimpleApplicationEventMulticaster</h4><p>SimpleApplicationEventMulticaster 默认事件发布器</p><p>AbstractApplicationContext#publishEvent(java.lang.Object, org.springframework.core.ResolvableType)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">publishEvent</span><span class="hljs-params">(Object event, <span class="hljs-meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;<br>Assert.notNull(event, <span class="hljs-string">&quot;Event must not be null&quot;</span>);<br><br><span class="hljs-comment">// Decorate event as an ApplicationEvent if necessary</span><br>ApplicationEvent applicationEvent;<br><span class="hljs-keyword">if</span> (event <span class="hljs-keyword">instanceof</span> ApplicationEvent) &#123;<br>applicationEvent = (ApplicationEvent) event;<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>applicationEvent = <span class="hljs-keyword">new</span> PayloadApplicationEvent&lt;&gt;(<span class="hljs-keyword">this</span>, event);<br><span class="hljs-keyword">if</span> (eventType == <span class="hljs-keyword">null</span>) &#123;<br>eventType = ((PayloadApplicationEvent&lt;?&gt;) applicationEvent).getResolvableType();<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// Multicast right now if possible - or lazily once the multicaster is initialized</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.earlyApplicationEvents != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">this</span>.earlyApplicationEvents.add(applicationEvent);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>getApplicationEventMulticaster().multicastEvent(applicationEvent, eventType);<br>&#125;<br><br><span class="hljs-comment">// Publish event via parent context as well...</span><br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parent != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.parent <span class="hljs-keyword">instanceof</span> AbstractApplicationContext) &#123;<br>((AbstractApplicationContext) <span class="hljs-keyword">this</span>.parent).publishEvent(event, eventType);<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">this</span>.parent.publishEvent(event);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>SimpleApplicationEventMulticaster#multicastEvent(org.springframework.context.ApplicationEvent, org.springframework.core.ResolvableType)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">multicastEvent</span><span class="hljs-params">(<span class="hljs-keyword">final</span> ApplicationEvent event, <span class="hljs-meta">@Nullable</span> ResolvableType eventType)</span> </span>&#123;<br>ResolvableType type = (eventType != <span class="hljs-keyword">null</span> ? eventType : resolveDefaultEventType(event));<br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">final</span> ApplicationListener&lt;?&gt; listener : getApplicationListeners(event, type)) &#123;<br>Executor executor = getTaskExecutor();<br><span class="hljs-keyword">if</span> (executor != <span class="hljs-keyword">null</span>) &#123;<br>executor.execute(() -&gt; invokeListener(listener, event));<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br>invokeListener(listener, event);<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——推断构造方法源码解析</title>
    <link href="/2022/07/08/Spring%E2%80%94%E2%80%94%E6%8E%A8%E6%96%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/07/08/Spring%E2%80%94%E2%80%94%E6%8E%A8%E6%96%AD%E6%9E%84%E9%80%A0%E6%96%B9%E6%B3%95%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.processon.com/view/link/629e0d260791293c9388933b">https://www.processon.com/view/link/629e0d260791293c9388933b</a></p><h3 id="1-推断构造的场景"><a href="#1-推断构造的场景" class="headerlink" title="1. 推断构造的场景"></a>1. 推断构造的场景</h3><ol><li>默认情况下，使用无参构造方法或者唯一的构造方法</li><li>如果通过 getBean()  或者  beanDefinition.getConstructorArgumentValues().addIndexedArgumentValue(1,new UserService()) 指定了构造方法的入参值，则使用锁匹配的构造方法</li><li>设置 autowire=”constructor”  让 Spring 自动选择构造方法以及入参值</li><li>通过 @Autowired 指定构造方法，Spring 自动匹配值</li></ol><p>Spring 中的一个 bean，需要实例化得到一个对象，而实例化就需要用到构造方法。</p><p>一般情况下，一个类只有一个构造方法：</p><ol><li>要么是无参的构造方法</li><li>要么是有参的构造方法</li></ol><p>如果只有<strong>一个无参</strong>的构造方法，那么实例化就只能使用这个构造方法了。<br>如果只有<strong>一个有参</strong>的构造方法，那么实例化时能使用这个构造方法吗？要分情况讨论：</p><ol><li>使用 AnnotationConfigApplicationContext，会使用这个构造方法进行实例化，那么 Spring 会根据构造方法的参数信息去寻找 bean，然后传给构造方法</li><li>使用 ClassPathXmlApplicationContext，表示使用 XML 的方式来使用 bean，要么在 XML 中指定构造方法的参数值(手动指定)，要么配置 <strong>autowire=constructor</strong> 让 Spring <strong>自动</strong> 去寻找 bean 做为构造方法参数值。</li></ol><p>上面是只有一个构造方法的情况，那么如果有多个构造方法呢？</p><p>又分为两种情况，多个构造方法中存不存在无参的构造方法。</p><p>分析：一个类存在多个构造方法，那么 Spring 进行实例化之前，该如何去确定到底用哪个构造方法呢？</p><ol><li>如果开发者指定了想要使用的构造方法，那么就用这个构造方法</li><li>如果开发者没有指定想要使用的构造方法，则看开发者有没有让 Spring 自动去选择构造方法</li><li>如果开发者也没有让 Spring 自动去选择构造方法，则 Spring 利用无参构造方法，如果没有无参构造方法，则报错</li></ol><ul><li>指定构造方法<ul><li>xml 中的 &lt;constructor-arg&gt; 标签，这个标签表示构造方法参数，所以可以根据这个确定想要使用的构造方法的参数个数，从而确定想要使用的构造方法</li><li>通过 @Autowired 注解，@Autowired 注解可以写在构造方法上，表示开发者想使用哪个构造方法，当然，它和第一个方式的不同点是，通过 xml 的方式，我们直接指定了构造方法的参数值，而通过 @Autowired 注解的方式，需要 Spring 通过 byType+byName 的方式去找到符合条件的 bean 作为构造方法的参数值</li><li>多个构造方法上写了 @Autowired 注解，那么此时 Spring 会报错。但是因为 @Autowired 还有一个属性 required，默认为 ture，所以一个类中，只有能一个构造方法标注了 @Autowired 或 @Autowired（required=true），有多个会报错。但是可以有多个 @Autowired（required=false），这种情况下，需要 Spring 从这些构造方法中去自动选择一个构造方法。</li></ul></li><li>Spring 自动去选择构造方法<ul><li>对于这一点，只能用在 ClassPathXmlApplicationContext，因为通过 AnnotationConfigApplicationContext 没有办法去指定某个 bean 可以自动去选择构造方法，而通过 ClassPathXmlApplicationContext 可以在 xml 中指定某个 bean 的 autowire 为 constructor，虽然这个属性表示通过构造方法自动注入，所以需要自动的去选择一个构造方法进行自动注入，因为是构造方法，所以顺便是进行实例化。</li></ul></li></ul><h3 id="2-源码思路"><a href="#2-源码思路" class="headerlink" title="2. 源码思路"></a>2. 源码思路</h3><h4 id="2-1-推断构造方法"><a href="#2-1-推断构造方法" class="headerlink" title="2.1 推断构造方法"></a>2.1 推断构造方法</h4><ol><li>AbstractAutowireCapableBeanFactory 类中的 createBeanInstance() 方法会去创建一个 Bean 实例</li><li>根据 BeanDefinition 加载类得到 Class 对象</li><li>如果 BeanDefinition 绑定了一个 Supplier，那就调用 Supplier 的 get 方法得到一个对象并直接返回</li><li>如果 BeanDefinition 中存在 <strong>factoryMethodName</strong>，那么就<strong>调用该工厂方法</strong>得到一个 bean 对象并返回</li><li>如果 BeanDefinition 已经自动构造过了，那就调用 autowireConstructor() 自动构造一个对象</li><li>调用 SmartInstantiationAwareBeanPostProcessor 的 determineCandidateConstructors() 方法得到哪些构造方法是可以用的</li><li>如果存在可用的构造方法，或者当前 BeanDefinition 的 autowired 是 AUTOWIRE_CONSTRUCTOR，或者 BeanDefinition 中指定了构造方法参数值，或者创建 Bean 的时候指定了构造方法参数值，那么就调用 <strong>autowireConstructor()</strong> 方法自动构造一个对象</li><li>最后，如果不是上述情况，就根据无参的构造方法实例化一个对象</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220710181239.png"></p><h4 id="2-2-autowireConstructor"><a href="#2-2-autowireConstructor" class="headerlink" title="2.2  autowireConstructor()"></a>2.2  autowireConstructor()</h4><ul><li>先检查是否指定了具体的构造方法和构造方法参数值，或者在 BeanDefinition 中缓存了具体的构造方法或构造方法参数值，如果存在那么则直接使用该构造方法进行实例化</li><li>如果没有确定的构造方法或构造方法参数值，那么<ol><li>如果没有确定的构造方法，那么则找出类中所有的构造方法</li><li>如果只有一个无参的构造方法，那么直接使用无参的构造方法进行实例化</li><li>如果有多个可用的构造方法或者当前Bean需要自动通过构造方法注入</li><li>根据所指定的构造方法参数值，确定所需要的最少的构造方法参数值的个数</li><li>对所有的构造方法进行排序，参数个数多的在前面</li><li>遍历每个构造方法</li><li>如果不是调用getBean方法时所指定的构造方法参数值，那么则根据构造方法参数类型找值</li><li>如果时调用getBean方法时所指定的构造方法参数值，就直接利用这些值</li><li>如果根据当前构造方法找到了对应的构造方法参数值，那么这个构造方法就是可用的，但是不一定这个构造方法就是最佳的，所以这里会涉及到是否有多个构造方法匹配了同样的值，这个时候就会用值和构造方法类型进行匹配程度的打分，找到一个最匹配的</li></ol></li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220710192029.png"></p><h4 id="2-3-匹配值分数"><a href="#2-3-匹配值分数" class="headerlink" title="2.3 匹配值分数"></a>2.3 匹配值分数</h4><p>主要是计算找到的 bean 和构造方法参数类型匹配程度有多高。分数越小优先级越高</p><p>假设 bean 的类型为 A，A 的父类是 B，B 的父类是 C，同时 A 实现了接口 D</p><ul><li>如果构造方法的参数类型为 A，那么完全匹配，得分为 0</li><li>如果构造方法的参数类型为 B，那么得分为 2</li><li>如果构造方法的参数类型为 C，那么得分为 4</li><li>如果构造方法的参数类型为 D，那么得分为1</li></ul><p>可以直接使用如下代码进行测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java">Object[] objects = <span class="hljs-keyword">new</span> Object[]&#123;<span class="hljs-keyword">new</span> A()&#125;;<br><br><span class="hljs-comment">// 0</span><br>System.out.println(MethodInvoker.getTypeDifferenceWeight(<span class="hljs-keyword">new</span> Class[]&#123;A.class&#125;, objects));<br><br><span class="hljs-comment">// 2</span><br>System.out.println(MethodInvoker.getTypeDifferenceWeight(<span class="hljs-keyword">new</span> Class[]&#123;B.class&#125;, objects));<br><br><span class="hljs-comment">// 4</span><br>System.out.println(MethodInvoker.getTypeDifferenceWeight(<span class="hljs-keyword">new</span> Class[]&#123;C.class&#125;, objects));<br><br><span class="hljs-comment">// 1</span><br>System.out.println(MethodInvoker.getTypeDifferenceWeight(<span class="hljs-keyword">new</span> Class[]&#123;D.class&#125;, objects));<br></code></pre></td></tr></table></figure><p>所以，我们可以发现，越匹配分数越低。</p><h4 id="2-4-Bean的情况"><a href="#2-4-Bean的情况" class="headerlink" title="2.4 @Bean的情况"></a>2.4 @Bean的情况</h4><p>首先，Spring 会把 @Bean 修饰的方法解析成 BeanDefinition：</p><ul><li>如果方法是非 static 的，那么解析出来的 BeanDefinition 中：<ol><li>factoryBeanName 为 AppConfig 所对应的 beanName，比如 “appConfig”</li><li>factoryMethodName 为对应的方法名，比如 “aService”</li><li>factoryClass 为 AppConfig.class</li></ol></li></ul><ol start="2"><li>如果方法是 static 的，那么解析出来的 BeanDefinition 中：<ol><li>factoryBeanName 为 null</li><li>factoryMethodName 为对应的方法名，比如  “aService”</li><li>factoryClass 也为 AppConfig.class</li></ol></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;!--非静态方法--&gt;<br>&lt;bean id=<span class="hljs-string">&quot;userService&quot;</span> factory-bean=<span class="hljs-string">&quot;userServiceFactory&quot;</span> factory-method=<span class="hljs-string">&quot;create&quot;</span>/&gt;<br>&lt;!--静态方法--&gt;<br>&lt;bean id=<span class="hljs-string">&quot;userService&quot;</span>  <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.UserServiceFactory&quot;</span> factory-method=<span class="hljs-string">&quot;xxx&quot;</span>/&gt;<br><br></code></pre></td></tr></table></figure><p>在由 @Bean 生成的 BeanDefinition 中，有一个重要的属性 isFactoryMethodUnique，表示 factoryMethod 是不是唯一的，在普通情况下 @Bean 生成的 BeanDefinition 的 isFactoryMethodUnique 为 true，但是如果出现了方法重载，那么就是特殊的情况，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> AService <span class="hljs-title">aService</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AService();<br>&#125;<br><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> AService <span class="hljs-title">aService</span><span class="hljs-params">(BService bService)</span></span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> AService();<br>&#125;<br></code></pre></td></tr></table></figure><p>虽然有两个 @Bean，但是肯定只会生成一个 aService 的 Bean，那么 Spring 在处理 @Bean 时，也只会生成一个 aService 的 BeanDefinition，比如 Spring 先解析到第一个 @Bean，会生成一个 BeanDefinition，此时 isFactoryMethodUnique 为 true，但是解析到第二个 @Bean 时，会判断出来 beanDefinitionMap 中已经存在一个 aService 的 BeanDefinition 了，那么会把之前的这个 BeanDefinition 的 isFactoryMethodUnique 修改为 false，并且不会生成新的 BeanDefinition 了。</p><p>并且后续在根据 BeanDefinition 创建 Bean 时，会根据 isFactoryMethodUnique 来操作，如果为 true，那就表示当前 BeanDefinition 只对应了一个方法，那也就是只能用这个方法来创建 Bean 了，但是如果 isFactoryMethodUnique 为 false，那就表示当前 BeanDefition 对应了多个方法，需要和推断构造方法的逻辑一样，去选择用哪个方法来创建 Bean。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——循环依赖源码解析</title>
    <link href="/2022/07/02/Spring%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/07/02/Spring%E2%80%94%E2%80%94%E5%BE%AA%E7%8E%AF%E4%BE%9D%E8%B5%96%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.processon.com/view/link/629e0d260791293c9388933b">https://www.processon.com/view/link/629e0d260791293c9388933b</a></p><h2 id="1-什么是循环依赖？"><a href="#1-什么是循环依赖？" class="headerlink" title="1. 什么是循环依赖？"></a>1. 什么是循环依赖？</h2><p>就是A对象依赖了B对象，B对象依赖了A对象。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// A依赖了B</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span></span>&#123;<br><span class="hljs-keyword">public</span> B b;<br>&#125;<br><br><span class="hljs-comment">// B依赖了A</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span></span>&#123;<br><span class="hljs-keyword">public</span> A a;<br>&#125;<br></code></pre></td></tr></table></figure><p>那么循环依赖是个问题吗？</p><p>如果不考虑 Spring，循环依赖并不是问题，因为对象之间相互依赖是很正常的事情。</p><p>比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">A a = <span class="hljs-keyword">new</span> A();<br>B b = <span class="hljs-keyword">new</span> B();<br><br>a.b = b;<br>b.a = a;<br></code></pre></td></tr></table></figure><p>这样，A,B就依赖上了。</p><p>但是，在 Spring 中循环依赖就是一个问题了，为什么？<br>因为，在 Spring 中，一个对象并不是简单 new 出来了，而是会经过一系列的 Bean 的生命周期，就是因为 Bean 的生命周期所以才会出现循环依赖问题。当然，在 Spring 中，出现循环依赖的场景很多，有的场景 Spring 自动帮我们解决了，而有的场景则需要程序员来解决。</p><h2 id="2-Bean-的生命周期"><a href="#2-Bean-的生命周期" class="headerlink" title="2. Bean 的生命周期"></a>2. Bean 的生命周期</h2><p>Bean 的生命周期指的就是：在 Spring 中，Bean 是如何生成的？</p><p>被 Spring 管理的对象叫做 Bean。Bean 的生成步骤如下：</p><ol><li>Spring 扫描 class 得到 BeanDefinition</li><li>根据得到的 BeanDefinition 去生成 bean</li><li>首先根据  class 推断构造方法</li><li>根据推断出来的构造方法，反射，得到一个对象（暂时叫做原始对象）</li><li>填充原始对象中的属性（依赖注入）</li><li>如果原始对象中的某个方法被 AOP 了，那么则需要根据原始对象生成一个代理对象</li><li>把最终生成的代理对象放入单例池（singletonObjects）中，下次 getBean 时就直接从单例池拿即可</li></ol><p>可以看到，对于 Spring 中的 Bean 的生成过程，还有很多很多，比如Aware回调、初始化等等。</p><p>可以发现，在 Spring 中，构造一个 Bean，包括了 new 这个步骤（第4步构造方法反射）。得到一个原始对象后，Spring 需要给对象中的属性进行依赖注入，那么这个注入过程是怎样的？<br>　　A 类中存在一个 B 类的 b 属性，所以，当 A 类生成了一个原始对象之后，就会去给 b 属性去赋值，此时就会根据 b 属性的类型和属性名去 BeanFactory 中去获取 B 类所对应的单例 bean。如果此时 BeanFactory 中存在 B 对应的 Bean，那么直接拿来赋值给 b 属性；如果此时 BeanFactory 中不存在 B 对应的 Bean，则需要生成一个 B 对应的 Bean，然后赋值给 b 属性。<br>　　问题就出现在第二种情况，如果此时 B 类在 BeanFactory 中还没有生成对应的 Bean，那么就需要去生成，就会经过 B 的 Bean 的生命周期。<br>　　那么在创建 B 类的 Bean 的过程中，如果 B 类中存在一个 A 类的 a 属性，那么在创建 B 的 Bean 的过程中就需要 A 类对应的 Bean，但是，触发 B 类 Bean 的创建的条件是 A 类 Bean 在创建过程中的依赖注入，所以这里就出现了循环依赖。</p><p>ABean 创建–&gt;依赖了 B 属性–&gt;触发 BBean 创建—&gt;B 依赖了 A 属性—&gt;需要 ABean（但 ABean 还在创建过程中）</p><p>从而导致 ABean 创建不出来，BBean 也创建不出来。</p><p>在 Spring 中，通过<strong>三级缓存</strong>机制帮开发者解决了部分循环依赖的问题。</p><h2 id="3-三级缓存"><a href="#3-三级缓存" class="headerlink" title="3. 三级缓存"></a>3. 三级缓存</h2><p>三级缓存是通用的叫法。<br>一级缓存为：<strong>singletonObjects</strong><br>二级缓存为：<strong>earlySingletonObjects</strong><br>三级缓存为：<strong>singletonFactories</strong></p><ul><li><strong>singletonObjects</strong>：中缓存的是已经经历了完整生命周期的 bean 对象。</li><li><strong>earlySingletonObjects</strong>：缓存的是早期的 bean 对象。表示 Bean 的生命周期还没走完就把这个 Bean 放入了 earlySingletonObjects。</li><li><strong>singletonFactories</strong>：缓存的是 ObjectFactory，对象工厂，用来创建早期 bean 对象的工厂。</li></ul><h2 id="4-解决循环依赖思路分析"><a href="#4-解决循环依赖思路分析" class="headerlink" title="4. 解决循环依赖思路分析"></a>4. 解决循环依赖思路分析</h2><p>A 创建时—&gt;需要 B—-&gt;B 去创建—&gt;需要 A，从而产生了循环</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220702154710.png"></p><p>那么如何打破这个循环，加个缓存：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220702154827.png"></p><p>　　A 的 Bean 创建过程中，在进行依赖注入之前，先把 A 的原始 Bean 放入缓存（提早暴露，只要放到缓存了，其他 Bean 需要时就可以从缓存中拿了），放入缓存后，再进行依赖注入，此时 A 的 Bean 依赖了 B 的 Bean，如果 B 的 Bean 不存在，则需要创建 B 的 Bean，而创建 B 的 Bean 的过程和 A 一样，也是先创建一个 B 的原始对象，然后把 B 的原始对象提早暴露出来放入缓存中，然后在对 B 的原始对象进行依赖注入 A，此时能从缓存中拿到 A 的原始对象（虽然是 A 的原始对象，还不是最终的 Bean），B 的原始对象依赖注入完了之后，B 的生命周期结束，那么 A 的生命周期也能结束。</p><p>　　因为整个过程中，都只有一个 A 原始对象，所以对于 B 而言，就算在属性注入时，注入的是 A  原始对象，也没有关系，因为 A 原始对象在后续的生命周期中在堆中没有发生变化。 </p><p>　　从上面这个分析过程中可以得出，只需要一个缓存就能解决循环依赖了，那么为什么 Spring 中还需要 <strong>singletonFactories</strong> 呢？</p><p>　　这是难点，基于上面的场景想一个问题：如果 A 的原始对象注入给 B 的属性之后，A 的原始对象进行了 AOP 产生了一个代理对象，此时就会出现，对于 A 而言，它的 Bean 对象其实应该是 AOP 之后的代理对象，而 B 的  a 属性对应的并不是 AOP 之后的代理对象，这就产生了冲突。<strong>B依赖的A和最终的A不是同一个对象</strong>。</p><p>　　AOP 就是通过 BeanPostProcessor 来实现的，这个 BeanPostProcessor 就是 AnnotationAwareAspectJAutoProxyCreator，它的父类是 AbstractAutoProxyCreator，而在 Spring 中 AOP 利用的要么是 JDK 动态代理，要么 CGLib 的动态代理，所以如果给一个类中的某个方法设置了切面，那么这个类最终就需要生成一个代理对象。</p><p>　　一般过程就是：A类—&gt;生成一个普通对象–&gt;属性注入–&gt;基于切面生成一个代理对象–&gt;把代理对象放入 singletonObjects 单例池中。</p><p>　　而 AOP 可以说是 Spring 中除开 IOC 的另外一大功能，而循环依赖又是属于 IOC 范畴的，所以这两大功能想要并存，Spring 需要特殊处理。</p><p>　　如何处理的，就是利用了第三级缓存 <strong>singletonFactories</strong>。</p><p>　　首先，singletonFactories 中存的是某个 beanName 对应的 ObjectFactory，在 bean 的生命周期中，生成完原始对象之后，就会构造一个 ObjectFactory 存入 singletonFactories 中。这个ObjectFactory 是一个函数式接口，所以支持 Lambda 表达式：**() -&gt; getEarlyBeanReference(beanName, mbd, bean)**</p><p>　　上面的 Lambda 表达式就是一个 ObjectFactory，执行该 Lambda 表达式就会去执行 getEarlyBeanReference 方法，而该方法如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Object <span class="hljs-title">getEarlyBeanReference</span><span class="hljs-params">(String beanName, RootBeanDefinition mbd, Object bean)</span> </span>&#123;<br>Object exposedObject = bean;<br><span class="hljs-keyword">if</span> (!mbd.isSynthetic() &amp;&amp; hasInstantiationAwareBeanPostProcessors()) &#123;<br><span class="hljs-keyword">for</span> (BeanPostProcessor bp : getBeanPostProcessors()) &#123;<br><span class="hljs-keyword">if</span> (bp <span class="hljs-keyword">instanceof</span> SmartInstantiationAwareBeanPostProcessor) &#123;<br>SmartInstantiationAwareBeanPostProcessor ibp = (SmartInstantiationAwareBeanPostProcessor) bp;<br>exposedObject = ibp.getEarlyBeanReference(exposedObject, beanName);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> exposedObject;<br>&#125;<br></code></pre></td></tr></table></figure><p>　　该方法会去执行 SmartInstantiationAwareBeanPostProcessor 中的 getEarlyBeanReference 方法，而这个接口下的实现类中只有两个类实现了这个方法，一个是 AbstractAutoProxyCreator，一个是 InstantiationAwareBeanPostProcessorAdapter，它的实现如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// InstantiationAwareBeanPostProcessorAdapter</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getEarlyBeanReference</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-keyword">return</span> bean;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// AbstractAutoProxyCreator</span><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getEarlyBeanReference</span><span class="hljs-params">(Object bean, String beanName)</span> </span>&#123;<br>Object cacheKey = getCacheKey(bean.getClass(), beanName);<br><span class="hljs-keyword">this</span>.earlyProxyReferences.put(cacheKey, bean);<br><span class="hljs-keyword">return</span> wrapIfNecessary(bean, beanName, cacheKey);<br>&#125;<br></code></pre></td></tr></table></figure><p>　在整个 Spring 中，默认就只有 AbstractAutoProxyCreator 真正意义上实现了 getEarlyBeanReference 方法，而该类就是用来进行 AOP 的。上文提到的 AnnotationAwareAspectJAutoProxyCreator 的父类就是 AbstractAutoProxyCreator。</p><p>那么　getEarlyBeanReference　方法到底在干什么？</p><ul><li>首先得到一个 cachekey，cachekey 就是beanName。</li><li>把 beanName 和 bean（这是原始对象）存入 earlyProxyReferences 中（标记已经 AOP 过了，初始化后不再进行 AOP）</li><li>调用 wrapIfNecessary 进行 AOP，得到一个代理对象。</li></ul><p>那么，什么时候会调用 getEarlyBeanReference 方法呢？回到循环依赖的场景中</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220702165327.png"></p><p>　　第三集缓存中保存的 ObjectFactory 实际上是一个 labmda 表达式，中间有 getEarlyBeanReference 方法，注意存入 singletonFactories 时并不会执行 lambda 表达式，也就是不会执行 getEarlyBeanReference 方法</p><p>　　如果存在循环依赖，从 singletonFactories 根据 beanName 得到一个 ObjectFactory，然后执行 ObjectFactory#getObject，也就是执行 getEarlyBeanReference 方法，此时会得到一个 A 原始对象经过 AOP 之后的代理对象，然后把该代理对象放入 earlySingletonObjects 中，注意此时并没有把代理对象放入 singletonObjects 中，那什么时候放入到singletonObjects中呢？</p><p>　　我们这个时候得来理解一下 earlySingletonObjects 的作用，此时，我们只得到了 A 原始对象的代理对象，这个对象还不完整，因为 A 原始对象还没有进行属性填充，所以此时不能直接把 A 的代理对象放入 singletonObjects 中，所以只能把代理对象放入  earlySingletonObjects，假设现在有其他对象依赖了A，那么则可以从 earlySingletonObjects 中得到 A 原始对象的代理对象了，并且是 A 的同一个代理对象。</p><p>　　当 B 创建完了之后，A 继续进行生命周期，而 A 在完成属性注入后，会按照它本身的逻辑去进行 AOP，而此时我们知道 A 原始对象已经经历过了 AOP，所以对于 A 本身而言，不会再去进行 AOP 了，那么怎么判断一个对象是否经历过了 AOP 呢？会利用上文提到的 earlyProxyReferences，在 AbstractAutoProxyCreator 的 postProcessAfterInitialization 方法中，会去判断当前 beanName 是否在 earlyProxyReferences，如果在则表示已经提前进行过 AOP 了，无需再次进行 AOP。</p><p>　　对于 A 而言，进行了 AOP 的判断后，以及 BeanPostProcessor 的执行之后，就需要把 A 对应的对象放入 singletonObjects 中了，但是我们知道，应该是要把 A 的代理对象放入 singletonObjects 中，所以此时需要从 earlySingletonObjects 中得到代理对象，然后加入 singletonObjects 中。<strong>整个循环依赖解决完毕。</strong></p><h2 id="５-总结"><a href="#５-总结" class="headerlink" title="５.总结"></a>５.总结</h2><ol><li><strong>singletonObjects</strong>：缓存经过了<strong>完整生命周期</strong>的 bean</li><li><strong>earlySingletonObjects</strong>：缓存<strong>未经过完整生命周期的 bean</strong>，如果某个 bean 出现了循环依赖，就会<strong>提前</strong>把这个暂时未经过完整生命周期的 bean 放入 earlySingletonObjects 中，这个 bean 如果要经过 AOP，那么就会把代理对象放入 earlySingletonObjects 中，否则就是把原始对象放入 earlySingletonObjects。</li><li><strong>singletonFactories</strong>：缓存的是一个 ObjectFactory，实际上是一个 Lambda 表达式。在每个 Bean 的生成过程中，经过<strong>实例化</strong>得到一个原始对象后，都会提前基于原始对象暴露一个 Lambda 表达式，并保存到三级缓存中，这个 Lambda 表达式<strong>可能用到，也可能用不到</strong>，如果当前 Bean 没有出现循环依赖，那么这个 Lambda 表达式没用，当前 bean 按照自己的生命周期正常执行，执行完后直接把当前 bean 放入 singletonObjects 中，如果当前 bean 在依赖注入时发现出现了循环依赖（当前正在创建的 bean 被其他 bean 依赖了），则从三级缓存中拿到 Lambda 表达式，并执行 Lambda 表达式得到一个对象，并把得到的对象放入二级缓存（如果当前Bean需要AOP，那么执行lambda表达式，得到就是对应的代理对象，如果无需AOP，则直接得到一个原始对象）。</li><li>其实还要一个缓存，就是 <strong>earlyProxyReferences</strong>，它用来记录某个原始对象是否进行过 AOP 了。</li></ol><p>Spring 所用的 singletonFactories，为了调和不同的情况，在 singletonFactories 中存的是lambda 表达式，这样的话，只有在出现了循环依赖的情况，才会执行 lambda 表达式，才会进行 AOP，也就说只有在出现了循环依赖的情况下才会打破 Bean 生命周期的设计，如果一个 Bean 没有出现循环依赖，那么它还是遵守了 Bean 的生命周期的设计的。</p><ul><li>原型 Bean 循环依赖无法解决，如果其中一个为单例则可以解决</li><li>循环依赖中先加载的 Bean（后加载的不会出现） 中使用 @Async 注解（AsyncAnnotationBeanPostProcessor)，会修改 AOP 生成的代理对象，导致循环依赖失败（否则单例池中的对象和循环依赖中引用的对象不是同一个对象）。可通过在使用 @Async 注解的 Bean 中通过 @Lazy 修饰需要依赖注入的 Bean 来解决。</li><li>使用 @Transactional 注解，循环依赖不会失败。因为 @Transactional 不会向容器中添加 BeanPostProcessor，而是 BeanFactoryTransactionAttributeSourceAdvisor。</li><li>通过构造方法注入的循环依赖将注入失败（无法拿到半成品 Bean），可以通过在构造方法上使用 @Lazy 注解（生成代理对象）来解决。</li><li>自己注入自己也属于循环依赖，Spring 也可以自己解决。</li></ul>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——依赖注入源码解析</title>
    <link href="/2022/06/20/Spring%E2%80%94%E2%80%94%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/"/>
    <url>/2022/06/20/Spring%E2%80%94%E2%80%94%E4%BE%9D%E8%B5%96%E6%B3%A8%E5%85%A5%E6%BA%90%E7%A0%81%E8%A7%A3%E6%9E%90/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.processon.com/view/link/629e0d260791293c9388933b">https://www.processon.com/view/link/629e0d260791293c9388933b</a></p><h2 id="1-Spring-中依赖注入的方式"><a href="#1-Spring-中依赖注入的方式" class="headerlink" title="1. Spring 中依赖注入的方式"></a>1. Spring 中依赖注入的方式</h2><p>首先分两种：</p><ol><li>手动注入</li><li>自动注入</li></ol><h3 id="1-1-手动注入"><a href="#1-1-手动注入" class="headerlink" title="1.1 手动注入"></a>1.1 手动注入</h3><p>在 XML 中定义 Bean 时，就是手动注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean name=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.debug.service.UserService&quot;</span>&gt;<br>&lt;property name=<span class="hljs-string">&quot;orderService&quot;</span> ref=<span class="hljs-string">&quot;orderService&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>上面这种方式底层是通过 <strong>set方法</strong> 进行注入。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean name=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.debug.service.UserService&quot;</span>&gt;<br>&lt;constructor-arg index=<span class="hljs-string">&quot;0&quot;</span> ref=<span class="hljs-string">&quot;orderService&quot;</span>/&gt;<br>&lt;/bean&gt;<br></code></pre></td></tr></table></figure><p>上面这种方式底层是通过 <strong>构造方法</strong> 进行注入。</p><p>所以手动注入的底层也就是分为两种：</p><ol><li>set 方法注入</li><li>构造方法注入</li></ol><h3 id="1-2-自动注入"><a href="#1-2-自动注入" class="headerlink" title="1.2 自动注入"></a>1.2 自动注入</h3><p>自动注入又分为两种：</p><ol><li>XML &lt;bean  autowire=”byType”/&gt; /    @Bean(autowire = Autowire.BY_NAME)</li><li>@Autowired 注解的自动注入</li></ol><h2 id="2-XML-的-autowire-自动注入"><a href="#2-XML-的-autowire-自动注入" class="headerlink" title="2. XML 的 autowire 自动注入"></a>2. XML 的 autowire 自动注入</h2><p>在 XML 中，我们可以在定义一个 Bean 时去指定这个 Bean 的自动注入模式：</p><ol><li>byType</li><li>byName</li><li>constructor</li><li>default</li><li>no</li></ol><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.debug.service.UserService&quot;</span> autowire=<span class="hljs-string">&quot;byType&quot;</span>/&gt;<br></code></pre></td></tr></table></figure><p>这么写，表示 Spring 会自动的给 userService 中所有的属性自动赋值（<strong>不需要</strong>这个属性上有 @Autowired 注解，但需要这个属性有对应的 <strong>set方法</strong>）。</p><p>在创建 Bean 的过程中，在填充属性时，Spring 会去解析当前类，把<strong>当前类的所有方法</strong>都解析出来，Spring 会去解析每个方法得到对应的 PropertyDescriptor 对象，PropertyDescriptor 中有几个属性：</p><ol><li>name：这个 name 并不是方法的名字，而是拿方法名字进过处理后的名字<ul><li>如果方法名字以 “get” 开头，比如 “getXXX”  ,那么 name=XXX</li><li>如果方法名字以 “is” 开头，比如 “isXXX” ,那么 name=XXX</li><li> 如果方法名字以 “set” 开头，比如 “setXXX” ,那么 name=XXX</li></ul></li><li>readMethodRef：表示 get 方法的 Method 对象的引用</li><li>readMethodName：表示 get 方法的名字</li><li>writeMethodRef：表示 set 方法的 Method 对象的引用</li><li>writeMethodName：表示 set 方法的名字</li><li>propertyTypeRef：如果有 get 方法那么对应的就是返回值的类型，如果是 set 方法那么对应的就是 set 方法中唯一参数的类型</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">protected</span> String[] unsatisfiedNonSimpleProperties(AbstractBeanDefinition mbd, BeanWrapper bw) &#123;<br><span class="hljs-comment">// bw 包含当前需要注入属性的对象</span><br>Set&lt;String&gt; result = <span class="hljs-keyword">new</span> TreeSet&lt;&gt;();<br>PropertyValues pvs = mbd.getPropertyValues();<br><span class="hljs-comment">// 属性描述器 getter 和 setter</span><br>PropertyDescriptor[] pds = bw.getPropertyDescriptors();<br><span class="hljs-comment">/*</span><br><span class="hljs-comment">哪些属性能自动注入？</span><br><span class="hljs-comment">1. 有 set 方法</span><br><span class="hljs-comment">2. 没有在 ignoredDependencyTypes 中</span><br><span class="hljs-comment">3. set 方法不是 ignoredDependencyInterfaces 中某个接口定义的</span><br><span class="hljs-comment">4. 属性类型不是简单类型 Int Integer... （@Autowired 可以注入）</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">for</span> (PropertyDescriptor pd : pds) &#123;<br><span class="hljs-keyword">if</span> (pd.getWriteMethod() != <span class="hljs-keyword">null</span> &amp;&amp; !isExcludedFromDependencyCheck(pd) &amp;&amp; !pvs.contains(pd.getName()) &amp;&amp;<br>!BeanUtils.isSimpleProperty(pd.getPropertyType())) &#123;<br>result.add(pd.getName());<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> StringUtils.toStringArray(result);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>get方法的定义是：</strong> 方法参数个数为 0 个，并且 （方法名字以 “get” 开头 或者 方法名字以 “is” 开头并且方法的返回类型为 boolean）</p><p><strong>set方法的定义是：</strong> 方法参数个数为 1 个，并且 （方法名字以 “set” 开头并且方法返回类型为 void）</p><p>所以，Spring 在通过 byName 的自动填充属性时流程是：</p><ol><li>找到所有 set 方法所对应的 XXX 部分的名字</li><li>根据 XXX 部分的名字去获取 bean</li></ol><p>Spring 在通过 byType 的自动填充属性时流程是：</p><ol><li>获取到 set 方法中的唯一参数的参数类型，并且根据该类型去容器中获取 bean</li><li>如果找到多个，会报错。</li></ol><p>以上，分析了 autowire 的  byType 和 byName 情况，那么接下来分析 constructor，constructor 表示通过构造方法注入.。</p><p>如果是 constructor，那么就可以不写 set 方法了，当某个 bean 是通过构造方法来注入时，spring 利用构造方法的参数信息从 Spring 容器中去找 bean，找到bean 之后作为参数传给构造方法，从而实例化得到一个 bean 对象，并完成属性赋值。</p><p>其实构造方法注入相当于 byType+byName，普通的 byType 是根据 set 方法中的参数类型去找 bean，找到多个会报错，而 constructor 就是通过构造方法中的参数类型去找 bean，如果找到多个会根据参数名确定。</p><p>另外两个：</p><ol><li>no，表示关闭 autowire</li><li>default，表示默认值，我们一直演示的某个bean的autowire，而也可以直接在 &lt;beans&gt; 标签中设置 autowire，如果设置了，那么 &lt;bean&gt; 标签中设置的 autowire 如果为 default，那么则会用 &lt;beans&gt; 标签中设置的 autowire。</li></ol><p>可以发现 XML 中的自动注入是挺强大的，那么问题来了，<strong>为什么我们平时都是用的@Autowired注解呢？而没有用上文说的这种自动注入方式呢？</strong></p><p>@Autowired 注解相当于 XML 中的 autowire 属性的<strong>注解方式的替代</strong>。</p><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs coffeescript">Essentially, the @Autowired annotation provides the same capabilities <span class="hljs-keyword">as</span> described <span class="hljs-keyword">in</span> Autowiring Collaborators but <span class="hljs-keyword">with</span> more fine-grained control <span class="hljs-keyword">and</span> wider applicability<br><br>从本质上讲，@Autowired注解提供了与autowire相同的功能，但是拥有更细粒度的控制和更广泛的适用性。<br></code></pre></td></tr></table></figure><p>注意：<strong>更细粒度的控制</strong>。</p><p>XML 中的 autowire 控制的是整个 bean 的所有属性，而 @Autowired 注解是直接写在某个属性、某个 set 方法、某个构造方法上的。</p><p>再举个例子，如果一个类有多个构造方法，那么如果用 XML 的 autowire=constructor，你无法控制到底用哪个构造方法，而你可以用 @Autowired 注解来直接指定你想用哪个构造方法。</p><p>同时，用 @Autowired 注解，还可以控制，哪些属性想被自动注入，哪些属性不想，这也是细粒度的控制。</p><p>但是 @Autowired 无法区分 byType 和 byName，@Autowired 是先 byType，如果找到多个则 byName。</p><p>那么 XML 的自动注入底层其实也就是：</p><ol><li>set方法注入</li><li>构造方法注入</li></ol><h2 id="3-Autowired-注解的自动注入"><a href="#3-Autowired-注解的自动注入" class="headerlink" title="3. @Autowired 注解的自动注入"></a>3. @Autowired 注解的自动注入</h2><p>依赖注入流程图：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220621225203.png"></p><p><a href="https://www.processon.com/view/link/5f899fa5f346fb06e1d8f570">https://www.processon.com/view/link/5f899fa5f346fb06e1d8f570</a></p><p>@Autowired 注解可以写在：</p><ol><li>属性上：先根据<strong>属性类型</strong>去找 Bean，如果找到多个再根据<strong>属性名</strong>确定一个</li><li>构造方法上：先根据方法<strong>参数类型</strong>去找 Bean，如果找到多个再根据<strong>参数名</strong>确定一个</li><li>set方法上：先根据方法<strong>参数类型</strong>去找 Bean，如果找到多个再根据<strong>参数名</strong>确定一个</li></ol><h3 id="3-1-寻找注入点"><a href="#3-1-寻找注入点" class="headerlink" title="3.1 寻找注入点"></a>3.1 寻找注入点</h3><p>在创建一个 Bean 的过程中，Spring 会利用 AutowiredAnnotationBeanPostProcessor 的 <strong>postProcessMergedBeanDefinition()</strong> 找出注入点并缓存，找注入点的流程为：</p><ol><li>遍历当前类的所有的属性字段 Field</li><li>查看字段上是否存在 @Autowired、@Value、@Inject 中的其中任意一个，存在则认为该字段是一个注入点</li><li>如果字段是 static 的，则不进行注入</li><li>获取 @Autowired 中的 required 属性的值</li><li>将字段信息构造成一个 <strong>AutowiredFieldElement对象</strong>，作为一个<strong>注入点对象</strong>添加到 currElements 集合中。</li><li>遍历当前类的所有方法 Method</li><li>判断当前 Method 是否是<strong>桥接方法</strong>，如果是找到原方法</li><li>查看方法上是否存在 @Autowired、@Value、@Inject 中的其中任意一个，存在则认为该方法是一个注入点</li><li>如果方法是 static 的，则不进行注入</li><li>获取 @Autowired 中的 required 属性的值</li><li>将方法信息构造成一个 <strong>AutowiredMethodElement 对象</strong>，作为一个<strong>注入点对象</strong>添加到 currElements 集合中。</li><li>遍历完当前类的字段和方法后，将<strong>遍历父类</strong>的，直到没有父类。</li><li>最后将 currElements 集合封装成一个 InjectionMetadata 对象，作为当前 Bean 对于的注入点集合对象，并缓存。</li></ol><h4 id="static-的字段或方法为什么不支持"><a href="#static-的字段或方法为什么不支持" class="headerlink" title="static 的字段或方法为什么不支持"></a>static 的字段或方法为什么不支持</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">OrderService</span> </span>&#123;<br><br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span>  </span>&#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> OrderService orderService;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test123&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>UserService 和 OrderService 都是原型 Bean，假设 Spring 支持 static 字段进行自动注入，那么现在调用两次</p><ol><li>UserService userService1 = context.getBean(“userService”)</li><li>UserService userService2 = context.getBean(“userService”)</li></ol><p>问此时，userService1 的 orderService 值是什么？还是它自己注入的值吗？</p><p>答案是不是，一旦 userService2 创建好了之后，static orderService 字段的值就发生了修改了，从而出现 bug。</p><h4 id="桥接方法"><a href="#桥接方法" class="headerlink" title="桥接方法"></a>桥接方法</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">UserInterface</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">setOrderService</span><span class="hljs-params">(T t)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">UserInterface</span>&lt;<span class="hljs-title">OrderService</span>&gt; </span>&#123;<br><br><span class="hljs-keyword">private</span> OrderService orderService;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setOrderService</span><span class="hljs-params">(OrderService orderService)</span> </span>&#123;<br><span class="hljs-keyword">this</span>.orderService = orderService;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test123&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>UserService对应的字节码为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">com</span>/<span class="hljs-title">debug</span>/<span class="hljs-title">service</span>/<span class="hljs-title">UserService</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">com</span>/<span class="hljs-title">debug</span>/<span class="hljs-title">service</span>/<span class="hljs-title">UserInterface</span> </span>&#123;<br><br>  <span class="hljs-comment">// compiled from: UserService.java</span><br><br>  <span class="hljs-meta">@Lorg</span>/springframework/stereotype/Component;()<br><br>  <span class="hljs-comment">// access flags 0x2</span><br>  <span class="hljs-keyword">private</span> Lcom/debug/service/OrderService; orderService<br><br>  <span class="hljs-comment">// access flags 0x1</span><br>  <span class="hljs-keyword">public</span> &lt;init&gt;()V<br>   L0<br>    LINENUMBER <span class="hljs-number">12</span> L0<br>    ALOAD <span class="hljs-number">0</span><br>    INVOKESPECIAL java/lang/Object.&lt;init&gt; ()V<br>    RETURN<br>   L1<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lcom/debug/service/UserService; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">1</span><br>    MAXLOCALS = <span class="hljs-number">1</span><br><br>  <span class="hljs-comment">// access flags 0x1</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">setOrderService</span><span class="hljs-params">(Lcom/debug/service/OrderService;)</span>V</span><br><span class="hljs-function">  @Lorg/springframework/beans/factory/annotation/Autowired</span>;()<br>   L0<br>    LINENUMBER <span class="hljs-number">19</span> L0<br>    ALOAD <span class="hljs-number">0</span><br>    ALOAD <span class="hljs-number">1</span><br>    PUTFIELD com/debug/service/UserService.orderService : Lcom/debug/service/OrderService;<br>   L1<br>    LINENUMBER <span class="hljs-number">20</span> L1<br>    RETURN<br>   L2<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lcom/debug/service/UserService; L0 L2 <span class="hljs-number">0</span><br>    LOCALVARIABLE orderService Lcom/debug/service/OrderService; L0 L2 <span class="hljs-number">1</span><br>    MAXSTACK = <span class="hljs-number">2</span><br>    MAXLOCALS = <span class="hljs-number">2</span><br><br>  <span class="hljs-comment">// access flags 0x1</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">test</span><span class="hljs-params">()</span>V</span><br><span class="hljs-function">   L0</span><br><span class="hljs-function">    LINENUMBER 23 L0</span><br><span class="hljs-function">    GETSTATIC java/lang/System.out : Ljava/io/PrintStream</span>;<br>    LDC <span class="hljs-string">&quot;test123&quot;</span><br>    INVOKEVIRTUAL java/io/PrintStream.println (Ljava/lang/String;)V<br>   L1<br>    LINENUMBER <span class="hljs-number">24</span> L1<br>    RETURN<br>   L2<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lcom/debug/service/UserService; L0 L2 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">2</span><br>    MAXLOCALS = <span class="hljs-number">1</span><br><br>  <span class="hljs-comment">// access flags 0x1041</span><br>  <span class="hljs-function"><span class="hljs-keyword">public</span> synthetic bridge <span class="hljs-title">setOrderService</span><span class="hljs-params">(Ljava/lang/Object;)</span>V</span><br><span class="hljs-function">  @Lorg/springframework/beans/factory/annotation/Autowired</span>;()<br>   L0<br>    LINENUMBER <span class="hljs-number">11</span> L0<br>    ALOAD <span class="hljs-number">0</span><br>    ALOAD <span class="hljs-number">1</span><br>    CHECKCAST com/debug/service/OrderService<br>    INVOKEVIRTUAL com/debug/service/UserService.setOrderService (Lcom/debug/service/OrderService;)V<br>    RETURN<br>   L1<br>    LOCALVARIABLE <span class="hljs-keyword">this</span> Lcom/debug/service/UserService; L0 L1 <span class="hljs-number">0</span><br>    MAXSTACK = <span class="hljs-number">2</span><br>    MAXLOCALS = <span class="hljs-number">2</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>可以看到在 UserSerivce 的字节码中有两个 setOrderService  方法：</p><ol><li> public setOrderService(Lcom/debug/service/OrderService;)V</li><li> public synthetic bridge setOrderService(Ljava/lang/Object;)V</li></ol><p>并且都是存在 @Autowired 注解的。</p><p>所以在 Spring 中需要处理这种情况，当遍历到桥接方法时，得找到原方法。</p><h3 id="3-2-注入点进行注入"><a href="#3-2-注入点进行注入" class="headerlink" title="3.2 注入点进行注入"></a>3.2 注入点进行注入</h3><p>Spring 在 AutowiredAnnotationBeanPostProcessor 的 <strong>postProcessPropertyValues()</strong> 方法中，会遍历所找到的注入点依次进行注入。</p><h4 id="字段注入"><a href="#字段注入" class="headerlink" title="字段注入"></a>字段注入</h4><ol><li>遍历所有的 <strong>AutowiredFieldElement 对象。</strong></li><li>将对应的字段封装为 <strong>DependencyDescriptor 对象</strong>。</li><li>调用 BeanFactory 的 <strong>resolveDependency()</strong> 方法，传入 <strong>DependencyDescriptor 对象</strong>，进行依赖查找，找到当前字段所匹配的 Bean 对象。</li><li>将 <strong>DependencyDescriptor 对象</strong>和所找到的<strong>结果对象 beanName</strong> 封装成一个 <strong>ShortcutDependencyDescriptor 对象</strong>作为缓存，比如如果当前 Bean 是原型 Bean，那么下次再来创建该 Bean 时，就可以直接拿缓存的结果对象 beanName 去 BeanFactory 中去拿 bean 对象了，不用再次进行查找了</li><li>利用反射将结果对象赋值给字段。</li></ol><h4 id="方法注入"><a href="#方法注入" class="headerlink" title="方法注入"></a>方法注入</h4><ol><li>遍历所有的 <strong>AutowiredMethodElement 对象</strong></li><li>遍历将对应的方法的参数，将每个参数封装成 <strong>MethodParameter 对象</strong></li><li>将 <strong>MethodParameter 对象</strong>封装为 <strong>DependencyDescriptor 对象</strong></li><li>调用 BeanFactory 的 <strong>resolveDependency()</strong> 方法，传入 <strong>DependencyDescriptor 对象</strong>，进行依赖查找，找到当前方法参数所匹配的 Bean 对象。</li><li>将 <strong>DependencyDescriptor 对象</strong>和所找到的<strong>结果对象 beanName</strong> 封装成一个 <strong>ShortcutDependencyDescriptor 对象</strong>作为缓存，比如如果当前 Bean 是原型 Bean，那么下次再来创建该 Bean 时，就可以直接拿缓存的结果对象 beanName 去 BeanFactory 中去拿 bean 对象了，不用再次进行查找了</li><li>利用反射将找到的所有结果对象传给当前方法，并执行。</li></ol><h4 id="DefaultListableBeanFactory-resolveDependency-实现流程"><a href="#DefaultListableBeanFactory-resolveDependency-实现流程" class="headerlink" title="DefaultListableBeanFactory#resolveDependency  实现流程"></a>DefaultListableBeanFactory#resolveDependency  实现流程</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220629224806.png"></p><p><a href="https://www.processon.com/view/link/5f8d3c895653bb06ef076688">https://www.processon.com/view/link/5f8d3c895653bb06ef076688</a></p><h4 id="findAutowireCandidates-实现"><a href="#findAutowireCandidates-实现" class="headerlink" title="findAutowireCandidates() 实现"></a>findAutowireCandidates() 实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Nullable</span><br><span class="hljs-function">Object <span class="hljs-title">resolveDependency</span><span class="hljs-params">(DependencyDescriptor descriptor, <span class="hljs-meta">@Nullable</span> String requestingBeanName,</span></span><br><span class="hljs-params"><span class="hljs-function"><span class="hljs-meta">@Nullable</span> Set&lt;String&gt; autowiredBeanNames, <span class="hljs-meta">@Nullable</span> TypeConverter typeConverter)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br></code></pre></td></tr></table></figure><p>该方法表示，传入一个依赖描述（DependencyDescriptor），该方法会根据该依赖描述从 BeanFactory 中找出对应的唯一的一个 Bean 对象。</p><ol><li>找出 BeanFactory 中类型为 type 的所有的 Bean 的名字，注意是名字，而不是 Bean 对象，因为我们可以根据 BeanDefinition 就能判断和当前 type 是不是匹配，不用生成 Bean 对象</li><li>把 resolvableDependencies 中 key 为 type 的对象找出来并添加到 result 中</li><li>遍历根据 type 找出的 beanName，判断当前 beanName 对应的 Bean 是不是能够被自动注入</li><li>先判断 beanName 对应的 BeanDefinition 中的 autowireCandidate 属性，如果为false，表示不能用来进行自动注入，如果为 true 则继续进行判断</li><li>判断当前 type 是不是泛型，如果是泛型是会把容器中所有的 beanName 找出来的，如果是这种情况，那么在这一步中就要获取到泛型的真正类型，然后进行匹配，如果当前 beanName 和当前泛型对应的真实类型匹配，那么则继续判断</li><li>如果当前 DependencyDescriptor 上存在 @Qualifier 注解，那么则要判断当前 beanName 上是否定义了Qualifier，并且是否和当前 DependencyDescriptor 上的 Qualifier 相等，相等则匹配</li><li>经过上述验证之后，当前 beanName 才能成为一个可注入的，添加到 result 中</li></ol><h4 id="关于依赖注入中泛型注入的实现"><a href="#关于依赖注入中泛型注入的实现" class="headerlink" title="关于依赖注入中泛型注入的实现"></a>关于依赖注入中泛型注入的实现</h4><p>首先在 Java 反射中，有一个 Type 接口，表示类型，具体分类为：</p><ol><li>raw types：也就是普通 Class</li><li>parameterized types：对应 ParameterizedType 接口，泛型类型</li><li>array types：对应 GenericArrayType，泛型数组</li><li>type variables：对应 TypeVariable 接口，表示类型变量，也就是所定义的泛型，比如T、K</li><li>primitive types：基本类型，int、boolean</li></ol><p>大家可以好好看看下面代码所打印的结果：<br>​</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TypeTest</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span> i;<br><span class="hljs-keyword">private</span> Integer it;<br><span class="hljs-keyword">private</span> <span class="hljs-keyword">int</span>[] iarray;<br><span class="hljs-keyword">private</span> List list;<br><span class="hljs-keyword">private</span> List&lt;String&gt; slist;<br><span class="hljs-keyword">private</span> List&lt;T&gt; tlist;<br><span class="hljs-keyword">private</span> T t;<br><span class="hljs-keyword">private</span> T[] tarray;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> NoSuchFieldException </span>&#123;<br><br>test(TypeTest.class.getDeclaredField(<span class="hljs-string">&quot;i&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>test(TypeTest.class.getDeclaredField(<span class="hljs-string">&quot;it&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>test(TypeTest.class.getDeclaredField(<span class="hljs-string">&quot;iarray&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>test(TypeTest.class.getDeclaredField(<span class="hljs-string">&quot;list&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>test(TypeTest.class.getDeclaredField(<span class="hljs-string">&quot;slist&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>test(TypeTest.class.getDeclaredField(<span class="hljs-string">&quot;tlist&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>test(TypeTest.class.getDeclaredField(<span class="hljs-string">&quot;t&quot;</span>));<br>System.out.println(<span class="hljs-string">&quot;=======&quot;</span>);<br>test(TypeTest.class.getDeclaredField(<span class="hljs-string">&quot;tarray&quot;</span>));<br><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">(Field field)</span> </span>&#123;<br><br><span class="hljs-keyword">if</span> (field.getType().isPrimitive()) &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;是基本数据类型&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;不是基本数据类型&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (field.getGenericType() <span class="hljs-keyword">instanceof</span> ParameterizedType) &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;是泛型类型&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;不是泛型类型&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (field.getType().isArray()) &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;是普通数组&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;不是普通数组&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (field.getGenericType() <span class="hljs-keyword">instanceof</span> GenericArrayType) &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;是泛型数组&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;不是泛型数组&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">if</span> (field.getGenericType() <span class="hljs-keyword">instanceof</span> TypeVariable) &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;是泛型变量&quot;</span>);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>System.out.println(field.getName() + <span class="hljs-string">&quot;不是泛型变量&quot;</span>);<br>&#125;<br><br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>Spring 中，注入点是一个泛型时，也是会进行处理的，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BaseService</span> &lt;<span class="hljs-title">OrderService</span>, <span class="hljs-title">StockService</span>&gt; </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(o);<br>&#125;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseService</span> &lt;<span class="hljs-title">O</span>, <span class="hljs-title">S</span>&gt; </span>&#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">protected</span> O o;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">protected</span> S s;<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>Spring 扫描时发现 UserService 是一个 Bean</li><li>那就取出注入点，也就是 BaseService 中的两个属性 o、s</li><li>接下来需要按注入点类型进行注入，但是 o 和 s 都是泛型，所以 Spring 需要确定 o 和 s 的具体类型。</li><li>因为当前正在创建的是 UserService 的 Bean，所以可以通过 <code>userService.getClass().getGenericSuperclass().getTypeName()</code> 获取到具体的泛型信息，比如 <code>com.debug.service.BaseService&lt;com.debug.service.OrderService, com.debug.service.StockService&gt;</code></li><li>然后再拿到 UserService 的父类 BaseService 的泛型变量：<code> for (TypeVariable&lt;? extends Class&lt;?&gt;&gt; typeParameter : userService.getClass().getSuperclass().getTypeParameters()) &#123; System._out_.println(typeParameter.getName()); &#125;</code></li><li>通过上面两段代码，就能知道 o 对应的具体就是 OrderService，s 对应的具体类型就是 StockService</li><li>然后再调用 <code>Field.getGenericType()</code> 就知道当前 field 使用的是哪个泛型，就能知道具体类型了</li></ol><h4 id="Qualifier-的使用"><a href="#Qualifier-的使用" class="headerlink" title="@Qualifier 的使用"></a>@Qualifier 的使用</h4><p>定义两个注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Qualifier(&quot;random&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> Random &#123;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Target(&#123;ElementType.TYPE, ElementType.FIELD&#125;)</span><br><span class="hljs-meta">@Retention(RetentionPolicy.RUNTIME)</span><br><span class="hljs-meta">@Qualifier(&quot;roundRobin&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-meta">@interface</span> RoundRobin &#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>定义一个接口和两个实现类，表示负载均衡：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">LoadBalance</span> </span>&#123;<br><span class="hljs-function">String <span class="hljs-title">select</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@Random</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RandomStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LoadBalance</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">select</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-meta">@RoundRobin</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RoundRobinStrategy</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">LoadBalance</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">select</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span>  </span>&#123;<br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-meta">@RoundRobin</span><br><span class="hljs-keyword">private</span> LoadBalance loadBalance;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(loadBalance);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="4-Resource"><a href="#4-Resource" class="headerlink" title="4. @Resource"></a>4. @Resource</h2><h3 id="4-1-寻找注入点"><a href="#4-1-寻找注入点" class="headerlink" title="4.1 寻找注入点"></a>4.1 寻找注入点</h3><p>CommonAnnotationBeanPostProcessor#postProcessMergedBeanDefinition</p><p>将 @Resource 注解的属性和方法作为注入点</p><h3 id="4-2-依赖注入"><a href="#4-2-依赖注入" class="headerlink" title="4.2 依赖注入"></a>4.2 依赖注入</h3><p>@Resource注解底层工作流程图：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220701002519.png"></p><p><a href="https://www.processon.com/view/link/5f91275f07912906db381f6e">https://www.processon.com/view/link/5f91275f07912906db381f6e</a></p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——Bean的生命周期</title>
    <link href="/2022/05/28/Spring%E2%80%94%E2%80%94Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <url>/2022/05/28/Spring%E2%80%94%E2%80%94Bean%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</url>
    
    <content type="html"><![CDATA[<p><a href="https://www.processon.com/view/link/629e0d260791293c9388933b">https://www.processon.com/view/link/629e0d260791293c9388933b</a></p><p>Spring 最重要的功能就是 IOC，而启动 Spring 就是为创建 Bean 对象做准备。</p><p>Bean 的生命周期就是指：<strong>在Spring中，一个Bean是如何创建、如何销毁的</strong></p><p>Bean 生命周期流程图：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220529092534.png"></p><h2 id="Bean-扫描"><a href="#Bean-扫描" class="headerlink" title="Bean 扫描"></a>Bean 扫描</h2><h3 id="1-生成-BeanDefinition"><a href="#1-生成-BeanDefinition" class="headerlink" title="1. 生成 BeanDefinition"></a>1. 生成 BeanDefinition</h3><p>Spring 启动的时候会进行扫描，会先调用 <code>org.springframework.context.annotation.ClassPathScanningCandidateComponentProvider#scanCandidateComponents(String basePackage)</code>  扫描某个包路径，并得到BeanDefinition 的 Set 集合。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220529094123.png"></p><p>Spring扫描底层流程：<a href="https://www.processon.com/view/link/61370ee60e3e7412ecd95d43">https://www.processon.com/view/link/61370ee60e3e7412ecd95d43</a></p><ol><li>首先，通过 ResourcePatternResolver 获得指定包路径下的所有<code>.class</code>文件</li><li>遍历每个 Resource 对象</li><li>利用 MetadataReaderFactory 解析 Resource 对象得到 MetadataReader（在Spring源码中MetadataReaderFactory具体的实现类为CachingMetadataReaderFactory，MetadataReader的具体实现类为 SimpleMetadataReader）</li><li>利用MetadataReader进行excludeFilters和includeFilters，以及条件注解@Conditional的筛选（条件注解并不能理解：某个类上是否存在@Conditional注解，如果存在则调用注解中所指定的类的match方法进行匹配，匹配成功则通过筛选，匹配失败则pass掉。）</li><li>筛选通过后，基于metadataReader生成ScannedGenericBeanDefinition</li><li>再基于metadataReader判断是不是对应的类是不是接口或抽象类</li><li>如果筛选通过，那么就表示扫描到了一个Bean，将ScannedGenericBeanDefinition加入结果集</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220529234900.png"></p><p>MetadataReader表示类的元数据读取器，主要包含了 AnnotationMetadata 和 classMetadata，功能有</p><ol><li>获取类的名字</li><li>获取父类的名字</li><li>获取所实现的所有接口名</li><li>获取所有内部类的名字</li><li>判断是不是抽象类</li><li>判断是不是接口</li><li>判断是不是一个注解</li><li>获取拥有某个注解的方法集合</li><li>获取类上添加的所有注解信息</li><li>获取类上添加的所有注解类型集合</li></ol><p>值得注意的是，CachingMetadataReaderFactory 解析某个 .class 文件得到 MetadataReader 对象是利用的 <strong>ASM</strong> 技术，并没有加载这个类到 JVM。并且最终得到的 ScannedGenericBeanDefinition 对象，<strong>beanClass 属性存储的是当前类的名字，而不是 class 对象</strong>。（beanClass属性的类型是Object，它即可以存储类的名字，也可以存储class对象）</p><p>最后，上面是通过扫描得到 BeanDefinition 对象，我们还可以通过直接定义 BeanDefinition，或解析 spring.xml文件的 <bean/>，或者 @Bean注解得到 BeanDefinition 对象。</p><p> BeanDefinition：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220529235316.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> Set&lt;BeanDefinitionHolder&gt; <span class="hljs-title">doScan</span><span class="hljs-params">(String... basePackages)</span> </span>&#123;<br>Assert.notEmpty(basePackages, <span class="hljs-string">&quot;At least one base package must be specified&quot;</span>);<br>Set&lt;BeanDefinitionHolder&gt; beanDefinitions = <span class="hljs-keyword">new</span> LinkedHashSet&lt;&gt;();<br><span class="hljs-keyword">for</span> (String basePackage : basePackages) &#123;<br><span class="hljs-comment">// 扫描包路径，得到 BeanDefinition</span><br>Set&lt;BeanDefinition&gt; candidates = findCandidateComponents(basePackage);<br><span class="hljs-keyword">for</span> (BeanDefinition candidate : candidates) &#123;<br>ScopeMetadata scopeMetadata = <span class="hljs-keyword">this</span>.scopeMetadataResolver.resolveScopeMetadata(candidate);<br><span class="hljs-comment">// 设置作用域</span><br>candidate.setScope(scopeMetadata.getScopeName());<br><span class="hljs-comment">// 获取 BeanName  前两个字母为大写 BeanName 则为类名</span><br>String beanName = <span class="hljs-keyword">this</span>.beanNameGenerator.generateBeanName(candidate, <span class="hljs-keyword">this</span>.registry);<br><span class="hljs-comment">// 设置 BeanDefinition 默认值</span><br><span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AbstractBeanDefinition) &#123;<br>postProcessBeanDefinition((AbstractBeanDefinition) candidate, beanName);<br>&#125;<br><span class="hljs-keyword">if</span> (candidate <span class="hljs-keyword">instanceof</span> AnnotatedBeanDefinition) &#123;<br><span class="hljs-comment">// 解析 @lazy、@Primary、@DependsOn、@Role、@Description</span><br>AnnotationConfigUtils.processCommonDefinitionAnnotations((AnnotatedBeanDefinition) candidate);<br>&#125;<br><span class="hljs-comment">// 检查容器中是否存在该 BeanName，返回 false 不会注册进去，如果冲突直接抛出异常</span><br><span class="hljs-keyword">if</span> (checkCandidate(beanName, candidate)) &#123;<br><br>BeanDefinitionHolder definitionHolder = <span class="hljs-keyword">new</span> BeanDefinitionHolder(candidate, beanName);<br><span class="hljs-comment">// 创建 AOP 对象</span><br>definitionHolder =<br>AnnotationConfigUtils.applyScopedProxyMode(scopeMetadata, definitionHolder, <span class="hljs-keyword">this</span>.registry);<br>beanDefinitions.add(definitionHolder);<br><span class="hljs-comment">// 注册到 BeanDefinitionMap</span><br>registerBeanDefinition(definitionHolder, <span class="hljs-keyword">this</span>.registry);<br>&#125;<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> beanDefinitions;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-componentsIndex"><a href="#2-componentsIndex" class="headerlink" title="2.  componentsIndex"></a>2.  componentsIndex</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220530225830.png"></p><p>使用 componentsIndex 将不再进行 Bean 扫描。加了 componentsIndex 的类还是需要加 @Compoent</p><p><a href="https://blog.csdn.net/W_317/article/details/117405805">https://blog.csdn.net/W_317/article/details/117405805</a><br><a href="https://blog.csdn.net/zzuhkp/article/details/108257764">https://blog.csdn.net/zzuhkp/article/details/108257764</a></p><h2 id="Bean-的生成过程"><a href="#Bean-的生成过程" class="headerlink" title="Bean 的生成过程"></a>Bean 的生成过程</h2><h3 id="1-合并-BeanDefinition"><a href="#1-合并-BeanDefinition" class="headerlink" title="1. 合并 BeanDefinition"></a>1. 合并 BeanDefinition</h3><p>通过扫描得到所有 BeanDefinition 之后，就可以根据 BeanDefinition 创建 Bean 对象了，但是在 Spring 中支持父子 BeanDefinition，和 Java 父子类类似。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.beans.User&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span> <span class="hljs-attr">abstract</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.Service.UserService&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;user&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p>子 BeanDefinition 会继承父 BeanDefinition 的属性，所以 userService 是原型的。</p><p>而在根据 userService 来生成 Bean 对象之前，需要进行 BeanDefinition 的合并，得到完整的 userService 的 BeanDefinition。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220605111531.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 获取合并后的 BeanDefinition ( 从父 BeanDefinition 获取自己未定义的属性）</span><br><span class="hljs-comment"> * 合并 BeanDefinition 将生成一个新的 RootBeanDefinition</span><br><span class="hljs-comment"> * 没有父 BeanDefinition 将属性复制到一个新的 RootBeanDefinition</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">protected</span> RootBeanDefinition <span class="hljs-title">getMergedBeanDefinition</span><span class="hljs-params">(</span></span><br><span class="hljs-params"><span class="hljs-function">String beanName, BeanDefinition bd, <span class="hljs-meta">@Nullable</span> BeanDefinition containingBd)</span></span><br><span class="hljs-function"><span class="hljs-keyword">throws</span> BeanDefinitionStoreException </span>&#123;<br><br><span class="hljs-keyword">synchronized</span> (<span class="hljs-keyword">this</span>.mergedBeanDefinitions) &#123;<br>RootBeanDefinition mbd = <span class="hljs-keyword">null</span>;<br><br><span class="hljs-keyword">if</span> (containingBd == <span class="hljs-keyword">null</span>) &#123;<br>mbd = <span class="hljs-keyword">this</span>.mergedBeanDefinitions.get(beanName);<br>&#125;<br><br><span class="hljs-keyword">if</span> (mbd == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-comment">// 如果没有父 BeanDefinition 直接深拷贝</span><br><span class="hljs-keyword">if</span> (bd.getParentName() == <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">if</span> (bd <span class="hljs-keyword">instanceof</span> RootBeanDefinition) &#123;<br>mbd = ((RootBeanDefinition) bd).cloneBeanDefinition();<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>mbd = <span class="hljs-keyword">new</span> RootBeanDefinition(bd);<br>&#125;<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>BeanDefinition pbd;<br><span class="hljs-keyword">try</span> &#123;<br>String parentBeanName = transformedBeanName(bd.getParentName());<br><span class="hljs-comment">// 递归合并</span><br><span class="hljs-keyword">if</span> (!beanName.equals(parentBeanName)) &#123;<br>pbd = getMergedBeanDefinition(parentBeanName);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>BeanFactory parent = getParentBeanFactory();<br><span class="hljs-keyword">if</span> (parent <span class="hljs-keyword">instanceof</span> ConfigurableBeanFactory) &#123;<br>pbd = ((ConfigurableBeanFactory) parent).getMergedBeanDefinition(parentBeanName);<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NoSuchBeanDefinitionException(parentBeanName,<br><span class="hljs-string">&quot;Parent name &#x27;&quot;</span> + parentBeanName + <span class="hljs-string">&quot;&#x27; is equal to bean name &#x27;&quot;</span> + beanName +<br><span class="hljs-string">&quot;&#x27;: cannot be resolved without a ConfigurableBeanFactory parent&quot;</span>);<br>&#125;<br>&#125;<br>&#125; <span class="hljs-keyword">catch</span> (NoSuchBeanDefinitionException ex) &#123;<br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> BeanDefinitionStoreException(bd.getResourceDescription(), beanName,<br><span class="hljs-string">&quot;Could not resolve parent bean definition &#x27;&quot;</span> + bd.getParentName() + <span class="hljs-string">&quot;&#x27;&quot;</span>, ex);<br>&#125;<br>mbd = <span class="hljs-keyword">new</span> RootBeanDefinition(pbd);<br><span class="hljs-comment">// 子 BeanDefinition 覆盖父 BeanDefinition 属性</span><br>mbd.overrideFrom(bd);<br>&#125;<br><br><span class="hljs-keyword">if</span> (!StringUtils.hasLength(mbd.getScope())) &#123;<br>mbd.setScope(SCOPE_SINGLETON);<br>&#125;<br><span class="hljs-comment">// 包含非单例 Bean 的 Bean 本身不能是单例的</span><br><span class="hljs-keyword">if</span> (containingBd != <span class="hljs-keyword">null</span> &amp;&amp; !containingBd.isSingleton() &amp;&amp; mbd.isSingleton()) &#123;<br>mbd.setScope(containingBd.getScope());<br>&#125;<br><br><span class="hljs-comment">// 缓存 BeanDefinition</span><br><span class="hljs-keyword">if</span> (containingBd == <span class="hljs-keyword">null</span> &amp;&amp; isCacheBeanMetadata()) &#123;<br><span class="hljs-keyword">this</span>.mergedBeanDefinitions.put(beanName, mbd);<br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> mbd;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-加载类"><a href="#2-加载类" class="headerlink" title="2. 加载类"></a>2. 加载类</h3><p>BeanDefinition 合并之后，就可以去创建 Bean 对象了，而创建 Bean 就必须实例化对象，而实例化就必须先加载当前 BeanDefinition 所对应的 class，在 AbstractAutowireCapableBeanFactory 类的 createBean() 方法中，一开始就会调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Class&lt;?&gt; resolvedClass = resolveBeanClass(mbd, beanName);<br></code></pre></td></tr></table></figure><p>这行代码就是去加载类，该方法是这么实现的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">if</span> (mbd.hasBeanClass()) &#123;<br><span class="hljs-keyword">return</span> mbd.getBeanClass();<br>&#125;<br><span class="hljs-keyword">if</span> (System.getSecurityManager() != <span class="hljs-keyword">null</span>) &#123;<br><span class="hljs-keyword">return</span> AccessController.doPrivileged((PrivilegedExceptionAction&lt;Class&lt;?&gt;&gt;) () -&gt;<br>doResolveBeanClass(mbd, typesToMatch), getAccessControlContext());<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> doResolveBeanClass(mbd, typesToMatch);<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">hasBeanClass</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.beanClass <span class="hljs-keyword">instanceof</span> Class);<br>&#125;<br></code></pre></td></tr></table></figure><p>如果 beanClass 属性的类型是 Class，那么就直接返回，如果不是，则会根据类名进行加载（doResolveBeanClass 方法所做的事情）</p><p>会利用 BeanFactory 所设置的类加载器来加载类，如果没有设置，则默认使用 <strong>ClassUtils.getDefaultClassLoader()</strong>  所返回的类加载器来加载。</p><h4 id="ClassUtils-getDefaultClassLoader"><a href="#ClassUtils-getDefaultClassLoader" class="headerlink" title="ClassUtils.getDefaultClassLoader()"></a><strong>ClassUtils.getDefaultClassLoader()</strong></h4><ol><li>优先返回当前线程中的 ClassLoader</li><li>线程中类加载器为 null 的情况下，返回 ClassUtils 类的类加载器</li><li>如果 ClassUtils 类的类加载器为空，那么则表示是 Bootstrap 类加载器加载的 ClassUtils 类，那么则返回系统类加载器</li></ol><h3 id="3-实例化前"><a href="#3-实例化前" class="headerlink" title="3. 实例化前"></a>3. 实例化前</h3><p>当前 BeanDefinition 对应的类成功加载后，就可以实例化对象了，但是在 Spring 中，实例化对象之前，Spring 提供了一个扩展点，允许用户来控制是否在某个或某些 Bean 实例化之前做一些启动动作。这个扩展点叫 **InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()**。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220603202638.png"></p><p>【示例】：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InstantiationAwareBeanPostProcessor</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;user&quot;</span>.equals(beanName))&#123;<br>System.out.println(<span class="hljs-string">&quot;实例化前&quot;</span>);<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>如上代码会导致，在 user 这个 Bean 实例化前，会进行打印。</p><p>值得注意的是，postProcessBeforeInstantiation() 是有返回值的，如果这么实现：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InstantiationAwareBeanPostProcessor</span> </span>&#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInstantiation</span><span class="hljs-params">(Class&lt;?&gt; beanClass, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;user&quot;</span>.equals(beanName))&#123;<br>System.out.println(<span class="hljs-string">&quot;实例化前&quot;</span>);<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> User();<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>user 这个 Bean，在实例化前会直接返回一个由我们所定义的 user 对象。如果是这样，表示不需要 Spring 来实例化了，并且后续的 Spring 依赖注入也不会进行了，会跳过一些步骤，直接执行初始化后这一步。</p><h3 id="4-实例化"><a href="#4-实例化" class="headerlink" title="4. 实例化"></a>4. 实例化</h3><p>在这个步骤中就会根据 BeanDefinition 去创建一个对象了。</p><h4 id="4-1-Supplier-创建对象"><a href="#4-1-Supplier-创建对象" class="headerlink" title="4.1 Supplier 创建对象"></a>4.1 Supplier 创建对象</h4><p>首先判断 BeanDefinition 中是否设置了 Supplier，如果设置了则调用 Supplier 的 get() 得到对象。</p><p>得直接使用 BeanDefinition 对象来设置 Supplier，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();<br>beanDefinition.setInstanceSupplier(<span class="hljs-keyword">new</span> Supplier&lt;Object&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserService();<br>&#125;<br>&#125;);<br>context.registerBeanDefinition(<span class="hljs-string">&quot;userService&quot;</span>, beanDefinition);<br></code></pre></td></tr></table></figure><h4 id="4-2-工厂方法创建对象"><a href="#4-2-工厂方法创建对象" class="headerlink" title="4.2 工厂方法创建对象"></a>4.2 工厂方法创建对象</h4><p>如果没有设置 Supplier，则检查 BeanDefinition 中是否设置了 factoryMethod，也就是工厂方法，有两种方式可以设置 factoryMethod，比如：</p><p>方式一：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;userService&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.zth.service.UserService&quot;</span> factory-method=<span class="hljs-string">&quot;createUserService&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>对应的 UserService 类为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> UserService <span class="hljs-title">createUserService</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;执行createUserService()&quot;</span>);<br>UserService userService = <span class="hljs-keyword">new</span> UserService();<br><span class="hljs-keyword">return</span> userService;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>System.out.println(<span class="hljs-string">&quot;test&quot;</span>);<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>方式二：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;bean id=<span class="hljs-string">&quot;commonService&quot;</span> <span class="hljs-class"><span class="hljs-keyword">class</span></span>=<span class="hljs-string">&quot;com.zhouyu.service.CommonService&quot;</span>/&gt;<br>&lt;bean id=<span class="hljs-string">&quot;userService1&quot;</span> factory-bean=<span class="hljs-string">&quot;commonService&quot;</span> factory-method=<span class="hljs-string">&quot;createUserService&quot;</span> /&gt;<br></code></pre></td></tr></table></figure><p>对应的 CommonService 的类为：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CommonService</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> UserService <span class="hljs-title">createUserService</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserService();<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>Spring 发现当前 BeanDefinition 方法设置了工厂方法后，就会区分这两种方式，然后调用工厂方法得到对象。</p><p>值得注意的是，我们通过 @Bean 所定义的 BeanDefinition，是存在 factoryMethod 和 factoryBean 的，也就是和上面的方式二非常类似，@Bean 所注解的方法就是 factoryMethod，AppConfig 对象就是 factoryBean。如果 @Bean 所注解的方法是 static 的，那么对应的就是方式一。</p><h3 id="4-3-推断构造方法"><a href="#4-3-推断构造方法" class="headerlink" title="4.3 推断构造方法"></a>4.3 推断构造方法</h3><p>推断完构造方法后，就会使用构造方法来进行实例化了。</p><p>额外的，在推断构造方法逻辑中除了会去选择构造方法以及查找入参对象意外，还会判断是否在对应的类中是否存在使用 <strong>@Lookup注解</strong> 了方法。如果存在则把该方法封装为 LookupOverride 对象并添加到 BeanDefinition 中。</p><p>在实例化时，如果判断出来当前 BeanDefinition 中没有 LookupOverride，那就直接用构造方法反射得到一个实例对象。如果存在 LookupOverride 对象，也就是类中存在 @Lookup 注解了的方法，那就会生成一个代理对象。</p><p>@Lookup 注解就是<strong>方法注入</strong>，使用 demo 如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserService</span> </span>&#123;<br><br><span class="hljs-keyword">private</span> OrderService orderService;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">test</span><span class="hljs-params">()</span> </span>&#123;<br>OrderService orderService = createOrderService();<br>System.out.println(orderService);<br>&#125;<br><br><span class="hljs-meta">@Lookup(&quot;orderService&quot;)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> OrderService <span class="hljs-title">createOrderService</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-BeanDefinition-的后置处理"><a href="#5-BeanDefinition-的后置处理" class="headerlink" title="5. BeanDefinition 的后置处理"></a>5. BeanDefinition 的后置处理</h3><p>Bean 对象实例化出来之后，接下来就应该给对象的属性赋值了。在真正给属性赋值之前，Spring 又提供了一个扩展点 **MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition()**，可以对此时的 BeanDefinition 进行加工，比如设置初始化方法或设置属性等等。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220603232841.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugMergedBeanDefinitionPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MergedBeanDefinitionPostProcessor</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessMergedBeanDefinition</span><span class="hljs-params">(RootBeanDefinition beanDefinition, Class&lt;?&gt; beanType, String beanName)</span> </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;userService&quot;</span>.equals(beanName)) &#123;<br>beanDefinition.getPropertyValues().add(<span class="hljs-string">&quot;orderService&quot;</span>, <span class="hljs-keyword">new</span> OrderService());<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Spring 源码中，AutowiredAnnotationBeanPostProcessor 就是一个 MergedBeanDefinitionPostProcessor，它的 postProcessMergedBeanDefinition() 中会去查找注入点，并缓存在 AutowiredAnnotationBeanPostProcessor 对象的一个 Map 中（injectionMetadataCache）。</p><h3 id="6-实例化后"><a href="#6-实例化后" class="headerlink" title="6. 实例化后"></a>6. 实例化后</h3><p>在处理完 BeanDefinition 后，Spring 又设计了一个扩展点：**InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()**，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">DebugInstantiationAwareBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InstantiationAwareBeanPostProcessor</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">postProcessAfterInstantiation</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;userService&quot;</span>.equals(beanName)) &#123;<br>UserService userService = (UserService) bean;<br>userService.test();<br>&#125;<br><br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>上述代码就是对 userService 所实例化出来的对象进行处理。</p><p>返回 false 不在执行其他 postProcessAfterInstantiation。</p><h3 id="7-依赖注入"><a href="#7-依赖注入" class="headerlink" title="7. 依赖注入"></a>7. 依赖注入</h3><p><a href="https://debuggingworld.github.io/2022/04/18/Spring%E2%80%94%E2%80%94IOC%E7%9A%84%E4%BD%BF%E7%94%A8/#%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5">https://debuggingworld.github.io/2022/04/18/Spring%E2%80%94%E2%80%94IOC%E7%9A%84%E4%BD%BF%E7%94%A8/#%E8%87%AA%E5%8A%A8%E6%B3%A8%E5%85%A5</a></p><p>这里的自动注入指的是 Spring 的自动注入。</p><h3 id="8-填充属性后"><a href="#8-填充属性后" class="headerlink" title="8. 填充属性后"></a>8. 填充属性后</h3><p>这个步骤中，就会处理 @Autowired、@Resource、@Value 等注解，也是通过 <strong>InstantiationAwareBeanPostProcessor.postProcessProperties()</strong> 扩展点来实现的，比如我们可以实现一个自己的自动注入功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugInstantiationAwareBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InstantiationAwareBeanPostProcessor</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> PropertyValues <span class="hljs-title">postProcessProperties</span><span class="hljs-params">(PropertyValues pvs, Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;userService&quot;</span>.equals(beanName)) &#123;<br><span class="hljs-keyword">for</span> (Field field : bean.getClass().getFields()) &#123;<br><span class="hljs-keyword">if</span> (field.isAnnotationPresent(DebugInject.class)) &#123;<br>field.setAccessible(<span class="hljs-keyword">true</span>);<br><span class="hljs-keyword">try</span> &#123;<br>field.set(bean, <span class="hljs-string">&quot;123&quot;</span>);<br>&#125; <span class="hljs-keyword">catch</span> (IllegalAccessException e) &#123;<br>e.printStackTrace();<br>&#125;<br>&#125;<br>&#125;<br>&#125;<br><br><span class="hljs-keyword">return</span> pvs;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="9-执行Aware"><a href="#9-执行Aware" class="headerlink" title="9. 执行Aware"></a>9. 执行Aware</h3><p>完成了属性赋值之后，Spring 会执行一些回调，包括：</p><ol><li>BeanNameAware：回传beanName给bean对象。</li><li>BeanClassLoaderAware：回传classLoader给bean对象。</li><li>BeanFactoryAware：回传beanFactory给对象。</li></ol><h3 id="10-初始化前"><a href="#10-初始化前" class="headerlink" title="10. 初始化前"></a>10. 初始化前</h3><p>初始化前，也是 Spring 提供的一个扩展点：**BeanPostProcessor.postProcessBeforeInitialization()**，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;userService&quot;</span>.equals(beanName)) &#123;<br>System.out.println(<span class="hljs-string">&quot;初始化前&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> bean;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>利用初始化前，可以对进行了依赖注入的Bean进行处理。</p><p>在Spring源码中：</p><ol><li>InitDestroyAnnotationBeanPostProcessor 会在初始化前这个步骤中执行 @PostConstruct 的方法，</li><li>ApplicationContextAwareProcessor 会在初始化前这个步骤中进行其他 Aware 的回调：<ol><li>EnvironmentAware：回传环境变量</li><li>EmbeddedValueResolverAware：回传占位符解析器</li><li>ResourceLoaderAware：回传资源加载器</li><li>ApplicationEventPublisherAware：回传事件发布器</li><li>MessageSourceAware：回传国际化资源</li><li>ApplicationStartupAware：回传应用其他监听对象，可忽略</li><li>ApplicationContextAware：回传Spring容器ApplicationContext</li></ol></li></ol><h3 id="11-初始化"><a href="#11-初始化" class="headerlink" title="11. 初始化"></a>11. 初始化</h3><ol><li>查看当前 Bean 对象是否实现了 InitializingBean 接口，如果实现了就调用其 afterPropertiesSet() 方法</li><li>执行 BeanDefinition 中指定的初始化方法</li></ol><h3 id="12-初始化后"><a href="#12-初始化后" class="headerlink" title="12. 初始化后"></a>12. 初始化后</h3><p>这是 Bean 创建生命周期中的最后一个步骤，也是 Spring 提供的一个扩展点：**BeanPostProcessor.postProcessAfterInitialization()**，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebugBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br><span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;userService&quot;</span>.equals(beanName)) &#123;<br>System.out.println(<span class="hljs-string">&quot;初始化后&quot;</span>);<br>&#125;<br><br><span class="hljs-keyword">return</span> bean;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>可以在这个步骤中，对 Bean 最终进行处理，Spring 中的<strong>AOP就是基于初始化后实现</strong>的，<strong>初始化后返回的对象才是最终的 Bean 对象</strong>。</p><h3 id="13-总结-BeanPostProcessor"><a href="#13-总结-BeanPostProcessor" class="headerlink" title="13. 总结 BeanPostProcessor"></a>13. 总结 BeanPostProcessor</h3><ol><li>InstantiationAwareBeanPostProcessor.postProcessBeforeInstantiation()<ol><li>实例化</li></ol></li><li>MergedBeanDefinitionPostProcessor.postProcessMergedBeanDefinition()</li><li>InstantiationAwareBeanPostProcessor.postProcessAfterInstantiation()</li><li>自动注入</li><li>InstantiationAwareBeanPostProcessor.postProcessProperties()</li><li>Aware对象</li><li>BeanPostProcessor.postProcessBeforeInitialization()</li><li>初始化</li><li>BeanPostProcessor.postProcessAfterInitialization()</li></ol><h2 id="Bean的销毁过程"><a href="#Bean的销毁过程" class="headerlink" title="Bean的销毁过程"></a>Bean的销毁过程</h2><p>Bean 销毁是发生在 Spring 容器关闭过程中。</p><p>在 Spring 容器关闭时，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br>UserService userService = (UserService) context.getBean(<span class="hljs-string">&quot;userService&quot;</span>);<br>userService.test();<br><br><span class="hljs-comment">// 容器关闭</span><br>context.close();<br></code></pre></td></tr></table></figure><p>或者：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br><span class="hljs-comment">// 注册关闭钩子</span><br>context.registerShutdownHook();<br>UserService userService = ((UserService) context.getBean(<span class="hljs-string">&quot;userService&quot;</span>));<br>userService.test();<br></code></pre></td></tr></table></figure><p>在 Bean 创建过程中，在最后（初始化之后），有一个步骤会去判断当前创建的 Bean 是不是 DisposableBean：</p><ol><li>当前 Bean 是否实现了 DisposableBean 接口</li><li>当前 Bean 是否实现了 AutoCloseable 接口</li><li>BeanDefinition 中是否指定了 destroyMethod</li><li>调用 DestructionAwareBeanPostProcessor.requiresDestruction(bean) 进行判断<ul><li> ApplicationListenerDetector 中直接使得 ApplicationListener 是 DisposableBean</li><li> InitDestroyAnnotationBeanPostProcessor 中使得拥有 @PreDestroy 注解了的方法就是 DisposableBean</li></ul></li><li>把符合上述任意一个条件的 Bean 适配成 DisposableBeanAdapter 对象，并存入 disposableBeans 中（一个LinkedHashMap）</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">DestructionAwareBeanPostProcessor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br><br><span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeforeDestruction</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br><br><span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">requiresDestruction</span><span class="hljs-params">(Object bean)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Spring 容器关闭过程是：</p><ol><li>首先发布 ContextClosedEvent 事件</li><li>调用 lifecycleProcessor 的 onCloese() 方法</li><li>销毁单例 Bean<ol><li>遍历 disposableBeans<ul><li> 把每个 disposableBean 从单例池中移除</li><li> 如果这个 disposableBean 还被其他 Bean 依赖了，那么也得销毁其他 Bean</li><li> 调用 disposableBean 的 destroy()</li><li> 如果这个 disposableBean 还包含了 inner beans，将这些 Bean 从单例池中移除掉 (inner bean参考<a href="https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-inner-beans">https://docs.spring.io/spring-framework/docs/current/spring-framework-reference/core.html#beans-inner-beans</a>)</li><li> 清空 containedBeanMap</li><li> 清空 dependentBeanMap</li><li> 清空 dependenciesForBeanMap</li></ul></li><li>清空 manualSingletonNames，是一个 Set，存的是用户手动注册的单例 Bean 的 beanName</li><li>清空 allBeanNamesByType，是一个 Map，key 是 bean 类型，value 是该类型所有的 beanName 数组</li><li>清空 singletonBeanNamesByType，和 allBeanNamesByType 类似，只不过只存了单例 Bean</li></ol></li></ol><p>这里涉及到一个设计模式：<strong>适配器模式</strong><br>将实现了 DisposableBean 接口、或者 AutoCloseable 接口等适配成实现了 DisposableBean 接口，所以就用到了 DisposableBeanAdapter。</p><p>在销毁时，Spring 会找出实现了 DisposableBean 接口的 Bean。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——底层架构核心概念</title>
    <link href="/2022/05/02/Spring%E2%80%94%E2%80%94%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/"/>
    <url>/2022/05/02/Spring%E2%80%94%E2%80%94%E5%BA%95%E5%B1%82%E6%9E%B6%E6%9E%84%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5/</url>
    
    <content type="html"><![CDATA[<h3 id="1-BeanDefinition"><a href="#1-BeanDefinition" class="headerlink" title="1. BeanDefinition"></a>1. BeanDefinition</h3><p>BeanDefinition 表示 Bean 定义，BeanDefinition 中存在很多属性用来描述一个 Bean 的特点。比如：</p><ul><li>beanClass：表示 Bean 类型</li><li>scope：表示 Bean 作用域，单例或原型等</li><li>lazyInit：表示 Bean 是否是懒加载</li><li>initMethodName：表示 Bean 初始化时要执行的方法</li><li>destroyMethodName：表示 Bean 销毁时要执行的方法</li><li>……</li></ul><p>在 Spring 中，经常会通过以下几种方式来定义Bean：</p><ol><li>&lt;bean/&gt;</li><li>@Bean</li><li>@Component(@Service,@Controller)</li></ol><p>这些，称之<strong>申明式定义Bean</strong>。</p><p>我们还可以<strong>编程式定义Bean</strong>，那就是直接通过 BeanDefinition，比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br><br>AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();<br>beanDefinition.setBeanClass(User.class);<br>beanDefinition.setLazyInit(<span class="hljs-keyword">true</span>);<br>beanDefinition.setScope(<span class="hljs-string">&quot;prototype&quot;</span>);<br>context.registerBeanDefinition(<span class="hljs-string">&quot;user&quot;</span>,beanDefinition);<br><br>System.out.println(context.getBean(User.class));<br></code></pre></td></tr></table></figure><p>和申明式事务、编程式事务类似，通过 &lt;bean/&gt;，@Bean，@Component 等申明式方式所定义的 Bean，最终都会被 Spring 解析为对应的BeanDefinition 对象，并放入Spring 容器中。</p><h3 id="2-BeanDefinitionReader"><a href="#2-BeanDefinitionReader" class="headerlink" title="2. BeanDefinitionReader"></a>2. BeanDefinitionReader</h3><p>BeanDefinition 读取器（BeanDefinitionReader）</p><h4 id="2-1-AnnotatedBeanDefinitionReader"><a href="#2-1-AnnotatedBeanDefinitionReader" class="headerlink" title="2.1 AnnotatedBeanDefinitionReader"></a>2.1 AnnotatedBeanDefinitionReader</h4><p>可以直接把某个类转换为 BeanDefinition，并且会解析该类上的注解，比如</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br><br>AnnotatedBeanDefinitionReader annotatedBeanDefinitionReader = <span class="hljs-keyword">new</span> AnnotatedBeanDefinitionReader(context);<br>annotatedBeanDefinitionReader.registerBean(User.class);<br><br>System.out.println(context.getBean(User.class));<br></code></pre></td></tr></table></figure><p>注意：它能解析的注解是：@Conditional、 <strong>@Scope</strong> 、@Lazy、@Primary、@DependsOn、@Role、@Description</p><h4 id="2-2-XmlBeanDefinitionReader"><a href="#2-2-XmlBeanDefinitionReader" class="headerlink" title="2.2 XmlBeanDefinitionReader"></a>2.2 XmlBeanDefinitionReader</h4><p>可以解析<bean/>标签</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br><br>XmlBeanDefinitionReader xmlBeanDefinitionReader = <span class="hljs-keyword">new</span> XmlBeanDefinitionReader(context);<br>xmlBeanDefinitionReader.loadBeanDefinitions(<span class="hljs-string">&quot;debug.xml&quot;</span>);<br><br>System.out.println(context.getBean(User.class));<br></code></pre></td></tr></table></figure><h3 id="3-ClassPathBeanDefinitionScanner"><a href="#3-ClassPathBeanDefinitionScanner" class="headerlink" title="3 ClassPathBeanDefinitionScanner"></a>3 ClassPathBeanDefinitionScanner</h3><p>ClassPathBeanDefinitionScanner 是扫描器，但是它的作用和 BeanDefinitionReader 类似，它可以进行扫描，扫描某个包路径，对扫描到的类进行解析，比如扫描到的类上如果存在 @Component 注解，那么就会把这个类解析为一个BeanDefinition。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();<br>context.refresh();<br><br>ClassPathBeanDefinitionScanner classPathBeanDefinitionScanner = <span class="hljs-keyword">new</span> ClassPathBeanDefinitionScanner(context);<br>classPathBeanDefinitionScanner.scan(<span class="hljs-string">&quot;com.zth&quot;</span>);<br><br>System.out.println(context.getBean(User.class));<br></code></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/52f96a333e9b">ClassPathBeanDefinitionScanner</a></p><h3 id="4-BeanFactory"><a href="#4-BeanFactory" class="headerlink" title="4. BeanFactory"></a>4. BeanFactory</h3><p>BeanFactory 表示 Bean <strong>工厂</strong>，BeanFactory 负责创建 Bean，并且提供获取 Bean 的 API。</p><p>在 Spring 中，BeanFactory 接口最重要的实现类是：<strong>DefaultListableBeanFactory</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">DefaultListableBeanFactory beanFactory = <span class="hljs-keyword">new</span> DefaultListableBeanFactory();<br><br>AbstractBeanDefinition beanDefinition = BeanDefinitionBuilder.genericBeanDefinition().getBeanDefinition();<br>beanDefinition.setBeanClass(User.class);<br>beanFactory.registerBeanDefinition(<span class="hljs-string">&quot;user&quot;</span>, beanDefinition);<br><br>System.out.println(beanFactory.getBean(User.class));<br></code></pre></td></tr></table></figure><p><strong>DefaultListableBeanFactory是非常强大的，支持很多功能，可以通过查看DefaultListableBeanFactory的类继承实现结构来看</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220517223724.png"></p><p>它实现了很多接口：</p><ol><li>AliasRegistry：支持别名功能，一个名字可以对应多个别名</li><li>BeanDefinitionRegistry：可以注册、保存、移除、获取某个 BeanDefinition</li><li>BeanFactory：Bean工厂，可以根据 bean 的名字、类型、别名获取 Bean 对象</li><li>SingletonBeanRegistry：可以直接注册、获取某个<strong>单例</strong> Bean</li><li>SimpleAliasRegistry：它是一个类，实现了 AliasRegistry 接口，支持别名功能</li><li>ListableBeanFactory：在 BeanFactory 的基础上，增加了其他功能，可以获取所有 BeanDefinition 的 beanNames，可以根据某个类型获取对应的 beanNames，可以根据某个类型获取 {类型：对应的 Bean } 的映射关系</li><li>HierarchicalBeanFactory：在 BeanFactory 的基础上，添加了获取父 BeanFactory 的功能</li><li>DefaultSingletonBeanRegistry：它是一个类，实现了 SingletonBeanRegistry 接口，拥有了直接注册、获取某个<strong>单例</strong> Bean 的功能</li><li>ConfigurableBeanFactory：在 HierarchicalBeanFactory 和 SingletonBeanRegistry 的基础上，添加了设置父 BeanFactory、类加载器（表示可以指定某个类加载器进行类的加载）、设置 Spring EL 表达式解析器（表示该 BeanFactory 可以解析 EL 表达式）、设置类型转化服务（表示该 BeanFactory 可以进行类型转化）、可以添加 BeanPostProcessor（表示该 BeanFactory 支持 Bean 的后置处理器），可以合并 BeanDefinition，可以销毁某个 Bean 等等功能</li><li>FactoryBeanRegistrySupport：支持了 FactoryBean 的功能</li><li>AutowireCapableBeanFactory：是直接继承了 BeanFactory，在 BeanFactory 的基础上，支持在创建 Bean 的过程中能对 Bean 进行自动装配</li><li>AbstractBeanFactory：实现了 ConfigurableBeanFactory 接口，继承了 FactoryBeanRegistrySupport，这个 BeanFactory 的功能已经很全面了，但是不能自动装配和获取 beanNames</li><li>ConfigurableListableBeanFactory：继承了 ListableBeanFactory、AutowireCapableBeanFactory、ConfigurableBeanFactory</li><li>AbstractAutowireCapableBeanFactory：继承了 AbstractBeanFactory，实现了 AutowireCapableBeanFactory，拥有了自动装配的功能</li><li>DefaultListableBeanFactory：继承了 AbstractAutowireCapableBeanFactory，实现了 ConfigurableListableBeanFactory 接口和BeanDefinitionRegistry 接口，所以 DefaultListableBeanFactory 的功能很强大</li></ol><h3 id="5-ApplicationContext"><a href="#5-ApplicationContext" class="headerlink" title="5. ApplicationContext"></a>5. ApplicationContext</h3><p>ApplicationContext 是 BeanFactory 的一种，在 Spring 源码中，是这么定义的：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ApplicationContext</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">EnvironmentCapable</span>, <span class="hljs-title">ListableBeanFactory</span>, <span class="hljs-title">HierarchicalBeanFactory</span>,</span><br><span class="hljs-class"><span class="hljs-title">MessageSource</span>, <span class="hljs-title">ApplicationEventPublisher</span>, <span class="hljs-title">ResourcePatternResolver</span> </span>&#123;<br><br>            ...<br>&#125;<br></code></pre></td></tr></table></figure><p>首先，在Java中，接口是可以<strong>多继承</strong>的，ApplicationContext 继承了 ListableBeanFactory 和 HierarchicalBeanFactory，而ListableBeanFactory 和 HierarchicalBeanFactory 都继承至 BeanFactory，所以 ApplicationContex t继承了 BeanFactory。</p><p>当 new 一个 ApplicationContext 时，其底层会 new 一个 BeanFactory 出来，当使用 ApplicationContext 的某些方法时，比如 getBean()，底层调用的是 BeanFactory 的 getBean() 方法。</p><p>ApplicationContext 是个接口，实际上也是一个 BeanFactory，不过比 BeanFactory 更加强大，比如：</p><ol><li>HierarchicalBeanFactory：拥有获取父 BeanFactory 的功能</li><li>ListableBeanFactory：拥有获取 beanNames 的功能</li><li>ResourcePatternResolver：资源加载器，可以一次性获取多个资源</li><li>EnvironmentCapable：可以获取运行时环境（没有设置运行时环境功能）</li><li>ApplicationEventPublisher：拥有广播事件的功能（没有添加事件监听器的功能）</li><li>MessageSource：拥有国际化功能</li></ol><h4 id="5-1-AnnotationConfigApplicationContext"><a href="#5-1-AnnotationConfigApplicationContext" class="headerlink" title="5.1 AnnotationConfigApplicationContext"></a>5.1 AnnotationConfigApplicationContext</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220518215301.png"></p><ol><li>ConfigurableApplicationContext：继承了 ApplicationContext 接口，增加了事件监听器、添加BeanFactoryPostProcessor、设置Environment，获取ConfigurableListableBeanFactory 等功能</li><li>AbstractApplicationContext：实现了 ConfigurableApplicationContext 接口</li><li>GenericApplicationContext：继承了 AbstractApplicationContext，实现了 BeanDefinitionRegistry 接口，拥有了所有 ApplicationContext 的功能，并且可以注册 BeanDefinition，注意这个类中有一个属性<strong>DefaultListableBeanFactory</strong></li><li>AnnotationConfigRegistry：可以单独注册某个为类为 BeanDefinition（可以处理该类上的 <strong>@Configuration</strong>注解，已经可以处理**@Bean注解**），同时可以扫描</li><li>AnnotationConfigApplicationContext：继承了 GenericApplicationContext，实现了 AnnotationConfigRegistry 接口，拥有了以上所有的功能</li></ol><h4 id="5-2-ClassPathXmlApplicationContext"><a href="#5-2-ClassPathXmlApplicationContext" class="headerlink" title="5.2 ClassPathXmlApplicationContext"></a>5.2 ClassPathXmlApplicationContext</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220518222613.png"></p><p>它也是继承了 AbstractApplicationContext，但是相对于 AnnotationConfigApplicationContext 而言，功能没有 AnnotationConfigApplicationContext 强大，比如不能注册 BeanDefinition。</p><h4 id="5-3-国际化"><a href="#5-3-国际化" class="headerlink" title="5.3 国际化"></a>5.3 国际化</h4><p>先定义一个 MessageSource：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-meta">@Bean</span><br>   <span class="hljs-function"><span class="hljs-keyword">public</span> MessageSource <span class="hljs-title">messageSource</span><span class="hljs-params">()</span></span>&#123;<br>       ResourceBundleMessageSource messageSource = <span class="hljs-keyword">new</span> ResourceBundleMessageSource();<br>       messageSource.setBasename(<span class="hljs-string">&quot;msg&quot;</span>);<br>       <span class="hljs-keyword">return</span> messageSource;<br>   &#125;<br><br><span class="hljs-meta">@Service</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MessageService</span> </span>&#123;<br>   <br>       <span class="hljs-meta">@Autowired</span><br>       <span class="hljs-keyword">private</span> MessageSource messageSource;<br>       <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Locale local = <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">&quot;en_US&quot;</span>);<br>   <br>   <br>       <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">getMessage</span><span class="hljs-params">(String key)</span> </span>&#123;<br>           <span class="hljs-keyword">return</span> messageSource.getMessage(key, <span class="hljs-keyword">null</span>, key, local);<br>       &#125;<br>   <br>   &#125;<br><br></code></pre></td></tr></table></figure><p>同时，因为 ApplicationContext 也拥有国际化的功能，所以可以直接这么用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 需要注入 MessageSource</span><br>context.getMessage(<span class="hljs-string">&quot;message&quot;</span>, <span class="hljs-keyword">null</span>, <span class="hljs-keyword">new</span> Locale(<span class="hljs-string">&quot;en_US&quot;</span>));<br></code></pre></td></tr></table></figure><p><a href="https://www.jianshu.com/p/69f5a19468db">https://www.jianshu.com/p/69f5a19468db</a></p><h4 id="5-4-资源加载"><a href="#5-4-资源加载" class="headerlink" title="5.4 资源加载"></a>5.4 资源加载</h4><p>ApplicationContext 还拥有资源加载的功能，可以直接利用 ApplicationContext 获取某个文件的内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br><br>    Resource resource = context.getResource(<span class="hljs-string">&quot;G:\\debugSpring\\src\\main\\java\\com\\zth\\debugSpring\\App.java&quot;</span>);<br>    System.out.println(resource.getFilename());<br><br>    Resource resource2 = context.getResource(<span class="hljs-string">&quot;classpath:dbConfig.properties&quot;</span>);<br>    System.out.println(resource2.contentLength());<br>    System.out.println(resource2.getURL());<br><br>    Resource resource1 = context.getResource(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>);<br>    System.out.println(resource1.contentLength());<br>    System.out.println(resource1.getURL());<br><br>    <span class="hljs-comment">// 一次性获取多个</span><br>    Resource[] resources = context.getResources(<span class="hljs-string">&quot;classpath:com/zth/*/*.class&quot;</span>);<br>    <span class="hljs-keyword">for</span> (Resource res : resources) &#123;<br>        System.out.println(res.getFilename());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-5-获取运行时环境"><a href="#5-5-获取运行时环境" class="headerlink" title="5.5 获取运行时环境"></a>5.5 获取运行时环境</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br><br>    <span class="hljs-comment">// 操作系统环境变量</span><br>    Map&lt;String, Object&gt; systemEnvironment = context.getEnvironment().getSystemEnvironment();<br>    System.out.println(systemEnvironment);<br><br>    <span class="hljs-comment">// JVM 启动时指定的环境变量</span><br>    Map&lt;String, Object&gt; systemProperties = context.getEnvironment().getSystemProperties();<br>    System.out.println(systemProperties);<br><br>    <span class="hljs-comment">// 变量集</span><br>    MutablePropertySources propertySources = context.getEnvironment().getPropertySources();<br>    System.out.println(propertySources);<br><br>    <span class="hljs-comment">// 获取指定变量</span><br>    System.out.println(context.getEnvironment().getProperty(<span class="hljs-string">&quot;driverClassName&quot;</span>));<br>    System.out.println(context.getEnvironment().getProperty(<span class="hljs-string">&quot;sun.jnu.encoding&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>注意，可以利用</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@PropertySource(&quot;classpath:dbConfig.properties&quot;)</span><br></code></pre></td></tr></table></figure><p>加载 properties 文件中的参数到运行时环境中。</p><h4 id="5-6-事件发布"><a href="#5-6-事件发布" class="headerlink" title="5.6 事件发布"></a>5.6 事件发布</h4><p>先定义一个事件监听器</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ApplicationListener <span class="hljs-title">applicationListener</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ApplicationListener() &#123;<br>        <span class="hljs-meta">@Override</span><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">onApplicationEvent</span><span class="hljs-params">(ApplicationEvent event)</span> </span>&#123;<br>            System.out.println(<span class="hljs-string">&quot;接收到事件&quot;</span>+event.getSource());<br>        &#125;<br>    &#125;;<br>&#125;<br></code></pre></td></tr></table></figure><p>然后发布一个事件：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">context.publishEvent(<span class="hljs-string">&quot;hello debuggingWorld&quot;</span>);<br></code></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/rickiyang/p/12001524.html">https://www.cnblogs.com/rickiyang/p/12001524.html</a></p><h3 id="6-类型转化"><a href="#6-类型转化" class="headerlink" title="6. 类型转化"></a>6. 类型转化</h3><p>在 Spring 源码中，有可能需要把String转成其他类型，所以在Spring源码中提供了一些技术来更方便的做对象的类型转化，关于类型转化的应用场景， 后续看源码的过程中会遇到很多。</p><h4 id="6-1-PropertyEditor"><a href="#6-1-PropertyEditor" class="headerlink" title="6.1 PropertyEditor"></a>6.1 PropertyEditor</h4><p>这其实是 JDK 中提供的类型转化工具类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Getter</span><br><span class="hljs-meta">@Setter</span><br><span class="hljs-meta">@ToString</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br>    String name;<br><br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringToTeacherPropertyEditor</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">PropertyEditorSupport</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">PropertyEditor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setAsText</span><span class="hljs-params">(String text)</span> <span class="hljs-keyword">throws</span> IllegalArgumentException </span>&#123;<br>        Teacher teacher = <span class="hljs-keyword">new</span> Teacher();<br>        teacher.setName(text);<br>        <span class="hljs-keyword">this</span>.setValue(teacher);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    StringToTeacherPropertyEditor propertyEditor = <span class="hljs-keyword">new</span> StringToTeacherPropertyEditor();<br>    propertyEditor.setAsText(<span class="hljs-string">&quot;debugging&quot;</span>);<br>    Teacher teacher = (Teacher) propertyEditor.getValue();<br>    System.out.println(teacher);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>如何向 Spring 中注册 PropertyEditor：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> CustomEditorConfigurer <span class="hljs-title">customEditorConfigurer</span><span class="hljs-params">()</span> </span>&#123;<br>    CustomEditorConfigurer customEditorConfigurer = <span class="hljs-keyword">new</span> CustomEditorConfigurer();<br>    Map&lt;Class&lt;?&gt;, Class&lt;? extends PropertyEditor&gt;&gt; propertyEditorMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>    <br>    <span class="hljs-comment">// 表示 StringToTeacherPropertyEditor 可以将 String 转化成 Teacher 类型</span><br>    <span class="hljs-comment">// 在 Spring 源码中，如果发现当前对象是 String，而需要的类型是 User，就会使用该 PropertyEditor 来做类型转化</span><br>    propertyEditorMap.put(Teacher.class, StringToTeacherPropertyEditor.class);<br>    customEditorConfigurer.setCustomEditors(propertyEditorMap);<br>    <span class="hljs-keyword">return</span> customEditorConfigurer;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设现在有如下Bean：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ToString</span><br><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br>    Integer age;<br>    <span class="hljs-meta">@Value(&quot;debugging&quot;)</span><br>    Teacher teacher;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>那么 @Value 就能正常的完成属性赋值。</p><h4 id="6-2-ConversionService"><a href="#6-2-ConversionService" class="headerlink" title="6.2 ConversionService"></a>6.2 ConversionService</h4><p>Spring 中提供的类型转化服务，它比 PropertyEditor 更强大（可以将任意类型转化为目标类型）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StringToTeacherConverter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ConditionalGenericConverter</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">matches</span><span class="hljs-params">(TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;<br>        <span class="hljs-comment">// 源类型是 String 目标类型是 Teacher 时进行转换</span><br>        <span class="hljs-keyword">return</span> sourceType.getType().equals(String.class) &amp;&amp; targetType.getType().equals(Teacher.class);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Set&lt;ConvertiblePair&gt; <span class="hljs-title">getConvertibleTypes</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Collections.singleton(<span class="hljs-keyword">new</span> ConvertiblePair(String.class, Teacher.class));<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">convert</span><span class="hljs-params">(Object source, TypeDescriptor sourceType, TypeDescriptor targetType)</span> </span>&#123;<br>        Teacher teacher = <span class="hljs-keyword">new</span> Teacher();<br>        teacher.setName((String) source);<br>        <span class="hljs-keyword">return</span> teacher;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>单独使用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    DefaultConversionService conversionService = <span class="hljs-keyword">new</span> DefaultConversionService();<br>    conversionService.addConverter(<span class="hljs-keyword">new</span> StringToTeacherConverter());<br>    Teacher value = conversionService.convert(<span class="hljs-string">&quot;debugging&quot;</span>, Teacher.class);<br>    System.out.println(value);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>向Spring中注册 ConversionService：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> ConversionServiceFactoryBean <span class="hljs-title">conversionService</span><span class="hljs-params">()</span> </span>&#123;<br>    ConversionServiceFactoryBean conversionServiceFactoryBean = <span class="hljs-keyword">new</span> ConversionServiceFactoryBean();<br>    conversionServiceFactoryBean.setConverters(Collections.singleton(<span class="hljs-keyword">new</span> StringToTeacherConverter()));<br>    <span class="hljs-keyword">return</span> conversionServiceFactoryBean;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-3-TypeConverter"><a href="#6-3-TypeConverter" class="headerlink" title="6.3 TypeConverter"></a>6.3 TypeConverter</h4><p>整合了 PropertyEditor 和 ConversionService 的功能，Spring 内部使用此种方式。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    SimpleTypeConverter typeConverter = <span class="hljs-keyword">new</span> SimpleTypeConverter();<br>    <span class="hljs-comment">//typeConverter.registerCustomEditor(Teacher.class, new StringToTeacherPropertyEditor());</span><br><br>    DefaultConversionService conversionService = <span class="hljs-keyword">new</span> DefaultConversionService();<br>    conversionService.addConverter(<span class="hljs-keyword">new</span> StringToTeacherConverter());<br>    typeConverter.setConversionService(conversionService);<br><br>    Teacher value = typeConverter.convertIfNecessary(<span class="hljs-string">&quot;debugging&quot;</span>, Teacher.class);<br>    System.out.println(value);<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="7-OrderComparator"><a href="#7-OrderComparator" class="headerlink" title="7. OrderComparator"></a>7. OrderComparator</h3><p>OrderComparator 是 Spring 所提供的一种比较器，可以用来根据实现 Ordered 接口来执行比较，从而可以进行排序。</p><p>比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Ordered</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getClass().getSimpleName();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">3</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Ordered</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getClass().getSimpleName();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">getOrder</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">2</span>;<br>    &#125;<br>&#125;<br><br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    A a = <span class="hljs-keyword">new</span> A(); <span class="hljs-comment">// order=3</span><br>    B b = <span class="hljs-keyword">new</span> B(); <span class="hljs-comment">// order=2</span><br><br>    OrderComparator comparator = <span class="hljs-keyword">new</span> OrderComparator();<br>    System.out.println(comparator.compare(a, b));  <span class="hljs-comment">// 1</span><br><br>    List list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(a);<br>    list.add(b);<br>    <span class="hljs-comment">// 按 order 值升序排序</span><br>    list.sort(comparator);<br><br>    System.out.println(list);  <span class="hljs-comment">// B，A</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>另外，Spring 中还提供了一个 OrderComparator 的子类：<strong>AnnotationAwareOrderComparator</strong>，它支持用 @Order 来指定 order 值。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-meta">@Order(3)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">A</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getClass().getSimpleName();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Order(2)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">B</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.getClass().getSimpleName();<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    A a = <span class="hljs-keyword">new</span> A(); <span class="hljs-comment">// order=3</span><br>    B b = <span class="hljs-keyword">new</span> B(); <span class="hljs-comment">// order=2</span><br><br>    OrderComparator comparator = <span class="hljs-keyword">new</span> AnnotationAwareOrderComparator();<br>    System.out.println(comparator.compare(a, b));  <span class="hljs-comment">// 1</span><br><br>    List list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    list.add(a);<br>    list.add(b);<br>    <span class="hljs-comment">// 按 order 值升序排序</span><br>    list.sort(comparator);<br><br>    System.out.println(list);  <span class="hljs-comment">// B，A</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-BeanPostProcessor"><a href="#8-BeanPostProcessor" class="headerlink" title="8. BeanPostProcessor"></a>8. BeanPostProcessor</h3><p>BeanPostProcess 表示 Bean 的后置处理器，我们可以定义一个或多个BeanPostProcessor。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebuggingBeanPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanPostProcessor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessBeforeInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;userService&quot;</span>.equals(beanName)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;初始化前&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">postProcessAfterInitialization</span><span class="hljs-params">(Object bean, String beanName)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;userService&quot;</span>.equals(beanName)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;初始化后&quot;</span>);<br>        &#125;<br>        <span class="hljs-keyword">return</span> bean;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>一个 BeanPostProcessor 可以在<strong>任意一个 Bean</strong> 的 <strong>初始化之前</strong>以及<strong>初始化之后</strong> 去额外的做一些用户自定义的逻辑，当然我们可以通过判断 beanName 来进行针对性处理（针对某个Bean，或某部分Bean）。</p><p>通过定义 BeanPostProcessor 来干涉 Spring 创建 Bean 的过程。</p><h3 id="9-BeanFactoryPostProcessor"><a href="#9-BeanFactoryPostProcessor" class="headerlink" title="9. BeanFactoryPostProcessor"></a>9. BeanFactoryPostProcessor</h3><p>BeanFactoryPostProcessor 表示 Bean 工厂的后置处理器，其实和 BeanPostProcessor 类似，BeanPostProcessor 是干涉 Bean 的创建过程，BeanFactoryPostProcessor 是干涉 BeanFactory 的创建过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebuggingBeanFactoryPostProcessor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanFactoryPostProcessor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postProcessBeanFactory</span><span class="hljs-params">(ConfigurableListableBeanFactory beanFactory)</span> <span class="hljs-keyword">throws</span> BeansException </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;加工 beanFactory&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>我们可以在postProcessBeanFactory()方法中对BeanFactory进行加工。</p><p>BeanFactoryPostProcessor 是在 spring 容器加载了 bean 的定义文件之后。</p><p>作用：</p><ol><li>在 bean 实例化之前执行的。可以用来对工厂内部的 beanDefinitionMap 中的 Bean 定义的属性进行修改和填充。</li><li>类中属性使用配置文件的定义来自动填充时，使 PropertySourcesPlaceholderConfigurer 会自动读取配置文件，并且填充到 BEANDEFINE 的属性中。<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;conf.properties&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;people1&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;p1&quot;</span>&gt;</span><span class="hljs-tag">&lt;/<span class="hljs-name">alias</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;people1&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.tpw.newday.bean.PeopleBean&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;p1.name&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="10-FactoryBean"><a href="#10-FactoryBean" class="headerlink" title="10. FactoryBean"></a>10. FactoryBean</h3><p>通过 FactoryBean 可以来控制 Bean 的创造过程。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DebuggingFactoryBean</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserService();<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> Class&lt;?&gt; getObjectType() &#123;<br>        <span class="hljs-keyword">return</span> UserService.class;<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br><br>    <span class="hljs-comment">// com.zth.debugSpring.service.UserService@303cf2ba</span><br>    System.out.println(context.getBean(<span class="hljs-string">&quot;debuggingFactoryBean&quot;</span>)); <br>    <span class="hljs-comment">// com.zth.debugSpring.config.DebuggingFactoryBean@76494737</span><br>    System.out.println(context.getBean(<span class="hljs-string">&quot;&amp;debuggingFactoryBean&quot;</span>));<br>&#125;<br></code></pre></td></tr></table></figure><p>在容器启动过程中，加了 @Component 的类不管是不是实现了 FactoryBean 接口，都会扫描为 BeanDefinition 并生成单例 Bean 放到单例池中（类型为 DebuggingFactoryBean）。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220525211710.png"></p><p>getBean() 中先从单例池拿到 FactoryBean 对象实例，然后判断是不是 FactoryBean，如果是则调用 getObject() 获取 Bean，然后缓存到 factoryBeanObjectCache。</p><p>调用 getBean() 之前：</p><p> <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220525214615.png"></p><p> 调用 getBean() 之后：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220525214933.png"></p><p>通过上面的 DebuggingFactoryBean  我们自己创造了一个 UserService 对象，并且它将成为 Bean。但是通过这种方式创造出来的 UserService 的 Bean <strong>只会经过初始化后（postProcessAfterInitialization）</strong>（为了实现 AOP），其他 Spring 的生命周期步骤是不会经过的，比如依赖注入。</p><p>@Bean 定义的 Bean 是会经过完整的 Bean 生命周期的。</p><h3 id="11-ExcludeFilter-和-IncludeFilter"><a href="#11-ExcludeFilter-和-IncludeFilter" class="headerlink" title="11. ExcludeFilter 和 IncludeFilter"></a>11. ExcludeFilter 和 IncludeFilter</h3><p>这两个 Filter 是 Spring 扫描过程中用来过滤的。ExcludeFilter 表示<strong>排除过滤器</strong>，IncludeFilter 表示<strong>包含过滤器</strong>。</p><p><a href="https://debuggingworld.github.io/2022/04/18/Spring%E2%80%94%E2%80%94IOC%E7%9A%84%E4%BD%BF%E7%94%A8/#3-1-%E7%B1%BB%E8%B7%AF%E5%BE%84%E6%89%AB%E6%8F%8F">（传送门）</a></p><p>比如以下配置，表示扫描 com.debugging 这个包下面的所有类，但是排除 UserService 类，就算它上面有 @Component 注解也不会成为 Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(value = &quot;com.debugging&quot;,</span><br><span class="hljs-meta">excludeFilters = &#123;@ComponentScan.Filter(</span><br><span class="hljs-meta">            type = FilterType.ASSIGNABLE_TYPE, </span><br><span class="hljs-meta">            classes = UserService.class)&#125;.)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>再比如以下配置，就算 UserService 类上没有 @Component 注解，它也会被扫描成为一个 Bean。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ComponentScan(value = &quot;com.debugging&quot;,</span><br><span class="hljs-meta">includeFilters = &#123;@ComponentScan.Filter(</span><br><span class="hljs-meta">            type = FilterType.ASSIGNABLE_TYPE, </span><br><span class="hljs-meta">            classes = UserService.class)&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>&#125;<br></code></pre></td></tr></table></figure><p>在 Spring 的扫描逻辑中，默认会添加一个 AnnotationTypeFilter 给 includeFilters，表示默认情况下 Spring 扫描过程中会认为类上有@Component 注解的就是 Bean。</p><p>ClassPathScanningCandidateComponentProvider.registerDefaultFilters()：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerDefaultFilters</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-comment">// 注册 @Component 对应的 AnnotationTypeFilter</span><br><span class="hljs-keyword">this</span>.includeFilters.add(<span class="hljs-keyword">new</span> AnnotationTypeFilter(Component.class));<br><br>ClassLoader cl = ClassPathScanningCandidateComponentProvider.class.getClassLoader();<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">this</span>.includeFilters.add(<span class="hljs-keyword">new</span> AnnotationTypeFilter(<br>((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="hljs-string">&quot;javax.annotation.ManagedBean&quot;</span>, cl)), <span class="hljs-keyword">false</span>));<br>logger.debug(<span class="hljs-string">&quot;JSR-250 &#x27;javax.annotation.ManagedBean&#x27; found and supported for component scanning&quot;</span>);<br>&#125;<br><span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br><span class="hljs-comment">// JSR-250 1.1 API (as included in Java EE 6) not available - simply skip.</span><br>&#125;<br><span class="hljs-keyword">try</span> &#123;<br><span class="hljs-keyword">this</span>.includeFilters.add(<span class="hljs-keyword">new</span> AnnotationTypeFilter(<br>((Class&lt;? extends Annotation&gt;) ClassUtils.forName(<span class="hljs-string">&quot;javax.inject.Named&quot;</span>, cl)), <span class="hljs-keyword">false</span>));<br>logger.debug(<span class="hljs-string">&quot;JSR-330 &#x27;javax.inject.Named&#x27; annotation found and supported for component scanning&quot;</span>);<br>&#125;<br><span class="hljs-keyword">catch</span> (ClassNotFoundException ex) &#123;<br><span class="hljs-comment">// JSR-330 API not available - simply skip.</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="12-MetadataReader、ClassMetadata、AnnotationMetadata"><a href="#12-MetadataReader、ClassMetadata、AnnotationMetadata" class="headerlink" title="12. MetadataReader、ClassMetadata、AnnotationMetadata"></a>12. MetadataReader、ClassMetadata、AnnotationMetadata</h3><p>在 Spring 中需要去解析类的信息，比如类名、类中的方法、类上的注解，这些都可以称之为类的元数据，所以 Spring 中对类的元数据做了抽象，并提供了一些工具类。</p><p>MetadataReader 表示类的元数据读取器，默认实现类为 <strong>SimpleMetadataReader</strong>。比如：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException </span>&#123;<br>    SimpleMetadataReaderFactory simpleMetadataReaderFactory = <span class="hljs-keyword">new</span> SimpleMetadataReaderFactory();<br>    <span class="hljs-comment">// 构造一个MetadataReader</span><br>    MetadataReader metadataReader = simpleMetadataReaderFactory.getMetadataReader(<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span>);<br>    <span class="hljs-comment">// 得到一个ClassMetadata，并获取了类名</span><br>    ClassMetadata classMetadata = metadataReader.getClassMetadata();<br>    System.out.println(classMetadata.getClassName());<br><br>    <span class="hljs-comment">// 获取一个AnnotationMetadata，并获取类上的注解信息</span><br>    AnnotationMetadata annotationMetadata = metadataReader.getAnnotationMetadata();<br>    <span class="hljs-keyword">for</span> (String annotationType : annotationMetadata.getAnnotationTypes()) &#123;<br>        System.out.println(annotationType);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>需要注意的是，SimpleMetadataReader去解析类时，使用的 <strong>ASM技术</strong>。</p><p>为什么要使用 ASM 技术，Spring 启动的时候需要去扫描，如果指定的包路径比较宽泛，那么扫描的类是非常多的，那如果在 Spring 启动时就把这些类全部加载进 JVM 了，这样不太好，所以使用了 ASM 技术。</p>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
      <tag>源码</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Spring——IOC的使用</title>
    <link href="/2022/04/18/Spring%E2%80%94%E2%80%94IOC%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
    <url>/2022/04/18/Spring%E2%80%94%E2%80%94IOC%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1-简介"><a href="#1-简介" class="headerlink" title="1. 简介"></a>1. 简介</h3><ul><li>spring 是一个轻量级的开源框架。 </li><li>spring 为了解决企业级应用开发的业务逻辑层和其他各层的耦合问题</li><li>spring 提供给了丰富的功能，这些功能都依赖于它的两个核心特性——IOC、AOP</li></ul><h4 id="1-1-spring-的优点"><a href="#1-1-spring-的优点" class="headerlink" title="1.1 spring 的优点"></a>1.1 spring 的优点</h4><ol><li>Spring 通过 DI、AOP 和消除样板代码来简化企业级开发</li><li>Spring 框架之外还存在一个构建在核心框架之上的庞大生态圈，它将 Spring 扩展到不同的领域，如  Web服务、REST、移动开发以及 NoSQL</li><li>低侵入式设计，代码的污染极低</li><li>独立于各种应用服务器，基于 Spring 框架的应用，可以真正实现 Write Once,Run Anywhere的承诺</li><li>Spring 的 IoC 容器降低了业务对象替换的复杂性，提高了组件之间的解耦</li><li>Spring 的 AOP 支持允许将一些通用任务如安全、事务、日志等进行集中式处理，从而提供了更好的复用</li><li>Spring 的 ORM 和 DAO 提供了与第三方持久层框架的的良好整合， 并简化了底层的数据库访问</li><li>Spring 的高度开放性，并不强制应用完全依赖于 Spring，开发者可自由选用 Spring 框架的部分或全部</li></ol><h4 id="1-2-spring-的模块划分"><a href="#1-2-spring-的模块划分" class="headerlink" title="1.2 spring 的模块划分"></a>1.2 spring 的模块划分</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/WPS%E5%9B%BE%E7%89%87%E6%89%93%E5%8D%B0_wps_doc_0.png"></p><ul><li>Test：Spring 的单元测试模块</li><li>Core Container：核心容器模块</li><li>AOP+Aspects：面向切面编程模块</li><li>Instrumentation：提供了class instrumentation支持和类加载器的实现来在特定的应用服务器上使用</li><li>Messaging：包括一系列的用来映射消息到方法的注解</li><li>Data Access/Integration：数据的获取/整合模块，包括了JDBC,ORM,OXM,JMS和事务模块 </li><li>Web：提供面向 web 整合特性</li></ul><h4 id="1-3-IOC"><a href="#1-3-IOC" class="headerlink" title="1.3 IOC"></a>1.3 IOC</h4><p>把创建和查找依赖对象的控制权交给 Spring 容器，由 Spring 容器进行注入、组合对象之间的关系。这样对象与对象之间是松耦合、功能可复用（减少对象的创建和内存消耗），使得程序的整个体系结构可维护性、灵活性、扩展性变高。 所谓IOC ，就简短一句话：对象由 spring 来创建、管理，装配！</p><p>IOC 和 DI 是从不同的角度描述的同一件事，IOC 是从容器的角度描述，而 DI 是从应用程序的角度来描述，也可以这样说，IOC 是依赖倒置原则的设计思想，而 DI 是具体的实现方式</p><h4 id="1-4-容器"><a href="#1-4-容器" class="headerlink" title="1.4 容器"></a>1.4 容器</h4><p>ApplicationContext 是 Spring IoC 容器实现的代表，它负责实例化、配置和组装 Bean。<br>容器通过读取配置元数据获取有关实例化、配置和组装哪些对象的说明 。配置元数据可以使用 XML、Java注解或J ava 代码来呈现。它允许你处理应用程序的对象与其他对象之间的互相依赖关系。 </p><ul><li>使用 xml 配置<br> 简单、直观 </li><li>基于注解的配置<br>@Compont(@serivce @controller @repository) @Autowride<br>Spring 2.5 支持基于注解的元数据配置</li><li>基于Java的配置:<br>@Confiration @Bean @Import 从 Spring 3.0 开始, 由 Spring JavaConfig 项目提供的功能已经成为Spring核心框架的一部分。因此可以使用 Java 配置来代替 XML 配置定义外部 bean.<br>从 spring4.0 开始支持 springboot1.0 之后 springboot 完全采用 javaConfig 的方式进行开发。</li></ul><h3 id="2-基于-XML-配置"><a href="#2-基于-XML-配置" class="headerlink" title="2. 基于 XML 配置"></a>2. 基于 XML 配置</h3><p>maven依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-context<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.2.21.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220418232434.png"></p><h4 id="2-1-配置-bean"><a href="#2-1-配置-bean" class="headerlink" title="2.1 配置 bean"></a>2.1 配置 bean</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">beans</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">       <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://www.springframework.org/schema/beans http://www.springframework.org/schema/beans/spring-beans.xsd&quot;</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    使用 name 可以设置别名</span><br><span class="hljs-comment">    使用空格或者，或者； 设置多个别名</span><br><span class="hljs-comment">    别名和 id 一样唯一确定一个 bean</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user2 user3,user4;user5&quot;</span>/&gt;</span><br><br>    <span class="hljs-comment">&lt;!--设置Bean的别名--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">alias</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">alias</span>=<span class="hljs-string">&quot;user6&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    使用 import 可以导入其他 spring 的 xml 配置文件</span><br><span class="hljs-comment">    导入配置中的 bean 和当前配置文件中的 bean 重名，则会覆盖当前配置文件中的 bean</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">import</span> <span class="hljs-attr">resource</span>=<span class="hljs-string">&quot;dao.xml&quot;</span>/&gt;</span><br>    <br><span class="hljs-tag">&lt;/<span class="hljs-name">beans</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        ApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;entity.xml&quot;</span>,<span class="hljs-string">&quot;services.xml&quot;</span>);<br>        User user = context.getBean(<span class="hljs-string">&quot;user&quot;</span>, User.class);<br>        System.out.println(user);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-实例化-Bean"><a href="#2-2-实例化-Bean" class="headerlink" title="2.2 实例化 Bean"></a>2.2 实例化 Bean</h4><ul><li>使用构造器实例化  <font color="red">默认</font><br> 如果不指定构造器参数，默认调用无参构造器实例化 Bean。(不指定且没有无参构造器编译报错)</li><li>使用静态工厂方法实例化<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createUserFactory&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> User <span class="hljs-title">createUserFactory</span><span class="hljs-params">()</span></span>&#123;<br>    User user = <span class="hljs-keyword">new</span> User();<br>    user.setName(<span class="hljs-string">&quot;debug&quot;</span>);<br>    <span class="hljs-keyword">return</span> user;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>使用实例工厂方法实例化<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.UserFactory&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;userFactory&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">factory-bean</span>=<span class="hljs-string">&quot;userFactory&quot;</span> <span class="hljs-attr">factory-method</span>=<span class="hljs-string">&quot;createUserFactory&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">UserFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span>  User <span class="hljs-title">createUserFactory</span><span class="hljs-params">()</span></span>&#123;<br>        User user = <span class="hljs-keyword">new</span> User();<br>        user.setName(<span class="hljs-string">&quot;debug&quot;</span>);<br>        <span class="hljs-keyword">return</span> user;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-依赖"><a href="#2-3-依赖" class="headerlink" title="2.3 依赖"></a>2.3 依赖</h4><h5 id="依赖注入"><a href="#依赖注入" class="headerlink" title="依赖注入"></a>依赖注入</h5></li></ul><p><strong>基于setter方法的依赖注入：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 基于 setter 方法的依赖注入</span><br><span class="hljs-comment">1. 属性必须声明了set 方法</span><br><span class="hljs-comment">2. name 是根据 set 方法的名字来的 比如方法名字是： setName ‐&gt; name=&quot;name&quot;</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debuggingWorld&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>基于构造函数的依赖注入：</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 基于构造函数的依赖注入</span><br><span class="hljs-comment"> 1. 将会调用自定义构造函数来实例化对象，就不会调用默认的无参构造函数</span><br><span class="hljs-comment"> 2. name 是根据构造函数的参数名来的， 比如：User(String idxx) ‐&gt; name=&quot;idxx&quot;</span><br><span class="hljs-comment"> 3. name 属性可以省略 但是要注意参数的位置</span><br><span class="hljs-comment"> 4. 如果非要把位置错开 可以使用 name 或者 index 或者 type</span><br><span class="hljs-comment"> 5. index 是下标 从 0 开始</span><br><span class="hljs-comment"> 6. type 在位置错开情况下只能在类型不一样的时候指定才有明显效果</span><br><span class="hljs-comment">  --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debuggingWorld&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">constructor-arg</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="依赖和配置的细节"><a href="#依赖和配置的细节" class="headerlink" title="依赖和配置的细节"></a>依赖和配置的细节</h5><ul><li>直接值（基本类型，String 等） </li><li>对其他 bean 的引用(装配) </li><li>内部 bean </li><li>集合</li><li>null 和空的字符串值</li><li>使用 p 命名空间简化基于 setter 属性注入</li><li>使用 c 命名空间简化基于构造函数的属性注入</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">p:teacher-ref</span>=<span class="hljs-string">&quot;teacher&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debuggingWorld&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!-- 设置 null 值 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">null</span>/&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br>    <span class="hljs-comment">&lt;!-- 当依赖其他bean: 内部 bean inner bean</span><br><span class="hljs-comment">    &lt;property name=&quot;teacher&quot;&gt;</span><br><span class="hljs-comment">        &lt;bean class=&quot;com.zth.debugSpring.entity.Teacher&quot;&gt;</span><br><span class="hljs-comment">            &lt;property name=&quot;name&quot; value=&quot;tony&quot;/&gt;</span><br><span class="hljs-comment">        &lt;/bean&gt;</span><br><span class="hljs-comment">    &lt;/property&gt;</span><br><span class="hljs-comment">    --&gt;</span><br><br>    <span class="hljs-comment">&lt;!--当依赖其他 bean: 引用外部 bean</span><br><span class="hljs-comment">    &lt;property name=&quot;teacher&quot; ref=&quot;teacher&quot;/&gt;</span><br><span class="hljs-comment">    --&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbies&quot;</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">list</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>抽烟<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>喝酒<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">value</span>&gt;</span>烫头<span class="hljs-tag">&lt;/<span class="hljs-name">value</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">list</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">property</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.Teacher&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teacher&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;tony&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-comment">&lt;!-- 可以使用 p 命名空间来简化基于 setter 属性注入 它不支持集合 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.Teacher&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teach2&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;法外狂徒&quot;</span>/&gt;</span><br><br><span class="hljs-comment">&lt;!-- 可以使用 c 命名空间来简化基于构造函数属性注入 它不支持集合 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;zhangSan&quot;</span> <span class="hljs-attr">c:name</span>=<span class="hljs-string">&quot;zhangSan&quot;</span> <span class="hljs-attr">c:age</span>=<span class="hljs-string">&quot;20&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--&lt;constructor-arg name=&quot;name&quot; value=&quot;zhangSan&quot;/&gt;</span><br><span class="hljs-comment">    &lt;constructor-arg name=&quot;age&quot; value=&quot;20&quot;/&gt;--&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="depends-on-属性"><a href="#depends-on-属性" class="headerlink" title="depends-on 属性"></a>depends-on 属性</h6><p>使用 depends‐on 可以设置先加载的 Bean，也就是控制 bean 的加载顺序。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">depends-on</span>=<span class="hljs-string">&quot;teacher&quot;</span> &gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debuggingWorld&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.Teacher&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teacher&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h6 id="懒加载-bean"><a href="#懒加载-bean" class="headerlink" title="懒加载 bean"></a>懒加载 bean</h6><p>使用 lazy‐init 设置懒加载<br>false（默认值）: 在 spring 容器创建的时候加载（实例化）<br>true: 在使用的时候(getBean)才会去加载（实例化）</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">lazy-init</span>=<span class="hljs-string">&quot;true&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;debuggingWorld&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;18&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h6 id="自动注入"><a href="#自动注入" class="headerlink" title="自动注入"></a>自动注入</h6><p>当一个对象中需要引用另外一个对象的时候，在之前的配置中我们都是通过 property 标签来进行手动配置的，其实在 spring 中还提供了一个非常强大的功能就是自动装配，可以按照指定的规则进行配置，配置的方式有以下几种： </p><ul><li>default/no：不自动装配 </li><li>byName：会根据属性 setxxx 方法去掉 set 的名字来自动匹配，如果找不到则装配 null</li><li>byType：按照类型进行装配，以属性的类型作为查找依据去容器中找到这个组件，如果有多个类型相同的 bean 对象，那么会报异常，如果找不到则装配 null</li><li>constructor：优先根据构造器参数名字来找， 如果名字没有匹配到根据类型来匹配， 如果类型匹 配到多个则不会自动注入。</li></ul><blockquote><p> 当根据类型匹配到多个 bean 时：</p><ol><li>通过将 autowire-candidate 属性设置为 false（放弃被注入的机会）</li><li>通过将 primary 属性设置为 true，将单个 bean 定义指定为主要候选项。</li></ol></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">autowire</span>=<span class="hljs-string">&quot;byType&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.Teacher&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;张三&quot;</span>  <span class="hljs-attr">autowire-candidate</span>=<span class="hljs-string">&quot;false&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.Teacher&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teacher2&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;lisi&quot;</span> <span class="hljs-attr">primary</span>=<span class="hljs-string">&quot;true&quot;</span>/&gt;</span><br><br></code></pre></td></tr></table></figure><p>Spring 自带的自动注入 @Bean 方式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Bean(autowire = Autowire.BY_NAME)</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> UserService <span class="hljs-title">user</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> UserService();<br>&#125;<br></code></pre></td></tr></table></figure><p>【注】Spring 自带的自动注入是在 Bean 实例化后注入的（需要 Setter 的支持），而     @Autowired、@Resource 是通过 BeanPostProcessor 实现的。</p><h4 id="2-4-Bean-的作用域"><a href="#2-4-Bean-的作用域" class="headerlink" title="2.4 Bean 的作用域"></a>2.4 Bean 的作用域</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220420211227.png"></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.Teacher&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;张三&quot;</span> <span class="hljs-attr">scope</span>=<span class="hljs-string">&quot;prototype&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><blockquote><p>默认情况下，低层的 Bean 工厂中只支持 singleton 及 prototype 两种类型的 Bean。当把 scope 设置成 request 及 session 时将会出现不能正确识别 Scope 的错误。这是因为普通的 Bean 工厂都没有注册新的 Scope。只有在 WebApplicationContext 中注册才注册了新类型的 Bean。</p></blockquote><h4 id="2-5-生命周期回调"><a href="#2-5-生命周期回调" class="headerlink" title="2.5 生命周期回调"></a>2.5 生命周期回调</h4><p>从 Spring 2.5 开始，有三种选择用于控制 bean 生命周期行为：</p><ul><li>InitializingBean 和 DisposableBean 回调接口</li><li>自定义 init() 和 destroy() 方法</li><li>@PostConstruct 和 @PreDestroy 注解</li></ul><p>如果 bean 配置了多个生命周期机制，而且每个机制都配置了不同的方法名字时，每个配置的方法会按照以下描述的顺序来执行。但是，如果配置了相同的名字， 例如初始化回调为init()，在不止一个生命周期机制配置为这个方法的情况下，这个方法只会执行一次。</p><p>为同一个 bean 配置的多个生命周期机制具有不同的初始化方法，如下所示:</p><ol><li>包含 @PostConstruct 注解的方法</li><li>在 InitializingBean 接口中的 afterPropertiesSet() 方法</li><li>自定义的 init() 方法</li><li>包含 @PreDestroy 注解的方法</li><li>在 DisposableBean 接口中的 destroy() 方法</li><li>自定义的 destroy() 方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">InitializingBean</span>, <span class="hljs-title">DisposableBean</span> </span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroy</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;User.destroy&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">afterPropertiesSet</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;User.afterPropertiesSet&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">initMethod</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;User.initMethod&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">destroyMethod</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;User.destroyMethod&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@PostConstruct</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">postConstruct</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;User.postConstruct&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-meta">@PreDestroy</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">preDestroy</span><span class="hljs-params">()</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;User.preDestroy&quot;</span>);<br>    &#125;<br><span class="hljs-comment">// ....</span><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">init-method</span>=<span class="hljs-string">&quot;initMethod&quot;</span> <span class="hljs-attr">destroy-method</span>=<span class="hljs-string">&quot;destroyMethod&quot;</span> /&gt;</span><br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ClassPathXmlApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;entity.xml&quot;</span>);<br>    User user = context.getBean(<span class="hljs-string">&quot;user&quot;</span>, User.class);<br>    context.close();<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220420223447.png"></p><h4 id="2-6-Aware接口"><a href="#2-6-Aware接口" class="headerlink" title="2.6 Aware接口"></a>2.6 Aware接口</h4><p>Aware 接口是为了能够感知到自身的一些属性。<br>比如实现了 ApplicationContextAware 接口的类，能够获取到 ApplicationContext，实现了 BeanFactoryAware 接口的类，能够获取到 BeanFactory 对象。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220422223033.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">User</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">BeanNameAware</span> </span>&#123;<br><br>    String beanName;<br>    String name;<br>    <br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setBeanName</span><span class="hljs-params">(String s)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.beanName = s;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-7-Bean-定义的继承"><a href="#2-7-Bean-定义的继承" class="headerlink" title="2.7 Bean 定义的继承"></a>2.7 Bean 定义的继承</h4><p>bean定义可以包含许多配置信息，包括构造函数参数，属性值和特定于容器的信息，例如初始化方法，静态工厂方法名称等。 子bean定义从父定义继承配置数据。 子定义可以覆盖某些值或根据需要添加其他值。 使用父子bean定义可以节省很多配置输入。 实际上，这是一种模板形式。</p><p>子bean如果没有指定class，它将使用父bean定义的class。但也可以进行重写。在后一种情况中，子bean必须与父bean兼容，也就是说，它必须接受父bean的属性值。</p><p>子bean定义从父类继承作用域、构造器参数、属性值和可重写的方法，除此之外，还可以增加新值。开发者指定任何作用域、初始化方法、销毁方法和/或者静态工厂方法设置都会覆盖相应的父bean设置。</p><p>剩下的设置会取子bean定义：依赖、自动注入模式、依赖检查、单例、延迟加载。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- </span><br><span class="hljs-comment">bean 的继承 一个 bean 继承另一个 bean </span><br><span class="hljs-comment">可以使用 parent 属性指定父类 bean</span><br><span class="hljs-comment">如果想让父类 bean 不能被实例化 abstract=&quot;true&quot;</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;张三&quot;</span> <span class="hljs-attr">p:age</span>=<span class="hljs-string">&quot;18&quot;</span> <span class="hljs-attr">abstract</span>=<span class="hljs-string">&quot;true&quot;</span> /&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.User&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;user2&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;lisi&quot;</span> <span class="hljs-attr">parent</span>=<span class="hljs-string">&quot;user&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-8-容器的扩展点"><a href="#2-8-容器的扩展点" class="headerlink" title="2.8 容器的扩展点"></a>2.8 容器的扩展点</h4><h5 id="使用-BeanPostProcessor-自定义-Bean"><a href="#使用-BeanPostProcessor-自定义-Bean" class="headerlink" title="使用 BeanPostProcessor 自定义 Bean"></a>使用 BeanPostProcessor 自定义 Bean</h5><h5 id="使用-BeanFactoryPostProcessor-自定义元数据配置"><a href="#使用-BeanFactoryPostProcessor-自定义元数据配置" class="headerlink" title="使用 BeanFactoryPostProcessor 自定义元数据配置"></a>使用 BeanFactoryPostProcessor 自定义元数据配置</h5><h5 id="使用-FactoryBean-自定义初始化逻辑"><a href="#使用-FactoryBean-自定义初始化逻辑" class="headerlink" title="使用 FactoryBean 自定义初始化逻辑"></a>使用 FactoryBean 自定义初始化逻辑</h5><h4 id="2-9-spring-创建第三方-bean-对象"><a href="#2-9-spring-创建第三方-bean-对象" class="headerlink" title="2.9 spring 创建第三方 bean 对象"></a>2.9 spring 创建第三方 bean 对象</h4><ol><li>导入数据库连接池的 pom 依赖<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml">   <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.alibaba<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>druid<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.1.21<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>mysql<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>mysql-connector-java<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>5.1.45<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>编写配置文件<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml">   <span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;root&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;mysql&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;jdbc:mysql://localhost:3306/debuggingworld?useSSL=false&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;com.mysql.jdbc.Driver&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li><li>测试<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> SQLException </span>&#123;<br>    ClassPathXmlApplicationContext context = <span class="hljs-keyword">new</span> ClassPathXmlApplicationContext(<span class="hljs-string">&quot;entity.xml&quot;</span>);<br>    DruidDataSource dataSource = context.getBean(<span class="hljs-string">&quot;dataSource&quot;</span>, DruidDataSource.class);<br>    System.out.println(dataSource);<br>    System.out.println(dataSource.getConnection());<br>&#125;<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-10-spring-引用外部配置文件"><a href="#2-10-spring-引用外部配置文件" class="headerlink" title="2.10 spring 引用外部配置文件"></a>2.10 spring 引用外部配置文件</h4><ol><li>在 resource 中添加 dbconfig.properties<figure class="highlight ini"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs ini"><span class="hljs-attr">name</span>=root<br><span class="hljs-attr">password</span>=mysql<br><span class="hljs-attr">url</span>=jdbc:mysql://localhost:<span class="hljs-number">3306</span>/debuggingworld?useSSL=<span class="hljs-literal">false</span><br><span class="hljs-attr">driverClassName</span>=com.mysql.jdbc.Driver<br></code></pre></td></tr></table></figure></li><li>编写配置文件<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml">   <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">加载外部配置文件</span><br><span class="hljs-comment">在加载外部依赖文件的时候需要 context 命名空间</span><br><span class="hljs-comment">--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">context:property-placeholder</span> <span class="hljs-attr">location</span>=<span class="hljs-string">&quot;classpath:dbConfig.properties&quot;</span>/&gt;</span><br><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;dataSource&quot;</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.alibaba.druid.pool.DruidDataSource&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;username&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;name&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;password&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;password&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;url&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;url&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;driverClassName&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;$&#123;driverClassName&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure></li></ol><h4 id="2-11-SpEL-的使用"><a href="#2-11-SpEL-的使用" class="headerlink" title="2.11 SpEL 的使用"></a>2.11 SpEL 的使用</h4><p>SpEL:Spring Expression Language,spring 的表达式语言，支持运行时查询操作对象使用 #{…} 作为语法规则，所有的大括号中的字符都认为是SpEL.</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.Teacher&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">p:name</span>=<span class="hljs-string">&quot;法外狂徒&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;com.zth.debugSpring.entity.Student&quot;</span> <span class="hljs-attr">id</span>=<span class="hljs-string">&quot;student&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--可以引用其他bean的某个属性值--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;name&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;#&#123;teacher.name&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--支持任何运算符--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;age&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;#&#123;9*2&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--‐引用其他bean--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;teacher&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;#&#123;teacher&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--调用静态方法--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;hobbies&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;#&#123;T(java.util.UUID).randomUUID().toString().substring(0,4)&#125;&quot;</span>/&gt;</span><br>    <span class="hljs-comment">&lt;!--调用非静态方法--&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">property</span> <span class="hljs-attr">name</span>=<span class="hljs-string">&quot;grade&quot;</span> <span class="hljs-attr">value</span>=<span class="hljs-string">&quot;#&#123;teacher.getName()&#125;&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">bean</span>&gt;</span><br></code></pre></td></tr></table></figure><h3 id="3-基于注解配置"><a href="#3-基于注解配置" class="headerlink" title="3. 基于注解配置"></a>3. 基于注解配置</h3><p>使用注解将一个类注册为 Bean 的步骤：</p><ol><li>设置包扫描</li><li>对应的类名上加对应的注解</li></ol><h4 id="3-1-类路径扫描"><a href="#3-1-类路径扫描" class="headerlink" title="3.1 类路径扫描"></a>3.1 类路径扫描</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">context:component-scan</span> <span class="hljs-attr">base-package</span>=<span class="hljs-string">&quot;com.zth.debugSpring&quot;</span> <span class="hljs-attr">use-default-filters</span>=<span class="hljs-string">&quot;false&quot;</span>&gt;</span><br>    <span class="hljs-comment">&lt;!--</span><br><span class="hljs-comment">    base-package：需要扫描的包</span><br><span class="hljs-comment">            排除扫描：exclude-filter</span><br><span class="hljs-comment">            包含扫描：include-filter</span><br><span class="hljs-comment">            type：1. annotation  默认 根据注解的完整限定名设置排除、包含</span><br><span class="hljs-comment">                  2. assignable 根据类的完整限定名设置排除、包含</span><br><span class="hljs-comment">                  3. aspectj 根据切面表达式设置排除、包含</span><br><span class="hljs-comment">                  4. regex 根据正则表达式设置排除、包含</span><br><span class="hljs-comment">                  5. custom 根据 org.springframework.core.type.filter.TypeFilter 接口设置排除、包含</span><br><span class="hljs-comment">            use-default-filters：默认 true ，默认包含扫描 @Component, @Repository,@Service, @Controller, 或 @Configuration</span><br><span class="hljs-comment">                                 false：不扫描 @Component, @Repository,@Service, @Controller, 或 @Configuration</span><br><span class="hljs-comment">    --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:include-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;regex&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;.*entity.*&quot;</span>/&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">context:exclude-filter</span> <span class="hljs-attr">type</span>=<span class="hljs-string">&quot;annotation&quot;</span> <span class="hljs-attr">expression</span>=<span class="hljs-string">&quot;org.springframework.stereotype.Repository&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">context:component-scan</span>&gt;</span><br></code></pre></td></tr></table></figure><p>等效于：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.zth.debugSpring&quot;,</span><br><span class="hljs-meta">        includeFilters = @ComponentScan.Filter(type = FilterType.REGEX,pattern = &quot;.*entity.*&quot;),</span><br><span class="hljs-meta">        excludeFilters = @ComponentScan.Filter(Repository.class))</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Config</span> </span>&#123;<br>    ……<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-注册-bean-到-IOC-容器中"><a href="#3-2-注册-bean-到-IOC-容器中" class="headerlink" title="3.2 注册 bean 到 IOC 容器中"></a>3.2 注册 bean 到 IOC 容器中</h4><p>如果想要将自定义的 bean 对象添加到 IOC 容器中，需要在类上添加某些注解。Spring 中包含 4 个主要的组件添加注解： </p><ul><li>@Controller：将控制层的类注册为 Bean</li><li>@Service：将业务逻辑层的类注册为 Bean</li><li>@Repository：将数据访问层的类注册为 Bean</li><li>@Component：将非三层的普通类注册为 Bean</li></ul><p>不是非要每个层对应相应的注解：</p><ol><li>增强可读性</li><li>利于 Spring 管理</li></ol><blockquote><p>注意：使用注解注册组件和使用配置文件注册组件是一样的，但是要注意：</p><ol><li>组件的 id 默认就是组件的类名首字符小写，也可在注解中修改</li><li>组件默认情况下都是单例的，如果需要配置多例模式的话，可以在注解下添加 @Scope注 解</li></ol></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Component(&quot;stu&quot;)</span><br><span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br>    String name;<br>    Integer age;<br>    Teacher teacher;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-Required-注解"><a href="#3-3-Required-注解" class="headerlink" title="3.3 @Required 注解"></a>3.3 @Required 注解</h4><p>在检查 javabean 中的某些属性是否一定有值的时候，可以通过 @Required 来实现。</p><p>@Required 注解只检查属性是否已经设置而不会测试属性是否非空</p><ol><li>只能在 setter 方法上加 @Required</li><li>如果任何带有 @Required 的属性未设置的话 将会抛出 BeanInitializationException 异常</li></ol><p>使用 @Required 时需要开启 RequiredAnnotationBeanPostProcessor。<br>开启方式：</p><ul><li>配置文件添加 &lt;context:annotation-config /&gt; 标签</li><li>注册 RequiredAnnotationBeanPostProcessor<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li></ul><blockquote><p><strong>&lt;context:annotation-config /&gt; 标签的作用</strong></p><p>当我们需要使用 BeanPostProcessor 时，直接在  Spring 配置文件中定义这些 Bean 显得比较笨拙.<br>例如：</p><ul><li>使用 @Autowired 注解，必须事先在 Spring 容器中声明 AutowiredAnnotationBeanPostProcessor 的 Bean：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.beans.factory.annotation.AutowiredAnnotationBeanPostProcessor &quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li><li>使用 @Required 注解，就必须声明 RequiredAnnotationBeanPostProcessor 的 Bean：<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">bean</span> <span class="hljs-attr">class</span>=<span class="hljs-string">&quot;org.springframework.beans.factory.annotation.RequiredAnnotationBeanPostProcessor&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure></li><li>使用 @Resource、@PostConstruct、@PreDestroy 等注解就必须声明 CommonAnnotationBeanPostProcessor  的 Bean；</li><li>使用 @PersistenceContext 注解，就必须声明 PersistenceAnnotationBeanPostProcessor 的 Bean。</li></ul><p>为了简化配置，Spring 为提供了一种极为方便注册这些BeanPostProcessor的方式，即使用 &lt;context:annotation-config/&gt;隐式地向 Spring容器注册 AutowiredAnnotationBeanPostProcessor、RequiredAnnotationBeanPostProcessor、CommonAnnotationBeanPostProcessor以及PersistenceAnnotationBeanPostProcessor 这 4 个 BeanPostProcessor。</p><p>&lt;context:component-scan base-package=”xx.xx”/&gt;  包含了自动注入上述Bean的功能，如果前者已存在 &lt;context:annotation-config/&gt; 可以省略。</p></blockquote><h4 id="3-4-自动注入"><a href="#3-4-自动注入" class="headerlink" title="3.4 自动注入"></a>3.4 自动注入</h4><h5 id="AutoWired"><a href="#AutoWired" class="headerlink" title="@AutoWired"></a>@AutoWired</h5><p>可以使用 JSR 330 的 @Inject 注解代替 @Autowired 注解</p><p><strong>使用位置：</strong></p><ol><li>可以用在构造器上<br>从 Spring  4.3 开始，如果目标 bean 仅定义一个构造函数，则不再需要 @Autowired 构造函数。如果有多个构造函数可用，则至少有一个必须注解 @Autowired 使容器知道它使用的是哪个</li><li>用在 setter 方法上</li><li>用于普通方法</li><li>用于字段</li><li>字段、setter方法、构造函数之间混用</li><li>用在数组上<br>注入全部指定类型 bean</li><li>用于集合类型<br>   注入全部指定类型 bean</li></ol><p><font color="red">使用 AutoWired  自动注入时，默认优先根据类型匹配，如果匹配到多个 bean 则会按照名字（添加 AutoWired 属性的名字） 匹配，如果名字没匹配到则会报错。</font></p><p>默认情况下，当没有候选的 bean 可用时，自动注入将会失败；可设置属性 required=false ，没有候选 bean 时忽略。也可用 @Required注解来代替。</p><p>@AutoWired 匹配到多个值解决办法：</p><ol><li>修改属性的名字来对应 bean 的名字</li><li>修改 bean 的名字来对应属性的名字  @Component(“name”)</li><li>通过 @Qualifier(“name”) 修改注入属性的名字</li><li>通过 @Primary 设置其中一个 bean 优先注入</li><li>使用泛型作为自动注入限定符</li></ol><h6 id="使用泛型作为自动装配限定符"><a href="#使用泛型作为自动装配限定符" class="headerlink" title="使用泛型作为自动装配限定符"></a>使用泛型作为自动装配限定符</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfiguration</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> StringStore <span class="hljs-title">stringStore</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> StringStore();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> IntegerStore <span class="hljs-title">integerStore</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> IntegerStore();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>假设上面的bean都实现了泛型接口,即 Store&lt;String&gt;和Store&lt;Integer&gt;,那么可以用@Autowire来注解Store 接口, 并将泛型用作限定符，如下例所示：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> Store&lt;String&gt; s1; <span class="hljs-comment">// &lt;String&gt; qualifier, injects the stringStore bean</span><br><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> Store&lt;Integer&gt; s2; <span class="hljs-comment">// &lt;Integer&gt; qualifier, injects the integerStore bean</span><br></code></pre></td></tr></table></figure><p>通用限定符也适用于自动装配列表，Map实例和数组。 以下示例自动装配通用List：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// Inject all Store beans as long as they have an &lt;Integer&gt; generic</span><br><span class="hljs-comment">// Store&lt;String&gt; beans will not appear in this list</span><br><span class="hljs-meta">@Autowired</span><br><span class="hljs-keyword">private</span> List&lt;Store&lt;Integer&gt;&gt; s;<br></code></pre></td></tr></table></figure><h5 id="Resource"><a href="#Resource" class="headerlink" title="@Resource"></a>@Resource</h5><p>@AutoWired 和 @Resource 的区别</p><ol><li>@AutoWired 是 spring 中提供的注解，@Resource 是 jdk 中定义的解，依靠的是 java 的标准</li><li>@AutoWired 优先按照类型进行装配，@Resource 优先按照名字进行匹配的，同时可以指定 name 属 性</li></ol><p><a href="https://blog.51cto.com/u_12012821/2510609">https://blog.51cto.com/u_12012821/2510609</a></p><h4 id="3-5-Value"><a href="#3-5-Value" class="headerlink" title="3.5 @Value"></a>3.5 @Value</h4><p>用于设置依赖注入的属性值</p><ol><li>硬编码值</li><li>${} 引用外部配置文件值</li><li>#{} spel 表达式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Value(&quot;$&#123;userName&#125;&quot;)</span><br>String name;<br>Integer age;<br><span class="hljs-meta">@Value(&quot;#&#123;teacher&#125;&quot;)</span><br>Teacher teachers;<br></code></pre></td></tr></table></figure><h4 id="3-6-JSR-330-标准注解"><a href="#3-6-JSR-330-标准注解" class="headerlink" title="3.6 JSR 330 标准注解"></a>3.6 JSR 330 标准注解</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220425231313.png"></p><p>注解依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>javax.inject<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>javax.inject<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@ManagedBean(&quot;lee&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Teacher</span> </span>&#123;<br>……<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Student</span> </span>&#123;<br><br>    Teacher teachers;<br>    <span class="hljs-meta">@Inject</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setTeachers</span><span class="hljs-params">(<span class="hljs-meta">@Named(&quot;lee&quot;)</span> Teacher teacher)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.teachers = teacher;<br>    &#125;<br>……<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-基于-java-配置"><a href="#4-基于-java-配置" class="headerlink" title="4. 基于 java 配置"></a>4. 基于 java 配置</h3><p>Spring 基于 Java 配置的核心内容是 @Configuration 注解的类和 @Bean 注解的方法。</p><p>@Bean 注解用于表明方法的实例化、配置和初始化都是由 Spring IoC 容器管理的新对象，@Bean注解扮演的角色与 XML 配置的 <beans/> 元素相同。可以在任意的Spring @Component 中使用 @Bean 注解方法 ，但大多数情况下，@Bean 是配合 @Configuration 使用的。</p><p>使用 @Configuration 注解类时，这个类的目的就是作为 bean 定义的地方。此外，@Configuration 类允许通过调用同一个类中的其他 @Bean 方法来定义 bean 间依赖关系，而不能使用 @Component 类声明 bean 间依赖关系。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">student</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Student(teacher());<br>    &#125;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Teacher <span class="hljs-title">teacher</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Teacher();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-1-使用-AnnotationConfigApplicationContext-初始化-Spring-容器"><a href="#4-1-使用-AnnotationConfigApplicationContext-初始化-Spring-容器" class="headerlink" title="4.1 使用 AnnotationConfigApplicationContext 初始化 Spring 容器"></a>4.1 使用 AnnotationConfigApplicationContext 初始化 Spring 容器</h5><p>AnnotationConfigApplicationContext 是在 Spring 3.0 中引入的， 不仅能解析 @Configuration 注解类 ,也能解析 @Component 注解的类和使用 JSR-330 注解的类。</p><ul><li>当使用 @Configuration 类作为输入时 @Configuration 类本身被注册为一个 bean 定义，类中所有声明的 @Bean 方法也被注册为 bean 定义。</li><li>当提供 @Component 和 JSR-330 类时，它们被注册为 bean 定义，并且假定在必要时在这些类中使用 DI 元数据，例如 @Autowired 或 @Inject。</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br>    Teacher bean = context.getBean(Teacher.class);<br>    System.out.println(bean);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="使用register-Class-lt-gt-…-编程构建容器"><a href="#使用register-Class-lt-gt-…-编程构建容器" class="headerlink" title="使用register(Class&lt;?&gt;…)编程构建容器"></a>使用register(Class&lt;?&gt;…)编程构建容器</h6><p>AnnotationConfigApplicationContext可以通过无参构造函数实例化，然后调用register() 方法进行配置。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();<br>    context.register(AppConfig.class);<br>    context.register(AppConfig1.class, AppConfig2.class);<br>    context.refresh();<br>    Teacher bean = context.getBean(Teacher.class);<br>    System.out.println(bean);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="使用-scan-String…-扫描组件"><a href="#使用-scan-String…-扫描组件" class="headerlink" title="使用 scan(String…) 扫描组件"></a>使用 scan(String…) 扫描组件</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@ComponentScan(basePackages = &quot;com.zth.debugSpring&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>@ComponentScan 用于启用组件扫描。和 XML 配置的 &lt;context:component-scan base-package=”com.zth.debugSpring”/&gt; 等价。<br>也可通过 AnnotationConfigApplicationContext 的 scan(String…) 方法开启扫描。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext();<br>    context.scan(<span class="hljs-string">&quot;com.zth.debugSpring&quot;</span>);<br>    context.refresh();<br>    Teacher bean = context.getBean(Teacher.class);<br>    System.out.println(bean);<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-2-Bean-注解"><a href="#4-2-Bean-注解" class="headerlink" title="4.2 @Bean 注解"></a>4.2 @Bean 注解</h5><p>@Bean 是一个方法级别的注解，与 XML 中的 <bean/>元素类似。注解支持 <bean/>提供的一些属性，例如  init-method  destroy-method  autowiring  name</p><p>可以在 @Configuration 类或 @Component 类中使用 @Bean 注解。</p><h6 id="声明一个Bean"><a href="#声明一个Bean" class="headerlink" title="声明一个Bean"></a>声明一个Bean</h6><p>要声明一个 bean，只需使用 @Bean 注解方法即可。使用此方法，将会在 ApplicationContext 内注册一个 bean，bean 的类型是方法的返回值类型。默认情况下， bean 名称将与方法名称相同。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferServiceImpl <span class="hljs-title">transferService</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Bean之间的依赖"><a href="#Bean之间的依赖" class="headerlink" title="Bean之间的依赖"></a>Bean之间的依赖</h6><ul><li>外部 Bean：直接在方法入参加入即可，不需要写 @Autowired（优先按类型查找，然后根据名字查找）</li><li>内部 Bean：直接调用放法即可（基于@Configuration）</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> TransferService <span class="hljs-title">transferService</span><span class="hljs-params">(AccountRepository accountRepository)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> TransferServiceImpl(accountRepository);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="生命周期回调"><a href="#生命周期回调" class="headerlink" title="生命周期回调"></a>生命周期回调</h6><p>@Bean 注解支持指定任意初始化和销毁回调方法，就像 bean 元素上的 Spring XML 的 init-method 和 destroy-method 属性一样。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanOne</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">init</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeanTwo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">cleanup</span><span class="hljs-params">()</span> </span>&#123;<br><br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean(initMethod = &quot;init&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanOne <span class="hljs-title">beanOne</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BeanOne();<br>    &#125;<br><br>    <span class="hljs-meta">@Bean(destroyMethod = &quot;cleanup&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BeanTwo <span class="hljs-title">beanTwo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BeanTwo();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="Bean-的作用域"><a href="#Bean-的作用域" class="headerlink" title="Bean 的作用域"></a>Bean 的作用域</h6><p>默认范围是 singleton 的，可以使用 @Scope 注解来覆盖。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyConfiguration</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-meta">@Scope(&quot;prototype&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Encryptor <span class="hljs-title">encryptor</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// ...</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>有作用域 bean 的依赖</strong></p><p>如果要将一个 bean 装配到比它作用域更广的 bean 时，那么应当选择注入 AOP 代理而不是使用带作用域的 bean。 也就是说需要注入代理对象，而这个代理对象既可以找到实际的 bean，还能够创建全新的 bean。</p><p><a href="https://github.com/DocsHome/spring-docs/blob/master/pages/core/IoC-container.md#%E6%9C%89%E4%BD%9C%E7%94%A8%E5%9F%9Fbean%E7%9A%84%E4%BE%9D%E8%B5%96">https://github.com/DocsHome/spring-docs/blob/master/pages/core/IoC-container.md#%E6%9C%89%E4%BD%9C%E7%94%A8%E5%9F%9Fbean%E7%9A%84%E4%BE%9D%E8%B5%96</a></p><p>使用 XML 配置时创建此类代理的最简单方法是  &lt;aop:scoped-proxy/&gt;元素。 使用 @Scope 注解在Java中配置 bean 提供了与 proxyMode 属性的等效支持。 默认值为无代理（ScopedProxyMode.NO），但您可以指定 ScopedProxyMode.TARGET_CLASS（具体类） 或 ScopedProxyMode.INTERFACES（实现了接口）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Component</span>  <br>    <span class="hljs-meta">@Scope</span>&#123;  <br> Value=WebApplicationContext.SCOPE_SISSION,<br>         proxyMode=ScopeProxyMode.INTERFACES&#125;<br>    <span class="hljs-function">Public ShoppingCart  <span class="hljs-title">cart</span><span class="hljs-params">()</span></span>&#123;<br>      <br>    &#125;  <br><br><span class="hljs-meta">@Component</span>  <br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StoreService</span></span>&#123;  <br>    <span class="hljs-meta">@Autowired</span> <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setShoppingCart</span><span class="hljs-params">(ShoppingCart shoppingCart)</span></span>&#123;<br>        <span class="hljs-keyword">this</span>.shoppingCart=shoppingCart;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="自定义-Bean-命名"><a href="#自定义-Bean-命名" class="headerlink" title="自定义 Bean 命名"></a>自定义 Bean 命名</h6><p>默认情况下，配置类使用 @Bean 方法的名称作为结果 bean 的名称。 但是，可以使用name属性覆盖此功能。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean(name = &quot;myThing&quot;)</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Thing <span class="hljs-title">thing</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Thing();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="4-3-引入外部属性资源文件"><a href="#4-3-引入外部属性资源文件" class="headerlink" title="4.3 引入外部属性资源文件"></a>4.3 引入外部属性资源文件</h5><p>@PropertySource</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@PropertySource(&quot;classpath:dbConfig.properties&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Value(&quot;$&#123;name&#125;&quot;)</span><br>    String userName;<br>    <span class="hljs-meta">@Value(&quot;$&#123;password&#125;&quot;)</span><br>    String password;<br>    <span class="hljs-meta">@Value(&quot;$&#123;url&#125;&quot;)</span><br>    String url;<br>    <span class="hljs-meta">@Value(&quot;$&#123;driverClassName&#125;&quot;)</span><br>    String driverClassName;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> DruidDataSource <span class="hljs-title">dataSource</span><span class="hljs-params">()</span> </span>&#123;<br>        DruidDataSource dataSource = <span class="hljs-keyword">new</span> DruidDataSource();<br>        dataSource.setUsername(userName);<br>        dataSource.setPassword(password);<br>        dataSource.setUrl(url);<br>        dataSource.setDriverClassName(driverClassName);<br>        <span class="hljs-keyword">return</span> dataSource;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-Import-注解"><a href="#4-3-Import-注解" class="headerlink" title="4.3 @Import 注解"></a>4.3 @Import 注解</h4><h6 id="导入其他配置类"><a href="#导入其他配置类" class="headerlink" title="导入其他配置类"></a>导入其他配置类</h6>  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java">  <span class="hljs-meta">@Configuration</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigA</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> A <span class="hljs-title">a</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> A();<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(ConfigA.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConfigB</span> </span>&#123;<br><br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> B <span class="hljs-title">b</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> B();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>在实例化上下文时，不需要同时指定 ConfigA.class 和 ConfigB.class，只需要显式提供 ConfigB：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    ApplicationContext ctx = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(ConfigB.class);<br><br>    A a = ctx.getBean(A.class);<br>    B b = ctx.getBean(B.class);<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="导入类注册为-Bean"><a href="#导入类注册为-Bean" class="headerlink" title="导入类注册为 Bean"></a>导入类注册为 Bean</h6><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(&#123;Teacher.class&#125;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>    <span class="hljs-meta">@Bean</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Student <span class="hljs-title">student</span><span class="hljs-params">(Teacher teacher)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Student( teacher);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="导入-ImportSelector-实现类"><a href="#导入-ImportSelector-实现类" class="headerlink" title="导入 ImportSelector 实现类"></a>导入 ImportSelector 实现类</h6><p>可以注册多个 Bean，必须根据类型获取</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImportSelector</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportSelector</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-keyword">public</span> String[] selectImports(AnnotationMetadata annotationMetadata) &#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> String[]&#123;<span class="hljs-string">&quot;com.zth.debugSpring.entity.Student&quot;</span>, Teacher.class.getName()&#125;;<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(MyImportSelector.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br>        Teacher bean = context.getBean(Teacher.class);<br>        System.out.println(bean);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h6 id="导入-ImportBeanDefinitionRegistrar-实现类"><a href="#导入-ImportBeanDefinitionRegistrar-实现类" class="headerlink" title="导入 ImportBeanDefinitionRegistrar 实现类"></a>导入 ImportBeanDefinitionRegistrar 实现类</h6><p>可以注册多个 Bean 定义</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyImportBeanDefinitionRegistrar</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ImportBeanDefinitionRegistrar</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">registerBeanDefinitions</span><span class="hljs-params">(AnnotationMetadata importingClassMetadata, BeanDefinitionRegistry registry)</span> </span>&#123;<br>        GenericBeanDefinition beanDefinition = <span class="hljs-keyword">new</span> GenericBeanDefinition();<br>        beanDefinition.setBeanClass(Teacher.class);<br>        registry.registerBeanDefinition(<span class="hljs-string">&quot;teacher&quot;</span>,beanDefinition);<br>    &#125;<br>&#125;<br><br><span class="hljs-meta">@Configuration</span><br><span class="hljs-meta">@Import(MyImportBeanDefinitionRegistrar.class)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AppConfig</span> </span>&#123;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">App</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AnnotationConfigApplicationContext context = <span class="hljs-keyword">new</span> AnnotationConfigApplicationContext(AppConfig.class);<br>        Teacher bean = context.getBean(<span class="hljs-string">&quot;teacher&quot;</span>,Teacher.class);<br>        System.out.println(bean);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Spring</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Spring</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——原型模式</title>
    <link href="/2022/04/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/04/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8E%9F%E5%9E%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>用一个已经创建的实例作为原型，通过复制该原型对象来创建一个和原型相同或相似的新对象。在这里，原型实例指定了要创建的对象的种类。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220410223155.png"></p><p><strong>优点：</strong></p><ol><li>可以不耦合具体类的情况下克隆对象 </li><li>避免重复的初始化代码 </li><li>更方便的构建复杂对象</li></ol><p><strong>应用场景：</strong></p><ul><li>对象之间相同或相似，即只是个别的几个属性不同的时候。</li><li>创建对象成本较大，例如初始化时间长，占用CPU太多，或者占用网络资源太多等，需要优化资源。</li><li>创建一个对象需要繁琐的数据准备或访问权限等，需要提高性能或者提高安全性。</li><li>系统中大量使用该类对象，且各个调用者都需要给它的属性重新赋值。</li></ul><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">PrototypeTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br><br>        BaseInfo baseInfo = <span class="hljs-keyword">new</span> BaseInfo(<span class="hljs-string">&quot;debuggingWorld&quot;</span>);<br>        Product product = <span class="hljs-keyword">new</span> Product(<span class="hljs-string">&quot;part1&quot;</span>, <span class="hljs-string">&quot;part2&quot;</span>, baseInfo);<br><br>        Product clone = product.clone();<br>        System.out.println(<span class="hljs-string">&quot;original: &quot;</span> + product);<br>        System.out.println(<span class="hljs-string">&quot;clone:  &quot;</span> + clone);<br>        product.getBaseInfo().setCompanyName(<span class="hljs-string">&quot;xxxx&quot;</span>);<br>        System.out.println(<span class="hljs-string">&quot;original: &quot;</span> + product);<br>        System.out.println(<span class="hljs-string">&quot;clone:  &quot;</span> + clone);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BaseInfo</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String companyName;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BaseInfo</span><span class="hljs-params">(String companyName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.companyName = companyName;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setCompanyName</span><span class="hljs-params">(String companyName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.companyName = companyName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> BaseInfo <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-keyword">return</span> ((BaseInfo) <span class="hljs-keyword">super</span>.clone());<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> hashCode() + <span class="hljs-string">&quot; ]BaseInfo&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;companyName=&#x27;&quot;</span> + companyName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Cloneable</span>, <span class="hljs-title">Serializable</span> </span>&#123;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">6772397503790075095L</span>;<br><br>    <span class="hljs-keyword">private</span> String part1;<br>    <span class="hljs-keyword">private</span> String part2;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 自定义数据类型</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-keyword">private</span> BaseInfo baseInfo;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Product</span><span class="hljs-params">(String part1, String part2, BaseInfo baseInfo)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.part1 = part1;<br>        <span class="hljs-keyword">this</span>.part2 = part2;<br>        <span class="hljs-keyword">this</span>.baseInfo = baseInfo;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BaseInfo <span class="hljs-title">getBaseInfo</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> baseInfo;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> Product <span class="hljs-title">clone</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> CloneNotSupportedException </span>&#123;<br>        <span class="hljs-comment">// 利用jvm克隆机制完成的深拷贝</span><br><span class="hljs-comment">//        Product productClone= ((Product) super.clone());</span><br><span class="hljs-comment">//        BaseInfo clone1=this.baseInfo.clone();</span><br><span class="hljs-comment">//        productClone.setBaseInfo( clone1 );</span><br><span class="hljs-comment">//        return productClone ;</span><br><br>        <span class="hljs-comment">// 序列化方式实现的深拷贝</span><br>        ByteArrayOutputStream byteArrayOutputStream = <span class="hljs-keyword">new</span> ByteArrayOutputStream();<br><br>        <span class="hljs-keyword">try</span> (ObjectOutputStream oos = <span class="hljs-keyword">new</span> ObjectOutputStream(byteArrayOutputStream)) &#123;<br>            oos.writeObject(<span class="hljs-keyword">this</span>);<br>        &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        ByteArrayInputStream byteArrayInputStream = <span class="hljs-keyword">new</span> ByteArrayInputStream(byteArrayOutputStream.toByteArray());<br><br>        <span class="hljs-keyword">try</span> (ObjectInputStream ois = <span class="hljs-keyword">new</span> ObjectInputStream(byteArrayInputStream)) &#123;<br>            <span class="hljs-keyword">return</span> ((Product) ois.readObject());<br>        &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>            e.printStackTrace();<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Product&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;part1=&#x27;&quot;</span> + part1 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, part2=&#x27;&quot;</span> + part2 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, baseInfo=&quot;</span> + baseInfo +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p> 如果对应的类中的字段为 8 种原生数据类型，或者 8 种原生数据类型的包装类型，或 String，BigInteger 则只需要实现 Cloneable 这个接口且覆盖 Object.clone 方法，即可利用 jvm 的克隆机制，完成对象的拷贝。 这种方式即是浅拷贝， 如果对应的类中数据为自定义数据类型，或者其他可变的数据类型（如 Date，或者其他对象类型），要借助 jvm 的克隆机制完成数据的拷贝，则需要实现所有的对象字段的遍历拷贝，即是深拷贝。</p></blockquote><h3 id="3-jdk-中的应用"><a href="#3-jdk-中的应用" class="headerlink" title="3.  jdk 中的应用"></a>3.  jdk 中的应用</h3><p>java.util.ArrayList</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> Object <span class="hljs-title">clone</span><span class="hljs-params">()</span> </span>&#123;<br><span class="hljs-keyword">try</span> &#123;<br>ArrayList&lt;?&gt; v = (ArrayList&lt;?&gt;) <span class="hljs-keyword">super</span>.clone();<br>v.elementData = Arrays.copyOf(elementData, size);<br>v.modCount = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">return</span> v;<br>&#125; <span class="hljs-keyword">catch</span> (CloneNotSupportedException e) &#123;<br><span class="hljs-comment">// this shouldn&#x27;t happen, since we are Cloneable</span><br><span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> InternalError(e);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-Spring-中的应用"><a href="#4-Spring-中的应用" class="headerlink" title="4. Spring 中的应用"></a>4. Spring 中的应用</h3><p><a href="https://blog.csdn.net/Woo_home/article/details/104359232">https://blog.csdn.net/Woo_home/article/details/104359232</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>创建型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——单例模式</title>
    <link href="/2022/04/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/04/09/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>保证一个类只有一个实例，并且提供一个全局访问点。</p><p><strong>优点：</strong></p><ul><li>保证内存里只有一个实例，减少了内存的开销。</li><li>避免对资源的多重占用。</li><li>设置全局访问点，可以优化和共享资源的访问。</li></ul><p><strong>缺点：</strong></p><ul><li>单例模式一般没有接口，扩展困难。违背开闭原则。</li><li>单例模式的功能代码通常写在一个类中，如果功能设计不合理，则很容易违背单一职责原则。</li></ul><p><strong>场景:</strong>  重量级的对象，不需要多个实例，如线程池，数据库连接池</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220409142054.png"></p><h3 id="2-实现"><a href="#2-实现" class="headerlink" title="2. 实现"></a>2. 实现</h3><h4 id="2-1-懒汉模式"><a href="#2-1-懒汉模式" class="headerlink" title="2.1 懒汉模式"></a>2.1 懒汉模式</h4><p>延迟加载， 只有在真正使用的时候，才开始实例化。 </p><ol><li>线程安全问题</li><li>double check 加锁优化</li><li>编译器(JIT)、CPU 有可能对指令进行重排序，导致使用到尚未初始化的实例，可以通过添加 volatile 关键字进行修饰，防止指令重排。</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LazySingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">volatile</span> <span class="hljs-keyword">static</span> LazySingleton instance;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">LazySingleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> LazySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == instance)&#123;<br>            <span class="hljs-keyword">synchronized</span> (LazySingleton.class)&#123;<br>                <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == instance)&#123;<br>                    instance = <span class="hljs-keyword">new</span> LazySingleton();<br>                &#125;<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-饿汉模式"><a href="#2-2-饿汉模式" class="headerlink" title="2.2 饿汉模式"></a>2.2 饿汉模式</h4><p>类加载的初始化阶段就完成了实例的初始化 。<br>本质上就是借助于 jvm 类加载机制，保证实例的唯一性（初始化过程只会执行一次）及线程安 全（JVM 以同步的形式来完成类加载的整个过程）。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HungrySingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> HungrySingleton instance = <span class="hljs-keyword">new</span> HungrySingleton();<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">HungrySingleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> HungrySingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-静态内部类"><a href="#2-3-静态内部类" class="headerlink" title="2.3 静态内部类"></a>2.3 静态内部类</h4><ol><li>本质上是利用类的加载机制来保证线程安全</li><li>只有在实际使用的时候，才会触发类的初始化，所以也是懒加载的一 种形式</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClassSingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClassHolder</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InnerClassSingleton instance = <span class="hljs-keyword">new</span> InnerClassSingleton();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">InnerClassSingleton</span><span class="hljs-params">()</span></span>&#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InnerClassSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> InnerClassHolder.instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-反射攻击实例"><a href="#2-4-反射攻击实例" class="headerlink" title="2.4 反射攻击实例"></a>2.4 反射攻击实例</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">Constructor&lt;InnerClassSingleton&gt; declaredConstructors = InnerClassSingleton.class.getDeclaredConstructor();<br>declaredConstructors.setAccessible(<span class="hljs-keyword">true</span>);<br>InnerClassSingleton innerClassSingleton = declaredConstructors.newInstance();<br><span class="hljs-comment">// false</span><br>System.out.println(innerClassSingleton == InnerClassSingleton.getInstance());<br></code></pre></td></tr></table></figure><p><strong>静态内部类防止反射破坏：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClassSingleton</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClassHolder</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InnerClassSingleton instance = <span class="hljs-keyword">new</span> InnerClassSingleton();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">InnerClassSingleton</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != InnerClassHolder.instance)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot; 单例不允许多个实例 &quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InnerClassSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> InnerClassHolder.instance;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-5-反序列化攻击"><a href="#2-5-反序列化攻击" class="headerlink" title="2.5 反序列化攻击"></a>2.5 反序列化攻击</h4><p>可以利用指定方法来替换从反序列化流中的数据：</p><blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">ANY‐ACCESS‐<span class="hljs-function">MODIFIER Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ObjectStreamException</span>;<br></code></pre></td></tr></table></figure></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClassSingleton</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Serializable</span> </span>&#123;<br>    <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">42L</span>;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">InnerClassHolder</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> InnerClassSingleton instance = <span class="hljs-keyword">new</span> InnerClassSingleton();<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">InnerClassSingleton</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != InnerClassHolder.instance)&#123;<br>            <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> RuntimeException(<span class="hljs-string">&quot; 单例不允许多个实例 &quot;</span>);<br>        &#125;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> InnerClassSingleton <span class="hljs-title">getInstance</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> InnerClassHolder.instance;<br>    &#125;<br><br>    <span class="hljs-function">Object <span class="hljs-title">readResolve</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> ObjectStreamException </span>&#123;<br>        <span class="hljs-keyword">return</span> InnerClassSingleton.getInstance();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>    InnerClassSingleton instance = InnerClassSingleton.getInstance();<br><br>    ObjectOutputStream outputStream = <span class="hljs-keyword">new</span> ObjectOutputStream(<span class="hljs-keyword">new</span> FileOutputStream(<span class="hljs-string">&quot;testObject&quot;</span>));<br>    outputStream.writeObject(instance);<br>    outputStream.close();<br><br>    ObjectInputStream inputStream = <span class="hljs-keyword">new</span> ObjectInputStream(<span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;testObject&quot;</span>));<br>    InnerClassSingleton serializedObject = ((InnerClassSingleton) inputStream.readObject());<br>    inputStream.close();<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 添加 readResolve() 前 false</span><br><span class="hljs-comment">     * 添加后为 true</span><br><span class="hljs-comment">     */</span><br>    System.out.println(serializedObject == instance);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-6-枚举类型"><a href="#2-6-枚举类型" class="headerlink" title="2.6 枚举类型"></a>2.6 枚举类型</h4><ol><li>天然不支持反射创建对应的实例，且有自己的反序列化机制 </li><li>利用类加载机制保证线程安全</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">enum</span> <span class="hljs-title">EnumSingleton</span> </span>&#123;<br>    INSTANCE;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-keyword">this</span>.hashCode());<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-jdk-中的应用"><a href="#3-jdk-中的应用" class="headerlink" title="3. jdk 中的应用"></a>3. jdk 中的应用</h3><p>java.lang.Runtime</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Runtime</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> Runtime currentRuntime = <span class="hljs-keyword">new</span> Runtime();<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Runtime <span class="hljs-title">getRuntime</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> currentRuntime;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">Runtime</span><span class="hljs-params">()</span> </span>&#123;&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-Spring-中的应用"><a href="#4-Spring-中的应用" class="headerlink" title="4. Spring 中的应用"></a>4. Spring 中的应用</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.aop.framework.ProxyFactoryBean<br>org.springframework.beans.factory.support.DefaultSingletonBeanRegistry <br>org.springframework.core.ReactiveAdapterRegistry<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>创建型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——抽象工厂模式</title>
    <link href="/2022/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/04/05/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%8A%BD%E8%B1%A1%E5%B7%A5%E5%8E%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1.模式定义"></a>1.模式定义</h3><p>提供一个创建一系列相关或互相依赖对象的接口，而无需指定它们具体的类。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220405163414.png"></p><ul><li>抽象工厂：声明了创建抽象产品对象的操作接口。</li><li>具体产品工厂：实现了抽象工厂的接口，负责创建产品对象。</li><li>产品抽象类或接口：定义一类产品对象的接口。</li><li>具体产品实现：定义一个将被相应具体工厂创建的产品对象。</li></ul><p><strong>优缺点:</strong><br>增加分组非常简单，分组中的产品扩展非常困难。</p><p><strong>使用场景：</strong></p><ol><li>一个系统要独立于它的产品的创建、组合和表示时；</li><li>一个系统要由多个产品系列中的一个来配置时；</li><li>要强调一系列相关的产品对象的设计以便进行联合使用时；</li><li>当你提供一个产品类库，而只想显示它们的接口而不是实现时；</li></ol><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220405165324.png"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.zth.designPatterns.abstractfactory;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 猫和少年</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2022-04-05 16:45</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Slogan</span> 才疏学浅，少年登科；满腹经纶，白发不第</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactoryTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        IFactory dellFactory = <span class="hljs-keyword">new</span> DellFactory();<br>        IFactory HPFactory = <span class="hljs-keyword">new</span> HPFactory();<br>        Keyboard dellKeyboard = dellFactory.createKeyboard();<br>        Monitor monitor = HPFactory.createMonitor();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Keyboard</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DellKeyboard</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Keyboard</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//...dell...dell;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HPKeyboard</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Keyboard</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//...HP...HP;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Monitor</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DellMonitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Monitor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//...dell...dell;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HPMonitor</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Monitor</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">play</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//...HP...HP;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">MainFrame</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DellMainFrame</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MainFrame</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//...dell...dell;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HPMainFrame</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">MainFrame</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">//...HP...HP;</span><br>    &#125;<br>&#125;<br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * 工厂类</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">IFactory</span> </span>&#123;<br>    <span class="hljs-function">MainFrame <span class="hljs-title">createMainFrame</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Monitor <span class="hljs-title">createMonitor</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function">Keyboard <span class="hljs-title">createKeyboard</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DellFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IFactory</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MainFrame <span class="hljs-title">createMainFrame</span><span class="hljs-params">()</span> </span>&#123;<br>        MainFrame mainFrame = <span class="hljs-keyword">new</span> DellMainFrame();<br>        <span class="hljs-comment">//...造一个Dell主机;</span><br>        <span class="hljs-keyword">return</span> mainFrame;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Monitor <span class="hljs-title">createMonitor</span><span class="hljs-params">()</span> </span>&#123;<br>        Monitor monitor = <span class="hljs-keyword">new</span> DellMonitor();<br>        <span class="hljs-comment">//...造一个Dell显示器;</span><br>        <span class="hljs-keyword">return</span> monitor;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Keyboard <span class="hljs-title">createKeyboard</span><span class="hljs-params">()</span> </span>&#123;<br>        Keyboard keyboard = <span class="hljs-keyword">new</span> DellKeyboard();<br>        <span class="hljs-comment">//...造一个Dell键盘;</span><br>        <span class="hljs-keyword">return</span> keyboard;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">HPFactory</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">IFactory</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> MainFrame <span class="hljs-title">createMainFrame</span><span class="hljs-params">()</span> </span>&#123;<br>        MainFrame mainFrame = <span class="hljs-keyword">new</span> HPMainFrame();<br>        <span class="hljs-comment">//...造一个HP主机;</span><br>        <span class="hljs-keyword">return</span> mainFrame;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Monitor <span class="hljs-title">createMonitor</span><span class="hljs-params">()</span> </span>&#123;<br>        Monitor monitor = <span class="hljs-keyword">new</span> HPMonitor();<br>        <span class="hljs-comment">//...造一个HP显示器;</span><br>        <span class="hljs-keyword">return</span> monitor;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Keyboard <span class="hljs-title">createKeyboard</span><span class="hljs-params">()</span> </span>&#123;<br>        Keyboard keyboard = <span class="hljs-keyword">new</span> HPKeyboard();<br>        <span class="hljs-comment">//...造一个HP键盘;</span><br>        <span class="hljs-keyword">return</span> keyboard;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-Spring-中的应用"><a href="#3-Spring-中的应用" class="headerlink" title="3. Spring 中的应用"></a>3. Spring 中的应用</h3><p>在 Spring 中，BeanFactory 是用于管理 Bean 的一个工厂，所有工厂都是 BeanFactory 的子类。这样我们可以通过 IOC 容器来管理访问 Bean，根据不同的策略调用 getBean() 方法，从而获得具体对象。</p><p>其中，BeanFactory 接口如下：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">BeanFactory</span> </span>&#123;<br>    String FACTORY_BEAN_PREFIX = <span class="hljs-string">&quot;&amp;&quot;</span>;<br>    <span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(String name, <span class="hljs-meta">@Nullable</span> Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>    <span class="hljs-function">Object <span class="hljs-title">getBean</span><span class="hljs-params">(String name, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>    &lt;T&gt; <span class="hljs-function">T <span class="hljs-title">getBean</span><span class="hljs-params">(Class&lt;T&gt; requiredType, Object... args)</span> <span class="hljs-keyword">throws</span> BeansException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">containsBean</span><span class="hljs-params">(String name)</span></span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isSingleton</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isPrototype</span><span class="hljs-params">(String name)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, ResolvableType typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">isTypeMatch</span><span class="hljs-params">(String name, <span class="hljs-meta">@Nullable</span> Class&lt;?&gt; typeToMatch)</span> <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException</span>;<br>    <span class="hljs-meta">@Nullable</span><br>    Class&lt;?&gt; getType(String name) <span class="hljs-keyword">throws</span> NoSuchBeanDefinitionException;<br>    String[] getAliases(String name);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>BeanFactory 的子类主要有 ClassPathXmlApplicationContext、XmlWebApplicationContext、StaticWebApplicationContext、StaticApplicationContext。在 Spring 中，DefaultListableBeanFactory 实现了所有工厂的公共逻辑。</p></blockquote><h3 id="4-JDK-中的应用"><a href="#4-JDK-中的应用" class="headerlink" title="4. JDK 中的应用"></a>4. JDK 中的应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">java.sql.Connection<br>java.sql.Driver<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>创建型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——工厂方法模式</title>
    <link href="/2022/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/30/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%B7%A5%E5%8E%82%E6%96%B9%E6%B3%95%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>定义一个用于创建对象的接口，让子类决定实例化哪一个类。工厂方法使得一个类的实例化延迟到子类</p><p><strong>主要优点：</strong></p><ol><li>将具体产品和创建者解耦</li><li>符合单一职责原则 </li><li>符合开闭原则</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220324231454.png"></p><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FactoryMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AbstractFactory factory = <span class="hljs-keyword">new</span> ConcreteProductA();<br>        Product product = factory.createProduct();<br>        product.method();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Product</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductA</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ProductA.method executed. &quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ProductB</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Product</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;ProductB.method executed. &quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span></span>;<br>    <span class="hljs-function">Product <span class="hljs-title">getObject</span><span class="hljs-params">()</span> </span>&#123;<br>        Product product = createProduct();<br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-comment">// ...</span><br>        <span class="hljs-keyword">return</span> product;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProductA</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function">Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductA();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ConcreteProductB</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractFactory</span> </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function">Product <span class="hljs-title">createProduct</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ProductB();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-jdk-中的应用"><a href="#3-jdk-中的应用" class="headerlink" title="3. jdk 中的应用"></a>3. jdk 中的应用</h3><p>Collections.iterator() 方法</p><h3 id="4-Spring-中的应用"><a href="#4-Spring-中的应用" class="headerlink" title="4. Spring 中的应用"></a>4. Spring 中的应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractFactoryBean</span>&lt;<span class="hljs-title">T</span>&gt;</span><br><span class="hljs-class"><span class="hljs-keyword">implements</span> <span class="hljs-title">FactoryBean</span>&lt;<span class="hljs-title">T</span>&gt;, <span class="hljs-title">BeanClassLoaderAware</span>, <span class="hljs-title">BeanFactoryAware</span>, <span class="hljs-title">InitializingBean</span>, <span class="hljs-title">DisposableBean</span> </span>&#123;<br><br><br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">final</span> T <span class="hljs-title">getObject</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><span class="hljs-keyword">if</span> (isSingleton()) &#123;<br><span class="hljs-keyword">return</span> (<span class="hljs-keyword">this</span>.initialized ? <span class="hljs-keyword">this</span>.singletonInstance : getEarlySingletonInstance());<br>&#125;<br><span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> createInstance();<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">abstract</span> T <span class="hljs-title">createInstance</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception</span>;<br><br>    ....<br><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220330224551.png"></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>创建型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——建造者模</title>
    <link href="/2022/03/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1/"/>
    <url>/2022/03/26/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%BB%BA%E9%80%A0%E8%80%85%E6%A8%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>指将一个复杂对象的构造与它的表示分离，使同样的构建过程可以创建不同的表示。</p><p><strong>优点：</strong></p><ol><li>封装性好，构建和表示分离。</li><li>扩展性好，各个具体的建造者相互独立，有利于系统的解耦。</li><li>客户端不必知道产品内部组成的细节，建造者可以对创建过程逐步细化，而不对其它模块产生任何影响，便于控制细节风险。</li></ol><p>【注】建造者模式和工厂模式的关注点不同：建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程</p><p><strong>应用场景：</strong> </p><ol><li>需要生成的对象具有复杂的内部结构 </li><li>需要生成的对象内部属性本身相互依赖</li><li>与不可变对象配合使用</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220323233438.png"></p><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Director director = <span class="hljs-keyword">new</span> Director(<span class="hljs-keyword">new</span> DefaultConcreteProductBuilder());<br>        Product product = director.makeProduct(<span class="hljs-string">&quot;name&quot;</span>, <span class="hljs-string">&quot;company&quot;</span>, <span class="hljs-string">&quot;xxx1&quot;</span>, <span class="hljs-string">&quot;xxx2&quot;</span>, <span class="hljs-string">&quot;xxx3&quot;</span>, <span class="hljs-string">&quot;xxx4&quot;</span>);<br><br>        System.out.println(product);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">ProductBuilder</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildProductName</span><span class="hljs-params">(String productName)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildCompany</span><span class="hljs-params">(String company)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildPart1</span><span class="hljs-params">(String part1)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildPart2</span><span class="hljs-params">(String part2)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildPart3</span><span class="hljs-params">(String part3)</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">buildPart4</span><span class="hljs-params">(String part4)</span></span>;<br><br>    <span class="hljs-function">Product <span class="hljs-title">build</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Director</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> ProductBuilder builder;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Director</span><span class="hljs-params">(ProductBuilder builder)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.builder = builder;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">makeProduct</span><span class="hljs-params">(String productName, String companyName, String part1, String part2, String part3, String part4)</span> </span>&#123;<br>        builder.buildProductName(productName);<br>        builder.buildCompany(companyName);<br>        builder.buildPart1(part1);<br>        builder.buildPart2(part2);<br>        builder.buildPart3(part3);<br>        builder.buildPart4(part4);<br><br>        <span class="hljs-keyword">return</span> builder.build();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DefaultConcreteProductBuilder</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">ProductBuilder</span> </span>&#123;<br><br>    <span class="hljs-keyword">private</span> String productName;<br>    <span class="hljs-keyword">private</span> String company;<br>    <span class="hljs-keyword">private</span> String part1;<br>    <span class="hljs-keyword">private</span> String part2;<br>    <span class="hljs-keyword">private</span> String part3;<br>    <span class="hljs-keyword">private</span> String part4;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildProductName</span><span class="hljs-params">(String productName)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.productName = productName;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildCompany</span><span class="hljs-params">(String company)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.company = company;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPart1</span><span class="hljs-params">(String part1)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.part1 = part1;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPart2</span><span class="hljs-params">(String part2)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.part2 = part2;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPart3</span><span class="hljs-params">(String part3)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.part3 = part3;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">buildPart4</span><span class="hljs-params">(String part4)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.part4 = part4;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">build</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Product(<span class="hljs-keyword">this</span>.productName, <span class="hljs-keyword">this</span>.company, <span class="hljs-keyword">this</span>.part1, <span class="hljs-keyword">this</span>.part2, <span class="hljs-keyword">this</span>.part3, <span class="hljs-keyword">this</span>.part4);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> String productName;<br>    <span class="hljs-keyword">private</span> String company;<br>    <span class="hljs-keyword">private</span> String part1;<br>    <span class="hljs-keyword">private</span> String part2;<br>    <span class="hljs-keyword">private</span> String part3;<br>    <span class="hljs-keyword">private</span> String part4;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Product</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Product</span><span class="hljs-params">(String productName, String company, String part1, String part2, String part3, String part4)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.productName = productName;<br>        <span class="hljs-keyword">this</span>.company = company;<br>        <span class="hljs-keyword">this</span>.part1 = part1;<br>        <span class="hljs-keyword">this</span>.part2 = part2;<br>        <span class="hljs-keyword">this</span>.part3 = part3;<br>        <span class="hljs-keyword">this</span>.part4 = part4;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Product&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;productName=&#x27;&quot;</span> + productName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, company=&#x27;&quot;</span> + company + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, part1=&#x27;&quot;</span> + part1 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, part2=&#x27;&quot;</span> + part2 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, part3=&#x27;&quot;</span> + part3 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, part4=&#x27;&quot;</span> + part4 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>建造者模式与不可变对象配合使用：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BuilderTest2</span> </span>&#123;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Product product = <span class="hljs-keyword">new</span> Product.Builder().productName(<span class="hljs-string">&quot;name&quot;</span>).company(<span class="hljs-string">&quot;xxx&quot;</span>).part1(<span class="hljs-string">&quot;1yy&quot;</span>).build();<br>        System.out.println(product);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Product</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String productName;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String company;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String part1;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String part2;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String part3;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> String part4;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Product</span><span class="hljs-params">(String productName, String company, String part1, String part2, String part3, String part4)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.productName = productName;<br>        <span class="hljs-keyword">this</span>.company = company;<br>        <span class="hljs-keyword">this</span>.part1 = part1;<br>        <span class="hljs-keyword">this</span>.part2 = part2;<br>        <span class="hljs-keyword">this</span>.part3 = part3;<br>        <span class="hljs-keyword">this</span>.part4 = part4;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Builder</span></span>&#123;<br>        <span class="hljs-keyword">private</span> String productName;<br>        <span class="hljs-keyword">private</span> String company;<br>        <span class="hljs-keyword">private</span> String part1;<br>        <span class="hljs-keyword">private</span> String part2;<br>        <span class="hljs-keyword">private</span> String part3;<br>        <span class="hljs-keyword">private</span> String part4;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">productName</span><span class="hljs-params">(String productName)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.productName = productName;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">company</span><span class="hljs-params">(String company)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.company = company;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">part1</span><span class="hljs-params">(String part1)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.part1 = part1;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">part2</span><span class="hljs-params">(String part2)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.part2 = part2;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">part3</span><span class="hljs-params">(String part3)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.part3 = part3;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Builder <span class="hljs-title">part4</span><span class="hljs-params">(String part4)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.part4 = part4;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Product <span class="hljs-title">build</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Product(<span class="hljs-keyword">this</span>.productName,<span class="hljs-keyword">this</span>.company,<span class="hljs-keyword">this</span>.part1,<span class="hljs-keyword">this</span>.part2,<span class="hljs-keyword">this</span>.part3,<span class="hljs-keyword">this</span>.part4);<br>        &#125;<br>    &#125;<br><br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">toString</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;Product&#123;&quot;</span> +<br>                <span class="hljs-string">&quot;productName=&#x27;&quot;</span> + productName + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, company=&#x27;&quot;</span> + company + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, part1=&#x27;&quot;</span> + part1 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, part2=&#x27;&quot;</span> + part2 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, part3=&#x27;&quot;</span> + part3 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&quot;, part4=&#x27;&quot;</span> + part4 + <span class="hljs-string">&#x27;\&#x27;&#x27;</span> +<br>                <span class="hljs-string">&#x27;&#125;&#x27;</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-Spring-中的应用"><a href="#3-Spring-中的应用" class="headerlink" title="3. Spring 中的应用"></a>3. Spring 中的应用</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">org.springframework.web.servlet.mvc.method.RequestMappingInfo org.springframework.beans.factory.support.BeanDefinitionBuilder<br></code></pre></td></tr></table></figure><p><a href="https://www.cnblogs.com/bjlhx/p/11156766.html">https://www.cnblogs.com/bjlhx/p/11156766.html</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>创建型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——享元模式</title>
    <link href="/2022/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/21/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E4%BA%AB%E5%85%83%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>运用共享技术来有效地支持大量细粒度对象的复用。它通过共享已经存在的对象来大幅度减少需要创建的对象数量、避免大量相似类的开销，从而提高系统资源的利用率。</p><p><strong>优点：</strong><br>如果系统有大量类似的对象，可以节省大量的内存及CPU资源</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220320224736.png"></p><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FlyweightTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        TreeNode treeNode1 = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">3</span>, <span class="hljs-number">4</span>, TreeFactory.getTree(<span class="hljs-string">&quot;xxx&quot;</span>));<br>        TreeNode treeNode2 = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, TreeFactory.getTree(<span class="hljs-string">&quot;xxx&quot;</span>));<br>        TreeNode treeNode3 = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">13</span>, <span class="hljs-number">24</span>, TreeFactory.getTree(<span class="hljs-string">&quot;yyy&quot;</span>));<br>        TreeNode treeNode4 = <span class="hljs-keyword">new</span> TreeNode(<span class="hljs-number">15</span>, <span class="hljs-number">24</span>, TreeFactory.getTree(<span class="hljs-string">&quot;yyy&quot;</span>));<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Tree</span> </span>&#123;<br>    String name;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Tree</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;name: &quot;</span>+name +<span class="hljs-string">&quot; tree created. &quot;</span>);<br>        <span class="hljs-keyword">this</span>.name = name;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeNode</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> x;<br>    <span class="hljs-keyword">int</span> y;<br>    Tree tree;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">TreeNode</span><span class="hljs-params">(<span class="hljs-keyword">int</span> x, <span class="hljs-keyword">int</span> y, Tree tree)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.x = x;<br>        <span class="hljs-keyword">this</span>.y = y;<br>        <span class="hljs-keyword">this</span>.tree = tree;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TreeFactory</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Map&lt;String, Tree&gt; cache = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">protected</span> <span class="hljs-keyword">static</span> Tree <span class="hljs-title">getTree</span><span class="hljs-params">(String name)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (cache.containsKey(name)) &#123;<br>            <span class="hljs-keyword">return</span> cache.get(name);<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            Tree tree = <span class="hljs-keyword">new</span> Tree(name);<br>            cache.put(name, tree);<br>            <span class="hljs-keyword">return</span> tree;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-JDK-中的应用"><a href="#3-JDK-中的应用" class="headerlink" title="3. JDK 中的应用"></a>3. JDK 中的应用</h3><p>享元模式比较经典的应用就是 JDK 中部分基本类型的包装类，缓存了一定数值范围的对象，valueOf 方法转换为包装对象时，如果值在缓存范围内，即返回缓存对象。</p><ul><li>Byte，缓存了 -128 ～ 127</li><li>Short，缓存了 -128 ～ 127</li><li>Character，缓存了 0 ～ 127</li><li>Integer，缓存了 -128 ~ 127，JVM 启动参数 -XX:AutoBoxCacheMax 可以设置范围的最大值</li><li>Long，缓存了 -128 ～ 127</li><li>Boolean，缓存了 true 和 false 对象</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs java">    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> Integer <span class="hljs-title">valueOf</span><span class="hljs-params">(<span class="hljs-keyword">int</span> i)</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (i &gt;= IntegerCache.low &amp;&amp; i &lt;= IntegerCache.high)<br>            <span class="hljs-keyword">return</span> IntegerCache.cache[i + (-IntegerCache.low)];<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Integer(i);<br>    &#125;<br><br><br><span class="hljs-comment">//----------------------------------------</span><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">IntegerCache</span> </span>&#123;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> low = -<span class="hljs-number">128</span>;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">int</span> high;<br>        <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> Integer cache[];<br><br>        <span class="hljs-keyword">static</span> &#123;<br>            <span class="hljs-comment">// high value may be configured by property</span><br>            <span class="hljs-keyword">int</span> h = <span class="hljs-number">127</span>;<br>            String integerCacheHighPropValue =<br>                sun.misc.VM.getSavedProperty(<span class="hljs-string">&quot;java.lang.Integer.IntegerCache.high&quot;</span>);<br>            <span class="hljs-keyword">if</span> (integerCacheHighPropValue != <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">try</span> &#123;<br>                    <span class="hljs-keyword">int</span> i = parseInt(integerCacheHighPropValue);<br>                    i = Math.max(i, <span class="hljs-number">127</span>);<br>                    <span class="hljs-comment">// Maximum array size is Integer.MAX_VALUE</span><br>                    h = Math.min(i, Integer.MAX_VALUE - (-low) -<span class="hljs-number">1</span>);<br>                &#125; <span class="hljs-keyword">catch</span>( NumberFormatException nfe) &#123;<br>                    <span class="hljs-comment">// If the property cannot be parsed into an int, ignore it.</span><br>                &#125;<br>            &#125;<br>            high = h;<br><br>            cache = <span class="hljs-keyword">new</span> Integer[(high - low) + <span class="hljs-number">1</span>];<br>            <span class="hljs-keyword">int</span> j = low;<br>            <span class="hljs-keyword">for</span>(<span class="hljs-keyword">int</span> k = <span class="hljs-number">0</span>; k &lt; cache.length; k++)<br>                cache[k] = <span class="hljs-keyword">new</span> Integer(j++);<br><br>            <span class="hljs-comment">// range [-128, 127] must be interned (JLS7 5.1.7)</span><br>            <span class="hljs-keyword">assert</span> IntegerCache.high &gt;= <span class="hljs-number">127</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-title">IntegerCache</span><span class="hljs-params">()</span> </span>&#123;&#125;<br>    &#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>结构型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——外观模式</title>
    <link href="/2022/03/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E5%A4%96%E8%A7%82%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>外观（Facade）模式又叫作门面模式，是一种通过为多个复杂的子系统提供一个一致的接口，而使这些子系统更加容易被访问的模式。该模式对外有一个统一接口，外部应用程序不用关心内部子系统的具体细节，这样会大大降低应用程序的复杂度，提高了程序的可维护性。</p><p><strong>应用场景：</strong></p><ul><li>对分层结构系统构建时，使用外观模式定义子系统中每层的入口点可以简化子系统之间的依赖关系。</li><li>当一个复杂系统的子系统很多时，外观模式可以为系统设计一个简单的接口供外界访问。</li><li>当客户端与多个子系统之间存在很大的联系时，引入外观模式可将它们分离，从而提高子系统的独立性和可移植性。</li></ul><p><strong>优点:</strong><br>观（Facade）模式是“迪米特法则”的典型应用，它有以下主要优点。</p><ul><li>降低了子系统与客户端之间的耦合度，使得子系统的变化不会影响调用它的客户类。</li><li>对客户屏蔽了子系统组件，减少了客户处理的对象数目，并使得子系统使用起来更加容易。</li></ul><p><strong>缺点：</strong></p><ul><li>违背了“开闭原则”。</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220317205254.png"></p><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FacadeTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Facade f = <span class="hljs-keyword">new</span> Facade();<br>        f.method();<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Facade</span></span>&#123;<br>    <span class="hljs-keyword">private</span> SubSystem01 obj1 = <span class="hljs-keyword">new</span> SubSystem01();<br>    <span class="hljs-keyword">private</span> SubSystem02 obj2 = <span class="hljs-keyword">new</span> SubSystem02();<br>    <span class="hljs-keyword">private</span> SubSystem03 obj3 = <span class="hljs-keyword">new</span> SubSystem03();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method</span><span class="hljs-params">()</span> </span>&#123;<br>        obj1.method1();<br>        obj2.method2();<br>        obj3.method3();<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystem01</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method1</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;子系统01的method1()被调用！&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystem02</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method2</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;子系统02的method2()被调用！&quot;</span>);<br>    &#125;<br>&#125;<br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SubSystem03</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">method3</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;子系统03的method3()被调用！&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>结构型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——装饰器模式</title>
    <link href="/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/14/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A3%85%E9%A5%B0%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>在不改变原有对象的基础上，将功能附加到对象上。</p><p><strong>应用场景：</strong><br>扩展一个类的功能或给一个类添加附加职责 </p><p><strong>优点:</strong> </p><ol><li>不改变原有对象的情况下给一个对象扩展功能 </li><li>使用不同的组合可以实现不同的效果 </li><li>符合开闭原则</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220314225121.png"></p><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">DecoratorTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        FilterCamera filterCamera = <span class="hljs-keyword">new</span> FilterCamera(<span class="hljs-keyword">new</span> BeautyCamera(<span class="hljs-keyword">new</span> CameraImpl()));<br>        filterCamera.photo();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Camera</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">photo</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CameraImpl</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Camera</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">photo</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;拍照&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CameraDecorator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Camera</span></span>&#123;<br>    Camera camera;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">CameraDecorator</span><span class="hljs-params">(Camera camera)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.camera = camera;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">BeautyCamera</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CameraDecorator</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">BeautyCamera</span><span class="hljs-params">(Camera camera)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(camera);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">photo</span><span class="hljs-params">()</span> </span>&#123;<br>        camera.photo();<br>        System.out.println(<span class="hljs-string">&quot;美颜&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FilterCamera</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">CameraDecorator</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FilterCamera</span><span class="hljs-params">(Camera camera)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(camera);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">photo</span><span class="hljs-params">()</span> </span>&#123;<br>        camera.photo();<br>        System.out.println(<span class="hljs-string">&quot;滤镜&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-JDK-中的应用"><a href="#3-JDK-中的应用" class="headerlink" title="3. JDK 中的应用"></a>3. JDK 中的应用</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220314233706.png"></p><h4 id="4-Spring-中的应用"><a href="#4-Spring-中的应用" class="headerlink" title="4. Spring 中的应用"></a>4. Spring 中的应用</h4><p><a href="http://c.biancheng.net/view/8464.html">http://c.biancheng.net/view/8464.html</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>结构型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——适配器模式</title>
    <link href="/2022/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/13/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E9%80%82%E9%85%8D%E5%99%A8%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>将一个类的接口转换成客户希望的另外一个接口，使得原本由于接口不兼容而不能一起工作的那些类能一起工作。</p><p>适配器模式分为类结构型模式（继承）和对象结构型模式（聚合）两种。前者类之间的耦合度比后者高，且对外暴露了不需要的方法（违反了迪米特法则）。</p><p><strong>优点：</strong></p><ol><li>符合单一职责原则</li><li>符合开闭原则</li></ol><p><strong>应用场景：</strong></p><ul><li>以前开发的系统存在满足新系统功能需求的类，但其接口同新系统的接口不一致。</li><li>使用第三方提供的组件，但组件接口定义和自己要求的接口定义不同。</li></ul><p>对象适配器：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220313175600.png"></p><p>类适配器：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220313175504.png"></p><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><p>对象适配器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObjectAdapterTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Target target = <span class="hljs-keyword">new</span> Adapter(<span class="hljs-keyword">new</span> Adaptee());<br>        target.output5V();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adaptee</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">output220V</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">220</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Target</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">output5V</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Target</span></span>&#123;<br>    Adaptee adaptee;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Adapter</span><span class="hljs-params">(Adaptee adaptee)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.adaptee = adaptee;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">output5V</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> v = adaptee.output220V();<br>        System.out.printf(<span class="hljs-string">&quot;原始电压： %d v ‐ &gt; 输出电压： %d v &quot;</span>,v,<span class="hljs-number">5</span> );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">5</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>类适配器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ClassAdapterTest</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Target target = <span class="hljs-keyword">new</span> Adapter2();<br>        target.output5V();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Adapter2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Adaptee</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Target</span></span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">output5V</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">int</span> v = output220V();<br>        System.out.printf(<span class="hljs-string">&quot;原始电压： %d v ‐ &gt; 输出电压： %d v &quot;</span>,v,<span class="hljs-number">5</span> );<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-JDK-中的应用"><a href="#3-JDK-中的应用" class="headerlink" title="3. JDK 中的应用"></a>3. JDK 中的应用</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220313231941.png"></p><h3 id="4-Spring-中的应用"><a href="#4-Spring-中的应用" class="headerlink" title="4. Spring 中的应用"></a>4. Spring 中的应用</h3><p><a href="https://blog.csdn.net/yuan882696yan/article/details/105602359">https://blog.csdn.net/yuan882696yan/article/details/105602359</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>结构型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——观察者模式</title>
    <link href="/2022/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/03/12/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%A7%82%E5%AF%9F%E8%80%85%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>定义了对象之间的一对多依赖，让多个观察者对象同时监听某一个主题对象，当主题对象发生变化时，它的所有依赖者都会收到通知并更新。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220312174159.png"></p><p>使用场景：</p><ul><li>事件多级触发场景</li><li>跨系统的消息交换场景，如消息队列、事件总线的处理机制</li></ul><p>优点：</p><ul><li>解除耦合，让耦合的双方都依赖于抽象（符合开闭原则）</li><li>可以在运行时建立对象之间的关系</li></ul><p>缺点：</p><ul><li>耗时：注册较多的观察者的时候，通知比较耗时</li><li>如果在被观察者之间有循环依赖的话，被观察者会触发它们之间进行循环调用，导致系统崩溃。</li><li>异步投递时，需满足自洽性：多线程异步通知时，系统必须保证通知是以自洽的方式进行的。</li></ul><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ObserverDemo</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Subject subject = <span class="hljs-keyword">new</span> Subject();<br>        Task1 task1 = <span class="hljs-keyword">new</span> Task1();<br>        Task2 task2 = <span class="hljs-keyword">new</span> Task2();<br>        subject.add(task1);<br>        subject.add(task2);<br>        subject.notifyObserver(<span class="hljs-string">&quot;hello&quot;</span>);<br>        subject.remove(task1);<br>        subject.notifyObserver(<span class="hljs-string">&quot;world&quot;</span>);<br>    &#125;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Subject</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> List&lt;Observer&gt; container = <span class="hljs-keyword">new</span> ArrayList&lt;Observer&gt;();<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">add</span><span class="hljs-params">(Observer observer)</span> </span>&#123;<br>        container.add(observer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">(Observer observer)</span> </span>&#123;<br>        container.remove(observer);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">notifyObserver</span><span class="hljs-params">(Object object)</span> </span>&#123;<br>        <span class="hljs-keyword">for</span> (Observer observer : container) &#123;<br>            observer.update(object);<br>        &#125;<br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Object object)</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task1</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Object object)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;task1 received: &quot;</span> + object);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Task2</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Observer</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">update</span><span class="hljs-params">(Object object)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;task2 received: &quot;</span> + object);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="3-jdk-中的应用"><a href="#3-jdk-中的应用" class="headerlink" title="3. jdk 中的应用"></a>3. jdk 中的应用</h3><p>java.util.Observable</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220312190855.png"></p><h3 id="4-Spring-中的应用"><a href="#4-Spring-中的应用" class="headerlink" title="4. Spring 中的应用"></a>4. Spring 中的应用</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220312190254.png"></p><p><a href="https://www.cnblogs.com/jmcui/p/11054756.html">https://www.cnblogs.com/jmcui/p/11054756.html</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>行为型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Kubernetes——k8s架构与核心组件</title>
    <link href="/2022/03/11/Kubernetes%E2%80%94%E2%80%94k8s%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/"/>
    <url>/2022/03/11/Kubernetes%E2%80%94%E2%80%94k8s%E6%9E%B6%E6%9E%84%E4%B8%8E%E6%A0%B8%E5%BF%83%E7%BB%84%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="1-什么是-Kubernetes"><a href="#1-什么是-Kubernetes" class="headerlink" title="1. 什么是 Kubernetes"></a>1. 什么是 Kubernetes</h3><p>Kubernetes(K8S)是由 Google 开源的生产级容器编排系统，是 Google 多年大规模容器管理技术 Borg 的开源版本</p><p>Kurbernets的本质是一组服务器集群，它可以在集群的每个节点上运行特定的程序，来对节点中的容器进行管理。它的目的就是实现资源管理的自动化，主要提供了如下的主要功能：</p><ul><li>自我修复：一旦某一个容器崩溃，能够在1秒钟左右迅速启动新的容器</li><li>弹性伸缩：可以根据需要，自动对集群中正在运行的容器数量进行调整</li><li>服务发现：服务可以通过自动发现的形式找到它所依赖的服务</li><li>负载均衡: 如果一个服务启动了多个容器，能够自动实现请求的负载均衡</li><li>版本回退：如果发现新发布的程序版本有问题，可以立即回退到原来的版本</li><li>容器编排：可以根据容器自身的需求自动创建存储卷</li><li>跨机器和跨地区的集群调度</li><li>无状态服务和有状态服务</li><li>广泛的Volume支持</li><li>插件机制保证扩展性</li></ul><h4 id="1-1-产生背景"><a href="#1-1-产生背景" class="headerlink" title="1.1 产生背景"></a>1.1 产生背景</h4><p>微服务和容器的流行。微服务是把原来一体化的应用转换为一个个相互独立(高内聚低耦合)的小应用，这些小应用就叫微服务。一个应用如果有成千上万的微服务，那么微服务的部署会很麻烦。一台机器可能部署多个微服务。对微服务进行隔离和资源控制(微服务的支持调度计划)就需要用到容器。</p><h4 id="1-2-容器"><a href="#1-2-容器" class="headerlink" title="1.2 容器"></a>1.2 容器</h4><ul><li>容器是一系列隔离运行的进程，提供了一种轻量操作系统层面的虚拟化技术。</li><li>每个容器都有自己的PID(进程号)，User，UTS，Network栈命名空间等</li><li>与传统虚拟机比具有启动快，性能损耗小，更轻量化的特点</li></ul><p>K8S默认使用Docker引擎，也可使用 Rkt(coreos) 或其他遵循 CRI(container runtime interface)标准的容器引擎，如Containerd等</p><p>Docker最创新的地方:引入了镜像分层的机制，可以让镜像比较小，使隔离技术在操作系统层面也可以用，docker 提供命令行的方式对容器进行增删改查，提供了镜像机制把环境打包到镜像中，使得使用容器技术变得非常简单</p><p>容器化系统面临的挑战：<br>容器虽然解决了应用打包、部署、运行的问题(一次构建、随处运行Build,Ship and Run Any App,Anywhere),但是也面临了跨机器的部署、资源调度、负载均衡、自动伸缩、容错处理、服务发现的挑战。</p><h4 id="1-3-容器编排"><a href="#1-3-容器编排" class="headerlink" title="1.3 容器编排"></a>1.3 容器编排</h4><p>容器编排：</p><ul><li>以容器为基本对象进行管理</li><li>协同容器共同实现应用功能</li></ul><p>容器编排的主要功能：</p><ol><li>容器调度（Placement, health checking..)</li><li>资源管理(CPU、GPU、Memory…)</li><li>服务管理(Service Discovery服务发现、Load Balance…)</li></ol>]]></content>
    
    
    <categories>
      
      <category>Kubernetes</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Kubernetes</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jenkins——构建持续集成环境</title>
    <link href="/2022/03/08/jenkins%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83/"/>
    <url>/2022/03/08/jenkins%E2%80%94%E2%80%94%E6%9E%84%E5%BB%BA%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%8E%AF%E5%A2%83/</url>
    
    <content type="html"><![CDATA[<p>更新机制是指项目如何进行更新，主要有两种方式：一种是自动推送，另外一种是手动拉取。前者用于开发环境、后者可以用于所有环境。</p><h3 id="1-手动拉取"><a href="#1-手动拉取" class="headerlink" title="1. 手动拉取"></a>1. 手动拉取</h3><p>拉取更新流程：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220308233636.png"></p><p>上述流程由 deploy.sh 脚本实现：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash -e</span><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;`dirname <span class="hljs-variable">$0</span>`&quot;</span><br>. ./pom.sh<br><br><span class="hljs-comment">#1. download war, ready env</span><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;deploy time: <span class="hljs-variable">$work_time</span>&quot;</span><br>mkdir -p war/<br>war=war/<span class="hljs-variable">$pom_a</span>-<span class="hljs-variable">$pom_v</span>.war<br>download_path=<span class="hljs-string">&quot;<span class="hljs-variable">$nexus_redirect</span>?r=<span class="hljs-variable">$pom_r</span>&amp;g=<span class="hljs-variable">$pom_g</span>&amp;a=<span class="hljs-variable">$pom_a</span>&amp;v=<span class="hljs-variable">$pom_v</span>&amp;e=war&quot;</span><br>wget  <span class="hljs-variable">$download_path</span> -O <span class="hljs-variable">$war</span><br><br>deploy_war<br></code></pre></td></tr></table></figure><p>pom.sh 脚本内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash -e</span><br>. ../bin/env-set.sh<br><br>pom_g=com.zth<br>pom_a=hello-debuggingWorld<br>pom_v=1.0-SNAPSHOT<br>pom_r=snapshots<br><br><br><span class="hljs-function"><span class="hljs-title">deploy_war</span></span>() &#123;<br>        target_d=war/<span class="hljs-variable">$&#123;pom_a&#125;</span>-<span class="hljs-variable">$&#123;pom_v&#125;</span>-<span class="hljs-variable">$work_time</span><br>        target_dir=`<span class="hljs-built_in">pwd</span>`/<span class="hljs-variable">$target_d</span><br>        <span class="hljs-keyword">if</span> [ ! -f <span class="hljs-string">&quot;<span class="hljs-variable">$war</span>&quot;</span> ]; <span class="hljs-keyword">then</span><br>                <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;war not exist: <span class="hljs-variable">$war</span>&quot;</span><br>                <span class="hljs-built_in">exit</span> 1<br>        <span class="hljs-keyword">fi</span><br>        unzip -q <span class="hljs-variable">$war</span> -d <span class="hljs-variable">$target_dir</span><br>        cp -r app-conf/* <span class="hljs-variable">$target_dir</span>/WEB-INF/classes/<br>        rm -rf appwar<br>        ln -sf <span class="hljs-variable">$target_d</span>/  appwar<br><br>        ./tomcat.sh stop<br><br>        target_ln=`<span class="hljs-built_in">pwd</span>`/appwar<br>        <span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot; ?&gt;</span><br><span class="hljs-string">&lt;Context docBase=&quot;&#x27;</span><span class="hljs-variable">$target_ln</span><span class="hljs-string">&#x27;&quot; allowLinking=&quot;true&quot;&gt;</span><br><span class="hljs-string">&lt;/Context&gt;&#x27;</span> &gt; conf/Catalina/localhost/ROOT.xml<br>        ./tomcat.sh start<br>&#125;<br></code></pre></td></tr></table></figure><p>tomcat.sh 内容：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/bash</span><br><span class="hljs-keyword">if</span> [ <span class="hljs-string">&quot;`whoami`&quot;</span> != <span class="hljs-string">&quot;root&quot;</span> ];<span class="hljs-keyword">then</span><br>                <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Error: You must be apps to run this command.&quot;</span><br>                <span class="hljs-built_in">exit</span> 1<br><span class="hljs-keyword">fi</span><br><br><span class="hljs-built_in">cd</span> <span class="hljs-string">&quot;`dirname <span class="hljs-variable">$0</span>`&quot;</span><br>. ../bin/env-set.sh<br>. ./pom.sh<br><br><span class="hljs-built_in">export</span> CATALINA_BASE=<span class="hljs-string">&quot;`pwd`&quot;</span><br>tomcat <span class="hljs-string">&quot;<span class="hljs-variable">$1</span>&quot;</span> <span class="hljs-string">&quot;<span class="hljs-variable">$&#123;pom_a&#125;</span>-<span class="hljs-variable">$&#123;pom_v&#125;</span>&quot;</span><br></code></pre></td></tr></table></figure><p> 文件结构：<br> <figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><code class="hljs crmsh"> ├── apache-tomcat -&gt; /usr/local/apache-maven-<span class="hljs-number">3.8</span>.<span class="hljs-number">4</span>/<br>├── jdk -&gt; /usr/local/jdk1.<span class="hljs-number">8.0</span>_211/<br>└── services<br>    ├── bin<br>    │   └── env-set.sh<br>    └── hello-debuggingworld<br>        ├── app-conf<br>        │   └── app.properties<br>        ├── appwar -&gt; war/hello-debuggingWorld-<span class="hljs-number">1.0</span>-SNAPSHOT-<span class="hljs-number">2022</span>-<span class="hljs-number">03</span>-<span class="hljs-number">08</span>_23-<span class="hljs-number">57</span>-<span class="hljs-number">57</span>/<br>        ├── conf<br>        │   ├── Catalina<br>        │   │   └── localhost<br>        │   │       └── ROOT.<span class="hljs-keyword">xml</span><br>        <span class="hljs-title">│   ├── catalina</span>.policy<br>        │   ├── catalina.properties<br>        │   ├── context.<span class="hljs-keyword">xml</span><br>        <span class="hljs-title">│   ├── jaspic-providers</span>.<span class="hljs-keyword">xml</span><br>        <span class="hljs-title">│   ├── jaspic-providers</span>.xsd<br>        │   ├── logging.properties<br>        │   ├── server.<span class="hljs-keyword">xml</span><br>        <span class="hljs-title">│   ├── tomcat-users</span>.<span class="hljs-keyword">xml</span><br>        <span class="hljs-title">│   ├── tomcat-users</span>.xsd<br>        │   └── web.<span class="hljs-keyword">xml</span><br>        <span class="hljs-title">├── deploy</span>.sh<br>        ├── jenkins.sh<br>        ├── logs<br>        ├── pom.sh<br>        ├── tomcat.sh<br>        ├── war<br>        │   ├── hello-debuggingWorld-<span class="hljs-number">1.0</span>-SNAPSHOT-<span class="hljs-number">2022</span>-<span class="hljs-number">03</span>-<span class="hljs-number">08</span>_23-<span class="hljs-number">57</span>-<span class="hljs-number">57</span><br>        │   │   ├── <span class="hljs-keyword">META</span><span class="hljs-literal">-INF</span><br>        │   │   └── WEB<span class="hljs-literal">-INF</span><br>        │   └── hello-debuggingWorld-<span class="hljs-number">1.0</span>-SNAPSHOT.war<br>        ├── webapps<br>        └── work<br>            └── Catalina<br>                └── localhost<br>                    └── ROOT<br></code></pre></td></tr></table></figure></p><p>执行 deploy.sh 脚本完成更新</p><p><a href="https://github.com/debuggingworld/jenkinsScript.git">代码地址</a></p><h3 id="2-自动推送"><a href="#2-自动推送" class="headerlink" title="2. 自动推送"></a>2. 自动推送</h3><p>自动推送方式采用在 jenkins 构建完成之后，执行远程 sh 脚本用于下载本次构建 WAR 包，在自动部署重启。基 jenkins 配置如下：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220309012019.png"></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">BUILD_ID=dontKillMe<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$BUILD_ID</span><br>ssh root@192.168.60.10 BUILD_URL=<span class="hljs-variable">$BUILD_URL</span> /root/svr/services/hello-debuggingworld/jenkins.sh<br></code></pre></td></tr></table></figure><p>【注】需要设置免密登录（添加公钥到服务器）</p><h3 id="3-配置文件更新"><a href="#3-配置文件更新" class="headerlink" title="3. 配置文件更新"></a>3. 配置文件更新</h3><p>在跌代的过程中要经过四个环境，每个环境的配置信息是不一样的，如何在更新项目的时候把对应的配置文件也更新了呢? 有一种做法是采用 Disconf 之类的配置系统来管理各个环境 的配置，也可以采用一个简单些的方案: 把当前环境 的配置文件放到 app-conf 目录下，等更新脚本的时候会一同覆盖原来的配置文件。 </p><h3 id="4-版本回滚"><a href="#4-版本回滚" class="headerlink" title="4. 版本回滚"></a>4. 版本回滚</h3><p>之前在部署的时候是通过软链接的形式指向指定程序目录，而且原历史版本不会删除，回滚的时候只要把原软链接指定历史程序目录即可。而且配置文件也会一同回滚。</p><h3 id="5-更新脚本说明"><a href="#5-更新脚本说明" class="headerlink" title="5. 更新脚本说明"></a>5. 更新脚本说明</h3><p>deploy.sh 部署脚本中还用到了 pom.sh 与 tomcat.sh 等脚本，这些脚本的作用是什么呢？整体逻辑如下依赖关系如下:</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220309001255.png"></p><ul><li>env-set.sh : 设置 jvm 、Tomcat 等环境参数</li><li>pom.sh: 设置当前项目的 groupid 、artifact、version 信息</li><li>tomcat.sh：启动关闭 Tomcat</li><li>deploy.sh :  下载并部署项目</li><li>jenkins.sh:  用于被 jenkins 远程触发下载指定更新版本</li></ul>]]></content>
    
    
    <categories>
      
      <category>jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven——nexus私服搭建</title>
    <link href="/2022/02/28/maven%E2%80%94%E2%80%94nexus%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/"/>
    <url>/2022/02/28/maven%E2%80%94%E2%80%94nexus%E7%A7%81%E6%9C%8D%E6%90%AD%E5%BB%BA/</url>
    
    <content type="html"><![CDATA[<h3 id="1-私服使用场景"><a href="#1-私服使用场景" class="headerlink" title="1. 私服使用场景"></a>1. 私服使用场景</h3><ol><li>公司不能连接公网，可以用一个私服务来统一连接</li><li>公司内部 jar 组件的共享</li></ol><h3 id="2-nexus-下载安装"><a href="#2-nexus-下载安装" class="headerlink" title="2. nexus 下载安装"></a>2. nexus 下载安装</h3><p>nexus 下载地址：<br><a href="https://sonatype-download.global.ssl.fastly.net/nexus/oss/nexus-2.14.5-02-bundle.tar.gz">https://sonatype-download.global.ssl.fastly.net/nexus/oss/nexus-2.14.5-02-bundle.tar.gz</a></p><p><strong>解压并设置环境变量</strong></p><p>解压：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">tar -zxvf nexus-2.14.5-02-bundle.tar.gz<br></code></pre></td></tr></table></figure><p>在环境变量当中设置启动用户：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /etc/profile<br><span class="hljs-comment">#添加 profile 文件。安全起见不建议使用root用户，如果使用其它用户需要加相应权限</span><br><span class="hljs-built_in">export</span> RUN_AS_USER=root<br><br><span class="hljs-comment"># 配置生效</span><br><span class="hljs-built_in">source</span> /etc/profile <br></code></pre></td></tr></table></figure><p>配置启动参数：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">vi <span class="hljs-variable">$&#123;nexusBase&#125;</span>/conf/nexus.properties<br><span class="hljs-comment">#端口号</span><br>application-port=8081<br></code></pre></td></tr></table></figure><p>启动与停止nexus：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#启动</span><br><span class="hljs-variable">$&#123;nexusBase&#125;</span>/bin/nexus start<br><span class="hljs-comment">#停止</span><br><span class="hljs-variable">$&#123;nexusBase&#125;</span>/bin/nexus stop<br></code></pre></td></tr></table></figure><p>登录 nexus 界面<br><a href="http://192.168.60.10:8081/nexus/">http://192.168.60.10:8081/nexus/</a><br>用户名:admin<br>密码：admin123</p><h3 id="3-nexus-仓库介绍"><a href="#3-nexus-仓库介绍" class="headerlink" title="3. nexus 仓库介绍"></a>3. nexus 仓库介绍</h3><p>3rd party：第三方仓库<br>Apache Snapshots：apache 快照仓库<br>Central: maven 中央仓库<br>Releases：私有发布版本仓库<br>Snapshots：私有 快照版本仓库</p><p>配置阿里云远程仓库：<br><a href="http://maven.aliyun.com/nexus/content/groups/public/">http://maven.aliyun.com/nexus/content/groups/public/</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220301232931.png"></p><h3 id="4-本地远程仓库配置"><a href="#4-本地远程仓库配置" class="headerlink" title="4. 本地远程仓库配置"></a>4. 本地远程仓库配置</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220301232522.png"></p><p>在pom 中配置远程仓库：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">repositories</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-public<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>my nexus repository<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>192.168.60.10:8081/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">repositories</span>&gt;</span><br></code></pre></td></tr></table></figure><p>或者在settings.xml 文件中配置远程仓库镜像</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">mirror</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>alimaven<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>aliyun maven<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://192.168.60.10:8081/nexus/content/groups/public/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">mirrorOf</span>&gt;</span>central<span class="hljs-tag">&lt;/<span class="hljs-name">mirrorOf</span>&gt;</span>        <br><span class="hljs-tag">&lt;/<span class="hljs-name">mirror</span>&gt;</span><br></code></pre></td></tr></table></figure><p>添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p>执行 mvn compile：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220301234516.png"></p><p>远程仓库：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220301235001.png"></p><h3 id="5-发布项目至-nexus-远程仓库"><a href="#5-发布项目至-nexus-远程仓库" class="headerlink" title="5. 发布项目至 nexus 远程仓库"></a>5. 发布项目至 nexus 远程仓库</h3><p>pom.xml 配置仓库地址：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">distributionManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">repository</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-release<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>nexus release<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://192.168.60.10:8081//nexus/content/repositories/releases/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">repository</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">snapshotRepository</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-snapshot<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>nexus snapshot<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">url</span>&gt;</span>http://192.168.60.10:8081//nexus/content/repositories/snapshots/<span class="hljs-tag">&lt;/<span class="hljs-name">url</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">snapshotRepository</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">distributionManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>setting.xml 中设置 server：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-snapshot<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>deployment<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>deployment123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-release<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>deployment<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>deployment123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220302000735.png"></p><p>pom.xml:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.zth<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>myplugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br></code></pre></td></tr></table></figure><p>执行 mvn deploy：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220302001136.png"></p><p><a href="https://zhuanlan.zhihu.com/p/443204695">maven配置多仓库</a></p>]]></content>
    
    
    <categories>
      
      <category>maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven——生命周期与自定义插件开发</title>
    <link href="/2022/02/28/maven%E2%80%94%E2%80%94%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/"/>
    <url>/2022/02/28/maven%E2%80%94%E2%80%94%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F%E4%B8%8E%E8%87%AA%E5%AE%9A%E4%B9%89%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h3 id="1-生命周期"><a href="#1-生命周期" class="headerlink" title="1. 生命周期"></a>1. 生命周期</h3><h4 id="1-1-生命周期的概念与意义"><a href="#1-1-生命周期的概念与意义" class="headerlink" title="1.1 生命周期的概念与意义"></a>1.1 生命周期的概念与意义</h4><p>在项目构建时通常会包含清理、编译、测试、打包、验证、部署，文档生成等步骤，maven 统一对其进行了整理抽像成三个生命周期 (lifecycle)及各自对应的多个阶段(phase)。这么做的意义是：</p><ol><li>每个阶段都成为了一个扩展点，可以采用不同的方式来实现，提高了扩展性与灵活性。</li><li>规范统一了 maven 的执行路径。</li></ol><p>可以通过命令 mvn ${phase name} 直接触发指定阶段的执行如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#执行清理 phase</span><br>mvn clean<br><span class="hljs-comment">#执行 compile phase</span><br>mvn compile<br><span class="hljs-comment">#也可以同时执行 清理加编译</span><br>mvn clean comile<br></code></pre></td></tr></table></figure><h4 id="1-2-maven-三大生命周期与其对应的phase"><a href="#1-2-maven-三大生命周期与其对应的phase" class="headerlink" title="1.2 maven 三大生命周期与其对应的phase"></a>1.2 maven 三大生命周期与其对应的phase</h4><p>maven 总共包含三大生生命周期</p><ol><li>clean Lifecycle：清理生命周期，用于清理项目</li><li>default Lifecycle：默认生命周期，用于编译、打包、测试、部署等</li><li>site Lifecycle：站点文档生成，用于构建站点文档</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220228203832.png"></p><p>三大生命周期其相互独立执行，也可以合在一起执行。但 lifecycle 中的 phase 是有严格执行的顺序的，比如必须是先执行完 compile 才能执行 pakcage 动作，此外 phase 还有包含逻辑存在，即当你执行一个phase 时 其前面的 phase 会自动执行（同一生命周期中）。</p><p><a href="https://maven.apache.org/ref/3.5.4/maven-core/lifecycles.html">https://maven.apache.org/ref/3.5.4/maven-core/lifecycles.html</a></p><h4 id="1-3-生命周期与插件的关系"><a href="#1-3-生命周期与插件的关系" class="headerlink" title="1.3 生命周期与插件的关系"></a>1.3 生命周期与插件的关系</h4><p>生命周期的 phase 组成了项目构建的完整过程，这些过程具体是由插件来实现的。</p><p>比如：test 阶段就是由 maven-surefire-plugin 实现。在 pom.xml 中可以设置指定插件目标（gogal）与 phase 绑定，当项目构建到达指定 phase 时，就会触发这些插件 gogal 的执行。一个插件有时会实现多个 phase 比如：maven-compiler-plugin 插件分别实现了compile 和 testCompile。</p><p> 总结：<br>生命周期的阶段可以绑定具体的插件及目标<br>不同配置下同一个阶段可以对应多个插件和目标</p><h4 id="1-4-生命周期与插件的默认绑定"><a href="#1-4-生命周期与插件的默认绑定" class="headerlink" title="1.4 生命周期与插件的默认绑定"></a>1.4 生命周期与插件的默认绑定</h4><p>在我们的项目当中并没有配置 maven-compiler-plugin 插件,但当执行 compile 阶段时一样能够执行编译操作，原因是 maven 默认为指定阶段绑定了插件实现。列如以下两个操作在一定程度上是等价的。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn compile<br><span class="hljs-comment">#直接执行compile插件目标</span><br>mvn org.apache.maven.plugins:maven-compiler-plugin:3.1:compile<br></code></pre></td></tr></table></figure><p>Default Lifecycle JAR 默认绑定:</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">phases</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">process-resources</span>&gt;</span><br>    org.apache.maven.plugins:maven-resources-plugin:2.6:resources<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">process-resources</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">compile</span>&gt;</span><br>    org.apache.maven.plugins:maven-compiler-plugin:3.1:compile<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">compile</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">process-test-resources</span>&gt;</span><br>    org.apache.maven.plugins:maven-resources-plugin:2.6:testResources<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">process-test-resources</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test-compile</span>&gt;</span><br>    org.apache.maven.plugins:maven-compiler-plugin:3.1:testCompile<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test-compile</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">test</span>&gt;</span><br>    org.apache.maven.plugins:maven-surefire-plugin:2.12.4:test<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">test</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">package</span>&gt;</span><br>    org.apache.maven.plugins:maven-jar-plugin:2.4:jar<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">package</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">install</span>&gt;</span><br>    org.apache.maven.plugins:maven-install-plugin:2.4:install<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">install</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">deploy</span>&gt;</span><br>    org.apache.maven.plugins:maven-deploy-plugin:2.7:deploy<br>  <span class="hljs-tag">&lt;/<span class="hljs-name">deploy</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">phases</span>&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://maven.apache.org/ref/3.5.4/maven-core/default-bindings.html">https://maven.apache.org/ref/3.5.4/maven-core/default-bindings.html</a></p><h3 id="2-maven-自定义插件开发"><a href="#2-maven-自定义插件开发" class="headerlink" title="2. maven 自定义插件开发"></a>2. maven 自定义插件开发</h3><h4 id="2-1-maven-插件相关概念"><a href="#2-1-maven-插件相关概念" class="headerlink" title="2.1 maven 插件相关概念"></a>2.1 maven 插件相关概念</h4><p><strong>插件坐标定位：</strong><br>插件与普通 jar 包一样包含 一组件坐标定位属性即：groupId、artifactId、version，当使用该插件时会从本地仓库中搜索，如果没有即从远程仓库下载</p><p><strong>插件执行 execution：</strong><br>execution 配置包含一组指示插件如何执行的属性：<br>id ： 执行器命名<br>phase：在什么阶段执行？<br>goals：执行一组什么目标或功能？<br>configuration：执行目标所需的配置文件？</p><p>【例】将插件依赖拷贝到指定目录</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.1.1<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>copy-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>package<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>copy-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span>              <span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/alternateLocation<span class="hljs-tag">&lt;/<span class="hljs-name">outputDirectory</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">overWriteReleases</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">overWriteReleases</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">overWriteSnapshots</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">overWriteSnapshots</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">excludeTransitive</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">excludeTransitive</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br></code></pre></td></tr></table></figure><h4 id="2-2-常用插件的使用"><a href="#2-2-常用插件的使用" class="headerlink" title="2.2 常用插件的使用"></a>2.2 常用插件的使用</h4><p>除了通过配置的方式使用插件以外，Maven 也提供了通过命令直接调用插件目标其命令格式如下：</p><p>mvn groupId:artifactId:version:goal -D{参数名}</p><p>【例】展示 pom 的依赖关系树</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn org.apache.maven.plugins:maven-dependency-plugin:2.10:tree<br></code></pre></td></tr></table></figure><p>也可以直接简化版的命令，但前提必须是 maven 官方插件</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn dependency:tree<br></code></pre></td></tr></table></figure><p><strong>查看 pom 文件的最终配置</strong> </p><p>mvn help:effective-pom</p><p><strong>原型项目生成</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">archetype:generate<br><span class="hljs-comment">#快速创建一个 WEB 程序</span><br>mvn archetype:generate -DgroupId=tuling -DartifactId=simple-webbapp -DarchetypeArtifactId=maven-archetype-webapp -DinteractiveMode=<span class="hljs-literal">false</span><br><span class="hljs-comment">#快速创建一个java 项目</span><br>mvn archetype:generate -DgroupId=tuling -DartifactId=simple-java -DarchetypeArtifactId=maven-archetype-quickstart -DinteractiveMode=<span class="hljs-literal">false</span><br></code></pre></td></tr></table></figure><h4 id="2-3-开发一个自定义插件"><a href="#2-3-开发一个自定义插件" class="headerlink" title="2.3 开发一个自定义插件"></a>2.3 开发一个自定义插件</h4><p>实现步骤：</p><ul><li>创建 maven 插件项目</li><li>设定 packaging 为 maven-plugin</li><li>添加插件依赖</li><li>编写插件实现逻辑</li><li>打包构建插</li></ul><p>pom.xml：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-meta">&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">         <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.zth<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>myplugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">packaging</span>&gt;</span>maven-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">packaging</span>&gt;</span><br><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-plugin-api<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugin-tools<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-plugin-annotations<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.4<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p>插件实现类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 猫和少年</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2022-02-28 21:31</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Slogan</span> 才疏学浅，少年登科；满腹经纶，白发不第</span><br><span class="hljs-comment"> */</span><br><span class="hljs-meta">@Mojo(name = &quot;debuggingWorld&quot;)</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyPlugin</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractMojo</span> </span>&#123;<br>    <span class="hljs-meta">@Parameter</span><br>    String name;<br><br>    <span class="hljs-meta">@Parameter</span><br>    String describe;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">execute</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> MojoExecutionException, MojoFailureException </span>&#123;<br>        getLog().info(String.format(<span class="hljs-string">&quot;name: %s describe=%s&quot;</span>,name,describe));<br>    &#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>打包到本地仓库：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn install<br></code></pre></td></tr></table></figure><p>其他项目使用此插件：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>   <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.zth<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>myplugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0-SNAPSHOT<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>       <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>           <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>print user info<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>debuggingWorld<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>               <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">name</span>&gt;</span>zth<span class="hljs-tag">&lt;/<span class="hljs-name">name</span>&gt;</span><br>                   <span class="hljs-tag">&lt;<span class="hljs-name">describe</span>&gt;</span>才疏学浅，少年登科；满腹经纶，白发不第<span class="hljs-tag">&lt;/<span class="hljs-name">describe</span>&gt;</span><br>               <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>           <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>       <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>   <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br></code></pre></td></tr></table></figure><p>执行结果：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh">PS G:\tmp\learnMaven&gt; mvn compile<br>[INFO] Scanning <span class="hljs-keyword">for</span> projects...<br>[INFO] ------------------------------------------------------------------------<br>[INFO] Reactor Build Order:<br>[INFO]<br>[INFO] my-maven                                                           [pom]<br>[INFO] module1                                                            [jar]<br>[INFO]<br>[INFO] --------------------&lt; com.debuggingworld:my-maven &gt;---------------------<br>[INFO] Building my-maven 1.0                                              [1/2]<br>[INFO] --------------------------------[ pom ]---------------------------------<br>[INFO]<br>[INFO] --- myplugin:1.0-SNAPSHOT:debuggingWorld (<span class="hljs-built_in">print</span> user info) @ my-maven ---<br>[INFO] name: zth describe=才疏学浅，少年登科；满腹经纶，白发不第<br>[INFO]<br>[INFO] ---------------------&lt; com.debuggingworld:module1 &gt;---------------------<br><br>....<br><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>maven——基本概念与核心配置</title>
    <link href="/2022/02/25/maven%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/"/>
    <url>/2022/02/25/maven%E2%80%94%E2%80%94%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5%E4%B8%8E%E6%A0%B8%E5%BF%83%E9%85%8D%E7%BD%AE/</url>
    
    <content type="html"><![CDATA[<h3 id="1-maven-安装与核心概念"><a href="#1-maven-安装与核心概念" class="headerlink" title="1. maven  安装与核心概念"></a>1. maven  安装与核心概念</h3><p>maven 的功能：编译、打包、测试、依赖管理</p><h4 id="1-1-安装"><a href="#1-1-安装" class="headerlink" title="1.1 安装"></a>1.1 安装</h4><ol><li>官网下载 Maven （<a href="http://maven.apache.org/download.cgi%EF%BC%89">http://maven.apache.org/download.cgi）</a></li><li>解压指定目录</li><li>配置环境变量</li><li>检查安装是否成功 （mvn -version）</li></ol><p><a href="https://blog.csdn.net/weixin_43811057/article/details/108235117">安装参考</a></p><h4 id="1-2-maven-编译"><a href="#1-2-maven-编译" class="headerlink" title="1.2 maven 编译"></a>1.2 maven 编译</h4><ul><li>创建 maven 项目</li><li>创建 src 文件</li><li>编写  pom 文件</li><li>执行编译命令</li></ul><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">project</span> <span class="hljs-attr">xmlns</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0&quot;</span> <span class="hljs-attr">xmlns:xsi</span>=<span class="hljs-string">&quot;http://www.w3.org/2001/XMLSchema-instance&quot;</span></span><br><span class="hljs-tag">  <span class="hljs-attr">xsi:schemaLocation</span>=<span class="hljs-string">&quot;http://maven.apache.org/POM/4.0.0 https://maven.apache.org/xsd/maven-4.0.0.xsd&quot;</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">modelVersion</span>&gt;</span>4.0.0<span class="hljs-tag">&lt;/<span class="hljs-name">modelVersion</span>&gt;</span><br> <br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.debuggingworld<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>my-maven<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">project</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>编译</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ mvn compile<br>[INFO] Scanning <span class="hljs-keyword">for</span> projects...<br>[INFO]<br>[INFO] --------------------&lt; com.debuggingworld:my-mavwn &gt;---------------------<br>[INFO] Building my-mavwn 1.0<br>[INFO] --------------------------------[ jar ]---------------------------------<br>[INFO]<br>[INFO] --- maven-resources-plugin:2.6:resources (default-resources) @ my-mavwn ---<br>[WARNING] Using platform encoding (GBK actually) to copy filtered resources, i.e. build is platform dependent!<br>[INFO] skip non existing resourceDirectory G:\tmp\learnMaven\src\main\resources<br>[INFO]<br>[INFO] --- maven-compiler-plugin:3.1:compile (default-compile) @ my-mavwn ---<br>[INFO] No sources to compile<br>[INFO] ------------------------------------------------------------------------<br>[INFO] BUILD SUCCESS<br>[INFO] ------------------------------------------------------------------------<br>[INFO] Total time:  0.947 s<br>[INFO] Finished at: 2022-02-26T09:58:01+08:00<br>[INFO] ------------------------------------------------------------------------<br></code></pre></td></tr></table></figure><p>maven 采用了约定的方式从指项目结构中获取源码与资源文件进行编译打包。<br><font color="red"><strong>(约定大于配置)</strong></font></p><figure class="highlight xl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs xl">my-app<br>│ <br>│-pom.xml<br>│<br>└─src<br>    ├─main<br>    │  ├─<span class="hljs-function"><span class="hljs-title">java</span>                        ---&gt;</span> 主源码文件<br>    │  │  └─com<br>    │  │      └─debuggging<br>    │  │          └─app<br>    │  │              └─App.java<br>    │  │<br>    │  └─<span class="hljs-function"><span class="hljs-title">resources</span>                   ---&gt;</span> 主资源文件<br>    └─test<br>        ├─<span class="hljs-function"><span class="hljs-title">java</span>                        ---&gt;</span> 测试源码文件<br>        └─<span class="hljs-function"><span class="hljs-title">resources</span>                   ---&gt;</span> 测试资源文件<br></code></pre></td></tr></table></figure><h4 id="1-3-maven-打包"><a href="#1-3-maven-打包" class="headerlink" title="1.3 maven 打包"></a>1.3 maven 打包</h4><p>打包命令：mvn package</p><p>【注】执行 package 命令前会自动执行 compile 命令</p><h4 id="1-4-maven-单元测试"><a href="#1-4-maven-单元测试" class="headerlink" title="1.4 maven 单元测试"></a>1.4 maven 单元测试</h4><ul><li>编写测试类</li><li>执行测试命令</li></ul><p>maven 中的测试类做了约定，必须是 Test 开头的类名与 test 开头的方法才会执行。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.debuggingworld;<br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestHello</span></span>&#123;<br>        <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">testHello</span><span class="hljs-params">()</span></span>&#123;<br>                System.out.println(<span class="hljs-string">&quot;run test .....&quot;</span>);<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行命令：<br><strong><font color="red"> mvn test</font></strong></p><h4 id="1-5-maven-依赖管理"><a href="#1-5-maven-依赖管理" class="headerlink" title="1.5 maven 依赖管理"></a>1.5 maven 依赖管理</h4><p>以 junit 为例。</p><ul><li>在 pom 文件中添加 junit 依赖</li><li>编写 junit 测试方法</li><li>执行测试命令</li></ul><p><strong>加入依懒配置</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>test<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><p><strong>编写测试方法</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">package</span> com.debuggingworld;<br><br><span class="hljs-keyword">import</span> org.junit.Assert;<br><span class="hljs-keyword">import</span> org.junit.Test;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TestHello</span></span>&#123;<br><span class="hljs-meta">@Test</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">sayHello</span><span class="hljs-params">()</span></span>&#123;<br>System.out.println(<span class="hljs-string">&quot;run test .....&quot;</span>);<br>Assert.assertEquals(<span class="hljs-string">&quot;hi&quot;</span>,<span class="hljs-string">&quot;hi&quot;</span>);<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>执行测试命令</strong></p><p><strong><font color="red"> mvn test</font></strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220226225016.png"></p><p>本地仓库位置：<br>默认在 ~/.m2/respository 下<br>修改 ${M2_HOME}/conf/settings.xml  来指定仓库目录</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 指定本地仓库目录--&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">localRepository</span>&gt;</span>G:\.m2\repository<span class="hljs-tag">&lt;/<span class="hljs-name">localRepository</span>&gt;</span><br></code></pre></td></tr></table></figure><p> <strong>配置文件以  ~/.m2/settings.xml 为主（优先级大于  ${M2_HOME}/conf/settings.xml ）</strong></p><h3 id="2-maven-核心配置"><a href="#2-maven-核心配置" class="headerlink" title="2. maven 核心配置"></a>2. maven 核心配置</h3><h4 id="2-1-项目依懒"><a href="#2-1-项目依懒" class="headerlink" title="2.1 项目依懒"></a>2.1 项目依懒</h4><p> 项目依赖是指 maven 通过依赖传播、依赖优先原则、可选依赖、排除依赖、依赖范围等特性来管理项目 ClassPath。</p><h5 id="依赖传播特性"><a href="#依赖传播特性" class="headerlink" title="依赖传播特性"></a>依赖传播特性</h5><p> 项目通常需要依赖第三方组件，而第三方组件又会依赖其它组件，遇到这种情况 Maven 会将依赖网络中的所有节点都会加入ClassPath当中，这就是Maven的依赖传播特性。</p><p>Spring MVC 的依赖网络：<br> <figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"> <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220227121810.png"></p><p>项目直接依赖了spring-webmvc 叫<strong>直接依赖</strong>，而对commons-logging 依赖是通过 webmvc 传递的所以叫<strong>间接依赖</strong>。</p><h5 id="依赖优先原则"><a href="#依赖优先原则" class="headerlink" title="依赖优先原则"></a>依赖优先原则</h5><p>基于依赖传播特性，导致整个依赖网络会很复杂，难免会出现相同组件不同版本的情况。Maven 此时会基于依赖优先原则选择其中一个版本。</p><p>第一原则：最短路径优先。<br>第二原则：相同路径下配置在前的优先（非同一 pom 引入）。</p><p>添加 commons-logging 依赖</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>1.2<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220227125217.png"></p><p>spring-webmvc 中引入 1.1.3 版本 commons-logging ，而项目中直接依赖了1.2 版本时，基于最短路径原则项目最终引入的是1.2 版本。</p><p><strong>注意</strong>：在同一pom文件，配置同一依赖的不同版本，以配置在后面的版本为准。</p><h5 id="可选依赖"><a href="#可选依赖" class="headerlink" title="可选依赖"></a>可选依赖</h5><p>可选依赖表示这个依赖不是必须的，通过在 &lt;dependency&gt; 添  &lt;optional&gt;true&lt;/optional&gt; 表示。默认是不可选的。</p><p>可选依赖不会被传递。</p><h5 id="排除依赖"><a href="#排除依赖" class="headerlink" title="排除依赖"></a>排除依赖</h5><p>即排除指定的间接依赖。通过配置 &lt;exclusions&gt; 配置排除指定组件。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.springframework<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>spring-webmvc<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.0.4.RELEASE<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">exclusions</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">exclusion</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>commons-logging<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">exclusion</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">exclusions</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="依赖范围"><a href="#依赖范围" class="headerlink" title="依赖范围"></a>依赖范围</h5><p>像 junit 只有在运行测试用例的时候去要用到，也就是没有必要在打包的时候把 junit.jar 包过构建进去。<br>可以通过 Mave 的依赖范围配置 &lt;scope&gt; 来达到这种目的。</p><p>maven 总共支持以下四种依赖范围：</p><ul><li>compile(默认): 编译范围，编译和打包都会依赖。</li><li>provided：提供范围，编译时依赖，但不会打包进去。如：servlet-api.jar</li><li>runtime：运行时范围，打包时依赖，编译不会。如：mysql-connector-java.jar</li><li>test：测试范围，编译运行测试用例依赖，不会打包进去。如：junit.jar</li><li>system：表示由系统中 CLASSPATH 指定。编译时依赖，不会打包进去。配合 &lt;systemPath&gt; 一起使用。</li></ul><p>例：java.home下的tool.jar</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>com.sun<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>tools<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>$&#123;java.version&#125;<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">scope</span>&gt;</span>system<span class="hljs-tag">&lt;/<span class="hljs-name">scope</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">optional</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">optional</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">systemPath</span>&gt;</span>$&#123;java.home&#125;/../lib/tools.jar<span class="hljs-tag">&lt;/<span class="hljs-name">systemPath</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220227154002.png"></p><p>system 除了可以用于引入系统 classpath 中包，也可以用于引入系统非 maven  收录的第三方Jar，做法是将第三方Jar放置在项目的 lib 目录下，然后配置 相对路径，但因 system 不会打包进去所以需要配合 maven-dependency-plugin 插件配合使用。当然还是推荐通过将第三方 Jar 手动 install 到仓库。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220227163955.png"></p><p><strong>通过插件将 system 的 jar 打包进去</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>  <span class="hljs-tag">&lt;<span class="hljs-name">plugins</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-war-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>3.2.0<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">failOnMissingWebXml</span>&gt;</span>false<span class="hljs-tag">&lt;/<span class="hljs-name">failOnMissingWebXml</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br><br>    <span class="hljs-comment">&lt;!-- 通过插件 将system 的jar 打包进去。 --&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">plugin</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>org.apache.maven.plugins<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>maven-dependency-plugin<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>2.10<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>      <span class="hljs-tag">&lt;<span class="hljs-name">executions</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">execution</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>copy-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">phase</span>&gt;</span>compile<span class="hljs-tag">&lt;/<span class="hljs-name">phase</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">goals</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">goal</span>&gt;</span>copy-dependencies<span class="hljs-tag">&lt;/<span class="hljs-name">goal</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">goals</span>&gt;</span><br>          <span class="hljs-tag">&lt;<span class="hljs-name">configuration</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">outputDirectory</span>&gt;</span>$&#123;project.build.directory&#125;/$&#123;project.build.finalName&#125;/WEB-INF/lib<span class="hljs-tag">&lt;/<span class="hljs-name">outputDirectory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includeScope</span>&gt;</span>system<span class="hljs-tag">&lt;/<span class="hljs-name">includeScope</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">excludeGroupIds</span>&gt;</span>com.sun<span class="hljs-tag">&lt;/<span class="hljs-name">excludeGroupIds</span>&gt;</span><br>          <span class="hljs-tag">&lt;/<span class="hljs-name">configuration</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">execution</span>&gt;</span><br>      <span class="hljs-tag">&lt;/<span class="hljs-name">executions</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">plugin</span>&gt;</span><br>  <span class="hljs-tag">&lt;/<span class="hljs-name">plugins</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220227163811.png"></p><p><strong>手动加入本地仓库</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">mvn install:install-file -Dfile=localJar-1.0.jar -DgroupId=com.zth  -DartifactId=localJar -Dversion=1.0 -Dpackaging=jar<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220227164849.png"></p><h4 id="2-2-项目聚合与继承"><a href="#2-2-项目聚合与继承" class="headerlink" title="2.2 项目聚合与继承"></a>2.2 项目聚合与继承</h4><h5 id="聚合"><a href="#聚合" class="headerlink" title="聚合"></a>聚合</h5><p>是指将多个模块整合在一起，统一构建。聚合需要在父工程中使用 &lt;modules&gt; 进行配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">modules</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>module1<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">module</span>&gt;</span>module2<span class="hljs-tag">&lt;/<span class="hljs-name">module</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">modules</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h5><p>继承是指子工程直接继承父工程中的属性、依赖、插件等配置，避免重复配置。</p><ul><li>.属性继承</li><li>依赖继承</li><li>.插件继承</li></ul><p>上面的三个配置子工程都可以进行重写，重写之后以子工程的为准。</p><h5 id="依赖管理"><a href="#依赖管理" class="headerlink" title="依赖管理"></a>依赖管理</h5><p>通过继承的特性，子工程是可以间接依赖父工程的依赖，但多个子工程依赖有时并不一致，这时就可以在父工程中加入 &lt;dependencyManagement&gt; 声明该功程需要的JAR包，然后在子工程中引入。</p><p>父工程中声明：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencyManagement</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">version</span>&gt;</span>4.12<span class="hljs-tag">&lt;/<span class="hljs-name">version</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencyManagement</span>&gt;</span><br></code></pre></td></tr></table></figure><p>子工程中引入 :</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">dependencies</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">dependency</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">groupId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">groupId</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">artifactId</span>&gt;</span>junit<span class="hljs-tag">&lt;/<span class="hljs-name">artifactId</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">dependency</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">dependencies</span>&gt;</span><br></code></pre></td></tr></table></figure><h5 id="项目属性"><a href="#项目属性" class="headerlink" title="项目属性"></a>项目属性</h5><p><a href="https://www.jianshu.com/p/82233bdc917c">maven 属性</a></p><p>通过 &lt;properties&gt; 配置 属性参数，可以简化配置。</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-comment">&lt;!-- 配置proName属性 --&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">properties</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">proName</span>&gt;</span>ddd<span class="hljs-tag">&lt;/<span class="hljs-name">proName</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">properties</span>&gt;</span><br></code></pre></td></tr></table></figure><p>引用方式<br>${proName}</p><h4 id="2-3-项目构建配置"><a href="#2-3-项目构建配置" class="headerlink" title="2.3 项目构建配置"></a>2.3 项目构建配置</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">build</span>&gt;</span><br>    <span class="hljs-tag">&lt;<span class="hljs-name">resources</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/java<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.MF<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*.XML<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>        <span class="hljs-tag">&lt;<span class="hljs-name">resource</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">directory</span>&gt;</span>src/main/resources<span class="hljs-tag">&lt;/<span class="hljs-name">directory</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">includes</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>**/*<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>                <span class="hljs-tag">&lt;<span class="hljs-name">include</span>&gt;</span>*<span class="hljs-tag">&lt;/<span class="hljs-name">include</span>&gt;</span><br>            <span class="hljs-tag">&lt;/<span class="hljs-name">includes</span>&gt;</span><br>            <span class="hljs-tag">&lt;<span class="hljs-name">filtering</span>&gt;</span>true<span class="hljs-tag">&lt;/<span class="hljs-name">filtering</span>&gt;</span><br>        <span class="hljs-tag">&lt;/<span class="hljs-name">resource</span>&gt;</span><br>    <span class="hljs-tag">&lt;/<span class="hljs-name">resources</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">build</span>&gt;</span><br></code></pre></td></tr></table></figure><p>说明：<br>  resources，build过程中涉及的资源文件</p><ul><li>targetPath：资源文件的目标路径</li><li>directory：资源文件的路径，默认位于 ${basedir}/src/main/resources/ 目录下</li><li>includes：一组文件名的匹配模式，被匹配的资源文件将被构建过程处理</li><li>excludes：一组文件名的匹配模式，被匹配的资源文件将被构建过程忽略。同时被 includes 和 excludes 匹配的资源文件，将被忽略。</li><li>filtering： 默认false 。true 表示通过参数对资源文件中的 ${key} 在编译时进行动态变更。替换源可以 -Dkey 和 pom 中的 &lt;properties&gt; 值 或  &lt;filters&gt; 中指定的 properties 文件。</li></ul>]]></content>
    
    
    <categories>
      
      <category>maven</category>
      
    </categories>
    
    
    <tags>
      
      <tag>maven</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git——搭建私有Git服务</title>
    <link href="/2022/02/23/Git%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89Git%E6%9C%8D%E5%8A%A1/"/>
    <url>/2022/02/23/Git%E2%80%94%E2%80%94%E6%90%AD%E5%BB%BA%E7%A7%81%E6%9C%89Git%E6%9C%8D%E5%8A%A1/</url>
    
    <content type="html"><![CDATA[<h3 id="1-git-支持的四种通信协议"><a href="#1-git-支持的四种通信协议" class="headerlink" title="1. git 支持的四种通信协议"></a>1. git 支持的四种通信协议</h3><ul><li>Local(本地协议)</li><li>ssh</li><li>http(Dumb、Smart)</li><li>git</li></ul><h4 id="1-1-Local-本地协议"><a href="#1-1-Local-本地协议" class="headerlink" title="1. 1 Local(本地协议)"></a>1. 1 Local(本地协议)</h4><p> 基于本地文件系统或共享（NFS）文件系统进行访问.</p><p>优点：简单，直接使用了现有的文件权限和网络访问权限。<br>缺点：这种协议的缺陷就是共享文件系统本身的局限，只能在局域网，而且速度也慢。<br>适应场景：小团队，小项目临时搭建版本服务。</p><ol><li>从本地 f/git/atals 目录克隆项目，即使是 bare仓库也可以正常下载。</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> /f/git/atals/<br></code></pre></td></tr></table></figure><ol start="2"><li>基于 file 协议克隆本地项目<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> file:///f/git/atals/<br></code></pre></td></tr></table></figure>如果在 URL 开头明确的指定 file://，那么 Git 的行为会略有不同。 如果仅是指定路径，Git 会尝试使用硬链接（hard link）或直接复制所需要的文件。 如果指定 file://，Git 会触发平时用于网路传输资料的进程，传输过来的是打包好的文件（git gc），更节约硬盘空间。</li></ol><h4 id="1-2-ssh-协议"><a href="#1-2-ssh-协议" class="headerlink" title="1.2 ssh 协议"></a>1.2 ssh 协议</h4><p>git 支持利用 ssh 协议进行通信，这是绝大部分 linux、uninx 系统都支持的，所以利用该协议架 设GIT 版本服务是非常方便的。</p><p>优点：首先SSH 架设相对简单、其次通过 SSH 访问是安全的、另外SSH 协议很高效，在传输前也会尽量压缩数据。<br>缺点：权限体系不灵活，必须提供操作系统的帐户密码，哪怕是只需要读取版本。<br>适应场景：小团队、小项目、临时项目</p><h5 id="linux-安装-git-服务"><a href="#linux-安装-git-服务" class="headerlink" title="linux 安装 git 服务"></a>linux 安装 git 服务</h5><ol><li>安装依赖环境</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">yum -y install curl-devel expat-devel gettext-devel openssl-devel zlib-devel gcc perl-ExtUtils-MakeMaker<br></code></pre></td></tr></table></figure><ol start="2"><li>下载并解压源码</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">$ wget https://github.com/git/git/archive/v2.3.0.zip<br>$ unzip v2.3.0.zip<br>$ <span class="hljs-built_in">cd</span> git-2.3.0<br></code></pre></td></tr></table></figure><p>备用下载链接: <a href="https://pan.baidu.com/s/1czwEz8">https://pan.baidu.com/s/1czwEz8</a> 密码: y3hn</p><ol start="3"><li>编译安装（如果没有权限就加上sudo）<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">make prefix=/usr/<span class="hljs-built_in">local</span>/git all<br>make prefix=/usr/<span class="hljs-built_in">local</span>/git install<br></code></pre></td></tr></table></figure></li><li>添加环境变量</li></ol><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs sh">vim /etc/profile<br><span class="hljs-built_in">export</span> PATH=/usr/<span class="hljs-built_in">local</span>/git/bin:<span class="hljs-variable">$PATH</span><br><span class="hljs-built_in">source</span> /etc/profile<br></code></pre></td></tr></table></figure><p>#如果成功显示版本号表示添加成功</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">git --version<br>git version 2.3.0<br></code></pre></td></tr></table></figure><h5 id="测试-ssh-协议"><a href="#测试-ssh-协议" class="headerlink" title="测试 ssh 协议"></a>测试 ssh 协议</h5><p>#创建一个祼项目</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git --bare init debuggingworld.git<br></code></pre></td></tr></table></figure><p>#本地基于远程克隆仓库</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">git <span class="hljs-built_in">clone</span> root@192.168.60.10:/data/git-repository/debuggingworld.git<br></code></pre></td></tr></table></figure><p>可能的错误：<br>git-upload-pack: command not found<br>原因是 ssh 协议下只能访问/usr/bin 下的目录，解决办法如下：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">ln -s /usr/<span class="hljs-built_in">local</span>/git/bin/git-upload-pack /usr/bin/git-upload-pack<br>ln -s /usr/<span class="hljs-built_in">local</span>/git/bin/git-receive-pack /usr/bin/git-receive-pack<br></code></pre></td></tr></table></figure><h4 id="3-http-Dumb、Smart"><a href="#3-http-Dumb、Smart" class="headerlink" title="3. http(Dumb、Smart)"></a>3. http(Dumb、Smart)</h4><p>Git http 协议实现是依懒 WEB容器(apache、nginx)及 cgi 组件进行通信交互，并利用 WEB 容器本身权限体系进行授权验证。在 Git 1.6.6  前只支持http Dumb（哑）协议，该协议只能下载不能提交，通常会配合 ssh 协议一起使用，ssh 分配提交帐号，http dumb 提供只读帐号。1.6.6 之后 git 提供了 git-http-backend 的 CGI 用于实现接收远程推送等功能。</p><p>优点：解决了 local 与ssh 权限验证单一的问题、可基于http url 提供匿名服务，从而可以放到公网上去。而 local 与 ssh 是很难做到这一点，比如实现一个类似github 这样的网站。<br>缺点：架设复杂一些需要部署 WEB服务器，和 https 证书之类的配置<br>场景：大型团队、需要对权限精准控制、需要把服务部署到公网上去</p><h5 id="http-Dumb-配置与使用"><a href="#http-Dumb-配置与使用" class="headerlink" title="http Dumb 配置与使用"></a>http Dumb 配置与使用</h5><ol><li>创建服务端版本仓库<figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> /data/git-repository<br>git --bare init debuggingworld.git<br><span class="hljs-built_in">cd</span> debuggingworld.git/hooks/<br>// 版本更新钩子，当有版本提交的时候会执行更新<br>mv post-update.sample post-update<br>./post-update<br></code></pre></td></tr></table></figure></li><li>nginx 静态访问配置</li></ol><figure class="highlight nginx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs nginx"><span class="hljs-section">server</span> &#123;<br>        <span class="hljs-attribute">listen</span>       <span class="hljs-number">80</span>;<br>        <span class="hljs-attribute">server_name</span>  git.tl.com;<br>        <span class="hljs-attribute">location</span> / &#123;<br>            <span class="hljs-attribute">root</span>  /data/git-repository;<br>        &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>本地克隆远程服务<br>git clone <a href="http://git.tl.com/debuggingworld.git">http://git.tl.com/debuggingworld.git</a></p><p>注：http  Smart 协议 是基于  CGI 配合GIT  git-http-backend 脚本进行使用，配置较复杂，现在一般不会这么去做，而是采用gitlab 、gogs 之类的web管理进行代替。</p><h4 id="4-GIT-协议"><a href="#4-GIT-协议" class="headerlink" title="4. GIT 协议"></a>4. GIT 协议</h4><p>Git 协议是包含在 Git 里的一个特殊的守护进程；它监听在一个特定的端口（9418），类似于 SSH 服务，但是访问无需任何授权。</p><p>优点：Git 协议是 Git 使用的网络传输协议里最快的。 如果你的项目有很大的访问量，或者你的项目很庞大并且不需要为写进行用户授权，架设 Git 守护进程来提供服务是不错的选择。 它使用与 SSH 相同的数据传输机制，但是省去了加密和授权的开销。</p><p>缺点：Git 协议缺点是缺乏授权机制。 而且9418是一个非标准端口，一般防火墙不会开放。</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">cd</span> debuggingworld.git/<br><span class="hljs-comment"># 创建一个空文件，表示开放该项目</span><br>touch git-daemon-export-ok<br><span class="hljs-comment"># 启动守护进程</span><br><span class="hljs-variable">$nohub</span> git daemon --reuseaddr --base-path=/data/git-repository/ /data/git-repository/ &amp;<br><br></code></pre></td></tr></table></figure><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#本地克隆远程项目</span><br>git <span class="hljs-built_in">clone</span> git://192.168.0.147:9418/debuggingworld.git<br></code></pre></td></tr></table></figure><h3 id="2-基于-gogs-搭建私有-GIT-服务"><a href="#2-基于-gogs-搭建私有-GIT-服务" class="headerlink" title="2. 基于 gogs 搭建私有 GIT 服务"></a>2. 基于 gogs 搭建私有 GIT 服务</h3><h4 id="2-1-gogs-介绍安装"><a href="#2-1-gogs-介绍安装" class="headerlink" title="2.1 gogs 介绍安装"></a>2.1 gogs 介绍安装</h4><p>Gogs 是一款开源的轻量级 Git web 服务，其特点是简单易用完档齐全、国际化做的相当不错。其主要功能如下:</p><ol><li>提供 Http 与 ssh 两种协议访问源码服务</li><li>提供可 WEB 界面可查看修改源码代码</li><li>提供较完善的权限管理功能、其中包括组织、团队、个人等仓库权限</li><li>提供简单的项目 viki 功能</li><li>提供工单管理与里程碑管理。</li></ol><p>下载安装<br>官网：<a href="https://gogs.io/">https://gogs.io</a><br>下载：<a href="https://gogs.io/docs/installation">https://gogs.io/docs/installation</a> 选择 linx amd64 下载安装<br>文档：<a href="https://gogs.io/docs/installation/install_from_binary">https://gogs.io/docs/installation/install_from_binary</a></p><p>解压之后目录：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220223231024.png"></p><p>运行：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#前台运行</span><br>./gogs web<br><span class="hljs-comment">#后台运行</span><br><span class="hljs-variable">$nohup</span> ./gogs web &amp;<br></code></pre></td></tr></table></figure><p>默认端口：3000</p><p>初次访问http://<host>:3000 会进到初始化页,进行引导配置。</p><p>可选择mysql 或sqlite 等数据。<br>注：mysql 索引长度的问题没有安装成功,需要用mysql5.7 以上版本。</p><h4 id="2-2-gogs-定时备份与恢复"><a href="#2-2-gogs-定时备份与恢复" class="headerlink" title="2.2 gogs 定时备份与恢复"></a>2.2 gogs 定时备份与恢复</h4><p>备份与恢复：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-comment">#查看备份相关参数</span><br>./gogs backup -h<br><span class="hljs-comment">#默认备份,备份在当前目录</span><br>./gogs backup <br><span class="hljs-comment">#参数化备份  --target 输出目录 --database-only 只备份 db </span><br>./gogs backup --target=./backupes --database-only --exclude-repos<br><span class="hljs-comment">#恢复。执行该命令前要先删除 custom.bak</span><br>./gogs restore --from=gogs-backup-20180411062712.zip<br></code></pre></td></tr></table></figure><p>#自动备份脚本</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-meta">#!/bin/sh -e</span><br>gogs_home=<span class="hljs-string">&quot;/home/apps/svr/gogs/&quot;</span><br>backup_dir=<span class="hljs-string">&quot;<span class="hljs-variable">$gogs_home</span>/backups&quot;</span><br><br><span class="hljs-built_in">cd</span> `dirname <span class="hljs-variable">$0</span>`<br><span class="hljs-comment"># 执行备份命令</span><br>./gogs backup --target=<span class="hljs-variable">$backup_dir</span><br><br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;backup sucess&#x27;</span><br>day=7<br><span class="hljs-comment">#查找并删除 7天前的备份  </span><br>find <span class="hljs-variable">$backup_dir</span> -name <span class="hljs-string">&#x27;*.zip&#x27;</span> -mtime +7 -<span class="hljs-built_in">type</span> f |xargs rm -f;<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&#x27;delete expire back data!&#x27;</span><br><br><span class="hljs-comment">#添加定时任务 每天4：00执行备份</span><br><span class="hljs-comment"># 打开任务编辑器</span><br>crontab -e<br><span class="hljs-comment"># 输入如下命令 00 04 * * * 每天凌晨4点执行 do-backup.sh 并输出日志至 #backup.log</span><br>00 04 * * * /home/apps/svr/gogs/do-backup.sh &gt;&gt; /home/apps/svr/gogs/backup.log 2&gt;&amp;1<br></code></pre></td></tr></table></figure><h4 id="2-3-客户端公钥配置与添加"><a href="#2-3-客户端公钥配置与添加" class="headerlink" title="2.3 客户端公钥配置与添加"></a>2.3 客户端公钥配置与添加</h4><p>SSH公钥创建<br>1、打开git bash<br>2、执行生成公钥和私钥的命令：ssh-keygen -t rsa 并按回车3下<br>3、执行查看公钥的命令：cat ~/.ssh/id_rsa.pub<br>4、拷贝id_rsa.pub 内容至至服务~~/.ssh/authorized_keys 中</p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git——reset的三种模式</title>
    <link href="/2022/02/22/Git%E2%80%94%E2%80%94reset%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/"/>
    <url>/2022/02/22/Git%E2%80%94%E2%80%94reset%E7%9A%84%E4%B8%89%E7%A7%8D%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-reset-的三种模式"><a href="#1-reset-的三种模式" class="headerlink" title="1. reset 的三种模式"></a>1. reset 的三种模式</h3><ul><li><p>–hard：stage区和工作目录里的内容会被完全重置为和指定 HEAD 位置相同的内容。</p></li><li><p>–soft：保留工作目录和暂存区中未提交的内容，并把重置 HEAD 所带来的新的差异（回滚掉的commit较回滚后最新commit的修改）放进暂存区。</p></li><li><p>–mixed（默认）：工作区、暂存区未提交的内容以及由 reset 所导致的新差异，都会被放进工作区。</p></li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220222220108.png"></p><h3 id="2-reset-–hard"><a href="#2-reset-–hard" class="headerlink" title="2. reset –hard"></a>2. reset –hard</h3><p>重置 stage 区和工作目录（慎用）。</p><p>在 reset 后面加 –hard 参数时，stage 区和工作目录里的内容会被完全重置为和指定 HEAD 位置相同的内容。也就是没有 commit 的修改会被全部擦掉。执行后工作区、暂存区、版本库保持一致（指定HEAD版本）</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git status<br>On branch master<br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)<br>  (use <span class="hljs-string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="hljs-keyword">in</span> working directory)<br>        modified:   aa.txt<br><br>no changes added to commit (use <span class="hljs-string">&quot;git add&quot;</span> and/or <span class="hljs-string">&quot;git commit -a&quot;</span>)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git <span class="hljs-built_in">log</span><br>commit 79ed69f7fdeb3474c36fa111ee82ef067575ad83 (HEAD -&gt; master)<br>Author: Zhangtao153 &lt;13289265979@163.com&gt;<br>Date:   Wed Nov 25 21:19:27 2020 +0800<br><br>    bb<br><br>commit d40163567818b2ac0b28743058ff9c68a7798390<br>Author: Zhangtao153 &lt;13289265979@163.com&gt;<br>Date:   Wed Nov 25 21:19:03 2020 +0800<br><br>    aa<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git reset --hard HEAD^<br>HEAD is now at d401635 aa<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git <span class="hljs-built_in">log</span><br>commit d40163567818b2ac0b28743058ff9c68a7798390 (HEAD -&gt; master)<br>Author: Zhangtao153 &lt;13289265979@163.com&gt;<br>Date:   Wed Nov 25 21:19:03 2020 +0800<br><br>    aa<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git status<br>On branch master<br>nothing to commit, working tree clean<br></code></pre></td></tr></table></figure><h3 id="3-reset-–soft"><a href="#3-reset-–soft" class="headerlink" title="3. reset –soft"></a>3. reset –soft</h3><p>保留工作目录和暂存区中未提交的内容，并把重置 HEAD 所带来的新的差异（回滚掉的commit较回滚后最新commit的修改）放进暂存区。</p><p>可以使用 Soft Reset 合并「当前节点」与「reset目标节点」之间不具太大意义的 commit 记录，让 commit 演进线图较为清晰点。</p><p>【示例】工作区添加新文件后reset </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git <span class="hljs-built_in">log</span><br>commit 82ad83fcfcfb366ab7a895053f9b8936aaabf6cf (HEAD -&gt; master)<br>Author: Zhangtao153 &lt;13289265979@163.com&gt;<br>Date:   Wed Nov 25 21:39:37 2020 +0800<br><br>    bb<br><br>commit d40163567818b2ac0b28743058ff9c68a7798390<br>Author: Zhangtao153 &lt;13289265979@163.com&gt;<br>Date:   Wed Nov 25 21:19:03 2020 +0800<br><br>    aa<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git status<br>On branch master<br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br>        bb.txt<br><br>nothing added to commit but untracked files present (use <span class="hljs-string">&quot;git add&quot;</span> to track)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git reset --soft HEAD^<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git <span class="hljs-built_in">log</span><br>commit d40163567818b2ac0b28743058ff9c68a7798390 (HEAD -&gt; master)<br>Author: Zhangtao153 &lt;13289265979@163.com&gt;<br>Date:   Wed Nov 25 21:19:03 2020 +0800<br><br>    aa<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git status<br>On branch master<br>Changes to be committed:<br>  (use <span class="hljs-string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)<br>        modified:   aa.txt<br><br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br>        bb.txt<br></code></pre></td></tr></table></figure><h3 id="4-reset-不加参数-mixed"><a href="#4-reset-不加参数-mixed" class="headerlink" title="4. reset 不加参数(mixed)"></a>4. reset 不加参数(mixed)</h3><p>工作区、暂存区未提交的内容以及由 reset 所导致的新差异，都会被放进工作区。简而言之，就是「把所有差异都混合（mixed）放在工作目录中」。</p><p>【例】工作区修改后添加到暂存区，在工作区添加新文件后reset</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git status<br>On branch master<br>Changes to be committed:<br>  (use <span class="hljs-string">&quot;git restore --staged &lt;file&gt;...&quot;</span> to unstage)<br>        modified:   aa.txt<br><br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br>        bb.txt<br><br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git reset HEAD^<br>Unstaged changes after reset:<br>M       aa.txt<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/tmp/<span class="hljs-built_in">test</span> (master)<br>$ git status<br>On branch master<br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)<br>  (use <span class="hljs-string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="hljs-keyword">in</span> working directory)<br>        modified:   aa.txt<br><br>Untracked files:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to include <span class="hljs-keyword">in</span> what will be committed)<br>        bb.txt<br><br>no changes added to commit (use <span class="hljs-string">&quot;git add&quot;</span> and/or <span class="hljs-string">&quot;git commit -a&quot;</span>)<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git——底层原理</title>
    <link href="/2022/02/20/Git%E2%80%94%E2%80%94%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/"/>
    <url>/2022/02/20/Git%E2%80%94%E2%80%94%E5%BA%95%E5%B1%82%E5%8E%9F%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="1-GIT-存储对像"><a href="#1-GIT-存储对像" class="headerlink" title="1. GIT 存储对像"></a>1. GIT 存储对像</h3><p>Git 是一个内容寻址文件系统，其核心部分是一个简单的键值对数据库（key-value data store），可以向数据库中插入任意内容，它会返回一个用于取回该值的hash 键。</p><p>git 键值库中插入数据：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;hello debuggingWorld&quot;</span> | git hash-object -w --stdin<br>cfd6e024dbae18ef2b3231ddd0374286bd2fe650<br></code></pre></td></tr></table></figure><p>git 基于键获取指定内容:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git cat-file -p cfd6e024dbae18ef2b3231ddd0374286bd2fe650<br>hello debuggingWorld<br></code></pre></td></tr></table></figure><p>Git 基于该功能 把每个文件的版本中内容都保存在数据库中，当要进行版本回滚的时候就通过其中一个键将期取回并替换。</p><p>所以平常用的 git add 其实就是把修改之后的内容插入到键值库中。当执行 git add README.md 等同于执行了 git hash-object -w README.md 把文件写到数据库中。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220220222727.png"></p><p>【问题】解决了存储的问题，但其只能存储内容同并没有存储文件名，如果要进行回滚怎么知道哪个内容对应哪个文件呢？树对象解决的就是文件名存储的问题 。</p><h3 id="2-树对像"><a href="#2-树对像" class="headerlink" title="2. 树对像"></a>2. 树对像</h3><p>树对像解决了文件名的问题，它的目的将多个文件名组织在一起，其内包含多个文件名称与其对应的Key和其它树对像的用引用。可以理解成操作系统当中的文件夹，一个文件夹包含多个文件和多个其它文件夹。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220220223413.png"></p><p>每一个分支当中都关联了一个树对像，存储了当前分支下所有的文件名及对应的 key。</p><p>#查看分支树<br> git cat-file -p master^{tree}[或 commitId]</p><p> <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220220234038.png"></p><h3 id="3-git-提交对象"><a href="#3-git-提交对象" class="headerlink" title="3. git 提交对象"></a>3. git 提交对象</h3><p> 一次提交即为当前版本的一个快照，该快照就是通过提交对像保存，其存储的内容为：一个顶级树对象、上一次提交的对像啥希、提交者用户名及邮箱、提交时间戳、提交评论。</p><p> <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220221000048.png"></p><p> 通过上面的知识，可以推测出从修改一个文件到提交的过程总共生成了三个对像：<br>一个内容对象 ==&gt; 存储了文件内容<br>一个树对像 ==&gt; 存储了文件名及内容对像的key<br>一个提交对像 ==&gt; 存储了树对像的key 及提交评论。 </p><h4 id="4-git-引用"><a href="#4-git-引用" class="headerlink" title="4.git 引用"></a>4.git 引用</h4><p>git 总共 有三种类型的引用：</p><ul><li>分支引用</li><li>远程分支引用</li><li>标签引用</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220221000853.png"></p><p>当执行 git branch {branchName} 时创建了一个分支，其本质就是 git 基于指定提交创建了一个引用文件，保存在 .git\refs\heads\ 下。</p><p>如 .git/refs/heads/master 文件保存的是 master 分支的引用</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220221000348.png"></p><p>创建 dev 分支：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220221000508.png"></p><p>/.git/refs/tags 保存的是标签引用</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220221001122.png"></p>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git——rebase命令</title>
    <link href="/2022/02/17/Git%E2%80%94%E2%80%94rebase%E5%91%BD%E4%BB%A4/"/>
    <url>/2022/02/17/Git%E2%80%94%E2%80%94rebase%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h3 id="1-应用场景"><a href="#1-应用场景" class="headerlink" title="1. 应用场景"></a>1. 应用场景</h3><ul><li>合并多次提交记录</li><li>分支合并</li><li>对一个分支做『变基』操作</li></ul><h3 id="2-合并多次提交记录"><a href="#2-合并多次提交记录" class="headerlink" title="2. 合并多次提交记录"></a>2. 合并多次提交记录</h3><p>合并最近两次 commit:</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git rebase -i HEAD~2<br></code></pre></td></tr></table></figure><p>执行命令后会自动进入 vi 编辑模式：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs bash">pick 6935383 rename冲突<br>pick 23b1a51 debug<br><br><span class="hljs-comment"># Rebase eb7f366..23b1a51 onto eb7f366 (2 commands)</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Commands:</span><br><span class="hljs-comment"># p, pick &lt;commit&gt; = use commit</span><br><span class="hljs-comment"># r, reword &lt;commit&gt; = use commit, but edit the commit message</span><br><span class="hljs-comment"># e, edit &lt;commit&gt; = use commit, but stop for amending</span><br><span class="hljs-comment"># s, squash &lt;commit&gt; = use commit, but meld into previous commit</span><br><span class="hljs-comment"># f, fixup &lt;commit&gt; = like &quot;squash&quot;, but discard this commit&#x27;s log message</span><br><span class="hljs-comment"># x, exec &lt;command&gt; = run command (the rest of the line) using shell</span><br><span class="hljs-comment"># b, break = stop here (continue rebase later with &#x27;git rebase --continue&#x27;)</span><br><span class="hljs-comment"># d, drop &lt;commit&gt; = remove commit</span><br><span class="hljs-comment"># l, label &lt;label&gt; = label current HEAD with a name</span><br><span class="hljs-comment"># t, reset &lt;label&gt; = reset HEAD to a label</span><br><span class="hljs-comment"># m, merge [-C &lt;commit&gt; | -c &lt;commit&gt;] &lt;label&gt; [# &lt;oneline&gt;]</span><br><span class="hljs-comment"># .       create a merge commit using the original merge commit&#x27;s</span><br><span class="hljs-comment"># .       message (or the oneline, if no original merge commit was</span><br><span class="hljs-comment"># .       specified). Use -c &lt;commit&gt; to reword the commit message.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># These lines can be re-ordered; they are executed from top to bottom.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># If you remove a line here THAT COMMIT WILL BE LOST.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># However, if you remove everything, the rebase will be aborted.</span><br></code></pre></td></tr></table></figure><blockquote><ul><li>【注】</li><li>p, pick = use commit</li><li>r, reword = use commit, but edit the commit message</li><li>e, edit = use commit, but stop for amending</li><li>s, squash = use commit, but meld into previous commit</li><li>f, fixup = like “squash”, but discard this commit’s log message</li><li>x, exec = run command (the rest of the line) using shell</li><li>d, drop = remove commit</li></ul></blockquote><p>修改提交纪录并保存退出。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">pick 6935383 rename冲突<br>s 23b1a51 debug<br></code></pre></td></tr></table></figure><p>保存后到注释修改界面。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs bash"><span class="hljs-comment"># This is a combination of 2 commits.</span><br><span class="hljs-comment"># This is the 1st commit message:</span><br><br>rename冲突<br><br><span class="hljs-comment"># This is the commit message #2:</span><br><br>debug<br><br><span class="hljs-comment"># Please enter the commit message for your changes. Lines starting</span><br><span class="hljs-comment"># with &#x27;#&#x27; will be ignored, and an empty message aborts the commit.</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># Date:      Tue Nov 24 22:56:02 2020 +0800</span><br><span class="hljs-comment">#</span><br><span class="hljs-comment"># interactive rebase in progress; onto eb7f366</span><br><span class="hljs-comment"># Last commands done (2 commands done):</span><br><span class="hljs-comment">#    pick 6935383 rename冲突</span><br><span class="hljs-comment">#    squash 23b1a51 debug</span><br><span class="hljs-comment"># No commands remaining.</span><br><span class="hljs-comment"># You are currently rebasing branch &#x27;maseter&#x27; on &#x27;eb7f366&#x27;.</span><br></code></pre></td></tr></table></figure><p>（非编辑状态输入dd删除一行）</p><p>保存后即合并完成。</p><blockquote><p> 异常情况：</p><p> 1、不要合并已提交远程分支的纪录</p><p> 如果这样做，可能出现push rejected。 解决方式当然是先拉下远程的代码，进行冲突处理，再进行提交。</p><p> 2、git rebase -i 异常操作导致退出了vim编辑页面，会提示：<br> <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash"> $ git rebase -i head~2<br> error: could not apply 040bd4b... commit on issue-005<br> Resolve all conflicts manually, mark them as resolved with<br><span class="hljs-string">&quot;git add/rm &lt;conflicted_files&gt;&quot;</span>, <span class="hljs-keyword">then</span> run <span class="hljs-string">&quot;git rebase --continue&quot;</span>.<br>You can instead skip this commit: run <span class="hljs-string">&quot;git rebase --skip&quot;</span>.<br>To abort and get back to the state before <span class="hljs-string">&quot;git rebase&quot;</span>, run <span class="hljs-string">&quot;git rebase --abort&quot;</span>.<br>Could not apply 040bd4b... commit on issue-005<br>Auto-merging README.md<br>CONFLICT (content): Merge conflict <span class="hljs-keyword">in</span> README.md<br></code></pre></td></tr></table></figure><br>使用 git rebase –edit-todo 会再次进入刚才编辑错误退出前的vim状态，这时候可以修改你的编辑。</p><p>使用git rebase –abort  表明退出当前的合并请求( 又回到原来的2个commit的状态)</p></blockquote><h3 id="3-变基"><a href="#3-变基" class="headerlink" title="3. 变基"></a>3. 变基</h3><p><font color="red">使用场景：本地与远端同一分支提交历史不一致</font></p><p>多个人在同一个分支上协作时，比如由我和A一同开发。我在修复了一个bug以后准备提交。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git add .<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git commit -m <span class="hljs-string">&quot;debug the world&quot;</span><br>[master a40d43c] debug the world<br> 1 file changed, 0 insertions(+), 0 deletions(-)<br> create mode 100644 aa.txt<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git push origin master<br>To github.com:Zhangtao153/learngit.git<br> ! [rejected]        master -&gt; master (non-fast-forward)<br>error: failed to push some refs to <span class="hljs-string">&#x27;github.com:Zhangtao153/learngit.git&#x27;</span><br>hint: Updates were rejected because the tip of your current branch is behind<br>hint: its remote counterpart. Integrate the remote changes (e.g.<br>hint: <span class="hljs-string">&#x27;git pull ...&#x27;</span>) before pushing again.<br>hint: See the <span class="hljs-string">&#x27;Note about fast-forwards&#x27;</span> <span class="hljs-keyword">in</span> <span class="hljs-string">&#x27;git push --help&#x27;</span> <span class="hljs-keyword">for</span> details.<br></code></pre></td></tr></table></figure><p>push失败了，说明A在我之前已经提交了，我本地master分支的提交历史已经落后远端了，需要先pull一下，与远端同步后才能push</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git pull<br>Merge made by the <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> README.md | 3 ++-<br> 1 file changed, 2 insertions(+), 1 deletion(-)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> --oneline --graph<br>*   912bb85 (HEAD -&gt; master) Merge branch <span class="hljs-string">&#x27;master&#x27;</span> of github.com:Zhangtao153/learngit into master<br>|\<br>| * 7ad4fd6 (origin/master) add a new <span class="hljs-keyword">function</span><br>* | a40d43c debug the world<br>|/<br>* a8d2e0d 手动删除<br>* 1d243ca add <span class="hljs-built_in">test</span> file<br>* 8438389 wrote a readme file<br></code></pre></td></tr></table></figure><p>竟然分叉了！由于我本地master的提交历史和远端的master分支的提交历史不一致，所以git为我进行了自动合并，然后生成了一个新的提交历史。</p><p>这个时候就可以用 git rebase 解决分叉的问题。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git rebase<br>Successfully rebased and updated refs/heads/master.<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> --oneline --graph<br>* 4178b6e (HEAD -&gt; master) debug the world<br>* 7ad4fd6 (origin/master) add a new <span class="hljs-keyword">function</span><br>* a8d2e0d 手动删除<br>* 1d243ca add <span class="hljs-built_in">test</span> file<br>* 8438389 wrote a readme file<br></code></pre></td></tr></table></figure><p>然后再push，将本地修改同步到远端。</p><p><font color="red">git pull –rebase </font> 和上面的效果一致。</p><h3 id="4-合并分支"><a href="#4-合并分支" class="headerlink" title="4. 合并分支"></a>4. 合并分支</h3><p>先创建一个分支用于解决bug</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b issues-001<br>Switched to a new branch <span class="hljs-string">&#x27;issues-001&#x27;</span><br></code></pre></td></tr></table></figure><p>接下解决bug，然后保存提交</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issues-001)<br>$ git add .<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issues-001)<br>$ git commit -m <span class="hljs-string">&quot;issues-001&quot;</span><br>[issues-001 7a55a26] issues-001<br> 1 file changed, 1 insertion(+)<br></code></pre></td></tr></table></figure><p>先尝试通过 <font color="red">merge</font> 合并：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issues-001)<br>$ git switch master<br>Switched to branch <span class="hljs-string">&#x27;master&#x27;</span><br>Your branch is ahead of <span class="hljs-string">&#x27;origin/master&#x27;</span> by 1 commit.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> to publish your <span class="hljs-built_in">local</span> commits)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git merge issues-001<br>Merge made by the <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> aa.txt | 1 +<br> 1 file changed, 1 insertion(+)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> --oneline --graph<br>*   ae02ea0 (HEAD -&gt; master) Merge branch <span class="hljs-string">&#x27;issues-001&#x27;</span> into master<br>|\<br>| * 7a55a26 (issues-001) issues-001<br>* | d36d166 commit on master<br>|/<br>* 4178b6e (origin/master) debug the world<br>* 7ad4fd6 add a new <span class="hljs-keyword">function</span><br>* a8d2e0d 手动删除<br>* 1d243ca add <span class="hljs-built_in">test</span> file<br>* 8438389 wrote a readme file<br></code></pre></td></tr></table></figure><p>虽然合并成功，但是Master已经保存了合并历史，出现开叉了！</p><p>通过 <font color="red">rebase</font> 合并分支</p><p>先将代码回退到merge之前</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git reset --hard HEAD^<br>HEAD is now at d36d166 commit on master<br></code></pre></td></tr></table></figure><p>先切换回issues-001分支，在issues-001分支上执行: git rebase master</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git switch issues-001<br>Switched to branch <span class="hljs-string">&#x27;issues-001&#x27;</span><br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issues-001)<br>$ git rebase master<br>Successfully rebased and updated refs/heads/issues-001.<br></code></pre></td></tr></table></figure><p>【注】如果rebase出现冲突，先解决冲突，然后通过add添加，之前的rebase其实只是完成了一半，由于出现冲突而终止，冲突解决之后，可以通过 <font color="red">git rebase —continue</font> 继续完成之前的 rebase 操作。</p><p>切换到主分支master，将issues-001分支上的提交合并过来。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issues-001)<br>$ git switch master<br>Switched to branch <span class="hljs-string">&#x27;master&#x27;</span><br>Your branch is ahead of <span class="hljs-string">&#x27;origin/master&#x27;</span> by 1 commit.<br>  (use <span class="hljs-string">&quot;git push&quot;</span> to publish your <span class="hljs-built_in">local</span> commits)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git merge issues-001<br>Updating d36d166..43823d4<br>Fast-forward<br> aa.txt | 1 +<br> 1 file changed, 1 insertion(+)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> --oneline --graph<br>* 43823d4 (HEAD -&gt; master, issues-001) issues-001<br>* d36d166 commit on master<br>* 4178b6e (origin/master) debug the world<br>* 7ad4fd6 add a new <span class="hljs-keyword">function</span><br>* a8d2e0d 手动删除<br>* 1d243ca add <span class="hljs-built_in">test</span> file<br>* 8438389 wrote a readme file<br></code></pre></td></tr></table></figure><p>master是一条直线了。最后删除掉issues-001分支。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git branch -d issues-001<br>Deleted branch issues-001 (was 43823d4).<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Git——核心概念与基本操作</title>
    <link href="/2022/02/13/Git%E2%80%94%E2%80%94%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/02/13/Git%E2%80%94%E2%80%94%E6%A0%B8%E5%BF%83%E6%A6%82%E5%BF%B5%E4%B8%8E%E5%9F%BA%E6%9C%AC%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="1-基本概念"><a href="#1-基本概念" class="headerlink" title="1. 基本概念"></a>1. 基本概念</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/07c78b7d376f4c8793b53a43f0a2a7fa.png"></p><ul><li><strong>工作区</strong>：能看到的目录</li><li><strong>暂存区</strong>：stage 或 index。一般存放在 .git/index 中，所以把暂存区有时也叫作索引（index）。</li><li><strong>版本库</strong>：工作区有一个隐藏目录 .git 就是 Git 的版本库。</li></ul><p>文件入库流程：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220213233336.png"></p><blockquote><p> 图中左侧为工作区，右侧为版本库。”index” 为是暂存区（stage/index）， “master” 是 master 分支所代表的目录树。</p><ul><li><p>图中的 objects 标识的区域为 Git 的对象库，实际位于 “.git/objects” 目录下，里面包含了创建的各种对象及内容。</p></li><li><p>当对工作区修改（或新增）的文件执行 git add 命令时，暂存区的目录树被更新，同时工作区修改（或新增）的文件内容被写入到对象库中的一个新的对象中，而该对象的ID被记录在暂存区的文件索引中。</p></li><li><p>当执行提交操作（git commit）时，暂存区的目录树写到版本库（对象库）中，master 分支会做相应的更新。即 master 指向的目录树就是提交时暂存区的目录树。</p></li><li><p>当执行 git reset HEAD 命令时，暂存区的目录树会被重写，被 master 分支指向的目录树所替换，但是工作区不受影响。</p></li><li><p>当执行 git rm –cached  &lt;file&gt; 命令时，会直接从暂存区删除文件，工作区则不做出改变。</p></li><li><p>当执行 git checkout . 或者 git checkout –  &lt;file&gt; 命令时，会用暂存区全部或指定的文件替换工作区的文件。这个操作很危险，会清除工作区中未添加到暂存区的改动。</p></li><li><p>当执行 git checkout HEAD . 或者 git checkout HEAD  &lt;file&gt; 命令时，会用 HEAD 指向的 master 分支中的全部或者部分文件替换暂存区和以及工作区中的文件。这个命令也是极具危险性的，因为不但会清除工作区中未提交的改动，也会清除暂存区中未提交的改动。</p></li></ul></blockquote><h3 id="2-创建版本库"><a href="#2-创建版本库" class="headerlink" title="2. 创建版本库"></a>2. 创建版本库</h3><h4 id="2-1-git-init-初始化仓库"><a href="#2-1-git-init-初始化仓库" class="headerlink" title="2.1  git init 初始化仓库"></a>2.1  git init 初始化仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git init<br>Initialized empty Git repository <span class="hljs-keyword">in</span> G:/learngit/.git/<br></code></pre></td></tr></table></figure><h4 id="2-2-git-add-跟踪文件"><a href="#2-2-git-add-跟踪文件" class="headerlink" title="2.2 git add 跟踪文件"></a>2.2 git add 跟踪文件</h4><p>git add  &lt;directory&gt;  添加指定目录至暂存区<br>git add -A            添加所有<br>git  add  &lt;file&gt;   跟踪指定文件</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git add README.md<br></code></pre></td></tr></table></figure><h4 id="2-3-git-commit-提交到仓库"><a href="#2-3-git-commit-提交到仓库" class="headerlink" title="2.3 git commit 提交到仓库"></a>2.3 git commit 提交到仓库</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git commit -m <span class="hljs-string">&quot;wrote a readme file&quot;</span><br>[master (root-commit) 8438389] wrote a readme file<br> 1 file changed, 2 insertions(+)<br> create mode 100644 README.md<br></code></pre></td></tr></table></figure><h4 id="2-4-git-status-查看-git-状态"><a href="#2-4-git-status-查看-git-状态" class="headerlink" title="2.4 git status 查看 git 状态"></a>2.4 git status 查看 git 状态</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git status<br>On branch master<br>nothing to commit, working directory clean<br></code></pre></td></tr></table></figure><h4 id="2-5-移出暂存区"><a href="#2-5-移出暂存区" class="headerlink" title="2.5 移出暂存区"></a>2.5 移出暂存区</h4><p>git rm –cached target -r<br>将指定目录及子目录移除出暂存区</p><h3 id="3-版本管理"><a href="#3-版本管理" class="headerlink" title="3. 版本管理"></a>3. 版本管理</h3><h4 id="3-1-git-diff-查看修改内容"><a href="#3-1-git-diff-查看修改内容" class="headerlink" title="3.1 git diff 查看修改内容"></a>3.1 git diff 查看修改内容</h4><ul><li>git diff：比较的是工作区和暂存区之间的差异</li><li>git diff HEAD：比较的是工作区和版本库之间的差异</li><li>git diff –cached：比较的是工作区和版本库之间的差异<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git diff README.md<br>diff --git a/README.md b/README.md<br>index d8036c1..013b5bc 100644<br>--- a/README.md<br>+++ b/README.md<br>@@ -1,2 +1,2 @@<br>-Git is a version control system.<br>+Git is a distributed version control system.<br> Git is free software.<br>\ No newline at end of file<br></code></pre></td></tr></table></figure></li></ul><h4 id="3-2-git-reset-回退到上一版本"><a href="#3-2-git-reset-回退到上一版本" class="headerlink" title="3.2 git reset 回退到上一版本"></a>3.2 git reset 回退到上一版本</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reset --hard HEAD^<br>HEAD is now at 8438389 wrote a readme file<br></code></pre></td></tr></table></figure><p>在 Git 中，用 HEAD 表示当前版本，上一个版本就是HEAD^，上上一个版本就是HEAD^^，当然往上100个版本写100个^比较容易数不过来，所以写成HEAD~100。</p><h4 id="3-3-回到回退之前版本"><a href="#3-3-回到回退之前版本" class="headerlink" title="3.3 回到回退之前版本"></a>3.3 回到回退之前版本</h4><p>Git 提供了一个命令 git reflog 用来记录你的每一次命令。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reflog<br>8438389 HEAD@&#123;0&#125;: reset: moving to HEAD^<br>43597ec HEAD@&#123;1&#125;: commit: add distributed<br>8438389 HEAD@&#123;2&#125;: commit (initial): wrote a readme file<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git reset --hard 43597ec<br>HEAD is now at 43597ec add distributed<br></code></pre></td></tr></table></figure><h4 id="3-4-撤销工作区修改"><a href="#3-4-撤销工作区修改" class="headerlink" title="3.4 撤销工作区修改"></a>3.4 撤销工作区修改</h4><p>命令：**<font color="red">git checkout  –  file</font>**</p><p>作用：撤销工作区的全部修改，这里有两种情况：</p><p>一种是readme.txt自修改后还没有被放到暂存区，现在，撤销修改就回到和版本库一模一样的状态；</p><p>一种是readme.txt已经添加到暂存区后，又作了修改，现在，撤销修改就回到添加到暂存区后的状态。</p><p>总之，就是让这个文件回到最近一次git commit或git add时的状态。</p><h4 id="3-5-撤销暂存区修改"><a href="#3-5-撤销暂存区修改" class="headerlink" title="3.5 撤销暂存区修改"></a>3.5 撤销暂存区修改</h4><p>命令： git  reset  HEAD  &lt;file&gt; </p><p>作用：把暂存区的修改回退到工作区。HEAD 表示最新的版本。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git reset HEAD README.md<br>Unstaged changes after reset:<br>M       README.md<br></code></pre></td></tr></table></figure><h4 id="3-6-删除文件"><a href="#3-6-删除文件" class="headerlink" title="3.6 删除文件"></a>3.6 删除文件</h4><p>先手动删除文件，然后使用 git add &lt;file&gt; 的效果和 git rm &lt;file&gt; 是一样的。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git rm test.txt<br>rm <span class="hljs-string">&#x27;test.txt&#x27;</span><br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git status<br>On branch master<br>Changes to be committed:<br>  (use <span class="hljs-string">&quot;git reset HEAD &lt;file&gt;...&quot;</span> to unstage)<br><br>        deleted:    test.txt<br></code></pre></td></tr></table></figure><h3 id="4-远程仓库"><a href="#4-远程仓库" class="headerlink" title="4. 远程仓库"></a>4. 远程仓库</h3><h4 id="4-1-添加远程仓库"><a href="#4-1-添加远程仓库" class="headerlink" title="4.1 添加远程仓库"></a>4.1 添加远程仓库</h4><p>命令：git  remote  add  origin &lt;URL&gt;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$  git remote add origin git@github.com:Zhangtao153/learngit.git<br></code></pre></td></tr></table></figure><h4 id="4-2-推送本地库内容到远程库"><a href="#4-2-推送本地库内容到远程库" class="headerlink" title="4.2 推送本地库内容到远程库"></a>4.2 推送本地库内容到远程库</h4><p>命令：git push origin &lt;branch-name&gt;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push -u origin master<br>Warning: Permanently added the RSA host key <span class="hljs-keyword">for</span> IP address <span class="hljs-string">&#x27;192.30.255.112&#x27;</span> to the list of known hosts.<br>Counting objects: 10, <span class="hljs-keyword">done</span>.<br>Delta compression using up to 4 threads.<br>Compressing objects: 100% (7/7), <span class="hljs-keyword">done</span>.<br>Writing objects: 100% (10/10), 855 bytes | 0 bytes/s, <span class="hljs-keyword">done</span>.<br>Total 10 (delta 1), reused 0 (delta 0)<br>remote: Resolving deltas: 100% (1/1), <span class="hljs-keyword">done</span>.<br>To git@github.com:Zhangtao153/learngit.git<br> * [new branch]      master -&gt; master<br>Branch master <span class="hljs-built_in">set</span> up to track remote branch master from origin.<br></code></pre></td></tr></table></figure><p>当前分支 master推送到远程</p><h4 id="4-3-查看远程仓库"><a href="#4-3-查看远程仓库" class="headerlink" title="4.3 查看远程仓库"></a>4.3 查看远程仓库</h4><p>git  remote  -v</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote<br>origin<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (dev)<br>$ git remote -v<br>origin  git@github.com:Zhangtao153/learngit.git (fetch)<br>origin  git@github.com:Zhangtao153/learngit.git (push)<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git remote show<br>origin<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git remote show origin<br>* remote origin<br>  Fetch URL: git@github.com:Zhangtao153/learngit.git<br>  Push  URL: git@github.com:Zhangtao153/learngit.git<br>  HEAD branch: master<br>  Remote branch:<br>    master tracked<br>  Local branch configured <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;git pull&#x27;</span>:<br>    master merges with remote master<br>  Local ref configured <span class="hljs-keyword">for</span> <span class="hljs-string">&#x27;git push&#x27;</span>:<br>    master pushes to master (up to date)<br></code></pre></td></tr></table></figure><h4 id="4-4-从远程库克隆"><a href="#4-4-从远程库克隆" class="headerlink" title="4.4 从远程库克隆"></a>4.4 从远程库克隆</h4><p>git clone &lt;url&gt;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">clone</span> git@github.com:Zhangtao153/learngit.git<br>Cloning into <span class="hljs-string">&#x27;learngit&#x27;</span>...<br>remote: Enumerating objects: 10, <span class="hljs-keyword">done</span>.<br>remote: Counting objects: 100% (10/10), <span class="hljs-keyword">done</span>.<br>remote: Compressing objects: 100% (6/6), <span class="hljs-keyword">done</span>.<br>remote: Total 10 (delta 1), reused 10 (delta 1), pack-reused 0<br>Receiving objects: 100% (10/10), <span class="hljs-keyword">done</span>.<br>Resolving deltas: 100% (1/1), <span class="hljs-keyword">done</span>.<br>Checking connectivity... <span class="hljs-keyword">done</span>.<br></code></pre></td></tr></table></figure><h4 id="4-5-本地创建和远程分支对应的分支"><a href="#4-5-本地创建和远程分支对应的分支" class="headerlink" title="4.5 本地创建和远程分支对应的分支"></a>4.5 本地创建和远程分支对应的分支</h4><p>从远程 clone 的代码库默认只有 master 分支。</p><p>命令：**<font color="red">git  checkout  -b  dev  origin/dev</font>** </p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b dev origin/dev<br>Switched to a new branch <span class="hljs-string">&#x27;dev&#x27;</span><br>Branch <span class="hljs-string">&#x27;dev&#x27;</span> <span class="hljs-built_in">set</span> up to track remote branch <span class="hljs-string">&#x27;dev&#x27;</span> from <span class="hljs-string">&#x27;origin&#x27;</span>.<br></code></pre></td></tr></table></figure><h4 id="4-6-修改远程仓库"><a href="#4-6-修改远程仓库" class="headerlink" title="4.6 修改远程仓库"></a>4.6 修改远程仓库</h4><p>方法一：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote set-url origin &lt;url&gt;<br></code></pre></td></tr></table></figure><p>方法二：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">git remote rm origin<br>git remote add origin [url]<br></code></pre></td></tr></table></figure><h4 id="4-7-将本地分支与远程建立关联"><a href="#4-7-将本地分支与远程建立关联" class="headerlink" title="4.7 将本地分支与远程建立关联"></a>4.7 将本地分支与远程建立关联</h4><p>git branch –track –set-upstream-to=origin/test test</p><h3 id="5-分支管理"><a href="#5-分支管理" class="headerlink" title="5. 分支管理"></a>5. 分支管理</h3><ul><li>git branch 查看本地分支</li><li>git branch -a  查看所有分支</li><li>git branch -av  查看所有分支详细信息</li><li>git branch -avv  查看本地分支和远程分支的关联信息</li></ul><h4 id="5-1-创建切换分支"><a href="#5-1-创建切换分支" class="headerlink" title="5.1 创建切换分支"></a>5.1 创建切换分支</h4><ul><li>git branch &lt;branch name&gt; 基于当前分支新建分支</li><li>git branch &lt;branch name&gt; &lt;commit id&gt;  基于提交新建分支</li></ul><p>命令：<font color="red">git checkout  -b  dev 或  git switch -c dev </font></p><p>作用：创建并切换分支</p><blockquote><p>git checkout 命令加上 -b 参数表示创建并切换，相当于以下两条命令：</p><p>$ git  branch  dev<br>$ git  checkout  dev</p></blockquote><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git checkout -b dev<br>Switched to a new branch <span class="hljs-string">&#x27;dev&#x27;</span><br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (dev)<br>$ git branch<br>* dev<br>  master<br></code></pre></td></tr></table></figure><h4 id="5-2-合并分支"><a href="#5-2-合并分支" class="headerlink" title="5.2 合并分支"></a>5.2 合并分支</h4><p>命令：git  merge &lt;branch&gt;</p><p>作用：合并指定分支到当前分支</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git merge dev<br>Updating 35bc9a6..83ef1fc<br>Fast-forward<br> README.md | 3 ++-<br> 1 file changed, 2 insertions(+), 1 deletion(-)<br></code></pre></td></tr></table></figure><blockquote><p>Fast-forward “快进模式”，就是直接把 master 指向 dev 的当前提交，所以合并速度非常快。</p></blockquote><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220214232219.png"></p><blockquote><p>通常合并分支时，如果可能，Git会用Fast forward模式，但这种模式下，删除分支后，会丢掉分支信息。</p><p>如果要强制禁用Fast forward模式，Git就会在merge时生成一个新的commit，这样，从分支历史上就可以看出分支信息。</p></blockquote><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220214232236.png"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git merge --no-ff -m <span class="hljs-string">&quot;merge with no-ff&quot;</span> zth<br>Merge made by the <span class="hljs-string">&#x27;recursive&#x27;</span> strategy.<br> README.md | 2 +-<br> 1 file changed, 1 insertion(+), 1 deletion(-)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (master)<br>$ git <span class="hljs-built_in">log</span> --graph --pretty=oneline --abbrev-commit<br>*   c5df1ca (HEAD -&gt; master) merge with no-ff<br>|\<br>| * 5db3e3d (zth) delete merge<br>|/<br>* 6707c86 add merge<br>* 7e760b4 add on zth branch<br>*   650cdbc clear on master<br></code></pre></td></tr></table></figure><h4 id="5-3-删除分支"><a href="#5-3-删除分支" class="headerlink" title="5.3 删除分支"></a>5.3 删除分支</h4><p>命令：git   branch  -d   &lt;branch&gt;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git branch -d dev<br>Deleted branch dev (was 83ef1fc).<br></code></pre></td></tr></table></figure><h4 id="5-4-查看分支合并情况"><a href="#5-4-查看分支合并情况" class="headerlink" title="5.4 查看分支合并情况"></a>5.4 查看分支合并情况</h4><p>命令：<font color="red"> git log –graph –pretty=oneline –abbrev-commit<br> 或：git log –graph –oneline </font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git <span class="hljs-built_in">log</span> --graph --pretty=oneline --abbrev-commit<br>*   8e7b6c4 conflict fixed<br>|\<br>| * e920442 update on dev<br>* | e15ba0e update on master<br>|/<br>* 83ef1fc add on dev<br>* 35bc9a6 delete test.txt<br>* fd68a6a add file test.txt<br>* a8d2e0d 手动删除<br>* 1d243ca add <span class="hljs-built_in">test</span> file<br>* 8438389 wrote a readme file<br></code></pre></td></tr></table></figure><h4 id="5-5-保存现场"><a href="#5-5-保存现场" class="headerlink" title="5.5 保存现场"></a>5.5 保存现场</h4><p>在创建一个新的分支用来修改 bug 时，当前分支的工作还没提交，可以通过 stash 功能把当前工作现场“储藏”起来，等以后恢复现场后继续工作。</p><p>原因：<font color="red">所有分支共享工作区和暂存区</font></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git stash<br>Saved working directory and index state WIP on issue-004: c5df1ca merge with no-ff<br></code></pre></td></tr></table></figure><p>git  stash  list</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git stash list<br>stash@&#123;0&#125;: WIP on issue-004: c5df1ca merge with no-ff<br>stash@&#123;1&#125;: WIP on dev: c5df1ca merge with no-ff<br></code></pre></td></tr></table></figure><p>恢复现场方法：</p><p>一： git stash apply 恢复，但是恢复后，stash内容并不删除，需要用git stash drop来删除；</p><p>二： git stash pop，恢复的同时把stash内容也删了：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git stash pop<br>On branch issue-004<br>Changes not staged <span class="hljs-keyword">for</span> commit:<br>  (use <span class="hljs-string">&quot;git add &lt;file&gt;...&quot;</span> to update what will be committed)<br>  (use <span class="hljs-string">&quot;git restore &lt;file&gt;...&quot;</span> to discard changes <span class="hljs-keyword">in</span> working directory)<br>        modified:   README.md<br><br>no changes added to commit (use <span class="hljs-string">&quot;git add&quot;</span> and/or <span class="hljs-string">&quot;git commit -a&quot;</span>)<br>Dropped refs/stash@&#123;0&#125; (020a507cf2c1cd55460d17081db6671b7e075ed6)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (issue-004)<br>$ git stash list<br>stash@&#123;0&#125;: WIP on dev: c5df1ca merge with no-ff<br></code></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git stash apply stash@&#123;0&#125;<br></code></pre></td></tr></table></figure><h4 id="5-6-git-cherry-pick"><a href="#5-6-git-cherry-pick" class="headerlink" title="5.6 git cherry-pick"></a>5.6 git cherry-pick</h4><p>作用：合并不同分支的若干个 commit 到当前分支</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220215233958.png"></p><p>语法： </p><p> git cherry-pick &lt;C commit-id&gt; &lt;D commit-id&gt; &lt;E commit-id&gt; </p><h3 id="6-多人协作工作模式"><a href="#6-多人协作工作模式" class="headerlink" title="6. 多人协作工作模式"></a>6. 多人协作工作模式</h3><p>首先，可以试图用 git push origin  &lt;branch-name&gt; 推送自己的修改；</p><p>如果推送失败，则因为远程分支比你的本地更新，需要先用git pull试图合并；</p><p>如果合并有冲突，则解决冲突，并在本地提交；</p><p>没有冲突或者解决掉冲突后，再用 git push origin &lt;branch-name&gt; 推送就能成功！</p><p>如果 git pull 提示 no tracking information，则说明本地分支和远程分支的链接关系没有创建，用命令 git branch –set-upstream-to &lt;branch-name&gt; origin/&lt;branch-name&gt;。</p><h3 id="7-标签管理"><a href="#7-标签管理" class="headerlink" title="7. 标签管理"></a>7. 标签管理</h3><h4 id="7-1-创建标签"><a href="#7-1-创建标签" class="headerlink" title="7.1 创建标签"></a>7.1 创建标签</h4><p>命令：git  tag  &lt;name&gt;  [commit]</p><p>-a 指定标签名，-m 指定说明文字</p><p>首先选择分支，默认在最新提交的 commit 上。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag v1.0<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (dev)<br>$ git tag v0.9 add2dbd<br></code></pre></td></tr></table></figure><h4 id="7-2-查看所有标签"><a href="#7-2-查看所有标签" class="headerlink" title="7.2 查看所有标签"></a>7.2 查看所有标签</h4><p>git  tag</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag<br>v0.9<br>v1.0<br></code></pre></td></tr></table></figure><h4 id="7-3-查看标签信息"><a href="#7-3-查看标签信息" class="headerlink" title="7.3 查看标签信息"></a>7.3 查看标签信息</h4><p>git  show  &lt;tagname&gt;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag -a v0.8 -m <span class="hljs-string">&quot;version 0.8 release&quot;</span> 94b83a0<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (dev)<br>$ git show v0.8<br>tag v0.8<br>Tagger: Zhangtao153 &lt;13289265979@163.com&gt;<br>Date:   Wed Oct 21 23:51:54 2020 +0800<br><br>version 0.8 release<br><br>commit 94b83a06c04b8b3a5ca5af4443dda614bc3b1441 (tag: v0.8)<br>Author: Zhangtao153 &lt;13289265979@163.com&gt;<br>Date:   Wed Oct 21 21:32:49 2020 +0800<br><br>    commit on issue-005<br><br>diff --git a/README.md b/README.md<br>index 25ed040..af0e009 100644<br>--- a/README.md<br>+++ b/README.md<br>@@ -1,2 +1,2 @@<br> Git is a version control system.<br>-Git is free software.哈哈zth  delete and update<br>+Git is free software.哈哈zth  delete and update on issue-005<br></code></pre></td></tr></table></figure><h4 id="7-4-删除标签"><a href="#7-4-删除标签" class="headerlink" title="7.4 删除标签"></a>7.4 删除标签</h4><p>删除本地标签： </p><p>git   tag   -d  &lt;tagname&gt;</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag -d v0.9<br>Deleted tag <span class="hljs-string">&#x27;v0.9&#x27;</span> (was add2dbd)<br></code></pre></td></tr></table></figure><p>删除远程标签（先删除本地，再删除远程）：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git tag -d v0.8<br>Deleted tag <span class="hljs-string">&#x27;v0.8&#x27;</span> (was 120a8d2)<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (dev)<br>$ git push origin  :refs/tags/v0.8<br>To github.com:Zhangtao153/learngit.git<br> - [deleted]         v0.8<br></code></pre></td></tr></table></figure><h4 id="7-5-推送标签到远程"><a href="#7-5-推送标签到远程" class="headerlink" title="7.5 推送标签到远程"></a>7.5 推送标签到远程</h4><p> 推送指定标签：</p><p>git push origin &lt;tagname&gt;</p><p>推送全部尚未推送到远程的本地标签：</p><p>git push origin –tags</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs bash">$ git push origin v1.0<br>Enumerating objects: 28, <span class="hljs-keyword">done</span>.<br>Counting objects: 100% (28/28), <span class="hljs-keyword">done</span>.<br>Delta compression using up to 4 threads<br>Compressing objects: 100% (18/18), <span class="hljs-keyword">done</span>.<br>Writing objects: 100% (26/26), 1.95 KiB | 667.00 KiB/s, <span class="hljs-keyword">done</span>.<br>Total 26 (delta 12), reused 0 (delta 0), pack-reused 0<br>remote: Resolving deltas: 100% (12/12), <span class="hljs-keyword">done</span>.<br>To github.com:Zhangtao153/learngit.git<br> * [new tag]         v1.0 -&gt; v1.0<br><br>Administrator@WIN-DTNF3GRDH5R MINGW64 /g/learngit (dev)<br>$ git push origin --tags<br>Enumerating objects: 1, <span class="hljs-keyword">done</span>.<br>Counting objects: 100% (1/1), <span class="hljs-keyword">done</span>.<br>Writing objects: 100% (1/1), 167 bytes | 167.00 KiB/s, <span class="hljs-keyword">done</span>.<br>Total 1 (delta 0), reused 0 (delta 0), pack-reused 0<br>To github.com:Zhangtao153/learngit.git<br> * [new tag]         v0.8 -&gt; v0.8<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Git</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Git</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea——使用技巧</title>
    <link href="/2022/02/04/idea%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/02/04/idea%E2%80%94%E2%80%94%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="1-代码模板"><a href="#1-代码模板" class="headerlink" title="1. 代码模板"></a>1. 代码模板</h3><h4 id="1-1-fori-forr-int-fori-forr"><a href="#1-1-fori-forr-int-fori-forr" class="headerlink" title="1.1  fori / forr / (int.fori/forr)"></a>1.1  fori / forr / (int.fori/forr)</h4><p>快速生成 for 循环</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220201100448.png"></p><h4 id="1-2-sout-soutv-sout-souf-soutm-serr"><a href="#1-2-sout-soutv-sout-souf-soutm-serr" class="headerlink" title="1.2 sout / soutv / sout / souf / soutm / serr"></a>1.2 sout / soutv / sout / souf / soutm / serr</h4><p>sout：快速生成         System.out.println();<br>soutv：输出当前上下文变量<br>soutm : 打印当前方法签名<br>soutp：打印当前方法参数<br>souf：格式化输出字符串<br>serr：prints a string to System.err</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220201101142.png"></p><h4 id="1-3-ifn-inn"><a href="#1-3-ifn-inn" class="headerlink" title="1.3 ifn / inn"></a>1.3 ifn / inn</h4><p>ifn：判断上下文变量是否为空</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220201230733.png"></p><p>inn：判断上下文变量是否不为空</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220201230938.png"></p><h4 id="1-4-surround-with"><a href="#1-4-surround-with" class="headerlink" title="1.4 surround with"></a>1.4 surround with</h4><p>快捷键 Ctrl + alt + T</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220201231455.png"></p><p>选择 Surround with Callable：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220201232104.png"></p><h3 id="2-代码重构"><a href="#2-代码重构" class="headerlink" title="2. 代码重构"></a>2. 代码重构</h3><ul><li>extract </li><li>change signature</li><li>rename</li></ul><h4 id="2-1-extract（提取）"><a href="#2-1-extract（提取）" class="headerlink" title="2.1 extract（提取）"></a>2.1 extract（提取）</h4><p>// method(M)、constant(C)、fields(F)、variables(V)、parameters(P)</p><ul><li>提取方法（Ctrl + Alt + M）</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202223339.png"></p><ul><li>提取常量（Ctrl + Alt + C）</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202224012.png"></p><ul><li>提取字段（Ctrl + Alt + F）</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202230344.png"></p><ul><li>提取变量（Ctrl + Alt + V）</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202231120.png"></p><ul><li>提取参数（Ctrl + Alt + P）</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202232910.png"></p><h4 id="2-2-change-signature"><a href="#2-2-change-signature" class="headerlink" title="2.2 change signature"></a>2.2 change signature</h4><p>快捷键：Ctrl+F6</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202234547.png"></p><h4 id="2-3-rename"><a href="#2-3-rename" class="headerlink" title="2.3 rename"></a>2.3 rename</h4><p>快捷键：shift+F6</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202235153.png"></p><p>也可以在按完快捷键之后再按 shift+F6，设置重命名范围。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202235400.png"></p><h3 id="3-常用快捷键"><a href="#3-常用快捷键" class="headerlink" title="3. 常用快捷键"></a>3. 常用快捷键</h3><p>显示快捷键插件：Presentation Assistant</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204001624.png"></p><p><font color="red"></font></p><ul><li><font color="red"><strong>Ctrl + F12</strong></font><br>查找当前类中的方法<img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20221109234601.png"></li></ul><ul><li><p><font color="red"><strong>alt+enter</strong></font><br>结合上下文显示 error 的 fix 信息</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203222308.png"></p><p>代码补全</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203222726.png"></p><p>lambda 表达式生成</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203224401.png"></p></li><li><p><font color="red"><strong>F2</strong></font> </p><p>快速定位到报错行，并且多次按 F2 可在不同报错位置切换。</p></li><li><p><font color="red"><strong>alt + 1</strong></font></p><p>快速定位到项目窗口，定位到 project 窗口之后可以直接输入进行搜索，定位到文件后直接回车打开。也可以按 esc 光标回到编辑区。</p></li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203230028.png"></p><ul><li><font color="red"><strong>esc</strong></font><br>关闭任何上层窗口，回到编辑区域。</li><li><font color="red"><strong>Ctrl + e</strong></font><br>显示最近修改的文件</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203230514.png"></p><ul><li><p><font color="red"><strong>Ctrl+b / Ctrl+alt+b</strong></font><br>Ctrl+b：进入到类的实现<br>Ctrl+alt+b：进入到接口的实现类</p></li><li><p><font color="red"><strong>alt + F7</strong></font><br> 定位类、方法使用到的位置</p></li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203231404.png"></p><ul><li><font color="red"><strong>Ctrl + Ctrl</strong></font><br>运行指令</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203231931.png"></p><ul><li><p><font color="red"><strong>Ctrl+W / Ctrl+shift+W</strong></font><br>选取代码块</p></li><li><p><font color="red"><strong>Ctrl+/  、Ctrl+shift+/</strong></font><br>Ctrl+/：单行注释<br>Ctrl+shift+/：多行注释</p></li><li><p><font color="red"><strong>Ctrl + shift + enter</strong></font><br>补全声明</p></li></ul><p> <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203233914.png"></p><ul><li><font color="red"><strong>Ctrl + alt + L</strong></font><br>格式化代码</li><li><font color="red"><strong>Ctrl + shift + alt + T</strong></font><br>重构代码<br>呼出面板后按选项前面的数字选择</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203235028.png"></p><ul><li><font color="red"><strong>Ctrl + shift + A</strong></font><br>查找操作</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220203235832.png"></p><ul><li><font color="red"><strong>shift + shift</strong></font><br>Search everywhere<br>可通过 tab 进行切换查找内容</li><li><font color="red"><strong>Ctrl + D</strong></font><br>重复当前行或选择块</li></ul><ul><li><p><font color="red">Ctrl+←  / Ctrl + →</font><br>光标按单词左右移动</p></li><li><p><font color="red">alt+ ←  / alt +→</font><br>左右切换编辑区 table 页</p></li><li><p><font color="red"><strong>alt+↑  / alt + ↓</strong></font><br> 光标定位到上一个/下一个方法</p></li><li><p><font color="red"><strong>shift + alt + 鼠标左键</strong></font><br>多行编辑</p></li></ul><h3 id="4-常用插件"><a href="#4-常用插件" class="headerlink" title="4. 常用插件"></a>4. 常用插件</h3><ul><li>Alibaba Java Coding Guidelines<br>代码规范校验</li><li>Grep console<br> 设置控制台打印颜色、过滤等</li><li>Presentation Aassistant<br>显示操作名称以及快捷键</li><li>SequenceDiagram<br>生成时序图</li><li>Tasks<br>待办事项记录卡</li></ul><h3 id="5-后缀补全（postfix-completion）"><a href="#5-后缀补全（postfix-completion）" class="headerlink" title="5. 后缀补全（postfix completion）"></a>5. 后缀补全（postfix completion）</h3><h4 id="5-1-for-循环（-for-fori-forr）"><a href="#5-1-for-循环（-for-fori-forr）" class="headerlink" title="5.1 for 循环（.for / .fori / .forr）"></a>5.1 for 循环（.for / .fori / .forr）</h4><p>  for each 循环（.for / .iter）：</p><p>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204143629.png"></p><p>  for 普通循环（.fori）：</p><p>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204144217.png"></p><p>  for  反向迭代（.forr)：<br>  （r：reverse）</p><p>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204144456.png"></p><h4 id="5-2-判空（-null-notnull-nn"><a href="#5-2-判空（-null-notnull-nn" class="headerlink" title="5.2 判空（.null / .notnull / .nn)"></a>5.2 判空（.null / .notnull / .nn)</h4><p>  判空（.null）</p><p>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204170246.png"></p><p>  判非空（ .notnull / .nn）</p><p>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204170739.png"></p><h4 id="5-3-boolean-判断（-if-not-if）"><a href="#5-3-boolean-判断（-if-not-if）" class="headerlink" title="5.3 boolean 判断（.if / .not.if）"></a>5.3 boolean 判断（.if / .not.if）</h4><p>  if 判断（.if）<br>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204171407.png"></p><p>  取反再判断（.not.if）</p><p>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204171943.png"></p><h4 id="5-4-定义变量（-new-var-val-field）"><a href="#5-4-定义变量（-new-var-val-field）" class="headerlink" title="5.4 定义变量（.new / .var / .val / .field）"></a>5.4 定义变量（.new / .var / .val / .field）</h4><p>  创建对象并定义局部变量：</p><p>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204173326.png"></p><p>  创建 val 类型局部变量：</p><p>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204173730.png"></p><p>  创建全局变量（.field）：</p><p>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204174100.png"></p><h4 id="5-5-格式化字符串（-format）"><a href="#5-5-格式化字符串（-format）" class="headerlink" title="5.5 格式化字符串（.format）"></a>5.5 格式化字符串（.format）</h4><p>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204174546.png"></p><h4 id="5-6-同步锁（-synchronized）"><a href="#5-6-同步锁（-synchronized）" class="headerlink" title="5.6  同步锁（.synchronized）"></a>5.6  同步锁（.synchronized）</h4><p>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204174922.png"></p><h4 id="5-7-异常捕获（-try）"><a href="#5-7-异常捕获（-try）" class="headerlink" title="5.7 异常捕获（.try）"></a>5.7 异常捕获（.try）</h4><p> <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204175516.png"></p><h4 id="5-8-强制转换（-cast-castvar）"><a href="#5-8-强制转换（-cast-castvar）" class="headerlink" title="5.8 强制转换（.cast / .castvar）"></a>5.8 强制转换（.cast / .castvar）</h4><p> <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/cast.gif"></p><h4 id="5-9-抛出异常-返回-（-throw-return）"><a href="#5-9-抛出异常-返回-（-throw-return）" class="headerlink" title="5.9 抛出异常 / 返回 （.throw / .return）"></a>5.9 抛出异常 / 返回 （.throw / .return）</h4><p> <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204183148.png"></p><p> <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220204183331.png"></p><h3 id="6-API-接口测试"><a href="#6-API-接口测试" class="headerlink" title="6. API 接口测试"></a>6. API 接口测试</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220209232819.png"></p><p>配置环境变量：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220210225000.png"></p><p>发送请求体：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220210224857.png"></p><p>请求模板：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220210225823.png"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>idea——debug 技巧</title>
    <link href="/2022/01/23/idea%E2%80%94%E2%80%94debug%E6%8A%80%E5%B7%A7/"/>
    <url>/2022/01/23/idea%E2%80%94%E2%80%94debug%E6%8A%80%E5%B7%A7/</url>
    
    <content type="html"><![CDATA[<h3 id="1-debug"><a href="#1-debug" class="headerlink" title="1. debug"></a>1. debug</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220123122508.png"></p><p>　1. 以 Debug 模式启动服务。<br>　2. 断点：在左边行号栏单击左键，或者快捷键Ctrl+F8 打上/取消断点。<br>　3. Debug窗口：访问请求到达第一个断点后，会自动激活Debug窗口。如果没有自动激活，可以去设置里设置。<br>　4. 调试按钮：在菜单栏 Run 里可以找到同样的对应的功能。<br>　5. 服务按钮：可以在这里关闭/启动服务，设置断点等。<br>　6. 方法调用栈：这里显示了该线程调试所经过的所有方法，勾选右上角的 [Show All Frames] 按钮，就不会显示其它类库的方法了。<br>　7. Variables：在变量区可以查看当前断点之前的当前方法内的变量。<br>　8. Watches：查看变量，可以将Variables区中的变量拖到Watches中查看 </p><h4 id="1-1-基本用法-amp-快捷键"><a href="#1-1-基本用法-amp-快捷键" class="headerlink" title="1.1 基本用法&amp;快捷键"></a>1.1 基本用法&amp;快捷键</h4><p>Debug 调试的功能主要对应上图中 4 和 5 两组按钮：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220123203210.png"></p><ol><li>Show Execution Point (Alt + F10)：如果你的光标在其它行或其它页面，点击这个按钮可跳转到当前代码执行的行。</li><li>Step Over (F8)：步过，一行一行地往下走，如果这一行上有方法不会进入方法。</li><li>Step Into (F7)：步入，如果当前行有方法，可以进入方法内部，一般用于进入自定义方法内。</li><li>Force Step Into (Alt + Shift + F7)：强制步入，能进入任何方法，查看底层源码的时候可以用这个进入官方类库的方法。</li><li>Step Out (Shift + F8)：步出，从步入的方法内退出到方法调用处，此时方法已执行完毕，只是还没有完成赋值。</li><li>Drop Frame (默认无)：回退断点，回到上一层该方法调用处或指定方法的调用处（断点回退只能重新走一下流程，之前的某些参数/数据的状态已经改变了的是无法回退到之前的状态的，如对象、集合、更新了数据库数据等等）</li><li>Run to Cursor (Alt + F9)：运行到光标处。</li><li> Evaluate Expression (Alt + F8)：计算表达式。</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220123205203.png"></p><ol><li>Rerun ‘xxxx’：重新运行程序，会关闭服务后重新启动程序。</li><li>Update ‘tech’ application (Ctrl + F5)：更新程序，一般在代码有改动后可执行这个功能。</li><li>Resume Program (F9)：执行到下一个断。</li><li>Pause Program：暂停程序，启用Debug。</li><li>Stop ‘xxx’ (Ctrl + F2)：连续按两下，关闭程序。</li><li>View Breakpoints (Ctrl + Shift + F8)：查看所有断点。</li><li>Mute Breakpoints：哑的断点，选择这个后，所有断点变为灰色，断点失效，按F9则可以直接运行完程序。再次点击，断点变为红色，有效。如果只想使某一个断点失效，可以在断点上右键取消Enabled。</li></ol><h4 id="1-2智能步入"><a href="#1-2智能步入" class="headerlink" title="1.2智能步入"></a>1.2智能步入</h4><p> 一行代码里有好几个方法，怎么只选择某一个方法进入。使用 Step Into (Alt + F7) 或者 Force Step Into (Alt + Shift + F7) 进入到方法内部，但这两个操作会根据方法调用顺序依次进入。那么智能步入就很方便了，这个功能在 Run 里可以看到，Smart Step Into (Shift + F7)。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/%E6%97%A0%E6%A0%87%E9%A2%98.png"></p><h4 id="1-3-中断Debug"><a href="#1-3-中断Debug" class="headerlink" title="1.3 中断Debug"></a>1.3 中断Debug</h4><p>想要在 Debug 的时候，中断请求，不要再走剩余的流程了？</p><p>有些时候，我们看到传入的参数有误后，不想走后面的流程了，怎么中断这次请求呢(后面的流程要删除数据库数据呢….)，难道要关闭服务重新启动程序？</p><p>可以通过 Force Return，即强制返回来避免后续的流程。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220123224600.png"></p><p>点击 Force Return，弹出Return Value的窗口。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220123225011.png"></p><h3 id="2-断点调试"><a href="#2-断点调试" class="headerlink" title="2. 断点调试"></a>2. 断点调试</h3><h4 id="2-1-行断点"><a href="#2-1-行断点" class="headerlink" title="2.1 行断点"></a>2.1 行断点</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220125222604.png"></p><p>在方法体的左侧鼠标单击即可添加行断点，debug 模式执行时，会在停在断点所在的行。</p><h4 id="2-2-详细断点"><a href="#2-2-详细断点" class="headerlink" title="2.2 详细断点"></a>2.2 详细断点</h4><p>通过设置断点条件，在满足条件时，才停在断点处，否则直接运行。</p><p>通常，当我们在遍历一个比较大的集合或数组时，在循环内设置了一个断点，难道我们要一个一个去看变量的值？那肯定很累，说不定你还错过这个值得重新来一次。</p><ol><li>在断点上右键直接设置当前断点的条件（shift + 鼠标左键 )</li></ol><p> <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220123214359.png"><br>  当 exis t为 true 时断点才生效。</p><ol start="2"><li>点击 View Breakpoints (Ctrl + Shift + F8)，查看所有断点。</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220123214720.png"></p><ul><li>. Java Line Breakpoints 显示了所有的断点，在右边勾选Condition，设置断点的条件。</li><li>. 勾选 Log message to console，则会将当前断点行输出到控制台。</li><li>. 勾选 Evaluate and log，可以在执行这行代码时计算表达式的值，并将结果输出到控制台。</li><li>. Instance filters：实例过滤，输入实例ID。</li><li>. Class filters：类过滤，根据类名过滤。</li><li>. Pass count：用于循环中，如果断点在循环中，可以设置该值，循环多少次后停在断点处，之后的循环都会停在断点处。</li></ul><h4 id="2-3-方法断点"><a href="#2-3-方法断点" class="headerlink" title="2.3 方法断点"></a>2.3 方法断点</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220125224402.png"></p><p>方法断点打在方法签名的左侧，图标为菱形。会在方法的第一行和最后一行停顿。（方便查看方法的返回值以及变量、表达式的变化等等）</p><p><font color="red">如果方法断点打在接口抽象方法上，则会停顿在实现类对应方法的第一行</font></p><h4 id="2-4-异常断点"><a href="#2-4-异常断点" class="headerlink" title="2.4 异常断点"></a>2.4 异常断点</h4><p>通过设置异常断点，在程序中出现需要拦截的异常时，会自动定位到异常行。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220123222025.png"></p><p>点击 + 号添加 Java Exception Breakpoints，添加异常断点。然后输入需要断点的异常类（如 NullPointerException）。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220123221924.png"></p><p>程序将暂停在抛出 NullPointerException 的行。</p><h4 id="2-5-字段断点（读写监控）"><a href="#2-5-字段断点（读写监控）" class="headerlink" title="2.5 字段断点（读写监控）"></a>2.5 字段断点（读写监控）</h4><p>监控值的变化。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220125231555.png"></p><p>执行如下代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">field</span><span class="hljs-params">()</span> </span>&#123;<br>    Person person = <span class="hljs-keyword">new</span> Person(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">20</span>);<br>    person.setAge(<span class="hljs-number">18</span>);<br>    System.out.println(person);<br>&#125;<br></code></pre></td></tr></table></figure><p>将会在如下地方暂停：</p><p> <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220125231721.png"></p><p> <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220125231812.png"></p><h4 id="2-6-stream-调试"><a href="#2-6-stream-调试" class="headerlink" title="2.6 stream 调试"></a>2.6 stream 调试</h4><p> <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220128232648.png"></p><p> 有三种断点模式。</p><p> 点击 Trance Current Stream Chain 按钮，查看流的转换过程。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220130231133.png"></p><h3 id="3-多线程-debug"><a href="#3-多线程-debug" class="headerlink" title="3. 多线程 debug"></a>3. 多线程 debug</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202183512.png"></p><p>suspend 分两类，一类是All，一类是Thread。</p><p>All：只有其中一个线程会在断点处挂起，此线程挂起后阻塞所有线程，并且不能在 call stack 处切换线程上下文。<br>Thread：每个线程执行到断点出会挂起，每个线程之间不会影响，并且在 call stack 出可以切换线程上下文。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220202183313.png"></p><h3 id="4-远程-debug"><a href="#4-远程-debug" class="headerlink" title="4. 远程 debug"></a>4. 远程 debug</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220205230647.png"></p><p>远程服务启动：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220205230914.png"></p><p>访问服务：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220205231329.png"></p><p>debug 结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220205231356.png"></p>]]></content>
    
    
    <categories>
      
      <category>工具</category>
      
    </categories>
    
    
    <tags>
      
      <tag>idea</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>jenkins——核心功能</title>
    <link href="/2022/01/20/jenkins%E2%80%94%E2%80%94%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/"/>
    <url>/2022/01/20/jenkins%E2%80%94%E2%80%94%E6%A0%B8%E5%BF%83%E5%8A%9F%E8%83%BD/</url>
    
    <content type="html"><![CDATA[<h3 id="1-概述与环境配置"><a href="#1-概述与环境配置" class="headerlink" title="1. 概述与环境配置"></a>1. 概述与环境配置</h3><h4 id="1-1-持续化集成"><a href="#1-1-持续化集成" class="headerlink" title="1.1 持续化集成"></a>1.1 持续化集成</h4><p>持续集成即 Continuous integration（CI） 是一种软件开发实践，即团队开发成员经常集成他们的工作，每次集成都通过自动化的构建（包括编译，发布，自动化测试）来验证，从而尽快地发现集成错误，让团队能够更高效的开发软件。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/CI.png"></p><p>持续集成要点：</p><ul><li>统一的代码库(git)</li><li>统一的依赖包管理(nexus)</li><li>测试自动化</li><li>构建全自动化(maven)</li><li>部署自动化</li><li>可追踪的集成记录</li></ul><h4 id="1-2-jenkins-概述"><a href="#1-2-jenkins-概述" class="headerlink" title="1.2 jenkins 概述"></a>1.2 jenkins 概述</h4><p>jenkins 就是为了满足持续集成的要点而设计的一款工具，其主体框架采用 JAVA 开发，实质内部功能都是由各种插件实现，极大提高了系统的扩展性。其不仅可以满足 JAVA 系统的集成，也可以实现 PHP 等语言的集成发布。通过其 pipeline 插件，用户可以随自己需要定制集成流程。</p><h4 id="1-3-安装-jenkins"><a href="#1-3-安装-jenkins" class="headerlink" title="1.3 安装 jenkins"></a>1.3 安装 jenkins</h4><ol><li><p>下载：jenkins 支持Docker、yum、msi 等安装，推荐通过 WAR 包进行安装。<a href="https://jenkins.io/download/">https://jenkins.io/download/</a></p></li><li><p>启动：下载完成之后直接可通过 jar -jar 命令启动</p></li></ol><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">java -jar jenkins.war --httpPort=8080<br></code></pre></td></tr></table></figure><p>也可以将其放至到 servlet 容器（tomcat\jetty\jboss）中直接启动，无需过多的配置。</p><ol start="3"><li>配置：下载完成之后进入启动页 (<a href="http://127.0.0.1:8080/">http://127.0.0.1:8080/</a>) 会有一个 验证过程，验证码存储在 ${user_home}.jenkins\secrets\initialAdminPassword 中，接着就是进入安装插件页，选择默认即可。</li></ol><h4 id="1-4-基础环境配置与常用插件下载"><a href="#1-4-基础环境配置与常用插件下载" class="headerlink" title="1.4 基础环境配置与常用插件下载"></a>1.4 基础环境配置与常用插件下载</h4><p>在集成的时候，jenkins 用到了 Maven 、Git。所以服务器中必须提前安装好这些环境。</p><p>Manage Jenkins  –&gt;  Manage Plugins –&gt; Advanced –&gt; 升级站点：</p><p><a href="https://updates.jenkins.io/update-center.json">https://updates.jenkins.io/update-center.json</a>   改为 <a href="http://mirror.esuni.jp/jenkins/updates/update-center.json">http://mirror.esuni.jp/jenkins/updates/update-center.json</a></p><p>镜像源查询：<a href="http://mirrors.jenkins-ci.org/status.html">http://mirrors.jenkins-ci.org/status.html</a></p><p>基本插件列表：</p><table><thead><tr><th>插件名称</th><th>插件描述</th></tr></thead><tbody><tr><td>Maven Integration</td><td>maven 管理插件</td></tr><tr><td>Deploy to container</td><td>容器部署插件</td></tr><tr><td>Pipeline</td><td>管道集成插件</td></tr><tr><td>Email Extension</td><td>邮件通知插件</td></tr><tr><td>SSH</td><td>用于ssh 通信</td></tr></tbody></table><h3 id="2-基于-jenkins-实现可持续化集成"><a href="#2-基于-jenkins-实现可持续化集成" class="headerlink" title="2. 基于 jenkins 实现可持续化集成"></a>2. 基于 jenkins 实现可持续化集成</h3><h4 id="2-1-持续化集成完成的目标"><a href="#2-1-持续化集成完成的目标" class="headerlink" title="2.1 持续化集成完成的目标"></a>2.1 持续化集成完成的目标</h4><ol><li>自动基于分支构建项目</li><li>构建好的项目自动部署至 Tomcat 容器</li><li>构建好的项目自动上传至 Nexus 私服存档</li><li>保存构建历史记录，并可以下载历史记录</li></ol><h4 id="2-2-持续化集成配置"><a href="#2-2-持续化集成配置" class="headerlink" title="2.2 持续化集成配置"></a>2.2 持续化集成配置</h4><ol><li> 新建 maven job</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220305154059.png"></p><ol start="2"><li>配置checkout 源码</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220305155309.png"></p><ol start="3"><li>编写 maven 构建命令</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220305162615.png"></p><p>构建结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220305170148.png"></p><ol start="4"><li>自动部署至 Tomcat 配置</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220305193106.png"></p><p>构建后访问：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220305193334.png"></p><p>自动部署的前提条件：<br>1.需要下载 Deploy to container 插件<br>2.设置Tomcat manager 用户和密码，以下配置加入至 Tomcat conf/tomcat-users.xml 中<br>3.tomcat webapp  中必须保留 manager 项目</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">&quot;admin-gui&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">&quot;manager-gui&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">role</span> <span class="hljs-attr">rolename</span>=<span class="hljs-string">&quot;manager-script&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">username</span>=<span class="hljs-string">&quot;manager&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;manager&quot;</span> <span class="hljs-attr">roles</span>=<span class="hljs-string">&quot;manager-gui,manager-script&quot;</span>/&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">user</span> <span class="hljs-attr">username</span>=<span class="hljs-string">&quot;admin&quot;</span> <span class="hljs-attr">password</span>=<span class="hljs-string">&quot;admin&quot;</span> <span class="hljs-attr">roles</span>=<span class="hljs-string">&quot;admin-gui,manager-gui&quot;</span>/&gt;</span><br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/weixin_33965305/article/details/93610207">远程无法管理 tomcat 问题</a></p><ol start="5"><li>存档配置<br>构建后发布到 nexus 私服</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220305233105.png"></p><p>配置 setting.xml 获取上传至 nexus 的权限：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs xml"><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-snapshot<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>deployment<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>deployment123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">server</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">id</span>&gt;</span>nexus-release<span class="hljs-tag">&lt;/<span class="hljs-name">id</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">username</span>&gt;</span>deployment<span class="hljs-tag">&lt;/<span class="hljs-name">username</span>&gt;</span><br><span class="hljs-tag">&lt;<span class="hljs-name">password</span>&gt;</span>deployment123<span class="hljs-tag">&lt;/<span class="hljs-name">password</span>&gt;</span><br><span class="hljs-tag">&lt;/<span class="hljs-name">server</span>&gt;</span><br></code></pre></td></tr></table></figure><p>构建结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220305233742.png"></p><h4 id="2-3-集成实现原理"><a href="#2-3-集成实现原理" class="headerlink" title="2.3 集成实现原理"></a>2.3 集成实现原理</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220306000108.png"></p><p>工作空间目录：~/.jenkins/workspace/</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220306000043.png"></p><h3 id="3-jenkins-pipeline-核心应用"><a href="#3-jenkins-pipeline-核心应用" class="headerlink" title="3. jenkins pipeline 核心应用"></a>3. jenkins pipeline 核心应用</h3><h4 id="3-1-pipeline-概要"><a href="#3-1-pipeline-概要" class="headerlink" title="3.1 pipeline 概要"></a>3.1 pipeline 概要</h4><p>使用 maven 来进行自动化构建，其流程分别是：构建环境准备 ——&gt; 源码下载——&gt;构建——&gt;存档——&gt;部署，这是一种固化的构建流程，如果需要多个项目进行依赖构建，这种复杂的构建场景 时该怎么办？jenkins pipeline 可以做到这一点。<br>Jenkins 从根本上讲是一种支持多种自动化模式的自动化引擎。Pipeline 在 Jenkins 上添加了一套强大的自动化工具，支持从简单的连续集成到全面的连续输送 Pipeline 的用例。用户可以基于他实现更为复杂的建模场景。</p><h4 id="3-2-pipeline-基础语法"><a href="#3-2-pipeline-基础语法" class="headerlink" title="3.2 pipeline 基础语法"></a>3.2 pipeline 基础语法</h4><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs json">pipeline &#123;<br>    agent any <br>    stages &#123;<br>        stage(&#x27;Build&#x27;) &#123; <br>            steps &#123; <br>                sh &#x27;make&#x27; <br>            &#125;<br>        &#125;<br>        stage(&#x27;Test&#x27;)&#123;<br>            steps &#123;<br>                sh &#x27;make check&#x27;<br>                junit &#x27;reports<span class="hljs-comment">/**/</span>*.xml&#x27; <br>            &#125;<br>        &#125;<br>        stage(&#x27;Deploy&#x27;) &#123;<br>            steps &#123;<br>                sh &#x27;make publish&#x27;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>agent  表示 Jenkins 应该为 Pipeline 的这一部分分配一个执行者和工作区。</li><li>stage  描述了这条 Pipeline 的一个阶段。</li><li>steps  描述了要在其中运行的步骤</li><li>sh      执行给定的 shell 命令</li><li>junit   是由 JUnit 插件提供的，用于聚合测试报告的 Pipeline 步骤。</li></ul><h4 id="3-3-pipeline-示例"><a href="#3-3-pipeline-示例" class="headerlink" title="3.3 pipeline 示例"></a>3.3 pipeline 示例</h4><p>前提条件：</p><ol><li>Jenkins 2.x 或更高版本</li><li>Pipeline插件</li></ol><p>可以通过以下任一方式创建基本 Pipeline：</p><ol><li>直接在 Jenkins 网页界面中输入脚本。</li><li>通过创建一个 Jenkinsfile 可以检入项目的源代码管理库。</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220306004515.png"></p><h5 id="Pipeline-script-方式"><a href="#Pipeline-script-方式" class="headerlink" title="Pipeline script 方式"></a>Pipeline script 方式</h5><p>点击”流水线语法“查看语法帮助：<br><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220306005949.png"></p><p>pipeline script：</p><figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs json">pipeline &#123;<br>    agent any <br>    stages &#123;<br>        stage(&#x27;checkout&#x27;) &#123; <br>            steps &#123; <br>                echo &#x27;checkout&#x27; <br>                checkout([$class: &#x27;GitSCM&#x27;, branches: [[name: &#x27;*/master&#x27;]], extensions: [], userRemoteConfigs: [[credentialsId: &#x27;<span class="hljs-number">3</span>c819818-d272<span class="hljs-number">-4155</span><span class="hljs-number">-91</span>d5<span class="hljs-number">-3</span>d59158e2823&#x27;, url: &#x27;http:<span class="hljs-comment">//192.168.60.10:3000/root/hello-debuggingWorld.git&#x27;]]])</span><br>            &#125;<br>        &#125;<br>        stage(&#x27;build&#x27;)&#123;<br>            steps &#123;<br>                 echo &#x27;build&#x27;<br>                 sh &#x27;mvn clean install&#x27;<br>            &#125;<br>        &#125;<br>        stage(&#x27;save&#x27;) &#123;<br>            steps &#123;<br>               echo &#x27;save&#x27;<br>               archiveArtifacts artifacts: &#x27;target<span class="hljs-comment">/*.war&#x27;, followSymlinks: false</span><br><span class="hljs-comment">            &#125;</span><br><span class="hljs-comment">        &#125;</span><br><span class="hljs-comment">    &#125;</span><br><span class="hljs-comment">&#125;</span><br></code></pre></td></tr></table></figure><p>构建结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220306011723.png"></p><h5 id="Jenkinsfile-方式"><a href="#Jenkinsfile-方式" class="headerlink" title="Jenkinsfile 方式"></a>Jenkinsfile 方式</h5><p>项目中添加 Jenkinsfile（内容同上）：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220306013006.png"></p><p>配置流水线：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220306012633.png"></p>]]></content>
    
    
    <categories>
      
      <category>jenkins</category>
      
    </categories>
    
    
    <tags>
      
      <tag>jenkins</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——socket 编程</title>
    <link href="/2022/01/17/Go%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    <url>/2022/01/17/Go%E2%80%94%E2%80%94%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Go-语言实现-TCP-通信"><a href="#1-Go-语言实现-TCP-通信" class="headerlink" title="1. Go 语言实现 TCP 通信"></a>1. Go 语言实现 TCP 通信</h3><p>TCP/IP(Transmission Control Protocol/Internet Protocol) 即传输控制协议/网间协议，是一种面向连接（连接导向）的、可靠的、基于字节流的传输层（Transport layer）通信协议。</p><h4 id="1-1-服务端"><a href="#1-1-服务端" class="headerlink" title="1.1 服务端"></a>1.1 服务端</h4><p>TCP 服务端程序的处理流程：</p><ol><li>监听端口</li><li>接收客户端请求建立链接</li><li>创建 goroutine 处理链接。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listen, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:28001&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;server error:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listen.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;accept fail:&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> process(conn)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br><span class="hljs-keyword">defer</span> conn.Close()<br><span class="hljs-keyword">var</span> buf [<span class="hljs-number">128</span>]<span class="hljs-keyword">byte</span><br><br><span class="hljs-keyword">for</span> &#123;<br>reader := bufio.NewReader(conn)<br><br>n, err := reader.Read(buf[:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;read from client failed, err:&quot;</span>, err)<br><span class="hljs-keyword">break</span><br>&#125;<br><br>res := <span class="hljs-keyword">string</span>(buf[:n])<br>fmt.Println(<span class="hljs-string">&quot;server 接收消息：&quot;</span>, res)<br>conn.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;收到&quot;</span>))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-客户端"><a href="#1-2-客户端" class="headerlink" title="1.2 客户端"></a>1.2 客户端</h4><p>一个 TCP 客户端进行 TCP 通信的流程如下：</p><ol><li>建立与服务端的链接</li><li>进行数据收发</li><li>关闭链接</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:28001&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;client connection error:&quot;</span>,err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-keyword">var</span> buf [<span class="hljs-number">128</span>]<span class="hljs-keyword">byte</span><br><br>inputReader := bufio.NewReader(os.Stdin)<br><span class="hljs-keyword">for</span> &#123;<br>readString, _ := inputReader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>)<br>readString = strings.Trim(readString,<span class="hljs-string">&quot;\r\nhello&quot;</span>)<br><span class="hljs-keyword">if</span> strings.EqualFold(readString, <span class="hljs-string">&quot;exit&quot;</span>) &#123;<span class="hljs-comment">// 退出</span><br><span class="hljs-keyword">return</span><br>&#125;<br>_, err = conn.Write([]<span class="hljs-keyword">byte</span>(readString)) <span class="hljs-comment">// 发送数据</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;client send error:&quot;</span>,err)<br><span class="hljs-keyword">return</span><br>&#125;<br><br>n, err := conn.Read(buf[:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;client receive error:&quot;</span>,err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-keyword">string</span>(buf[:n]))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-TCP黏包"><a href="#2-TCP黏包" class="headerlink" title="2. TCP黏包"></a>2. TCP黏包</h3><p><strong>服务端代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listen, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:28001&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;server error:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listen.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;accept fail:&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> process(conn)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br><span class="hljs-keyword">defer</span> conn.Close()<br><span class="hljs-keyword">var</span> buf [<span class="hljs-number">128</span>]<span class="hljs-keyword">byte</span><br>reader := bufio.NewReader(conn)<br><br><span class="hljs-keyword">for</span> &#123;<br>n, err := reader.Read(buf[:])<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;read from client failed, err:&quot;</span>, err)<br><span class="hljs-keyword">break</span><br>&#125;<br>res := <span class="hljs-keyword">string</span>(buf[:n])<br>fmt.Println(<span class="hljs-string">&quot;server 接收消息：&quot;</span>, res)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:28001&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;client connection error:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++ &#123;<br>conn.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hello debuggingWorld!&quot;</span>))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220118204607.png"></p><h4 id="2-1-粘包的原因"><a href="#2-1-粘包的原因" class="headerlink" title="2.1 粘包的原因"></a>2.1 粘包的原因</h4><p>主要原因就是 tcp 数据传递模式是流模式，在保持长连接的时候可以进行多次的收和发。</p><p>“粘包”可发生在发送端也可发生在接收端：</p><ol><li>由 Nagle 算法造成的发送端的粘包：Nagle 算法是一种改善网络传输效率的算法。简单来说就是当提交一段数据给 TCP 发送时，TCP 并不立刻发送此段数据，而是等待一小段时间看看在等待期间是否还有要发送的数据，若有则会一次把这两段数据发送出去。</li><li>接收端接收不及时造成的接收端粘包：TCP 会把接收到的数据存在自己的缓冲区中，然后通知应用层取数据。当应用层由于某些原因不能及时的把 TCP 的数据取出来，就会造成 TCP 缓冲区中存放了几段数据。</li></ol><h4 id="2-2-解决办法"><a href="#2-2-解决办法" class="headerlink" title="2.2 解决办法"></a>2.2 解决办法</h4><p>出现”粘包”的关键在于接收方不确定将要传输的数据包的大小，因此我们可以对数据包进行封包和拆包的操作。</p><p>封包：封包就是给一段数据加上包头，这样一来数据包就分为包头和包体两部分内容了(过滤非法包时封包会加入”包尾”内容)。包头部分的长度是固定的，并且它存储了包体的长度，根据包头长度固定以及包头中含有包体长度的变量就能正确的拆分出一个完整的数据包。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> proto<br><br><span class="hljs-keyword">import</span> (<br><span class="hljs-string">&quot;bufio&quot;</span><br><span class="hljs-string">&quot;bytes&quot;</span><br><span class="hljs-string">&quot;encoding/binary&quot;</span><br>)<br><br><span class="hljs-comment">// Encode 消息编码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Encode</span><span class="hljs-params">(message <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">([]<span class="hljs-keyword">byte</span>, error)</span></span> &#123;<br><span class="hljs-comment">// 消息头前四个字节为消息体长度</span><br>length := <span class="hljs-keyword">int32</span>(<span class="hljs-built_in">len</span>(message))<br><br>buffer := <span class="hljs-built_in">new</span>(bytes.Buffer)<br>err := binary.Write(buffer, binary.LittleEndian, length)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-comment">// 写入消息体</span><br>err = binary.Write(buffer, binary.LittleEndian, []<span class="hljs-keyword">byte</span>(message))<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, err<br>&#125;<br><span class="hljs-keyword">return</span> buffer.Bytes(), <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-comment">// Decode 消息解码</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Decode</span><span class="hljs-params">(reader *bufio.Reader)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span> &#123;<br><span class="hljs-comment">// 读取消息体长度</span><br>lenByte, _ := reader.Peek(<span class="hljs-number">4</span>)<br>buffer := bytes.NewBuffer(lenByte)<br><br><span class="hljs-keyword">var</span> length <span class="hljs-keyword">int32</span><br>err := binary.Read(buffer, binary.LittleEndian, &amp;length)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br><span class="hljs-comment">// Buffered返回缓冲中现有的可读取的字节数。</span><br><span class="hljs-keyword">if</span> <span class="hljs-keyword">int32</span>(reader.Buffered()) &lt; length+<span class="hljs-number">4</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, err<br>&#125;<br><br><span class="hljs-comment">// 读取真正的消息数据</span><br>msg := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, length+<span class="hljs-number">4</span>)<br><br>_, err = reader.Read(msg)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, <span class="hljs-literal">nil</span><br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-keyword">string</span>(msg[<span class="hljs-number">4</span>:]), <span class="hljs-literal">nil</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>服务端代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>listen, err := net.Listen(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;:28001&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;server error:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">for</span> &#123;<br>conn, err := listen.Accept()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;accept fail:&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br><span class="hljs-keyword">go</span> process(conn)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">process</span><span class="hljs-params">(conn net.Conn)</span></span> &#123;<br><span class="hljs-keyword">defer</span> conn.Close()<br>reader := bufio.NewReader(conn)<br><br><span class="hljs-keyword">for</span> &#123;<br>res, err := proto.Decode(reader)<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;decode msg failed, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;server 接收消息：&quot;</span>, res)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端代码：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := net.Dial(<span class="hljs-string">&quot;tcp&quot;</span>, <span class="hljs-string">&quot;127.0.0.1:28001&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;client connection error:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++ &#123;<br>bytes, err := proto.Encode(<span class="hljs-string">&quot;hello debuggingWorld!&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;encode msg failed, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>conn.Write(bytes)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220118213857.png"></p><h3 id="3-Go语言实现UDP通信"><a href="#3-Go语言实现UDP通信" class="headerlink" title="3. Go语言实现UDP通信"></a>3. Go语言实现UDP通信</h3><p>UDP 协议（User Datagram Protocol）中文名称是用户数据报协议，是 OSI（Open System Interconnection，开放式系统互联）参考模型中一种无连接的传输层协议，不需要建立连接就能直接进行数据发送和接收，属于不可靠的、没有时序的通信，但是UDP协议的实时性比较好，通常用于视频直播相关领域。</p><p><strong>服务端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>conn, err := net.ListenUDP(<span class="hljs-string">&quot;udp&quot;</span>,&amp;net.UDPAddr&#123;<br>IP: net.IPv4(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,<span class="hljs-number">0</span>),<br>Port: <span class="hljs-number">8888</span>,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;udp server listen fail:&quot;</span>,err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> conn.Close()<br><br><span class="hljs-keyword">var</span> buf [<span class="hljs-number">1024</span>]<span class="hljs-keyword">byte</span><br><br><span class="hljs-keyword">for</span> &#123;<br>n, addr, err := conn.ReadFromUDP(buf[:])<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;read udp failed, err:&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;data:%v addr:%v count:%v\n&quot;</span>, <span class="hljs-keyword">string</span>(buf[:n]), addr, n)<br><br>_, err = conn.WriteToUDP([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;已接收&quot;</span>), addr)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;write to udp failed, err:&quot;</span>, err)<br><span class="hljs-keyword">continue</span><br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>客户端</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>socket, err := net.DialUDP(<span class="hljs-string">&quot;udp&quot;</span>, <span class="hljs-literal">nil</span>, &amp;net.UDPAddr&#123;<br>IP:   net.IPv4(<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>),<br>Port: <span class="hljs-number">8888</span>,<br>&#125;)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;连接服务端失败，err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> socket.Close()<br>sendData := []<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;Hello server&quot;</span>)<br>_, err = socket.Write(sendData) <span class="hljs-comment">// 发送数据</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;发送数据失败，err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>data := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">4096</span>)<br>n, remoteAddr, err := socket.ReadFromUDP(data) <span class="hljs-comment">// 接收数据</span><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;接收数据失败，err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;recv:%v addr:%v count:%v\n&quot;</span>, <span class="hljs-keyword">string</span>(data[:n]), remoteAddr, n)<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——文件操作</title>
    <link href="/2022/01/16/Go%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/"/>
    <url>/2022/01/16/Go%E2%80%94%E2%80%94%E6%96%87%E4%BB%B6%E6%93%8D%E4%BD%9C/</url>
    
    <content type="html"><![CDATA[<h3 id="1-目录操作"><a href="#1-目录操作" class="headerlink" title="1. 目录操作"></a>1. 目录操作</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 创建目录</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">createDir</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建单个目录</span><br><span class="hljs-comment">// err := os.Mkdir(&quot;test&quot;, os.ModePerm)</span><br>err := os.MkdirAll(<span class="hljs-string">&quot;test/a/b&quot;</span>, os.ModePerm)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;err: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 删除目录</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">removeDir</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// err := os.Remove(&quot;test.txt&quot;)</span><br><br>err := os.RemoveAll(<span class="hljs-string">&quot;test&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;err: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-comment">// 获得工作目录</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getWd</span><span class="hljs-params">()</span></span> &#123;<br>dir, err := os.Getwd()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;err: %v\n&quot;</span>, err)<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;dir: %v\n&quot;</span>, dir)<br>&#125;<br><br><span class="hljs-comment">// 获得临时目录</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getTemp</span><span class="hljs-params">()</span></span> &#123;<br>s := os.TempDir()<br>fmt.Printf(<span class="hljs-string">&quot;s: %v\n&quot;</span>, s)<br>&#125;<br><br><span class="hljs-comment">// 重命名文件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">renameFile</span><span class="hljs-params">()</span></span> &#123;<br>err := os.Rename(<span class="hljs-string">&quot;test.txt&quot;</span>, <span class="hljs-string">&quot;test2.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;err: %v\n&quot;</span>, err)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>createDir()<br>removeDir()<br>getWd()<br>getTemp()<br>renameFile()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="2. 文件操作"></a>2. 文件操作</h3><h4 id="2-1-打开和关闭文件"><a href="#2-1-打开和关闭文件" class="headerlink" title="2.1 打开和关闭文件"></a>2.1 打开和关闭文件</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 关闭文件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(f \*File)</span> <span class="hljs-title">Close</span><span class="hljs-params">()</span> <span class="hljs-title">error</span></span><br><span class="hljs-comment">// 以只读的方式打开文件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Open</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(\*File, error)</span></span><br><span class="hljs-comment">// 以指定模式打开文件</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">OpenFile</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, flag <span class="hljs-keyword">int</span>, perm FileMode)</span> <span class="hljs-params">(\*File, error)</span></span><br></code></pre></td></tr></table></figure><p>其中：</p><ul><li>name：要打开的文件名</li><li>perm：文件权限，一个八进制数。r（读）04，w（写）02，x（执行）01。</li><li>flag：打开文件的模式。 模式有以下几种：</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220116182739.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 只读方式打开</span><br><span class="hljs-comment">//file, err := os.Open(&quot;./test&quot;)</span><br><br>file, err := os.OpenFile(<span class="hljs-string">&quot;./test.txt&quot;</span>, os.O_RDWR | os.O_CREATE, <span class="hljs-number">0777</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;open file failed!, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-comment">// 关闭文件</span><br>file.Close()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-文件读取"><a href="#2-2-文件读取" class="headerlink" title="2.2 文件读取"></a>2.2 文件读取</h4><h5 id="file-Read"><a href="#file-Read" class="headerlink" title="file.Read()"></a>file.Read()</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>file, err := os.Open(<span class="hljs-string">&quot;./test.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;open file failed!, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br><br><span class="hljs-comment">// 循环读取文件</span><br><span class="hljs-keyword">var</span> tmp = <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">128</span>)<br><span class="hljs-keyword">for</span> &#123;<br>n, err := file.Read(tmp)<br><span class="hljs-keyword">if</span> err == io.EOF &#123;<span class="hljs-comment">// 文件读取结束</span><br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;read file failed, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Print(<span class="hljs-keyword">string</span>(tmp[:n]))<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="bufio"><a href="#bufio" class="headerlink" title="bufio"></a>bufio</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>file, err := os.Open(<span class="hljs-string">&quot;./test.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;open file failed!, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br><br>reader := bufio.NewReader(file)<br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-comment">// line, err := reader.ReadBytes(&#x27;\n&#x27;)</span><br>line, err := reader.ReadString(<span class="hljs-string">&#x27;\n&#x27;</span>) <span class="hljs-comment">//注意是字符</span><br><span class="hljs-keyword">if</span> err == io.EOF &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(line) != <span class="hljs-number">0</span> &#123;<br>fmt.Println(line)<br>&#125;<br><span class="hljs-keyword">break</span><br>&#125;<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;read file failed, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Print(line)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h5 id="ioutil"><a href="#ioutil" class="headerlink" title="ioutil"></a>ioutil</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>content, err := ioutil.ReadFile(<span class="hljs-string">&quot;./test.txt&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;read file failed, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-keyword">string</span>(content))<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-3-文件写入"><a href="#2-3-文件写入" class="headerlink" title="2.3 文件写入"></a>2.3 文件写入</h4><h5 id="Write和WriteString"><a href="#Write和WriteString" class="headerlink" title="Write和WriteString"></a>Write和WriteString</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>file, err := os.OpenFile(<span class="hljs-string">&quot;xx.txt&quot;</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="hljs-number">0666</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;open file failed, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br>str := <span class="hljs-string">&quot;满腹经纶，白发不第；&quot;</span><br>file.Write([]<span class="hljs-keyword">byte</span>(str))       <span class="hljs-comment">//写入字节切片数据</span><br>file.WriteString(<span class="hljs-string">&quot;才疏学浅，少年登科&quot;</span>) <span class="hljs-comment">//直接写入字符串数据</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="bufio-1"><a href="#bufio-1" class="headerlink" title="bufio"></a>bufio</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>file, err := os.OpenFile(<span class="hljs-string">&quot;xx.txt&quot;</span>, os.O_CREATE|os.O_TRUNC|os.O_WRONLY, <span class="hljs-number">0666</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;open file failed, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br><span class="hljs-keyword">defer</span> file.Close()<br>writer := bufio.NewWriter(file)<br><br>writer.Write([]<span class="hljs-keyword">byte</span>(<span class="hljs-string">&quot;hello &quot;</span>))<br>writer.WriteString(<span class="hljs-string">&quot;debuggingWorld&quot;</span>)<br><br>writer.Flush() <span class="hljs-comment">//将缓存中的内容写入文件</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="ioutil-WriteFile"><a href="#ioutil-WriteFile" class="headerlink" title="ioutil.WriteFile"></a>ioutil.WriteFile</h5><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>str := <span class="hljs-string">&quot;hello debuggingWorld&quot;</span><br>err := ioutil.WriteFile(<span class="hljs-string">&quot;./xx.txt&quot;</span>, []<span class="hljs-keyword">byte</span>(str), <span class="hljs-number">0666</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;write file failed, err:&quot;</span>, err)<br><span class="hljs-keyword">return</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——并发</title>
    <link href="/2022/01/13/Go%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91/"/>
    <url>/2022/01/13/Go%E2%80%94%E2%80%94%E5%B9%B6%E5%8F%91/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Goroutine"><a href="#1-Goroutine" class="headerlink" title="1. Goroutine"></a>1. Goroutine</h3><p>Go 语言中的 goroutine 是由 Go 的运行时（runtime）调度和管理的。Go 程序会将 goroutine 中的任务合理地分配给每个CPU。</p><p>OS线程（操作系统线程）一般都有固定的栈内存（通常为2MB）,一个 goroutine 的栈在其生命周期开始时只有很小的栈（典型情况下 2KB），goroutine 的栈不是固定的，他可以按需增大和缩小，goroutine 的栈大小限制可以达到1GB。</p><h4 id="1-1-使用-goroutine"><a href="#1-1-使用-goroutine" class="headerlink" title="1.1 使用 goroutine"></a>1.1 使用 goroutine</h4><p>Go 语言中使用g oroutine 非常简单，只需要在调用函数的时候在前面加上 go 关键字，就可以为一个函数创建一个 goroutine。</p><p>一个 goroutine 必定对应一个函数，可以创建多个 goroutine 去执行相同的函数。</p><p>使用 go 关键字创建 goroutine 时，被调用函数的返回值会被忽略。</p><p>在程序启动时，Go 程序就会为 main() 函数创建一个默认的 goroutine。所有 goroutine 在 main() 函数结束时会一同结束。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//go 关键字放在方法调用前新建一个 goroutine 并执行方法体</span><br><span class="hljs-keyword">go</span> GetThingDone(param1, param2);<br><br><span class="hljs-comment">//新建一个匿名方法并执行</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(param1, param2)</span></span> &#123;<br>&#125;(val1, val2)<br><br><span class="hljs-keyword">go</span> 语句<br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;this is a goroutine&quot;</span>)<br>&#125;()<br><br>fmt.Println(<span class="hljs-string">&quot;this is main goroutine !&quot;</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-GOMAXPROCS"><a href="#1-2-GOMAXPROCS" class="headerlink" title="1.2 GOMAXPROCS"></a>1.2 GOMAXPROCS</h4><p>Go 运行时的调度器使用 <code>GOMAXPROCS</code> 参数来确定需要使用多少个 OS 线程来同时执行 Go 代码。默认值是机器上的CPU核心数。</p><p>Go语言中可以通过runtime.GOMAXPROCS()函数设置当前程序并发时占用的CPU逻辑核心数。</p><p>Go1.5版本之前，默认使用的是单核心执行。Go1.5版本之后，默认使用全部的CPU逻辑核心数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">a</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;A:&quot;</span>, i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">b</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>fmt.Println(<span class="hljs-string">&quot;B:&quot;</span>, i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>runtime.GOMAXPROCS(<span class="hljs-number">1</span>)<br><br><span class="hljs-keyword">go</span> a()<br><span class="hljs-keyword">go</span> b()<br>time.Sleep(time.Second)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-channel"><a href="#2-channel" class="headerlink" title="2. channel"></a>2. channel</h3><p>Go 语言的并发模型是 CSP（Communicating Sequential Processes），提倡 <code>通过通信共享内存</code>而不是<code>通过共享内存而实现通信</code>。</p><p>如果说 goroutine 是 Go 程序并发的执行体，channel 就是它们之间的连接。channel 是可以让一个 goroutine 发送特定值到另一个 goroutine 的通信机制。</p><p>Go语言中的通道（channel）是一种特殊的类型。在任何时候，同时只能有一个 goroutine 访问通道进行发送和获取数据。goroutine 间通过通道就可以通信。</p><p>通道像一个队列，总是遵循先入先出（First In First Out）的规则，保证收发数据的顺序。</p><h4 id="2-1-channel-类型"><a href="#2-1-channel-类型" class="headerlink" title="2.1 channel 类型"></a>2.1 channel 类型</h4><p>channel 是一种类型，一种引用类型。声明通道类型的格式如下：</p><blockquote><p>var　变量　chan　元素类型</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> ch1 <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>   <span class="hljs-comment">// 声明一个传递整型的通道</span><br><span class="hljs-keyword">var</span> ch2 <span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>  <span class="hljs-comment">// 声明一个传递布尔型的通道</span><br><span class="hljs-keyword">var</span> ch3 <span class="hljs-keyword">chan</span> []<span class="hljs-keyword">int</span> <span class="hljs-comment">// 声明一个传递int切片的通道</span><br></code></pre></td></tr></table></figure><h4 id="2-2-创建-channel"><a href="#2-2-创建-channel" class="headerlink" title="2.2 创建 channel"></a>2.2 创建 channel</h4><p>通道是引用类型，通道类型的空值是nil。</p><p>声明的通道后需要使用 make 函数初始化之后才能使用。</p><p>创建channel的格式如下：</p><blockquote><p>make(chan 元素类型, [缓冲大小])</p></blockquote><p>channel 的缓冲大小是可选的。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go">ch4 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>ch5 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">bool</span>)<br>ch6 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> []<span class="hljs-keyword">int</span>)<br></code></pre></td></tr></table></figure><h4 id="2-3-channel-操作"><a href="#2-3-channel-操作" class="headerlink" title="2.3 channel 操作"></a>2.3 channel 操作</h4><p>通道有发送（send）、接收(receive）和关闭（close）三种操作。</p><p>发送和接收都使用 &lt;- 符号。</p><p>关闭后的通道有以下特点：</p><blockquote><ul><li>对一个关闭的通道再发送值就会导致 panic。</li><li>对一个关闭的通道进行接收会一直获取值直到通道为空。</li><li>对一个关闭的并且没有值的通道执行接收操作会得到对应类型的零值。</li><li>关闭一个已经关闭的通道会导致 panic。</li></ul></blockquote><h4 id="2-4-for-range-从通道循环接收"><a href="#2-4-for-range-从通道循环接收" class="headerlink" title="2.4 for range 从通道循环接收"></a>2.4 for range 从通道循环接收</h4><p>使用 for range 遍历通道，当通道被关闭的时候就会退出 for range。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go">ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><span class="hljs-comment">// 开启 goroutine 将 0~100 的数发送到 ch1 中</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>ch1 &lt;- i<br>&#125;<br><span class="hljs-built_in">close</span>(ch1)<br>&#125;()<br><span class="hljs-comment">// 开启 goroutine 从 ch1 中接收值，并将该值的平方发送到 ch2 中</span><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> &#123;<br>i, ok := &lt;-ch1 <span class="hljs-comment">// 通道关闭后再取值 ok =false</span><br><span class="hljs-keyword">if</span> !ok &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>ch2 &lt;- i * i<br>&#125;<br><span class="hljs-built_in">close</span>(ch2)<br>&#125;()<br><br><span class="hljs-comment">// 在主 goroutine 中从 ch2 中接收值打印</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> ch2 &#123; <span class="hljs-comment">// 通道关闭后会退出 for range 循环</span><br>fmt.Println(i)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-5-无缓冲的通道"><a href="#2-5-无缓冲的通道" class="headerlink" title="2.5 无缓冲的通道"></a>2.5 无缓冲的通道</h4><p>无缓冲的通道又称为阻塞的通道。</p><p>无缓冲通道上的发送操作会阻塞，直到另一个 goroutine 在该通道上执行接收操作，这时值才能发送成功，两个 goroutine 将继续执行。相反，如果接收操作先执行，接收方的 goroutine 将阻塞，直到另一个 goroutine 在该通道上发送一个值。</p><p>使用无缓冲通道进行通信将导致发送和接收的 goroutine 同步化。因此，无缓冲通道也被称为同步通道。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">receive</span><span class="hljs-params">(c <span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br>ret := &lt;-c<br>fmt.Println(<span class="hljs-string">&quot;接收成功&quot;</span>, ret)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><span class="hljs-keyword">go</span> receive(ch) <span class="hljs-comment">// 启用 goroutine 从通道接收值</span><br>ch &lt;- <span class="hljs-number">10</span><br>fmt.Println(<span class="hljs-string">&quot;发送成功&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-6-有缓冲的通道"><a href="#2-6-有缓冲的通道" class="headerlink" title="2.6 有缓冲的通道"></a>2.6 有缓冲的通道</h4><p>有缓冲的通道（buffered channel）是一种在被接收前能存储一个或者多个值的通道。这种类型的通道并不强制要求 goroutine 之间必须同时完成发送和接收。通道会阻塞发送和接收动作的条件也会不同。只有在通道中没有要接收的值时，接收动作才会阻塞。只有在通道没有可用缓冲区容纳被发送的值时，发送动作才会阻塞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 创建一个3个元素缓冲大小的整型通道</span><br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">3</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(ch)) <span class="hljs-comment">// 0</span><br>ch &lt;- <span class="hljs-number">1</span><br>ch &lt;- <span class="hljs-number">2</span><br>ch &lt;- <span class="hljs-number">3</span><br>fmt.Println(<span class="hljs-built_in">len</span>(ch)) <span class="hljs-comment">// 3</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-7-单向通道"><a href="#2-7-单向通道" class="headerlink" title="2.7 单向通道"></a>2.7 单向通道</h4><p>声明格式：</p><blockquote><p>var 通道实例 chan&lt;- 元素类型    // 只能写入数据的通道<br>var 通道实例 &lt;-chan 元素类型    // 只能读取数据的通道</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">counter</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">100</span>; i++ &#123;<br>out &lt;- i<br>&#125;<br><span class="hljs-built_in">close</span>(out)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">squarer</span><span class="hljs-params">(out <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>, in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> in &#123;<br>out &lt;- i * i<br>&#125;<br><span class="hljs-built_in">close</span>(out)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printer</span><span class="hljs-params">(in &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-keyword">range</span> in &#123;<br>fmt.Println(i)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch1 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br>ch2 := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>)<br><span class="hljs-keyword">go</span> counter(ch1)<br><span class="hljs-keyword">go</span> squarer(ch2, ch1)<br>printer(ch2)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-8-worker-pool"><a href="#2-8-worker-pool" class="headerlink" title="2.8 worker pool"></a>2.8 worker pool</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">worker</span><span class="hljs-params">(id <span class="hljs-keyword">int</span>, jobs &lt;-<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, results <span class="hljs-keyword">chan</span>&lt;- <span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-keyword">range</span> jobs &#123;<br>fmt.Printf(<span class="hljs-string">&quot;worker:%d start job:%d\n&quot;</span>, id, j)<br>time.Sleep(time.Second)<br>fmt.Printf(<span class="hljs-string">&quot;worker:%d end job:%d\n&quot;</span>, id, j)<br>results &lt;- j * <span class="hljs-number">2</span><br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>jobs := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">100</span>)<br>results := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">100</span>)<br><span class="hljs-comment">// 开启 3 个 goroutine</span><br><span class="hljs-keyword">for</span> w := <span class="hljs-number">1</span>; w &lt;= <span class="hljs-number">3</span>; w++ &#123;<br><span class="hljs-keyword">go</span> worker(w, jobs, results)<br>&#125;<br><span class="hljs-comment">// 5个任务</span><br><span class="hljs-keyword">for</span> j := <span class="hljs-number">1</span>; j &lt;= <span class="hljs-number">5</span>; j++ &#123;<br>jobs &lt;- j<br>&#125;<br><span class="hljs-built_in">close</span>(jobs)<br><span class="hljs-comment">// 输出结果</span><br><span class="hljs-keyword">for</span> a := <span class="hljs-number">1</span>; a &lt;= <span class="hljs-number">5</span>; a++ &#123;<br>fmt.Println(&lt;-results)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-9-通道异常总结"><a href="#2-9-通道异常总结" class="headerlink" title="2.9 通道异常总结"></a>2.9 通道异常总结</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220114215946.png"></p><p>关闭已经关闭的 channel 也会引发 panic。</p><h3 id="3-select-语句"><a href="#3-select-语句" class="headerlink" title="3. select 语句"></a>3. select 语句</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">select</span> &#123;<br>    <span class="hljs-keyword">case</span> communication clause  :<br>       statement(s);      <br>    <span class="hljs-keyword">case</span> communication clause  :<br>       statement(s);<br>    ...<br>    <span class="hljs-keyword">default</span> : <span class="hljs-comment">/* 可选 */</span><br>       statement(s);<br>&#125;<br></code></pre></td></tr></table></figure><ul><li>每个 case 都必须是一个通信（接收或发送）</li><li>所有 channel 表达式都会被求值</li><li>如果任意某个通信可以进行，它就执行，其他被忽略。</li><li>对于没有 case 的 select{} 会一直等待。</li><li>如果有多个 case 都可以运行，Select 会随机公平地选出一个执行。其他不会执行。<br>否则：<ol><li>如果有 default 子句，则执行该语句。</li><li>如果没有 default 子句，select 将阻塞，直到某个通信可以运行；Go 不会重新对 channel 或值进行求值。</li></ol></li></ul><p>例1：打印偶数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>ch := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">int</span>, <span class="hljs-number">1</span>)<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> x := &lt;-ch:<br>fmt.Println(x)<br><span class="hljs-keyword">case</span> ch &lt;- i:<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>例2：火箭点火<br>火箭点火倒计时10秒，如果键盘输入任意字符就打断点火，如果没有就10s后起飞。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>abort := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">chan</span> <span class="hljs-keyword">struct</span>&#123;&#125;)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>os.Stdin.Read(<span class="hljs-built_in">make</span>([]<span class="hljs-keyword">byte</span>, <span class="hljs-number">1</span>))<br>abort &lt;- <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br>&#125;()<br>fmt.Println(<span class="hljs-string">&quot;start countdown&quot;</span>)<br><span class="hljs-keyword">select</span> &#123;<br><span class="hljs-keyword">case</span> &lt;-time.After(<span class="hljs-number">10</span> * time.Second):<br><span class="hljs-keyword">case</span> &lt;-abort:<br>fmt.Println(<span class="hljs-string">&quot;Launch aborted!&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;launch&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-并发安全和锁"><a href="#4-并发安全和锁" class="headerlink" title="4. 并发安全和锁"></a>4. 并发安全和锁</h3><p>多个 goroutine 同时操作一个资源（临界区），会发生竞态问题（数据竞态）。</p><h4 id="4-1-互斥锁"><a href="#4-1-互斥锁" class="headerlink" title="4.1 互斥锁"></a>4.1 互斥锁</h4><p>互斥锁是一种常用的控制共享资源访问的方法，它能够保证同时只有一个 goroutine 可以访问共享资源。Go 语言中使用 sync 包的 Mutex 类型来实现互斥锁。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x <span class="hljs-keyword">int64</span><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-keyword">var</span> lock sync.Mutex<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5000</span>; i++ &#123;<br>lock.Lock() <span class="hljs-comment">// 加锁</span><br>x = x + <span class="hljs-number">1</span><br>lock.Unlock() <span class="hljs-comment">// 解锁</span><br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg.Add(<span class="hljs-number">2</span>)<br><span class="hljs-keyword">go</span> add()<br><span class="hljs-keyword">go</span> add()<br>wg.Wait()<br>fmt.Println(x)<br>&#125;<br></code></pre></td></tr></table></figure><p>使用互斥锁能够保证同一时间有且只有一个 goroutine 进入临界区，其他的 goroutine 则在等待锁；当互斥锁释放后，等待的 goroutine 才可以获取锁进入临界区，多个 goroutine 同时等待一个锁时，唤醒的策略是随机的。</p><h4 id="4-2-读写互斥锁"><a href="#4-2-读写互斥锁" class="headerlink" title="4.2 读写互斥锁"></a>4.2 读写互斥锁</h4><p>读写锁分为两种：读锁和写锁。当一个 goroutine 获取读锁之后，其他的goroutine如果是获取读锁会继续获得锁，如果是获取写锁就会等待；当一个 goroutine 获取写锁之后，其他的 goroutine 无论是获取读锁还是写锁都会等待。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>x      <span class="hljs-keyword">int64</span><br>wg     sync.WaitGroup<br>rwLock sync.RWMutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">write</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>rwLock.Lock() <span class="hljs-comment">// 加写锁</span><br>x = x + <span class="hljs-number">1</span><br>time.Sleep(<span class="hljs-number">10</span> * time.Millisecond) <span class="hljs-comment">// 假设读操作耗时10毫秒</span><br>rwLock.Unlock()                   <span class="hljs-comment">// 解写锁</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">read</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">defer</span> wg.Done()<br>rwLock.RLock()               <span class="hljs-comment">// 加读锁</span><br>time.Sleep(time.Millisecond) <span class="hljs-comment">// 假设读操作耗时1毫秒</span><br>rwLock.RUnlock()             <span class="hljs-comment">// 解读锁</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> write()<br>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">1000</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> read()<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-3-sync-WaitGroup"><a href="#4-3-sync-WaitGroup" class="headerlink" title="4.3 sync.WaitGroup"></a>4.3 sync.WaitGroup</h4><p>sync.WaitGroup 方法：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220115180328.png"></p><p>需要注意sync.WaitGroup是一个结构体，传递的时候要传递指针。</p><h4 id="4-4-sync-Once"><a href="#4-4-sync-Once" class="headerlink" title="4.4 sync.Once"></a>4.4 sync.Once</h4><p>Once is an object that will perform exactly one action.</p><p>可以用来实现加载配置文件等只需要加载一次的操作。</p><p>sync.Once 实现的并发安全的单例模式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> singleton <span class="hljs-keyword">struct</span> &#123;&#125;<br><br><span class="hljs-keyword">var</span> instance *singleton<br><span class="hljs-keyword">var</span> once sync.Once<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">GetInstance</span><span class="hljs-params">()</span> *<span class="hljs-title">singleton</span></span> &#123;<br>once.Do(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>instance = &amp;singleton&#123;&#125;<br>&#125;)<br><span class="hljs-keyword">return</span> instance<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-5-sync-Map"><a href="#4-5-sync-Map" class="headerlink" title="4.5 sync.Map"></a>4.5 sync.Map</h4><p>Go 语言中内置的 map 不是并发安全的</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> m = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)<br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span></span> &#123;<br>key := strconv.Itoa(n)<br>m[key] = n<br>fmt.Printf(<span class="hljs-string">&quot;k=:%v,v:=%v\n&quot;</span>, key, m[key])<br>wg.Done()<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><p>报错：fatal error: concurrent map writes</p><p>Go 语言的 sync 包中提供了一个开箱即用的并发安全版 map——sync.Map。开箱即用表示不用像内置的 map 一样使用 make 函数初始化就能直接使用。同时 sync.Map 内置了诸如 Store、Load、LoadOrStore、Delete、Range 等操作方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> m = sync.Map&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>wg := sync.WaitGroup&#123;&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">20</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span></span> &#123;<br>key := strconv.Itoa(n)<br>m.Store(key, n)<br>value, _ := m.Load(key)<br>fmt.Printf(<span class="hljs-string">&quot;k=:%v,v:=%v\n&quot;</span>, key, value)<br>wg.Done()<br>&#125;(i)<br>&#125;<br>wg.Wait()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-6-sync-Pool"><a href="#4-6-sync-Pool" class="headerlink" title="4.6 sync.Pool"></a>4.6 sync.Pool</h4><p>sync.Pool是一个并发池，负责安全地保存一组对象。它有两个导出方法：</p><ul><li>Get() interface{} 用来从并发池中随机取出元素。</li><li>Put(interface{}) 将一个对象加入并发池。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>pool := &amp;sync.Pool&#123;&#125;<br><br>pool.Put(NewConnection(<span class="hljs-number">1</span>))<br>pool.Put(NewConnection(<span class="hljs-number">2</span>))<br>pool.Put(NewConnection(<span class="hljs-number">3</span>))<br><br>connection := pool.Get().(*Connection)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, connection.id)<br>connection = pool.Get().(*Connection)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, connection.id)<br>connection = pool.Get().(*Connection)<br>fmt.Printf(<span class="hljs-string">&quot;%d\n&quot;</span>, connection.id)<br>&#125;<br></code></pre></td></tr></table></figure><p>还可以为 sync.Pool 指定一个创建者方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>pool := &amp;sync.Pool&#123;<br>New: <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span> <span class="hljs-title">interface</span></span>&#123;&#125; &#123;<br><span class="hljs-keyword">return</span> NewConnection()<br>&#125;,<br>&#125;<br><br>connection := pool.Get().(*Connection)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-7-sync-Cond"><a href="#4-7-sync-Cond" class="headerlink" title="4.7 sync.Cond"></a>4.7 sync.Cond</h4><p>类似与Java的wait和notify 或者说 Condition ，更像后者，但是没有超时的机制。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>mutex := sync.Mutex&#123;&#125;<br>start := sync.NewCond(&amp;mutex)<br><br><span class="hljs-keyword">for</span> x := <span class="hljs-number">0</span>; x &lt; <span class="hljs-number">10</span>; x++ &#123;<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>start.L.Lock()<br><span class="hljs-keyword">defer</span> start.L.Unlock()<br>start.Wait()<br>fmt.Println(<span class="hljs-string">&quot;do work&quot;</span>)<br>&#125;()<br>&#125;<br><br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>time.Sleep(time.Second * <span class="hljs-number">3</span>)<br>start.Broadcast()<br>&#125;()<br><br>time.Sleep(time.Second * <span class="hljs-number">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-原子操作"><a href="#5-原子操作" class="headerlink" title="5. 原子操作"></a>5. 原子操作</h3><p>Go语言中原子操作由内置的标准库sync/atomic提供。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220115185737.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> counter <span class="hljs-keyword">int64</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">var</span> wg sync.WaitGroup<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">10000</span>; i++ &#123;<br>wg.Add(<span class="hljs-number">1</span>)<br><span class="hljs-keyword">go</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>atomic.AddInt64(&amp;counter, <span class="hljs-number">1</span>)<br>wg.Done()<br>&#125;()<br>&#125;<br>wg.Wait()<br>fmt.Println(atomic.LoadInt64(&amp;counter))<span class="hljs-comment">// 10000</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——反射</title>
    <link href="/2022/01/11/Go%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84/"/>
    <url>/2022/01/11/Go%E2%80%94%E2%80%94%E5%8F%8D%E5%B0%84/</url>
    
    <content type="html"><![CDATA[<p>反射是指在程序运行期对程序本身进行访问和修改的能力。</p><p>支持反射的语言可以在程序编译期将变量的反射信息，如字段名称、类型信息、结构体信息等整合到可执行文件中，并给程序提供接口访问反射信息，这样就可以在程序运行期获取类型的反射信息，并且有能力修改它们。</p><p>Go 程序在运行期使用 reflect 包访问程序的反射信息。</p><h3 id="1-reflect-包"><a href="#1-reflect-包" class="headerlink" title="1. reflect 包"></a>1. reflect 包</h3><p>在 Go 语言的反射机制中，任何接口值都由是一个 <strong>具体类型</strong> 和 <strong>具体类型的值</strong> 两部分组成。<br>在 Go 语言中反射的相关功能由内置的 reflect 包提供，任意接口值在反射中都可以理解为由 reflect.Type 和 reflect.Value 两部分组成，并且 reflect 包提供了 reflect.TypeOf 和 reflect.ValueOf 两个函数来获取任意对象的 Value 和 Type。</p><h4 id="1-1-reflect-Type"><a href="#1-1-reflect-Type" class="headerlink" title="1.1 reflect.Type"></a>1.1 reflect.Type</h4><p>使用 reflect.TypeOf() 函数可以获得任意值的类型对象（reflect.Type），程序通过类型对象可以访问任意值的类型信息。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span><br>typeOfA := reflect.TypeOf(a)<br>fmt.Println(typeOfA.Name(), typeOfA.Kind())<span class="hljs-comment">// int int</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="反射的类型（Type）与种类（Kind）"><a href="#反射的类型（Type）与种类（Kind）" class="headerlink" title="反射的类型（Type）与种类（Kind）"></a>反射的类型（Type）与种类（Kind）</h5><p>Go语言程序中的类型（Type）指的是系统原生数据类型，如 int、string、bool、float32 等类型，以及使用 type 关键字定义的类型，这些类型的名称就是其类型本身的名称。例如使用 type A struct{} 定义结构体时，A 就是 struct{} 的类型。</p><p>种类（Kind）指的是对象归属的品种，在 reflect 包中定义的 Kind 类型如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Kind <span class="hljs-keyword">uint</span><br><span class="hljs-keyword">const</span> (<br>    Invalid Kind = <span class="hljs-literal">iota</span>  <span class="hljs-comment">// 非法类型</span><br>    Bool                 <span class="hljs-comment">// 布尔型</span><br>    Int                  <span class="hljs-comment">// 有符号整型</span><br>    Int8                 <span class="hljs-comment">// 有符号8位整型</span><br>    Int16                <span class="hljs-comment">// 有符号16位整型</span><br>    Int32                <span class="hljs-comment">// 有符号32位整型</span><br>    Int64                <span class="hljs-comment">// 有符号64位整型</span><br>    Uint                 <span class="hljs-comment">// 无符号整型</span><br>    Uint8                <span class="hljs-comment">// 无符号8位整型</span><br>    Uint16               <span class="hljs-comment">// 无符号16位整型</span><br>    Uint32               <span class="hljs-comment">// 无符号32位整型</span><br>    Uint64               <span class="hljs-comment">// 无符号64位整型</span><br>    Uintptr              <span class="hljs-comment">// 指针</span><br>    Float32              <span class="hljs-comment">// 单精度浮点数</span><br>    Float64              <span class="hljs-comment">// 双精度浮点数</span><br>    Complex64            <span class="hljs-comment">// 64位复数类型</span><br>    Complex128           <span class="hljs-comment">// 128位复数类型</span><br>    Array                <span class="hljs-comment">// 数组</span><br>    Chan                 <span class="hljs-comment">// 通道</span><br>    Func                 <span class="hljs-comment">// 函数</span><br>    Interface            <span class="hljs-comment">// 接口</span><br>    Map                  <span class="hljs-comment">// 映射</span><br>    Ptr                  <span class="hljs-comment">// 指针</span><br>    Slice                <span class="hljs-comment">// 切片</span><br>    String               <span class="hljs-comment">// 字符串</span><br>    Struct               <span class="hljs-comment">// 结构体</span><br>    UnsafePointer        <span class="hljs-comment">// 底层指针</span><br>)<br></code></pre></td></tr></table></figure><h5 id="从类型对象中获取类型名称和种类"><a href="#从类型对象中获取类型名称和种类" class="headerlink" title="从类型对象中获取类型名称和种类"></a>从类型对象中获取类型名称和种类</h5><p>Go语言中的类型名称对应的反射获取方法是 reflect.Type 中的 Name() 方法，返回表示类型名称的字符串；类型归属的种类（Kind）使用的是 reflect.Type 中的 Kind() 方法，返回 reflect.Kind 类型的常量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> myInt <span class="hljs-keyword">int64</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectType</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>t := reflect.TypeOf(x)<br>fmt.Printf(<span class="hljs-string">&quot;type:%v   kind:%v\n&quot;</span>, t.Name(), t.Kind())<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a *<span class="hljs-keyword">float32</span> <span class="hljs-comment">// 指针</span><br><span class="hljs-keyword">var</span> b myInt    <span class="hljs-comment">// 自定义类型</span><br><span class="hljs-keyword">var</span> c <span class="hljs-keyword">rune</span>     <span class="hljs-comment">// 类型别名</span><br>reflectType(a) <span class="hljs-comment">// type:   kind:ptr</span><br>reflectType(b) <span class="hljs-comment">// type:myInt   kind:int64</span><br>reflectType(c) <span class="hljs-comment">// type:int32   kind:int32</span><br><br><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br><br>&#125;<br><span class="hljs-keyword">var</span> d = person&#123;<br>name: <span class="hljs-string">&quot;张三&quot;</span>,<br>&#125;<br>reflectType(d) <span class="hljs-comment">// type:person kind:struct</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Go 语言的反射中像数组、切片、Map、指针等类型的变量，它们的 Name() 都是返回空。</p><h4 id="1-2-reflect-Value"><a href="#1-2-reflect-Value" class="headerlink" title="1.2 reflect.Value"></a>1.2 reflect.Value</h4><p>reflect.ValueOf()返回的是reflect.Value类型，其中包含了原始值的值信息。reflect.Value与原始值之间可以互相转换。</p><p>reflect.Value类型提供的获取原始值的方法如下：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220111203052.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">reflectValue</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>v := reflect.ValueOf(x)<br>k := v.Kind()<br><span class="hljs-keyword">switch</span> k &#123;<br><span class="hljs-keyword">case</span> reflect.Int64:<br>fmt.Println(<span class="hljs-keyword">int64</span>(v.Int()))<br><span class="hljs-keyword">case</span> reflect.Float32:<br>fmt.Println(<span class="hljs-keyword">float32</span>(v.Float()))<br><span class="hljs-keyword">case</span> reflect.Float64:<br>fmt.Println(v.Float())<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">float32</span> = <span class="hljs-number">3.14</span><br><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int64</span> = <span class="hljs-number">100</span><br>reflectValue(a) <span class="hljs-comment">// 3.14</span><br>reflectValue(b) <span class="hljs-comment">// 100</span><br><span class="hljs-comment">// 将int类型的原始值转换为reflect.Value类型</span><br>c := reflect.ValueOf(<span class="hljs-number">10</span>)<br>fmt.Printf(<span class="hljs-string">&quot;type c :%T\n&quot;</span>, c) <span class="hljs-comment">// type c :reflect.Value</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-指针与指针指向的元素"><a href="#1-3-指针与指针指向的元素" class="headerlink" title="1.3 指针与指针指向的元素"></a>1.3 指针与指针指向的元素</h4><p>Go语言程序中对指针获取反射对象时，可以通过 reflect.Elem() 方法获取这个指针指向的元素类型，这个获取过程被称为取元素，等效于对指针类型变量做了一个 * 操作</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">type</span> cat <span class="hljs-keyword">struct</span> &#123;<br>&#125;<br><span class="hljs-comment">// 创建cat的实例</span><br>ins := &amp;cat&#123;&#125;<br><span class="hljs-comment">// 获取结构体实例的反射类型对象</span><br>typeOfCat := reflect.TypeOf(ins)<br><span class="hljs-comment">// 显示反射类型对象的名称和种类</span><br>fmt.Printf(<span class="hljs-string">&quot;name:&#x27;%v&#x27; kind:&#x27;%v&#x27;\n&quot;</span>, typeOfCat.Name(), typeOfCat.Kind())<span class="hljs-comment">// name:&#x27;&#x27; kind:&#x27;ptr&#x27;</span><br><span class="hljs-comment">// 取类型的元素</span><br>typeOfCat = typeOfCat.Elem()<br><span class="hljs-comment">// 显示反射类型对象的名称和种类</span><br>fmt.Printf(<span class="hljs-string">&quot;element name: &#x27;%v&#x27;, element kind: &#x27;%v&#x27;\n&quot;</span>, typeOfCat.Name(), typeOfCat.Kind())<br><span class="hljs-comment">// element name: &#x27;cat&#x27;, element kind: &#x27;struct&#x27;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-IsNil-和-IsValid"><a href="#2-IsNil-和-IsValid" class="headerlink" title="2. IsNil() 和 IsValid()"></a>2. IsNil() 和 IsValid()</h3><p>IsNil() bool：返回值是否为 nil。如果值类型不是通道（channel）、函数、接口、map、指针或 切片时发生 panic，类似于语言层的v== nil操作<br>IsValid() bool：判断值是否有效。 当值本身非法时，返回 false，例如 reflect Value不包含任何值，值为 nil 等，此时除了 IsValid、String、Kind 之外的方法都会导致 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// *int类型空指针</span><br><span class="hljs-keyword">var</span> a *<span class="hljs-keyword">int</span><br>fmt.Println(<span class="hljs-string">&quot;var a *int IsNil:&quot;</span>, reflect.ValueOf(a).IsNil()) <span class="hljs-comment">// true</span><br><span class="hljs-comment">// nil值</span><br>fmt.Println(<span class="hljs-string">&quot;nil IsValid:&quot;</span>, reflect.ValueOf(<span class="hljs-literal">nil</span>).IsValid()) <span class="hljs-comment">// false</span><br><span class="hljs-comment">// 实例化一个匿名结构体</span><br>b := <span class="hljs-keyword">struct</span>&#123;&#125;&#123;&#125;<br><span class="hljs-comment">// 尝试从结构体中查找&quot;abc&quot;字段</span><br>fmt.Println(<span class="hljs-string">&quot;不存在的结构体成员:&quot;</span>, reflect.ValueOf(b).FieldByName(<span class="hljs-string">&quot;abc&quot;</span>).IsValid()) <span class="hljs-comment">// false</span><br><span class="hljs-comment">// 尝试从结构体中查找&quot;abc&quot;方法</span><br>fmt.Println(<span class="hljs-string">&quot;不存在的结构体方法:&quot;</span>, reflect.ValueOf(b).MethodByName(<span class="hljs-string">&quot;abc&quot;</span>).IsValid()) <span class="hljs-comment">// false</span><br><span class="hljs-comment">// map</span><br>c := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>&#123;&#125;<br><span class="hljs-comment">// 尝试从map中查找一个不存在的键</span><br>fmt.Println(<span class="hljs-string">&quot;map中不存在的键：&quot;</span>, reflect.ValueOf(c).MapIndex(reflect.ValueOf(<span class="hljs-string">&quot;娜扎&quot;</span>)).IsValid()) <span class="hljs-comment">// false</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-通过反射修改变量的值"><a href="#3-通过反射修改变量的值" class="headerlink" title="3. 通过反射修改变量的值"></a>3. 通过反射修改变量的值</h3><p> 有一些 reflect.Values 是可取地址的；其它一些则不可以。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"> x := <span class="hljs-number">2</span> <span class="hljs-comment">// value type variable?</span><br>a := reflect.ValueOf(<span class="hljs-number">2</span>) <span class="hljs-comment">// 2 int no</span><br>b := reflect.ValueOf(x) <span class="hljs-comment">// 2 int no</span><br>c := reflect.ValueOf(&amp;x)<span class="hljs-comment">// &amp;x *int no</span><br>d := c.Elem() <span class="hljs-comment">// 2 int yes (x)</span><br></code></pre></td></tr></table></figure><p>其中 a 对应的变量则不可取地址。因为 a 中的值仅仅是整数 2 的拷贝副本。b 中的值也同样不可取地址。c 中的值还是不可取地址，它只是一个指针 &amp;x 的拷贝。实际上，所有通过 reflect.ValueOf(x) 返回的 reflect.Value 都是不可取地址的。但是对于 d，它是 c 的解引用方式生成的，指向另一个变量，因此是可取地址的。我们可以通过调用 reflect.ValueOf(&amp;x).Elem()，来获取任意变量x对应的可取地址的 Value。</p><p> 判定及获取元素的相关方法：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220112102159.png"></p><p>值修改相关方法：</p><p> <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220112103035.png"></p><h4 id="值可修改条件之一：可被寻址"><a href="#值可修改条件之一：可被寻址" class="headerlink" title="值可修改条件之一：可被寻址"></a>值可修改条件之一：可被寻址</h4> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 声明整型变量a并赋初值</span><br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">1024</span><br><span class="hljs-comment">// 获取变量a的反射值对象</span><br>valueOfA := reflect.ValueOf(a)<br><span class="hljs-comment">// 尝试将a修改为1(此处会发生崩溃)</span><br>valueOfA.SetInt(<span class="hljs-number">1</span>) <span class="hljs-comment">// panic: reflect: reflect.Value.SetInt using unaddressable value</span><br>&#125;<br></code></pre></td></tr></table></figure><p> 从 reflect.ValueOf 传入的是 a 的值，而不是 a 的地址，这个 reflect.Value 当然是不能被寻址的。<br> <figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs stylus"> func <span class="hljs-selector-tag">main</span>() &#123;<br><span class="hljs-selector-tag">var</span> <span class="hljs-selector-tag">a</span> int = <span class="hljs-number">1024</span><br><span class="hljs-comment">// 获取变量a的反射值对象(a的地址)</span><br>valueOfA := reflect<span class="hljs-selector-class">.ValueOf</span>(&amp;a)<br><span class="hljs-comment">// 取出a地址的元素(a的值)</span><br>valueOfA = valueOfA<span class="hljs-selector-class">.Elem</span>()<br><span class="hljs-comment">// 修改a的值为1</span><br>valueOfA<span class="hljs-selector-class">.SetInt</span>(<span class="hljs-number">1</span>)<br>fmt<span class="hljs-selector-class">.Println</span>(valueOfA<span class="hljs-selector-class">.Int</span>()) <span class="hljs-comment">// 1</span><br>&#125;<br></code></pre></td></tr></table></figure><br>当 reflect.Value 不可寻址时，使用 Addr() 方法也是无法取到值的地址的，同时会发生宕机。虽然说 reflect.Value 的 Addr() 方法类似于语言层的&amp;操作；Elem() 方法类似于语言层的*操作，但并不代表这些方法与语言层操作等效。</p><h4 id="值可修改条件之一：被导出"><a href="#值可修改条件之一：被导出" class="headerlink" title="值可修改条件之一：被导出"></a>值可修改条件之一：被导出</h4><p> 结构体成员中，如果字段没有被导出，即便不使用反射也可以被访问，但不能通过反射修改。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs GO"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">type</span> dog <span class="hljs-keyword">struct</span> &#123;<br>legCount <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-comment">// 获取 dog 实例地址的反射值对象</span><br>valueOfDog := reflect.ValueOf(&amp;dog&#123;&#125;)<br><span class="hljs-comment">// 取出 dog 实例地址的元素</span><br>valueOfDog = valueOfDog.Elem()<br><span class="hljs-comment">// 获取 legCount 字段的值</span><br>vLegCount := valueOfDog.FieldByName(<span class="hljs-string">&quot;legCount&quot;</span>)<br><br>vLegCount.SetInt(<span class="hljs-number">4</span>)<span class="hljs-comment">// panic: reflect: reflect.Value.SetInt using value obtained using unexported field</span><br><br>fmt.Println(vLegCount.Int())<br>&#125;<br></code></pre></td></tr></table></figure><p>SetInt() 使用的值来自于一个未导出的字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">type</span> dog <span class="hljs-keyword">struct</span> &#123;<br>LegCount <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-comment">// 获取 dog 实例地址的反射值对象</span><br>valueOfDog := reflect.ValueOf(&amp;dog&#123;&#125;)<br><span class="hljs-comment">// 取出 dog 实例地址的元素</span><br>valueOfDog = valueOfDog.Elem()<br><span class="hljs-comment">// 获取 legCount 字段的值</span><br>vLegCount := valueOfDog.FieldByName(<span class="hljs-string">&quot;LegCount&quot;</span>)<br><br>vLegCount.SetInt(<span class="hljs-number">4</span>)<br><br>fmt.Println(vLegCount.Int())<span class="hljs-comment">// 4</span><br>&#125;<br></code></pre></td></tr></table></figure><p>导出后可正确设置。</p><h3 id="4-结构体反射"><a href="#4-结构体反射" class="headerlink" title="4. 结构体反射"></a>4. 结构体反射</h3><p> 结构体相关的方法：</p><p> <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220112105630.png"></p><p> StructField 类型用来描述结构体中的一个字段的信息。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-keyword">type</span> StructField <span class="hljs-keyword">struct</span> &#123;<br>    <span class="hljs-comment">// Name是字段的名字。PkgPath是非导出字段的包路径，对导出字段该字段为&quot;&quot;。</span><br>    <span class="hljs-comment">// 参见http://golang.org/ref/spec#Uniqueness_of_identifiers</span><br>    Name    <span class="hljs-keyword">string</span><br>    PkgPath <span class="hljs-keyword">string</span><br>    Type      Type      <span class="hljs-comment">// 字段的类型</span><br>    Tag       StructTag <span class="hljs-comment">// 字段的标签</span><br>    Offset    <span class="hljs-keyword">uintptr</span>   <span class="hljs-comment">// 字段在结构体中的字节偏移量</span><br>    Index     []<span class="hljs-keyword">int</span>     <span class="hljs-comment">// 用于Type.FieldByIndex时的索引切片</span><br>    Anonymous <span class="hljs-keyword">bool</span>      <span class="hljs-comment">// 是否匿名字段</span><br>&#125;<br></code></pre></td></tr></table></figure><p>StructTag 拥有一些方法，可以进行 Tag 信息的解析和提取，如下所示：</p><ul><li>func (tag StructTag) Get(key string) string<br>根据 Tag 中的键获取对应的值，例如 <code>key1:&quot;value1&quot;key2:&quot;value2&quot;</code> 的 Tag 中，可以传入“key1”获得“value1”。</li><li>func(tag StructTag) Lookup(key string)(value string,ok bool)<br>根据 Tag 中的键，查询值是否存在。</li></ul><h4 id="反射操作结构体字段"><a href="#反射操作结构体字段" class="headerlink" title="反射操作结构体字段"></a>反射操作结构体字段</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>stu1 := student&#123;<br>Name:  <span class="hljs-string">&quot;张三&quot;</span>,<br>Score: <span class="hljs-number">18</span>,<br>&#125;<br><br>t := reflect.TypeOf(stu1)<br>fmt.Println(t.Name(), t.Kind()) <span class="hljs-comment">// student struct</span><br><br><span class="hljs-comment">// 通过for循环遍历结构体的所有字段信息</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; t.NumField(); i++ &#123;<br>field := t.Field(i)<br>fmt.Printf(<span class="hljs-string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, field.Name, field.Index, field.Type, field.Tag.Get(<span class="hljs-string">&quot;json&quot;</span>))<br>&#125;<br><span class="hljs-comment">// name:Name index:[0] type:string json tag:name</span><br><span class="hljs-comment">// name:Score index:[1] type:int json tag:score</span><br><br><span class="hljs-comment">// 通过字段名获取指定结构体字段信息</span><br><span class="hljs-keyword">if</span> scoreField, ok := t.FieldByName(<span class="hljs-string">&quot;Score&quot;</span>); ok &#123;<br>fmt.Printf(<span class="hljs-string">&quot;name:%s index:%d type:%v json tag:%v\n&quot;</span>, scoreField.Name, scoreField.Index, scoreField.Type, scoreField.Tag.Get(<span class="hljs-string">&quot;json&quot;</span>))<br>&#125;<br><span class="hljs-comment">// name:Score index:[1] type:int json tag:score</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="反射操作结构体方法"><a href="#反射操作结构体方法" class="headerlink" title="反射操作结构体方法"></a>反射操作结构体方法</h4> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-keyword">type</span> student <span class="hljs-keyword">struct</span> &#123;<br>Name  <span class="hljs-keyword">string</span> <span class="hljs-string">`json:&quot;name&quot;`</span><br>Score <span class="hljs-keyword">int</span>    <span class="hljs-string">`json:&quot;score&quot;`</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s student)</span> <span class="hljs-title">Study</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br>msg := <span class="hljs-string">&quot;好好学习，天天向上。&quot;</span><br>fmt.Println(msg)<br><span class="hljs-keyword">return</span> msg<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s student)</span> <span class="hljs-title">Sleep</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br>msg := <span class="hljs-string">&quot;zzzzzz&quot;</span><br>fmt.Println(msg)<br><span class="hljs-keyword">return</span> msg<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">printMethod</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>t := reflect.TypeOf(x)<br>v := reflect.ValueOf(x)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; v.NumMethod(); i++ &#123;<br>methodType := v.Method(i).Type()<br>fmt.Printf(<span class="hljs-string">&quot;method name:%s\n&quot;</span>, t.Method(i).Name)<br>fmt.Printf(<span class="hljs-string">&quot;method type:%s\n&quot;</span>, methodType)<br><span class="hljs-comment">// 通过反射调用方法传递的参数必须是 []reflect.Value 类型</span><br><span class="hljs-keyword">var</span> args []reflect.Value<br>v.Method(i).Call(args)<br>&#125;<br><span class="hljs-comment">// 执行结果：</span><br><span class="hljs-comment">// method name:Sleep</span><br><span class="hljs-comment">// method type:func() string</span><br><span class="hljs-comment">// zzzzzz</span><br><span class="hljs-comment">// method name:Study</span><br><span class="hljs-comment">// method type:func() string</span><br><span class="hljs-comment">// 好好学习，天天向上。</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>printMethod(student&#123;&#125;)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-反射调用方法"><a href="#5-反射调用方法" class="headerlink" title="5. 反射调用方法"></a>5. 反射调用方法</h3><p>将函数保存到反射值对象（reflect.Value）中，然后将两个整型值构造为反射值对象的切片（[]reflect.Value），使用 Call() 方法进行调用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 普通函数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(a, b <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> a + b<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 将函数包装为反射值对象</span><br>funcValue := reflect.ValueOf(add)<br><br>fmt.Println(funcValue.Type().Kind(),<span class="hljs-string">&quot;---&quot;</span>,funcValue.Type().Name())<br><span class="hljs-comment">// func ---</span><br><span class="hljs-comment">// 构造函数参数, 传入两个整型值</span><br>paramList := []reflect.Value&#123;reflect.ValueOf(<span class="hljs-number">10</span>), reflect.ValueOf(<span class="hljs-number">20</span>)&#125;<br><span class="hljs-comment">// 反射调用函数</span><br>retList := funcValue.Call(paramList)<br><span class="hljs-comment">// 获取第一个返回值, 取整数值</span><br>fmt.Println(retList[<span class="hljs-number">0</span>].Int())<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——排序</title>
    <link href="/2022/01/09/Go%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/"/>
    <url>/2022/01/09/Go%E2%80%94%E2%80%94%E6%8E%92%E5%BA%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-使用-sort-Interface-接口进行排序"><a href="#1-使用-sort-Interface-接口进行排序" class="headerlink" title="1. 使用 sort.Interface 接口进行排序"></a>1. 使用 sort.Interface 接口进行排序</h3><p>sort.Interface 接口的定义：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Interface <span class="hljs-keyword">interface</span> &#123;<br><span class="hljs-comment">// Len 集合中元素的数量</span><br>Len() <span class="hljs-keyword">int</span><br><br><span class="hljs-comment">// Less 索引为 i 的元素是否必须排在索引为 j 的元素之前</span><br>Less(i, j <span class="hljs-keyword">int</span>) <span class="hljs-keyword">bool</span><br><br><span class="hljs-comment">// Swap 交换索引为 i 和 j 的元素</span><br>Swap(i, j <span class="hljs-keyword">int</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyStringList []<span class="hljs-keyword">string</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MyStringList)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(m)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MyStringList)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">return</span> m[i] &lt; m[j]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m MyStringList)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span> &#123;<br>m[i], m[j] = m[j], m[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// 准备一个内容被打乱顺序的字符串切片</span><br>names := MyStringList&#123;<br><span class="hljs-string">&quot;zhangsan&quot;</span>,<br><span class="hljs-string">&quot;lisi&quot;</span>,<br><span class="hljs-string">&quot;wamgwu&quot;</span>,<br><span class="hljs-string">&quot;zhaoliu&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">// 使用sort包进行排序</span><br>sort.Sort(names)<br><br><span class="hljs-comment">// 遍历打印结果</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> names &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, v)<br>&#125;<br><span class="hljs-comment">/* 执行结果：</span><br><span class="hljs-comment">lisi</span><br><span class="hljs-comment">wamgwu</span><br><span class="hljs-comment">zhangsan</span><br><span class="hljs-comment">zhaoliu</span><br><span class="hljs-comment">*/</span><br><br>sort.Sort(sort.Reverse(names))<br><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> names &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, v)<br>&#125;<br><span class="hljs-comment">/* 执行结果：</span><br><span class="hljs-comment">zhaoliu</span><br><span class="hljs-comment">zhangsan</span><br><span class="hljs-comment">wamgwu</span><br><span class="hljs-comment">lisi</span><br><span class="hljs-comment">*/</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-常见类型的便捷排序"><a href="#2-常见类型的便捷排序" class="headerlink" title="2. 常见类型的便捷排序"></a>2. 常见类型的便捷排序</h3><p> sort 包内建的类型排序接口一览：</p><p> <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220109172924.png"></p><p> int32、int64、float32、bool 类型并没有由 sort 包实现</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// 准备一个内容被打乱顺序的字符串切片</span><br>names := sort.StringSlice&#123;<br><span class="hljs-string">&quot;zhangsan&quot;</span>,<br><span class="hljs-string">&quot;lisi&quot;</span>,<br><span class="hljs-string">&quot;wamgwu&quot;</span>,<br><span class="hljs-string">&quot;zhaoliu&quot;</span>,<br>&#125;<br><br><span class="hljs-comment">// 使用sort包进行排序</span><br>sort.Sort(names)<br><br><br>names2 := []<span class="hljs-keyword">string</span>&#123;<br><span class="hljs-string">&quot;zhangsan&quot;</span>,<br><span class="hljs-string">&quot;lisi&quot;</span>,<br><span class="hljs-string">&quot;wamgwu&quot;</span>,<br><span class="hljs-string">&quot;zhaoliu&quot;</span>,<br>&#125;<br><br>sort.Strings(names2)<br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-对结构体数据进行排序"><a href="#3-对结构体数据进行排序" class="headerlink" title="3. 对结构体数据进行排序"></a>3. 对结构体数据进行排序</h3><h4 id="3-1-实现-sort-Interface-进行结构体排序"><a href="#3-1-实现-sort-Interface-进行结构体排序" class="headerlink" title="3.1 实现 sort.Interface 进行结构体排序"></a>3.1 实现 sort.Interface 进行结构体排序</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// HeroKind 声明英雄的分类</span><br><span class="hljs-keyword">type</span> HeroKind <span class="hljs-keyword">int</span><br><br><span class="hljs-comment">// 定义HeroKind常量, 类似于枚举</span><br><span class="hljs-keyword">const</span> (<br>None HeroKind = <span class="hljs-literal">iota</span><br>Tank<br>Assassin<br>Mage<br>)<br><br><span class="hljs-keyword">type</span> Hero <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-keyword">string</span>  <span class="hljs-comment">// 英雄的名字</span><br>Kind HeroKind  <span class="hljs-comment">// 英雄的种类</span><br>&#125;<br><br><br><span class="hljs-keyword">type</span> Heroes []*Hero<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Heroes)</span> <span class="hljs-title">Len</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-built_in">len</span>(s)<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Heroes)</span> <span class="hljs-title">Less</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><br><span class="hljs-comment">// 如果英雄的分类不一致时, 优先对分类进行排序</span><br><span class="hljs-keyword">if</span> s[i].Kind != s[j].Kind &#123;<br><span class="hljs-keyword">return</span> s[i].Kind &lt; s[j].Kind<br>&#125;<br><br><span class="hljs-comment">// 默认按英雄名字字符升序排列</span><br><span class="hljs-keyword">return</span> s[i].Name &lt; s[j].Name<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s Heroes)</span> <span class="hljs-title">Swap</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span></span> &#123;<br>s[i], s[j] = s[j], s[i]<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// 准备英雄列表</span><br>heroes := Heroes&#123;<br>&amp;Hero&#123;<span class="hljs-string">&quot;吕布&quot;</span>, Tank&#125;,<br>&amp;Hero&#123;<span class="hljs-string">&quot;李白&quot;</span>, Assassin&#125;,<br>&amp;Hero&#123;<span class="hljs-string">&quot;妲己&quot;</span>, Mage&#125;,<br>&amp;Hero&#123;<span class="hljs-string">&quot;貂蝉&quot;</span>, Assassin&#125;,<br>&amp;Hero&#123;<span class="hljs-string">&quot;关羽&quot;</span>, Tank&#125;,<br>&amp;Hero&#123;<span class="hljs-string">&quot;诸葛亮&quot;</span>, Mage&#125;,<br>&#125;<br><br><span class="hljs-comment">// 使用sort包进行排序</span><br>sort.Sort(heroes)<br><br><span class="hljs-comment">// 遍历英雄列表打印排序结果</span><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> heroes &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220109174536.png"></p><h4 id="3-2-使用-sort-Slice-进行切片元素排序"><a href="#3-2-使用-sort-Slice-进行切片元素排序" class="headerlink" title="3.2 使用 sort.Slice 进行切片元素排序"></a>3.2 使用 sort.Slice 进行切片元素排序</h4><p>从 Go 1.8 开始，Go语言在 sort 包中提供了 sort.Slice() 函数进行更为简便的排序方法。sort.Slice() 函数只要求传入需要排序的数据，以及一个排序时对元素的回调函数，类型为 func(i,j int)bool，sort.Slice() 函数的定义如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Slice</span><span class="hljs-params">(x <span class="hljs-keyword">interface</span>&#123;&#125;, less <span class="hljs-keyword">func</span>(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span>)</span> &#123;<br>rv := reflectValueOf(x)<br>swap := reflectSwapper(x)<br>length := rv.Len()<br>quickSort_func(lessSwap&#123;less, swap&#125;, <span class="hljs-number">0</span>, length, maxDepth(length))<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>使用示例：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> HeroKind <span class="hljs-keyword">int</span><br><br><span class="hljs-keyword">const</span> (<br>None = <span class="hljs-literal">iota</span><br>Tank<br>Assassin<br>Mage<br>)<br><br><span class="hljs-keyword">type</span> Hero <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-keyword">string</span><br>Kind HeroKind<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>heroes := []*Hero&#123;<br>&#123;<span class="hljs-string">&quot;吕布&quot;</span>, Tank&#125;,<br>&#123;<span class="hljs-string">&quot;李白&quot;</span>, Assassin&#125;,<br>&#123;<span class="hljs-string">&quot;妲己&quot;</span>, Mage&#125;,<br>&#123;<span class="hljs-string">&quot;貂蝉&quot;</span>, Assassin&#125;,<br>&#123;<span class="hljs-string">&quot;关羽&quot;</span>, Tank&#125;,<br>&#123;<span class="hljs-string">&quot;诸葛亮&quot;</span>, Mage&#125;,<br>&#125;<br><br>sort.Slice(heroes, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> heroes[i].Kind != heroes[j].Kind &#123;<br><span class="hljs-keyword">return</span> heroes[i].Kind &lt; heroes[j].Kind<br>&#125;<br><br><span class="hljs-keyword">return</span> heroes[i].Name &lt; heroes[j].Name<br>&#125;)<br><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> heroes &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——接口</title>
    <link href="/2022/01/06/Go%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3/"/>
    <url>/2022/01/06/Go%E2%80%94%E2%80%94%E6%8E%A5%E5%8F%A3/</url>
    
    <content type="html"><![CDATA[<p>接口（interface）定义了一个对象的行为规范，只定义规范不实现，由具体的对象来实现规范的细节。</p><p><font color="red"> <strong>接口（interface）是一种类型</strong></font></p><h3 id="1-接口定义"><a href="#1-接口定义" class="headerlink" title="1. 接口定义"></a>1. 接口定义</h3><p>Go 语言中每个接口由数个方法（零个或多个）组成，接口的定义格式如下：</p><blockquote><p>type　接口类型名　interface{<br>　方法名1( 参数列表1 )　返回值列表1<br>　方法名2( 参数列表2 )　返回值列表2<br>　 …<br>}</p></blockquote><p>其中：</p><ul><li>接口名：使用 type 将接口定义为自定义的类型名。Go 语言的接口在命名时，一般会在单词后面添加er，如有写操作的接口叫Writer。</li><li>方法名：当方法名首字母是大写且这个接口类型名首字母也是大写时，这个方法可以被接口所在的包（package）之外的代码访问。</li><li>参数列表、返回值列表：参数列表和返回值列表中的参数变量名可以省略。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Stringer <span class="hljs-keyword">interface</span> &#123;<br>    String() <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>实现该接，调用 String() 方法时可以获得对象对应的字符串，功能类似于 Java 语言里的 toString 的操作。</p><h3 id="2-接口实现"><a href="#2-接口实现" class="headerlink" title="2. 接口实现"></a>2. 接口实现</h3><p>如果一个任意类型 T 的方法集为一个接口类型的方法集的超集，则我们说类型 T 实现了此接口类型。T 可以是一个非接口类型，也可以是一个接口类型。</p><p>实现关系在Go语言中是隐式的。两个类型之间的实现关系不需要在代码中显式地表示出来。Go语言中没有类似于 implements 的关键字。 Go编译器将自动在需要的时候检查两个类型之间的实现关系。</p><p>接口定义后，需要实现接口，调用方才能正确编译通过并使用接口。接口的实现需要遵循两条规则才能让接口可用。</p><p>一个对象只要全部实现了接口中的方法，那么就实现了这个接口。</p><ol><li>接口的方法与实现接口的类型方法格式一致</li></ol><p>在类型中添加与接口签名一致的方法就可以实现该方法。签名包括方法中的名称、参数列表、返回参数列表。也就是说，只要实现接口类型中的方法的名称、参数列表、返回参数列表中的任意一项与接口要实现的方法不一致，那么接口的这个方法就不会被实现。</p><ol start="2"><li>接口中所有方法均被实现</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Eater 定义接口</span><br><span class="hljs-keyword">type</span> Eater <span class="hljs-keyword">interface</span> &#123;<br>eat()<br>&#125;<br><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-keyword">type</span> Cat <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// 实现接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;骨头&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> eater Eater = <span class="hljs-built_in">new</span>(Dog)<br>eater.eat()<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-1-值接收者实现接口"><a href="#2-1-值接收者实现接口" class="headerlink" title="2.1 值接收者实现接口"></a>2.1 值接收者实现接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 实现接口</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;骨头&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> eater Eater<br>eater = Dog&#123;&#125;<span class="hljs-comment">// Dog 类型</span><br>eater = <span class="hljs-built_in">new</span>(Dog)<span class="hljs-comment">// 指针类型</span><br>eater.eat()<br>&#125;<br></code></pre></td></tr></table></figure><p>使用值接收者实现接口，不管是 dog 结构体还是结构体指针 *dog 类型的变量都可以赋值给该接口变量。因为 Go 语言中有对指针类型变量求值的语法糖，dog 指针内部会自动求值。</p><h4 id="2-2-指针接收者实现接口"><a href="#2-2-指针接收者实现接口" class="headerlink" title="2.2 指针接收者实现接口"></a>2.2 指针接收者实现接口</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *Cat)</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;小黄鱼&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> eater Eater<br>eater = <span class="hljs-built_in">new</span>(Cat) <span class="hljs-comment">// 指针类型</span><br><span class="hljs-comment">// eater = Cat&#123;&#125;// Cat 类型，编译错误</span><br>eater.eat()<br>&#125;<br></code></pre></td></tr></table></figure><p>时实现接口的是 *Cat 类型，所以不把 Cat 类型传给接口类型变量。</p><h3 id="3-接口变量"><a href="#3-接口变量" class="headerlink" title="3. 接口变量"></a>3. 接口变量</h3><p>接口类型变量可以存储所有实现了该接口的实例</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> w io.Writer<br>fmt.Printf(<span class="hljs-string">&quot;%T \n&quot;</span>,w)<span class="hljs-comment">// &lt;nil&gt;</span><br>w = os.Stdout<br>fmt.Printf(<span class="hljs-string">&quot;%T \n&quot;</span>,w)<span class="hljs-comment">// *os.File</span><br>w = <span class="hljs-built_in">new</span>(bytes.Buffer)<br>fmt.Printf(<span class="hljs-string">&quot;%T \n&quot;</span>,w)<span class="hljs-comment">// *bytes.Buffer</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>一个接口的值（简称接口值）是由一个具体类型和具体类型的值两部分组成的。这两部分分别称为接口的动态类型和动态值。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220108225046.png"></p><h3 id="4-类型与接口的关系"><a href="#4-类型与接口的关系" class="headerlink" title="4. 类型与接口的关系"></a>4. 类型与接口的关系</h3><ol><li>一个类型实现多个接口</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Sayer <span class="hljs-keyword">interface</span> &#123;<br>say()<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;汪汪汪~~~&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>dog := Dog&#123;&#125;<br>dog.say()<br>dog.eat()<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>多个类型实现同一接口</li></ol><p>并且一个接口的方法，不一定需要由一个类型完全实现，接口的方法可以通过在类型中嵌入其他类型或者结构体来实现。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// Washer 洗衣</span><br><span class="hljs-keyword">type</span> Washer <span class="hljs-keyword">interface</span> &#123;<br>wash()<br>dry()<br>&#125;<br><br><span class="hljs-comment">// 甩干器</span><br><span class="hljs-keyword">type</span> dryer <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-comment">// 实现 Washer 接口的 dry() 方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d dryer)</span> <span class="hljs-title">dry</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;甩一甩&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 海尔洗衣机</span><br><span class="hljs-keyword">type</span> haier <span class="hljs-keyword">struct</span> &#123;<br>dryer <span class="hljs-comment">//嵌入甩干器</span><br>&#125;<br><br><span class="hljs-comment">// 实现 WashingMachine 接口的 wash() 方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(h haier)</span> <span class="hljs-title">wash</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;洗刷刷&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-接口嵌套"><a href="#5-接口嵌套" class="headerlink" title="5. 接口嵌套"></a>5. 接口嵌套</h3><p>接口与接口间可以通过嵌套创造出新的接口。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">/ 接口嵌套<br><span class="hljs-keyword">type</span> animal <span class="hljs-keyword">interface</span> &#123;<br>Sayer<br>Eater<br>&#125;<br><br><span class="hljs-comment">// Eater 定义接口</span><br><span class="hljs-keyword">type</span> Eater <span class="hljs-keyword">interface</span> &#123;<br>eat()<br>&#125;<br><br><span class="hljs-keyword">type</span> Sayer <span class="hljs-keyword">interface</span> &#123;<br>say()<br>&#125;<br></code></pre></td></tr></table></figure><p>实现嵌套接口：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span>&#123;&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;骨头&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;汪汪汪~~~&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a animal =  Dog&#123;&#125;<br>a.say()<br>a.eat()<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-空接口"><a href="#6-空接口" class="headerlink" title="6. 空接口"></a>6. 空接口</h3><p>空接口是指没有定义任何方法的接口。因此任何类型都实现了空接口。</p><p>空接口类型的变量可以存储任意类型的变量。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 定义一个空接口</span><br><span class="hljs-keyword">var</span> object <span class="hljs-keyword">interface</span>&#123;&#125;<br><br>object = <span class="hljs-string">&quot;Hello world&quot;</span><br>fmt.Printf(<span class="hljs-string">&quot;type:%T   value:%v\n&quot;</span>, object, object)<br><span class="hljs-comment">//type:string   value:Hello world</span><br><br>object = <span class="hljs-number">100</span><br>fmt.Printf(<span class="hljs-string">&quot;type:%T   value:%v\n&quot;</span>, object, object)<br><span class="hljs-comment">// type:int   value:100</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>空接口的应用</strong></p><ol><li>空接口作为函数的参数</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 空接口作为函数参数</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sout</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;type:%T value:%v\n&quot;</span>, a, a)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>空接口作为map的值</li></ol><p>使用空接口实现可以保存任意值的字典。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> studentInfo = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">interface</span>&#123;&#125;)<br>studentInfo[<span class="hljs-string">&quot;name&quot;</span>] = <span class="hljs-string">&quot;张三&quot;</span><br>studentInfo[<span class="hljs-string">&quot;age&quot;</span>] = <span class="hljs-number">18</span><br>studentInfo[<span class="hljs-string">&quot;married&quot;</span>] = <span class="hljs-literal">false</span><br>fmt.Println(studentInfo)<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-1-从空接口获取值"><a href="#6-1-从空接口获取值" class="headerlink" title="6.1 从空接口获取值"></a>6.1 从空接口获取值</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// 声明a变量, 类型int, 初始值为1</span><br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span><br><span class="hljs-comment">// 声明i变量, 类型为interface&#123;&#125;, 初始值为a, 此时i的值变为1</span><br><span class="hljs-keyword">var</span> i <span class="hljs-keyword">interface</span>&#123;&#125; = a<br><span class="hljs-comment">// 声明b变量, 尝试赋值i</span><br><span class="hljs-comment">// var b int = i// cannot use i (type interface &#123;&#125;) as type int in assignment: need type assertion</span><br><br><span class="hljs-keyword">var</span> b <span class="hljs-keyword">int</span> = i.(<span class="hljs-keyword">int</span>)<br>fmt.Println(b)<span class="hljs-comment">// 1</span><br>&#125;<br></code></pre></td></tr></table></figure><p>保存到空接口的值，如果直接取出指定类型的值时，会发生编译错误。</p><h4 id="6-2-空接口的值比较"><a href="#6-2-空接口的值比较" class="headerlink" title="6.2 空接口的值比较"></a>6.2 空接口的值比较</h4><p>空接口在保存不同的值后，可以和其他变量值一样使用==进行比较操作。空接口的比较有以下几种特性。</p><ol><li>类型不同的空接口间的比较结果不相同<br>保存有类型不同的值的空接口进行比较时，Go 语言会优先比较值的类型。因此类型不同，比较结果也是不相同的。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// a保存整型</span><br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-number">100</span><br><span class="hljs-comment">// b保存字符串</span><br><span class="hljs-keyword">var</span> b <span class="hljs-keyword">interface</span>&#123;&#125; = <span class="hljs-string">&quot;hi&quot;</span><br><span class="hljs-comment">// 两个空接口不相等</span><br>fmt.Println(a == b) <span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>不能比较空接口中的动态值<br>当接口中保存有动态类型的值时，运行时将触发错误。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// c保存包含10的整型切片</span><br><span class="hljs-keyword">var</span> c <span class="hljs-keyword">interface</span>&#123;&#125; = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">10</span>&#125;<br><span class="hljs-comment">// d保存包含20的整型切片</span><br><span class="hljs-keyword">var</span> d <span class="hljs-keyword">interface</span>&#123;&#125; = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">20</span>&#125;<br><span class="hljs-comment">// 这里会发生崩溃</span><br>fmt.Println(c == d)<span class="hljs-comment">// panic: runtime error: comparing uncomparable type []int</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20220109122840.png"></p><h3 id="7-类型断言"><a href="#7-类型断言" class="headerlink" title="7. 类型断言"></a>7. 类型断言</h3><p>类型断言（Type Assertion）是一个使用在接口值上的操作，用于检查接口类型变量所持有的值是否实现了期望的接口或者具体的类型。</p><p>类型断言的语法格式如下：</p><blockquote><p>value, ok := x.(T)</p></blockquote><p>其中，x 表示一个接口类型的变量，T 表示一个具体的类型（也可为接口类型）。</p><p>该断言表达式会返回 x 的值（也就是 value）和一个布尔值（也就是 ok），可根据该布尔值判断 x 是否为 T 类型：</p><ul><li>如果 T 是具体某个类型，类型断言会检查 x 的动态类型是否等于具体类型 T。如果检查成功，类型断言返回的结果是 x 的动态值，其类型是 T。</li><li>如果 T 是接口类型，类型断言会检查 x 的动态类型是否满足 T。如果检查成功，x 的动态值不会被提取，返回值是一个类型为 T 的接口值。</li><li>无论 T 是什么类型，如果 x 是 nil 接口值，类型断言都会失败。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span>&#123;<br>name <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span>&#123;&#125;<br><br>x = <span class="hljs-number">10</span><br>value, ok := x.(<span class="hljs-keyword">int</span>)<br>fmt.Print(value, <span class="hljs-string">&quot;,&quot;</span>, ok,<span class="hljs-string">&quot;\n&quot;</span>)<br><span class="hljs-comment">// 10,true</span><br><br>x = Dog&#123;<span class="hljs-string">&quot;旺财&quot;</span>&#125;<br>v, b := x.(animal)<br>fmt.Print(v, <span class="hljs-string">&quot;,&quot;</span>, b)<br><span class="hljs-comment">// &#123;花花&#125;,true</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>如果不接收第二个参数，断言失败时会直接造成一个 panic。如果 x 为 nil 同样也会 panic。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> x <span class="hljs-keyword">interface</span>&#123;&#125;<br><br>x = <span class="hljs-number">10</span><br>value := x.(<span class="hljs-keyword">int</span>)<br>fmt.Print(value, <span class="hljs-string">&quot;\n&quot;</span>) <span class="hljs-comment">// 10</span><br><br>x = <span class="hljs-number">10</span><br>v := x.(<span class="hljs-keyword">string</span>) <span class="hljs-comment">// panic: interface conversion: interface &#123;&#125; is int, not string</span><br>fmt.Print(v, <span class="hljs-string">&quot;\n&quot;</span>)<br><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>类型断言还可以配合 switch 使用：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span><br>a = <span class="hljs-number">10</span><br>getType(a)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getType</span><span class="hljs-params">(a <span class="hljs-keyword">interface</span>&#123;&#125;)</span></span> &#123;<br><span class="hljs-keyword">switch</span> a.(<span class="hljs-keyword">type</span>) &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">int</span>:<br>fmt.Println(<span class="hljs-string">&quot;the type of a is int&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">string</span>:<br>fmt.Println(<span class="hljs-string">&quot;the type of a is string&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-keyword">float64</span>:<br>fmt.Println(<span class="hljs-string">&quot;the type of a is float&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;unknown type&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="8-接口和类型之间的转换"><a href="#8-接口和类型之间的转换" class="headerlink" title="8. 接口和类型之间的转换"></a>8. 接口和类型之间的转换</h3><h4 id="8-1-将接口转换为其他接口"><a href="#8-1-将接口转换为其他接口" class="headerlink" title="8.1 将接口转换为其他接口"></a>8.1 将接口转换为其他接口</h4><p>实现某个接口的类型同时实现了另外一个接口，此时可以在两个接口间转换。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Sayer <span class="hljs-keyword">interface</span> &#123;<br>say()<br>&#125;<br><br><span class="hljs-keyword">type</span> Eater <span class="hljs-keyword">interface</span> &#123;<br>eat()<br>&#125;<br><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">eat</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;骨头&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d Dog)</span> <span class="hljs-title">say</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;汪汪汪~~~&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> eat Eater = Dog&#123;<span class="hljs-string">&quot;小黄&quot;</span>&#125;<br>say := eat.(Sayer)<br><br>fmt.Println(say)<br><span class="hljs-comment">// &#123;小黄&#125;</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="8-2-将接口转换为其他类型"><a href="#8-2-将接口转换为其他类型" class="headerlink" title="8.2 将接口转换为其他类型"></a>8.2 将接口转换为其他类型</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> dog *Dog = <span class="hljs-built_in">new</span>(Dog)<br><span class="hljs-keyword">var</span> eat Eater = dog<br><br><span class="hljs-comment">// d := eat.(Dog)</span><br><span class="hljs-comment">// panic: interface conversion: main.Eater is *main.Dog, not main.Dog</span><br>d := eat.(*Dog)<br>fmt.Println(d)<br>&#125;<br></code></pre></td></tr></table></figure><p>如果接口内保存的实例对应的类型指针，必须是要转换的对应的类型指针。</p><h3 id="9-error-接口"><a href="#9-error-接口" class="headerlink" title="9. error 接口"></a>9. error 接口</h3><p>Go语言中返回的 error 类型接口类型</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> error <span class="hljs-keyword">interface</span> &#123;<br>Error() <span class="hljs-keyword">string</span><br>&#125;<br></code></pre></td></tr></table></figure><p>自定义错误类型：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyError <span class="hljs-keyword">struct</span> &#123;<br>code     <span class="hljs-keyword">int</span><br>msg <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(err MyError)</span> <span class="hljs-title">Error</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span> &#123;<br><span class="hljs-keyword">return</span> fmt.Sprintf(<span class="hljs-string">&quot;error code：%v，error message :%v&quot;</span>, err.code,err.msg)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getUser</span><span class="hljs-params">(id <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">string</span>, error)</span></span> &#123;<br><span class="hljs-keyword">if</span> id == <span class="hljs-string">&quot;&quot;</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>, MyError&#123;<span class="hljs-number">400</span>, <span class="hljs-string">&quot;user id is illegal&quot;</span>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&#123;....&#125;&quot;</span>, <span class="hljs-literal">nil</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>result, err := getUser(<span class="hljs-string">&quot;&quot;</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br><span class="hljs-comment">// error code：400，error message :user id is illegal</span><br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(result)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——结构体</title>
    <link href="/2022/01/02/Go%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93/"/>
    <url>/2022/01/02/Go%E2%80%94%E2%80%94%E7%BB%93%E6%9E%84%E4%BD%93/</url>
    
    <content type="html"><![CDATA[<p>Golang 面向对象编程非常简洁，去掉了传统 OOP 语言的方法重载、构造函数和析构函数、隐藏的this指针等等</p><h3 id="1-结构体"><a href="#1-结构体" class="headerlink" title="1. 结构体"></a>1. 结构体</h3><h4 id="1-1-结构体的定义"><a href="#1-1-结构体的定义" class="headerlink" title="1.1 结构体的定义"></a>1.1 结构体的定义</h4><p>使用type和struct关键字来定义结构体，具体代码格式如下：</p><blockquote><p>type　类型名　struct {<br>　字段名　字段类型<br>　字段名　字段类型<br>　…<br>}</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>ID   <span class="hljs-keyword">string</span><br>Name <span class="hljs-keyword">string</span><br>Age  <span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-comment">// 同样类型的字段也可以写在一行</span><br><span class="hljs-keyword">type</span> Student1 <span class="hljs-keyword">struct</span> &#123;<br>ID, Name <span class="hljs-keyword">string</span><br>Age      <span class="hljs-keyword">int</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h4 id="1-2-实例化与初始化"><a href="#1-2-实例化与初始化" class="headerlink" title="1.2 实例化与初始化"></a>1.2 实例化与初始化</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// 方法一</span><br><span class="hljs-keyword">var</span> stu Student<br>fmt.Println(stu)<br><span class="hljs-comment">// &#123;  0&#125;</span><br>stu.ID = <span class="hljs-string">&quot;0001&quot;</span><br>stu.Name = <span class="hljs-string">&quot;张三&quot;</span><br>stu.Age = <span class="hljs-number">18</span><br>fmt.Println(stu)<br><span class="hljs-comment">// &#123;0001 张涛 18&#125;</span><br><br><span class="hljs-comment">// 方法二</span><br><span class="hljs-comment">//var stu1 Student = Student&#123;&#125;</span><br><span class="hljs-keyword">var</span> stu1 Student = Student&#123;<span class="hljs-string">&quot;0002&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-number">19</span>&#125;<br>fmt.Println(stu1)<br><span class="hljs-comment">// &#123;0002 李四 19&#125;</span><br><br><span class="hljs-comment">// 方法三</span><br><span class="hljs-keyword">var</span> stu2 *Student = <span class="hljs-built_in">new</span>(Student)<br>(*stu2).ID = <span class="hljs-string">&quot;0003&quot;</span><br>(*stu2).Name = <span class="hljs-string">&quot;李四&quot;</span><br><span class="hljs-comment">// 编译器进行自动转换</span><br>stu2.Age = <span class="hljs-number">20</span><br>fmt.Println(*stu2)<br><span class="hljs-comment">// &#123;0003 李四 20&#125;</span><br><br><span class="hljs-comment">// 方法四</span><br><span class="hljs-comment">//var stu3 *Student = &amp;Student&#123;&#125;</span><br>stu3 := &amp;Student&#123;<span class="hljs-string">&quot;0004&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>, <span class="hljs-number">19</span>&#125;<br>fmt.Println(*stu3)<br><br><span class="hljs-comment">// 初始化方式</span><br>stu4 := &amp;Student&#123;Name: <span class="hljs-string">&quot;王五&quot;</span>, ID: <span class="hljs-string">&quot;00005&quot;</span>, Age: <span class="hljs-number">19</span>&#125;<br>fmt.Println(*stu4)<br><br>stu5 := &amp;Student&#123;Name: <span class="hljs-string">&quot;王五&quot;</span>&#125;<br>fmt.Println(*stu5)<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-3-匿名结构体"><a href="#1-3-匿名结构体" class="headerlink" title="1.3 匿名结构体"></a>1.3 匿名结构体</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> user <span class="hljs-keyword">struct</span> &#123;<br>Name <span class="hljs-keyword">string</span><br>age  <span class="hljs-keyword">int</span><br>&#125;<br>user.Name = <span class="hljs-string">&quot;张三&quot;</span><br>user.age = <span class="hljs-number">19</span><br>fmt.Println(user)<br></code></pre></td></tr></table></figure><h4 id="1-4-结构体的匿名字段"><a href="#1-4-结构体的匿名字段" class="headerlink" title="1.4 结构体的匿名字段"></a>1.4 结构体的匿名字段</h4><p>结构体允许其成员字段在声明时没有字段名而只有类型，这种没有名字的字段就称为匿名字段。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br><span class="hljs-keyword">string</span><br><span class="hljs-keyword">int</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p1 := Person&#123;<br><span class="hljs-string">&quot;张三&quot;</span>,<br><span class="hljs-number">18</span>,<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%+v\n&quot;</span>, p1)<span class="hljs-comment">// &#123;string:张三 int:18&#125;</span><br>fmt.Println(p1.<span class="hljs-keyword">string</span>, p1.<span class="hljs-keyword">int</span>) <span class="hljs-comment">//张三 18</span><br>&#125;<br></code></pre></td></tr></table></figure><p>注意：这里匿名字段的说法并不代表没有字段名，而是默认会采用类型名作为字段名，结构体要求字段名称必须唯一，因此一个结构体中同种类型的匿名字段只能有一个。</p><h4 id="1-5-嵌套结构体"><a href="#1-5-嵌套结构体" class="headerlink" title="1.5 嵌套结构体"></a>1.5 嵌套结构体</h4><p>一个结构体中可以嵌套包含另一个结构体或结构体指针。<br>当访问结构体成员时会先在结构体中查找该字段，找不到再去嵌套的匿名字段中查找。<br>嵌套结构体内部可能存在相同的字段名。在这种情况下为了避免歧义需要通过指定具体的内嵌结构体字段名。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Address 地址结构体</span><br><span class="hljs-keyword">type</span> Address <span class="hljs-keyword">struct</span> &#123;<br>Province <span class="hljs-keyword">string</span><br>City     <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">// User 嵌套结构体</span><br><span class="hljs-keyword">type</span> User <span class="hljs-keyword">struct</span> &#123;<br>Name    <span class="hljs-keyword">string</span><br>Gender  <span class="hljs-keyword">string</span><br>Address Address<br>&#125;<br><br><span class="hljs-comment">// User1 嵌套匿名字段</span><br><span class="hljs-keyword">type</span> User1 <span class="hljs-keyword">struct</span> &#123;<br>Name   <span class="hljs-keyword">string</span><br>Gender <span class="hljs-keyword">string</span><br>Address<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>u1 := User&#123;<br>Name:   <span class="hljs-string">&quot;张三&quot;</span>,<br>Gender: <span class="hljs-string">&quot;男&quot;</span>,<br>Address: Address&#123;<br>Province: <span class="hljs-string">&quot;陕西&quot;</span>,<br>City:     <span class="hljs-string">&quot;西安&quot;</span>,<br>&#125;,<br>&#125;<br><br><span class="hljs-keyword">var</span> u2 User1<br>u2.Name = <span class="hljs-string">&quot;李四&quot;</span><br>u2.Gender = <span class="hljs-string">&quot;男&quot;</span><br>u2.Address.Province = <span class="hljs-string">&quot;甘肃&quot;</span> <span class="hljs-comment">// 匿名字段默认使用类型名作为字段名</span><br>u2.City = <span class="hljs-string">&quot;天水&quot;</span>             <span class="hljs-comment">// 匿名字段可以省略</span><br><br>fmt.Printf(<span class="hljs-string">&quot;user1=%+v\n&quot;</span>, u1)<br>fmt.Printf(<span class="hljs-string">&quot;user1=%+v\n&quot;</span>, u2)<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-6-结构体之间的转换"><a href="#1-6-结构体之间的转换" class="headerlink" title="1.6 结构体之间的转换"></a>1.6 结构体之间的转换</h4><ol><li>结构体是用户单独定义的类型，和其它类型进行转换时需要有完全相同的字段(名字、个数和类型)</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Age <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>Age <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> p Person = Person&#123;<span class="hljs-number">10</span>&#125;<br><span class="hljs-keyword">var</span> s Student<br>s = Student(p)<br>fmt.Println(s)<br><span class="hljs-comment">// &#123;10&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>结构体进行 typ e重新定义(相当于取别名)，Golang 认为是新的数据类型，但是相互间可以强转</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>Age <span class="hljs-keyword">int</span><br>&#125;<br><span class="hljs-keyword">type</span> Stu Student<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> s1 Student = Student&#123;<span class="hljs-number">19</span>&#125;<br><span class="hljs-keyword">var</span> s2 Stu<br>s2 = Stu(s1)<br>fmt.Println(s2)<br><span class="hljs-comment">// &#123;19&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-结构体的“继承”"><a href="#2-结构体的“继承”" class="headerlink" title="2. 结构体的“继承”"></a>2. 结构体的“继承”</h3><h4 id="2-1-方法和接收者"><a href="#2-1-方法和接收者" class="headerlink" title="2.1 方法和接收者"></a>2.1 方法和接收者</h4><p>Go语言中的方法（Method）是一种作用于特定类型变量的函数。这种特定类型变量叫做接收者（Receiver）。接收者的概念就类似于其他语言中的 this 或者 self。</p><p>定义格式如下：</p><blockquote><p>func　(接收者变量 接收者类型)　方法名(参数列表)　(返回参数) {<br>　　函数体<br>}</p></blockquote><ul><li>接收者类型：接收者类型和参数类似，可以是指针类型和非指针类型。</li><li>方法名、参数列表、返回参数：具体格式与函数定义相同。</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Person 结构体</span><br><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>age  <span class="hljs-keyword">int8</span><br>&#125;<br><br><span class="hljs-comment">//NewPerson 构造函数（Go语言的结构体没有构造函数）</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NewPerson</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, age <span class="hljs-keyword">int8</span>)</span> *<span class="hljs-title">Person</span></span> &#123;<br><span class="hljs-keyword">return</span> &amp;Person&#123;<br>name: name,<br>age:  age,<br>&#125;<br>&#125;<br><br><span class="hljs-comment">//Eat Person做梦的方法</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p Person)</span> <span class="hljs-title">Eat</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;干啥啥不行，吃饭第一名&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// SetAge 实现 setter</span><br><span class="hljs-comment">// 使用指针接收者</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(p *Person)</span> <span class="hljs-title">SetAge</span><span class="hljs-params">(newAge <span class="hljs-keyword">int8</span>)</span></span> &#123;<br>p.age = newAge<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>p1 := NewPerson(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-number">25</span>)<br>p1.SetAge(<span class="hljs-number">18</span>)<br>fmt.Println(*p1)<span class="hljs-comment">// &#123;张三 18&#125;</span><br>p1.Eat()<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-结构体的-“继承”"><a href="#2-2-结构体的-“继承”" class="headerlink" title="2.2 结构体的 “继承”"></a>2.2 结构体的 “继承”</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Animal 动物</span><br><span class="hljs-keyword">type</span> Animal <span class="hljs-keyword">struct</span> &#123;<br>name <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(a *Animal)</span> <span class="hljs-title">move</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s会动！\n&quot;</span>, a.name)<br>&#125;<br><br><span class="hljs-comment">//Dog 狗</span><br><span class="hljs-keyword">type</span> Dog <span class="hljs-keyword">struct</span> &#123;<br>Feet    <span class="hljs-keyword">int8</span><br>*Animal <span class="hljs-comment">//通过嵌套匿名结构体实现继承</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(d *Dog)</span> <span class="hljs-title">wang</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%s会汪汪汪~\n&quot;</span>, d.name)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>d1 := &amp;Dog&#123;<br>Feet: <span class="hljs-number">4</span>,<br>Animal: &amp;Animal&#123;<br>name: <span class="hljs-string">&quot;小黄&quot;</span>,<br>&#125;,<br>&#125;<br>d1.wang() <span class="hljs-comment">// 小黄会汪汪汪~</span><br>d1.move() <span class="hljs-comment">// 小黄会动！</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-结构体与JSON序列化"><a href="#3-结构体与JSON序列化" class="headerlink" title="3. 结构体与JSON序列化"></a>3. 结构体与JSON序列化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">//Student 学生</span><br><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>ID     <span class="hljs-keyword">int</span><br>Gender <span class="hljs-keyword">string</span><br>Name   <span class="hljs-keyword">string</span><br>&#125;<br><br><span class="hljs-comment">//Class 班级</span><br><span class="hljs-keyword">type</span> Class <span class="hljs-keyword">struct</span> &#123;<br>Title    <span class="hljs-keyword">string</span><br>Students []*Student<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>c := &amp;Class&#123;<br>Title:    <span class="hljs-string">&quot;101&quot;</span>,<br>Students: <span class="hljs-built_in">make</span>([]*Student, <span class="hljs-number">2</span>),<br>&#125;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">2</span>; i++ &#123;<br>stu := &amp;Student&#123;<br>Name:   fmt.Sprintf(<span class="hljs-string">&quot;stu%02d&quot;</span>, i),<br>Gender: <span class="hljs-string">&quot;男&quot;</span>,<br>ID:     i,<br>&#125;<br>c.Students = <span class="hljs-built_in">append</span>(c.Students, stu)<br>&#125;<br><br><span class="hljs-comment">//JSON序列化：结构体--&gt;JSON格式的字符串</span><br>data, err := json.Marshal(c)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;json marshal failed&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;json:%s\n&quot;</span>, data)<br><br><span class="hljs-comment">//JSON反序列化：JSON格式的字符串--&gt;结构体</span><br>str := <span class="hljs-string">`&#123;&quot;Title&quot;:&quot;101&quot;,&quot;Students&quot;:[&#123;&quot;ID&quot;:0,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu00&quot;&#125;,&#123;&quot;ID&quot;:1,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu01&quot;&#125;,&#123;&quot;ID&quot;:2,&quot;Gender&quot;:&quot;男&quot;,&quot;Name&quot;:&quot;stu02&quot;&#125;]&#125;`</span><br>c1 := &amp;Class&#123;&#125;<br>err = json.Unmarshal([]<span class="hljs-keyword">byte</span>(str), c1)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;json unmarshal failed!&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%v\n&quot;</span>, *c1)<br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-结构体标签"><a href="#4-结构体标签" class="headerlink" title="4. 结构体标签"></a>4. 结构体标签</h3><p>Tag是结构体的元信息，可以在运行的时候通过反射的机制读取出来。 Tag 在结构体字段的后方定义，由一对反引号包裹起来，具体的格式如下：</p><blockquote><p>`key1:”value1　“key2:”value2” `</p></blockquote><p>结构体 tag 由一个或多个键值对组成。键与值使用冒号分隔，值用双引号括起来。同一个结构体字段可以设置多个键值对tag，不同的键值对之间使用空格分隔。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> Student <span class="hljs-keyword">struct</span> &#123;<br>ID     <span class="hljs-keyword">int</span>    <span class="hljs-string">`json:&quot;id&quot;`</span> <span class="hljs-comment">// 通过指定 tag 实现 json 序列化该字段时的 key</span><br>Gender <span class="hljs-keyword">string</span> <span class="hljs-comment">// json 序列化是默认使用字段名作为 key</span><br>name   <span class="hljs-keyword">string</span> <span class="hljs-comment">// 私有不能被 json 包访问</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>s1 := Student&#123;<br>ID:     <span class="hljs-number">1</span>,<br>Gender: <span class="hljs-string">&quot;男&quot;</span>,<br>name:   <span class="hljs-string">&quot;张三&quot;</span>,<br>&#125;<br>data, err := json.Marshal(s1)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;json marshal failed!&quot;</span>)<br><span class="hljs-keyword">return</span><br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%s\n&quot;</span>, data) <span class="hljs-comment">// &#123;&quot;id&quot;:1,&quot;Gender&quot;:&quot;男&quot;&#125;</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——Map</title>
    <link href="/2022/01/02/Go%E2%80%94%E2%80%94Map/"/>
    <url>/2022/01/02/Go%E2%80%94%E2%80%94Map/</url>
    
    <content type="html"><![CDATA[<h3 id="1-定义-Map"><a href="#1-定义-Map" class="headerlink" title="1. 定义 Map"></a>1. 定义 Map</h3><blockquote><p>var　map_variable　map[key_data_type]　value_data_type</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> student <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span><br></code></pre></td></tr></table></figure><ul><li>key、value的类型：bool、数字、string、指针、channel 、还可以是只包含前面几个类型的接口、结构体、数组</li><li>key 通常为 int 、string 类型，value 通常为数字（整数、浮点数）、string、map、结构体</li><li>key：slice、map、function 不可以</li><li>map 只申明不会进行内存分配</li><li>map 的 key-value 是无序的</li><li>key 是不可以重复的</li><li>value 可以重复</li></ul><h3 id="2-初始化"><a href="#2-初始化" class="headerlink" title="2. 初始化"></a>2. 初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> student <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span><br><span class="hljs-comment">// 第一种</span><br>student = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>, <span class="hljs-number">10</span>)<br>student[<span class="hljs-number">00001</span>] = <span class="hljs-string">&quot;张三&quot;</span><br><br><span class="hljs-comment">// 第二种</span><br>stu := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>)<br>stu[<span class="hljs-number">00002</span>] = <span class="hljs-string">&quot;李四&quot;</span><br><br><span class="hljs-comment">// 第三种</span><br>stud := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>&#123;<br><span class="hljs-number">00003</span>: <span class="hljs-string">&quot;王五&quot;</span>,<br><span class="hljs-number">00004</span>: <span class="hljs-string">&quot;赵六&quot;</span>,<br>&#125;<br><br>fmt.Println(stud)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-操作"><a href="#3-操作" class="headerlink" title="3. 操作"></a>3. 操作</h3><ol><li><p>增加、更新操作<br> map[“key”] = value<br> 如果 key 不存在，进行新增，如果 key 存则覆盖。</p></li><li><p>删除操作<br>delete(map，”key”)<br>如果 key 存在，就删除该 key-value，如果 key 不存在，不操作也不会报错。</p></li><li><p>清空操作<br>（1）可以遍历key，逐个删除<br>（2）或者map = make(…)，make一个新的，让原来的成为垃圾，被gc回收</p></li><li><p>查找操作<br>value ,bool = map[key]<br>value 为返回的 value，bool 为是否返回</p></li><li><p>获取长度：len函数</p></li><li><p>遍历：for-range</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>student := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>)<br><br>student[<span class="hljs-number">00001</span>] = <span class="hljs-string">&quot;张三&quot;</span><br>student[<span class="hljs-number">00001</span>] = <span class="hljs-string">&quot;李四&quot;</span><br>student[<span class="hljs-number">00002</span>] = <span class="hljs-string">&quot;王五&quot;</span><br>fmt.Println(student)<br><span class="hljs-comment">// map[1:李四 2:王五]</span><br><br><span class="hljs-comment">// 查找</span><br>s := student[<span class="hljs-number">0001</span>]<br>fmt.Println(s) <span class="hljs-comment">// 李四</span><br>s2, b := student[<span class="hljs-number">0004</span>]<br>fmt.Println(s2, b) <span class="hljs-comment">// false</span><br><br><span class="hljs-keyword">for</span> i, s3 := <span class="hljs-keyword">range</span> student &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%v --- %v \n&quot;</span>, i, s3)<br>&#125;<br><br><span class="hljs-comment">// 删除</span><br><span class="hljs-built_in">delete</span>(student, <span class="hljs-number">001</span>)<br><span class="hljs-built_in">delete</span>(student, <span class="hljs-number">003</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(student)) <span class="hljs-comment">// 1</span><br><br><span class="hljs-comment">// 清空</span><br>student = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>]<span class="hljs-keyword">string</span>)<br>fmt.Println(<span class="hljs-built_in">len</span>(student)) <span class="hljs-comment">// 0</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-比较"><a href="#4-比较" class="headerlink" title="4. 比较"></a>4. 比较</h3><p>map 之间也不能进行相等比较；唯一的例外是和nil进行比较。要判断两个 map 是否包含相同的 key 和 value，我们必须通过一个循环实现：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">equal</span><span class="hljs-params">(x, y <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> &#123;<br><span class="hljs-keyword">if</span> <span class="hljs-built_in">len</span>(x) != <span class="hljs-built_in">len</span>(y) &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br><span class="hljs-keyword">for</span> k, xv := <span class="hljs-keyword">range</span> x &#123;<br><span class="hljs-keyword">if</span> yv, ok := y[k]; !ok || yv != xv &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">false</span><br>&#125;<br>&#125;<br><span class="hljs-keyword">return</span> <span class="hljs-literal">true</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——切片</title>
    <link href="/2022/01/02/Go%E2%80%94%E2%80%94%E5%88%87%E7%89%87/"/>
    <url>/2022/01/02/Go%E2%80%94%E2%80%94%E5%88%87%E7%89%87/</url>
    
    <content type="html"><![CDATA[<p>切片（slice）是对数组的一个连续片段的引用，所以切片是一个引用类型，这个片段可以是整个数组，也可以是由起始和终止索引标识的一些项的子集，需要注意的是，终止索引标识的项不包括在切片内。</p><p>一个 slice 由三个部分构成：指针、长度和容量。指针指向第一个 slice 元素对应的底层数组元素的地址，要注意的是 slice 的第一个元素并不一定就是数组的第一个元素。</p><h3 id="1-切片的定义"><a href="#1-切片的定义" class="headerlink" title="1. 切片的定义"></a>1. 切片的定义</h3><ol><li><p>从数组或切片生成新的切片</p><p>语法：slice [开始位置 : 结束位置]</p><blockquote><p>从数组或切片生成新的切片拥有如下特性：</p><ul><li>取出的元素数量为：结束位置 - 开始位置；</li><li>取出元素不包含结束位置对应的索引，切片最后一个元素使用 slice[len(slice)] 获取；</li><li>当缺省开始位置时，表示从连续区域开头到结束位置；</li><li>当缺省结束位置时，表示从开始位置到整个连续区域末尾；</li><li>两者同时缺省时，与切片本身等效；</li><li>两者同时为 0 时，等效于空切片，一般用于切片复位。</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">   <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">/* 数组长度为 5 */</span><br><span class="hljs-keyword">var</span>  array = [<span class="hljs-number">5</span>]<span class="hljs-keyword">int</span> &#123;<span class="hljs-number">1000</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">17</span>, <span class="hljs-number">50</span>&#125;<br><br>slice := array[<span class="hljs-number">0</span>:<span class="hljs-number">4</span>]<br><span class="hljs-comment">// [1000 2 3 17]</span><br>slice2 := slice[<span class="hljs-number">0</span>:<span class="hljs-number">3</span>]<br><span class="hljs-comment">// [1000 2 3]</span><br><br>fmt.Printf(<span class="hljs-string">&quot;%T&quot;</span>,slice)<br><span class="hljs-comment">// []int</span><br>fmt.Printf(<span class="hljs-string">&quot;%v,%v&quot;</span>,<span class="hljs-built_in">len</span>(slice2),<span class="hljs-built_in">cap</span>(slice2))<br><span class="hljs-comment">// 3,5</span><br>&#125;<br></code></pre></td></tr></table></figure></li><li><p>使用 make() 函数构造切片</p></li></ol><blockquote><p>语法：make( []Type, size, cap )    </p></blockquote><p> make 底层创建一个数组，对外不可见</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"> <br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>slice := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">5</span>, <span class="hljs-number">10</span>)<br>fmt.Println(slice)<br><span class="hljs-comment">//[0 0 0 0 0]</span><br><br>fmt.Printf(<span class="hljs-string">&quot;长度：%v，容量：%v&quot;</span>, <span class="hljs-built_in">len</span>(slice), <span class="hljs-built_in">cap</span>(slice))<br><span class="hljs-comment">// 长度：5，容量：10</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>直接声明新的切片</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>slice := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">23</span>, <span class="hljs-number">45</span>, <span class="hljs-number">67</span>&#125;<br>fmt.Println(slice)<br><span class="hljs-comment">//[23 45 67]</span><br><br>fmt.Printf(<span class="hljs-string">&quot;长度：%v，容量：%v&quot;</span>, <span class="hljs-built_in">len</span>(slice), <span class="hljs-built_in">cap</span>(slice))<br><span class="hljs-comment">// 长度：3，容量：3</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-切片的遍历"><a href="#2-切片的遍历" class="headerlink" title="2. 切片的遍历"></a>2. 切片的遍历</h3><p>方式1：for循环常规方式遍历<br>方式2：for-range 结构遍历切片</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>slice := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">23</span>, <span class="hljs-number">45</span>, <span class="hljs-number">67</span>&#125;<br><br><span class="hljs-comment">//方式1：普通for循环</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(slice); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;slice[%v] = %v \t&quot;</span>, i, slice[i])<br>&#125;<br>fmt.Println(<span class="hljs-string">&quot;\n------------------------------&quot;</span>)<br><span class="hljs-comment">//方式2：for-range循环：</span><br><span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> slice &#123;<br>fmt.Printf(<span class="hljs-string">&quot;下标：%v ，元素：%v\n&quot;</span>, i, v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-切片的操作"><a href="#3-切片的操作" class="headerlink" title="3. 切片的操作"></a>3. 切片的操作</h3><h4 id="3-1-添加元素"><a href="#3-1-添加元素" class="headerlink" title="3.1 添加元素"></a>3.1 添加元素</h4><p>用 append() 函数为切片动态添加元素时，如果空间不足，切片就会进行“扩容”。切片在扩容时，容量的扩展规律是按容量的 2 倍数进行扩充。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> a []<span class="hljs-keyword">int</span><br>a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">1</span>)                 <span class="hljs-comment">// 追加1个元素</span><br>a = <span class="hljs-built_in">append</span>(a, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>)           <span class="hljs-comment">// 追加多个元素, 手写解包方式</span><br>a = <span class="hljs-built_in">append</span>(a, []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;...) <span class="hljs-comment">// 追加一个切片, 切片需要解包</span><br><br>fmt.Println(a)<br><span class="hljs-comment">// [1 1 2 3 1 2 3]</span><br><br><span class="hljs-keyword">var</span> b = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>b = <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>&#125;, b...)          <span class="hljs-comment">// 在开头添加1个元素</span><br>b = <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">-3</span>, <span class="hljs-number">-2</span>, <span class="hljs-number">-1</span>&#125;, b...) <span class="hljs-comment">// 在开头添加1个切片</span><br>fmt.Println(b)<br><span class="hljs-comment">// [-3 -2 -1 0 1 2 3]</span><br><br><span class="hljs-keyword">var</span> c []<span class="hljs-keyword">int</span> = []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;<br>c = <span class="hljs-built_in">append</span>(c[:<span class="hljs-number">1</span>], <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">100</span>&#125;, c[<span class="hljs-number">1</span>:]...)...)     <span class="hljs-comment">// 在第i个位置插入x</span><br>c = <span class="hljs-built_in">append</span>(c[:<span class="hljs-number">2</span>], <span class="hljs-built_in">append</span>([]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, c[<span class="hljs-number">2</span>:]...)...) <span class="hljs-comment">// 在第i个位置插入切片</span><br>fmt.Println(c)<br><span class="hljs-comment">// [1 100 0 0 0 2 3]</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>在切片开头添加元素一般都会导致内存的重新分配，而且会导致已有元素全部被复制 1 次，因此，从切片的开头添加元素的性能要比从尾部追加元素的性能差很多。</p><h4 id="3-2-切片复制"><a href="#3-2-切片复制" class="headerlink" title="3.2 切片复制"></a>3.2 切片复制</h4><blockquote><p>语法：copy( destSlice, srcSlice []T) int<br>将 srcSlice 复制到 destSlice</p></blockquote><p> copy() 可以将一个数组切片复制到另一个数组切片中，如果加入的两个数组切片不一样大，就会按照其中较小的那个数组切片的元素个数进行复制。</p><p>来源和目标的类型必须一致，copy() 函数的返回值表示实际发生复制的元素个数。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>slice1 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>&#125;<br>slice2 := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">5</span>, <span class="hljs-number">4</span>, <span class="hljs-number">3</span>&#125;<br><span class="hljs-built_in">copy</span>(slice2, slice1) <span class="hljs-comment">// 只会复制slice1的前3个元素到slice2中</span><br>fmt.Println(slice2)<br><span class="hljs-comment">// [1 2 3]</span><br><br><span class="hljs-built_in">copy</span>(slice1, slice2) <span class="hljs-comment">// 只会复制slice2的3个元素到slice1的前3个位置</span><br>fmt.Println(slice1)<br><span class="hljs-comment">// [1 2 3 4 5]</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-删除元素"><a href="#3-3-删除元素" class="headerlink" title="3.3 删除元素"></a>3.3 删除元素</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>a := []<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>&#125;<br>a = a[<span class="hljs-number">2</span>:] <span class="hljs-comment">// 删除开头N个元素</span><br>a = <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">0</span>], a[<span class="hljs-number">3</span>:]...) <span class="hljs-comment">// 删除开头N个元素</span><br><br>fmt.Println(a)<br><span class="hljs-comment">// [6 7 8 9]</span><br><br>a = <span class="hljs-built_in">append</span>(a[:<span class="hljs-number">1</span>], a[<span class="hljs-number">1</span>+<span class="hljs-number">1</span>:]...) <span class="hljs-comment">// 删除中间N个元素</span><br><br>a = a[:<span class="hljs-built_in">len</span>(a)<span class="hljs-number">-2</span>] <span class="hljs-comment">// 删除尾部N个元素</span><br><br>fmt.Println(a)<br><span class="hljs-comment">// [6]</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——数组</title>
    <link href="/2022/01/01/Go%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/"/>
    <url>/2022/01/01/Go%E2%80%94%E2%80%94%E6%95%B0%E7%BB%84/</url>
    
    <content type="html"><![CDATA[<h3 id="1-数组的申明"><a href="#1-数组的申明" class="headerlink" title="1. 数组的申明"></a>1. 数组的申明</h3><blockquote><p>var　variable_name　[SIZE]variable_type</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> scores [<span class="hljs-number">5</span>]<span class="hljs-keyword">int16</span><br><br>fmt.Println(scores)         <span class="hljs-comment">// [0 0 0 0 0]</span><br>fmt.Println(<span class="hljs-built_in">len</span>(scores))    <span class="hljs-comment">// 5</span><br>fmt.Printf(<span class="hljs-string">&quot;%T \n&quot;</span>, scores) <span class="hljs-comment">// [5]int16</span><br><br>fmt.Printf(<span class="hljs-string">&quot;数组的地址：%p \n&quot;</span>, &amp;scores) <span class="hljs-comment">// 0xc0000ac070</span><br><span class="hljs-comment">//第一个空间的地址：</span><br>fmt.Printf(<span class="hljs-string">&quot;第一个元素地址：%p \n&quot;</span>, &amp;scores[<span class="hljs-number">0</span>]) <span class="hljs-comment">// 0xc0000ac070</span><br><span class="hljs-comment">//第二个空间的地址：</span><br>fmt.Printf(<span class="hljs-string">&quot;第二个元素地址：%p \n&quot;</span>, &amp;scores[<span class="hljs-number">1</span>]) <span class="hljs-comment">// 0xc0000ac072</span><br>&#125;<br><br></code></pre></td></tr></table></figure><p>【注】</p><ol><li>数组的地址即第一个元素的地址，数组每个元素占用的字节数取决于数组类型。</li><li>长度属于类型的一部分 </li><li>Go 中数组属值类型，在默认情况下是值传递，因此会进行值拷贝。</li></ol><h3 id="2-数组的初始化"><a href="#2-数组的初始化" class="headerlink" title="2. 数组的初始化"></a>2. 数组的初始化</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//第一种：</span><br><span class="hljs-keyword">var</span> arr1 [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span> = [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">3</span>, <span class="hljs-number">6</span>, <span class="hljs-number">9</span>&#125;<br>fmt.Println(arr1)<br><span class="hljs-comment">//第二种：</span><br><span class="hljs-keyword">var</span> arr2 = [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">1</span>, <span class="hljs-number">4</span>, <span class="hljs-number">7</span>&#125;<br>fmt.Println(arr2)<br><span class="hljs-comment">//第三种：</span><br><span class="hljs-keyword">var</span> arr3 = [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>&#125;<br>fmt.Println(arr3)<br><span class="hljs-comment">//第四种：</span><br><span class="hljs-keyword">var</span> arr4 = [...]<span class="hljs-keyword">int</span>&#123;<span class="hljs-number">2</span>: <span class="hljs-number">66</span>, <span class="hljs-number">0</span>: <span class="hljs-number">33</span>, <span class="hljs-number">1</span>: <span class="hljs-number">99</span>, <span class="hljs-number">3</span>: <span class="hljs-number">88</span>&#125;<br>fmt.Println(arr4)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-数组的遍历"><a href="#3-数组的遍历" class="headerlink" title="3. 数组的遍历"></a>3. 数组的遍历</h3><ol><li>for 循环</li><li> for range</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> scores [<span class="hljs-number">5</span>]<span class="hljs-keyword">int16</span> = [<span class="hljs-number">5</span>]<span class="hljs-keyword">int16</span>&#123;<span class="hljs-number">56</span>, <span class="hljs-number">34</span>, <span class="hljs-number">78</span>, <span class="hljs-number">94</span>&#125;<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(scores); i++ &#123;<br>fmt.Println(scores[i])<br>&#125;<br><br><span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> scores &#123;<br>fmt.Println(v)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-二维数组"><a href="#4-二维数组" class="headerlink" title="4. 二维数组"></a>4. 二维数组</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> array1 [<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]<span class="hljs-keyword">int16</span> = [<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]<span class="hljs-keyword">int16</span>&#123;&#123;<span class="hljs-number">32</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">0</span>&#125;, &#123;<span class="hljs-number">0</span>, <span class="hljs-number">32</span>&#125;&#125;<br>fmt.Println(array1)<br><br><span class="hljs-keyword">var</span> array [<span class="hljs-number">3</span>][<span class="hljs-number">2</span>]<span class="hljs-keyword">int16</span><br><span class="hljs-comment">// 赋值</span><br>array[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>] = <span class="hljs-number">32</span><br>array[<span class="hljs-number">2</span>][<span class="hljs-number">1</span>] = <span class="hljs-number">32</span><br>fmt.Println(array)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(array); i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-built_in">len</span>(array[i]); j++ &#123;<br>fmt.Print(array[i][j], <span class="hljs-string">&quot;\t&quot;</span>)<br>&#125;<br>fmt.Println()<br>&#125;<br><br><span class="hljs-keyword">for</span> key, value := <span class="hljs-keyword">range</span> array &#123;<br><span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> value &#123;<br>fmt.Printf(<span class="hljs-string">&quot;arr[%v][%v]=%v\t&quot;</span>, key, k, v)<br>&#125;<br>fmt.Println()<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-向函数传递数组"><a href="#5-向函数传递数组" class="headerlink" title="5. 向函数传递数组"></a>5. 向函数传递数组</h3><p>void myFunction(param [10]int){}<br>void myFunction(param []int)</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">/* 数组长度为 5 */</span><br><span class="hljs-keyword">var</span>  balance = []<span class="hljs-keyword">int</span> &#123;<span class="hljs-number">1000</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">17</span>, <span class="hljs-number">50</span>&#125;<br><span class="hljs-keyword">var</span> avg <span class="hljs-keyword">float32</span><br><br>avg = getAverage( balance, <span class="hljs-number">5</span> )<br>fmt.Printf( <span class="hljs-string">&quot;平均值为: %f &quot;</span>, avg )<br><br><span class="hljs-keyword">var</span>  balance2 = [<span class="hljs-number">6</span>]<span class="hljs-keyword">int</span> &#123;<span class="hljs-number">1000</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">17</span>, <span class="hljs-number">50</span>&#125;<br>avg = getAverage2( balance2)<br>fmt.Printf( <span class="hljs-string">&quot;平均值为: %f &quot;</span>, avg )<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getAverage</span><span class="hljs-params">(arr []<span class="hljs-keyword">int</span>, size <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">float32</span></span> &#123;<br><span class="hljs-keyword">var</span> i,sum <span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> avg <span class="hljs-keyword">float32</span><br><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; i &lt; size;i++ &#123;<br>sum += arr[i]<br>&#125;<br>avg = <span class="hljs-keyword">float32</span>(sum) / <span class="hljs-keyword">float32</span>(size)<br><span class="hljs-keyword">return</span> avg<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getAverage2</span><span class="hljs-params">(arr [6]<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">float32</span></span> &#123;<br><span class="hljs-keyword">var</span> i,sum <span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> avg <span class="hljs-keyword">float32</span><br><br><span class="hljs-keyword">for</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(arr);i++ &#123;<br>sum += arr[i]<br>&#125;<br>avg = <span class="hljs-keyword">float32</span>(sum) / <span class="hljs-keyword">float32</span>(<span class="hljs-built_in">len</span>(arr))<br><span class="hljs-keyword">return</span> avg<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——异常处理</title>
    <link href="/2021/12/30/Go%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/"/>
    <url>/2021/12/30/Go%E2%80%94%E2%80%94%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86/</url>
    
    <content type="html"><![CDATA[<h3 id="1-defer-recover-机制处理错误"><a href="#1-defer-recover-机制处理错误" class="headerlink" title="1. defer+recover 机制处理错误"></a>1. defer+recover 机制处理错误</h3><blockquote><p>func recover() interface{}</p></blockquote><p>内建函数 recover 允许程序管理恐慌过程中的 Go 程。在 defer 的函数中，执行 recover 调用会取回传至 panic 调用的错误值，恢复正常执行，停止恐慌过程。若 recover 在 defer 的函数之外被调用，它将不会停止恐慌过程序列。在此情况下，或当该 Go 程不在恐慌过程中时，或提供给 panic 的实参为 nil 时，recover 就会返回nil。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>result := division(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)<br>fmt.Println(result)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">division</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><br><span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> &#123;<br>err := <span class="hljs-built_in">recover</span>()<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;捕获到异常:&quot;</span>, err)<br>&#125;<br>&#125;()<br><br><span class="hljs-keyword">return</span> num1 / num2<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211230233446.png"></p><h3 id="2-自定义错误"><a href="#2-自定义错误" class="headerlink" title="2. 自定义错误"></a>2. 自定义错误</h3><p>调用 errors 包下的 New 函数，函数返回 error 类型。</p><blockquote><p>func New(text string) error</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>result, err := division(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)<br><br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br>fmt.Println(err)<br>&#125;<br><br>fmt.Println(result)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">division</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;<br><br><span class="hljs-keyword">if</span> num2 == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;integer divide by zero&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> num1 / num2, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211230234230.png"></p><h3 id="3-出现异常后中断程序"><a href="#3-出现异常后中断程序" class="headerlink" title="3. 出现异常后中断程序"></a>3. 出现异常后中断程序</h3><blockquote><p>func panic(v interface{})</p></blockquote><p> 内建函数 panic 停止当前 Go 程的正常执行。当函数 F 调用 panic 时，F 的正常执行就会立刻停止。F 中 defer 的所有函数先入后出执行后，F 返回给其调用者 G。G 如同 F 一样行动，层层返回，直到该 Go 程中所有函数都按相反的顺序停止执行。之后，程序被终止，而错误情况会被报告，包括引发该恐慌的实参值，此终止序列称为恐慌过程。</p> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>result, err := division(<span class="hljs-number">10</span>, <span class="hljs-number">0</span>)<br><span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> &#123;<br><span class="hljs-built_in">panic</span>(err)<br>&#125;<br>fmt.Println(result)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">division</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, error)</span></span> &#123;<br><br><span class="hljs-keyword">if</span> num2 == <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">&quot;integer divide by zero&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br><span class="hljs-keyword">return</span> num1 / num2, <span class="hljs-literal">nil</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211230234827.png"></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——函数</title>
    <link href="/2021/12/29/Go%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/"/>
    <url>/2021/12/29/Go%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h3 id="1-函数"><a href="#1-函数" class="headerlink" title="1. 函数"></a>1. 函数</h3><p><strong>基本语法：</strong><br>func   函数名（形参列表) [ 返回值类型列表 ] {<br> 　　执行语句..<br>　　return　返回值列表<br>}</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>)</span></span> &#123; <span class="hljs-comment">// 如果返回值类型只有一个，那么()是可以省略不写</span><br><span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br></code></pre></td></tr></table></figure><ol><li>函数名</li></ol><ul><li>驼峰命名  </li><li>首字母不能是数字</li><li>首字母大写该函数可以被本包文件和其它包文件使用</li><li>首学母小写只能被本包文件使用</li></ul><ol start="2"><li><p>形参列表：<br>形参可以是一个参数，可以是n个参数，可以是0个参数</p></li><li><p>返回值类型列表<br>如果有多个返回值，用 () 括起来；如果返回值类型只有一个，可以省略 ()；如果没有返回值，什么都不用写。在函数调用时，如果有返回值不想接收，可以用 _ 忽略。</p></li><li><p>值传递和引用传递<br>基本数据类型和数组默认都是值传递的，即进行值拷贝</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> num <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><br>aa(num)<br>fmt.Println(num)<span class="hljs-comment">// 10</span><br>bb(&amp;num)<br>fmt.Println(num)<span class="hljs-comment">// 200</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">aa</span><span class="hljs-params">(int2 <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>int2 = <span class="hljs-number">100</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bb</span><span class="hljs-params">(int2 *<span class="hljs-keyword">int</span>)</span></span>  &#123;<br>*int2 = <span class="hljs-number">200</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="5"><li><p>Golang 中函数不支持重载</p></li><li><p>支持可变参数<br>函数内将可变参数当做切片来处理</p></li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>test(<span class="hljs-number">37</span>, <span class="hljs-number">58</span>, <span class="hljs-number">39</span>, <span class="hljs-number">59</span>, <span class="hljs-number">47</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(args ...<span class="hljs-keyword">int</span>)</span></span> &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(args); i++ &#123;<br>fmt.Println(args[i])<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><ol start="7"><li>在 Go 中函数也是一种数据类型，可以赋值给一个变量，通过该变量可以对函数调用。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(num <span class="hljs-keyword">int</span>)</span></span> &#123;<br>fmt.Println(num)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>a := test<br>fmt.Printf(<span class="hljs-string">&quot;a的类型：%T，test函数的类型：%T \n&quot;</span>, a, test)<br><span class="hljs-comment">// a的类型：func(int)，test函数的类型：func(int)</span><br>a(<span class="hljs-number">10</span>)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="8"><li>函数既然是一种数据类型，因此在 Go 中，函数可以作为形参。</li></ol>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go">  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(str <span class="hljs-keyword">string</span>)</span></span> &#123;<br>fmt.Println(str)<br>&#125;<br><br><span class="hljs-comment">//定义一个函数，把另一个函数作为形参</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test02</span><span class="hljs-params">(testFunc <span class="hljs-keyword">func</span>(string2 <span class="hljs-keyword">string</span>)</span>)</span> &#123;<br>testFunc(<span class="hljs-string">&quot;hello&quot;</span>)<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>a := test<br>test02(a)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="9"><li>为了简化数据类型定义，Go 支持自定义数据类型 基本语法：type　自定义数据类型名　数据类型</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">type</span> myInt <span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> num myInt = <span class="hljs-number">100</span><br><br><span class="hljs-comment">// 虽然是别名，但是还是两种不同的类型</span><br><span class="hljs-comment">//var num2 int = num</span><br><br><span class="hljs-keyword">var</span> num2 <span class="hljs-keyword">int</span> = <span class="hljs-keyword">int</span>(num)<br>fmt.Println(num2)<br><br><span class="hljs-keyword">type</span> myFunc <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="10"><li>支持对函数返回值命名</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span></span> &#123;<br>sum := num1 + num2<br>sub := num1 - num2<br><span class="hljs-keyword">return</span> sum, sub<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">test2</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(sum <span class="hljs-keyword">int</span>, sub <span class="hljs-keyword">int</span>)</span></span> &#123;<br>sum = num1 + num2<br>sub = num1 - num2<br><span class="hljs-keyword">return</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-包"><a href="#2-包" class="headerlink" title="2. 包"></a>2. 包</h3><ol><li><p>package 进行包的声明<br>建议：包的声明和所在的文件夹同名</p></li><li><p>main 包是程序的入口包<br>main 函数一定要放在 main 包下，否则不能编译执行</p></li><li><p>包的引入<br>语法：import  “包的路径”<br>包名是从 $GOPATH/src/ 后开始的，使用 / 进行路径分隔。<br>【注：未开启 go modules 的情况下】</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211230161703.png"></p></li><li><p>包名和文件夹的名字，可以不一样，建议一致</p><p> <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211230162839.png"> </p></li><li><p>一个目录下只能声明一个 package，所以一个目录下不能有重复的函数</p></li><li><p>可以给包取别名，取别名后，原来的包名就不能使用了</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211230163246.png"></p></li></ol><h3 id="3-init函数"><a href="#3-init函数" class="headerlink" title="3. init函数"></a>3. init函数</h3><p> 初始化函数，可以用来进行一些初始化的操作</p><p>每一个源文件都可以包含一个 init 函数，该函数会在 main 函数执行前，被 Go 运行框架调用。</p><p>全局变量定义，init 函数，main 函数的执行流程：</p><p>全局变量 –&gt; init 函数 –&gt; main 函数</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> global <span class="hljs-keyword">int</span> = get()<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">get</span><span class="hljs-params">()</span> <span class="hljs-title">int</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;get....&quot;</span>)<br><span class="hljs-keyword">return</span> <span class="hljs-number">100</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;init....&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;main......&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211230174442.png"></p><p>多个源文件都有init函数的时候，如何执行：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211230174547.png"></p><h4 id="4-匿名函数"><a href="#4-匿名函数" class="headerlink" title="4. 匿名函数"></a>4. 匿名函数</h4><p>匿名函数使用方式：</p><ol><li>在定义匿名函数时就直接调用，这种方式匿名函数只能调用一次</li></ol> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"> <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>result := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> num1 + num2<br>&#125;(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br><br>fmt.Println(result)<br>&#125;<br></code></pre></td></tr></table></figure><ol start="2"><li>将匿名函数赋给一个变量，再通过该变量来调用匿名函数</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>add := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">return</span> num1 + num2<br>&#125;<br>fmt.Println(add(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>))<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-闭包"><a href="#5-闭包" class="headerlink" title="5. 闭包"></a>5. 闭包</h4><p>闭包就是一个函数和与其相关的引用环境组合的一个整体</p><p>闭包的本质：闭包本质依旧是一个匿名函数，只是这个函数引入外界的变量/参数<br>匿名函数 + 引用的变量/参数 = 闭包</p><p>（ 当一个函数的返回值是另外一个函数，而返回的这个函数如果调用了其父函数内部的变量，且返回的这个函数在外部被执行，就产生了闭包。闭包是一个环境，具体指的就是外部函数–高阶函数。）</p><p>特点：</p><ol><li>返回的是一个匿名函数，但是这个匿名函数引用到函数外的变量/参数 ,因此这个匿名函数就和变量/参数形成一个整体，构成闭包。</li><li>闭包中使用的变量/参数会一直保存在内存中</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getSum</span><span class="hljs-params">()</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">var</span> sum <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>sum = sum + num<br><span class="hljs-keyword">return</span> sum<br>&#125;<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>f := getSum()<br>fmt.Println(f(<span class="hljs-number">1</span>)) <span class="hljs-comment">// 1</span><br>fmt.Println(f(<span class="hljs-number">2</span>)) <span class="hljs-comment">// 3</span><br>fmt.Println(f(<span class="hljs-number">3</span>)) <span class="hljs-comment">// 6</span><br>&#125;<br></code></pre></td></tr></table></figure><p>用处：</p><ol><li>读取函数内部的变量</li><li>这些变量的值始终保持在内存中，不会在外层函数调用后被自动清除</li></ol><p>优点：</p><ol><li>变量长期驻扎在内存中</li><li>避免全局变量的污染</li></ol><p>缺点：</p><ol><li>常驻内存 会增大内存的使用量</li></ol><h3 id="5-defer关键字"><a href="#5-defer关键字" class="headerlink" title="5. defer关键字"></a>5. defer关键字</h3><p>defer提供延迟机制，会将要延迟执行的方法“压栈”，当 defer 被触发时，将所有“压栈”的方法“出栈”并执行。</p><p>defer 的执行时机：</p><ol><li>包裹 defer 的函数返回时</li><li>包裹 defer 的函数执行到末尾时</li><li>所在的 goroutine 发生 panic 时</li></ol><p>【注】调用 os.Exit() 方法退出程序时，不会执行</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getSum</span><span class="hljs-params">(num1 <span class="hljs-keyword">int</span>, num2 <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;num1：&quot;</span>, num1)<br><span class="hljs-keyword">defer</span> fmt.Println(<span class="hljs-string">&quot;num2：&quot;</span>, num2)<br><br>sum := num1 + num2<br>fmt.Println(<span class="hljs-string">&quot;sum：&quot;</span>, sum)<br><br><span class="hljs-keyword">return</span> sum<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>getSum(<span class="hljs-number">10</span>, <span class="hljs-number">20</span>)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-系统函数"><a href="#6-系统函数" class="headerlink" title="6. 系统函数"></a>6. 系统函数</h3><h4 id="6-1-内置函数"><a href="#6-1-内置函数" class="headerlink" title="6.1 内置函数"></a>6.1 内置函数</h4><p>new 函数：<br>分配内存，主要用来分配值类型（int系列, float系列, bool, string、数组和结构体 struct）</p><p>func new(Type) *Type<br>其第一个实参为类型，而非值。其返回值为指向该类型的新分配的零值的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>num := <span class="hljs-built_in">new</span>(<span class="hljs-keyword">int</span>)<br>fmt.Printf(<span class="hljs-string">&quot;num 的类型：%T，num 的值：%v，num 的地址：%v， num 指针指向的值: %v&quot;</span>, num, num, &amp;num, *num)<br><span class="hljs-comment">//num 的类型：*int，num 的值：0xc0000a6058，num 的地址：0xc0000d2018， num 指针指向的值: 0</span><br>&#125;<br></code></pre></td></tr></table></figure><p>make函数:<br>func make(Type, size IntegerType) Type</p><p>make分配并初始化一个类型为切片、映射、或通道的对象。其第一个实参为类型，而非值。make的返回类型与其参数相同，而非指向它的指针。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>demo := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">10</span>)<br>fmt.Println( demo)<br><span class="hljs-comment">// [0 0 0 0 0 0 0 0 0 0]</span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="6-1-字符串相关函数"><a href="#6-1-字符串相关函数" class="headerlink" title="6.1 字符串相关函数"></a>6.1 字符串相关函数</h4><ol><li><p>字符串转整数<br>n, err := strconv.Atoi(“66”)</p></li><li><p>整数转字符串<br>str := strconv.Itoa(6887)</p></li><li><p>不区分大小写比较字符串是否相同<br>func EqualFold(s, t string) bool</p></li><li><p>判断 s 是否有前缀字符串 prefix<br>func HasPrefix(s, prefix string) bool</p></li><li><p>判断 s 是否有后缀字符串 suffix<br>func HasSuffix(s, suffix string) bool</p></li><li><p>判断字符串 s 是否包含子串 substr<br>func Contains(s, substr string) bool</p></li><li><p>返回字符串 s 中有几个不重复的 sep 子串<br>func Count(s, sep string) int</p></li><li><p>子串 sep 在字符串s中第一次出现的位置，不存在则返回-1<br>func Index(s, sep string) int</p></li><li><p>子串 sep 在字符串 s 中最后一次出现的位置，不存在则返回-1<br>func LastIndex(s, sep string) int</p></li><li><p>将所有字母都转为对应的小写<br>func ToLower(s string) string</p></li><li><p>将所有字母都转为对应的大写<br>func ToUpper(s string) string</p></li><li><p>返回 count 个 s 串联的字符串。<br>func Repeat(s string, count int) string</p></li><li><p>将 s 中前 n 个不重叠 old 子串都替换为 new 的新字符串<br>func Replace(s, old, new string, n int) string</p></li><li><p>将 s 前后端所有 cutset  去掉<br>func Trim(s string, cutset string) string</p></li><li><p>将 s 前后端所有空白都去掉<br>func TrimSpace(s string) string</p></li><li><p>用去掉 s 中出现的 sep 的方式进行分割，返回生成的所有片段组成的切片<br>func Split(s, sep string) []string<br>每一个 sep 都会进行一次切割，即使两个 sep 相邻，也会进行两次切割。</p></li></ol><h4 id="6-2-时间相关函数"><a href="#6-2-时间相关函数" class="headerlink" title="6.2 时间相关函数"></a>6.2 时间相关函数</h4><p>时间和日期的函数在 time 包，time.Now() 返回当前时间。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>now := time.Now()<br>fmt.Printf(<span class="hljs-string">&quot;%v ~~~ 对应的类型为：%T\n&quot;</span>, now, now)<br><span class="hljs-comment">// 2021-12-30 19:36:01.1827252 +0800 CST m=+0.003000101 ~~~ 对应的类型为：time.Time</span><br><br><span class="hljs-comment">// 当前时间戳</span><br>fmt.Println(now.Unix())<br><span class="hljs-comment">// 纳秒级时间戳</span><br>fmt.Println(now.UnixNano())<br><span class="hljs-comment">// 时间戳小数部分 单位：纳秒</span><br>fmt.Println(now.Nanosecond())<br><br><span class="hljs-comment">//调用结构体中的方法：</span><br>fmt.Printf(<span class="hljs-string">&quot;年：%v \n&quot;</span>, now.Year())<br>fmt.Printf(<span class="hljs-string">&quot;月：%v \n&quot;</span>, now.Month())      <span class="hljs-comment">//月：February</span><br>fmt.Printf(<span class="hljs-string">&quot;月：%v \n&quot;</span>, <span class="hljs-keyword">int</span>(now.Month())) <span class="hljs-comment">//月：2</span><br>fmt.Printf(<span class="hljs-string">&quot;日：%v \n&quot;</span>, now.Day())<br>fmt.Printf(<span class="hljs-string">&quot;时：%v \n&quot;</span>, now.Hour())<br>fmt.Printf(<span class="hljs-string">&quot;分：%v \n&quot;</span>, now.Minute())<br>fmt.Printf(<span class="hljs-string">&quot;秒：%v \n&quot;</span>, now.Second())<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>根据指定时间返回 time.Time</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>now := time.Now()<br>layout := <span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span><br><br><span class="hljs-comment">//根据指定时间返回 time.Time 类型</span><br><span class="hljs-comment">//分别指定年，月，日，时，分，秒，纳秒，时区</span><br>t := time.Date(<span class="hljs-number">2011</span>, time.Month(<span class="hljs-number">3</span>), <span class="hljs-number">12</span>, <span class="hljs-number">15</span>, <span class="hljs-number">30</span>, <span class="hljs-number">20</span>, <span class="hljs-number">0</span>, now.Location())<br>fmt.Println(t.Format(layout))<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>日期字符串解析成 time.Time</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>t, _ := time.ParseInLocation(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>, time.Now().Format(<span class="hljs-string">&quot;2006-01-02 15:04:05&quot;</span>), time.Local)<br>fmt.Println(t)<br><span class="hljs-comment">// 2021-12-30 19:54:31 +0800 CST</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211230195731.png"></p><p><strong>日期的格式化</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>now := time.Now()<br><br>fmt.Println( now.Format(<span class="hljs-string">&quot;2006/01/02 15/04/05&quot;</span>))<br><span class="hljs-comment">// 2021/12/30 19/46/44</span><br><br>fmt.Println(now.Format(<span class="hljs-string">&quot;2006 15:04&quot;</span>))<br><span class="hljs-comment">//2021 19:46</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>计算、比较日期</strong></p><p>0-24小时之内的时间计算:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br><br><span class="hljs-comment">// 1小时1分1s之后</span><br>t1, _ := time.ParseDuration(<span class="hljs-string">&quot;1h1m1s&quot;</span>)<br>m1 := now.Add(t1)<br>fmt.Println(m1)<br><br><span class="hljs-comment">// 1小时1分1s之前</span><br>t2, _ := time.ParseDuration(<span class="hljs-string">&quot;-1h1m1s&quot;</span>)<br>m2 := now.Add(t2)<br>fmt.Println(m2)<br><br><span class="hljs-comment">// 3小时之前</span><br>t3, _ := time.ParseDuration(<span class="hljs-string">&quot;-1h&quot;</span>)<br>m3 := now.Add(t3 * <span class="hljs-number">3</span>)<br>fmt.Println(m3)<br><br><span class="hljs-comment">// 10 分钟之后</span><br>t4, _ := time.ParseDuration(<span class="hljs-string">&quot;10m&quot;</span>)<br>m4 := now.Add(t4)<br>fmt.Println(m4)<br><br><span class="hljs-comment">// Sub 计算两个时间差</span><br>sub1 := now.Sub(m3)<br>fmt.Println(sub1.Hours())   <span class="hljs-comment">// 相差小时数</span><br>fmt.Println(sub1.Minutes()) <span class="hljs-comment">// 相差分钟数</span><br><br><br><br><span class="hljs-comment">// 返回当前时间与 t 的时间差，返回值是 Duration</span><br><span class="hljs-comment">// time.Since(t Time) Duration</span><br><br><span class="hljs-comment">// 返回 t 与当前时间的时间差，返回值是 Duration</span><br><span class="hljs-comment">// time.Until(t Time) Duration</span><br><br><br>t5, _ := time.ParseDuration(<span class="hljs-string">&quot;-1h&quot;</span>)<br>m5 := now.Add(t5)<br><br>fmt.Println(time.Since(m5))<br>fmt.Println(time.Until(m5))<br>&#125;<br><br><br></code></pre></td></tr></table></figure><p>1-24小时之外的时间计算</p><p>func (t Time) AddDate(years int, months int, days int) Time</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br>fmt.Println(now)<br><span class="hljs-comment">// 一年一个月零一天 </span><br>m1 := now.AddDate(<span class="hljs-number">1</span>,<span class="hljs-number">1</span>,<span class="hljs-number">1</span>)<br>fmt.Println(m1)<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>日期比较</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>now := time.Now()<br><br><span class="hljs-comment">// 1小时之后</span><br>t1, _ := time.ParseDuration(<span class="hljs-string">&quot;1h&quot;</span>)<br>m1 := now.Add(t1)<br><br>fmt.Println(m1.After(now))  <span class="hljs-comment">// true</span><br>fmt.Println(now.Before(m1))<span class="hljs-comment">// true</span><br>fmt.Println(now.Equal(m1))<span class="hljs-comment">// false</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——流程控制</title>
    <link href="/2021/12/29/Go%E2%80%94%E2%80%94%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
    <url>/2021/12/29/Go%E2%80%94%E2%80%94%E6%B5%81%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h3 id="1-分支结构"><a href="#1-分支结构" class="headerlink" title="1. 分支结构"></a>1. 分支结构</h3><h4 id="1-1-if-分支"><a href="#1-1-if-分支" class="headerlink" title="1.1 if 分支"></a>1.1 if 分支</h4><p><strong>基本语法：</strong></p><p>if  条件表达式1 {<br>    　逻辑代码1<br>} else if　条件表达式2 {<br>   　逻辑代码2<br>}<br>…….<br>else {<br>  　逻辑代码n<br>}</p><blockquote><ul><li>条件表达式左右的 () 可以不写，也建议不写。</li><li>if 和表达式中间，一定要有空格。</li><li>{} 是必须有的，即使逻辑代码只有一行。</li><li>else 和上一个代码块结束的 { 必须在同一行，不能换行</li></ul></blockquote><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211229113906.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> score = <span class="hljs-number">80</span><br><br><span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">90</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;A&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">80</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;B&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">70</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;C&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> score &gt;= <span class="hljs-number">60</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;D&quot;</span>)<br>&#125; <span class="hljs-keyword">else</span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;E&quot;</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-switch-分支"><a href="#1-2-switch-分支" class="headerlink" title="1.2 switch 分支"></a>1.2 switch 分支</h4><p><strong>基本语法：</strong></p><p>switch 表达式 {<br>　case 值1,值2,.….<strong>:</strong><br>　　　语句块1<br>　case 值3,值4,…<strong>:</strong><br>　　　语句块2<br>　 ….<br>　default <strong>:</strong><br>　　　 语句块<br>}</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> score <span class="hljs-keyword">int</span> = <span class="hljs-number">89</span><br><br><span class="hljs-keyword">switch</span> score / <span class="hljs-number">10</span> &#123;<br><span class="hljs-keyword">case</span> <span class="hljs-number">10</span>, <span class="hljs-number">9</span>:<br>fmt.Println(<span class="hljs-string">&quot;A&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">8</span>:<br>fmt.Println(<span class="hljs-string">&quot;B&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">7</span>:<br>fmt.Println(<span class="hljs-string">&quot;C&quot;</span>)<br><span class="hljs-keyword">case</span> <span class="hljs-number">6</span>:<br>fmt.Println(<span class="hljs-string">&quot;D&quot;</span>)<br><span class="hljs-keyword">default</span>:<br>fmt.Println(<span class="hljs-string">&quot;E&quot;</span>)<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><ol><li>switch 后是一个表达式（即:常量值、变量、一个有返回值的函数等）</li><li>case 后面的值如果是常量值(字面量)，则要求不能重复</li></ol><p>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211229123557.png"></p><p>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211229123520.png"></p><ol start="3"><li>case 后的各个值的数据类型，必须和 switch 的表达式数据类型一致</li><li>case 后面可以带多个值，使用逗号间隔</li><li>case 后面不需要带 break ，默认不穿透</li><li>default 语句不是必须的，位置也是随意的<br>(所有 case 不匹配才执行)<img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211229124313.png"></li><li>switch 后也可以不带表达式，当做 if 分支来使用<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> score <span class="hljs-keyword">int</span> = <span class="hljs-number">69</span><br><br><span class="hljs-keyword">switch</span> &#123;<br><span class="hljs-keyword">case</span> score &gt;= <span class="hljs-number">60</span>:<br>fmt.Println(<span class="hljs-string">&quot;及格&quot;</span>)<br><span class="hljs-keyword">case</span> score &lt; <span class="hljs-number">60</span>:<br>fmt.Println(<span class="hljs-string">&quot;不及格&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></li><li>利用 fallthrough 关键字进行 switch 穿透，继续执行下一个case</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211229125520.png"></p><p><font color="red"><strong>java 中的 switch：</strong></font></p><blockquote><p> case 标签必须为字符串常量或字面量。<br>支持的类型：</p><blockquote><p>Java5 以前，只支持 byte，short，char，int 类型<br>Java5 引入了枚举类型和 byte，short，char，int 的包装类<br>从Java7开始，支持 String 类型</p></blockquote></blockquote><p>（byte、short、char 类型可以在不损失精度的情况下向上转型成int类型。枚举类型的支持是因为枚举类有一个 ordinal 方法,该方法返回一个 int 类型的值。支持 String 是利用 String 的 hash 值，本质上也是 switch-int 结构，并且通过 equals 方法来防止 hash 冲突，用 switch-byte 结构精确匹配。)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        <span class="hljs-keyword">switch</span> (<span class="hljs-string">&quot;A&quot;</span>) &#123;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;A&quot;</span> :<br>                System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>            <span class="hljs-keyword">case</span> <span class="hljs-string">&quot;B&quot;</span> :<br>                System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<br>                <span class="hljs-keyword">break</span>;<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>反编译结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Test</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Test</span><span class="hljs-params">()</span> </span>&#123;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] var0)</span> </span>&#123;<br>        String var1 = <span class="hljs-string">&quot;A&quot;</span>;<br>        <span class="hljs-keyword">byte</span> var2 = -<span class="hljs-number">1</span>;<br>        <span class="hljs-keyword">switch</span>(var1.hashCode()) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">65</span>:<br>            <span class="hljs-keyword">if</span> (var1.equals(<span class="hljs-string">&quot;A&quot;</span>)) &#123;<br>                var2 = <span class="hljs-number">0</span>;<br>            &#125;<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">66</span>:<br>            <span class="hljs-keyword">if</span> (var1.equals(<span class="hljs-string">&quot;B&quot;</span>)) &#123;<br>                var2 = <span class="hljs-number">1</span>;<br>            &#125;<br>        &#125;<br><br>        <span class="hljs-keyword">switch</span>(var2) &#123;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>:<br>            System.out.println(<span class="hljs-string">&quot;A&quot;</span>);<br>            <span class="hljs-keyword">break</span>;<br>        <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>:<br>            System.out.println(<span class="hljs-string">&quot;B&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-循环结构"><a href="#2-循环结构" class="headerlink" title="2. 循环结构"></a>2. 循环结构</h3><p>Go 语言中只有 for 循环。</p><h4 id="2-1-基本格式"><a href="#2-1-基本格式" class="headerlink" title="2.1 基本格式"></a>2.1 基本格式</h4><p>for init; condition; post { }<br>for condition { }<br>for { }</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> sum <span class="hljs-keyword">int</span> = <span class="hljs-number">0</span><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">1</span>; i &lt;= <span class="hljs-number">5</span>; i++ &#123;<br>sum += i<br>&#125;<br><br>index := <span class="hljs-number">5</span><br><span class="hljs-keyword">for</span> index &gt; <span class="hljs-number">0</span> &#123;<br>fmt.Println(index)<br>index--<br>&#125;<br><br>index = <span class="hljs-number">5</span><br><span class="hljs-keyword">for</span> &#123;<br><span class="hljs-keyword">if</span> index &lt; <span class="hljs-number">0</span> &#123;<br><span class="hljs-keyword">break</span><br>&#125;<br>fmt.Println(index)<br>index--<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-循环控制关键字"><a href="#2-2-循环控制关键字" class="headerlink" title="2.2 循环控制关键字"></a>2.2 循环控制关键字</h4><table><thead><tr><th align="center">控制语句</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">break</td><td align="center">经常用于中断当前 for 循环或跳出 switch 语句</td></tr><tr><td align="center">continue</td><td align="center">跳过当前循环的剩余语句，然后继续进行下一轮循环</td></tr><tr><td align="center">goto</td><td align="center">将控制转移到被标记的语句</td></tr></tbody></table><p>以上关键字均支持标签。<br>（语法和 java 相同）</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>label:<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">5</span>; i++ &#123;<br><span class="hljs-keyword">for</span> j := <span class="hljs-number">0</span>; j &lt; <span class="hljs-number">3</span>; j++ &#123;<br><span class="hljs-keyword">if</span> j == <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">continue</span> label<br>&#125;<br>fmt.Printf(<span class="hljs-string">&quot;%d --- %d \n&quot;</span>, i, j)<br>&#125;<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-4-for-range"><a href="#2-4-for-range" class="headerlink" title="2.4 for range"></a>2.4 for range</h4><p>for range 可以遍历数组、切片、字符串、map 及通道，for range 语法上类似于其它 java 中的 foreach 语句，一般形式为：</p><p>for key, val := range coll {<br>　　…<br>}</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>strings := []<span class="hljs-keyword">string</span>&#123;<span class="hljs-string">&quot;hello&quot;</span>, <span class="hljs-string">&quot;world&quot;</span>&#125;<br><span class="hljs-keyword">for</span> i, s := <span class="hljs-keyword">range</span> strings &#123;<br>fmt.Println(i, s)<br>&#125;<br><br><span class="hljs-keyword">var</span> str <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;hello 张三&quot;</span><br><span class="hljs-keyword">for</span> i, value := <span class="hljs-keyword">range</span> str &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%d &lt;====&gt; %c \n&quot;</span>, i, value)<br>&#125;<br><br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211229181327.png"></p><p>字符串遍历的另一种方式：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br>str := <span class="hljs-string">&quot;hello 张三&quot;</span><br>r := []<span class="hljs-keyword">rune</span>(str)<br><br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; <span class="hljs-built_in">len</span>(r); i++ &#123;<br>fmt.Printf(<span class="hljs-string">&quot;%c &quot;</span>, r[i])<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——运算符</title>
    <link href="/2021/12/28/Go%E2%80%94%E2%80%94%E8%BF%90%E7%AE%97%E7%AC%A6/"/>
    <url>/2021/12/28/Go%E2%80%94%E2%80%94%E8%BF%90%E7%AE%97%E7%AC%A6/</url>
    
    <content type="html"><![CDATA[<p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211228223837.png"></p><h3 id="1-算术运算符"><a href="#1-算术运算符" class="headerlink" title="1. 算术运算符"></a>1. 算术运算符</h3><p>算术运算符包括： + ，-，*，/，%，++，–</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">//+加号：</span><br><span class="hljs-comment">//1.正数 2.相加操作  3.字符串拼接</span><br><span class="hljs-keyword">var</span> n1 <span class="hljs-keyword">int</span> = +<span class="hljs-number">10</span><br>fmt.Println(n1)<br><span class="hljs-keyword">var</span> n2 <span class="hljs-keyword">int</span> = <span class="hljs-number">4</span> + <span class="hljs-number">7</span><br>fmt.Println(n2)<br><span class="hljs-keyword">var</span> s1 <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span><br>fmt.Println(s1)<br><br><span class="hljs-comment">// /除号：</span><br>fmt.Println(<span class="hljs-number">10</span> / <span class="hljs-number">3</span>)   <span class="hljs-comment">//两个int类型数据运算，结果一定为整数类型</span><br>fmt.Println(<span class="hljs-number">10.0</span> / <span class="hljs-number">3</span>) <span class="hljs-comment">//浮点类型参与运算，结果为浮点类型</span><br><br><span class="hljs-comment">// % 取模</span><br>fmt.Println(<span class="hljs-number">10</span> % <span class="hljs-number">-3</span>) <span class="hljs-comment">// 1</span><br><span class="hljs-comment">//++自增操作：</span><br><span class="hljs-keyword">var</span> a <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><br>a++<br>a--<br><span class="hljs-comment">//++ 自增 加1操作，--自减，减1操作</span><br><span class="hljs-comment">// 只能单独使用，不能参与到运算中去</span><br><span class="hljs-comment">// ++，--只能在变量的后面</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-赋值运算符"><a href="#2-赋值运算符" class="headerlink" title="2. 赋值运算符"></a>2. 赋值运算符</h3><p>赋值运算符包括=,+=，-=，*=，/=,%=</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> num1 <span class="hljs-keyword">int</span> = (<span class="hljs-number">10</span> + <span class="hljs-number">20</span>) % <span class="hljs-number">3</span><br>num1 += <span class="hljs-number">20</span><br>fmt.Println(num1) <span class="hljs-comment">// 20</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-关系运算符"><a href="#3-关系运算符" class="headerlink" title="3. 关系运算符"></a>3. 关系运算符</h3><p>关系运算符包括：==、!=、&gt;、&lt;、&gt; =、&lt;=</p><h3 id="4-逻辑运算符"><a href="#4-逻辑运算符" class="headerlink" title="4. 逻辑运算符"></a>4. 逻辑运算符</h3><p>逻辑运算符：&amp;&amp;(逻辑与/短路与)，||（逻辑或/短路或），!（逻辑非）</p><p>【注】&amp; 不能作为逻辑运算</p><h3 id="5-位运算符"><a href="#5-位运算符" class="headerlink" title="5. 位运算符"></a>5. 位运算符</h3><table><thead><tr><th align="center">运算符</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">&amp;</td><td align="center">按位与</td></tr><tr><td align="center">|</td><td align="center">按位或</td></tr><tr><td align="center">^</td><td align="center">按位异或</td></tr><tr><td align="center">&lt;&lt;</td><td align="center">左移运算符（高位丢弃，低位补0）</td></tr><tr><td align="center">&gt;&gt;</td><td align="center">右移运算符</td></tr></tbody></table><p>【注】没有无符号右移</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-keyword">var</span> c <span class="hljs-keyword">int8</span> = <span class="hljs-number">127</span><br>fmt.Println(c &lt;&lt; <span class="hljs-number">1</span>) <span class="hljs-comment">// -2</span><br><br><span class="hljs-comment">// 01111111// 127</span><br><span class="hljs-comment">// 11111110// 补码</span><br><span class="hljs-comment">// 10000001// 反码</span><br><span class="hljs-comment">// 10000010// 原码</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-其他运算符"><a href="#6-其他运算符" class="headerlink" title="6. 其他运算符"></a>6. 其他运算符</h3><p>&amp; ：返回变量的存储地址<br>* ：返回针变量对应的值</p><h3 id="7-运算符优先级"><a href="#7-运算符优先级" class="headerlink" title="7. 运算符优先级"></a>7. 运算符优先级</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211228232536.png"></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——testify</title>
    <link href="/2021/12/22/Go%E2%80%94%E2%80%94testify/"/>
    <url>/2021/12/22/Go%E2%80%94%E2%80%94testify/</url>
    
    <content type="html"><![CDATA[<p>testify 扩展了 testing 标准库，断言库 assert，测试替身 mock 和测试套件 suite 等，让我们编写测试代码更容易！</p><h3 id="1-引入"><a href="#1-引入" class="headerlink" title="1. 引入"></a>1. 引入</h3><p>安装 testify 库：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs vim">$ <span class="hljs-keyword">go</span> <span class="hljs-built_in">get</span> -<span class="hljs-keyword">u</span> github.<span class="hljs-keyword">com</span>/stretchr/testify<br></code></pre></td></tr></table></figure><p>如果 go  get 失败：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs js">$ go env -w GO111MODULE=on<br>$ go env -w GOPROXY=https:<span class="hljs-comment">//goproxy.cn,direct</span><br></code></pre></td></tr></table></figure><p>estify 模块：</p><ul><li>assert</li><li>http</li><li>mock</li><li>require</li><li>suite</li></ul><h3 id="2-assert"><a href="#2-assert" class="headerlink" title="2. assert"></a>2. assert</h3><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Equal</span><span class="hljs-params">(t TestingT, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotEqual</span><span class="hljs-params">(t TestingT, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Nil</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotNil</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-comment">/* 断言object是空，根据object中存储的实际类型，空的含义不同：</span><br><span class="hljs-comment">   指针：nil；</span><br><span class="hljs-comment">   整数：0；</span><br><span class="hljs-comment">   浮点数：0.0；</span><br><span class="hljs-comment">   字符串：空串&quot;&quot;；</span><br><span class="hljs-comment">   布尔：false；</span><br><span class="hljs-comment">   切片或 channel：长度为 0。</span><br><span class="hljs-comment">*/</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Empty</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotEmpty</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NoError</span><span class="hljs-params">(t TestingT, err error, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 断言err不为nil</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Error</span><span class="hljs-params">(t TestingT, err error, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 断言err表示的 error 链中至少有一个和target匹配</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ErrorAs</span><span class="hljs-params">(t TestingT, err error, target <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 断言err的 error 链中有target</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ErrorIs</span><span class="hljs-params">(t TestingT, err, target error, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Zero</span><span class="hljs-params">(t TestingT, i <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotZero</span><span class="hljs-params">(t TestingT, i <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">True</span><span class="hljs-params">(t TestingT, value <span class="hljs-keyword">bool</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">False</span><span class="hljs-params">(t TestingT, value <span class="hljs-keyword">bool</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Len</span><span class="hljs-params">(t TestingT, object <span class="hljs-keyword">interface</span>&#123;&#125;, length <span class="hljs-keyword">int</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-comment">// 断言 s 包含 contains。其中 s 可以是字符串，数组/切片，map。相应地，contains为子串，数组/切片元素，map 的键。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Contains</span><span class="hljs-params">(t TestingT, s, contains <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotContains</span><span class="hljs-params">(t TestingT, s, contains <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Subset</span><span class="hljs-params">(t TestingT, list, subset <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(ok <span class="hljs-keyword">bool</span>)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">NotSubset</span><span class="hljs-params">(t TestingT, list, subset <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-params">(ok <span class="hljs-keyword">bool</span>)</span></span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">FileExists</span><span class="hljs-params">(t TestingT, path <span class="hljs-keyword">string</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><span class="hljs-comment">// 断言路径 path 是一个目录，如果 path 不存在或者是一个文件，断言失败。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DirExists</span><span class="hljs-params">(t TestingT, path <span class="hljs-keyword">string</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><br><span class="hljs-comment">// 断言 listA 和 listB 包含相同的元素，忽略元素出现的顺序。listA/listB 必须是数组或切片。如果有重复元素，重复元素出现的次数也必须相等。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ElementsMatch</span><span class="hljs-params">(t TestingT, listA, listB <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-comment">// 断言theError.Error()的返回值与errString相等。</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">EqualError</span><span class="hljs-params">(t TestingT, theError error, errString <span class="hljs-keyword">string</span>, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br><span class="hljs-comment">// 断言expected与actual相等，或者可以转换为相同的类型，并且相等</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">EqualValues</span><span class="hljs-params">(t TestingT, expected, actual <span class="hljs-keyword">interface</span>&#123;&#125;, msgAndArgs ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span> <span class="hljs-title">bool</span></span><br><br></code></pre></td></tr></table></figure><p><strong>示例:</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestSomething</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><br><span class="hljs-comment">//断言相等</span><br>assert.Equal(t, <span class="hljs-number">123</span>, <span class="hljs-number">123</span>, <span class="hljs-string">&quot;they should be equal&quot;</span>)<br><span class="hljs-comment">//断言不相等</span><br>assert.NotEqual(t, <span class="hljs-number">123</span>, <span class="hljs-number">456</span>, <span class="hljs-string">&quot;they should not be equal&quot;</span>)<br><br><span class="hljs-comment">//对于nil的断言</span><br>assert.Nil(t, <span class="hljs-literal">nil</span>)<br><span class="hljs-keyword">var</span> object = <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-comment">//对于非nil的断言</span><br><span class="hljs-keyword">if</span> assert.NotNil(t, object) &#123;<br>assert.Equal(t, <span class="hljs-string">&quot;hello&quot;</span>, object)<br><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>Assertions 对象</strong></p><p>上面的断言都是以 TestingT 为第一个参数，需要大量使用时比较麻烦。testify 提供了一种方便的方式。先以 * testing.T创建一个* Assertions 对象，Assertions 定义了前面所有的断言方法，只是不需要再传入TestingT参数了。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestEqual</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>  assertions := assert.New(t)<br>  assertion.Equal(a, b, <span class="hljs-string">&quot;&quot;</span>)<br>  <span class="hljs-comment">// ...</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-require"><a href="#3-require" class="headerlink" title="3. require"></a>3. require</h3><p>require提供了和assert同样的接口，但是遇到错误时，require直接终止测试，而assert返回false。</p><h3 id="4-mock"><a href="#4-mock" class="headerlink" title="4. mock"></a>4. mock</h3><p>testify 提供了对 Mock 的简单支持。Mock 简单来说就是构造一个仿对象，仿对象提供和原对象一样的接口，在测试中用仿对象来替换原对象。</p><p>待测试代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java">type User struct &#123;<br>Name string<br>Age  <span class="hljs-keyword">int</span><br>&#125;<br><br>type ICrawler <span class="hljs-class"><span class="hljs-keyword">interface</span> </span>&#123;<br>GetUserList() ([]*User, error)<br>&#125;<br><br>type MyCrawler struct &#123;<br>url string<br>&#125;<br><br>func (c *MyCrawler) GetUserList() ([]*User, error) &#123;<br>resp, err := http.Get(c.url)<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-keyword">return</span> nil, err<br>&#125;<br><br>defer resp.Body.Close()<br>data, err := ioutil.ReadAll(resp.Body)<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-keyword">return</span> nil, err<br>&#125;<br><br><span class="hljs-keyword">var</span> userList []*User<br>err = json.Unmarshal(data, &amp;userList)<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-keyword">return</span> nil, err<br>&#125;<br><br><span class="hljs-keyword">return</span> userList, nil<br>&#125;<br><br><span class="hljs-function">func <span class="hljs-title">GetAndPrintUsers</span><span class="hljs-params">(crawler ICrawler)</span> </span>&#123;<br>users, err := crawler.GetUserList()<br><span class="hljs-keyword">if</span> err != nil &#123;<br><span class="hljs-keyword">return</span><br>&#125;<br><br><span class="hljs-keyword">for</span> _, u := range users &#123;<br>fmt.Println(u)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试代码：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MockCrawler <span class="hljs-keyword">struct</span> &#123;<br>mock.Mock<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(m *MockCrawler)</span> <span class="hljs-title">GetUserList</span><span class="hljs-params">()</span> <span class="hljs-params">([]*User, error)</span></span> &#123;<br>args := m.Called()<br><span class="hljs-keyword">return</span> args.Get(<span class="hljs-number">0</span>).([]*User), args.Error(<span class="hljs-number">1</span>)<br>&#125;<br><br><span class="hljs-keyword">var</span> (<br>MockUsers []*User<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">init</span><span class="hljs-params">()</span></span> &#123;<br>MockUsers = <span class="hljs-built_in">append</span>(MockUsers, &amp;User&#123;<span class="hljs-string">&quot;dj&quot;</span>, <span class="hljs-number">18</span>&#125;)<br>MockUsers = <span class="hljs-built_in">append</span>(MockUsers, &amp;User&#123;<span class="hljs-string">&quot;zhangsan&quot;</span>, <span class="hljs-number">20</span>&#125;)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGetUserList</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>crawler := <span class="hljs-built_in">new</span>(MockCrawler)<br>crawler.On(<span class="hljs-string">&quot;GetUserList&quot;</span>).Return(MockUsers, <span class="hljs-literal">nil</span>)<br><br>GetAndPrintUsers(crawler)<br><br>crawler.AssertExpectations(t)<br>&#125;<br></code></pre></td></tr></table></figure><p>实现 GetUserList() 方法时，需要调用 Mock.Called() 方法，传入参数。Called() 会返回一个 mock.Arguments 对象，该对象中保存着返回的值。它提供了对基本类型和 error 的获取方法 Int()/String()/Bool()/Error()，和通用的获取方法 Get()，通用方法返回 interface{}，需要类型断言为具体类型，它们都接受一个表示索引的参数。</p><p>crawler.On(“GetUserList”).Return(MockUsers, nil) 是 Mock 发挥魔法的地方，这里指示调用 GetUserList() 方法的返回值分别 为MockUsers 和 nil，返回值在上面的 GetUserList() 方法中被 Arguments.Get(0) 和 Arguments.Error(1) 获取。</p><p>最后 crawler.AssertExpectations(t)对 Mock 对象做断言。</p><p>执行结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211225233426.png"></p><hr><p>使用 Mock，可以精确断言某方法以特定参数的调用次数，Times(n int)，它有两个便捷函数Once()/Twice()。下面我们要求函数Hello(n int)要以参数 1 调用 1次，参数 2 调用两次，参数 3 调用 3 次：</p><p>待测试方法:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> IExample <span class="hljs-keyword">interface</span> &#123;<br>Hello(n <span class="hljs-keyword">int</span>) <span class="hljs-keyword">int</span><br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">func</span>  <span class="hljs-title">Hello</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;Hello with %d\n&quot;</span>, n)<br><span class="hljs-keyword">return</span> n<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleFunc</span><span class="hljs-params">(e IExample)</span></span> &#123;<br><span class="hljs-keyword">for</span> n := <span class="hljs-number">1</span>; n &lt;= <span class="hljs-number">3</span>; n++ &#123;<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt;= n; i++ &#123;<br>e.Hello(n)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>测试方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MockExample <span class="hljs-keyword">struct</span> &#123;<br>mock.Mock<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(e *MockExample)</span> <span class="hljs-title">Hello</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br>args := e.Mock.Called(n)<br><span class="hljs-keyword">return</span> args.Int(<span class="hljs-number">0</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestExample</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>e := <span class="hljs-built_in">new</span>(MockExample)<br><br>e.On(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">1</span>).Return(<span class="hljs-number">1</span>).Times(<span class="hljs-number">1</span>)<br>e.On(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">2</span>).Return(<span class="hljs-number">2</span>).Times(<span class="hljs-number">2</span>)<br>e.On(<span class="hljs-string">&quot;Hello&quot;</span>, <span class="hljs-number">3</span>).Return(<span class="hljs-number">3</span>).Times(<span class="hljs-number">3</span>)<br><br>ExampleFunc(e)<br><br>e.AssertExpectations(t)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211225235248.png"></p><p>修改 ExampleFunc 将 for i := 0; i &lt;= n; i++  改为 for i := 0; i &lt; n; i++ </p><p>执行结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211225235641.png"></p><h3 id="5-suite"><a href="#5-suite" class="headerlink" title="5. suite"></a>5. suite</h3><p>testify提供了测试套件的功能（TestSuite），testify测试套件只是一个结构体，内嵌一个匿名的 suite.Suite 结构。测试套件中可以包含多个测试，它们可以共享状态，还可以定义钩子方法执行初始化和清理操作。钩子都是通过接口来定义的，实现了这些接口的测试套件结构在运行到指定节点时会调用对应的方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SetupAllSuite <span class="hljs-keyword">interface</span> &#123;<br>  SetupSuite()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果定义了SetupSuite()方法（即实现了SetupAllSuite接口），在套件中所有测试开始运行前调用这个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TearDownAllSuite <span class="hljs-keyword">interface</span> &#123;<br>  TearDownSuite()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果定义了TearDonwSuite()方法（即实现了TearDownSuite接口），在套件中所有测试运行完成后调用这个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> SetupTestSuite <span class="hljs-keyword">interface</span> &#123;<br>  SetupTest()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果定义了SetupTest()方法（即实现了SetupTestSuite接口），在套件中每个测试执行前都会调用这个方法。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> TearDownTestSuite <span class="hljs-keyword">interface</span> &#123;<br>  TearDownTest()<br>&#125;<br></code></pre></td></tr></table></figure><p>如果定义了TearDownTest()方法（即实现了TearDownTest接口），在套件中每个测试执行后都会调用这个方法。</p><p>还有一对接口BeforeTest/AfterTest，它们分别在每个测试运行前/后调用，接受套件名和测试名作为参数。</p><p><strong>示例</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MyTestSuit <span class="hljs-keyword">struct</span> &#123;<br>suite.Suite<br>testCount <span class="hljs-keyword">uint32</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">SetupSuite</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;SetupSuite&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">TearDownSuite</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;TearDownSuite&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">SetupTest</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;SetupTest test count:%d\n&quot;</span>, s.testCount)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">TearDownTest</span><span class="hljs-params">()</span></span> &#123;<br>s.testCount++<br>fmt.Printf(<span class="hljs-string">&quot;TearDownTest test count:%d\n&quot;</span>, s.testCount)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">BeforeTest</span><span class="hljs-params">(suiteName, testName <span class="hljs-keyword">string</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;BeforeTest suite:%s test:%s\n&quot;</span>, suiteName, testName)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">AfterTest</span><span class="hljs-params">(suiteName, testName <span class="hljs-keyword">string</span>)</span></span> &#123;<br>fmt.Printf(<span class="hljs-string">&quot;AfterTest suite:%s test:%s\n&quot;</span>, suiteName, testName)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">TestExample</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;TestExample1111&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MyTestSuit)</span> <span class="hljs-title">TestExample2</span><span class="hljs-params">()</span></span> &#123;<br>fmt.Println(<span class="hljs-string">&quot;TestExample2222&quot;</span>)<br>&#125;<br><br><br><span class="hljs-comment">// 为了用 go test 运行测试</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestExample</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>suite.Run(t, <span class="hljs-built_in">new</span>(MyTestSuit))<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211226005128.png"></p><h3 id="6-HTTP-测试"><a href="#6-HTTP-测试" class="headerlink" title="6. HTTP 测试"></a>6. HTTP 测试</h3><p>httptest提供了一个ResponseRecorder类型，它实现了http.ResponseWriter接口，但是它只是记录写入的状态码和响应内容，不会发送响应给客户端</p><p>一个简单的 http 服务器：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">index</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>  fmt.Fprintln(w, <span class="hljs-string">&quot;Hello World&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">greeting</span><span class="hljs-params">(w http.ResponseWriter, r *http.Request)</span></span> &#123;<br>  fmt.Fprintf(w, <span class="hljs-string">&quot;welcome, %s&quot;</span>, r.URL.Query().Get(<span class="hljs-string">&quot;name&quot;</span>))<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>  mux := http.NewServeMux()<br>  mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, index)<br>  mux.HandleFunc(<span class="hljs-string">&quot;/greeting&quot;</span>, greeting)<br><br>  server := &amp;http.Server&#123;<br>    Addr:    <span class="hljs-string">&quot;:8080&quot;</span>,<br>    Handler: mux,<br>  &#125;<br><br>  <span class="hljs-keyword">if</span> err := server.ListenAndServe(); err != <span class="hljs-literal">nil</span> &#123;<br>    log.Fatal(err)<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试1</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestIndex</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>recorder := httptest.NewRecorder()<br>request, _ := http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-literal">nil</span>)<br>mux := http.NewServeMux()<br>mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, index)<br>mux.HandleFunc(<span class="hljs-string">&quot;/greeting&quot;</span>, greeting)<br><br>mux.ServeHTTP(recorder, request)<br><br>assert.Equal(t, recorder.Code, <span class="hljs-number">200</span>, <span class="hljs-string">&quot;get index error&quot;</span>)<br>assert.Contains(t, recorder.Body.String(), <span class="hljs-string">&quot;Hello World&quot;</span>, <span class="hljs-string">&quot;body error&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGreeting</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>recorder := httptest.NewRecorder()<br>request, _ := http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/greeting&quot;</span>, <span class="hljs-literal">nil</span>)<br>request.URL.RawQuery = <span class="hljs-string">&quot;name=dj&quot;</span><br>mux := http.NewServeMux()<br>mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, index)<br>mux.HandleFunc(<span class="hljs-string">&quot;/greeting&quot;</span>, greeting)<br><br>mux.ServeHTTP(recorder, request)<br><br>assert.Equal(t, recorder.Code, <span class="hljs-number">200</span>, <span class="hljs-string">&quot;greeting error&quot;</span>)<br>assert.Contains(t, recorder.Body.String(), <span class="hljs-string">&quot;welcome, dj&quot;</span>, <span class="hljs-string">&quot;body error&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>可以使用 suite，消除 recorder/mux 等对象的创建，处理器函数的注册。</p><p><strong>测试2</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">type</span> MySuite <span class="hljs-keyword">struct</span> &#123;<br>suite.Suite<br>recorder *httptest.ResponseRecorder<br>mux      *http.ServeMux<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MySuite)</span> <span class="hljs-title">SetupSuite</span><span class="hljs-params">()</span></span> &#123;<br>s.recorder = httptest.NewRecorder()<br>s.mux = http.NewServeMux()<br>s.mux.HandleFunc(<span class="hljs-string">&quot;/&quot;</span>, index)<br>s.mux.HandleFunc(<span class="hljs-string">&quot;/greeting&quot;</span>, greeting)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MySuite)</span> <span class="hljs-title">TestIndex</span><span class="hljs-params">()</span></span> &#123;<br>request, _ := http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/&quot;</span>, <span class="hljs-literal">nil</span>)<br>s.mux.ServeHTTP(s.recorder, request)<br><br>s.Assert().Equal(s.recorder.Code, <span class="hljs-number">200</span>, <span class="hljs-string">&quot;get index error&quot;</span>)<br>s.Assert().Contains(s.recorder.Body.String(), <span class="hljs-string">&quot;Hello World&quot;</span>, <span class="hljs-string">&quot;body error&quot;</span>)<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(s *MySuite)</span> <span class="hljs-title">TestGreeting</span><span class="hljs-params">()</span></span> &#123;<br>request, _ := http.NewRequest(<span class="hljs-string">&quot;GET&quot;</span>, <span class="hljs-string">&quot;/greeting&quot;</span>, <span class="hljs-literal">nil</span>)<br>request.URL.RawQuery = <span class="hljs-string">&quot;name=dj&quot;</span><br><br>s.mux.ServeHTTP(s.recorder, request)<br><br>s.Assert().Equal(s.recorder.Code, <span class="hljs-number">200</span>, <span class="hljs-string">&quot;greeting error&quot;</span>)<br>s.Assert().Contains(s.recorder.Body.String(), <span class="hljs-string">&quot;welcome, dj&quot;</span>, <span class="hljs-string">&quot;body error&quot;</span>)<br>&#125;<br><br><span class="hljs-comment">// 测试驱动</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestHTTP</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>suite.Run(t, <span class="hljs-built_in">new</span>(MySuite))<br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://zhuanlan.zhihu.com/p/267341653">拓展</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——测试</title>
    <link href="/2021/12/20/Go%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95/"/>
    <url>/2021/12/20/Go%E2%80%94%E2%80%94%E6%B5%8B%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h3 id="1-基本测试框架"><a href="#1-基本测试框架" class="headerlink" title="1. 基本测试框架"></a>1. 基本测试框架</h3><p>在 Go 语言中，所有的测试都需要以  _test.go 结尾，这样 go build 不会去编译  _test.go 结尾的文件，而  go test 会去编译  _test.go 结尾的文件。</p><p>在编写测试的时候，会用到 testing 这个包，在这个包中，常用的类型有下面这些:</p><ul><li>testing.T（单元测试）</li><li>testing.B（基准测试）</li><li>testing.M（TestMain 测试）</li><li>testing.TB（testing.T、testing.B 公用接口）</li><li>testing.PB（Next() 接口 。 判断是否继续循环）</li></ul><p>有一类测试例外，那就是 Example 测试，主要用来在文档中输出一些测试案例，Example 测试必须以 Example 开头，方法不需要任何参数，同时要指明这个实例的输出，像下面这样：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ExampleTest</span><span class="hljs-params">()</span></span> &#123;<br> fmt.Println(<span class="hljs-string">&quot;run example test&quot;</span>)<br> <span class="hljs-comment">// Output:</span><br> <span class="hljs-comment">// run example test</span><br>&#125;<br></code></pre></td></tr></table></figure><p>所有的测试都可以通过 go test 来发起，例如，在当前包下发起测试 go test -v ./ ，-v 参数表示打印测试的过程，会把测试过程中的标准输出都打印出来。</p><h3 id="2-单元测试"><a href="#2-单元测试" class="headerlink" title="2. 单元测试"></a>2. 单元测试</h3><h4 id="2-1-语法格式："><a href="#2-1-语法格式：" class="headerlink" title="2.1 语法格式："></a>2.1 语法格式：</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestXxx</span><span class="hljs-params">(*testing.T)</span></span><br></code></pre></td></tr></table></figure><p><font color="red">注意：Xxx 可以是任何字母数字字符串，但是第一个字母不能是小写字母。</font><br>其中参数 t 用于报告测试失败和附加的日志信息。<br>testing.T的拥有的方法如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Error</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Errorf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Fail</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">FailNow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Failed</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Fatal</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Fatalf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Log</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Logf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Name</span><span class="hljs-params">()</span> <span class="hljs-title">string</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span> <span class="hljs-title">Parallel</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(t *T)</span> <span class="hljs-title">Run</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>, f <span class="hljs-keyword">func</span>(t *T)</span>) <span class="hljs-title">bool</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Skip</span><span class="hljs-params">(args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">SkipNow</span><span class="hljs-params">()</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Skipf</span><span class="hljs-params">(format <span class="hljs-keyword">string</span>, args ...<span class="hljs-keyword">interface</span>&#123;&#125;)</span></span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-params">(c *T)</span> <span class="hljs-title">Skipped</span><span class="hljs-params">()</span> <span class="hljs-title">bool</span></span><br><br></code></pre></td></tr></table></figure><ul><li>判定失败接口：<br>　　Fail 失败继续<br>　　FailNow 失败终止</li><li>打印信息接口：<br>　　Log 数据流 （cout　类似）<br>　　Logf format (printf 类似）</li><li>SkipNow 跳过当前测试</li><li>Skiped 检测是否跳过</li><li>综合接口产生：<br>　　Error / Errorf 报告出错继续 [ Log / Logf + Fail ]<br>　　Fatel / Fatelf 报告出错终止 [ Log / Logf + FailNow ]<br>　　Skip / Skipf 报告并跳过 [ Log / Logf + SkipNow ]<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getAge</span><span class="hljs-params">(IDNumber <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">int16</span></span> &#123;<br><br> strYear := IDNumber[<span class="hljs-number">6</span>:<span class="hljs-number">10</span>]<br> intYear, _ := strconv.Atoi(strYear)<br><br> <span class="hljs-keyword">return</span> <span class="hljs-keyword">int16</span>(<span class="hljs-number">2022</span> - intYear)<br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_GetAge</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br> <span class="hljs-keyword">var</span> (<br>  in       = <span class="hljs-string">&quot;610113200505189012&quot;</span><br>  expected = <span class="hljs-number">16</span><br> )<br> actual := getAge(in)<br> <span class="hljs-keyword">if</span> actual != <span class="hljs-keyword">int16</span>(expected) &#123;<br>  t.Errorf(<span class="hljs-string">&quot;Fib(%s) = %d; expected %d&quot;</span>, in, actual, expected)<br> &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li></ul><p>所有的测试都可以通过 go test 来发起，例如，在当前包下发起测试 go test -v ./ ，-v ：查看测试函数名称和运行时间</p><p>还可以在go test命令后添加 -run 参数，它对应一个正则表达式，只有函数名匹配上的测试函数才会被 go test 命令执行</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211220232747.png"></p><p>【注】：</p><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs maxima">PS D:\workspace\zth\gotest\src\gocode\main&gt; <span class="hljs-built_in">go</span> test .    <br><span class="hljs-built_in">go</span>: <span class="hljs-built_in">go</span>.<span class="hljs-built_in">mod</span> file <span class="hljs-keyword">not</span> found <span class="hljs-keyword">in</span> current <span class="hljs-built_in">directory</span> <span class="hljs-keyword">or</span> any parent <span class="hljs-built_in">directory</span>; see &#x27;<span class="hljs-built_in">go</span> help modules&#x27; <br></code></pre></td></tr></table></figure><p><strong>问题原因：</strong><br>go module 是 go 从1.13 版本开始正式推荐使用依赖管理库<br>go module 可以将某个项目(文件夹)下的所有依赖整理成一个 go.mod 文件,里面写入了依赖的版本等<br>使用go module之后我们可不用将代码放置在src下了<br>使用 go module 管理依赖后会在项目根目录下生成两个文件 go.mod 和 go.sum。</p><blockquote><p>go env -w GO111MODULE=auto<br>go mod init XXX 　//初始化Go moudle，xxx为文件夹名</p></blockquote><blockquote><p>用环境变量 GO111MODULE 开启或关闭模块支持，它有三个可选值：off、on、auto，默认值是 auto。</p><ul><li>GO111MODULE=off 　无模块支持，go 会从 GOPATH 和 vendor 文件夹寻找包。</li><li>GO111MODULE=on 　模块支持，go 会忽略 GOPATH 和 vendor 文件夹，只根据 go.mod 下载依赖。</li><li>GO111MODULE=auto 　在 $GOPATH/src 外面且根目录有 go.mod 文件时，开启模块支持。<br>在使用模块的时候，GOPATH 是无意义的，不过它还是会把下载的依赖储存在 $GOPATH/src/mod 中，也会把 go install 的结果放在$GOPATH/bin 中。</li></ul></blockquote><h4 id="2-2-Table-Driven-Test"><a href="#2-2-Table-Driven-Test" class="headerlink" title="2.2 Table-Driven Test"></a>2.2 Table-Driven Test</h4><p>采用 Table-Driven 的方式盖更多 case。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Test_GetAge2</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br><span class="hljs-keyword">var</span> ageTest = [] <span class="hljs-keyword">struct</span>&#123;<br>in       <span class="hljs-keyword">string</span><br>expected <span class="hljs-keyword">int</span><br>&#125;&#123;<br>&#123;<span class="hljs-string">&quot;610113200505189012&quot;</span>,<span class="hljs-number">16</span>&#125;,<br>&#123;<span class="hljs-string">&quot;610113202105189012&quot;</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-string">&quot;610113202005189012&quot;</span>,<span class="hljs-number">1</span>&#125;,<br>&#123;<span class="hljs-string">&quot;610113202105189012&quot;</span>,<span class="hljs-number">2</span>&#125;,<br><br><br>&#125;<br><br><span class="hljs-keyword">for</span> _,item := <span class="hljs-keyword">range</span> ageTest&#123;<br>actual := getAge(item.in)<br><span class="hljs-keyword">if</span> actual != item.expected &#123;<br>t.Errorf(<span class="hljs-string">&quot;Fib(%s) = %d; expected %d&quot;</span>, item.in, actual, item.expected)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>t.Errorf，即使其中某个 case 失败，也不会终止测试执行。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211220234619.png"></p><h4 id="2-3-Parallel-测试"><a href="#2-3-Parallel-测试" class="headerlink" title="2.3 Parallel 测试"></a>2.3 Parallel 测试</h4><p>被测试方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> (<br>data   = <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">string</span>)<br>locker sync.RWMutex<br>)<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">WriteToMap</span><span class="hljs-params">(k, v <span class="hljs-keyword">string</span>)</span></span> &#123;<br>locker.Lock()<br><span class="hljs-keyword">defer</span> locker.Unlock()<br>data[k] = v<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">ReadFromMap</span><span class="hljs-params">(k <span class="hljs-keyword">string</span>)</span> <span class="hljs-title">string</span></span> &#123;<br>locker.RLock()<br><span class="hljs-keyword">defer</span> locker.RUnlock()<br><span class="hljs-keyword">return</span> data[k]<br>&#125;<br></code></pre></td></tr></table></figure><p>单元测试方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> pairs = []<span class="hljs-keyword">struct</span> &#123;<br>k <span class="hljs-keyword">string</span><br>v <span class="hljs-keyword">string</span><br>&#125;&#123;<br>&#123;<span class="hljs-string">&quot;baidu&quot;</span>, <span class="hljs-string">&quot;百度&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;google&quot;</span>, <span class="hljs-string">&quot;谷歌&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;jd&quot;</span>, <span class="hljs-string">&quot;京东&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;taobao&quot;</span>, <span class="hljs-string">&quot;淘宝&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;tianmao&quot;</span>, <span class="hljs-string">&quot;天猫&quot;</span>&#125;,<br>&#123;<span class="hljs-string">&quot;meituan&quot;</span>, <span class="hljs-string">&quot;美团&quot;</span>&#125;,<br>&#125;<br><br><span class="hljs-comment">// 注意 TestWriteToMap 需要在 TestReadFromMap 之前</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestWriteToMap</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>t.Parallel()<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> pairs &#123;<br>time.Sleep(time.Duration(<span class="hljs-number">1</span>)*time.Second)<br>WriteToMap(tt.k, tt.v)<br>&#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestReadFromMap</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>t.Parallel()<br><span class="hljs-keyword">for</span> _, tt := <span class="hljs-keyword">range</span> pairs &#123;<br>time.Sleep(time.Duration(<span class="hljs-number">1</span>)*time.Second)<br>actual := ReadFromMap(tt.k)<br><span class="hljs-keyword">if</span> actual != tt.v &#123;<br>t.Errorf(<span class="hljs-string">&quot;the value of key(%s) is %s, expected: %s&quot;</span>, tt.k, actual, tt.v)<br>&#125;<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211221234812.png"></p><p>如果注释掉 WriteToMap 和 ReadFromMap 中 locker 保护的代码，执行测试，测试失败。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211222000146.png"></p><h4 id="2-4-testing-的变量"><a href="#2-4-testing-的变量" class="headerlink" title="2.4 testing 的变量"></a>2.4 testing 的变量</h4><ul><li>test.short : 一个快速测试的标记，在测试用例中可以使用 testing.Short() 来绕开一些测试</li><li>test.outputdir : 输出目录</li><li>test.coverprofile : 测试覆盖率参数，指定输出文件</li><li>test.run : 指定正则来运行某个 / 某些测试用例</li><li>test.memprofile : 内存分析参数，指定输出文件</li><li>test.memprofilerate : 内存分析参数，内存分析的抽样率</li><li>test.cpuprofile : cpu 分析输出参数，为空则不做 cpu 分析</li><li>test.blockprofile : 阻塞事件的分析参数，指定输出文件</li><li>test.blockprofilerate : 阻塞事件的分析参数，指定抽样频率</li><li>test.timeout : 超时时间</li><li>test.cpu : 指定 cpu 数量</li><li>test.parallel : 指定运行测试用例的并行数</li></ul><p>测试覆盖率：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211221235659.png"></p><p>将覆盖率相关的信息输出到文件：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211222000959.png"></p><h3 id="3-基准测试"><a href="#3-基准测试" class="headerlink" title="3. 基准测试"></a>3. 基准测试</h3><h4 id="3-1-基本格式"><a href="#3-1-基本格式" class="headerlink" title="3.1 基本格式"></a>3.1 基本格式</h4><p>在 _test.go 结尾的测试文件中，基准测试函数形式如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkXxx</span><span class="hljs-params">(*testing.B)</span></span><br></code></pre></td></tr></table></figure><p>通过 go test 命令，加上 -bench （匹配需要执行的函数）标志来执行。多个基准测试按照顺序运行。</p><p>待测试函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">Fib</span><span class="hljs-params">(n <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> &#123;<br><span class="hljs-keyword">if</span> n &lt; <span class="hljs-number">2</span> &#123;<br><span class="hljs-keyword">return</span> n<br>&#125;<br><span class="hljs-keyword">return</span> Fib(n<span class="hljs-number">-1</span>) + Fib(n<span class="hljs-number">-2</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>基准测试函数：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkFib10</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-keyword">for</span> n := <span class="hljs-number">0</span>; n &lt; b.N; n++ &#123;<br>Fib(<span class="hljs-number">10</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/1%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211222154956.png"></p><h4 id="3-2-计时方法"><a href="#3-2-计时方法" class="headerlink" title="3.2 计时方法"></a>3.2 计时方法</h4><ol><li>StartTimer：开始对测试进行计时。该方法会在基准测试开始时自动被调用，也可以在调用 StopTimer 之后恢复计时；</li><li>StopTimer：停止对测试进行计时。当需要执行一些复杂的初始化操作，并且不想对这些操作进行测量时，就可以使用这个方法来暂时地停止计时；</li><li>ResetTimer：对已经逝去的基准测试时间以及内存分配计数器进行清零。对于正在运行中的计时器，不会产生任何效果。</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkFibReset</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br><span class="hljs-comment">// 长耗时配置等</span><br>time.Sleep(time.Duration(<span class="hljs-number">2</span>)*time.Second)<br>b.ResetTimer()<br><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &lt; b.N; i++ &#123;<br>Fib(<span class="hljs-number">10</span>)<br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>  <img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/2%E5%BE%AE%E4%BF%A1%E6%88%AA%E5%9B%BE_20211222161446.png"></p><h4 id="3-3-内存统计"><a href="#3-3-内存统计" class="headerlink" title="3.3  内存统计"></a>3.3  内存统计</h4><p>  ReportAllocs 方法用于打开当前基准测试的内存统计功能， 与 go test 使用 -benchmem 标志类似，但 ReportAllocs 只影响那些调用了该函数的基准测试。<br>  <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go">  <span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">BenchmarkFib10Para</span><span class="hljs-params">(b *testing.B)</span></span> &#123;<br>b.ReportAllocs()<br>templ := template.Must(template.New(<span class="hljs-string">&quot;test&quot;</span>).Parse(<span class="hljs-string">&quot;Hello, &#123;&#123;.&#125;&#125;!&quot;</span>))<br>b.RunParallel(<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(pb *testing.PB)</span></span> &#123;<br><span class="hljs-comment">// Each goroutine has its own bytes.Buffer.</span><br><span class="hljs-keyword">var</span> buf bytes.Buffer<br><span class="hljs-keyword">for</span> pb.Next() &#123;<br><span class="hljs-comment">// The loop body is executed b.N times total across all goroutines.</span><br>buf.Reset()<br>templ.Execute(&amp;buf, <span class="hljs-string">&quot;World&quot;</span>)<br>&#125;<br>&#125;)<br><br>&#125;<br></code></pre></td></tr></table></figure><br><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211222222227.png"></p><h3 id="4-子测试与子基准测试"><a href="#4-子测试与子基准测试" class="headerlink" title="4.  子测试与子基准测试"></a>4.  子测试与子基准测试</h3><p>T 和 B 的 Run 方法允许定义子单元测试和子基准测试，而不必为它们单独定义函数。这便于创建基于 Table-Driven 的基准测试和层级测试。它还提供了一种共享通用 setup 和 tear-down 代码的方法：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestFoo</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-comment">// &lt;setup code&gt;</span><br>    t.Run(<span class="hljs-string">&quot;A=1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123; ... &#125;)<br>    t.Run(<span class="hljs-string">&quot;A=2&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123; ... &#125;)<br>    t.Run(<span class="hljs-string">&quot;B=1&quot;</span>, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123; ... &#125;)<br>    <span class="hljs-comment">// &lt;tear-down code&gt;</span><br>&#125;<br></code></pre></td></tr></table></figure><p>每个子测试和子基准测试都有一个唯一的名称：由顶层测试的名称与传递给 Run 的名称组成，以斜杠分隔，并具有可选的尾随序列号，用于消除歧义。</p><p>命令行标志 -run 和 -bench 的参数是非固定的正则表达式，用于匹配测试名称。对于由斜杠分隔的测试名称，例如子测试的名称，它名称本身即可作为参数，依次匹配由斜杠分隔的每部分名称。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs js">go test -run <span class="hljs-string">&#x27;&#x27;</span>      # 执行所有测试。<br>go test -run Foo     # 执行匹配 <span class="hljs-string">&quot;Foo&quot;</span> 的顶层测试，例如 <span class="hljs-string">&quot;TestFooBar&quot;</span>。<br>go test -run Foo/A=  # 对于匹配 <span class="hljs-string">&quot;Foo&quot;</span> 的顶层测试，执行其匹配 <span class="hljs-string">&quot;A=&quot;</span> 的子测试。<br>go test -run /A=<span class="hljs-number">1</span>    # 执行所有匹配 <span class="hljs-string">&quot;A=1&quot;</span> 的子测试。<br></code></pre></td></tr></table></figure><p>子测试也可用于程序并行控制。只有子测试全部执行完毕后，父测试才会完成。在下述例子中，所有子测试之间并行运行，此处的 “并行” 只限于这些子测试之间，并不影响定义在其他顶层测试中的子测试：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">TestGroupedParallel</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>    <span class="hljs-keyword">for</span> _, tc := <span class="hljs-keyword">range</span> tests &#123;<br>        tc := tc <span class="hljs-comment">// capture range variable</span><br>        t.Run(tc.Name, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(t *testing.T)</span></span> &#123;<br>            t.Parallel()<br>            ...<br>        &#125;)<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Go——变量、常量与数据类型</title>
    <link href="/2021/12/18/Go%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <url>/2021/12/18/Go%E2%80%94%E2%80%94%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1-变量"><a href="#1-变量" class="headerlink" title="1. 变量"></a>1. 变量</h3><h4 id="1-1-变量的声明"><a href="#1-1-变量的声明" class="headerlink" title="1.1 变量的声明"></a>1.1 变量的声明</h4><ol><li>指定变量类型，如果没有初始化，则变量默认为零值。</li><li>根据值自行判定变量类型</li><li>简短形式，使用 := 赋值操作符（只能声明局部变量）</li></ol><p>【注】局部变量声明后未使用，编译报错。</p><blockquote><p>申明变量没有初始化就为零值</p><ul><li>数值类型为 0</li><li>布尔类型为 false</li><li>字符串为 “”（空字符串）</li><li>复杂类型为 nil（指针、切片、map 等）</li></ul></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> name <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;张三&quot;</span><br>fmt.Println(name)<br><br><span class="hljs-keyword">var</span> flag = <span class="hljs-literal">true</span><br>fmt.Println(flag)<br><br>age := <span class="hljs-number">18</span><br>fmt.Println(age)<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-多变量声明"><a href="#1-2-多变量声明" class="headerlink" title="1.2 多变量声明"></a>1.2 多变量声明</h4><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">var</span> x, y <span class="hljs-keyword">int</span><br><span class="hljs-keyword">var</span> (<br><span class="hljs-comment">// 这种写法一般用于声明全局变量</span><br>a , z <span class="hljs-keyword">int</span><br>b <span class="hljs-keyword">bool</span><br>)<br><br><span class="hljs-keyword">var</span> c, d <span class="hljs-keyword">int</span> = <span class="hljs-number">1</span>, <span class="hljs-number">2</span><br><span class="hljs-keyword">var</span> e, f = <span class="hljs-number">123</span>, <span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br>g, h := <span class="hljs-number">123</span>, <span class="hljs-string">&quot;hello&quot;</span><br><span class="hljs-built_in">println</span>(x, y, a, b, c, d, e, f, g, h)<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-常量"><a href="#2-常量" class="headerlink" title="2. 常量"></a>2. 常量</h3><p>常量的声明和变量声明非常类似，只是把 var 换成了 const，常量在定义的时候必须赋值。</p><p>const同时声明多个常量时，如果省略了值则表示和上面一行的值相同。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> pi = <span class="hljs-number">3.1415</span><br><span class="hljs-keyword">const</span> e = <span class="hljs-number">2.7182</span><br><br><span class="hljs-keyword">const</span> (<br>a = <span class="hljs-number">1</span><br>b = <span class="hljs-number">2</span><br>)<br><br><span class="hljs-keyword">const</span> (<br>n1 = <span class="hljs-number">100</span><br>n2<br>n3<br>)<br><br>fmt.Println(n3) <span class="hljs-comment">// 100</span><br></code></pre></td></tr></table></figure><h4 id="2-1-iota"><a href="#2-1-iota" class="headerlink" title="2.1 iota"></a>2.1 iota</h4><p>iota  是 go 语言的常量计数器，只能在常量的表达式中使用。</p><p>iota 在 const 关键字出现时将被重置为 0。const 中每新增一行常量声明将使 iota 计数一次( iota 可理解为 const 语句块中的行索引)。 使用 iota 能简化定义，在定义枚举时很有用。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">const</span> (<br>n1 = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 0</span><br>n2        <span class="hljs-comment">// 1</span><br>n3        <span class="hljs-comment">// 2</span><br>n4        <span class="hljs-comment">// 3</span><br>)<br><br><span class="hljs-comment">// 使用_跳过某些值</span><br><span class="hljs-keyword">const</span> (<br>n5 = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 0</span><br>n6        <span class="hljs-comment">// 1</span><br>_<br>n7 <span class="hljs-comment">// 3</span><br>)<br><br><span class="hljs-comment">// iota声明中间插队</span><br><span class="hljs-keyword">const</span> (<br>n8  = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 0</span><br>n9  = <span class="hljs-number">100</span>  <span class="hljs-comment">// 100</span><br>n10 = <span class="hljs-literal">iota</span> <span class="hljs-comment">// 2</span><br>n11        <span class="hljs-comment">// 3</span><br>)<br><br><span class="hljs-comment">// 多个 iota 定义在一行</span><br><span class="hljs-keyword">const</span> (<br>a, b = <span class="hljs-literal">iota</span> + <span class="hljs-number">1</span>, <span class="hljs-literal">iota</span> + <span class="hljs-number">2</span> <span class="hljs-comment">// 1,2</span><br>c, d                      <span class="hljs-comment">// 2,3</span><br>e, f                      <span class="hljs-comment">// 3,4</span><br>)<br></code></pre></td></tr></table></figure><h3 id="3-数据类型"><a href="#3-数据类型" class="headerlink" title="3. 数据类型"></a>3. 数据类型</h3><h4 id="3-1-基本数据类型"><a href="#3-1-基本数据类型" class="headerlink" title="3.1 基本数据类型"></a>3.1 基本数据类型</h4><h5 id="整型"><a href="#整型" class="headerlink" title="整型"></a>整型</h5><table><thead><tr><th align="center">类型</th><th align="center">有无符号</th><th align="center">占用存储空间</th><th align="center">表示范围</th></tr></thead><tbody><tr><td align="center">uint8</td><td align="center">无符号</td><td align="center">1字节</td><td align="center">0 - 255(2^8^ -1)</td></tr><tr><td align="center">uint16</td><td align="center">无符号</td><td align="center">21字节</td><td align="center">0 - 65535(2^16^ -1)</td></tr><tr><td align="center">uint32</td><td align="center">无符号</td><td align="center">4字节</td><td align="center">0 到 4294967295(2^32^ -1)</td></tr><tr><td align="center">uint64</td><td align="center">无符号</td><td align="center">8字节</td><td align="center">0 到 18446744073709551615(2^64^ -1)</td></tr><tr><td align="center">int8</td><td align="center">有符号</td><td align="center">1字节</td><td align="center">-128 到 127(-2^7^  ~  2^7^-1)</td></tr><tr><td align="center">int16</td><td align="center">有符号</td><td align="center">2字节</td><td align="center">-32768 到 32767(-2^15^  ~  2^15^-1)</td></tr><tr><td align="center">int32</td><td align="center">有符号</td><td align="center">4字节</td><td align="center">-2147483648 到 2147483647(-2^31^  ~  2^31^-1)</td></tr><tr><td align="center">int64</td><td align="center">有符号</td><td align="center">8字节</td><td align="center">-2^63^  ~  2^63^-1</td></tr></tbody></table><p>其他整数类型：</p><table><thead><tr><th align="center">类型</th><th align="center">有无符号</th><th align="center">占用存储空间</th><th align="center">表示范围</th></tr></thead><tbody><tr><td align="center">int</td><td align="center">有符号</td><td align="center">32位机占4字节，64位机占8字节</td><td align="center">(-2^31^  ~  2^31^-1) \ ( -2^63^  ~  2^63^-1)</td></tr><tr><td align="center">uint</td><td align="center">无符号</td><td align="center">32位机占4字节，64位机占8字节</td><td align="center">(0~2^32^ -1) \ ( 0  ~  2^64^-1)</td></tr><tr><td align="center">rune</td><td align="center">有符号</td><td align="center">等价 int32</td><td align="center">-2^31^  ~  2^31^-1</td></tr><tr><td align="center">byte</td><td align="center">无符号</td><td align="center">等价 uint8</td><td align="center">0 - 255</td></tr></tbody></table><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">// 整型默认类型</span><br><span class="hljs-keyword">var</span> num1 = <span class="hljs-number">1</span><br><span class="hljs-comment">// 打印数据类型、内存占用大小  （64 位机)</span><br>fmt.Printf(<span class="hljs-string">&quot;num1 数据类型：%T，内存占用空间：%d&quot;</span>, num1, unsafe.Sizeof(num1))<br><span class="hljs-comment">// num1 数据类型：int，内存占用空间：8</span><br><br><span class="hljs-keyword">var</span> num2 <span class="hljs-keyword">int8</span> = <span class="hljs-number">128</span><br><span class="hljs-comment">// 编译报错：constant 128 overflows int8</span><br>fmt.Println(num2)<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="浮点型"><a href="#浮点型" class="headerlink" title="浮点型"></a>浮点型</h5><table><thead><tr><th align="center">类型</th><th align="center">占用存储空间</th><th align="center">表示范围</th></tr></thead><tbody><tr><td align="center">float32</td><td align="center">4字节</td><td align="center">-3.403E38 ~ 3.403E38</td></tr><tr><td align="center">float64</td><td align="center">8字节</td><td align="center">-1.798E308 ~ 1.798E308</td></tr><tr><td align="center">complex64</td><td align="center">8字节</td><td align="center">32 位实数和虚数</td></tr><tr><td align="center">complex128</td><td align="center">16字节</td><td align="center">64 位实数和虚数</td></tr></tbody></table><p>浮点类型存储：符号位+指数位+尾数位，所以可能会出现精度损失</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><br><span class="hljs-comment">//定义浮点类型的数据：</span><br><span class="hljs-keyword">var</span> num1 <span class="hljs-keyword">float32</span> = <span class="hljs-number">3.14</span><br>fmt.Println(num1)<br><span class="hljs-comment">//浮点数可以用十进制表示形式，也可以用科学计数法表示形式  E 大写小写都可以的</span><br><span class="hljs-keyword">var</span> num2 <span class="hljs-keyword">float32</span> = <span class="hljs-number">-314E-2</span><br>fmt.Println(num2)<br><br><span class="hljs-comment">//浮点数可能会有精度的损失，所以通常情况下，建议你使用：float64</span><br><span class="hljs-keyword">var</span> num3 <span class="hljs-keyword">float32</span> = <span class="hljs-number">256.000000916</span><br>fmt.Println(num3)  <span class="hljs-comment">// 256</span><br><span class="hljs-keyword">var</span> num4 <span class="hljs-keyword">float64</span> = <span class="hljs-number">256.000000916</span><br>fmt.Println(num4)  <span class="hljs-comment">// 256.000000916</span><br><br><span class="hljs-comment">// 默认的浮点类型为：float64</span><br><span class="hljs-keyword">var</span> num5 = <span class="hljs-number">3.17</span><br>fmt.Printf(<span class="hljs-string">&quot;num9对应的默认的类型为：%T&quot;</span>,num5)<br><br>&#125;<br></code></pre></td></tr></table></figure><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">// complex定义复数类型使用的关键字。</span><br><span class="hljs-keyword">var</span> score <span class="hljs-keyword">complex64</span> = <span class="hljs-built_in">complex</span>(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>)<br><span class="hljs-keyword">var</span> number <span class="hljs-keyword">complex128</span> = <span class="hljs-built_in">complex</span>(<span class="hljs-number">23.23</span>, <span class="hljs-number">11.11</span>)<br>fmt.Print(<span class="hljs-string">&quot;Score = &quot;</span>, score, <span class="hljs-string">&quot; Number = &quot;</span>, number, <span class="hljs-string">&quot;\n&quot;</span>)<br><span class="hljs-comment">// Score = (1+2i) Number = (23.23+11.11i)</span><br><br><span class="hljs-comment">// 使用 real 获取复数的实部，使用 imag 获取复数的虚部。</span><br>fmt.Print(<span class="hljs-string">&quot;Real Score = &quot;</span>, <span class="hljs-built_in">real</span>(score), <span class="hljs-string">&quot; Image Score = &quot;</span>, <span class="hljs-built_in">imag</span>(score), <span class="hljs-string">&quot;\n&quot;</span>)<br><span class="hljs-comment">// Real Score = 1 Image Score = 2</span><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="字符类型"><a href="#字符类型" class="headerlink" title="字符类型"></a>字符类型</h5><p>Golang中没有专门的字符类型，如果要存储单个字符(字母)，一般使用 byte 来保存（Unicode 码）。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//定义字符类型的数据：</span><br><span class="hljs-keyword">var</span> c1 <span class="hljs-keyword">byte</span> = <span class="hljs-string">&#x27;a&#x27;</span><br>fmt.Printf(<span class="hljs-string">&quot;c1 的值：%d ,对应的具体的字符为：%c&quot;</span>, c1, c1)<br><span class="hljs-comment">// c1 的值：97 ,对应的具体的字符为：a</span><br><br><span class="hljs-comment">//定义字符类型的数据：</span><br><span class="hljs-keyword">var</span> c2 <span class="hljs-keyword">int16</span> = <span class="hljs-string">&#x27;中&#x27;</span><br>fmt.Printf(<span class="hljs-string">&quot;c1 的值：%d ,对应的具体的字符为：%c&quot;</span>, c2, c2)<br><span class="hljs-comment">// c1 的值：20013 ,对应的具体的字符为：中</span><br><br><span class="hljs-keyword">var</span> int1 <span class="hljs-keyword">int</span> = <span class="hljs-string">&#x27;中&#x27;</span><br>fmt.Println(int1)<br><span class="hljs-comment">// 20013</span><br><br>&#125;<br></code></pre></td></tr></table></figure><p>java 中的字符：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    <span class="hljs-keyword">int</span> code = <span class="hljs-string">&#x27;中&#x27;</span>;<br>    System.out.println(code);<br>    <span class="hljs-comment">// 20013</span><br>&#125;<br></code></pre></td></tr></table></figure><p><strong>转义字符</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211228130016.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//\b 退格</span><br>fmt.Println(<span class="hljs-string">&quot;aaa\bbbb&quot;</span>)<br><span class="hljs-comment">//\r 光标回到本行的开头，后续输入就会替换原有的字符</span><br>fmt.Println(<span class="hljs-string">&quot;aaaaa\rbbb&quot;</span>)<br><span class="hljs-comment">//\t 制表符</span><br>fmt.Println(<span class="hljs-string">&quot;aaaaaaaabbbbbbbbcccccccc&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;aaaaa\tbbbbb&quot;</span>)<br>fmt.Println(<span class="hljs-string">&quot;aaaaaaaa\tbbbbb&quot;</span>)<br><span class="hljs-comment">//\&quot;</span><br>fmt.Println(<span class="hljs-string">&quot;\&quot;Golang\&quot;&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211228130737.png"></p><h5 id="布尔类型"><a href="#布尔类型" class="headerlink" title="布尔类型"></a>布尔类型</h5><p>布尔型的值只可以是常量 true 或者 false。<br>布尔类型占1个字节</p><h5 id="字符串类型"><a href="#字符串类型" class="headerlink" title="字符串类型"></a>字符串类型</h5><p>【注意】go 中 字符串是基本数据类型</p><figure class="highlight csharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs csharp"><span class="hljs-function">func <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span> &#123;<br><br><span class="hljs-comment">//1.定义一个字符串：</span><br><span class="hljs-keyword">var</span> s1 <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;hello world&quot;</span><br>fmt.Println(s1)<br><br><span class="hljs-comment">//2.字符串的表示形式：</span><br><span class="hljs-comment">//（1）如果字符串中没有特殊字符，字符串的表示形式用双引号</span><br><span class="hljs-comment">//（2）如果字符串中有特殊字符，字符串的表示形式用反引号 ``</span><br><span class="hljs-keyword">var</span> s4 <span class="hljs-built_in">string</span> = `<br>        package main<br>        import <span class="hljs-string">&quot;fmt&quot;</span> <br>        <span class="hljs-function">func <span class="hljs-title">main</span>(<span class="hljs-params"></span>)</span>&#123;<br><br>        &#125;<br>        `<br>fmt.Println(s4)<br><br><span class="hljs-comment">//3.字符串的拼接：</span><br><span class="hljs-keyword">var</span> s5 <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span><br>s5 += <span class="hljs-string">&quot;hello&quot;</span><br><br><span class="hljs-comment">//当一个字符串过长的时候：注意：+保留在上一行的最后</span><br><span class="hljs-keyword">var</span> s6 <span class="hljs-built_in">string</span> = <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span> + <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span> + <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span> + <span class="hljs-string">&quot;abc&quot;</span> +<br><span class="hljs-string">&quot;def&quot;</span> + <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span> + <span class="hljs-string">&quot;abc&quot;</span> + <span class="hljs-string">&quot;def&quot;</span><br>fmt.Println(s6)<br><br>&#125;<br></code></pre></td></tr></table></figure><h5 id="数据类型转换"><a href="#数据类型转换" class="headerlink" title="数据类型转换"></a>数据类型转换</h5><h6 id="数值类型之间转换"><a href="#数值类型之间转换" class="headerlink" title="数值类型之间转换"></a>数值类型之间转换</h6><p>Go 在不同类型的变量之间赋值时需要显式转换，并且只有显式转换(强制转换)。</p><p>语法：T(v)<br>T : 数据类型<br>v : 需要转换的变量<br>将值 v 转换为类型 T</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//进行类型转换：</span><br><span class="hljs-keyword">var</span> n1 <span class="hljs-keyword">int</span> = <span class="hljs-number">100</span><br><span class="hljs-comment">//var n2 float32 = n1  // 无法直接转换</span><br><br><span class="hljs-keyword">var</span> n2 <span class="hljs-keyword">float32</span> = <span class="hljs-keyword">float32</span>(n1)<br>fmt.Println(n2)<br><br><span class="hljs-comment">//将int64转为int8的时候，编译不会出错的，但是会数据的溢出</span><br><span class="hljs-keyword">var</span> n3 <span class="hljs-keyword">int64</span> = <span class="hljs-number">888888</span><br><span class="hljs-keyword">var</span> n4 <span class="hljs-keyword">int8</span> = <span class="hljs-keyword">int8</span>(n3)<br>fmt.Println(n4) <span class="hljs-comment">//56</span><br><br><span class="hljs-keyword">var</span> n5 <span class="hljs-keyword">int32</span> = <span class="hljs-number">12</span><br><span class="hljs-keyword">var</span> n6 <span class="hljs-keyword">int64</span> = <span class="hljs-keyword">int64</span>(n5) + <span class="hljs-number">30</span> <span class="hljs-comment">//一定要匹配=左右的数据类型</span><br>fmt.Println(n6)<br><br><span class="hljs-keyword">var</span> n7 <span class="hljs-keyword">int64</span> = <span class="hljs-number">12</span><br><span class="hljs-keyword">var</span> n8 <span class="hljs-keyword">int8</span> = <span class="hljs-keyword">int8</span>(n7) + <span class="hljs-number">127</span> <span class="hljs-comment">//编译通过，但是结果可能会溢出</span><br><span class="hljs-comment">//var n9 int8 = int8(n7) + 128 //编译不会通过</span><br>fmt.Println(n8) <span class="hljs-comment">// -117</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="数值类型转换为-string"><a href="#数值类型转换为-string" class="headerlink" title="数值类型转换为 string"></a>数值类型转换为 string</h6><p>方式1：fmt.Sprintf(“%参数”,表达式)<br>方式2：使用 strconv 包的函数<br>参数参考：<a href="https://studygolang.com/pkgdoc">https://studygolang.com/pkgdoc</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211228134900.png"></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> n1 <span class="hljs-keyword">int</span> = <span class="hljs-number">19</span><br><span class="hljs-keyword">var</span> n2 <span class="hljs-keyword">float64</span> = <span class="hljs-number">4.78</span><br><span class="hljs-keyword">var</span> s1 <span class="hljs-keyword">string</span> = fmt.Sprintf(<span class="hljs-string">&quot;%d&quot;</span>, n1)<br>fmt.Printf(<span class="hljs-string">&quot;s1对应的类型是：%T ，s1 = %#v \n&quot;</span>, s1, s1)<br><span class="hljs-keyword">var</span> s2 <span class="hljs-keyword">string</span> = fmt.Sprintf(<span class="hljs-string">&quot;%f&quot;</span>, n2)<br>fmt.Printf(<span class="hljs-string">&quot;s2对应的类型是：%T ，s2 = %q \n&quot;</span>, s2, s2)<br><br><span class="hljs-keyword">var</span> n3 <span class="hljs-keyword">bool</span> = <span class="hljs-literal">true</span><br><span class="hljs-keyword">var</span> s3 <span class="hljs-keyword">string</span> = strconv.FormatBool(n3)<br>fmt.Printf(<span class="hljs-string">&quot;s3对应的类型是：%T ，s3 = %q \n&quot;</span>, s3, s3)<br><span class="hljs-keyword">var</span> s4 <span class="hljs-keyword">string</span> = strconv.FormatInt(<span class="hljs-keyword">int64</span>(n1), <span class="hljs-number">10</span>) <span class="hljs-comment">//参数：第二个参数指定字面值的进制形式为十进制</span><br>fmt.Printf(<span class="hljs-string">&quot;s1对应的类型是：%T ，s1 = %q \n&quot;</span>, s4, s4)<br><span class="hljs-keyword">var</span> s5 <span class="hljs-keyword">string</span> = strconv.FormatFloat(n2, <span class="hljs-string">&#x27;f&#x27;</span>, <span class="hljs-number">9</span>, <span class="hljs-number">64</span>)<br><span class="hljs-comment">//第二个参数：&#x27;f&#x27;（-ddd.dddd）  第三个参数：9 保留小数点后面9位  第四个参数：表示这个小数是float64类型</span><br>fmt.Printf(<span class="hljs-string">&quot;s2对应的类型是：%T ，s2 = %q \n&quot;</span>, s5, s5)<br><span class="hljs-comment">// 4.780000000</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h6 id="string-类型转数值类型"><a href="#string-类型转数值类型" class="headerlink" title="string 类型转数值类型"></a>string 类型转数值类型</h6><p>方式：使用 strconv 包的函数   </p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211228140047.png"></p><p>注意：string向基本数据类型转换的时候，一定要确保 string 类型能够转成有效的数据类型，否则最后得到的结果就是按照对应类型的默认值输出</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-comment">//string--&gt;bool</span><br><span class="hljs-keyword">var</span> s1 <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;true&quot;</span><br><span class="hljs-comment">//ParseBool这个函数的返回值有两个：(value bool, err error)</span><br>b, _ := strconv.ParseBool(s1)<br>fmt.Printf(<span class="hljs-string">&quot;b的类型是：%T,b=%v \n&quot;</span>, b, b)<br><br><span class="hljs-comment">//string---》int</span><br><span class="hljs-keyword">var</span> s2 <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;-19&quot;</span><br>num1, _ := strconv.ParseInt(s2, <span class="hljs-number">10</span>, <span class="hljs-number">64</span>)<br>fmt.Printf(<span class="hljs-string">&quot;num1的类型是：%T,num1=%v \n&quot;</span>, num1, num1)<br><br><span class="hljs-comment">//string--&gt;float32/float64</span><br><span class="hljs-keyword">var</span> s3 <span class="hljs-keyword">string</span> = <span class="hljs-string">&quot;3.14&quot;</span><br>f1, _ := strconv.ParseFloat(s3, <span class="hljs-number">64</span>)<br>fmt.Printf(<span class="hljs-string">&quot;f1的类型是：%T,f1=%v \n&quot;</span>, f1, f1)<br><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-复杂数据类型"><a href="#3-2-复杂数据类型" class="headerlink" title="3.2 复杂数据类型"></a>3.2 复杂数据类型</h4><h5 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h5><p>基本数据类型都有对应的指针类型，形式为 *数据类型</p><p>基本数据类型和指针：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> age <span class="hljs-keyword">int</span> = <span class="hljs-number">18</span><br><span class="hljs-comment">//&amp;符号+变量 就可以获取这个变量内存的地址</span><br>fmt.Println(&amp;age) <span class="hljs-comment">//0xc0000a2058</span><br>&#125;<br></code></pre></td></tr></table></figure><p>指针变量：</p><ol><li>&amp; 取内存地址</li><li> * 根据地址取值</li></ol><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> &#123;<br><span class="hljs-keyword">var</span> age <span class="hljs-keyword">int</span> = <span class="hljs-number">18</span><br><br><span class="hljs-comment">//定义一个指针变量：</span><br><span class="hljs-comment">//ptr 指针变量的名字</span><br><span class="hljs-comment">//ptr对应的类型是：*int 是一个指针类型 （可以理解为 指向int类型的指针）</span><br><span class="hljs-comment">//&amp;age 就是一个地址，是 ptr 变量的具体的值</span><br><span class="hljs-keyword">var</span> ptr *<span class="hljs-keyword">int</span> = &amp;age<br>fmt.Println(ptr)<span class="hljs-comment">// 0xc0000a2058</span><br>fmt.Println(<span class="hljs-string">&quot;ptr 存储空间的地址为：&quot;</span>, &amp;ptr) <br><span class="hljs-comment">// 获取指针指向的变量的值</span><br>fmt.Printf(<span class="hljs-string">&quot;ptr指向的数值为：%v&quot;</span>, *ptr) <span class="hljs-comment">//ptr指向的数值为：18</span><br>&#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211228142655.png"></p><p>通过指针改变指向值:</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br><span class="hljs-keyword">var</span> num <span class="hljs-keyword">int</span> = <span class="hljs-number">10</span><br>aa(num)<br>fmt.Println(num)<span class="hljs-comment">// 10</span><br>bb(&amp;num)<br>fmt.Println(num)<span class="hljs-comment">// 200</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">aa</span><span class="hljs-params">(int2 <span class="hljs-keyword">int</span>)</span></span>  &#123;<br>int2 = <span class="hljs-number">100</span><br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">bb</span><span class="hljs-params">(int2 *<span class="hljs-keyword">int</span>)</span></span>  &#123;<br>*int2 = <span class="hljs-number">200</span><br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——模板模式</title>
    <link href="/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/12/17/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E6%A8%A1%E6%9D%BF%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>定义一个操作的算法骨架，而将一些步骤延迟到子类中。Template Method 使得子类可以不改变一个算法的结构即可重定义该算法的某些 特定步骤。</p><p><strong>优点：</strong></p><ol><li>封装不变部分，扩展可变部分。 </li><li>提取公共代码，便于维护。</li><li>行为由父类控制，子类实现。</li></ol><p><strong>缺点：</strong></p><ul><li>每一个不同的实现都需要一个子类来实现，导致类的个数增加，使得系统更加庞大。</li></ul><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211217214833.png"></p><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@author</span> 猫和少年</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@create</span> 2021-12-17 21:35</span><br><span class="hljs-comment"> * <span class="hljs-doctag">@Slogan</span> 才疏学浅，少年登科；满腹经纶，白发不第</span><br><span class="hljs-comment"> */</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">TemplateMethod</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        AbstractClass abstractClass = <span class="hljs-keyword">new</span> SubClass();<br>        abstractClass.option();<br><br>        abstractClass = <span class="hljs-keyword">new</span> SubClass2();<br>        abstractClass.option();<br>    &#125;<br>&#125;<br><br><br><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">AbstractClass</span></span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">option</span><span class="hljs-params">()</span></span>&#123;<br>        <span class="hljs-comment">// 准备工作</span><br>        System.out.println(<span class="hljs-string">&quot;pre .......&quot;</span>);<br>        templateMethod();<br>        <span class="hljs-comment">// 结尾工作</span><br>        System.out.println(<span class="hljs-string">&quot;teardown.....&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">templateMethod</span><span class="hljs-params">()</span></span>;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">SubClass</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClass</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">templateMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;subclass  executed...&quot;</span>);<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span>  <span class="hljs-title">SubClass2</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">AbstractClass</span></span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">templateMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;subclass2  executed...&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-JDK-中的应用"><a href="#3-JDK-中的应用" class="headerlink" title="3. JDK 中的应用"></a>3. JDK 中的应用</h3><p><strong>HttpServlet</strong></p><p>通过继承 HttpServlet ，并实现 doGet 等方法来支持相应的请求。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/GenericServlet.png"></p><p><strong>HttpServlet 响应流程</strong></p><ol><li>Web 客户向 Servlet 容器发出Http请求</li><li>Servlet 容器解析 Web 客户的 Http 请求</li><li>Servlet 容器创建一个 HttpRequest 对象，封装 Http 请求信息</li><li>Servlet 容器创建一个 HttpResponse 对象</li><li>Servlet 容器调用 HttpServlet 的 service 方法，把 HttpRequest 和 HttpResponse 对象作为 service 方法的参数传给 HttpServlet 对象</li><li>HttpServle t调用 HttpRequest 的有关方法，获取HTTP请求信息</li><li>HttpServlet 调用 HttpResponse 的有关方法，生成响应数据</li><li>Servlet 容器把 HttpServle t的响应结果传给 Web 客户</li></ol><p>其中HttpServlet首先必须读取Http请求的内容，Servlet容器负责创建HttpServlet对象，并把Http请求直接封装到HttpServlet对象中。</p><p><strong>创建 HttpServlet 步骤</strong></p><ol><li>继承 HttpServlet 抽象类</li><li>重写 HttpServlet 的部分方法，如 doGet() 或 doPost() 方法</li><li>获取 HTTP 请求信息。通过 HttpServletRequest 对象来检索 HTML 表单所提交的数据或 URL 上的查询字符串</li><li>生成 HTTP 响应结果。通过 HttpServletResponse 对象生成响应结果</li></ol><h3 id="4-Spring-中的应用"><a href="#4-Spring-中的应用" class="headerlink" title="4. Spring 中的应用"></a>4. Spring 中的应用</h3><p><strong>AbstractController</strong><br>通过继承 AbstractController 并重写  handleRequestInternal 方法，实现 Controller。AbstractController 包装的功能：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211217234313.png"></p><p>AbstractController 继承关系：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/AbstractController.png"></p><p><a href="https://www.cnblogs.com/yif0118/p/12494239.html">SpringMVC实现Controller方式</a> </p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>行为型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——责任链模式</title>
    <link href="/2021/12/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/12/15/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E8%B4%A3%E4%BB%BB%E9%93%BE%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>为请求创建了一个接收者对象的链。<br>为了避免请求发送者与多个请求处理者耦合在一起，于是将所有请求的处理者通过前一对象记住其下一个对象的引用而连成一条链；当有请求发生时，可将请求沿着这条链传递，直到有对象处理它为止。</p><p><strong>优点：</strong> </p><ol><li>降低耦合。它将请求的发送者和接收者解耦。 </li><li>可以控制执行顺序。可以动态增删责任以及调动他们的顺序。</li><li> 符合开闭原则和单一职责原则</li></ol><p><strong>缺点：</strong></p><ol><li>不能保证请求一定被接收。</li><li>系统性能将受到一定影响，而且在进行代码调试时不太方便，可能会造成循环调用。</li><li>可能不容易观察运行时的特征，有碍于除错。</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/WPS%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91.png"></p><p>使用场景： 1、有多个对象处理同一个请求，具体哪个对象处理该请求由运行时刻自动确定。 2、在不明确指定接收者的情况下，向多个对象中的一个提交一个请求。 3、可动态指定一组对象处理请求。</p><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><p>在请求业务前，需要对请求进行请求频率控制、登录认证、访问权限验证、敏感词过滤等。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ChainOfResponsibility</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Request request = <span class="hljs-keyword">new</span> Request.RequestBuilder().frequentOK(<span class="hljs-keyword">true</span>).loggedOn(<span class="hljs-keyword">false</span>).build();<br><br>        RequestFrequentHandler requestFrequentHandler = <span class="hljs-keyword">new</span> RequestFrequentHandler(<span class="hljs-keyword">new</span> LoggingHandler(<span class="hljs-keyword">null</span>));<br><br>        <span class="hljs-keyword">if</span> (requestFrequentHandler.process(request)) &#123;<br>            System.out.println(<span class="hljs-string">&quot;业务正常处理&quot;</span>);<br>        &#125;<span class="hljs-keyword">else</span> &#123;<br>            System.out.println(<span class="hljs-string">&quot;访问异常&quot;</span>);<br>        &#125;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>责任定义:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">abstract</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Handler</span> </span>&#123;<br>    Handler next;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Handler</span><span class="hljs-params">(Handler next)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Handler <span class="hljs-title">getNext</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">setNext</span><span class="hljs-params">(Handler next)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">abstract</span> <span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Request request)</span></span>;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestFrequentHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br><br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">RequestFrequentHandler</span><span class="hljs-params">(Handler next)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(next);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Request request)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;访问频率验证&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (request.isFrequentOK()) &#123;<br>            Handler next = getNext();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == next) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> next.process(request);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">LoggingHandler</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Handler</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">LoggingHandler</span><span class="hljs-params">(Handler next)</span> </span>&#123;<br>        <span class="hljs-keyword">super</span>(next);<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">process</span><span class="hljs-params">(Request request)</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;登录验证&quot;</span>);<br><br>        <span class="hljs-keyword">if</span> (request.isLoggedOn()) &#123;<br>            Handler next = getNext();<br>            <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> == next) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">true</span>;<br>            &#125;<br>            <span class="hljs-keyword">return</span> next.process(request);<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">false</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>请求定义：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Request</span> </span>&#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> loggedOn;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> frequentOK;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isPermits;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> containsSensitiveWords;<br>    <span class="hljs-keyword">private</span> String requestBody;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Request</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> loggedOn, <span class="hljs-keyword">boolean</span> frequentOK, <span class="hljs-keyword">boolean</span> isPermits, <span class="hljs-keyword">boolean</span> containsSensitiveWords)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.loggedOn = loggedOn;<br>        <span class="hljs-keyword">this</span>.frequentOK = frequentOK;<br>        <span class="hljs-keyword">this</span>.isPermits = isPermits;<br>        <span class="hljs-keyword">this</span>.containsSensitiveWords = containsSensitiveWords;<br>    &#125;<br><br>    <span class="hljs-keyword">static</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">RequestBuilder</span></span>&#123;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> loggedOn;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> frequentOK;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> isPermits;<br>        <span class="hljs-keyword">private</span> <span class="hljs-keyword">boolean</span> containsSensitiveWords;<br><br>        <span class="hljs-function">RequestBuilder <span class="hljs-title">loggedOn</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> loggedOn)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.loggedOn = loggedOn;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function">RequestBuilder <span class="hljs-title">frequentOK</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> frequentOK)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.frequentOK = frequentOK;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function">RequestBuilder <span class="hljs-title">isPermits</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> isPermits)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.isPermits = isPermits;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br>        <span class="hljs-function">RequestBuilder <span class="hljs-title">containsSensitiveWords</span><span class="hljs-params">(<span class="hljs-keyword">boolean</span> containsSensitiveWords)</span></span>&#123;<br>            <span class="hljs-keyword">this</span>.containsSensitiveWords = containsSensitiveWords;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;<br>        &#125;<br><br>        <span class="hljs-function"><span class="hljs-keyword">public</span> Request <span class="hljs-title">build</span><span class="hljs-params">()</span></span>&#123;<br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> Request(loggedOn,frequentOK,isPermits,containsSensitiveWords);<br>        &#125;<br><br>    &#125;<br><br>    <span class="hljs-comment">/* getter  setter */</span><br><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-JDK-中应用"><a href="#3-JDK-中应用" class="headerlink" title="3. JDK 中应用"></a>3. JDK 中应用</h3><p>javax.servlet.FilterChain<br>javax.servlet.Filter</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211215232225.png"></p><p>通过数组实现责任链表</p><h3 id="4-Spring-中的应用"><a href="#4-Spring-中的应用" class="headerlink" title="4. Spring 中的应用"></a>4. Spring 中的应用</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211218232612.png"></p><p><a href="https://blog.csdn.net/u014082714/article/details/103463378">https://blog.csdn.net/u014082714/article/details/103463378</a></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>行为型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>GO——入门</title>
    <link href="/2021/12/13/GO%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"/>
    <url>/2021/12/13/GO%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h3 id="1-认识-Go-语言"><a href="#1-认识-Go-语言" class="headerlink" title="1. 认识 Go 语言"></a>1. 认识 Go 语言</h3><h4 id="1-1-GO-语言的-logo"><a href="#1-1-GO-语言的-logo" class="headerlink" title="1.1 GO 语言的 logo"></a>1.1 GO 语言的 logo</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211214223325.png"></p><h4 id="1-2-Go-语言的吉祥物"><a href="#1-2-Go-语言的吉祥物" class="headerlink" title="1.2 Go 语言的吉祥物"></a>1.2 Go 语言的吉祥物</h4><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211214223153.png"></p><p>gopher 是一种生活在加拿大的小动物，中文名叫做囊地鼠。</p><h3 id="2-Go-语言特性"><a href="#2-Go-语言特性" class="headerlink" title="2. Go 语言特性"></a>2. Go 语言特性</h3><blockquote><ul><li>自动垃圾回收</li><li>更丰富的内置类型</li><li>函数多返回值</li><li>错误处理</li><li>匿名函数和闭包</li><li>类型和接口</li><li>并发编程</li><li>反射</li><li>语言交互性</li></ul></blockquote><h3 id="3-语言结构"><a href="#3-语言结构" class="headerlink" title="3. 语言结构"></a>3. 语言结构</h3><p>基础组成有以下几个部分：</p><ul><li>包声明</li><li>引入包</li><li>函数</li><li>变量</li><li>语句 &amp; 表达式</li><li>注释</li></ul><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-comment">// 必须在源文件中非注释的第一行指明这个文件属于哪个包，每个 Go 应用程序都包含一个名为 main 的包。</span><br><span class="hljs-keyword">package</span> main<br><span class="hljs-comment">// 引入包</span><br><span class="hljs-keyword">import</span>  <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-comment">// 每一个可执行程序必须包含 main 函数是</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br> fmt.Println(<span class="hljs-string">&quot;Hello World!&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><ul><li>注释：多行注释（/*…*/）和单行注释（//） </li><li>分隔符：在 Go 程序中，一行代表一个语句结束。如果一行只有一个语句，结尾不需要显式加分号（;），但是多个语句写在同一行，则必须使用 ; 区分。</li><li>标识符：标识符由一个或是多个字母、数字、下划线组成的序列，并且第一个字符必须是字母或下划线而不能是数字。</li><li>当标识符（包括常量、变量、类型、函数名、结构字段等等）以大写字母开头，它就可以被外部包的代码所使用（类似 java 中的public）；标识符如果以小写字母开头，则对包外是不可见的（类似 java 的 protected ）。</li></ul></blockquote><p><font color = "red"><strong>注意：</strong></font><br> { 不能单独放在一行，否则编译错误<br> <figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs go"><span class="hljs-keyword">package</span> main<br><br><span class="hljs-keyword">import</span> <span class="hljs-string">&quot;fmt&quot;</span><br><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span><br>&#123;<br> fmt.Println(<span class="hljs-string">&quot;hello world&quot;</span>)<br>&#125;<br></code></pre></td></tr></table></figure></p><h3 id="4-执行-GO-程序"><a href="#4-执行-GO-程序" class="headerlink" title="4. 执行 GO 程序"></a>4. 执行 GO 程序</h3><ol><li> 先编译再执行</li><li> 编译运行一起执行</li></ol><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211214231117.png"></p><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211213234710.png"></p><p>Golang中文网在线标准库文档: <a href="https://studygolang.com/pkgdoc">https://studygolang.com/pkgdoc</a></p>]]></content>
    
    
    <categories>
      
      <category>Golang</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Golang</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式——策略模式</title>
    <link href="/2021/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/"/>
    <url>/2021/12/10/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E2%80%94%E2%80%94%E7%AD%96%E7%95%A5%E6%A8%A1%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="1-模式定义"><a href="#1-模式定义" class="headerlink" title="1. 模式定义"></a>1. 模式定义</h3><p>定义了算法族，分别封装起来，让他们之间可以相互替换，此模式的变化独立于算法的使用者。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211211121318.png"></p><p>解决场景：一般是具有同类可替代的行为逻辑算法场景。比如；不同类型的交易方式（信用卡、支付宝、微信）、生成唯一 ID 策略（UUID、DB自增、DB+Redis、雪花算法、Leaf 算法）等，都可以使用策略模式进行行为包装，供给外部使用。 </p><h3 id="2-示例"><a href="#2-示例" class="headerlink" title="2. 示例"></a>2. 示例</h3><p>场景：模拟在购买商品时使用各种类型优惠券(满减、直减、折扣、n元购)，</p><h4 id="2-1-一般实现"><a href="#2-1-一般实现" class="headerlink" title="2.1 一般实现"></a>2.1 一般实现</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CouponDiscountService</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">double</span> <span class="hljs-title">disCountAmount</span><span class="hljs-params">(<span class="hljs-keyword">int</span> type, <span class="hljs-keyword">double</span> typeContent, <span class="hljs-keyword">double</span> skuPrice, <span class="hljs-keyword">double</span> typeExt)</span> </span>&#123;<br>        <span class="hljs-comment">// 直减</span><br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> skuPrice - typeContent;<br>        &#125;<br>        <span class="hljs-comment">// 满减</span><br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">2</span>) &#123;<br>            <span class="hljs-keyword">return</span> skuPrice &lt; typeContent ? skuPrice : skuPrice - typeContent;<br>        &#125;<br>        <span class="hljs-comment">// 折扣</span><br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">3</span>) &#123;<br>            <span class="hljs-keyword">return</span> skuPrice * typeContent;<br>        &#125;<br>        <span class="hljs-comment">// n 元购</span><br>        <span class="hljs-keyword">if</span> (type == <span class="hljs-number">4</span>) &#123;<br>            <span class="hljs-keyword">return</span> typeContent;<br>        &#125;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="2-2-策略模式重构代码"><a href="#2-2-策略模式重构代码" class="headerlink" title="2.2 策略模式重构代码"></a>2.2 策略模式重构代码</h4><p><strong>优惠券接口</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 优惠券金额计算</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> couponInfo 优惠券信息</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@param</span> skuPrice skuji金额</span><br><span class="hljs-comment">     * <span class="hljs-doctag">@return</span>   折扣金额</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-function">BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(T couponInfo,BigDecimal skuPrice)</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>优惠券接口实现</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MJCouponDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">Map</span>&lt;<span class="hljs-title">String</span>, <span class="hljs-title">String</span>&gt;&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 满减计算</span><br><span class="hljs-comment">     * 1. 判断满⾜x元后-n元，否则不减</span><br><span class="hljs-comment">     * 2. 最低⽀付⾦额1元</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(Map&lt;String, String&gt; couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br>        String condition = couponInfo.get(<span class="hljs-string">&quot;condition&quot;</span>);<br>        String amount = couponInfo.get(<span class="hljs-string">&quot;amount&quot;</span>);<br>        <span class="hljs-comment">// ⼩于商品⾦额条件的，直接返回商品原价</span><br>        <span class="hljs-keyword">if</span> (skuPrice.compareTo(<span class="hljs-keyword">new</span> BigDecimal(condition)) &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> skuPrice;<br>        <span class="hljs-comment">// 减去优惠⾦额判断</span><br>        BigDecimal discountAmount = skuPrice.subtract(<span class="hljs-keyword">new</span> BigDecimal(amount));<br>        <span class="hljs-keyword">if</span> (discountAmount.compareTo(BigDecimal.ZERO) &lt; <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span><br>                BigDecimal.ONE;<br>        <span class="hljs-keyword">return</span> discountAmount;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZJCouponDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">Double</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 直减计算</span><br><span class="hljs-comment">     * 1. 使用商品价格减去优惠价格</span><br><span class="hljs-comment">     * 2. 最低⽀付⾦额1元</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(Double couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br>        BigDecimal discountAmount = skuPrice.subtract(<span class="hljs-keyword">new</span> BigDecimal(couponInfo));<br><br>        <span class="hljs-keyword">if</span> (discountAmount.compareTo(BigDecimal.ONE) &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> BigDecimal.ONE;<br>        &#125;<br>        <span class="hljs-keyword">return</span> discountAmount;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ZKCouponDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">Double</span>&gt; </span>&#123;<br><br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * 折扣计算</span><br><span class="hljs-comment">     * 1. 使⽤商品价格乘以折扣⽐例，为最后⽀付⾦额</span><br><span class="hljs-comment">     * 2. 保留两位⼩数</span><br><span class="hljs-comment">     * 3. 最低⽀付⾦额1元</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(Double couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br><br>        BigDecimal discountAmount = skuPrice.multiply(<span class="hljs-keyword">new</span> BigDecimal(couponInfo)).<br>                setScale(<span class="hljs-number">2</span>, BigDecimal.ROUND_HALF_UP);<br>        <span class="hljs-keyword">if</span> (discountAmount.compareTo(BigDecimal.ONE) &lt; <span class="hljs-number">1</span>) &#123;<br>            <span class="hljs-keyword">return</span> BigDecimal.ONE;<br>        &#125;<br>        <span class="hljs-keyword">return</span> discountAmount;<br>    &#125;<br>&#125;<br><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">NYGCouponDiscount</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">CouponDiscount</span>&lt;<span class="hljs-title">Double</span>&gt; </span>&#123;<br>    <span class="hljs-comment">/**</span><br><span class="hljs-comment">     * n 元购购买</span><br><span class="hljs-comment">     * 1. ⽆论原价多少钱都固定⾦额购买</span><br><span class="hljs-comment">     */</span><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(Double couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> BigDecimal(couponInfo);<br>    &#125;<br>&#125;<br><br></code></pre></td></tr></table></figure><p><strong>策略控制类</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Context</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-keyword">private</span> CouponDiscount&lt;T&gt; couponDiscount;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Context</span><span class="hljs-params">(CouponDiscount&lt;T&gt; couponDiscount)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.couponDiscount = couponDiscount;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> BigDecimal <span class="hljs-title">discountAmount</span><span class="hljs-params">(T couponInfo, BigDecimal skuPrice)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> couponDiscount.discountAmount(couponInfo, skuPrice);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>测试验证</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ContextTest</span> </span>&#123;<br>    <span class="hljs-meta">@Test</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">discountAmount</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> Exception </span>&#123;<br><br>        <span class="hljs-comment">// 直减；100-10，商品100元</span><br>        Context&lt;Double&gt; context = <span class="hljs-keyword">new</span> Context&lt;Double&gt;(<span class="hljs-keyword">new</span> ZJCouponDiscount());<br>        BigDecimal discountAmount = context.discountAmount(<span class="hljs-number">10D</span>, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">100</span>));<br>        Assert.assertTrue(discountAmount.equals(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">90</span>)));<br><br>        <span class="hljs-comment">// 满100减10，商品100元</span><br>        Context&lt;Map&lt;String, String&gt;&gt; context1 = <span class="hljs-keyword">new</span> Context&lt;Map&lt;String, String&gt;&gt;(<span class="hljs-keyword">new</span> MJCouponDiscount());<br>        Map&lt;String, String&gt; mapReq = <span class="hljs-keyword">new</span> HashMap&lt;String, String&gt;();<br>        mapReq.put(<span class="hljs-string">&quot;condition&quot;</span>, <span class="hljs-string">&quot;100&quot;</span>);<br>        mapReq.put(<span class="hljs-string">&quot;amount&quot;</span>, <span class="hljs-string">&quot;10&quot;</span>);<br>        BigDecimal discountAmount1 = context1.discountAmount(mapReq, <span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">90</span>));<br>        Assert.assertTrue(discountAmount1.equals(<span class="hljs-keyword">new</span> BigDecimal(<span class="hljs-number">90</span>)));<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p>通过策略设计模式的使用可以把方法中的 if 语句优化掉，大量的 if 语句使用会让代码难以扩展，也不好维护，同时在后期遇到各种问题也很难维护。在使用这样的设计模式后可以很好的满足隔离性与和扩展性，对于不断新增的需求也非常方便承接。</p><h3 id="3-JDK中的应用"><a href="#3-JDK中的应用" class="headerlink" title="3. JDK中的应用"></a>3. JDK中的应用</h3><p>排序时通过实现排序接口生成不同的排序类，以达到按不同的属性排序。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">ComparatorTest</span> </span>&#123;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        Person[] people = <span class="hljs-keyword">new</span> Person[]&#123;<span class="hljs-keyword">new</span> Person(<span class="hljs-number">10</span>,<span class="hljs-number">111</span>),<span class="hljs-keyword">new</span> Person(<span class="hljs-number">18</span>,<span class="hljs-number">99</span>),<span class="hljs-keyword">new</span> Person(<span class="hljs-number">15</span>,<span class="hljs-number">122</span>)&#125;;<br><br>        System.out.println(Arrays.toString(people));<br>        Arrays.sort(people,<span class="hljs-keyword">new</span> SortByAge());<br>        System.out.println(Arrays.toString(people));<br>        Arrays.sort(people,<span class="hljs-keyword">new</span> SortByHeight());<br>        System.out.println(Arrays.toString(people));<br><br>        <span class="hljs-comment">/**</span><br><span class="hljs-comment">         *  [Person&#123;age=10, height=111&#125;, Person&#123;age=18, height=99&#125;, Person&#123;age=15, height=122&#125;]</span><br><span class="hljs-comment">            [Person&#123;age=10, height=111&#125;, Person&#123;age=15, height=122&#125;, Person&#123;age=18, height=99&#125;]</span><br><span class="hljs-comment">            [Person&#123;age=15, height=122&#125;, Person&#123;age=10, height=111&#125;, Person&#123;age=18, height=99&#125;]</span><br><span class="hljs-comment">         */</span><br>    &#125;<br><br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortByHeight</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Person</span>&gt;</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person o1, Person o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span>  o1.getHeight()-o2.getHeight();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">SortByAge</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Comparator</span>&lt;<span class="hljs-title">Person</span>&gt;</span>&#123;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Person o1, Person o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> o1.getAge()-o2.getAge();<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Person</span></span>&#123;<br>    <span class="hljs-keyword">int</span> age;<br>    <span class="hljs-keyword">int</span> height;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Person</span><span class="hljs-params">(<span class="hljs-keyword">int</span> age, <span class="hljs-keyword">int</span> height)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.age = age;<br>        <span class="hljs-keyword">this</span>.height = height;<br>    &#125;<br>    <br>    <span class="hljs-comment">/* getter setter  toString */</span><br>&#125;<br><br></code></pre></td></tr></table></figure><h3 id="4-Spring-中的应用"><a href="#4-Spring-中的应用" class="headerlink" title="4. Spring 中的应用"></a>4. Spring 中的应用</h3><h4 id="4-1-InstantiationStrategy"><a href="#4-1-InstantiationStrategy" class="headerlink" title="4.1 InstantiationStrategy"></a>4.1 InstantiationStrategy</h4><p>接口 InstantiationStrategy 是实例化策略接口类，它定义了三种实例化方式，SimpleInstantiationStrategy 实现了该策略，CglibSubclassingInstantiationStrategy 又继承了 SimpleInstantiationStrategy  新增了根据 cglib 生成代理类实例化方法。</p><p><a href="https://my.oschina.net/chengxiaoyuan/blog/823655">实例化策略 InstantiationStrategy</a></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211211125722.png"></p><p>如果工厂方法实例化直接用反射创建对象，如果是构造方法实例化的则判断是否有 MethodOverrides，如果没有MethodOverrides 也是直接用反射，如果有 MethodOverrides 就需要用 cglib 实例化对象，SimpleInstantiationStrategy 把通过 cglib 实例化的任务交给了它的子类 CglibSubclassingInstantiationStrategy。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211211224848.png"></p><h4 id="4-2-Aop代理策略"><a href="#4-2-Aop代理策略" class="headerlink" title="4.2 Aop代理策略"></a>4.2 Aop代理策略</h4><p>首先 AopProxyFactory 接口类提供了 createAopProxy 接口，这个是策略模式的接口方法。DefaultAopProxyFactory 实现了该接口作为策略的实现者。ProxyCreatorSupport 里面引用了 AopProxyFactory，并且提供了 get、set 方法用来运行时改变策略。这里 Spring 只实现了 DefaultAopProxyFactory 这一个策略，如果需要自己也可以实现。</p><p>DefaultAopProxyFactory 里面的 createAopProxy 的逻辑如下，可以在运行时根据参数决定用 Cglib 策略还是 JDK 动态代理策略生成代理类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> AopProxy <span class="hljs-title">createAopProxy</span><span class="hljs-params">(AdvisedSupport config)</span> <span class="hljs-keyword">throws</span> AopConfigException </span>&#123;<br><br><br>        <span class="hljs-comment">//如果XML打开了优化开关，或者设置为了代理目标类，或者目前类没有接口</span><br>        <span class="hljs-keyword">if</span> (config.isOptimize() || config.isProxyTargetClass() || hasNoUserSuppliedProxyInterfaces(config)) &#123;<br>            Class&lt;?&gt; targetClass = config.getTargetClass();<br>            <span class="hljs-keyword">if</span> (targetClass == <span class="hljs-keyword">null</span>) &#123;<br>                <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> AopConfigException(<span class="hljs-string">&quot;TargetSource cannot determine target class: &quot;</span> +<br>                        <span class="hljs-string">&quot;Either an interface or a target is required for proxy creation.&quot;</span>);<br>            &#125;<br><br>            <span class="hljs-comment">//如果有接口，或者通过Proxy.newProxyInstance生成的，则使用jdk动态代理</span><br>            <span class="hljs-keyword">if</span> (targetClass.isInterface() || Proxy.isProxyClass(targetClass)) &#123;<br>                <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);<br>            &#125;<br><br>            <span class="hljs-comment">//使用cglib</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> ObjenesisCglibAopProxy(config);<br>        &#125;<br>        <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">//使用jdk动态代理</span><br>            <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> JdkDynamicAopProxy(config);<br>        &#125;<br>    &#125;<br></code></pre></td></tr></table></figure><p>另外 AopProxy 也是一个策略接口类，具体实现的策略为 JdkDynamicAopProxy、CglibAopProxy、ObjenesisCglibAopProxy。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211211231617.png"></p>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>设计模式</tag>
      
      <tag>行为型模式</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——泛型</title>
    <link href="/2021/12/09/java%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B/"/>
    <url>/2021/12/09/java%E2%80%94%E2%80%94%E6%B3%9B%E5%9E%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1-理解泛型"><a href="#1-理解泛型" class="headerlink" title="1.理解泛型"></a>1.理解泛型</h3><p>什么是泛型？为什么要使用泛型？</p><p>Java 泛型（generics）是 JDK 5 中引入的一个新特性, 泛型提供了编译时类型安全检测机制，该机制允许程序员在编译时检测到非法的类型。</p><p>泛型的本质是参数化类型，也就是说所操作的数据类型被指定为一个参数。<br>泛型，即“参数化类型”。就是将类型由原来的具体的类型参数化（称之为类型形参），然后在使用/调用时传入具体的类型（类型实参）。</p><p>泛型可以用在类、接口和方法中，分别被称为泛型类、泛型接口、泛型方法。</p><blockquote><p>注意：<br>泛型的类型参数只能是类类型，不能是简单类型。<br>不能对确切的泛型类型使用 instanceof 操作。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; strings = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br><span class="hljs-comment">// 编译报错：Illegal generic type for instanceo</span><br><span class="hljs-keyword">if</span> (strings <span class="hljs-keyword">instanceof</span> List&lt;String&gt;) &#123;&#125;<br></code></pre></td></tr></table></figure><h3 id="2-泛型类"><a href="#2-泛型类" class="headerlink" title="2. 泛型类"></a>2. 泛型类</h3><p>泛型类的声明和非泛型类的声明类似，除了在类名后面添加了类型参数声明部分。泛型类的类型参数声明部分可以包含一个或多个类型参数，参数间用逗号隔开。</p><p>一个泛型参数，也被称为一个类型变量，是用于指定一个泛型类型名称的标识符。因为他们接受一个或多个参数，这些类被称为参数化的类或参数化的类型。</p><p>通过泛型可以完成对一组类的操作对外开放相同的接口。最典型的就是各种容器类，如：List、Set、Map。</p><p><strong>语法：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> 类名称 &lt;泛型标识：可以是任意标识号&gt;</span>&#123;<br>    <span class="hljs-keyword">private</span> 泛型标识 <span class="hljs-comment">/*（成员变量类型）*/</span> <span class="hljs-keyword">var</span>;<br>    .....<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">//key这个成员变量的类型为T,T的类型由外部指定</span><br>    <span class="hljs-keyword">private</span> T key;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Generic</span><span class="hljs-params">(T key)</span> </span>&#123; <span class="hljs-comment">// 构造方法形参类型也为T，由外部指定</span><br>        <span class="hljs-keyword">this</span>.key = key;<br>    &#125;<br>&#125;<br><br><span class="hljs-comment">//传入的实参类型需与泛型的类型参数类型相同，即为 Integer.</span><br>Generic&lt;Integer&gt; genericInteger = <span class="hljs-keyword">new</span> Generic&lt;Integer&gt;(<span class="hljs-number">123456</span>);<br></code></pre></td></tr></table></figure><h3 id="3-泛型接口"><a href="#3-泛型接口" class="headerlink" title="3. 泛型接口"></a>3. 泛型接口</h3><p>泛型类型用于接口的定义中，被称为泛型接口。</p><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 定义泛型接口</span><br><span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>&#125;<br><span class="hljs-comment">// 实现接口一</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">CarGenerator</span> <span class="hljs-keyword">implements</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> String <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;car&quot;</span>;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// 实现接口二</span><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">FruitGenerator</span>&lt;<span class="hljs-title">T</span>&gt; <span class="hljs-keyword">implements</span> <span class="hljs-title">Generator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br><br>    <span class="hljs-keyword">private</span> T next;<br><br><span class="hljs-comment">// 非泛型方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">FruitGenerator</span><span class="hljs-params">(T next)</span> </span>&#123;<br>        <span class="hljs-keyword">this</span>.next = next;<br>    &#125;<br><br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> T <span class="hljs-title">next</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> next;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>        FruitGenerator&lt;String&gt; fruit = <span class="hljs-keyword">new</span> FruitGenerator&lt;String&gt;(<span class="hljs-string">&quot;Fruit&quot;</span>);<br>        System.out.println(fruit.next);<br>        <span class="hljs-comment">// Fruit</span><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-泛型方法"><a href="#4-泛型方法" class="headerlink" title="4. 泛型方法"></a>4. 泛型方法</h3><p>泛型方法：是在调用方法的时候指明泛型的具体类型。</p><blockquote><p>泛型类：是在实例化类的时候指明泛型的具体类型。</p></blockquote><h4 id="4-1-泛型方法的基本用法"><a href="#4-1-泛型方法的基本用法" class="headerlink" title="4.1 泛型方法的基本用法"></a>4.1 泛型方法的基本用法</h4><p>泛型方法的定义规则：</p><ul><li>所有泛型方法声明在方法返回类型之前都有类型参数声明部分（由尖括号分隔）</li><li>每一个类型参数声明部分包含一个或多个类型参数，参数间用逗号隔开。</li><li>类型参数能被用来声明返回值类型，并且能作为泛型方法得到的实际参数类型的占位符。</li></ul><blockquote><p>java 中泛型标记符：</p><ul><li>E - Element (在集合中使用，因为集合中存放的是元素)</li><li>T - Type（Java 类）</li><li>K - Key（键）</li><li>V - Value（值）</li><li>N - Number（数值类型）</li><li>？ - 表示不确定的 java 类型</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 泛型方法 printArray</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;E&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printArray</span><span class="hljs-params">(E[] inputArray)</span></span>&#123;<br>    <span class="hljs-comment">// 输出数组元素</span><br>    Arrays.stream(inputArray).forEach(System.out::println);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String args[])</span></span>&#123;<br>    <span class="hljs-comment">// 创建不同的数组</span><br>    Integer[] intArray = &#123; <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span> &#125;;<br>    Double[] doubleArray = &#123; <span class="hljs-number">1.1</span>, <span class="hljs-number">2.2</span>, <span class="hljs-number">3.3</span>, <span class="hljs-number">4.4</span> &#125;;<br>    Character[] charArray = &#123; <span class="hljs-string">&#x27;H&#x27;</span>, <span class="hljs-string">&#x27;E&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;L&#x27;</span>, <span class="hljs-string">&#x27;O&#x27;</span> &#125;;<br><br>    System.out.println(<span class="hljs-string">&quot;整型数组元素为：&quot;</span>);<br>    printArray(intArray);<br><br>    System.out.println(<span class="hljs-string">&quot;双精度型数组元素为：&quot;</span>);<br>    printArray(doubleArray);<br><br>    System.out.println(<span class="hljs-string">&quot;字符型数组元素为：&quot;</span>);<br>    printArray(charArray);<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-泛型方法与可变参数"><a href="#4-2-泛型方法与可变参数" class="headerlink" title="4.2 泛型方法与可变参数"></a>4.2 泛型方法与可变参数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">   <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">printMsg</span><span class="hljs-params">(T... args)</span></span>&#123;<br>       Arrays.stream(args).forEach(System.out::println);<br>   &#125;<br><br>printMsg(<span class="hljs-string">&quot;111&quot;</span>,<span class="hljs-number">111</span>,<span class="hljs-number">123.23</span>,<span class="hljs-string">&#x27;a&#x27;</span>,<span class="hljs-number">123L</span>);<br></code></pre></td></tr></table></figure><h4 id="4-3-静态方法与泛型"><a href="#4-3-静态方法与泛型" class="headerlink" title="4.3 静态方法与泛型"></a>4.3 静态方法与泛型</h4><p>静态方法无法访问类上定义的泛型，如果静态方法操作的引用数据类型不确定时，必须将泛型定义在方法上。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">StaticGenerator</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 编译错误：cannot be referenced from a static context</span><br>    <span class="hljs-comment">// public static void Show(T t) &#123;&#125;</span><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt; <span class="hljs-function"><span class="hljs-keyword">void</span> <span class="hljs-title">Show</span><span class="hljs-params">(T t)</span> </span>&#123;<br><br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-泛型通配符"><a href="#5-泛型通配符" class="headerlink" title="5.  泛型通配符"></a>5.  泛型通配符</h3><h4 id="5-1-用-代替具体的类型参数"><a href="#5-1-用-代替具体的类型参数" class="headerlink" title="5.1 用 ? 代替具体的类型参数"></a>5.1 用 ? 代替具体的类型参数</h4><p>此处’？’是类型实参，而不是类型形参。也就是说此处的？和 Number、String、Integer一样都是一种实际的类型，可以把？看成所有类型的父类。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span></span>&#123;<br>    List&lt;String&gt; name = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>    List&lt;Integer&gt; age = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>    List&lt;Number&gt; number = <span class="hljs-keyword">new</span> ArrayList&lt;Number&gt;();<br><br>    name.add(<span class="hljs-string">&quot;zth&quot;</span>);<br>    age.add(<span class="hljs-number">18</span>);<br>    number.add(<span class="hljs-number">13</span>);<br>    getData(name);<br>    getData(age);<br>    getData(number);<br>&#125;<br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getData</span><span class="hljs-params">(List&lt;?&gt; data)</span></span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;data: &quot;</span>+data.get(<span class="hljs-number">0</span>));<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="5-2-泛型的上边界"><a href="#5-2-泛型的上边界" class="headerlink" title="5.2 泛型的上边界"></a>5.2 泛型的上边界</h4><p>通过形如  List &lt; ? extends Number&gt;  来定义，如此定义就是通配符泛型值接受Number及其下层子类类型。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; age = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Number&gt; number = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Double&gt; doubles = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    printNumber(age);<br>    printNumber(number);<br>    printNumber(doubles);<br>&#125;<br><br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printNumber</span><span class="hljs-params">(List&lt;? extends Number&gt; data)</span> </span>&#123;<br>    data.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>Ingeter 是 Number 的一个子类，但是 Generic<Integer>  不能被看作为 Generic<Number>  的子类。由此可以看出：同一种泛型可以对应多个版本（因为参数类型是不确定的），不同版本的泛型类实例是不兼容的。</p></blockquote><h4 id="5-3-泛型的下边界"><a href="#5-3-泛型的下边界" class="headerlink" title="5.3 泛型的下边界"></a>5.3 泛型的下边界</h4><p>通过形如 List&lt; ? super Number&gt; 来定义，表示类型只能接受 Number 及其三层父类类型，如Objec类型的实例。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Number&gt; number = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>    List&lt;Object&gt; objects = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br><br>    printNumber(number);<br>    printNumber(objects);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printNumber</span><span class="hljs-params">(List&lt; ? <span class="hljs-keyword">super</span> Number&gt; data)</span> </span>&#123;<br>    data.forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>注：不能在上限泛型集合中添加元素，可以在下限泛型集合中添加元素</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">      List&lt; ? <span class="hljs-keyword">super</span> Integer&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      <span class="hljs-comment">// 可以在下限泛型集合中添加元素</span><br>      list.add(<span class="hljs-number">111</span>);<br>      <span class="hljs-comment">//报错： add (capture&lt; ? super java.lang.Integer&gt;) in List cannot be applied  to (java.lang.Object)</span><br>      list.add(<span class="hljs-keyword">new</span> Object());<br><br><span class="hljs-comment">// 不能在上限泛型集合中添加元素</span><br>      List&lt; ? extends Number&gt; data = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>      <span class="hljs-comment">// 报错：add  (capture&lt; ? extends java.lang.Number&gt;) in List cannot be applied to (java.lang.Integer)</span><br>      data.add(<span class="hljs-keyword">new</span> Integer(<span class="hljs-number">111</span>));<br></code></pre></td></tr></table></figure><p>在日常中，只要记住 “ PECS(Producer Extends Consumer Super)原则” 即可。意思为：<br>（1）频繁往外读取内容的，适合用上界Extends。<br>（2）经常往里插入的，适合用下界Super。</p><p>参考：<a href="https://www.zhihu.com/question/20400700">https://www.zhihu.com/question/20400700</a></p><h3 id="6-泛型的生命周期"><a href="#6-泛型的生命周期" class="headerlink" title="6. 泛型的生命周期"></a>6. 泛型的生命周期</h3><p>Java的泛型信息只存在于编译期间，编译之后所有的泛型信息都会被擦除。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integerList = <span class="hljs-keyword">new</span> ArrayList&lt;Integer&gt;();<br>List&lt;String&gt; stringList = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>System.out.println(integerList.getClass() == stringList.getClass());<br><span class="hljs-comment">// true</span><br></code></pre></td></tr></table></figure><p>不管是 ArrayList&lt; Integer &gt; 还是 ArrayList&lt; Long &gt;，在编译时都会被编译器擦除成了 ArrayList。</p><p>Java引入泛型是为了加强参数类型的安全性，在编译期间根据泛型声明及早发现类型转化问题，减少了类型的转换。因为在 JDK1.5 之前是没有泛型的，需要考虑向下兼容，所以对于泛型只存在于编译期间。编译成字节码后，ArrayList&lt; Integer &gt; 或 ArrayList&lt; Long &gt; 都会被擦除成 ArrayList，这样就能保持和 JDK1.5 之前版本兼容。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">ArrayList&lt;String&gt; list = <span class="hljs-keyword">new</span> ArrayList&lt;String&gt;();<br>list.add(<span class="hljs-string">&quot;hello&quot;</span>);<br>Class listClass = list.getClass();<br>Method methodList = listClass.getMethod(<span class="hljs-string">&quot;add&quot;</span>, Object.class);<br>methodList.invoke(list, <span class="hljs-keyword">new</span> Integer(<span class="hljs-number">10</span>));<br><span class="hljs-keyword">for</span> (Object obj : list) &#123;<br>    System.out.println(<span class="hljs-string">&quot;obj = &quot;</span> + obj +<span class="hljs-string">&quot;, class = &quot;</span> + obj.getClass().getName());<br>&#125;<br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * obj = hello, class = java.lang.String</span><br><span class="hljs-comment"> * obj = 10, class = java.lang.Integer</span><br><span class="hljs-comment"> */</span><br></code></pre></td></tr></table></figure><p><strong>在运行期间获取泛型信息</strong></p><p>虽然泛型类在编译的时候会进行泛型擦除，不过泛型信息还是会保存在泛型类的字节码对象中。</p><blockquote><p>获取到泛型类型的要求：</p><ul><li>必须具有真实类型的存在。</li><li>泛型的类型是明确的（如List<User>是明确的，List<T>是不明确的）。</li></ul></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">T</span>&gt; </span>&#123;<br>    <span class="hljs-comment">// 为了方便其他类获取，将其作为公有属性</span><br>    Class&lt;?&gt; clazz;<br><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-title">Generic</span><span class="hljs-params">()</span> </span>&#123;<br>        ParameterizedType pt = (ParameterizedType)<br>                <span class="hljs-keyword">this</span>.getClass().getGenericSuperclass();<br>        <span class="hljs-comment">// 获取泛型参数列表，如Map&lt;K,V&gt;，那么返回K，V的数组</span><br>        Type[] types = pt.getActualTypeArguments();<br>        <span class="hljs-comment">//因为这里只有一个泛型T，所以获取第一个元素</span><br>        clazz = (Class&lt;?&gt;) types[<span class="hljs-number">0</span>];<br>    &#125;<br>&#125;<br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">MyGeneric</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>&#125;<br><br><br><span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">Generic1</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">Generic</span>&lt;<span class="hljs-title">String</span>&gt; </span>&#123;<br>&#125;<br>System.out.println(<span class="hljs-keyword">new</span> Generic1().clazz);<br><span class="hljs-comment">// class java.lang.String</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——java9新特性</title>
    <link href="/2021/12/06/Java%E2%80%94%E2%80%94java9%E6%96%B0%E7%89%B9%E6%80%A7/"/>
    <url>/2021/12/06/Java%E2%80%94%E2%80%94java9%E6%96%B0%E7%89%B9%E6%80%A7/</url>
    
    <content type="html"><![CDATA[<p><strong>java9 新特性：</strong></p><ul><li>目录结构</li><li>模块化系统</li><li>jshell</li><li>接口的私有方法</li><li>改进 try-with-resourcs </li><li>改进钻石操作符 </li><li>限制使用单独下划线标识符</li><li> String 存储结构变更</li><li> 快速创建只读集合</li><li> 增强 Stream API</li><li> 改进 Optional 类</li><li> 多分辨率图像 API</li><li> 全新 HTTP 客户端 API</li><li> 智能 JAVA 编译工具</li><li> 统一 JVM 日志系统</li><li> javadoc 的 HTML5 支持</li><li> java 动态编译</li></ul><h4 id="1-目录结构"><a href="#1-目录结构" class="headerlink" title="1.目录结构"></a>1.目录结构</h4><p>JDK9具体目录结构：</p><ul><li>bin： 该目录包含所有的命令。</li><li>conf： 包含用户可以编辑的配置文件，例如以前位于 jre\lib 目录中的 .properties 和 .policy 文件。 </li><li>include： 包含一些编译本地代码时使用的 C/C++头文件。</li><li>jmods： 包含JMOD 格式的平台模块，创建自定义运行映射时需要它。 </li><li>legal： 包含法律声明。 </li><li>lib： 包含非 Windows 平台上动态链接的本地库，其子目录和文件不应由开发人员直 接编辑或使用。</li></ul><blockquote><p>JDK8 目录结构：</p><ul><li>bin： 该目录存放了 JDK 的各种工具命令，即 jdk 工具的可执行二进制文件，包括编译器，调试器等，例如：java，javac</li><li>db： 该目录是安装 Java DB 的路径。Java 自带数据库 Derby。</li><li>include： 包含一些编译本地代码时使用的 C/C++头文件。</li><li>jre： 该目录包含的是 jre 环境(Java runtime environment 即 Java 运行时环境)。</li><li>lib：该目录存放的是 java 工具命令实际执行的程序包。</li></ul></blockquote><p> <strong>注：JDK9 目录中不再有 jre 子目录。</strong></p><h4 id="2-模块化系统"><a href="#2-模块化系统" class="headerlink" title="2. 模块化系统"></a>2. 模块化系统</h4><p>JDK9 将 JDK 分成一组模块，可以在编译时，运行时或构建时进行组合。模块化可以减少内存开销；只需必要的模块，并非全部模块，可以简化各种类库和大型应用的开发和维护，八个仓库： root、corba、hotspot、jaxp、jaxws、jdk、langtools 和 nashorn </p><blockquote><p>module-info.java：该文件必须位于项目的根目录中。该文件用于定义模块需要什么依赖，以及哪些包被外部使用。<br>exports：控制哪些包可以被其他模块访问，所有不被 exports 的包默认都被封装在模块里面不 被外界所使用。<br>requires：指明对其他模块的依赖。 </p></blockquote><p><strong>示例:</strong></p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211212225847.png"></p><p>有两个模块 jdk9 和 jdk9module1，在 jdk9 中引用 jdk9module1 的内容。</p><p>jdk9  module-info 内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> jdk9 &#123;<br>    <span class="hljs-keyword">requires</span> jdk9module1;<br>    <span class="hljs-keyword">requires</span> jdk.incubator.httpclient;<br>&#125;<br></code></pre></td></tr></table></figure><p>jdk9module1  module-info 内容：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">module</span> jdk9module1 &#123;<br>    <span class="hljs-keyword">exports</span> com.zth.bean;<br>    <span class="hljs-comment">//exports com.zth.common;</span><br>&#125;<br></code></pre></td></tr></table></figure><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211212230559.png"><br>可以看到如果没有引用 common 包，将如法使用 Util 类。</p><h4 id="3-JShell"><a href="#3-JShell" class="headerlink" title="3. JShell"></a>3. JShell</h4><p>JDK9 新增了 REPL（Read-Eval-Print Loop）工具 jshell，jshell 工具提供了一个交互式命令界面， 可以评估声明、语句和表达式，无需编译即可返回执行结果。</p><blockquote><ol><li> /list   　　　　    //列出所有的代码 </li><li> /methods 　　   //查看所有的方法 </li><li> /var          　　   //所有的变量 </li><li>/edit          　　  //打开编辑器 </li><li>/open path 　　//执行路径上的代码 如 /open C:\Users\wukong\Desktop\App.java </li></ol></blockquote><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211212231645.png"></p><h4 id="4-接口私有化方法"><a href="#4-接口私有化方法" class="headerlink" title="4. 接口私有化方法"></a>4. 接口私有化方法</h4><p>jdk1.8 之前接口定义中只有抽象方法（public abstract）和常量（public static final），从 jdk8 开始，接口可以加入静态方法和默认方法，JDK9 可以在接口中使用私有方法。</p><p>作用：在一个接口中，有可能在多个默认方法上存在重复的通用代码，但通用代码又不想被子类发现，所以引入了私有方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInterface</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">default</span> String <span class="hljs-title">getName</span><span class="hljs-params">()</span> </span>&#123;<br>        log(<span class="hljs-string">&quot;getName&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;猫和少年&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> String <span class="hljs-title">getSlogan</span><span class="hljs-params">()</span> </span>&#123;<br>        log(<span class="hljs-string">&quot;getSlogan&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;才疏学浅，少年登科；满腹经纶，白发不第&quot;</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 接口的私有化方法</span><br>    <span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title">log</span><span class="hljs-params">(String method)</span></span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;TestInterface.&quot;</span>+method+<span class="hljs-string">&quot;()被调用&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-改进-try-with-resource"><a href="#5-改进-try-with-resource" class="headerlink" title="5. 改进 try-with-resource"></a>5. 改进 try-with-resource</h3><p>JDK 8中新增了 try-with-resources 语句，可以自动关闭需要关闭的资源文件。但是必须在 try 语句后的括号中初始化需要关闭的资源。在JDK9中改进了 try-with-resources 语句，可以在 try 外初始化资源，然后在 try 后的括号中添加需要自动关的资源即可。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jdk7</span><span class="hljs-params">()</span></span>&#123;<br>    FileInputStream fileInputStream = <span class="hljs-keyword">null</span>;<br>    <span class="hljs-keyword">try</span>&#123;<br>        fileInputStream = <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;/home/a.txt&quot;</span>);<br>        <span class="hljs-keyword">byte</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        fileInputStream.read(temp);<br>        System.out.println(<span class="hljs-keyword">new</span> String(temp));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125; <span class="hljs-keyword">finally</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != fileInputStream)&#123;<br>            <span class="hljs-keyword">try</span> &#123;<br>                fileInputStream.close();<br>            &#125; <span class="hljs-keyword">catch</span> (IOException e) &#123;<br>                e.printStackTrace();<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jdk8</span><span class="hljs-params">()</span></span>&#123;<br>    <span class="hljs-keyword">try</span>(FileInputStream fileInputStream =  <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;/home/a.txt&quot;</span>))&#123;<br><br>        <span class="hljs-keyword">byte</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> read = fileInputStream.read(temp);<br>        System.out.println(<span class="hljs-keyword">new</span> String(temp));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title">jdk9</span><span class="hljs-params">()</span> <span class="hljs-keyword">throws</span> FileNotFoundException </span>&#123;<br>    FileInputStream fileInputStream =  <span class="hljs-keyword">new</span> FileInputStream(<span class="hljs-string">&quot;/home/a.txt&quot;</span>);<br>    <span class="hljs-keyword">try</span>(fileInputStream)&#123;<br>        <span class="hljs-keyword">byte</span>[] temp = <span class="hljs-keyword">new</span> <span class="hljs-keyword">byte</span>[<span class="hljs-number">1024</span>];<br>        <span class="hljs-keyword">int</span> read = fileInputStream.read(temp);<br>        System.out.println(<span class="hljs-keyword">new</span> String(temp));<br>    &#125; <span class="hljs-keyword">catch</span> (Exception e) &#123;<br>        e.printStackTrace();<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="6-改进钻石操作符"><a href="#6-改进钻石操作符" class="headerlink" title="6. 改进钻石操作符"></a>6. 改进钻石操作符</h3><p>JDK9 中钻石操作符可以使用匿名实现类，可以在匿名实现类中重写方法等操作 。</p><p>JDK8 中：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;Integer&gt; integerComparator = <span class="hljs-keyword">new</span> Comparator&lt;Integer&gt;() &#123;<br><span class="hljs-meta">@Override</span><br><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<br><span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br>&#125;;<br><br>Set&lt;String&gt; hashSet = <span class="hljs-keyword">new</span> HashSet&lt;String&gt;() &#123;<br>&#125;;<br><br></code></pre></td></tr></table></figure><p>JDK9：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Comparator&lt;Integer&gt; integerComparator = <span class="hljs-keyword">new</span> Comparator&lt;&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">int</span> <span class="hljs-title">compare</span><span class="hljs-params">(Integer o1, Integer o2)</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>    &#125;<br>&#125;;<br><br>Set&lt;String&gt; hashSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;() &#123;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="7-限制使用单独下划线标识符"><a href="#7-限制使用单独下划线标识符" class="headerlink" title="7. 限制使用单独下划线标识符"></a>7. 限制使用单独下划线标识符</h3><p>在 JDK8 之前可以使用单独的下划线（ _ ）作为标识符，但在 JDK9 中限制使用单独的下划线作为标识符。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211226115041.png"></p><h3 id="8-String-存储结构变更"><a href="#8-String-存储结构变更" class="headerlink" title="8. String 存储结构变更"></a>8. String 存储结构变更</h3><p>String 类在 JDK8 以及之前将字符存储在 char 数组中，每个字符使用两个字节（十六位）。 从许多不同的应用程序收集的数据表明，字符串是堆使用的主要组成部分，而且大多数 String 对象仅包含 Latin-1 字符。 此类字符仅需要一个字节的存储空间，也就是 String 对象的内部字符数组中有一半空间未使用。<br>JDK 8 String 结构：<br><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211226122939.png"></p><p>JDK9 将 String 的内部表示从 UTF-16 字符数组更改为字节数组加上编码标志字段。 将根据字符串的内容存储编码为 ISO-8859-1/Latin-1（每个字符一个字节）或 UTF-16（每个字符两个字节）的字符。 编码标志将指示使用哪种编码。<br>JDK 9 String 结构：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211226123032.png"></p><blockquote><p>内码 :某种语言运行时，其 char 和 string 在内存中的编码方式。<br>  外码 :除了内码，皆是外码。<br>要注意的是，源代码编译产生的目标代码文件（可执行文件或class文件）中的编码方式属于外码。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    printString(<span class="hljs-string">&quot;abc&quot;</span>);<br>    printString(<span class="hljs-string">&quot;中文&quot;</span>);<br>    printString(<span class="hljs-string">&quot;abc中文&quot;</span>);<br>&#125;<br><br><span class="hljs-function"><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printString</span><span class="hljs-params">(String str)</span> </span>&#123;<br>    System.out.println(<span class="hljs-string">&quot;======&gt;&quot;</span> + str);<br>    <span class="hljs-comment">// return the UTF-16 char[] size</span><br>    System.out.println(<span class="hljs-string">&quot;length: &quot;</span> + str.length());<br>    <span class="hljs-comment">// Use default Encoding (UTF-8)</span><br>    System.out.println(<span class="hljs-string">&quot;getBytes: &quot;</span> + str.getBytes().length);<br>    <span class="hljs-comment">// Convert UTF-16 char[] to char</span><br>    System.out.println(<span class="hljs-string">&quot;codePointCount: &quot;</span> + str.codePointCount(<span class="hljs-number">0</span>, str.length()));<br>    <span class="hljs-comment">// Get the UTF-16 char[]</span><br>    System.out.println(<span class="hljs-string">&quot;toCharArray: &quot;</span> + str.toCharArray().length);<br>&#125;<br></code></pre></td></tr></table></figure><p>执行结果：</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211226210914.png"></p><p><a href="https://blog.csdn.net/loveshunyi/article/details/90680487">java 编码详解与原理</a></p><h3 id="9-快速创建只读集合"><a href="#9-快速创建只读集合" class="headerlink" title="9. 快速创建只读集合"></a>9. 快速创建只读集合</h3><p>JDK9 在 List、Set 和 Map 集合中新增 of 静态方法，快速创建只读集合。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br><br>    Map&lt;String, String&gt; map = Map.of(<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;aaa&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;bbb&quot;</span>);<br><br>    List&lt;String&gt; names = List.of(<span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;王五&quot;</span>);<br>    names.forEach(System.out::println);<br>    names.remove(<span class="hljs-string">&quot;张三&quot;</span>); <span class="hljs-comment">// 抛出 UnsupportedOperationException</span><br>&#125;<br></code></pre></td></tr></table></figure><h3 id="10-增强-Stream-API"><a href="#10-增强-Stream-API" class="headerlink" title="10. 增强 Stream API"></a>10. 增强 Stream API</h3><p>JDK9 在 Stream 接口中新增4个方法：dropWhile、takeWhile、ofNullable、iterate方法新增重载方法</p><ol><li> default Stream<T> takeWhile(Predicate&lt; ? super T&gt; predicate)</li></ol><blockquote><p>有序的集合：从 Stream 中获取一部分数据, 返回从头开始的尽可能多的元素, 直到遇到第一个 false 结果，如果第一个值不满足断言条件，将返回一个空的 Stream。</p><p>无序的集合：如果这个流是无序的，那么这个操作的结果是<strong>不确定</strong>的。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Stream&lt;String&gt; nameStream = Stream.of(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王麻子&quot;</span>, <span class="hljs-string">&quot;赵六&quot;</span>);<br>    nameStream.takeWhile(item -&gt; item.length() == <span class="hljs-number">2</span>).forEach(System.out::println);<br>    <span class="hljs-comment">// 张三  李四</span><br><br>    System.out.println(<span class="hljs-string">&quot;=========&quot;</span>);<br><br>    Set&lt;String&gt; names = Set.of(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王麻子&quot;</span>, <span class="hljs-string">&quot;赵六&quot;</span>);<br>    names.stream().takeWhile(item -&gt; item.length() == <span class="hljs-number">2</span>).forEach(System.out::println);<br>    <span class="hljs-comment">// 第一次执行结果： 李四</span><br>    <span class="hljs-comment">// 第二次执行结果： 张三</span><br>    <span class="hljs-comment">// 第三次执行结果： 赵六  李四</span><br>    <span class="hljs-comment">// ......</span><br><br>&#125;<br><br></code></pre></td></tr></table></figure><ol start="2"><li>default Stream<T> dropWhile(Predicate&lt; ? super T&gt; predicate)<blockquote><p>与 takeWhile 相反，返回剩余的元素，和 takeWhile 方法形成互补<br>有序的集合：从头开始删除元素，直到第一个值不满足断言条件，返回剩余元素。<br>无序的集合：如果这个流是无序的，那么这个操作的结果是<strong>不确定</strong>的。</p></blockquote></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    Stream&lt;String&gt; nameStream = Stream.of(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王麻子&quot;</span>, <span class="hljs-string">&quot;赵六&quot;</span>);<br>    nameStream.dropWhile(item -&gt; item.length() == <span class="hljs-number">2</span>).forEach(System.out::println);<br>    <span class="hljs-comment">// 王麻子  赵六</span><br><br>    System.out.println(<span class="hljs-string">&quot;=========&quot;</span>);<br><br>    Set&lt;String&gt; names = Set.of(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王麻子&quot;</span>, <span class="hljs-string">&quot;赵六&quot;</span>);<br>    names.stream().dropWhile(item -&gt; item.length() == <span class="hljs-number">2</span>).forEach(System.out::println);<br>    <span class="hljs-comment">// 第一次执行结果： 王麻子  赵六</span><br>    <span class="hljs-comment">// 第二次执行结果： 王麻子  赵六  李四</span><br>    <span class="hljs-comment">// ......</span><br>&#125;<br></code></pre></td></tr></table></figure><ol start="3"><li>public static<T> Stream<T> ofNullable(T t)<blockquote><p>如果非空，则返回一个包含单个元素的连续流，否则返回空流。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Object&gt; nulStream = Stream.ofNullable(<span class="hljs-keyword">null</span>);<br>System.out.println(nulStream.count());<br><span class="hljs-comment">// 0</span><br></code></pre></td></tr></table></figure></li></ol><h3 id="11-改进-Optional-类"><a href="#11-改进-Optional-类" class="headerlink" title="11. 改进 Optional 类"></a>11. 改进 Optional 类</h3><p>Optional 类是在 JDK8 中新增的类，主要是为了解决空指针异常。在 JDK9 中对这个类进行了改进，主要是新增了三个方法：stream、ifPresentOrElse 和 or</p><blockquote><p>ifPresentOrElse：如果有值，则使用该值执行给定的操作，否则执行给定的基于空的操作。<br>or：如果有值，则返回描述该值的 Optional，否则返回由提供函数生成的 Optional。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;String&gt; list = List.of(<span class="hljs-string">&quot;张三&quot;</span>, <span class="hljs-string">&quot;李四&quot;</span>, <span class="hljs-string">&quot;王麻子&quot;</span>, <span class="hljs-string">&quot;赵六&quot;</span>);<br>    Optional&lt;List&lt;String&gt;&gt; optional = Optional.ofNullable(list);<br>    optional.stream().forEach(System.out::println);<br>    <span class="hljs-comment">// [张三, 李四, 王麻子, 赵六]</span><br><br>    Optional&lt;String&gt; name = Optional.ofNullable(<span class="hljs-keyword">null</span>);<br>    name.ifPresentOrElse(item -&gt; System.out.println(<span class="hljs-string">&quot;name: &quot;</span> + item), () -&gt; System.out.println(<span class="hljs-string">&quot;Not Present.&quot;</span>));<br>    <span class="hljs-comment">// Not Present.</span><br><br>    name = name.or(() -&gt; Optional.of(<span class="hljs-string">&quot;Not Present&quot;</span>));<br>    System.out.println(name.get());<br>    <span class="hljs-comment">// Not Present</span><br>&#125;<br></code></pre></td></tr></table></figure><p>Optional 类是在JDK8中新增的类，主要是为了解决空指针异常。在JDK9中对这个类进行了改 进，主要是新增了三个方法：stream，ifPresentOrElse 和 or 1 List<String> list = new ArrayList&lt;&gt;(); 2 list.add(“人参”); 3 list.add(“当归”); 4 list.add(“鹿茸”); 5 list.add(“黄柏”); 6 Optional&lt;List<String>&gt; optional = Optional.ofNullable(list); 7 optional.stream().forEach(System.out::println); 8910 Optional<String> optional1 = Optional.of(“Mahesh”); 11 optional1.ifPresentOrElse( x ‐&gt; System.out.println(“Value: “ + x),() ‐&gt; 12 System.out.println(“Not Present.”)); 13 Supplier&lt;Optional<String>&gt; supplierString = () ‐&gt; Optional.of(“Not Prese nt”); 14 optional1 = optional1.or( supplierString); </p><h3 id="12-多分辨率图像API"><a href="#12-多分辨率图像API" class="headerlink" title="12. 多分辨率图像API"></a>12. 多分辨率图像API</h3><p>在 java.awt.image 包下新增了支持多分辨率图片的API，用于支持多分辨率的图片。 </p><ol><li>将不同分辨率的图像封装到一张（多分辨率的）图像中，作为它的变体。</li><li>获取这个图像的所有变体。</li><li>获取特定分辨率的图像变体，表示一张已知分辨率单位为 DPI 的特定尺寸大小的逻辑图像，并且这张图像是最佳的变体。</li><li>java.awt.image.MultiResolutionImage 接口的基础实现 java.awt.image.BaseMultiResolutionImage 获取所需要的变体。</li><li>通过接口的 getResolutionVariant（double destImageWidth, double destImageHeight）方法，根据分辨率获取图像。</li></ol><h3 id="13-全新的-HTTP-客户端-API"><a href="#13-全新的-HTTP-客户端-API" class="headerlink" title="13. 全新的 HTTP 客户端 API"></a>13. 全新的 HTTP 客户端 API</h3><p>HTTP，用于传输网页的协议，早在 1997 年就被采用在目前的 1.1 版本中。直到 2015 年， HTTP2 才成为标准。</p><p><img src="https://debugging.oss-cn-hangzhou.aliyuncs.com/20211227000024.png"></p><p>Http2和Http1.X的区别</p><ol><li>HTTP2 使用的是二进制传输，HTTP1.X 是文本（字符串）传输。</li><li>HTTP2 支持多路复用</li><li>HTTP2 头部压缩</li><li>HTTP2 支持服务器推送</li></ol><p>HTTP/1.1 和 HTTP/2 的主要区别是如何在客户端和服务器之间构建和传输数据。HTTP/1.1 依赖于请求/响应周期。 HTTP/2 允许服务器“push”数据：它可以发送比客户端请求更多的数据。 这使得它可以优先处理并发送对于首先加载网页至关重要的数据</p><p><a href="https://www.jianshu.com/p/63fe1bf5d445">http2 和http1.1 区别详细分析</a></p><p>JDK9 中有新的方式来处理 HTTP 调用。它提供了一个新的 HTTP客户端(HttpClient)，它将替代仅适用于 blocking 模式的 HttpURLConnection（HttpURLConnection 是在HTTP 1.0 时代创建的， 并使用了协议无关的方法)，并提供对 WebSocket 和 HTTP/2 的支持。<br>此外，HTTP客户端还提供 API 来处理 HTTP/2 的特性，比如流和服务器推送等功能。 </p><p>全新的 HTTP 客户端 API 可以从 jdk.incubator.httpclient 模块中获取。因为在默认情况下，这个模块是不能根据 classpath 获取的，需要使用 add modules 命令选项配置这个模块，将这个模块添加到  classpath 中。（requires jdk.incubator.httpclient;）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> <span class="hljs-keyword">throws</span> IOException, InterruptedException, URISyntaxException </span>&#123;<br>    <span class="hljs-comment">//创建 builder</span><br>    HttpClient.Builder builder = HttpClient.newBuilder();<br>    <span class="hljs-comment">//链式调用</span><br>    HttpClient client = builder<br>            <span class="hljs-comment">//http 协议版本 1.1 或者 2</span><br>            .version(HttpClient.Version.HTTP_2) <span class="hljs-comment">//.version(HttpClient.Version.HTTP_1_1)</span><br>            <span class="hljs-comment">//连接完成之后的转发策略</span><br>            .followRedirects(HttpClient.Redirect.NEVER). <span class="hljs-comment">//followRedirects(HttpClient.Redirect.ALWAYS)</span><br>            <span class="hljs-comment">// 指定线程池</span><br>                    executor(Executors.newFixedThreadPool(<span class="hljs-number">5</span>))<br><br>            <span class="hljs-comment">//认证，默认情况下 Authenticator.getDefault() 是 null 值，会报错</span><br>            <span class="hljs-comment">//.authenticator(Authenticator.getDefault())</span><br><br>            <span class="hljs-comment">//代理地址</span><br>            <span class="hljs-comment">//.proxy(ProxySelector.of(new InetSocketAddress(&quot;http://www.baidu.com&quot;, 8080)))</span><br><br>            .cookieManager(<span class="hljs-keyword">new</span> CookieManager())<br>            <span class="hljs-comment">//创建完成</span><br>            .build();<br><br>    <span class="hljs-comment">//组装 request</span><br><br>    URI baiduUri = <span class="hljs-keyword">new</span> URI(<span class="hljs-string">&quot;https://www.baidu.com&quot;</span>);<br>    HttpRequest request = HttpRequest.newBuilder(baiduUri)<br>            .version(HttpClient.Version.HTTP_2)<br>            .build();<br>    <span class="hljs-comment">//发起调用</span><br>    HttpResponse&lt;String&gt; r = client.send(request, HttpResponse.BodyHandler.asString());<br>    System.out.println(r.body());<br><br>&#125;<br></code></pre></td></tr></table></figure><p><a href="https://blog.csdn.net/u014042066/article/details/78153653">Java9之HttpClientAPI实战详解</a></p><h3 id="14-智能-JAVA-编译工具"><a href="#14-智能-JAVA-编译工具" class="headerlink" title="14. 智能 JAVA 编译工具"></a>14. 智能 JAVA 编译工具</h3><p>智能 java 编译工具（sjavac）的第一个阶段始于 JEP139 这个项目，用于在多核处理器情况下提升 JDK 的编译速度。如今，这个项目已经进入第二阶段，即 JEP199，其目的是改进 Java 编译工 具，并取代目前 JDK 编译工具 javac，继而成为 Java 环境默认的通用的智能编译工具。<br>JDK 9 还更新了 javac 编译器以便能够将 java 9 代码编译运行在低版本 Java 中。</p><h3 id="15-统一的JVM日志系统"><a href="#15-统一的JVM日志系统" class="headerlink" title="15. 统一的JVM日志系统"></a>15. 统一的JVM日志系统</h3><p>日志是解决问题的唯一有效途径：曾经很难知道导致 JVM 性能问题和导致 JVM 崩溃的根本原因。不同的 JVM 日志的碎片化和日志选项（例如：JVM 组件对于日志使用的是不同的机制和规则），这使得 JVM 难以进行调试。<br>解决该问题最佳方法：对所有的 JVM 组件引入一个单一的系统，这些 JVM 组件支持细粒度的和易配置的 JVM 日志。</p><h3 id="16-javadoc-的-HTML5-支持"><a href="#16-javadoc-的-HTML5-支持" class="headerlink" title="16. javadoc 的 HTML5 支持"></a>16. javadoc 的 HTML5 支持</h3><p>JDK8 生成的 java 帮助文档是在 HTML4 中。而 HTML4 已经是很久的标准了。 JDK9 的 javadoc，现支持HTML5 标准，具有搜索功能。</p><h3 id="18-java-动态编译器"><a href="#18-java-动态编译器" class="headerlink" title="18. java 动态编译器"></a>18. java 动态编译器</h3><p>JIT（Just-in-time）编译器可以在运行时将热点编译成本地代码，速度很快。但是 Java 项目现在变得很大很复杂，因此 JIT 编译器需要花费较长时间才能热身完，而且有些 Java 方法还没法编译，性能方面也会下降。AoT 编译就是为了解决这些问题而生的。</p><p>在 JDK 9 中， AOT（JEP 295: Ahead-of-Time Compilation）作为实验特性被引入进来，开发者可以利用新的 jaotc 工具将重点代码转换成类似类库一样的文件。虽然仍处于试验阶段，但这个功能使得 Java 应用在被虚拟机启动之前能够先将 Java 类编译为原生代码。此功能旨在改进小型和大型应用程序的启动时间，同时对峰值性能的影响很小。<br>但是 Java 技术供应商 Excelsior 的营销总监 Dmitry Leskov 担心 AoT 编译技术不够成熟，希望 Oracle 能够等到 Java10 时有个更稳定版本才发布。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java9新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——java8新特性之Optional</title>
    <link href="/2021/12/03/Java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BOptional/"/>
    <url>/2021/12/03/Java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BOptional/</url>
    
    <content type="html"><![CDATA[<h3 id="1-Optional-介绍"><a href="#1-Optional-介绍" class="headerlink" title="1. Optional 介绍"></a>1. Optional 介绍</h3><p>Optional<T> 是在 java.util 包下的一个用于代替 null 的一个工具类</p><p><strong>仅仅是解决 NPE(NullPointerException) 问题吗？</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">List&lt;Order&gt;  <span class="hljs-title">getOrders</span><span class="hljs-params">(User user)</span></span>&#123;<br>    Optional&lt;User&gt; u = Optional.ofNullable(user);<br>    <span class="hljs-keyword">if</span> (u.isPresent())&#123;<br>        <span class="hljs-keyword">return</span> u.get().getOrders();<br>    &#125;<br>    <span class="hljs-keyword">return</span> Collections.emptyList();<br>&#125;<br><br><span class="hljs-function">List&lt;Order&gt;  <span class="hljs-title">getOrders2</span><span class="hljs-params">(User user)</span></span>&#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != user)&#123;<br>        <span class="hljs-keyword">return</span> user.getOrders();<br>    &#125;<br>    <span class="hljs-keyword">return</span> Collections.emptyList();<br>&#125;<br></code></pre></td></tr></table></figure><p>第一种方法虽然使用了 Optional ，但是本质上没有区别，如何优雅的使用 Optional？    </p><p><strong>Optional 错误使用姿势</strong></p><ol><li>调用 isPresent() 方法</li><li>调用 get() 方法</li><li>Optional 类型作为类/实例属性</li><li>Optional 类型作为方法参数 </li></ol><blockquote><p>解释：</p><ul><li>使用 isPresent() 和使用 obj != null 无任何分别</li><li>直接调用 get() 方法虽然不抛出 NPE 了，但如果没有值是会抛出 NoSuchElementException。</li></ul></blockquote><p>Optional 中可以依赖的是除了 isPresent() 和 get() 的其他方法：</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">public<U> Optional<U> map(Function&lt;? super T, ? extends U&gt; mapper)</td><td align="center">如果值存在，就对该值执行提供的 mapping 函数的调用</td></tr><tr><td align="center">public T orElse(T other)</td><td align="center">如果有值则将其返回，否则返回默认值</td></tr><tr><td align="center">public T orElseGet(Supplier&lt;? extends T&gt; other)</td><td align="center">如果有值则将其返回，否则返回一个 Supplier 接口生成的值</td></tr><tr><td align="center">public void ifPresent(Consumer&lt;? super T&gt; consumer)</td><td align="center">如果值存在，就通过 consumer 消费次值，否则什么也不做</td></tr><tr><td align="center">public Optional<T> filter(Predicate&lt;? super T&gt; predicate)</td><td align="center">如果值存在并且满足提供的谓词，就返回包含该值的 Optional 对象</td></tr><tr><td align="center">public<U> Optional<U> flatMap(Function&lt;? super T, Optional<U>&gt; mapper)</td><td align="center">如果值存在，就对该值执行提供的 mapping 函数调用</td></tr><tr><td align="center">public <X extends Throwable> T orElseThrow(Supplier&lt;? extends X&gt; exceptionSupplier) throws X</td><td align="center">如果有值则将其返回，否则抛出一个由指定的 Supplier 接口生成的异常</td></tr></tbody></table><h3 id="2-Optional-构造方式"><a href="#2-Optional-构造方式" class="headerlink" title="2. Optional 构造方式"></a>2. Optional 构造方式</h3><ul><li>Optional.of(obj)：要求传入的 obj 不能为 null，否则还抛出 NullPointerException 异常</li><li>Optional.empty()：value 为 null 的 Optional</li><li>Optional.ofNullable(obj)：如果 obj  为 null 返回 Optional.empty()，否则返回 Optional.of(obj)</li></ul><blockquote><p>Optional.of(obj) 的作用</p><ol><li>当非常明确将要传给 Optional.of(obj) 的 obj 参数不可能为 null 时, 比如刚 new 出来的对象(Optional.of(new User(…))), 或者是一个非 null 常量时;</li><li>当想为 obj 断言不为 null 时, 即想在万一 obj 为 null 立即报告 NullPointException 异常, 立即修改, 而不是隐藏空指针异常</li></ol></blockquote><h3 id="3-Optional-使用"><a href="#3-Optional-使用" class="headerlink" title="3. Optional 使用"></a>3. Optional 使用</h3><h4 id="3-1-获取值"><a href="#3-1-获取值" class="headerlink" title="3.1 获取值"></a>3.1 获取值</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 存在即返回，否则提供默认值</span><br><span class="hljs-keyword">return</span> user.orElse(UNKNOWUSER);<br><span class="hljs-comment">// 而不是 return user.isPresent() ? user.get() : null ;</span><br><br><br><span class="hljs-comment">// 存在即返回，否则函数生成</span><br><span class="hljs-keyword">return</span> user.orElseGet(<span class="hljs-keyword">this</span>::getDefaultUser);<br><br><span class="hljs-comment">// 存在即返回，否则抛出异常</span><br><span class="hljs-keyword">return</span> user.orElseThrow(NullPointerException::<span class="hljs-keyword">new</span>);<br><br><br><span class="hljs-comment">// 存在才执行操作</span><br>user.ifPresent(System.out::print);<br><span class="hljs-comment">// 而不是</span><br><span class="hljs-keyword">if</span> (user.isPresent())&#123;<br>    System.out.println(user.get());<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-2-map-函数"><a href="#3-2-map-函数" class="headerlink" title="3.2 map 函数"></a>3.2 map 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 当 user.isPresent() 为真, 获得 用户名，否则返回 null</span><br>String name = user.map(User::getName).orElse(<span class="hljs-string">&quot;UNKNOW&quot;</span>);<br><br><span class="hljs-comment">// java8 之前</span><br>String name2 = <span class="hljs-string">&quot;&quot;</span>;<br><span class="hljs-keyword">if</span> (user.isPresent())&#123;<br>    name2 = user.get().getName();<br>&#125;<span class="hljs-keyword">else</span> &#123;<br>    name2 = <span class="hljs-string">&quot;UNKNOW&quot;</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="3-3-filter-函数"><a href="#3-3-filter-函数" class="headerlink" title="3.3 filter 函数"></a>3.3 filter 函数</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java">Optional&lt;String&gt; name = Optional.of(<span class="hljs-string">&quot;debugging&quot;</span>);<br>Optional&lt;String&gt; longName = name.filter(i -&gt; i.length() &gt; <span class="hljs-number">6</span>);<br>System.out.println(longName.orElse(<span class="hljs-string">&quot;The name is less than 6 characters&quot;</span>));<br><span class="hljs-comment">// debugging</span><br><br>Optional&lt;String&gt; name2 = Optional.of(<span class="hljs-string">&quot;admin&quot;</span>);<br>Optional&lt;String&gt; longName2 = name2.filter(i -&gt; i.length() &gt; <span class="hljs-number">6</span>);<br>System.out.println(longName2.orElse(<span class="hljs-string">&quot;The name is less than 6 characters&quot;</span>));<br><span class="hljs-comment">// The name is less than 6 characters</span><br><br><br>Optional&lt;String&gt; name3 = Optional.empty();<br>Optional&lt;String&gt; longName3 = name3.filter(i -&gt; i.length() &gt; <span class="hljs-number">6</span>);<br>System.out.println(longName3.orElse(<span class="hljs-string">&quot;The name is less than 6 characters&quot;</span>));<br><span class="hljs-comment">// The name is less than 6 characters</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——java8新特性之Stream</title>
    <link href="/2021/12/01/java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/"/>
    <url>/2021/12/01/java%E2%80%94%E2%80%94java8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BStream/</url>
    
    <content type="html"><![CDATA[<h3 id="1-定义"><a href="#1-定义" class="headerlink" title="1. 定义"></a>1. 定义</h3><p><strong>A sequence of elements supporting sequential and parallel aggregate operations .</strong></p><ol><li>Stream 是元素的集合，这点让 Stream 看起来用些类似 Iterator；</li><li>可以支持顺序和并行的对原Stream进行汇聚的操作；</li></ol><blockquote><p>Java 8 中的 Stream 是对集合（Collection）对象功能的增强，它专注于对集合对象进行各种非常便利、高效的聚合操作（aggregate operation），或者大批量数据操作 (bulkdata operation)。</p></blockquote><p>Stream API 借助于 Lambda 表达式，极大的提高编程效率和程序可读性。同时提供串行和并行两种模式进行汇聚操作，并发模式能够充分利用多核处理器的优势（使用 fork/join框架，fork 递归式地分解问题，然后每段并行执行，最终由 join 合并结果，返回最后的值）。</p><p>[例] 统计列表中不为 null 的元素个数。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; nums = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">3</span>, <span class="hljs-number">5</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">6</span>);<br><br><span class="hljs-comment">//原始版本</span><br><span class="hljs-keyword">int</span> count = <span class="hljs-number">0</span>;<br><span class="hljs-keyword">for</span> (Integer item : nums) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">null</span> != item) &#123;<br>        count++;<br>    &#125;<br>&#125;<br><span class="hljs-comment">// Stream 版本</span><br><span class="hljs-keyword">long</span> count1 = nums.stream().filter(Objects::nonNull).count();<br></code></pre></td></tr></table></figure><h3 id="2-语法"><a href="#2-语法" class="headerlink" title="2. 语法"></a>2. 语法</h3><p><img src="https://user-images.githubusercontent.com/45761474/144250337-a744591a-f7ef-4877-8876-c01a7ede3661.jpg" alt="Stream表达式"></p><p>一条语句分为三部分：</p><ol><li>红色框中的语句是一个 Stream 的生命开始的地方，负责创建一个Stream实例；</li><li>绿色框中的语句是赋予 Stream 灵魂的地方，把一个 Stream 转换成另外一个 Stream；</li><li>蓝色框中的语句是汇聚的地方，把 Stream 里面包含的内容按照某种算法来汇聚成一个值。</li></ol><blockquote><p>使用Stream的基本步骤：</p><ol><li>创建Stream；</li><li>转换Stream，每次转换原有Stream对象不改变，返回一个新的Stream对象（可以有多次转换）；</li><li>对Stream进行聚合（Reduce）操作，获取想要的结果</li></ol></blockquote><h3 id="3-创建-Stream"><a href="#3-创建-Stream" class="headerlink" title="3. 创建 Stream"></a>3. 创建 Stream</h3><p>常见创建 Stream 的方式有三种：</p><ul><li>通过 Stream 接口的静态工厂方法</li><li>通过 Collection 接口的默认方法 stream() 把一个 Collection 对象转换为 Stream</li><li>通过数组，Arrays.stream(T array)</li></ul><ol><li><p>of 方法：有两个 overload 方法，一个接受变长参数，一个接口单一值；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream&lt;Integer&gt; integerStream = Stream.of(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>);<br>Stream&lt;String&gt; stringStream = Stream.of(<span class="hljs-string">&quot;abc&quot;</span>);<br></code></pre></td></tr></table></figure></li><li><p>generator 方法<br>生成一个无限长度的 Stream ，其元素生成时通过给定的 Supplier 接口提供</p></li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">Stream.generate(<span class="hljs-keyword">new</span> Supplier&lt;Double&gt;() &#123;<br>    <span class="hljs-meta">@Override</span><br>    <span class="hljs-function"><span class="hljs-keyword">public</span> Double <span class="hljs-title">get</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">return</span> Math.random();<br>    &#125;<br>&#125;);<br>Stream.generate(()-&gt;Math.random());<br><br>Stream.generate(Math::random);<br></code></pre></td></tr></table></figure><p>生成一个无限长度的Stream，其中值是随机的。这个无限长度Stream是懒加载。</p><ol start="3"><li>iterate 方法：</li></ol><p>也是生成无限长度的 Stream，和 generator 不同的是，其元素的生成是重复对给定的种子值(seed)调用用户指定函数来生成的。其中包含的元素可以认为是：seed，f(seed),f(f(seed))无限循环。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 先获取一个无限长度的正整数集合的Stream，然后取出前10个打印。</span><br>      Stream.iterate(<span class="hljs-number">1</span>, item -&gt; item * <span class="hljs-number">2</span>).limit(<span class="hljs-number">10</span>).forEach(System.out::println);<br></code></pre></td></tr></table></figure><ol start="4"><li>通过 Collection 子类获取 Stream<br>Collection接口有一个stream方法，所以其所有子类都都可以获取对应的Stream对象。<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integerList = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">3</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>);<br>integerList.stream();<br>Set&lt;Integer&gt; integerSet = <span class="hljs-keyword">new</span> HashSet&lt;&gt;();<br>integerSet.stream();<br>Map&lt;String, String&gt; stringMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>stringMap.entrySet().stream();<br>stringMap.keySet().stream();<br>stringMap.values().stream();<br></code></pre></td></tr></table></figure></li><li>Arrays.stream(T array)</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.stream(<span class="hljs-keyword">new</span> <span class="hljs-keyword">int</span>[]&#123;<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>&#125;);<br></code></pre></td></tr></table></figure><h3 id="4-转换Stream"><a href="#4-转换Stream" class="headerlink" title="4. 转换Stream"></a>4. 转换Stream</h3><p>转换Stream就是把一个 Stream 通过某些行为转换成一个新的 Stream。</p><p>Stream 接口中几个常用的转换方法:</p><ul><li>disinct</li><li>filter</li><li>map</li><li>flatmap</li><li>peek</li><li>limit</li><li>skip</li></ul><h4 id="4-1-distinct"><a href="#4-1-distinct" class="headerlink" title="4.1 distinct"></a>4.1 distinct</h4><p>对于 Stream 中包含的元素进行去重操作(依赖于元素的 equals 方法)，新生成的Stream 中没有重复的元素。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>    list.stream().distinct().forEach(item -&gt; System.out.print(item+ <span class="hljs-string">&quot;  &quot;</span>));<br>    <span class="hljs-comment">// 1  null  2  3  4  5  6  7  8  9 </span><br>&#125;<br></code></pre></td></tr></table></figure><h4 id="4-2-filter"><a href="#4-2-filter" class="headerlink" title="4.2 filter"></a>4.2 filter</h4><p>对于 Stream 中包含的元素使用给定的过滤函数进行过滤，新生成的 Stream 只包含符合条件的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>list.stream().distinct().filter(Objects::nonNull).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br><span class="hljs-comment">// 1  2  3  4  5  6  7  8  9  </span><br></code></pre></td></tr></table></figure><h4 id="4-3-map"><a href="#4-3-map" class="headerlink" title="4.3 map"></a>4.3 map</h4><p>对于 Stream 中包含的元素使用给定的转换函数进行转换操作，新生成的 Stream 只包含转换生成的元素。这个方法有三个对于原始类型的变种方法，分别是：mapToInt，mapToLong 和 mapToDouble。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; list = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>list.stream().distinct().filter(Objects::nonNull).map(i -&gt; i * <span class="hljs-number">2</span>).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br><span class="hljs-comment">// 2  4  6  8  10  12  14  16  18 </span><br><br>DoubleStream stream = DoubleStream.of(<span class="hljs-number">23.0</span>, <span class="hljs-number">25.4</span>, <span class="hljs-number">32.5</span>, <span class="hljs-number">45.9</span>);<br>stream.mapToInt(item -&gt; (<span class="hljs-keyword">int</span>) item).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br><span class="hljs-comment">// 23  25  32  45          </span><br></code></pre></td></tr></table></figure><h4 id="4-4-flatMap"><a href="#4-4-flatMap" class="headerlink" title="4.4 flatMap"></a>4.4 flatMap</h4><p>和map类似，不同的是其每个元素转换得到的是Stream对象，会把子Stream中的元素压缩到父集合中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;String&gt; teamIndia = Arrays.asList(<span class="hljs-string">&quot;Virat&quot;</span>, <span class="hljs-string">&quot;Dhoni&quot;</span>, <span class="hljs-string">&quot;Jadeja&quot;</span>);<br>List&lt;String&gt; teamAustralia = Arrays.asList(<span class="hljs-string">&quot;Warner&quot;</span>, <span class="hljs-string">&quot;Watson&quot;</span>, <span class="hljs-string">&quot;Smith&quot;</span>);<br>List&lt;List&lt;String&gt;&gt; players = <span class="hljs-keyword">new</span> ArrayList&lt;&gt;();<br>players.add(teamIndia);<br>players.add(teamAustralia);<br>players.stream().flatMap(Collection::stream).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;  &quot;</span>));<br></code></pre></td></tr></table></figure><h4 id="4-5-peek"><a href="#4-5-peek" class="headerlink" title="4.5. peek"></a>4.5. peek</h4><p>生成一个包含原 Stream 的所有元素的新 Stream，同时会提供一个消费函数（Consumer实例），新 Stream 每个元素被消费的时候都会执行给定的消费函数；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>System.out.println(<span class="hljs-string">&quot;\n&quot;</span>+integers.stream().peek(System.out::print).count());<br><span class="hljs-comment">//16789</span><br><span class="hljs-comment">//5</span><br></code></pre></td></tr></table></figure><h4 id="4-6-limit"><a href="#4-6-limit" class="headerlink" title="4.6 limit"></a>4.6 limit</h4><p>对一个 Stream 进行截断操作，获取其前N个元素，如果原 Stream 中包含的元素个数小于N，则获取其所有的元素</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>integers.stream().limit(<span class="hljs-number">3</span>).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;   &quot;</span>));<br><span class="hljs-comment">// 1   6   7</span><br></code></pre></td></tr></table></figure><h4 id="4-7-skip"><a href="#4-7-skip" class="headerlink" title="4.7 skip"></a>4.7 skip</h4><p>返回一个丢弃原 Stream 的前 N 个元素后剩下元素组成的新 Stream，如果原Stream中包含的元素个数小于N，那么返回空 Stream</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>integers.stream().skip(<span class="hljs-number">2</span>).forEach(item -&gt; System.out.print(item + <span class="hljs-string">&quot;   &quot;</span>));<br><span class="hljs-comment">// 7   8   9  </span><br></code></pre></td></tr></table></figure><p>  <strong>转换操作都是 lazy 的，多个转换操作只会在汇聚操作的时候融合起来，一次循环完成。可以这样简单的理解，Stream 里有个操作函数的集合，每次转换操作就是把转换函数放入这个集合中，在汇聚操作的时候循环 Stream 对应的集合，然后对每个元素执行所有的函数。</strong></p><h3 id="5-汇聚（reduce）Stream"><a href="#5-汇聚（reduce）Stream" class="headerlink" title="5. 汇聚（reduce）Stream"></a>5. 汇聚（reduce）Stream</h3><p>Reduce 操作接受一个元素序列为输入，反复使用某个合并操作，把序列中的元素合并成一个汇总的结果。</p><p>比如查找一个数字列表的总和或者最大值，或者把这些数字累积成一个List对象。</p><p>Stream接口通用的汇聚操作</p><ul><li>reduce()</li><li>collect()</li><li>count() </li><li>sum()</li><li>allMatch：判断是否是全部的元素都满足给定匹配条件</li><li>noneMatch：判断是否是全部的元素都不满足给定匹配条件</li><li>anyMatch：判断是否至少有一个元素满足给定匹配条件</li><li>findFirst：返回第一个元素</li><li>max()：使用比较器（Operator），返回 Stream 中最大的元素</li></ul><p>注意：sum 方法不是所有的 Stream 对象都有的，只有 IntStream、LongStream 和 DoubleStream是实例才有。</p><h4 id="5-1-collect"><a href="#5-1-collect" class="headerlink" title="5.1  collect"></a>5.1  collect</h4><p>把输入的元素累积到一个可变的容器中，比如 Collection 或者 StringBuilder。<br>可变汇聚对应的方法只有一个：collect，它的作用就是把Stream中的所有元素收集到一个结果容器中。</p><p><strong>方法定义1：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R&gt; <span class="hljs-function">R <span class="hljs-title">collect</span><span class="hljs-params">(Supplier&lt;R&gt; supplier,</span></span><br><span class="hljs-params"><span class="hljs-function">              BiConsumer&lt;R, ? <span class="hljs-keyword">super</span> T&gt; accumulator,</span></span><br><span class="hljs-params"><span class="hljs-function">              BiConsumer&lt;R, R&gt; combiner)</span></span><br></code></pre></td></tr></table></figure><p>方法参数：</p><ul><li>Supplier<R> supplier：工厂函数，用来生成一个新的容器。</li><li>BiConsumer&lt;R, ? super T&gt; accumulator：用来把 Stream 中的元素添加到结果容器</li><li>BiConsumer&lt;R, R&gt; combiner：用来把中间状态的多个结果容器合并成一个（并发时）</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>ArrayList&lt;Integer&gt; collect = integers.stream().filter(Objects::nonNull)<br>        .collect(ArrayList::<span class="hljs-keyword">new</span>, ArrayList::add, ArrayList::addAll);<br>System.out.println(collect.toString());<br><span class="hljs-comment">// [1, 6, 7, 8, 9]</span><br></code></pre></td></tr></table></figure><p><strong>方法定义2：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;R, A&gt; <span class="hljs-function">R <span class="hljs-title">collect</span><span class="hljs-params">(Collector&lt;? <span class="hljs-keyword">super</span> T, A, R&gt; collector)</span></span>;<br></code></pre></td></tr></table></figure><p>Collectors 已经定义了一些静态工厂方法：</p><ul><li>Collectors.toCollection() 收集到 Collection 中</li><li>Collectors.toList() 收集到 List 中</li><li>Collectors.toSet() 收集到 Set 中</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>List&lt;Integer&gt; collect = integers.stream().filter(Objects::nonNull)<br>        .collect(Collectors.toList());<br>System.out.println(collect.toString());<br><span class="hljs-comment">// [1, 6, 7, 8, 9]</span><br></code></pre></td></tr></table></figure><h4 id="5-2-reduce"><a href="#5-2-reduce" class="headerlink" title="5.2 reduce"></a>5.2 reduce</h4><p><strong>方法定义1</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">Optional&lt;T&gt; <span class="hljs-title">reduce</span><span class="hljs-params">(BinaryOperator&lt;T&gt; accumulator)</span></span>;<br></code></pre></td></tr></table></figure><p>接受一个 BinaryOperator 类型的参数，BinaryOperator 函数有两个参数</p><ul><li>第一个参数是上次函数执行的返回值（中间结果）</li><li>第二个参数是 Stream 中的元素</li></ul><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>Integer integer = integers.stream().filter(Objects::nonNull).<br>        reduce((sum, item) -&gt; sum + item).get();<br>System.out.println(integer);<br><span class="hljs-comment">// 31</span><br></code></pre></td></tr></table></figure><p><strong>方法定义2</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function">T <span class="hljs-title">reduce</span><span class="hljs-params">(T identity, BinaryOperator&lt;T&gt; accumulator)</span></span>;<br></code></pre></td></tr></table></figure><p>和上面的类似，不同的是允许提供一个初始值，如果 Stream 为空，则直接返回初始值。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>Integer integer = integers.stream().filter(Objects::nonNull).<br>        reduce(<span class="hljs-number">100</span>,(sum, item) -&gt; sum + item);<br>System.out.println(integer);<br><span class="hljs-comment">// 131</span><br></code></pre></td></tr></table></figure><p><strong>方法定义3</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">&lt;U&gt; <span class="hljs-function">U <span class="hljs-title">reduce</span><span class="hljs-params">(U identity,</span></span><br><span class="hljs-params"><span class="hljs-function">             BiFunction&lt;U, ? <span class="hljs-keyword">super</span> T, U&gt; accumulator,</span></span><br><span class="hljs-params"><span class="hljs-function">             BinaryOperator&lt;U&gt; combiner)</span></span>;<br></code></pre></td></tr></table></figure><p>功能和上面的类似，不同的是允许用户提供一个 combiner 函数用来处理并发场景下的数据汇总。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>Integer integer = integers.parallelStream().filter(Objects::nonNull).<br>        reduce(<span class="hljs-number">0</span>, (sum, item) -&gt; sum + item, (result, fragment) -&gt; result + fragment);<br>System.out.println(integer);<br><span class="hljs-comment">// 31</span><br></code></pre></td></tr></table></figure><h4 id="5-3-count-方法"><a href="#5-3-count-方法" class="headerlink" title="5.3 count 方法"></a>5.3 count 方法</h4><p>统计 Stream 中的元素的个数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">7</span>, <span class="hljs-keyword">null</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><span class="hljs-keyword">long</span> count = integers.parallelStream().filter(Objects::nonNull).count();<br>System.out.println(count);<br><span class="hljs-comment">// 5</span><br></code></pre></td></tr></table></figure><h3 id="6-Collectors"><a href="#6-Collectors" class="headerlink" title="6. Collectors"></a>6. Collectors</h3><p>Collector接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Collector</span>&lt;<span class="hljs-title">T</span>, <span class="hljs-title">A</span>, <span class="hljs-title">R</span>&gt; </span>&#123;<br> <span class="hljs-comment">// 用于生成和返回一个结果容器</span><br>    <span class="hljs-function">Supplier&lt;A&gt; <span class="hljs-title">supplier</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-comment">// 将元素 T 归纳到容器A</span><br>    <span class="hljs-function">BiConsumer&lt;A, T&gt; <span class="hljs-title">accumulator</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-comment">// 将两个结果合并并返回</span><br>    <span class="hljs-function">BinaryOperator&lt;A&gt; <span class="hljs-title">combiner</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-comment">// 将中间结果R 转换为A</span><br>    <span class="hljs-function">Function&lt;A, R&gt; <span class="hljs-title">finisher</span><span class="hljs-params">()</span></span>;<br><br> <span class="hljs-comment">// characteristics 表示当前 collector的特征值，返回 Collector 特征值的 Set</span><br>    <span class="hljs-function">Set&lt;Characteristics&gt; <span class="hljs-title">characteristics</span><span class="hljs-params">()</span></span>;<br><br>&#125;<br><br></code></pre></td></tr></table></figure><p>Collectors 是一个工具类，是 JDK 预实现 Collector 的工具类，它内部提供了多种 Collector。</p><p>Collectors 除了提供了上文介绍过的收集方法外还提供了一组非常有用方法。</p><h4 id="6-1-joining"><a href="#6-1-joining" class="headerlink" title="6.1 joining"></a>6.1 joining</h4><p>连接收集的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>String value = integers.stream().map(String::valueOf).collect(Collectors.joining());<br><span class="hljs-comment">// 16789</span><br><br><span class="hljs-comment">// 指定间隔符</span><br>String value1 = integers.stream().map(String::valueOf).collect(Collectors.joining(<span class="hljs-string">&quot;-&quot;</span>));<br><span class="hljs-comment">// 1-6-7-8-9</span><br><br><br><span class="hljs-comment">// 指定间隔符、前缀、后缀</span><br>String value2 = integers.stream().map(String::valueOf).collect(Collectors.joining(<span class="hljs-string">&quot;-&quot;</span>,<span class="hljs-string">&quot;$&quot;</span>,<span class="hljs-string">&quot;#&quot;</span>));<br><span class="hljs-comment">// $1-6-7-8-9#</span><br></code></pre></td></tr></table></figure><h4 id="6-2-collectingAndThen"><a href="#6-2-collectingAndThen" class="headerlink" title="6.2 collectingAndThen"></a>6.2 collectingAndThen</h4><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span>&lt;T,A,R,RR&gt; Collector&lt;T,A,RR&gt; <span class="hljs-title">collectingAndThen</span><span class="hljs-params">(Collector&lt;T,A,R&gt; downstream,</span></span><br><span class="hljs-params"><span class="hljs-function">                                                            Function&lt;R,RR&gt; finisher)</span></span><br></code></pre></td></tr></table></figure><p>通过第二个参数 Function 函数对汇聚后的结果进行再操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 收集后逆序排序</span><br>      List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>      List&lt;String&gt; collect = integers.stream().map(String::valueOf).<br>              collect(Collectors.collectingAndThen(Collectors.toList(), Lists::reverse));<br>      <span class="hljs-comment">// [9, 8, 7, 6, 1]</span><br></code></pre></td></tr></table></figure><h4 id="6-3-groupingBy"><a href="#6-3-groupingBy" class="headerlink" title="6.3 groupingBy"></a>6.3 groupingBy</h4><p>用于生成一个拥有分组功能的 Collector，它也有三个重载方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 只需一个分组参数 classifier，内部自动将结果保存到一个 map 中</span><br><span class="hljs-comment">// 每个 map 的键为 ？ 类型（即 classifier 的结果类型），值为 list（保存这个组中的元素）</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K&gt; Collector&lt;T, ?, Map&lt;K, List&lt;T&gt;&gt;&gt;<br>    groupingBy(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; classifier)<br><br><span class="hljs-comment">// 在上面方法的基础上增加了对流元素的处理方式的Collector，比如上面的默认处理方法是 Collectors.toList()</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K, A, D&gt;<br>    Collector&lt;T, ?, Map&lt;K, D&gt;&gt; groupingBy(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; classifier,<br>                                          Collector&lt;? <span class="hljs-keyword">super</span> T, A, D&gt; downstream)<br><br><span class="hljs-comment">// 在第二个方法的基础上增加了结果 Map 的生成方式</span><br><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, K, D, A, M extends Map&lt;K, D&gt;&gt;<br>    Collector&lt;T, ?, M&gt; groupingBy(Function&lt;? <span class="hljs-keyword">super</span> T, ? extends K&gt; classifier,<br>                                  Supplier&lt;M&gt; mapFactory,<br>                                  Collector&lt;? <span class="hljs-keyword">super</span> T, A, D&gt; downstream)<br><br></code></pre></td></tr></table></figure><p><strong>示例：</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br>Map&lt;Integer, List&lt;Integer&gt;&gt; collect = integers.stream().collect(Collectors.groupingBy(item -&gt; item % <span class="hljs-number">3</span>));<br><span class="hljs-comment">// &#123;0=[3, 6, 9], 1=[1, 4, 7], 2=[2, 5, 8]&#125;</span><br><br>Map&lt;Integer, Set&lt;Integer&gt;&gt; collect1 = integers.stream().collect(Collectors.groupingBy(item -&gt; item % <span class="hljs-number">3</span>, Collectors.toSet()));<br><span class="hljs-comment">// &#123;0=[3, 6, 9], 1=[1, 4, 7], 2=[2, 5, 8]&#125;</span><br><br><br>Map&lt;Integer, Set&lt;Integer&gt;&gt; collect2 = integers.stream()<br>        .collect(Collectors.groupingBy(item -&gt; item % <span class="hljs-number">3</span>,HashMap::<span class="hljs-keyword">new</span>, Collectors.toSet()));<br><span class="hljs-comment">// &#123;0=[3, 6, 9], 1=[1, 4, 7], 2=[2, 5, 8]&#125;</span><br></code></pre></td></tr></table></figure><h4 id="6-4-partitioningBy"><a href="#6-4-partitioningBy" class="headerlink" title="6.4 partitioningBy"></a>6.4 partitioningBy</h4><p>将流中的元素按照给定的校验规则分为两部分，放到一个 map 中返回，map 的键是 boolean 类型，值为元素的列表 list。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 只需要一个校验参数 predicate</span><br>   <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T&gt;<br>   Collector&lt;T, ?, Map&lt;Boolean, List&lt;T&gt;&gt;&gt; partitioningBy(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate)<br><span class="hljs-comment">// 在上面的基础上增加了对流中元素的处理方式的 Collector，默认 Collector.toList()</span><br> <span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> &lt;T, D, A&gt;<br>   Collector&lt;T, ?, Map&lt;Boolean, D&gt;&gt; partitioningBy(Predicate&lt;? <span class="hljs-keyword">super</span> T&gt; predicate,<br>                                                   Collector&lt;? <span class="hljs-keyword">super</span> T, A, D&gt; downstream)<br><br></code></pre></td></tr></table></figure><p>示例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><br><span class="hljs-comment">// 对序列进行奇偶分区</span><br>Map&lt;Boolean, List&lt;Integer&gt;&gt; collect = integers.stream().collect(Collectors.partitioningBy(item -&gt; item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>));<br><span class="hljs-comment">// &#123;false=[1, 1, 3, 5, 7, 9], true=[2, 4, 6, 8]&#125;</span><br><br>Map&lt;Boolean, Set&lt;Integer&gt;&gt; collect1 = integers.stream().<br>        collect(Collectors.partitioningBy(item -&gt; item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>, Collectors.toSet()));<br><span class="hljs-comment">// &#123;false=[1, 3, 5, 7, 9], true=[2, 4, 6, 8]&#125;</span><br></code></pre></td></tr></table></figure><h4 id="6-4-reducing"><a href="#6-4-reducing" class="headerlink" title="6.4 reducing"></a>6.4 reducing</h4><p><strong>方法定义</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 无初始值，返回一个可以生成 Optional 结果的  Collector</span><br>&lt;T&gt; Collector&lt;T, ?, T&gt;   reducing(T identity, BinaryOperator&lt;T&gt; op)<br><br><span class="hljs-comment">// 有初始值，返回一个可以直接生成结果的  Collector</span><br>&lt;T&gt; Collector&lt;T, ?, T&gt;  reducing(T identity, BinaryOperator&lt;T&gt; op)<br><br><span class="hljs-comment">// 有初始值，元素在执行操作之前先执行 mapper 进行元素转换</span><br> &lt;T, U&gt; Collector&lt;T, ?, U&gt; reducing(U identity,<br>                                Function&lt;? <span class="hljs-keyword">super</span> T, ? extends U&gt; mapper,<br>                                BinaryOperator&lt;U&gt; op)<br></code></pre></td></tr></table></figure><p><strong>示例</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><br>Optional&lt;Integer&gt; integerOptional = integers.stream().collect(Collectors.reducing(Integer::sum));<br><span class="hljs-comment">// 等价于 integers.stream().reduce(Integer::sum);</span><br>System.out.println(integerOptional.get());<br><span class="hljs-comment">// 46</span><br><br>Integer collect = integers.stream().collect(Collectors.reducing(<span class="hljs-number">10</span>, Integer::sum));<br><span class="hljs-comment">// 等价于 integers.stream().reduce(10, Integer::sum);</span><br><span class="hljs-comment">// 56</span><br><br>String s = integers.stream().collect(Collectors.reducing(<span class="hljs-string">&quot;@&quot;</span>, String::valueOf, String::concat));<br><span class="hljs-comment">// 等价于 integers.stream().map(String::valueOf).reduce(&quot;@&quot;, String::concat);</span><br><span class="hljs-comment">// @1123456789</span><br></code></pre></td></tr></table></figure><h4 id="6-5-综合应用"><a href="#6-5-综合应用" class="headerlink" title="6.5 综合应用"></a>6.5 综合应用</h4><p>将列表按奇偶分组，然后每组里面找最大值（两种实现）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java">List&lt;Integer&gt; integers = Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>);<br><br>Map&lt;Boolean, Optional&lt;Integer&gt;&gt; collect = integers.stream().collect(<br>        Collectors.partitioningBy(item -&gt; item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>,<br>                Collectors.maxBy(Comparator.comparing(Integer::valueOf))));<br><br>Map&lt;Boolean, Optional&lt;Integer&gt;&gt; collect1 = integers.stream().collect(<br>        Collectors.partitioningBy(item -&gt; item % <span class="hljs-number">2</span> == <span class="hljs-number">0</span>,<br>                Collectors.reducing(BinaryOperator.maxBy(Comparator.comparing(Integer::valueOf)))));<br><br><span class="hljs-comment">// &#123;false=Optional[9], true=Optional[8]&#125;</span><br></code></pre></td></tr></table></figure><h3 id="7-Stream-的关闭"><a href="#7-Stream-的关闭" class="headerlink" title="7 Stream 的关闭"></a>7 Stream 的关闭</h3><p>Steam 继承了 AutoCloseable 接口，在大多数场景下都是无需手动关闭的，仅在流的资源是 IO 通道（例如：Files.lines(Path ,Charset )）时需要调用 Stream.close() 方法关闭流，以保证 IO 资源的释放。也可以使用 try-with-resources 语法关闭 Stream。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——函数式编程</title>
    <link href="/2021/11/30/java%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/"/>
    <url>/2021/11/30/java%E2%80%94%E2%80%94%E5%87%BD%E6%95%B0%E5%BC%8F%E7%BC%96%E7%A8%8B/</url>
    
    <content type="html"><![CDATA[<h3 id="1-重新认识接口"><a href="#1-重新认识接口" class="headerlink" title="1. 重新认识接口"></a>1. 重新认识接口</h3><h4 id="1-1-java8之前"><a href="#1-1-java8之前" class="headerlink" title="1.1 java8之前"></a>1.1 java8之前</h4><p>接口的作用：定义该类型实例具有的功能，不关心如何进行这些工作。所以，接口定义中只有抽象方法（public abstract）和常量（public static final），并且接口中不允许定义实例变量。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInterface</span> </span>&#123;<br>    Integer age = <span class="hljs-number">18</span>;<br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="1-2-java8之后"><a href="#1-2-java8之后" class="headerlink" title="1.2 java8之后"></a>1.2 java8之后</h4><p>从JDK8开始，接口可以加入静态方法和默认方法<br>默认方法允许接口方法定义默认实现，而所有子类都继承该方法及实现</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">TestInterface</span> </span>&#123;<br>    Integer age = <span class="hljs-number">18</span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">int</span> <span class="hljs-title">getInt</span><span class="hljs-params">()</span></span>;<br><br>    <span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">printHello</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">getString</span><span class="hljs-params">()</span> </span>&#123;<br>        System.out.println(<span class="hljs-string">&quot;Hello&quot;</span>);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>默认方法的优势</strong></p><ol><li>默认方法的主要优势是提供一种拓展接口的方法，而不破坏现有代码。增加新的方法，并且能保证对使用这个接口的老版本代码的兼容性。<br>在JDK8以前，如果为一个现有接口增加一个新方法，则我们必须在所有实现类中添加该方法的实现，否则编译会出现异常。<br>如果实现类比较多或者我们没有权限修改实现类源代码，这样可能就比较麻烦。<br>默认方法则解决了这个问题，它提供了一个实现，当没有显式提供其他实现时就采用这个实现，这样新添加的方法将不会破坏现有代码。</li><li>另一个优势是该方法是可选，子类可以根据不同的需求Override默认实现。<br>例如，我们定义一个集合接口，其中有增、删、改等操作。如果实现类90%都是以数组保存数据，那么可以定义针对这些方法给出默认实现，而对于其他非数组集合或者有其他类似业务，可以选择性复写接口中默认方法。</li></ol><h3 id="2-函数式接口"><a href="#2-函数式接口" class="headerlink" title="2.函数式接口"></a>2.函数式接口</h3><p><strong>定义：</strong></p><blockquote><p>如果一个接口定义唯一一个抽象方法，那么这个接口就成为函数式接口。</p></blockquote><p>java.lang.Runnable 就是一个函数式接口，因为它只有一个抽象方法。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-meta">@FunctionalInterface</span><br><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Runnable</span> </span>&#123;<br>    <span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">abstract</span> <span class="hljs-keyword">void</span> <span class="hljs-title">run</span><span class="hljs-params">()</span></span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>默认方法不是abstract的，所以一个函数式接口里可以定义任意多的默认方法。<br>为了标明函数式接口Java8引入了一个新的注解： @FunctionalInterface</p><p><strong>函数接口特性</strong></p><ul><li>@FunctionInterface 注解只能标记在有且仅有一个抽象方法的接口上；</li><li>Java8接口中的静态方法和默认方法，都不算是抽象方法；</li><li>接口默认继承 java.lang.Object ,所以如果接口声明覆盖了Object中的方法，那么也不算抽象方法；</li><li>注解不是必须的，如果接口符合函数式接口的定义，那么不加注解也没有影响。加上则编译器可以进行检查。如果不是函数接口而加上了注解，则编译器会报错。</li></ul><h3 id="3-函数式编程"><a href="#3-函数式编程" class="headerlink" title="3.  函数式编程"></a>3.  函数式编程</h3><p>函数编程特性：</p><p><strong>a. 闭包与高阶函数</strong><br>函数编程支持函数作为第一类对象，有时称为 闭包或者 仿函数（functor）对象。实质上，闭包是起函数的作用并可以像对象一样操作的对象。高阶函数可以用另一个函数作为其输入参数，也可以返回一个函数作为其输出参数。</p><p><strong>b. 惰性计算</strong><br>在惰性计算中，表达式不是在绑定到变量时立即计算，而是在求值程序需要产生表达式的值时进行计算。延迟的计算可以编写可能潜在地生成无穷输出的函数。因为不会计算多于程序的其余部分所需要的值，所以不需要担心由无穷计算所导致的 out-of-memory 错误。</p><p><strong>c. 没有“副作用”</strong><br>所谓”副作用”（side effect），指的是函数内部与外部互动（最典型的情况，就是修改全局变量的值），产生运算以外的其他结果。函数式编程强调没有”副作用”，意味着函数要保持独立，所有功能返回一个新的值，没有其他行为，尤其是不得修改外部变量的值。</p><blockquote><p>综上所述，函数式编程可以简言之是： 使用不可变值和函数， 通过函数对一个值进行处理， 映射成另一个值。这个值在面向对象语言中可以理解为对象，另外这个值还可以作为函数的输入。</p></blockquote><p>Java8 中的函数式编程</p><ul><li>内建的函数式接口</li><li>Optional API</li><li>Lambda表达式</li><li>Stream API</li></ul><h4 id="3-1-内建的函数式接口"><a href="#3-1-内建的函数式接口" class="headerlink" title="3.1 内建的函数式接口"></a>3.1 内建的函数式接口</h4><p>Java8 API包含了很多内建的函数式接口，在老Java中常用到的比如Comparator或者Runnable接口，这些接口都增加了@FunctionalInterface注解以便能用在lambda上。</p><table><thead><tr><th align="center">name</th><th align="center">type</th><th align="center">description</th></tr></thead><tbody><tr><td align="center">Consumer(消费者)</td><td align="center">Consumer<T></td><td align="center">接收 T 对象，不返回值</td></tr><tr><td align="center">Predicate(谓词)</td><td align="center">Predicate<T></td><td align="center">接收 T 对象并返回boolean</td></tr><tr><td align="center">Function(函数)</td><td align="center">Function&lt;T,R&gt;</td><td align="center">接收 T 对象，返回 R 对象</td></tr><tr><td align="center">Supplier(提供者)</td><td align="center">Supplier<T></td><td align="center">提供T对象，不接收值</td></tr><tr><td align="center">UnaryOperator(一元运算符)</td><td align="center">UnaryOperator<T></td><td align="center">接收T对象，返回T对象</td></tr><tr><td align="center">BinaryOperator(二元操作)</td><td align="center">BinaryOperator<T></td><td align="center">接收两个T对象，返回T对象</td></tr></tbody></table><blockquote><p>以上四种为基本的函数接口，在此之上JDK又提供了若干扩展：</p><ol><li>以上前三种添加了Bi的前缀：BiConsumer,BiPredicate,BiFunction,入参变为两个；</li><li>对Function的扩展产生了UnaryOperator(一元运算符)，接收T返回T；</li><li>对BiFunction的扩展产生了BinaryOperator(二元操作)，收两个T对象，返回T对象</li><li>增加了若干具体基本类型的接口，可参见function包下具体接口说明。</li></ol></blockquote><h4 id="3-2-Optional-API"><a href="#3-2-Optional-API" class="headerlink" title="3.2 Optional API"></a>3.2 Optional API</h4><p>Java8中引入的 Optional 是一种优雅解决NPE(NullPointExcepiton)问题的方法，是通过函数式接口实现的。</p><p>Optional 提供的方法：</p><table><thead><tr><th align="center">方法</th><th align="center">描述</th></tr></thead><tbody><tr><td align="center">public<U> Optional<U> map(Function&lt;? super T, ? extends U&gt; mapper)</td><td align="center">如果当前 Optional 为 Optional.empty，则依旧返回 Optional.empty；否则返回一个新的 Optional，该 Optional 包含的是：函数 mapper 在以 value 作为输入时的输出值。</td></tr><tr><td align="center">public T orElse(T other)</td><td align="center">如果有值则将其返回，否则返回一个默认值</td></tr><tr><td align="center">public T orElseGet(Supplier&lt;? extends T&gt; other)</td><td align="center">如果有值则将其返回，否则返回一个由指定的Supplier接口生成的值</td></tr></tbody></table><p>如果当前 Optional 为 Optional.empty，则依旧返回 Optional.empty；否则返回一个新的 Optional，该 Optional 包含的是：函数 mapper 在以 value 作为输入时的输出值。</p>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>java——java8新特性之Lambda 表达式</title>
    <link href="/2021/11/28/java%E2%80%94%E2%80%94jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
    <url>/2021/11/28/java%E2%80%94%E2%80%94jdk8%E6%96%B0%E7%89%B9%E6%80%A7%E4%B9%8BLambda-%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
    
    <content type="html"><![CDATA[<h3 id="Lambda表达式"><a href="#Lambda表达式" class="headerlink" title="Lambda表达式"></a>Lambda表达式</h3><p>lambda 表达式本质上是一段匿名内部类，也可以是一段可以传递的代码</p><h4 id="1-语法"><a href="#1-语法" class="headerlink" title="1. 语法"></a>1. 语法</h4><p>完整的 Lambda 表达式由三部分组成：参数列表、箭头、声明语句；</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java"> (Type1 param1, Type2 param2, ..., TypeN paramN) ‐&gt; &#123; statment1;<br>statment2; <span class="hljs-comment">//............. return statmentM;&#125;</span><br></code></pre></td></tr></table></figure><ol><li>绝大多数情况，编译器都可以从上下文环境中推断出lambda表达式的参数类型，所以参数可以省略：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs java">(param1,param2, ..., paramN) ‐&gt; &#123; statment1; statment2; <span class="hljs-comment">//............. r</span><br>eturn statmentM;&#125;<br></code></pre></td></tr></table></figure></li><li>当lambda表达式的参数个数只有一个，可以省略小括号：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">param1 ‐&gt; &#123; statment1; statment2; <span class="hljs-comment">//............. return statmentM;&#125;</span><br></code></pre></td></tr></table></figure></li><li>当lambda表达式只包含一条语句时，可以省略大括号、return和语句结尾的分号：<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs java">param1 ‐&gt; statment<br></code></pre></td></tr></table></figure></li></ol><h4 id="2-函数接口"><a href="#2-函数接口" class="headerlink" title="2. 函数接口"></a>2. 函数接口</h4><p>函数接口是只有一个抽象方法的接口， 用作 Lambda 表达式的返回类型。<br>包路径为 java.util.function 接口类上面都有@FunctionalInterface这个注解。</p><h4 id="3-类型检查、类型推断"><a href="#3-类型检查、类型推断" class="headerlink" title="3.  类型检查、类型推断"></a>3.  类型检查、类型推断</h4><p>Java编译器根据 Lambda 表达式上下文信息就能推断出参数的正确类型。 程序依然要经过类型检查来保证运行的安全性， 但不用再显式声明类型罢了。 这就是所谓的类型推断。</p><h4 id="4-局部变量限制"><a href="#4-局部变量限制" class="headerlink" title="4.  局部变量限制"></a>4.  局部变量限制</h4><p>Lambda表达式也允许使用自由变量（不是参数，而是在外层作用域中定义的变量），就像匿名类一样。 它们被称作捕获Lambda。 Lambda可以没有限制地捕获（也就是在其主体中引用）实例变量和静态变量。但局部变量必须显式声明为final，或事实上是final。</p><p>Lambda 表达式访问外部变量：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-function"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> <span class="hljs-title">main</span><span class="hljs-params">(String[] args)</span> </span>&#123;<br>    String[] strings = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;;<br>    <span class="hljs-keyword">for</span> (Integer i : Arrays.asList(<span class="hljs-number">1</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)) &#123;<br>        Stream.of(strings).map(string -&gt; string + i).forEach(System.out::println);<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure><blockquote><p>为什么局部变量有这些限制？<br>实例变量和局部变量背后的实现有一个关键不同。实例变量都存储在堆中，而局部变量则保存在栈上。如果Lambda可以直接访问局部变量，而且Lambda是在一个线程中使用的，则使用Lambda的线程，可能会在分配该变量的线程将这个变量收回之后，去访问该变量。因此， Java在访问自由局部变量时，实际上是在访问它的副本，而不是访问原始变量。如果局部变量仅仅赋值一次那就没有什么区别了——因此就有了这个限制。</p></blockquote><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">String[] strings = &#123;<span class="hljs-string">&quot;a&quot;</span>, <span class="hljs-string">&quot;b&quot;</span>, <span class="hljs-string">&quot;c&quot;</span>&#125;;<br><br><span class="hljs-keyword">for</span> (<span class="hljs-keyword">int</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-number">4</span>; i++) &#123;<br>    Stream.of(strings).map(string -&gt; string + i).forEach(System.out::println);<br>&#125;<br></code></pre></td></tr></table></figure><p><strong>上面的代码会报编译错误，lambda 表达式引用的变量需要时final或等效final的变量。</strong></p><h4 id="5-Lambda表达式的方法和构造器引用"><a href="#5-Lambda表达式的方法和构造器引用" class="headerlink" title="5.  Lambda表达式的方法和构造器引用"></a>5.  Lambda表达式的方法和构造器引用</h4><p>方法引用的语法格式有以下三种：</p><ol><li>objectName::instanceMethod</li><li>ClassName::staticMethod</li><li>ClassName::instanceMethod</li></ol><blockquote><p>前两种等同于把lambda表达式的参数当成 instanceMethod | staticMethod 的参数来调用。<br>例如： Math::max等同于(x, y)-&gt;Math.max(x,y)</p><p>后一种等于把lambda表达式的第一个参数当成instanceMethod 的目标对象，其他参数当成该方法的参数。<br>例如： String::toLowerCase() 等同于 x-&gt;x.toLowerCase()</p></blockquote><p><em>构造器引用语法如下</em></p><p>ClassName::new</p><blockquote><p>把 lambda 表达式的参数当成 ClassName 构造器的参数。例如： BigDecimal::new 等同于 x-&gt;new BigDecimal(x)</p></blockquote>]]></content>
    
    
    <categories>
      
      <category>Java</category>
      
    </categories>
    
    
    <tags>
      
      <tag>java</tag>
      
      <tag>java8新特性</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Redis——入门</title>
    <link href="/2021/11/28/Redis%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/"/>
    <url>/2021/11/28/Redis%E2%80%94%E2%80%94%E5%85%A5%E9%97%A8/</url>
    
    <content type="html"><![CDATA[<h2 id="1-NoSQL介绍"><a href="#1-NoSQL介绍" class="headerlink" title="1.  NoSQL介绍"></a>1.  NoSQL介绍</h2><p>NoSQL （Not Only SQL）指的是非关系型的数据库，是对不同于传统的关系型数据库的数据库管理系统的统称。NoSQL用于超大规模数据的存储。Redis就属于非关系型数据库,传统的Mysql ,oracle ,sql server 等 都是关系型数据库。</p><h2 id="2-为什么需要NoSQL"><a href="#2-为什么需要NoSQL" class="headerlink" title="2. 为什么需要NoSQL"></a>2. 为什么需要NoSQL</h2><p>主要应对以下问题时，传统关系型数据库力不从心</p><p>  高并发读写<br>  海量数据的高效率存储和访问<br>  高可扩展性和高可用性</p><h2 id="3-Redis-简介"><a href="#3-Redis-简介" class="headerlink" title="3. Redis 简介"></a>3. Redis 简介</h2><p>Redis 是一个高性能的 key-value 数据库。它通常被称为数据结构服务器，因为值（value）可以是 字符串(String), 哈希(Hash), 列表(list), 集合(sets) 和 有序集合(sorted sets)等类型。</p><p>Redis 与其他 key - value 缓存产品相比有以下三个特点：<br>Redis支持数据的持久化，可以将内存中的数据保存在磁盘中，重启的时候可以再次加载进行使用。<br>Redis不仅仅支持简单的key-value类型的数据，同时还提供list，set，zset，hash等数据结构的存储。<br>Redis支持数据的备份，即master-slave模式的数据备份。<br>Redis的应用场景<br>缓存<br>任务队列<br>网站访问统计<br>数据过期处理<br>应用排行榜<br>分布式集群架构中的session分离<br>Redis 支持的五种数据类型：<br>字符串（String）<br>字符串列表（list）<br>哈希（hash）<br>字符串集合（set）<br>有序字符串集合（zset）</p>]]></content>
    
    
    <categories>
      
      <category>Redis</category>
      
    </categories>
    
    
    <tags>
      
      <tag>redis</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
